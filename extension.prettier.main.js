"use strict";
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (TQ.crypto.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto,
  rnds8Pool,
  poolPtr,
  init_rng = __esmMin(() => {
    import_crypto = Ns(require("crypto")), rnds8Pool = new Uint8Array(256), poolPtr = rnds8Pool.length;
    __name(rng, "rng");
  });
var regex_default,
  init_regex = __esmMin(() => {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  });
function validate(uuid) {
  return typeof uuid == "string" && regex_default.test(uuid);
}
var validate_default,
  init_validate = __esmMin(() => {
    init_regex();
    __name(validate, "validate");
    validate_default = validate;
  });
function stringify(arr, offset = 0) {
  let uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) throw TypeError("Stringified UUID is invalid");
  return uuid;
}
var byteToHex,
  stringify_default,
  init_stringify = __esmMin(() => {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
    __name(stringify, "stringify");
    stringify_default = stringify;
  });
function v1(options, buf, offset) {
  let i = buf && offset || 0,
    b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId,
    clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    let seedBytes = options.random || (options.rng || rng)();
    node == null && (node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]]), clockseq == null && (clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383);
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now(),
    nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1,
    dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0 && (clockseq = clockseq + 1 & 16383), (dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0 && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, msecs += 122192928e5;
  let tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = tl & 255;
  let tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255, b[i++] = tmh & 255, b[i++] = tmh >>> 24 & 15 | 16, b[i++] = tmh >>> 16 & 255, b[i++] = clockseq >>> 8 | 128, b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) b[i + n] = node[n];
  return buf || stringify_default(b);
}
var _nodeId,
  _clockseq,
  _lastMSecs,
  _lastNSecs,
  v1_default,
  init_v1 = __esmMin(() => {
    init_rng();
    init_stringify();
    _lastMSecs = 0, _lastNSecs = 0;
    __name(v1, "v1");
    v1_default = v1;
  });
function parse(uuid) {
  if (!validate_default(uuid)) throw TypeError("Invalid UUID");
  let v,
    arr = new Uint8Array(16);
  return arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24, arr[1] = v >>> 16 & 255, arr[2] = v >>> 8 & 255, arr[3] = v & 255, arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, arr[5] = v & 255, arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, arr[7] = v & 255, arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, arr[9] = v & 255, arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, arr[11] = v / 4294967296 & 255, arr[12] = v >>> 24 & 255, arr[13] = v >>> 16 & 255, arr[14] = v >>> 8 & 255, arr[15] = v & 255, arr;
}
var parse_default,
  init_parse = __esmMin(() => {
    init_validate();
    __name(parse, "parse");
    parse_default = parse;
  });
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  let bytes = [];
  for (let i = 0; i < str.length; ++i) bytes.push(str.charCodeAt(i));
  return bytes;
}
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value == "string" && (value = stringToBytes(value)), typeof namespace == "string" && (namespace = parse_default(namespace)), namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let bytes = new Uint8Array(16 + value.length);
    if (bytes.set(namespace), bytes.set(value, namespace.length), bytes = hashfunc(bytes), bytes[6] = bytes[6] & 15 | version, bytes[8] = bytes[8] & 63 | 128, buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
      return buf;
    }
    return stringify_default(bytes);
  }
  __name(generateUUID, "generateUUID");
  try {
    generateUUID.name = name;
  } catch {}
  return generateUUID.DNS = DNS, generateUUID.URL = URL, generateUUID;
}
var DNS,
  URL,
  init_v35 = __esmMin(() => {
    init_stringify();
    init_parse();
    __name(stringToBytes, "stringToBytes");
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    __name(v35_default, "default");
  });
function md5(bytes) {
  return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : typeof bytes == "string" && (bytes = Buffer.from(bytes, "utf8")), RQ.crypto.createHash("md5").update(bytes).digest();
}
var import_crypto,
  md5_default,
  init_md5 = __esmMin(() => {
    import_crypto = Ns(require("crypto"));
    __name(md5, "md5");
    md5_default = md5;
  });
var v3,
  v3_default,
  init_v3 = __esmMin(() => {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default), v3_default = v3;
  });
function v4(options, buf, offset) {
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default,
  init_v4 = __esmMin(() => {
    init_rng();
    init_stringify();
    __name(v4, "v4");
    v4_default = v4;
  });
function sha1(bytes) {
  return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : typeof bytes == "string" && (bytes = Buffer.from(bytes, "utf8")), BQ.crypto.createHash("sha1").update(bytes).digest();
}
var import_crypto,
  sha1_default,
  init_sha1 = __esmMin(() => {
    import_crypto = Ns(require("crypto"));
    __name(sha1, "sha1");
    sha1_default = sha1;
  });
var v5,
  v5_default,
  init_v5 = __esmMin(() => {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default), v5_default = v5;
  });
var nil_default,
  init_nil = __esmMin(() => {
    nil_default = "00000000-0000-0000-0000-000000000000";
  });
function version(uuid) {
  if (!validate_default(uuid)) throw TypeError("Invalid UUID");
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default,
  init_version = __esmMin(() => {
    init_validate();
    __name(version, "version");
    version_default = version;
  });
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esmMin(() => {
  init_v1();
  init_v3();
  init_v4();
  init_v5();
  init_nil();
  init_version();
  init_validate();
  init_stringify();
  init_parse();
});
function bytes_to_unicode(map) {
  let bs = range(ord("!"), ord("~") + 1).concat(range(ord("\xA1"), ord("\xAC") + 1), range(ord("\xAE"), ord("\xFF") + 1)),
    cs = bs.slice(),
    n = 0;
  for (let b = 0; b < 2 ** 8; b++) bs.includes(b) || (bs.push(b), cs.push(2 ** 8 + n), n = n + 1);
  let cs_ = cs.map(x => chr(x));
  for (let i = 0; i < bs.length; i++) map.set(bs[i], cs_[i]);
}
function get_char_pairs(word) {
  let pairs = new Set(),
    prev_char = word[0];
  for (let i = 1; i < word.length; i++) {
    let char = word[i];
    pairs.add([prev_char, char]), prev_char = char;
  }
  return pairs;
}
function getTokenizer(name = "cl100k") {
  let tokenizer = tokenizers.get(name);
  return tokenizer !== void 0 || (name === "mock" ? tokenizer = new MockTokenizer() : tokenizer = new BPETokenizer(name), tokenizers.set(name, tokenizer)), tokenizer;
}
var fs,
  path,
  import_util,
  range,
  ord,
  chr,
  textDecoder,
  decodeStr,
  dictZip,
  TokenizerName,
  tokenizers,
  BPETokenizer,
  MockTokenizer,
  init_tokenizer = __esmMin(() => {
    "use strict";

    fs = Ns(require("fs")), path = Ns(require("path")), import_util = require("util"), range = __name((x, y) => Array.from(Array(y).keys()).slice(x), "range"), ord = __name(x => x.charCodeAt(0), "ord"), chr = __name(x => String.fromCharCode(x), "chr"), textDecoder = new eb.TextDecoder("utf-8"), decodeStr = __name(arr => textDecoder.decode(new Uint8Array(arr)), "decodeStr"), dictZip = __name((x, y) => {
      let result = new Map();
      return x.forEach((_, i) => {
        result.set(x[i], y[i]);
      }), result;
    }, "dictZip");
    __name(bytes_to_unicode, "bytes_to_unicode");
    __name(get_char_pairs, "get_char_pairs");
    TokenizerName = (r => (TokenizerName.cl100k = "cl100k", TokenizerName.mock = "mock", TokenizerName))(tb || {}), tokenizers = new Map();
    __name(getTokenizer, "getTokenizer");
    BPETokenizer = class {
      constructor(name = "cl100k") {
        this.decoder = new Map();
        this.byte_encoder = new Map();
        this.byte_decoder = new Map();
        this.cache = new Map();
        this.textEncoder = new eb.TextEncoder();
        this.encodeStr = str => Array.from(this.textEncoder.encode(str));
        let VOCAB = "",
          ENCODER = "";
        if (name === "cl100k") VOCAB = "vocab_cushman002.bpe", ENCODER = "tokenizer_cushman002.json", this.pat = /'s|'t|'re|'ve|'m|'ll|'d|[^\r\n\p{L}\p{N}]?\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]+[\r\n]*|\s*[\r\n]+|\s+(?!\S)|\s+/giu;else throw new Error(`Unknown tokenizer name: ${name}`);
        let encoder_json, bpe_file;
        try {
          let encoder_text = SO.readFileSync(wO.resolve(__dirname, "resources", name, ENCODER));
          encoder_json = JSON.parse(encoder_text.toString()), bpe_file = SO.readFileSync(wO.resolve(__dirname, "resources", name, VOCAB), "utf-8");
        } catch (e) {
          if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code === "EPERM") && e instanceof Error || e instanceof SyntaxError) {
            let error = new Error(`Could not load tokenizer: ${name}`);
            throw error.code = "CopilotPromptLoadFailure", error;
          }
          throw e;
        }
        this.encoder = new Map(Object.entries(encoder_json));
        for (let [key, value] of this.encoder) this.decoder.set(value, key);
        let bpe_merges = bpe_file.split(`
`).slice(1).filter(l => l.trim().length > 0);
        this.bpe_ranks = dictZip(bpe_merges, range(0, bpe_merges.length)), bytes_to_unicode(this.byte_encoder), this.byte_encoder.forEach((value, key, _) => {
          this.byte_decoder.set(value, key);
        });
      }
      static {
        __name(this, "BPETokenizer");
      }
      byteEncodeStr(s) {
        return this.encodeStr(s).map(x => this.byte_encoder.get(x));
      }
      mutatingConcat(dest, src) {
        for (let i = 0; i < src.length; i++) dest.push(src[i]);
        return dest;
      }
      bpe(chunk) {
        if (this.cache.has(chunk)) return this.cache.get(chunk);
        let bytes = this.byteEncodeStr(chunk),
          pairs = get_char_pairs(bytes);
        if (!pairs) return bytes.map(x => this.encoder.get(x));
        for (;;) {
          let minPairs = new Map();
          pairs.forEach(pair => {
            let joined_pair = pair.join(" "),
              rank = this.bpe_ranks.get(joined_pair);
            minPairs.set(rank === void 0 || isNaN(rank) ? 1e11 : rank, pair);
          });
          let minPairsKeys = Array.from(minPairs.keys()).map(x => Number(x)),
            bigram = minPairs.get(Math.min(...minPairsKeys));
          if (!bigram || !this.bpe_ranks.has(bigram.join(" "))) break;
          let first = bigram[0],
            second = bigram[1],
            new_bytes = [],
            i = 0;
          for (; i < bytes.length;) {
            let j = bytes.indexOf(first, i);
            if (j === -1) {
              this.mutatingConcat(new_bytes, bytes.slice(i));
              break;
            }
            this.mutatingConcat(new_bytes, bytes.slice(i, j)), i = j, bytes[i] === first && i < bytes.length - 1 && bytes[i + 1] === second ? (new_bytes.push(first + second), i = i + 2) : (new_bytes.push(bytes[i]), i = i + 1);
          }
          if (bytes = new_bytes, bytes.length === 1) break;
          pairs = get_char_pairs(bytes);
        }
        let tokens = bytes.map(x => this.encoder.get(x));
        return this.cache.set(chunk, tokens), tokens;
      }
      tokenize(text) {
        let tokens = [],
          matches = Array.from(text.matchAll(this.pat)).map(x => x[0]);
        for (let chunk of matches) {
          let chunk_tokens = this.bpe(chunk);
          this.mutatingConcat(tokens, chunk_tokens);
        }
        return tokens;
      }
      tokenLength(text) {
        return this.tokenize(text).length;
      }
      takeLastTokens(text, n) {
        if (n <= 0) return "";
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          suffix = text.slice(-chars),
          suffixT = this.tokenize(suffix);
        for (; suffixT.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), suffix = text.slice(-chars), suffixT = this.tokenize(suffix);
        return suffixT.length < n ? text : (suffixT = suffixT.slice(-n), this.detokenize(suffixT));
      }
      takeFirstTokens(text, n) {
        if (n <= 0) return {
          text: "",
          tokens: []
        };
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          prefix = text.slice(0, chars),
          prefix_t = this.tokenize(prefix);
        for (; prefix_t.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), prefix = text.slice(0, chars), prefix_t = this.tokenize(prefix);
        return prefix_t.length < n ? {
          text: text,
          tokens: prefix_t
        } : (prefix_t = prefix_t.slice(0, n), {
          text: this.detokenize(prefix_t),
          tokens: prefix_t
        });
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
      detokenize(tokens) {
        let text = tokens.map(x => this.decoder.get(x)).join("");
        return text = decodeStr(text.split("").map(x => this.byte_decoder.get(x))), text;
      }
      tokenizeStrings(text) {
        return this.tokenize(text).map(token => decodeStr(this.decoder.get(token).split("").map(char => this.byte_decoder.get(char))));
      }
    }, MockTokenizer = class {
      constructor() {
        this.hash = str => {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            let char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char, hash &= hash & 65535;
          }
          return hash;
        };
      }
      static {
        __name(this, "MockTokenizer");
      }
      tokenize(text) {
        return this.tokenizeStrings(text).map(this.hash);
      }
      detokenize(tokens) {
        return tokens.map(token => token.toString()).join(" ");
      }
      tokenizeStrings(text) {
        return text.split(/\b/);
      }
      tokenLength(text) {
        return this.tokenizeStrings(text).length;
      }
      takeLastTokens(text, n) {
        return this.tokenizeStrings(text).slice(-n).join("");
      }
      takeFirstTokens(text, n) {
        let tokens = this.tokenizeStrings(text).slice(0, n);
        return {
          text: tokens.join(""),
          tokens: tokens.map(this.hash)
        };
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
    };
  });
var init_tokenization = __esmMin(() => {
  "use strict";

  init_tokenizer();
});
function virtualNode(indentation, subs, label) {
  return {
    type: "virtual",
    indentation: indentation,
    subs: subs,
    label: label
  };
}
function lineNode(indentation, lineNumber, sourceLine, subs, label) {
  if (sourceLine === "") throw new Error("Cannot create a line node with an empty source line");
  return {
    type: "line",
    indentation: indentation,
    lineNumber: lineNumber,
    sourceLine: sourceLine,
    subs: subs,
    label: label
  };
}
function blankNode(line) {
  return {
    type: "blank",
    lineNumber: line,
    subs: []
  };
}
function topNode(subs) {
  return {
    type: "top",
    indentation: -1,
    subs: subs ?? []
  };
}
function isBlank(tree) {
  return tree.type === "blank";
}
function isLine(tree) {
  return tree.type === "line";
}
function isVirtual(tree) {
  return tree.type === "virtual";
}
function isTop(tree) {
  return tree.type === "top";
}
function cutTreeAfterLine(tree, lineNumber) {
  function cut(tree) {
    if (!isVirtual(tree) && !isTop(tree) && tree.lineNumber === lineNumber) return tree.subs = [], !0;
    for (let i = 0; i < tree.subs.length; i++) if (cut(tree.subs[i])) return tree.subs = tree.subs.slice(0, i + 1), !0;
    return !1;
  }
  __name(cut, "cut"), cut(tree);
}
function duplicateTree(tree) {
  return JSON.parse(JSON.stringify(tree));
}
var init_classes = __esmMin(() => {
  "use strict";

  __name(virtualNode, "virtualNode");
  __name(lineNode, "lineNode");
  __name(blankNode, "blankNode");
  __name(topNode, "topNode");
  __name(isBlank, "isBlank");
  __name(isLine, "isLine");
  __name(isVirtual, "isVirtual");
  __name(isTop, "isTop");
  __name(cutTreeAfterLine, "cutTreeAfterLine");
  __name(duplicateTree, "duplicateTree");
});
function clearLabels(tree) {
  return visitTree(tree, tree => {
    tree.label = void 0;
  }, "bottomUp"), tree;
}
function clearLabelsIf(tree, condition) {
  return visitTree(tree, tree => {
    tree.label = tree.label ? condition(tree.label) ? void 0 : tree.label : void 0;
  }, "bottomUp"), tree;
}
function mapLabels(tree, map) {
  switch (tree.type) {
    case "line":
    case "virtual":
      let newSubs = tree.subs.map(sub => mapLabels(sub, map));
      return {
        ...tree,
        subs: newSubs,
        label: tree.label ? map(tree.label) : void 0
      };
    case "blank":
      return {
        ...tree,
        label: tree.label ? map(tree.label) : void 0
      };
    case "top":
      return {
        ...tree,
        subs: tree.subs.map(sub => mapLabels(sub, map)),
        label: tree.label ? map(tree.label) : void 0
      };
  }
}
function resetLineNumbers(tree) {
  let lineNumber = 0;
  function visitor(tree) {
    !isVirtual(tree) && !isTop(tree) && (tree.lineNumber = lineNumber, lineNumber++);
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "topDown");
}
function visitTree(tree, visitor, direction) {
  function _visit(tree) {
    direction === "topDown" && visitor(tree), tree.subs.forEach(subtree => {
      _visit(subtree);
    }), direction === "bottomUp" && visitor(tree);
  }
  __name(_visit, "_visit"), _visit(tree);
}
function visitTreeConditionally(tree, visitor, direction) {
  function _visit(tree) {
    if (direction === "topDown" && !visitor(tree)) return !1;
    let shouldContinue = !0;
    return tree.subs.forEach(subtree => {
      shouldContinue = shouldContinue && _visit(subtree);
    }), direction === "bottomUp" && (shouldContinue = shouldContinue && visitor(tree)), shouldContinue;
  }
  __name(_visit, "_visit"), _visit(tree);
}
function foldTree(tree, init, accumulator, direction) {
  let acc = init;
  function visitor(tree) {
    acc = accumulator(tree, acc);
  }
  return __name(visitor, "visitor"), visitTree(tree, visitor, direction), acc;
}
function rebuildTree(tree, visitor, skip) {
  let rebuild = __name(tree => {
      if (skip !== void 0 && skip(tree)) return tree;
      {
        let newSubs = tree.subs.map(rebuild).filter(sub => sub !== void 0);
        return tree.subs = newSubs, visitor(tree);
      }
    }, "rebuild"),
    rebuilt = rebuild(tree);
  return rebuilt !== void 0 ? rebuilt : topNode();
}
var init_manipulation = __esmMin(() => {
  "use strict";

  init_classes();
  __name(clearLabels, "clearLabels");
  __name(clearLabelsIf, "clearLabelsIf");
  __name(mapLabels, "mapLabels");
  __name(resetLineNumbers, "resetLineNumbers");
  __name(visitTree, "visitTree");
  __name(visitTreeConditionally, "visitTreeConditionally");
  __name(foldTree, "foldTree");
  __name(rebuildTree, "rebuildTree");
});
function parseRaw(source) {
  let rawLines = source.split(`
`),
    indentations = rawLines.map(line => line.match(/^\s*/)[0].length),
    lines = rawLines.map(line => line.trimLeft());
  function parseNode(line) {
    let [subs, nextLine] = parseSubs(line + 1, indentations[line]);
    return [lineNode(indentations[line], line, lines[line], subs), nextLine];
  }
  __name(parseNode, "parseNode");
  function parseSubs(initialLine, parentIndentation) {
    let sub,
      subs = [],
      line = initialLine,
      lastBlank;
    for (; line < lines.length && (lines[line] === "" || indentations[line] > parentIndentation);) if (lines[line] === "") lastBlank === void 0 && (lastBlank = line), line += 1;else {
      if (lastBlank !== void 0) {
        for (let i = lastBlank; i < line; i++) subs.push(blankNode(i));
        lastBlank = void 0;
      }
      [sub, line] = parseNode(line), subs.push(sub);
    }
    return lastBlank !== void 0 && (line = lastBlank), [subs, line];
  }
  __name(parseSubs, "parseSubs");
  let [subs, parsedLine] = parseSubs(0, -1),
    line = parsedLine;
  for (; line < lines.length && lines[line] === "";) subs.push(blankNode(line)), line += 1;
  if (line < lines.length) throw new Error(`Parsing did not go to end of file. Ended at ${line} out of ${lines.length}`);
  return topNode(subs);
}
function labelLines(tree, labelRules) {
  function visitor(tree) {
    if (isLine(tree)) {
      let rule = labelRules.find(rule => rule.matches(tree.sourceLine));
      rule && (tree.label = rule.label);
    }
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
}
function labelVirtualInherited(tree) {
  function visitor(tree) {
    if (isVirtual(tree) && tree.label === void 0) {
      let subs = tree.subs.filter(sub => !isBlank(sub));
      subs.length === 1 && (tree.label = subs[0].label);
    }
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
}
function buildLabelRules(ruleMap) {
  return Object.keys(ruleMap).map(key => {
    let matches;
    return ruleMap[key].test ? matches = __name(sourceLine => ruleMap[key].test(sourceLine), "matches") : matches = ruleMap[key], {
      matches: matches,
      label: key
    };
  });
}
function combineClosersAndOpeners(tree) {
  let returnTree = rebuildTree(tree, __name(function (tree) {
    if (tree.subs.length === 0 || tree.subs.findIndex(sub => sub.label === "closer" || sub.label === "opener") === -1) return tree;
    let newSubs = [],
      lastNew;
    for (let i = 0; i < tree.subs.length; i++) {
      let sub = tree.subs[i],
        directOlderSibling = tree.subs[i - 1];
      if (sub.label === "opener" && directOlderSibling !== void 0 && isLine(directOlderSibling)) directOlderSibling.subs.push(sub), sub.subs.forEach(sub => directOlderSibling.subs.push(sub)), sub.subs = [];else if (sub.label === "closer" && lastNew !== void 0 && (isLine(sub) || isVirtual(sub)) && sub.indentation >= lastNew.indentation) {
        let j = newSubs.length - 1;
        for (; j > 0 && isBlank(newSubs[j]);) j -= 1;
        if (lastNew.subs.push(...newSubs.splice(j + 1)), sub.subs.length > 0) {
          let firstNonVirtual = lastNew.subs.findIndex(sub => sub.label !== "newVirtual"),
            subsToKeep = lastNew.subs.slice(0, firstNonVirtual),
            subsToWrap = lastNew.subs.slice(firstNonVirtual),
            wrappedSubs = subsToWrap.length > 0 ? [virtualNode(sub.indentation, subsToWrap, "newVirtual")] : [];
          lastNew.subs = [...subsToKeep, ...wrappedSubs, sub];
        } else lastNew.subs.push(sub);
      } else newSubs.push(sub), isBlank(sub) || (lastNew = sub);
    }
    return tree.subs = newSubs, tree;
  }, "rebuilder"));
  return clearLabelsIf(tree, arg => arg === "newVirtual"), returnTree;
}
function groupBlocks(tree, isDelimiter = isBlank, label) {
  return rebuildTree(tree, __name(function (tree) {
    if (tree.subs.length <= 1) return tree;
    let newSubs = [],
      nodesSinceLastFlush = [],
      currentBlockIndentation,
      lastNodeWasDelimiter = !1;
    function flushBlockIntoNewSubs(final = !1) {
      if (currentBlockIndentation !== void 0 && (newSubs.length > 0 || !final)) {
        let virtual = virtualNode(currentBlockIndentation, nodesSinceLastFlush, label);
        newSubs.push(virtual);
      } else nodesSinceLastFlush.forEach(node => newSubs.push(node));
    }
    __name(flushBlockIntoNewSubs, "flushBlockIntoNewSubs");
    for (let i = 0; i < tree.subs.length; i++) {
      let sub = tree.subs[i],
        subIsDelimiter = isDelimiter(sub);
      !subIsDelimiter && lastNodeWasDelimiter && (flushBlockIntoNewSubs(), nodesSinceLastFlush = []), lastNodeWasDelimiter = subIsDelimiter, nodesSinceLastFlush.push(sub), isBlank(sub) || (currentBlockIndentation = currentBlockIndentation ?? sub.indentation);
    }
    return flushBlockIntoNewSubs(!0), tree.subs = newSubs, tree;
  }, "rebuilder"));
}
function flattenVirtual(tree) {
  return rebuildTree(tree, __name(function (tree) {
    return isVirtual(tree) && tree.label === void 0 && tree.subs.length <= 1 ? tree.subs.length === 0 ? void 0 : tree.subs[0] : (tree.subs.length === 1 && isVirtual(tree.subs[0]) && tree.subs[0].label === void 0 && (tree.subs = tree.subs[0].subs), tree);
  }, "rebuilder"));
}
function registerLanguageSpecificParser(language, parser) {
  LANGUAGE_SPECIFIC_PARSERS[language] = parser;
}
function parseTree(source, languageId) {
  let raw = parseRaw(source),
    languageSpecificParser = LANGUAGE_SPECIFIC_PARSERS[languageId ?? ""];
  return languageSpecificParser ? languageSpecificParser(raw) : (labelLines(raw, genericLabelRules), combineClosersAndOpeners(raw));
}
var _genericLabelRules,
  genericLabelRules,
  LANGUAGE_SPECIFIC_PARSERS,
  init_parsing = __esmMin(() => {
    "use strict";

    init_classes();
    init_manipulation();
    __name(parseRaw, "parseRaw");
    __name(labelLines, "labelLines");
    __name(labelVirtualInherited, "labelVirtualInherited");
    __name(buildLabelRules, "buildLabelRules");
    __name(combineClosersAndOpeners, "combineClosersAndOpeners");
    __name(groupBlocks, "groupBlocks");
    __name(flattenVirtual, "flattenVirtual");
    _genericLabelRules = {
      opener: /^[\[({]/,
      closer: /^[\])}]/
    }, genericLabelRules = buildLabelRules(_genericLabelRules), LANGUAGE_SPECIFIC_PARSERS = {};
    __name(registerLanguageSpecificParser, "registerLanguageSpecificParser");
    __name(parseTree, "parseTree");
  });
function processJava(originalTree) {
  let tree = originalTree;
  return labelLines(tree, javaLabelRules), tree = combineClosersAndOpeners(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), visitTree(tree, tree => {
    if (tree.label === "class" || tree.label === "interface") for (let sub of tree.subs) !isBlank(sub) && (sub.label === void 0 || sub.label === "annotation") && (sub.label = "member");
  }, "bottomUp"), tree;
}
var _javaLabelRules,
  javaLabelRules,
  init_java = __esmMin(() => {
    "use strict";

    init_classes();
    init_manipulation();
    init_parsing();
    _javaLabelRules = {
      package: /^package /,
      import: /^import /,
      class: /\bclass /,
      interface: /\binterface /,
      javadoc: /^\/\*\*/,
      comment_multi: /^\/\*[^*]/,
      comment_single: /^\/\//,
      annotation: /^@/,
      opener: /^[\[({]/,
      closer: /^[\])}]/
    }, javaLabelRules = buildLabelRules(_javaLabelRules);
    __name(processJava, "processJava");
  });
function processMarkdown(originalTree) {
  let tree = originalTree;
  if (labelLines(tree, MarkdownLabelRules), isBlank(tree)) return tree;
  function headingLevel(sub) {
    if (sub.label === "heading") return 1;
    if (sub.label === "subheading") return 2;
    if (sub.label === "subsubheading") return 3;
  }
  __name(headingLevel, "headingLevel");
  let currentHierarchy = [tree],
    oldTreeSubs = [...tree.subs];
  tree.subs = [];
  for (let sub of oldTreeSubs) {
    let level = headingLevel(sub);
    if (level === void 0 || isBlank(sub)) currentHierarchy[currentHierarchy.length - 1].subs.push(sub);else {
      for (; currentHierarchy.length < level;) currentHierarchy.push(currentHierarchy[currentHierarchy.length - 1]);
      for (currentHierarchy[level - 1].subs.push(sub), currentHierarchy[level] = sub; currentHierarchy.length > level + 1;) currentHierarchy.pop();
    }
  }
  return tree = groupBlocks(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), tree;
}
var _MarkdownLabelRules,
  MarkdownLabelRules,
  init_markdown = __esmMin(() => {
    "use strict";

    init_classes();
    init_parsing();
    _MarkdownLabelRules = {
      heading: /^# /,
      subheading: /^## /,
      subsubheading: /### /
    }, MarkdownLabelRules = buildLabelRules(_MarkdownLabelRules);
    __name(processMarkdown, "processMarkdown");
  });
function deparseLine(node) {
  return " ".repeat(node.indentation) + node.sourceLine + `
`;
}
function deparseTree(tree) {
  function accumulator(tree, accum) {
    let str = "";
    return isLine(tree) ? str = deparseLine(tree) : isBlank(tree) && (str = `
`), accum + str;
  }
  return __name(accumulator, "accumulator"), foldTree(tree, "", accumulator, "topDown");
}
function deparseAndCutTree(tree, cutAt) {
  let cutAtSet = new Set(cutAt),
    cuts = [],
    curUndef = "";
  function visit(tree) {
    tree.label !== void 0 && cutAtSet.has(tree.label) ? (curUndef !== "" && cuts.push({
      label: void 0,
      source: curUndef
    }), cuts.push({
      label: tree.label,
      source: deparseTree(tree)
    }), curUndef = "") : (isLine(tree) && (curUndef += deparseLine(tree)), tree.subs.forEach(visit));
  }
  return __name(visit, "visit"), visit(tree), curUndef !== "" && cuts.push({
    label: void 0,
    source: curUndef
  }), cuts;
}
function describeTree(tree, indent = 0) {
  let ind = " ".repeat(indent);
  if (tree === void 0) return "UNDEFINED NODE";
  let children;
  tree.subs === void 0 ? children = "UNDEFINED SUBS" : children = tree.subs.map(child => describeTree(child, indent + 2)).join(`,
`), children === "" ? children = "[]" : children = `[
${children}
      ${ind}]`;
  let prefix = (isVirtual(tree) || isTop(tree) ? "   " : String(tree.lineNumber).padStart(3, " ")) + `:  ${ind}`,
    labelString = tree.label === void 0 ? "" : JSON.stringify(tree.label);
  return isVirtual(tree) || isTop(tree) ? `${prefix}vnode(${tree.indentation}, ${labelString}, ${children})` : isBlank(tree) ? `${prefix}blank(${labelString ?? ""})` : `${prefix}lnode(${tree.indentation}, ${labelString}, ${JSON.stringify(tree.sourceLine)}, ${children})`;
}
function encodeTree(tree, indent = "") {
  let labelString = tree.label === void 0 ? "" : `, ${JSON.stringify(tree.label)}`,
    subString = !isBlank(tree) && tree.subs.length > 0 ? `[
${tree.subs.map(node => encodeTree(node, indent + "  ")).join(`, 
`)}
${indent}]` : "[]";
  switch (tree.type) {
    case "blank":
      return `${indent}blankNode(${tree.lineNumber}${labelString})`;
    case "top":
      return `topNode(${subString}${labelString})`;
    case "virtual":
      return `${indent}virtualNode(${tree.indentation}, ${subString}${labelString})`;
    case "line":
      return `${indent}lineNode(${tree.indentation}, ${tree.lineNumber}, "${tree.sourceLine}", ${subString}${labelString})`;
  }
}
function firstLineOf(tree) {
  if (isLine(tree) || isBlank(tree)) return tree.lineNumber;
  for (let sub of tree.subs) {
    let firstLine = firstLineOf(sub);
    if (firstLine !== void 0) return firstLine;
  }
}
function lastLineOf(tree) {
  let lastLine,
    i = tree.subs.length - 1;
  for (; i >= 0 && lastLine === void 0;) lastLine = lastLineOf(tree.subs[i]), i--;
  return lastLine === void 0 && !isVirtual(tree) && !isTop(tree) ? tree.lineNumber : lastLine;
}
var init_description = __esmMin(() => {
  "use strict";

  init_classes();
  init_manipulation();
  __name(deparseLine, "deparseLine");
  __name(deparseTree, "deparseTree");
  __name(deparseAndCutTree, "deparseAndCutTree");
  __name(describeTree, "describeTree");
  __name(encodeTree, "encodeTree");
  __name(firstLineOf, "firstLineOf");
  __name(lastLineOf, "lastLineOf");
});
var init_indentation = __esmMin(() => {
  "use strict";

  init_java();
  init_markdown();
  init_parsing();
  init_classes();
  init_description();
  init_manipulation();
  init_parsing();
  registerLanguageSpecificParser("markdown", processMarkdown);
  registerLanguageSpecificParser("java", processJava);
});
function fromTreeWithFocussedLines(tree, config = DEFAULT_TREE_TRAVERSAL_CONFIG) {
  let treeWithDistances = mapLabels(tree, x => x ? 1 : void 0);
  return visitTree(treeWithDistances, node => {
    if (isBlank(node)) return;
    let maxChildLabel = Math.max(...node.subs.map(child => child.label ?? 0));
    node.label = Math.max(node.label ?? 0, maxChildLabel * config.worthUp);
  }, "bottomUp"), visitTree(treeWithDistances, node => {
    if (isBlank(node)) return;
    let values = node.subs.map(sub => sub.label ?? 0),
      new_values = [...values];
    for (let i = 0; i < values.length; i++) values[i] !== 0 && (new_values = new_values.map((v, j) => Math.max(v, Math.pow(config.worthSibling, Math.abs(i - j)) * values[i])));
    let nodeLabel = node.label;
    nodeLabel !== void 0 && (new_values = new_values.map(v => Math.max(v, config.worthDown * nodeLabel))), node.subs.forEach((sub, i) => sub.label = new_values[i]);
  }, "topDown"), fromTreeWithValuedLines(treeWithDistances);
}
function fromTreeWithValuedLines(tree) {
  let valuedLines = foldTree(tree, [], (node, acc) => ((node.type === "line" || node.type === "blank") && acc.push(node.type === "line" ? [deparseLine(node).trimEnd(), node.label ?? 0] : ["", node.label ?? 0]), acc), "topDown");
  return new ElidableText(...valuedLines);
}
var DEFAULT_TREE_TRAVERSAL_CONFIG,
  init_fromIndentationTrees = __esmMin(() => {
    "use strict";

    init_indentation();
    init_elidableText();
    DEFAULT_TREE_TRAVERSAL_CONFIG = {
      worthUp: .9,
      worthSibling: .88,
      worthDown: .8
    };
    __name(fromTreeWithFocussedLines, "fromTreeWithFocussedLines");
    __name(fromTreeWithValuedLines, "fromTreeWithValuedLines");
  });
function elidableTextForSourceCode(contents, focusOnLastLeaf = !0, focusOnFirstLine = !0) {
  let tree = typeof contents == "string" ? parseTree(contents) : parseTree(contents.source, contents.languageId);
  flattenVirtual(tree);
  let treeWithFocussedLines = mapLabels(tree, label => focusOnLastLeaf && label !== "closer");
  return visitTree(treeWithFocussedLines, node => {
    node.label === void 0 && (node.label = focusOnLastLeaf && node.label !== !1);
  }, "topDown"), focusOnLastLeaf && visitTree(treeWithFocussedLines, node => {
    if (node.label) {
      let foundLastTrue = !1;
      for (let subnode of [...node.subs].reverse()) subnode.label && !foundLastTrue ? foundLastTrue = !0 : subnode.label = !1;
    } else for (let subnode of node.subs) subnode.label = !1;
    node.subs.length > 0 && (node.label = !1);
  }, "topDown"), focusOnFirstLine && visitTree(treeWithFocussedLines, node => {
    node.label ||= (isLine(node) || isBlank(node)) && node.lineNumber == 0;
  }, "topDown"), fromTreeWithFocussedLines(treeWithFocussedLines);
}
var init_fromSourceCode = __esmMin(() => {
  "use strict";

  init_indentation();
  init_fromIndentationTrees();
  __name(elidableTextForSourceCode, "elidableTextForSourceCode");
});
var LineWithValueAndCost,
  init_lineWithValueAndCost = __esmMin(() => {
    "use strict";

    init_tokenization();
    LineWithValueAndCost = class _LineWithValueAndCost {
      constructor(text, _value, _cost = getTokenizer().tokenLength(text + `
`), validate = "strict") {
        this.text = text;
        this._value = _value;
        this._cost = _cost;
        if (text.includes(`
`) && validate !== "none") throw new Error("LineWithValueAndCost: text contains newline");
        if (_value < 0 && validate !== "none") throw new Error("LineWithValueAndCost: value is negative");
        if (_cost < 0 && validate !== "none") throw new Error("LineWithValueAndCost: cost is negative");
        if (validate == "strict" && _value > 1) throw new Error("Value should normally be between 0 and 1 -- set validation to `loose` to ignore this error");
      }
      static {
        __name(this, "LineWithValueAndCost");
      }
      get value() {
        return this._value;
      }
      get cost() {
        return this._cost;
      }
      adjustValue(multiplier) {
        return this._value *= multiplier, this;
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        return this._cost = coster(this.text), this;
      }
      copy() {
        return new _LineWithValueAndCost(this.text, this.value, this.cost, "none");
      }
    };
  });
function makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer) {
  if (tokenizer.tokenLength(ellipsis + `
`) > maxTokens) throw new Error("maxTokens must be larger than the ellipsis length");
  strategy === "removeLeastBangForBuck" && lines.forEach(line => line.adjustValue(1 / line.cost));
  let infiniteWorth = lines.reduce((a, b) => Math.max(a, b.value), 0) + 1,
    infiniteIndentation = lines.reduce((a, b) => Math.max(a, b.text.length), 0) + 1,
    trimmedEllipsis = ellipsis.trim(),
    totalCost = lines.reduce((sum, line) => sum + line.cost, 0),
    defensiveCounter = lines.length + 1;
  for (; totalCost > maxTokens && defensiveCounter-- >= -1;) {
    let leastDesirable = lines.reduce((least, line) => line.value < least.value ? line : least),
      index = lines.indexOf(leastDesirable),
      mostRecentNonBlankLine = lines.slice(0, index + 1).reverse().find(line => line.text.trim() !== "") ?? {
        text: ""
      },
      indentation = indentEllipses ? Math.min(mostRecentNonBlankLine.text.match(/^\s*/)?.[0].length ?? 0, lines[index - 1]?.text.trim() === trimmedEllipsis ? lines[index - 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation, lines[index + 1]?.text.trim() === trimmedEllipsis ? lines[index + 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation) : 0,
      insert = " ".repeat(indentation) + ellipsis,
      newEllipis = new LineWithValueAndCost(insert, infiniteWorth, tokenizer.tokenLength(insert + `
`), "loose");
    lines.splice(index, 1, newEllipis), lines[index + 1]?.text.trim() === trimmedEllipsis && lines.splice(index + 1, 1), lines[index - 1]?.text.trim() === trimmedEllipsis && lines.splice(index - 1, 1);
    let newTotalCost = lines.reduce((sum, line) => sum + line.cost, 0);
    newTotalCost >= totalCost && lines.every(line => line.value === infiniteWorth) && (indentEllipses = !1), totalCost = newTotalCost;
  }
  if (defensiveCounter < 0) throw new Error("Infinite loop in ElidableText.makePrompt: Defensive counter < 0 in ElidableText.makePrompt with end text");
  return lines.map(line => line.text).join(`
`);
}
var ElidableText,
  init_elidableText = __esmMin(() => {
    "use strict";

    init_tokenization();
    init_fromSourceCode();
    init_lineWithValueAndCost();
    ElidableText = class _ElidableText {
      constructor(...chunks) {
        this.lines = [];
        let lines = [];
        for (let chunk of chunks) {
          let value = Array.isArray(chunk) ? chunk[1] : 1,
            input = Array.isArray(chunk) ? chunk[0] : chunk;
          typeof input == "string" ? input.split(`
`).forEach(line => lines.push(new LineWithValueAndCost(line, value))) : input instanceof _ElidableText ? lines.push(...input.lines.map(line => line.copy().adjustValue(value))) : "source" in input && "languageId" in input && lines.push(...elidableTextForSourceCode(input).lines.map(line => line.copy().adjustValue(value)));
        }
        this.lines = lines;
      }
      static {
        __name(this, "ElidableText");
      }
      adjust(multiplier) {
        this.lines.forEach(line => line.adjustValue(multiplier));
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        this.lines.forEach(line => line.recost(coster));
      }
      makePrompt(maxTokens, ellipsis = "[...]", indentEllipses = !0, strategy = "removeLeastDesirable", tokenizer = getTokenizer()) {
        let lines = this.lines.map(line => line.copy());
        return makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer);
      }
    };
    __name(makePrompt, "makePrompt");
  });
function Diff() {}
function buildValues(diff, components, newString, oldString, useLongestToken) {
  for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (component.removed) {
      if (component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), oldPos += component.count, componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos], components[componentPos] = tmp;
      }
    } else {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        }), component.value = diff.join(value);
      } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
      newPos += component.count, component.added || (oldPos += component.count);
    }
  }
  var lastComponent = components[componentLen - 1];
  return componentLen > 1 && typeof lastComponent.value == "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, components.pop()), components;
}
function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = __name(function (obj) {
    return typeof obj;
  }, "_typeof") : _typeof = __name(function (obj) {
    return obj && typeof Symbol == "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, "_typeof"), _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if (typeof o == "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
}
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [], replacementStack = replacementStack || [], replacer && (obj = replacer(key, obj));
  var i;
  for (i = 0; i < stack.length; i += 1) if (stack[i] === obj) return replacementStack[i];
  var canonicalizedObj;
  if (objectPrototypeToString.call(obj) === "[object Array]") {
    for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    return stack.pop(), replacementStack.pop(), canonicalizedObj;
  }
  if (obj && obj.toJSON && (obj = obj.toJSON()), _typeof(obj) === "object" && obj !== null) {
    stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
      _key;
    for (_key in obj) obj.hasOwnProperty(_key) && sortedKeys.push(_key);
    for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) _key = sortedKeys[i], canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    stack.pop(), replacementStack.pop();
  } else canonicalizedObj = obj;
  return canonicalizedObj;
}
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  options || (options = {}), typeof options.context > "u" && (options.context = 4);
  var diff = diffLines(oldStr, newStr, options);
  if (!diff) return;
  diff.push({
    value: "",
    lines: []
  });
  function contextLines(lines) {
    return lines.map(function (entry) {
      return " " + entry;
    });
  }
  __name(contextLines, "contextLines");
  for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = __name(function (i) {
      var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, "").split(`
`);
      if (current.lines = lines, current.added || current.removed) {
        var _curRange;
        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
        }
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
          return (current.added ? "+" : "-") + entry;
        }))), current.added ? newLine += lines.length : oldLine += lines.length;
      } else {
        if (oldRangeStart) if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3,
            contextSize = Math.min(lines.length, options.context);
          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i >= diff.length - 2 && lines.length <= options.context) {
            var oldEOFNewline = /\n$/.test(oldStr),
              newEOFNewline = /\n$/.test(newStr),
              noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
            !oldEOFNewline && noNlBeforeAdds && oldStr.length > 0 && curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file"), (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) && curRange.push("\\ No newline at end of file");
          }
          hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
        }
        oldLine += lines.length, newLine += lines.length;
      }
    }, "_loop"), i = 0; i < diff.length; i++) _loop(i);
  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
var characterDiff,
  extendedWordChars,
  reWhitespace,
  wordDiff,
  lineDiff,
  sentenceDiff,
  cssDiff,
  objectPrototypeToString,
  jsonDiff,
  arrayDiff,
  init_lib = __esmMin(() => {
    __name(Diff, "Diff");
    Diff.prototype = {
      diff: __name(function (oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
          callback = options.callback;
        typeof options == "function" && (callback = options, options = {}), this.options = options;
        var self = this;
        function done(value) {
          return callback ? (setTimeout(function () {
            callback(void 0, value);
          }, 0), !0) : value;
        }
        __name(done, "done"), oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString)), newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
          oldLen = oldString.length,
          editLength = 1,
          maxEditLength = newLen + oldLen;
        options.maxEditLength && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
        var bestPath = [{
            newPos: -1,
            components: []
          }],
          oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) return done([{
          value: this.join(newString),
          count: newString.length
        }]);
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0,
              addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            addPath && (bestPath[diagonalPath - 1] = void 0);
            var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), self.pushComponent(basePath.components, void 0, !0)) : (basePath = addPath, basePath.newPos++, self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            bestPath[diagonalPath] = basePath;
          }
          editLength++;
        }
        if (__name(execEditLength, "execEditLength"), callback) __name(function exec() {
          setTimeout(function () {
            if (editLength > maxEditLength) return callback();
            execEditLength() || exec();
          }, 0);
        }, "exec")();else for (; editLength <= maxEditLength;) {
          var ret = execEditLength();
          if (ret) return ret;
        }
      }, "diff"),
      pushComponent: __name(function (components, added, removed) {
        var last = components[components.length - 1];
        last && last.added === added && last.removed === removed ? components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        } : components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }, "pushComponent"),
      extractCommon: __name(function (basePath, newString, oldString, diagonalPath) {
        for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1]);) newPos++, oldPos++, commonCount++;
        return commonCount && basePath.components.push({
          count: commonCount
        }), basePath.newPos = newPos, oldPos;
      }, "extractCommon"),
      equals: __name(function (left, right) {
        return this.options.comparator ? this.options.comparator(left, right) : left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }, "equals"),
      removeEmpty: __name(function (array) {
        for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
        return ret;
      }, "removeEmpty"),
      castInput: __name(function (value) {
        return value;
      }, "castInput"),
      tokenize: __name(function (value) {
        return value.split("");
      }, "tokenize"),
      join: __name(function (chars) {
        return chars.join("");
      }, "join")
    };
    __name(buildValues, "buildValues");
    __name(clonePath, "clonePath");
    characterDiff = new Diff(), extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, reWhitespace = /\S/, wordDiff = new Diff();
    wordDiff.equals = function (left, right) {
      return this.options.ignoreCase && (left = left.toLowerCase(), right = right.toLowerCase()), left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function (value) {
      for (var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), i = 0; i < tokens.length - 1; i++) !tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2]) && (tokens[i] += tokens[i + 2], tokens.splice(i + 1, 2), i--);
      return tokens;
    };
    lineDiff = new Diff();
    lineDiff.tokenize = function (value) {
      var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/);
      linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        i % 2 && !this.options.newlineIsToken ? retLines[retLines.length - 1] += line : (this.options.ignoreWhitespace && (line = line.trim()), retLines.push(line));
      }
      return retLines;
    };
    __name(diffLines, "diffLines");
    sentenceDiff = new Diff();
    sentenceDiff.tokenize = function (value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    cssDiff = new Diff();
    cssDiff.tokenize = function (value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    __name(_typeof, "_typeof");
    __name(_toConsumableArray, "_toConsumableArray");
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    __name(_iterableToArray, "_iterableToArray");
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    __name(_nonIterableSpread, "_nonIterableSpread");
    objectPrototypeToString = Object.prototype.toString, jsonDiff = new Diff();
    jsonDiff.useLongestToken = !0;
    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function (value) {
      var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
          return typeof v > "u" ? undefinedReplacement : v;
        } : _this$options$stringi;
      return typeof value == "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function (left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
    };
    __name(canonicalize, "canonicalize");
    arrayDiff = new Diff();
    arrayDiff.tokenize = function (value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function (value) {
      return value;
    };
    __name(structuredPatch, "structuredPatch");
  });
function elidableTextForDiff(oldContent, newContent) {
  let languageId = typeof oldContent == "string" ? typeof newContent == "string" ? void 0 : newContent.languageId : typeof newContent == "string" || oldContent.languageId === newContent.languageId ? oldContent.languageId : void 0;
  oldContent = typeof oldContent == "string" ? oldContent : oldContent.source, newContent = typeof newContent == "string" ? newContent : newContent.source;
  let patch = structuredPatch("", "", oldContent, newContent),
    changedLinesOld = new Set(),
    changedLinesNew = new Set();
  for (let hunk of patch.hunks) {
    for (let i = hunk.oldStart; i < hunk.oldStart + hunk.oldLines; i++) changedLinesOld.add(i);
    for (let i = hunk.newStart; i < hunk.newStart + hunk.newLines; i++) changedLinesNew.add(i);
  }
  let oldTree = mapLabels(flattenVirtual(parseTree(oldContent, languageId)), () => !1),
    newTree = mapLabels(flattenVirtual(parseTree(newContent, languageId)), () => !1);
  return visitTree(oldTree, node => {
    (node.type === "line" || node.type === "blank") && changedLinesOld.has(node.lineNumber) && (node.label = !0);
  }, "topDown"), visitTree(newTree, node => {
    (node.type === "line" || node.type === "blank") && changedLinesNew.has(node.lineNumber) && (node.label = !0);
  }, "topDown"), [fromTreeWithFocussedLines(oldTree), fromTreeWithFocussedLines(newTree)];
}
var init_fromDiff = __esmMin(() => {
  "use strict";

  init_lib();
  init_indentation();
  init_fromIndentationTrees();
  __name(elidableTextForDiff, "elidableTextForDiff");
});
var init_elidableText = __esmMin(() => {
  "use strict";

  init_elidableText();
  init_fromDiff();
  init_fromIndentationTrees();
  init_fromSourceCode();
  init_lineWithValueAndCost();
});
var import_fs,
  FileSystem,
  defaultFileSystem,
  init_fileSystem = __esmMin(() => {
    "use strict";

    import_fs = require("fs"), FileSystem = class {
      static {
        __name(this, "FileSystem");
      }
    }, defaultFileSystem = {
      readFile(uri) {
        return jO.fsp.readFile(uri);
      },
      async stat(uri) {
        let stat = await jO.fsp.stat(uri);
        return {
          ctime: stat.ctimeMs,
          mtime: stat.mtimeMs,
          size: stat.size
        };
      }
    };
  });
function hasLanguageMarker({
  source: source
}) {
  return source.startsWith("#!") || source.startsWith("<!DOCTYPE");
}
function comment(text, languageId) {
  let markers = languageCommentMarkers[languageId];
  if (markers) {
    let end = markers.end == "" ? "" : " " + markers.end;
    return `${markers.start} ${text}${end}`;
  }
  return "";
}
function commentBlockAsSingles(text, languageId) {
  if (!languageCommentMarkers[languageId] || text === "") return "";
  let trailingNewline = text.endsWith(`
`),
    commented = (trailingNewline ? text.slice(0, -1) : text).split(`
`).map(line => comment(line, languageId)).join(`
`);
  return trailingNewline ? commented + `
` : commented;
}
function getLanguageMarker(doc) {
  let {
    languageId: languageId
  } = doc;
  return dontAddLanguageMarker.indexOf(languageId) === -1 && !hasLanguageMarker(doc) ? languageId in shebangLines ? shebangLines[languageId] : comment(`Language: ${languageId}`, languageId) : "";
}
function getPathMarker(doc) {
  return doc.relativePath ? comment(`Path: ${doc.relativePath}`, doc.languageId) : "";
}
function newLineEnded(str) {
  return str === "" || str.endsWith(`
`) ? str : str + `
`;
}
var languageCommentMarkers,
  dontAddLanguageMarker,
  shebangLines,
  init_languageMarker = __esmMin(() => {
    "use strict";

    languageCommentMarkers = {
      abap: {
        start: '"',
        end: ""
      },
      bat: {
        start: "REM",
        end: ""
      },
      bibtex: {
        start: "%",
        end: ""
      },
      blade: {
        start: "#",
        end: ""
      },
      c: {
        start: "//",
        end: ""
      },
      clojure: {
        start: ";",
        end: ""
      },
      coffeescript: {
        start: "//",
        end: ""
      },
      cpp: {
        start: "//",
        end: ""
      },
      csharp: {
        start: "//",
        end: ""
      },
      css: {
        start: "/*",
        end: "*/"
      },
      dart: {
        start: "//",
        end: ""
      },
      dockerfile: {
        start: "#",
        end: ""
      },
      elixir: {
        start: "#",
        end: ""
      },
      erb: {
        start: "<%#",
        end: "%>"
      },
      erlang: {
        start: "%",
        end: ""
      },
      fsharp: {
        start: "//",
        end: ""
      },
      go: {
        start: "//",
        end: ""
      },
      groovy: {
        start: "//",
        end: ""
      },
      haml: {
        start: "-#",
        end: ""
      },
      handlebars: {
        start: "{{!",
        end: "}}"
      },
      haskell: {
        start: "--",
        end: ""
      },
      html: {
        start: "<!--",
        end: "-->"
      },
      ini: {
        start: ";",
        end: ""
      },
      java: {
        start: "//",
        end: ""
      },
      javascript: {
        start: "//",
        end: ""
      },
      javascriptreact: {
        start: "//",
        end: ""
      },
      jsonc: {
        start: "//",
        end: ""
      },
      jsx: {
        start: "//",
        end: ""
      },
      julia: {
        start: "#",
        end: ""
      },
      kotlin: {
        start: "//",
        end: ""
      },
      latex: {
        start: "%",
        end: ""
      },
      less: {
        start: "//",
        end: ""
      },
      lua: {
        start: "--",
        end: ""
      },
      makefile: {
        start: "#",
        end: ""
      },
      markdown: {
        start: "[]: #",
        end: ""
      },
      "objective-c": {
        start: "//",
        end: ""
      },
      "objective-cpp": {
        start: "//",
        end: ""
      },
      perl: {
        start: "#",
        end: ""
      },
      php: {
        start: "//",
        end: ""
      },
      powershell: {
        start: "#",
        end: ""
      },
      pug: {
        start: "//",
        end: ""
      },
      python: {
        start: "#",
        end: ""
      },
      ql: {
        start: "//",
        end: ""
      },
      r: {
        start: "#",
        end: ""
      },
      razor: {
        start: "<!--",
        end: "-->"
      },
      ruby: {
        start: "#",
        end: ""
      },
      rust: {
        start: "//",
        end: ""
      },
      sass: {
        start: "//",
        end: ""
      },
      scala: {
        start: "//",
        end: ""
      },
      scss: {
        start: "//",
        end: ""
      },
      shellscript: {
        start: "#",
        end: ""
      },
      slim: {
        start: "/",
        end: ""
      },
      solidity: {
        start: "//",
        end: ""
      },
      sql: {
        start: "--",
        end: ""
      },
      stylus: {
        start: "//",
        end: ""
      },
      svelte: {
        start: "<!--",
        end: "-->"
      },
      swift: {
        start: "//",
        end: ""
      },
      terraform: {
        start: "#",
        end: ""
      },
      tex: {
        start: "%",
        end: ""
      },
      typescript: {
        start: "//",
        end: ""
      },
      typescriptreact: {
        start: "//",
        end: ""
      },
      vb: {
        start: "'",
        end: ""
      },
      verilog: {
        start: "//",
        end: ""
      },
      "vue-html": {
        start: "<!--",
        end: "-->"
      },
      vue: {
        start: "//",
        end: ""
      },
      xml: {
        start: "<!--",
        end: "-->"
      },
      xsl: {
        start: "<!--",
        end: "-->"
      },
      yaml: {
        start: "#",
        end: ""
      }
    }, dontAddLanguageMarker = ["php", "plaintext"], shebangLines = {
      html: "<!DOCTYPE html>",
      python: "#!/usr/bin/env python3",
      ruby: "#!/usr/bin/env ruby",
      shellscript: "#!/bin/sh",
      yaml: "# YAML data"
    };
    __name(hasLanguageMarker, "hasLanguageMarker");
    __name(comment, "comment");
    __name(commentBlockAsSingles, "commentBlockAsSingles");
    __name(getLanguageMarker, "getLanguageMarker");
    __name(getPathMarker, "getPathMarker");
    __name(newLineEnded, "newLineEnded");
  });
var require_tree_sitter = __commonJSMin((exports, module) => {
  var Module = Module !== void 0 ? Module : {},
    TreeSitter = function () {
      var initPromise,
        document = typeof window == "object" ? {
          currentScript: window.document.currentScript
        } : null;
      class Parser {
        static {
          __name(this, "Parser");
        }
        constructor() {
          this.initialize();
        }
        initialize() {
          throw new Error("cannot construct a Parser before calling `init()`");
        }
        static init(moduleOptions) {
          return initPromise || (Module = Object.assign({}, Module, moduleOptions), initPromise = new Promise(resolveInitPromise => {
            var moduleOverrides = Object.assign({}, Module),
              arguments_ = [],
              thisProgram = "./this.program",
              quit_ = __name((e, t) => {
                throw t;
              }, "quit_"),
              ENVIRONMENT_IS_WEB = typeof window == "object",
              ENVIRONMENT_IS_WORKER = typeof importScripts == "function",
              ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string",
              scriptDirectory = "",
              read_,
              readAsync,
              readBinary,
              setWindowTitle;
            function locateFile(e) {
              return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
            }
            __name(locateFile, "locateFile");
            function logExceptionOnExit(e) {
              e instanceof ExitStatus || err("exiting due to exception: " + e);
            }
            if (__name(logExceptionOnExit, "logExceptionOnExit"), ENVIRONMENT_IS_NODE) {
              var fs = require("fs"),
                nodePath = require("path");
              scriptDirectory = ENVIRONMENT_IS_WORKER ? nodePath.dirname(scriptDirectory) + "/" : __dirname + "/", read_ = __name((e, t) => (e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFileSync(e, t ? void 0 : "utf8")), "read_"), readBinary = __name(e => {
                var t = read_(e, !0);
                return t.buffer || (t = new Uint8Array(t)), t;
              }, "readBinary"), readAsync = __name((e, t, r) => {
                e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFile(e, function (e, _) {
                  e ? r(e) : t(_.buffer);
                });
              }, "readAsync"), process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), typeof module < "u" && (module.exports = Module), quit_ = __name((e, t) => {
                if (keepRuntimeAlive()) throw process.exitCode = e, t;
                logExceptionOnExit(t), process.exit(e);
              }, "quit_"), Module.inspect = function () {
                return "[Emscripten Module object]";
              };
            } else (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : document !== void 0 && document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = scriptDirectory.indexOf("blob:") !== 0 ? scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", read_ = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.send(null), t.responseText;
            }, "read_"), ENVIRONMENT_IS_WORKER && (readBinary = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
            }, "readBinary")), readAsync = __name((e, t, r) => {
              var _ = new XMLHttpRequest();
              _.open("GET", e, !0), _.responseType = "arraybuffer", _.onload = () => {
                _.status == 200 || _.status == 0 && _.response ? t(_.response) : r();
              }, _.onerror = r, _.send(null);
            }, "readAsync"), setWindowTitle = __name(e => document.title = e, "setWindowTitle"));
            var out = Module.print || console.log.bind(console),
              err = Module.printErr || console.warn.bind(console);
            Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram), Module.quit && (quit_ = Module.quit);
            var STACK_ALIGN = 16,
              dynamicLibraries = Module.dynamicLibraries || [],
              wasmBinary;
            Module.wasmBinary && (wasmBinary = Module.wasmBinary);
            var noExitRuntime = Module.noExitRuntime || !0,
              wasmMemory;
            typeof WebAssembly != "object" && abort("no native wasm support detected");
            var ABORT = !1,
              EXITSTATUS,
              UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
              buffer,
              HEAP8,
              HEAPU8,
              HEAP16,
              HEAPU16,
              HEAP32,
              HEAPU32,
              HEAPF32,
              HEAPF64;
            function UTF8ArrayToString(e, t, r) {
              for (var _ = t + r, n = t; e[n] && !(n >= _);) ++n;
              if (n - t > 16 && e.buffer && UTF8Decoder) return UTF8Decoder.decode(e.subarray(t, n));
              for (var s = ""; t < n;) {
                var a = e[t++];
                if (128 & a) {
                  var o = 63 & e[t++];
                  if ((224 & a) != 192) {
                    var i = 63 & e[t++];
                    if ((a = (240 & a) == 224 ? (15 & a) << 12 | o << 6 | i : (7 & a) << 18 | o << 12 | i << 6 | 63 & e[t++]) < 65536) s += String.fromCharCode(a);else {
                      var l = a - 65536;
                      s += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);
                    }
                  } else s += String.fromCharCode((31 & a) << 6 | o);
                } else s += String.fromCharCode(a);
              }
              return s;
            }
            __name(UTF8ArrayToString, "UTF8ArrayToString");
            function UTF8ToString(e, t) {
              return e ? UTF8ArrayToString(HEAPU8, e, t) : "";
            }
            __name(UTF8ToString, "UTF8ToString");
            function stringToUTF8Array(e, t, r, _) {
              if (!(_ > 0)) return 0;
              for (var n = r, s = r + _ - 1, a = 0; a < e.length; ++a) {
                var o = e.charCodeAt(a);
                if (o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e.charCodeAt(++a)), o <= 127) {
                  if (r >= s) break;
                  t[r++] = o;
                } else if (o <= 2047) {
                  if (r + 1 >= s) break;
                  t[r++] = 192 | o >> 6, t[r++] = 128 | 63 & o;
                } else if (o <= 65535) {
                  if (r + 2 >= s) break;
                  t[r++] = 224 | o >> 12, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                } else {
                  if (r + 3 >= s) break;
                  t[r++] = 240 | o >> 18, t[r++] = 128 | o >> 12 & 63, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                }
              }
              return t[r] = 0, r - n;
            }
            __name(stringToUTF8Array, "stringToUTF8Array");
            function stringToUTF8(e, t, r) {
              return stringToUTF8Array(e, HEAPU8, t, r);
            }
            __name(stringToUTF8, "stringToUTF8");
            function lengthBytesUTF8(e) {
              for (var t = 0, r = 0; r < e.length; ++r) {
                var _ = e.charCodeAt(r);
                _ <= 127 ? t++ : _ <= 2047 ? t += 2 : _ >= 55296 && _ <= 57343 ? (t += 4, ++r) : t += 3;
              }
              return t;
            }
            __name(lengthBytesUTF8, "lengthBytesUTF8");
            function updateGlobalBufferAndViews(e) {
              buffer = e, Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e);
            }
            __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
            var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432;
            wasmMemory = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({
              initial: INITIAL_MEMORY / 65536,
              maximum: 32768
            }), wasmMemory && (buffer = wasmMemory.buffer), INITIAL_MEMORY = buffer.byteLength, updateGlobalBufferAndViews(buffer);
            var wasmTable = new WebAssembly.Table({
                initial: 20,
                element: "anyfunc"
              }),
              __ATPRERUN__ = [],
              __ATINIT__ = [],
              __ATMAIN__ = [],
              __ATPOSTRUN__ = [],
              __RELOC_FUNCS__ = [],
              runtimeInitialized = !1;
            function keepRuntimeAlive() {
              return noExitRuntime;
            }
            __name(keepRuntimeAlive, "keepRuntimeAlive");
            function preRun() {
              if (Module.preRun) for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length;) addOnPreRun(Module.preRun.shift());
              callRuntimeCallbacks(__ATPRERUN__);
            }
            __name(preRun, "preRun");
            function initRuntime() {
              runtimeInitialized = !0, callRuntimeCallbacks(__RELOC_FUNCS__), callRuntimeCallbacks(__ATINIT__);
            }
            __name(initRuntime, "initRuntime");
            function preMain() {
              callRuntimeCallbacks(__ATMAIN__);
            }
            __name(preMain, "preMain");
            function postRun() {
              if (Module.postRun) for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length;) addOnPostRun(Module.postRun.shift());
              callRuntimeCallbacks(__ATPOSTRUN__);
            }
            __name(postRun, "postRun");
            function addOnPreRun(e) {
              __ATPRERUN__.unshift(e);
            }
            __name(addOnPreRun, "addOnPreRun");
            function addOnInit(e) {
              __ATINIT__.unshift(e);
            }
            __name(addOnInit, "addOnInit");
            function addOnPostRun(e) {
              __ATPOSTRUN__.unshift(e);
            }
            __name(addOnPostRun, "addOnPostRun");
            var runDependencies = 0,
              runDependencyWatcher = null,
              dependenciesFulfilled = null;
            function addRunDependency(e) {
              runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies);
            }
            __name(addRunDependency, "addRunDependency");
            function removeRunDependency(e) {
              if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), runDependencies == 0 && (runDependencyWatcher !== null && (clearInterval(runDependencyWatcher), runDependencyWatcher = null), dependenciesFulfilled)) {
                var t = dependenciesFulfilled;
                dependenciesFulfilled = null, t();
              }
            }
            __name(removeRunDependency, "removeRunDependency");
            function abort(e) {
              throw Module.onAbort && Module.onAbort(e), err(e = "Aborted(" + e + ")"), ABORT = !0, EXITSTATUS = 1, e += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(e);
            }
            __name(abort, "abort");
            var dataURIPrefix = "data:application/octet-stream;base64,",
              wasmBinaryFile,
              tempDouble,
              tempI64;
            function isDataURI(e) {
              return e.startsWith(dataURIPrefix);
            }
            __name(isDataURI, "isDataURI");
            function isFileURI(e) {
              return e.startsWith("file://");
            }
            __name(isFileURI, "isFileURI");
            function getBinary(e) {
              try {
                if (e == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                if (readBinary) return readBinary(e);
                throw "both async and sync fetching of the wasm failed";
              } catch (e) {
                abort(e);
              }
            }
            __name(getBinary, "getBinary");
            function getBinaryPromise() {
              if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                  credentials: "same-origin"
                }).then(function (e) {
                  if (!e.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                  return e.arrayBuffer();
                }).catch(function () {
                  return getBinary(wasmBinaryFile);
                });
                if (readAsync) return new Promise(function (e, t) {
                  readAsync(wasmBinaryFile, function (t) {
                    e(new Uint8Array(t));
                  }, t);
                });
              }
              return Promise.resolve().then(function () {
                return getBinary(wasmBinaryFile);
              });
            }
            __name(getBinaryPromise, "getBinaryPromise");
            function createWasm() {
              var e = {
                env: asmLibraryArg,
                wasi_snapshot_preview1: asmLibraryArg,
                "GOT.mem": new Proxy(asmLibraryArg, GOTHandler),
                "GOT.func": new Proxy(asmLibraryArg, GOTHandler)
              };
              function t(e, t) {
                var r = e.exports;
                r = relocateExports(r, 1024);
                var _ = getDylinkMetadata(t);
                _.neededDynlibs && (dynamicLibraries = _.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(r, "main"), Module.asm = r, addOnInit(Module.asm.__wasm_call_ctors), __RELOC_FUNCS__.push(Module.asm.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate");
              }
              __name(t, "t");
              function r(e) {
                t(e.instance, e.module);
              }
              __name(r, "r");
              function _(t) {
                return getBinaryPromise().then(function (t) {
                  return WebAssembly.instantiate(t, e);
                }).then(function (e) {
                  return e;
                }).then(t, function (e) {
                  err("failed to asynchronously prepare wasm: " + e), abort(e);
                });
              }
              if (__name(_, "_"), addRunDependency("wasm-instantiate"), Module.instantiateWasm) try {
                return Module.instantiateWasm(e, t);
              } catch (e) {
                return err("Module.instantiateWasm callback failed with error: " + e), !1;
              }
              return wasmBinary || typeof WebAssembly.instantiateStreaming != "function" || isDataURI(wasmBinaryFile) || isFileURI(wasmBinaryFile) || ENVIRONMENT_IS_NODE || typeof fetch != "function" ? _(r) : fetch(wasmBinaryFile, {
                credentials: "same-origin"
              }).then(function (t) {
                return WebAssembly.instantiateStreaming(t, e).then(r, function (e) {
                  return err("wasm streaming compile failed: " + e), err("falling back to ArrayBuffer instantiation"), _(r);
                });
              }), {};
            }
            __name(createWasm, "createWasm"), wasmBinaryFile = "tree-sitter.wasm", isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile));
            var ASM_CONSTS = {};
            function ExitStatus(e) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e;
            }
            __name(ExitStatus, "ExitStatus");
            var GOT = {},
              CurrentModuleWeakSymbols = new Set([]),
              GOTHandler = {
                get: function (e, t) {
                  var r = GOT[t];
                  return r || (r = GOT[t] = new WebAssembly.Global({
                    value: "i32",
                    mutable: !0
                  })), CurrentModuleWeakSymbols.has(t) || (r.required = !0), r;
                }
              };
            function callRuntimeCallbacks(e) {
              for (; e.length > 0;) e.shift()(Module);
            }
            __name(callRuntimeCallbacks, "callRuntimeCallbacks");
            function getDylinkMetadata(e) {
              var t = 0,
                r = 0;
              function _() {
                for (var r = 0, _ = 1;;) {
                  var n = e[t++];
                  if (r += (127 & n) * _, _ *= 128, !(128 & n)) break;
                }
                return r;
              }
              __name(_, "_");
              function n() {
                var r = _();
                return UTF8ArrayToString(e, (t += r) - r, r);
              }
              __name(n, "n");
              function s(e, t) {
                if (e) throw new Error(t);
              }
              __name(s, "s");
              var a = "dylink.0";
              if (e instanceof WebAssembly.Module) {
                var o = WebAssembly.Module.customSections(e, a);
                o.length === 0 && (a = "dylink", o = WebAssembly.Module.customSections(e, a)), s(o.length === 0, "need dylink section"), r = (e = new Uint8Array(o[0])).length;
              } else {
                s(new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0] != 1836278016, "need to see wasm magic number"), s(e[8] !== 0, "need the dylink section to be first"), t = 9;
                var i = _();
                r = t + i, a = n();
              }
              var l = {
                neededDynlibs: [],
                tlsExports: new Set(),
                weakImports: new Set()
              };
              if (a == "dylink") {
                l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();
                for (var u = _(), d = 0; d < u; ++d) {
                  var c = n();
                  l.neededDynlibs.push(c);
                }
              } else for (s(a !== "dylink.0"); t < r;) {
                var m = e[t++],
                  p = _();
                if (m === 1) l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();else if (m === 2) for (u = _(), d = 0; d < u; ++d) c = n(), l.neededDynlibs.push(c);else if (m === 3) for (var f = _(); f--;) {
                  var h = n();
                  256 & _() && l.tlsExports.add(h);
                } else if (m === 4) for (f = _(); f--;) n(), h = n(), (3 & _()) == 1 && l.weakImports.add(h);else t += p;
              }
              return l;
            }
            __name(getDylinkMetadata, "getDylinkMetadata");
            function getValue(e, t = "i8") {
              switch (t.endsWith("*") && (t = "*"), t) {
                case "i1":
                case "i8":
                  return HEAP8[e >> 0];
                case "i16":
                  return HEAP16[e >> 1];
                case "i32":
                case "i64":
                  return HEAP32[e >> 2];
                case "float":
                  return HEAPF32[e >> 2];
                case "double":
                  return HEAPF64[e >> 3];
                case "*":
                  return HEAPU32[e >> 2];
                default:
                  abort("invalid type for getValue: " + t);
              }
              return null;
            }
            __name(getValue, "getValue");
            function asmjsMangle(e) {
              return e.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"].includes(e) ? e : "_" + e;
            }
            __name(asmjsMangle, "asmjsMangle");
            function mergeLibSymbols(e, t) {
              for (var r in e) if (e.hasOwnProperty(r)) {
                asmLibraryArg.hasOwnProperty(r) || (asmLibraryArg[r] = e[r]);
                var _ = asmjsMangle(r);
                Module.hasOwnProperty(_) || (Module[_] = e[r]), r == "__main_argc_argv" && (Module._main = e[r]);
              }
            }
            __name(mergeLibSymbols, "mergeLibSymbols");
            var LDSO = {
              loadedLibsByName: {},
              loadedLibsByHandle: {}
            };
            function dynCallLegacy(e, t, r) {
              var _ = Module["dynCall_" + e];
              return r && r.length ? _.apply(null, [t].concat(r)) : _.call(null, t);
            }
            __name(dynCallLegacy, "dynCallLegacy");
            var wasmTableMirror = [];
            function getWasmTableEntry(e) {
              var t = wasmTableMirror[e];
              return t || (e >= wasmTableMirror.length && (wasmTableMirror.length = e + 1), wasmTableMirror[e] = t = wasmTable.get(e)), t;
            }
            __name(getWasmTableEntry, "getWasmTableEntry");
            function dynCall(e, t, r) {
              return e.includes("j") ? dynCallLegacy(e, t, r) : getWasmTableEntry(t).apply(null, r);
            }
            __name(dynCall, "dynCall");
            function createInvokeFunction(e) {
              return function () {
                var t = stackSave();
                try {
                  return dynCall(e, arguments[0], Array.prototype.slice.call(arguments, 1));
                } catch (e) {
                  if (stackRestore(t), e !== e + 0) throw e;
                  _setThrew(1, 0);
                }
              };
            }
            __name(createInvokeFunction, "createInvokeFunction");
            var ___heap_base = 78144;
            function zeroMemory(e, t) {
              return HEAPU8.fill(0, e, e + t), e;
            }
            __name(zeroMemory, "zeroMemory");
            function getMemory(e) {
              if (runtimeInitialized) return zeroMemory(_malloc(e), e);
              var t = ___heap_base,
                r = t + e + 15 & -16;
              return ___heap_base = r, GOT.__heap_base.value = r, t;
            }
            __name(getMemory, "getMemory");
            function isInternalSym(e) {
              return ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm"].includes(e);
            }
            __name(isInternalSym, "isInternalSym");
            function uleb128Encode(e, t) {
              e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
            }
            __name(uleb128Encode, "uleb128Encode");
            function sigToWasmTypes(e) {
              for (var t = {
                  i: "i32",
                  j: "i32",
                  f: "f32",
                  d: "f64",
                  p: "i32"
                }, r = {
                  parameters: [],
                  results: e[0] == "v" ? [] : [t[e[0]]]
                }, _ = 1; _ < e.length; ++_) r.parameters.push(t[e[_]]), e[_] === "j" && r.parameters.push("i32");
              return r;
            }
            __name(sigToWasmTypes, "sigToWasmTypes");
            function generateFuncType(e, t) {
              var r = e.slice(0, 1),
                _ = e.slice(1),
                n = {
                  i: 127,
                  p: 127,
                  j: 126,
                  f: 125,
                  d: 124
                };
              t.push(96), uleb128Encode(_.length, t);
              for (var s = 0; s < _.length; ++s) t.push(n[_[s]]);
              r == "v" ? t.push(0) : t.push(1, n[r]);
            }
            __name(generateFuncType, "generateFuncType");
            function convertJsFunctionToWasm(e, t) {
              if (typeof WebAssembly.Function == "function") return new WebAssembly.Function(sigToWasmTypes(t), e);
              var r = [1];
              generateFuncType(t, r);
              var _ = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              uleb128Encode(r.length, _), _.push.apply(_, r), _.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              var n = new WebAssembly.Module(new Uint8Array(_));
              return new WebAssembly.Instance(n, {
                e: {
                  f: e
                }
              }).exports.f;
            }
            __name(convertJsFunctionToWasm, "convertJsFunctionToWasm");
            function updateTableMap(e, t) {
              if (functionsInTableMap) for (var r = e; r < e + t; r++) {
                var _ = getWasmTableEntry(r);
                _ && functionsInTableMap.set(_, r);
              }
            }
            __name(updateTableMap, "updateTableMap");
            var functionsInTableMap = void 0,
              freeTableIndexes = [];
            function getEmptyTableSlot() {
              if (freeTableIndexes.length) return freeTableIndexes.pop();
              try {
                wasmTable.grow(1);
              } catch (e) {
                throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
              }
              return wasmTable.length - 1;
            }
            __name(getEmptyTableSlot, "getEmptyTableSlot");
            function setWasmTableEntry(e, t) {
              wasmTable.set(e, t), wasmTableMirror[e] = wasmTable.get(e);
            }
            __name(setWasmTableEntry, "setWasmTableEntry");
            function addFunction(e, t) {
              if (functionsInTableMap || (functionsInTableMap = new WeakMap(), updateTableMap(0, wasmTable.length)), functionsInTableMap.has(e)) return functionsInTableMap.get(e);
              var r = getEmptyTableSlot();
              try {
                setWasmTableEntry(r, e);
              } catch (_) {
                if (!(_ instanceof TypeError)) throw _;
                setWasmTableEntry(r, convertJsFunctionToWasm(e, t));
              }
              return functionsInTableMap.set(e, r), r;
            }
            __name(addFunction, "addFunction");
            function updateGOT(e, t) {
              for (var r in e) if (!isInternalSym(r)) {
                var _ = e[r];
                r.startsWith("orig$") && (r = r.split("$")[1], t = !0), GOT[r] || (GOT[r] = new WebAssembly.Global({
                  value: "i32",
                  mutable: !0
                })), (t || GOT[r].value == 0) && (typeof _ == "function" ? GOT[r].value = addFunction(_) : typeof _ == "number" ? GOT[r].value = _ : err("unhandled export type for `" + r + "`: " + typeof _));
              }
            }
            __name(updateGOT, "updateGOT");
            function relocateExports(e, t, r) {
              var _ = {};
              for (var n in e) {
                var s = e[n];
                typeof s == "object" && (s = s.value), typeof s == "number" && (s += t), _[n] = s;
              }
              return updateGOT(_, r), _;
            }
            __name(relocateExports, "relocateExports");
            function resolveGlobalSymbol(e, t) {
              var r;
              return t && (r = asmLibraryArg["orig$" + e]), r || (r = asmLibraryArg[e]) && r.stub && (r = void 0), r || (r = Module[asmjsMangle(e)]), !r && e.startsWith("invoke_") && (r = createInvokeFunction(e.split("_")[1])), r;
            }
            __name(resolveGlobalSymbol, "resolveGlobalSymbol");
            function alignMemory(e, t) {
              return Math.ceil(e / t) * t;
            }
            __name(alignMemory, "alignMemory");
            function loadWebAssemblyModule(binary, flags, handle) {
              var metadata = getDylinkMetadata(binary);
              function loadModule() {
                var firstLoad = !handle || !HEAP8[handle + 12 >> 0];
                if (firstLoad) {
                  var memAlign = Math.pow(2, metadata.memoryAlign);
                  memAlign = Math.max(memAlign, STACK_ALIGN);
                  var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0,
                    tableBase = metadata.tableSize ? wasmTable.length : 0;
                  handle && (HEAP8[handle + 12 >> 0] = 1, HEAPU32[handle + 16 >> 2] = memoryBase, HEAP32[handle + 20 >> 2] = metadata.memorySize, HEAPU32[handle + 24 >> 2] = tableBase, HEAP32[handle + 28 >> 2] = metadata.tableSize);
                } else memoryBase = HEAPU32[handle + 16 >> 2], tableBase = HEAPU32[handle + 24 >> 2];
                var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length,
                  moduleExports;
                function resolveSymbol(e) {
                  var t = resolveGlobalSymbol(e, !1);
                  return t || (t = moduleExports[e]), t;
                }
                __name(resolveSymbol, "resolveSymbol"), tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
                var proxyHandler = {
                    get: function (e, t) {
                      switch (t) {
                        case "__memory_base":
                          return memoryBase;
                        case "__table_base":
                          return tableBase;
                      }
                      if (t in asmLibraryArg) return asmLibraryArg[t];
                      var r;
                      return t in e || (e[t] = function () {
                        return r || (r = resolveSymbol(t)), r.apply(null, arguments);
                      }), e[t];
                    }
                  },
                  proxy = new Proxy({}, proxyHandler),
                  info = {
                    "GOT.mem": new Proxy({}, GOTHandler),
                    "GOT.func": new Proxy({}, GOTHandler),
                    env: proxy,
                    wasi_snapshot_preview1: proxy
                  };
                function postInstantiation(instance) {
                  function addEmAsm(addr, body) {
                    for (var args = [], arity = 0; arity < 16 && body.indexOf("$" + arity) != -1; arity++) args.push("$" + arity);
                    args = args.join(",");
                    var func = "(" + args + " ) => { " + body + "};";
                    ASM_CONSTS[start] = eval(func);
                  }
                  if (__name(addEmAsm, "addEmAsm"), updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols(), "__start_em_asm" in moduleExports) for (var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start < stop;) {
                    var jsString = UTF8ToString(start);
                    addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
                  }
                  var applyRelocs = moduleExports.__wasm_apply_data_relocs;
                  applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
                  var init = moduleExports.__wasm_call_ctors;
                  return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
                }
                if (__name(postInstantiation, "postInstantiation"), flags.loadAsync) {
                  if (binary instanceof WebAssembly.Module) {
                    var instance = new WebAssembly.Instance(binary, info);
                    return Promise.resolve(postInstantiation(instance));
                  }
                  return WebAssembly.instantiate(binary, info).then(function (e) {
                    return postInstantiation(e.instance);
                  });
                }
                var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
                  instance = new WebAssembly.Instance(module, info);
                return postInstantiation(instance);
              }
              return __name(loadModule, "loadModule"), CurrentModuleWeakSymbols = metadata.weakImports, flags.loadAsync ? metadata.neededDynlibs.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, flags);
                });
              }, Promise.resolve()).then(function () {
                return loadModule();
              }) : (metadata.neededDynlibs.forEach(function (e) {
                loadDynamicLibrary(e, flags);
              }), loadModule());
            }
            __name(loadWebAssemblyModule, "loadWebAssemblyModule");
            function loadDynamicLibrary(e, t, r) {
              t = t || {
                global: !0,
                nodelete: !0
              };
              var _ = LDSO.loadedLibsByName[e];
              if (_) return t.global && !_.global && (_.global = !0, _.module !== "loading" && mergeLibSymbols(_.module, e)), t.nodelete && _.refcount !== 1 / 0 && (_.refcount = 1 / 0), _.refcount++, r && (LDSO.loadedLibsByHandle[r] = _), !t.loadAsync || Promise.resolve(!0);
              function n(e) {
                if (t.fs && t.fs.findObject(e)) {
                  var r = t.fs.readFile(e, {
                    encoding: "binary"
                  });
                  return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r;
                }
                if (e = locateFile(e), t.loadAsync) return new Promise(function (t, r) {
                  readAsync(e, e => t(new Uint8Array(e)), r);
                });
                if (!readBinary) throw new Error(e + ": file not found, and synchronous loading of external files is not available");
                return readBinary(e);
              }
              __name(n, "n");
              function s() {
                if (typeof preloadedWasm < "u" && preloadedWasm[e]) {
                  var _ = preloadedWasm[e];
                  return t.loadAsync ? Promise.resolve(_) : _;
                }
                return t.loadAsync ? n(e).then(function (e) {
                  return loadWebAssemblyModule(e, t, r);
                }) : loadWebAssemblyModule(n(e), t, r);
              }
              __name(s, "s");
              function a(t) {
                _.global && mergeLibSymbols(t, e), _.module = t;
              }
              return __name(a, "a"), _ = {
                refcount: t.nodelete ? 1 / 0 : 1,
                name: e,
                module: "loading",
                global: t.global
              }, LDSO.loadedLibsByName[e] = _, r && (LDSO.loadedLibsByHandle[r] = _), t.loadAsync ? s().then(function (e) {
                return a(e), !0;
              }) : (a(s()), !0);
            }
            __name(loadDynamicLibrary, "loadDynamicLibrary");
            function reportUndefinedSymbols() {
              for (var e in GOT) if (GOT[e].value == 0) {
                var t = resolveGlobalSymbol(e, !0);
                if (!t && !GOT[e].required) continue;
                if (typeof t == "function") GOT[e].value = addFunction(t, t.sig);else {
                  if (typeof t != "number") throw new Error("bad export type for `" + e + "`: " + typeof t);
                  GOT[e].value = t;
                }
              }
            }
            __name(reportUndefinedSymbols, "reportUndefinedSymbols");
            function preloadDylibs() {
              dynamicLibraries.length ? (addRunDependency("preloadDylibs"), dynamicLibraries.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, {
                    loadAsync: !0,
                    global: !0,
                    nodelete: !0,
                    allowUndefined: !0
                  });
                });
              }, Promise.resolve()).then(function () {
                reportUndefinedSymbols(), removeRunDependency("preloadDylibs");
              })) : reportUndefinedSymbols();
            }
            __name(preloadDylibs, "preloadDylibs");
            function setValue(e, t, r = "i8") {
              switch (r.endsWith("*") && (r = "*"), r) {
                case "i1":
                case "i8":
                  HEAP8[e >> 0] = t;
                  break;
                case "i16":
                  HEAP16[e >> 1] = t;
                  break;
                case "i32":
                  HEAP32[e >> 2] = t;
                  break;
                case "i64":
                  tempI64 = [t >>> 0, (tempDouble = t, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[e >> 2] = tempI64[0], HEAP32[e + 4 >> 2] = tempI64[1];
                  break;
                case "float":
                  HEAPF32[e >> 2] = t;
                  break;
                case "double":
                  HEAPF64[e >> 3] = t;
                  break;
                case "*":
                  HEAPU32[e >> 2] = t;
                  break;
                default:
                  abort("invalid type for setValue: " + r);
              }
            }
            __name(setValue, "setValue");
            var ___memory_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1024),
              ___stack_pointer = new WebAssembly.Global({
                value: "i32",
                mutable: !0
              }, 78144),
              ___table_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1),
              nowIsMonotonic = !0,
              _emscripten_get_now;
            function __emscripten_get_now_is_monotonic() {
              return nowIsMonotonic;
            }
            __name(__emscripten_get_now_is_monotonic, "__emscripten_get_now_is_monotonic");
            function _abort() {
              abort("");
            }
            __name(_abort, "_abort");
            function _emscripten_date_now() {
              return Date.now();
            }
            __name(_emscripten_date_now, "_emscripten_date_now");
            function _emscripten_memcpy_big(e, t, r) {
              HEAPU8.copyWithin(e, t, t + r);
            }
            __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
            function getHeapMax() {
              return 2147483648;
            }
            __name(getHeapMax, "getHeapMax");
            function emscripten_realloc_buffer(e) {
              try {
                return wasmMemory.grow(e - buffer.byteLength + 65535 >>> 16), updateGlobalBufferAndViews(wasmMemory.buffer), 1;
              } catch {}
            }
            __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
            function _emscripten_resize_heap(e) {
              var t = HEAPU8.length;
              e >>>= 0;
              var r = getHeapMax();
              if (e > r) return !1;
              for (var _ = 1; _ <= 4; _ *= 2) {
                var n = t * (1 + .2 / _);
                if (n = Math.min(n, e + 100663296), emscripten_realloc_buffer(Math.min(r, (s = Math.max(e, n)) + ((a = 65536) - s % a) % a))) return !0;
              }
              var s, a;
              return !1;
            }
            __name(_emscripten_resize_heap, "_emscripten_resize_heap"), __emscripten_get_now_is_monotonic.sig = "i", Module._abort = _abort, _abort.sig = "v", _emscripten_date_now.sig = "d", _emscripten_get_now = ENVIRONMENT_IS_NODE ? () => {
              var e = process.hrtime();
              return 1e3 * e[0] + e[1] / 1e6;
            } : () => performance.now(), _emscripten_get_now.sig = "d", _emscripten_memcpy_big.sig = "vppp", _emscripten_resize_heap.sig = "ip";
            var SYSCALLS = {
              DEFAULT_POLLMASK: 5,
              calculateAt: function (e, t, r) {
                if (PATH.isAbs(t)) return t;
                var _;
                if (e === -100 ? _ = FS.cwd() : _ = SYSCALLS.getStreamFromFD(e).path, t.length == 0) {
                  if (!r) throw new FS.ErrnoError(44);
                  return _;
                }
                return PATH.join2(_, t);
              },
              doStat: function (e, t, r) {
                try {
                  var _ = e(t);
                } catch (e) {
                  if (e && e.node && PATH.normalize(t) !== PATH.normalize(FS.getPath(e.node))) return -54;
                  throw e;
                }
                HEAP32[r >> 2] = _.dev, HEAP32[r + 8 >> 2] = _.ino, HEAP32[r + 12 >> 2] = _.mode, HEAPU32[r + 16 >> 2] = _.nlink, HEAP32[r + 20 >> 2] = _.uid, HEAP32[r + 24 >> 2] = _.gid, HEAP32[r + 28 >> 2] = _.rdev, tempI64 = [_.size >>> 0, (tempDouble = _.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 40 >> 2] = tempI64[0], HEAP32[r + 44 >> 2] = tempI64[1], HEAP32[r + 48 >> 2] = 4096, HEAP32[r + 52 >> 2] = _.blocks;
                var n = _.atime.getTime(),
                  s = _.mtime.getTime(),
                  a = _.ctime.getTime();
                return tempI64 = [Math.floor(n / 1e3) >>> 0, (tempDouble = Math.floor(n / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 56 >> 2] = tempI64[0], HEAP32[r + 60 >> 2] = tempI64[1], HEAPU32[r + 64 >> 2] = n % 1e3 * 1e3, tempI64 = [Math.floor(s / 1e3) >>> 0, (tempDouble = Math.floor(s / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 72 >> 2] = tempI64[0], HEAP32[r + 76 >> 2] = tempI64[1], HEAPU32[r + 80 >> 2] = s % 1e3 * 1e3, tempI64 = [Math.floor(a / 1e3) >>> 0, (tempDouble = Math.floor(a / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 88 >> 2] = tempI64[0], HEAP32[r + 92 >> 2] = tempI64[1], HEAPU32[r + 96 >> 2] = a % 1e3 * 1e3, tempI64 = [_.ino >>> 0, (tempDouble = _.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 104 >> 2] = tempI64[0], HEAP32[r + 108 >> 2] = tempI64[1], 0;
              },
              doMsync: function (e, t, r, _, n) {
                if (!FS.isFile(t.node.mode)) throw new FS.ErrnoError(43);
                if (2 & _) return 0;
                var s = HEAPU8.slice(e, e + r);
                FS.msync(t, s, n, r, _);
              },
              varargs: void 0,
              get: function () {
                return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2];
              },
              getStr: function (e) {
                return UTF8ToString(e);
              },
              getStreamFromFD: function (e) {
                var t = FS.getStream(e);
                if (!t) throw new FS.ErrnoError(8);
                return t;
              }
            };
            function _proc_exit(e) {
              EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit && Module.onExit(e), ABORT = !0), quit_(e, new ExitStatus(e));
            }
            __name(_proc_exit, "_proc_exit");
            function exitJS(e, t) {
              EXITSTATUS = e, _proc_exit(e);
            }
            __name(exitJS, "exitJS"), _proc_exit.sig = "vi";
            var _exit = exitJS;
            function _fd_close(e) {
              try {
                var t = SYSCALLS.getStreamFromFD(e);
                return FS.close(t), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_close, "_fd_close");
            function convertI32PairToI53Checked(e, t) {
              return t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN;
            }
            __name(convertI32PairToI53Checked, "convertI32PairToI53Checked");
            function _fd_seek(e, t, r, _, n) {
              try {
                var s = convertI32PairToI53Checked(t, r);
                if (isNaN(s)) return 61;
                var a = SYSCALLS.getStreamFromFD(e);
                return FS.llseek(a, s, _), tempI64 = [a.position >>> 0, (tempDouble = a.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[n >> 2] = tempI64[0], HEAP32[n + 4 >> 2] = tempI64[1], a.getdents && s === 0 && _ === 0 && (a.getdents = null), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_seek, "_fd_seek");
            function doWritev(e, t, r, _) {
              for (var n = 0, s = 0; s < r; s++) {
                var a = HEAPU32[t >> 2],
                  o = HEAPU32[t + 4 >> 2];
                t += 8;
                var i = FS.write(e, HEAP8, a, o, _);
                if (i < 0) return -1;
                n += i, _ !== void 0 && (_ += i);
              }
              return n;
            }
            __name(doWritev, "doWritev");
            function _fd_write(e, t, r, _) {
              try {
                var n = doWritev(SYSCALLS.getStreamFromFD(e), t, r);
                return HEAPU32[_ >> 2] = n, 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_write, "_fd_write");
            function _tree_sitter_log_callback(e, t) {
              if (currentLogCallback) {
                let r = UTF8ToString(t);
                currentLogCallback(r, e !== 0);
              }
            }
            __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
            function _tree_sitter_parse_callback(e, t, r, _, n) {
              var s = currentParseCallback(t, {
                row: r,
                column: _
              });
              typeof s == "string" ? (setValue(n, s.length, "i32"), stringToUTF16(s, e, 10240)) : setValue(n, 0, "i32");
            }
            __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
            function handleException(e) {
              if (e instanceof ExitStatus || e == "unwind") return EXITSTATUS;
              quit_(1, e);
            }
            __name(handleException, "handleException");
            function allocateUTF8OnStack(e) {
              var t = lengthBytesUTF8(e) + 1,
                r = stackAlloc(t);
              return stringToUTF8Array(e, HEAP8, r, t), r;
            }
            __name(allocateUTF8OnStack, "allocateUTF8OnStack");
            function stringToUTF16(e, t, r) {
              if (r === void 0 && (r = 2147483647), r < 2) return 0;
              for (var _ = t, n = (r -= 2) < 2 * e.length ? r / 2 : e.length, s = 0; s < n; ++s) {
                var a = e.charCodeAt(s);
                HEAP16[t >> 1] = a, t += 2;
              }
              return HEAP16[t >> 1] = 0, t - _;
            }
            __name(stringToUTF16, "stringToUTF16");
            function AsciiToString(e) {
              for (var t = "";;) {
                var r = HEAPU8[e++ >> 0];
                if (!r) return t;
                t += String.fromCharCode(r);
              }
            }
            __name(AsciiToString, "AsciiToString"), _exit.sig = "vi", _fd_close.sig = "ii", _fd_seek.sig = "iijip", _fd_write.sig = "iippp";
            var asmLibraryArg = {
                __heap_base: ___heap_base,
                __indirect_function_table: wasmTable,
                __memory_base: ___memory_base,
                __stack_pointer: ___stack_pointer,
                __table_base: ___table_base,
                _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
                abort: _abort,
                emscripten_get_now: _emscripten_get_now,
                emscripten_memcpy_big: _emscripten_memcpy_big,
                emscripten_resize_heap: _emscripten_resize_heap,
                exit: _exit,
                fd_close: _fd_close,
                fd_seek: _fd_seek,
                fd_write: _fd_write,
                memory: wasmMemory,
                tree_sitter_log_callback: _tree_sitter_log_callback,
                tree_sitter_parse_callback: _tree_sitter_parse_callback
              },
              asm = createWasm(),
              ___wasm_call_ctors = Module.___wasm_call_ctors = function () {
                return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
              },
              ___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = function () {
                return (___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = Module.asm.__wasm_apply_data_relocs).apply(null, arguments);
              },
              _malloc = Module._malloc = function () {
                return (_malloc = Module._malloc = Module.asm.malloc).apply(null, arguments);
              },
              _calloc = Module._calloc = function () {
                return (_calloc = Module._calloc = Module.asm.calloc).apply(null, arguments);
              },
              _realloc = Module._realloc = function () {
                return (_realloc = Module._realloc = Module.asm.realloc).apply(null, arguments);
              },
              _free = Module._free = function () {
                return (_free = Module._free = Module.asm.free).apply(null, arguments);
              },
              _ts_language_symbol_count = Module._ts_language_symbol_count = function () {
                return (_ts_language_symbol_count = Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
              },
              _ts_language_version = Module._ts_language_version = function () {
                return (_ts_language_version = Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
              },
              _ts_language_field_count = Module._ts_language_field_count = function () {
                return (_ts_language_field_count = Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
              },
              _ts_language_symbol_name = Module._ts_language_symbol_name = function () {
                return (_ts_language_symbol_name = Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
              },
              _ts_language_symbol_for_name = Module._ts_language_symbol_for_name = function () {
                return (_ts_language_symbol_for_name = Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
              },
              _ts_language_symbol_type = Module._ts_language_symbol_type = function () {
                return (_ts_language_symbol_type = Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
              },
              _ts_language_field_name_for_id = Module._ts_language_field_name_for_id = function () {
                return (_ts_language_field_name_for_id = Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
              },
              _memset = Module._memset = function () {
                return (_memset = Module._memset = Module.asm.memset).apply(null, arguments);
              },
              _memcpy = Module._memcpy = function () {
                return (_memcpy = Module._memcpy = Module.asm.memcpy).apply(null, arguments);
              },
              _ts_parser_delete = Module._ts_parser_delete = function () {
                return (_ts_parser_delete = Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
              },
              _ts_parser_reset = Module._ts_parser_reset = function () {
                return (_ts_parser_reset = Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
              },
              _ts_parser_set_language = Module._ts_parser_set_language = function () {
                return (_ts_parser_set_language = Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
              },
              _ts_parser_timeout_micros = Module._ts_parser_timeout_micros = function () {
                return (_ts_parser_timeout_micros = Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
              },
              _ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = function () {
                return (_ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
              },
              _memmove = Module._memmove = function () {
                return (_memmove = Module._memmove = Module.asm.memmove).apply(null, arguments);
              },
              _memcmp = Module._memcmp = function () {
                return (_memcmp = Module._memcmp = Module.asm.memcmp).apply(null, arguments);
              },
              _ts_query_new = Module._ts_query_new = function () {
                return (_ts_query_new = Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
              },
              _ts_query_delete = Module._ts_query_delete = function () {
                return (_ts_query_delete = Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
              },
              _iswspace = Module._iswspace = function () {
                return (_iswspace = Module._iswspace = Module.asm.iswspace).apply(null, arguments);
              },
              _iswalnum = Module._iswalnum = function () {
                return (_iswalnum = Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
              },
              _ts_query_pattern_count = Module._ts_query_pattern_count = function () {
                return (_ts_query_pattern_count = Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
              },
              _ts_query_capture_count = Module._ts_query_capture_count = function () {
                return (_ts_query_capture_count = Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
              },
              _ts_query_string_count = Module._ts_query_string_count = function () {
                return (_ts_query_string_count = Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
              },
              _ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = function () {
                return (_ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
              },
              _ts_query_string_value_for_id = Module._ts_query_string_value_for_id = function () {
                return (_ts_query_string_value_for_id = Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
              },
              _ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = function () {
                return (_ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
              },
              _ts_tree_copy = Module._ts_tree_copy = function () {
                return (_ts_tree_copy = Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
              },
              _ts_tree_delete = Module._ts_tree_delete = function () {
                return (_ts_tree_delete = Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
              },
              _ts_init = Module._ts_init = function () {
                return (_ts_init = Module._ts_init = Module.asm.ts_init).apply(null, arguments);
              },
              _ts_parser_new_wasm = Module._ts_parser_new_wasm = function () {
                return (_ts_parser_new_wasm = Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
              },
              _ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = function () {
                return (_ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
              },
              _ts_parser_parse_wasm = Module._ts_parser_parse_wasm = function () {
                return (_ts_parser_parse_wasm = Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
              },
              _ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = function () {
                return (_ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
              },
              _ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = function () {
                return (_ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
              },
              _ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = function () {
                return (_ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
              },
              _ts_tree_edit_wasm = Module._ts_tree_edit_wasm = function () {
                return (_ts_tree_edit_wasm = Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
              },
              _ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = function () {
                return (_ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = function () {
                return (_ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = function () {
                return (_ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = function () {
                return (_ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = function () {
                return (_ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = function () {
                return (_ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = function () {
                return (_ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = function () {
                return (_ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = function () {
                return (_ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = function () {
                return (_ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = function () {
                return (_ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = function () {
                return (_ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = function () {
                return (_ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = function () {
                return (_ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = function () {
                return (_ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = function () {
                return (_ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = function () {
                return (_ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
              },
              _ts_node_symbol_wasm = Module._ts_node_symbol_wasm = function () {
                return (_ts_node_symbol_wasm = Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
              },
              _ts_node_child_count_wasm = Module._ts_node_child_count_wasm = function () {
                return (_ts_node_child_count_wasm = Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
              },
              _ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = function () {
                return (_ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
              },
              _ts_node_child_wasm = Module._ts_node_child_wasm = function () {
                return (_ts_node_child_wasm = Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
              },
              _ts_node_named_child_wasm = Module._ts_node_named_child_wasm = function () {
                return (_ts_node_named_child_wasm = Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
              },
              _ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = function () {
                return (_ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
              },
              _ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = function () {
                return (_ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = function () {
                return (_ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
              },
              _ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = function () {
                return (_ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = function () {
                return (_ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_parent_wasm = Module._ts_node_parent_wasm = function () {
                return (_ts_node_parent_wasm = Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = function () {
                return (_ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = function () {
                return (_ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = function () {
                return (_ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = function () {
                return (_ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_start_point_wasm = Module._ts_node_start_point_wasm = function () {
                return (_ts_node_start_point_wasm = Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
              },
              _ts_node_end_point_wasm = Module._ts_node_end_point_wasm = function () {
                return (_ts_node_end_point_wasm = Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
              },
              _ts_node_start_index_wasm = Module._ts_node_start_index_wasm = function () {
                return (_ts_node_start_index_wasm = Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
              },
              _ts_node_end_index_wasm = Module._ts_node_end_index_wasm = function () {
                return (_ts_node_end_index_wasm = Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
              },
              _ts_node_to_string_wasm = Module._ts_node_to_string_wasm = function () {
                return (_ts_node_to_string_wasm = Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
              },
              _ts_node_children_wasm = Module._ts_node_children_wasm = function () {
                return (_ts_node_children_wasm = Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
              },
              _ts_node_named_children_wasm = Module._ts_node_named_children_wasm = function () {
                return (_ts_node_named_children_wasm = Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
              },
              _ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = function () {
                return (_ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
              },
              _ts_node_is_named_wasm = Module._ts_node_is_named_wasm = function () {
                return (_ts_node_is_named_wasm = Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
              },
              _ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = function () {
                return (_ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
              },
              _ts_node_has_error_wasm = Module._ts_node_has_error_wasm = function () {
                return (_ts_node_has_error_wasm = Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
              },
              _ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = function () {
                return (_ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_query_matches_wasm = Module._ts_query_matches_wasm = function () {
                return (_ts_query_matches_wasm = Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
              },
              _ts_query_captures_wasm = Module._ts_query_captures_wasm = function () {
                return (_ts_query_captures_wasm = Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
              },
              ___cxa_atexit = Module.___cxa_atexit = function () {
                return (___cxa_atexit = Module.___cxa_atexit = Module.asm.__cxa_atexit).apply(null, arguments);
              },
              _iswdigit = Module._iswdigit = function () {
                return (_iswdigit = Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
              },
              _iswalpha = Module._iswalpha = function () {
                return (_iswalpha = Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
              },
              _iswlower = Module._iswlower = function () {
                return (_iswlower = Module._iswlower = Module.asm.iswlower).apply(null, arguments);
              },
              _memchr = Module._memchr = function () {
                return (_memchr = Module._memchr = Module.asm.memchr).apply(null, arguments);
              },
              _strlen = Module._strlen = function () {
                return (_strlen = Module._strlen = Module.asm.strlen).apply(null, arguments);
              },
              _towupper = Module._towupper = function () {
                return (_towupper = Module._towupper = Module.asm.towupper).apply(null, arguments);
              },
              _setThrew = Module._setThrew = function () {
                return (_setThrew = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
              },
              stackSave = Module.stackSave = function () {
                return (stackSave = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
              },
              stackRestore = Module.stackRestore = function () {
                return (stackRestore = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
              },
              stackAlloc = Module.stackAlloc = function () {
                return (stackAlloc = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
              },
              __Znwm = Module.__Znwm = function () {
                return (__Znwm = Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
              },
              __ZdlPv = Module.__ZdlPv = function () {
                return (__ZdlPv = Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
              },
              __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {
                return (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw).apply(null, arguments);
              },
              dynCall_jiji = Module.dynCall_jiji = function () {
                return (dynCall_jiji = Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments);
              },
              _orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = function () {
                return (_orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
              },
              _orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = function () {
                return (_orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
              },
              calledRun;
            function callMain(e) {
              var t = Module._main;
              if (t) {
                (e = e || []).unshift(thisProgram);
                var r = e.length,
                  _ = stackAlloc(4 * (r + 1)),
                  n = _ >> 2;
                e.forEach(e => {
                  HEAP32[n++] = allocateUTF8OnStack(e);
                }), HEAP32[n] = 0;
                try {
                  var s = t(r, _);
                  return exitJS(s, !0), s;
                } catch (e) {
                  return handleException(e);
                }
              }
            }
            __name(callMain, "callMain"), Module.AsciiToString = AsciiToString, Module.stringToUTF16 = stringToUTF16, dependenciesFulfilled = __name(function e() {
              calledRun || run(), calledRun || (dependenciesFulfilled = e);
            }, "e");
            var dylibsLoaded = !1;
            function run(e) {
              function t() {
                calledRun || (calledRun = !0, Module.calledRun = !0, ABORT || (initRuntime(), preMain(), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), shouldRunNow && callMain(e), postRun()));
              }
              __name(t, "t"), e = e || arguments_, runDependencies > 0 || !dylibsLoaded && (preloadDylibs(), dylibsLoaded = !0, runDependencies > 0) || (preRun(), runDependencies > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function () {
                setTimeout(function () {
                  Module.setStatus("");
                }, 1), t();
              }, 1)) : t()));
            }
            if (__name(run, "run"), Module.preInit) for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;) Module.preInit.pop()();
            var shouldRunNow = !0;
            Module.noInitialRun && (shouldRunNow = !1), run();
            let C = Module,
              INTERNAL = {},
              SIZE_OF_INT = 4,
              SIZE_OF_NODE = 5 * SIZE_OF_INT,
              SIZE_OF_POINT = 2 * SIZE_OF_INT,
              SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
              ZERO_POINT = {
                row: 0,
                column: 0
              },
              QUERY_WORD_REGEX = /[\w-.]*/g,
              PREDICATE_STEP_TYPE_CAPTURE = 1,
              PREDICATE_STEP_TYPE_STRING = 2,
              LANGUAGE_FUNCTION_REGEX = /^_?tree_sitter_\w+/;
            var VERSION, MIN_COMPATIBLE_VERSION, TRANSFER_BUFFER, currentParseCallback, currentLogCallback;
            class ParserImpl {
              static {
                __name(this, "ParserImpl");
              }
              static init() {
                TRANSFER_BUFFER = C._ts_init(), VERSION = getValue(TRANSFER_BUFFER, "i32"), MIN_COMPATIBLE_VERSION = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              initialize() {
                C._ts_parser_new_wasm(), this[0] = getValue(TRANSFER_BUFFER, "i32"), this[1] = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              delete() {
                C._ts_parser_delete(this[0]), C._free(this[1]), this[0] = 0, this[1] = 0;
              }
              setLanguage(e) {
                let t;
                if (e) {
                  if (e.constructor !== Language) throw new Error("Argument must be a Language");
                  {
                    t = e[0];
                    let r = C._ts_language_version(t);
                    if (r < MIN_COMPATIBLE_VERSION || VERSION < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${VERSION}.`);
                  }
                } else t = 0, e = null;
                return this.language = e, C._ts_parser_set_language(this[0], t), this;
              }
              getLanguage() {
                return this.language;
              }
              parse(e, t, r) {
                if (typeof e == "string") currentParseCallback = __name((t, r, _) => e.slice(t, _), "currentParseCallback");else {
                  if (typeof e != "function") throw new Error("Argument must be a string or a function");
                  currentParseCallback = e;
                }
                this.logCallback ? (currentLogCallback = this.logCallback, C._ts_parser_enable_logger_wasm(this[0], 1)) : (currentLogCallback = null, C._ts_parser_enable_logger_wasm(this[0], 0));
                let _ = 0,
                  n = 0;
                if (r && r.includedRanges) {
                  _ = r.includedRanges.length, n = C._calloc(_, SIZE_OF_RANGE);
                  let e = n;
                  for (let t = 0; t < _; t++) marshalRange(e, r.includedRanges[t]), e += SIZE_OF_RANGE;
                }
                let s = C._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, n, _);
                if (!s) throw currentParseCallback = null, currentLogCallback = null, new Error("Parsing failed");
                let a = new Tree(INTERNAL, s, this.language, currentParseCallback);
                return currentParseCallback = null, currentLogCallback = null, a;
              }
              reset() {
                C._ts_parser_reset(this[0]);
              }
              setTimeoutMicros(e) {
                C._ts_parser_set_timeout_micros(this[0], e);
              }
              getTimeoutMicros() {
                return C._ts_parser_timeout_micros(this[0]);
              }
              setLogger(e) {
                if (e) {
                  if (typeof e != "function") throw new Error("Logger callback must be a function");
                } else e = null;
                return this.logCallback = e, this;
              }
              getLogger() {
                return this.logCallback;
              }
            }
            class Tree {
              static {
                __name(this, "Tree");
              }
              constructor(e, t, r, _) {
                assertInternal(e), this[0] = t, this.language = r, this.textCallback = _;
              }
              copy() {
                let e = C._ts_tree_copy(this[0]);
                return new Tree(INTERNAL, e, this.language, this.textCallback);
              }
              delete() {
                C._ts_tree_delete(this[0]), this[0] = 0;
              }
              edit(e) {
                marshalEdit(e), C._ts_tree_edit_wasm(this[0]);
              }
              get rootNode() {
                return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this);
              }
              getLanguage() {
                return this.language;
              }
              walk() {
                return this.rootNode.walk();
              }
              getChangedRanges(e) {
                if (e.constructor !== Tree) throw new TypeError("Argument must be a Tree");
                C._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                let t = getValue(TRANSFER_BUFFER, "i32"),
                  r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  _ = new Array(t);
                if (t > 0) {
                  let e = r;
                  for (let r = 0; r < t; r++) _[r] = unmarshalRange(e), e += SIZE_OF_RANGE;
                  C._free(r);
                }
                return _;
              }
            }
            class Node {
              static {
                __name(this, "Node");
              }
              constructor(e, t) {
                assertInternal(e), this.tree = t;
              }
              get typeId() {
                return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0]);
              }
              get type() {
                return this.tree.language.types[this.typeId] || "ERROR";
              }
              get endPosition() {
                return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get endIndex() {
                return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0]);
              }
              get text() {
                return getText(this.tree, this.startIndex, this.endIndex);
              }
              isNamed() {
                return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1;
              }
              hasError() {
                return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1;
              }
              hasChanges() {
                return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1;
              }
              isMissing() {
                return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1;
              }
              equals(e) {
                return this.id === e.id;
              }
              child(e) {
                return marshalNode(this), C._ts_node_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              namedChild(e) {
                return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              childForFieldId(e) {
                return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              childForFieldName(e) {
                let t = this.tree.language.fields.indexOf(e);
                if (t !== -1) return this.childForFieldId(t);
              }
              get childCount() {
                return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0]);
              }
              get namedChildCount() {
                return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0]);
              }
              get firstChild() {
                return this.child(0);
              }
              get firstNamedChild() {
                return this.namedChild(0);
              }
              get lastChild() {
                return this.child(this.childCount - 1);
              }
              get lastNamedChild() {
                return this.namedChild(this.namedChildCount - 1);
              }
              get children() {
                if (!this._children) {
                  marshalNode(this), C._ts_node_children_wasm(this.tree[0]);
                  let e = getValue(TRANSFER_BUFFER, "i32"),
                    t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  if (this._children = new Array(e), e > 0) {
                    let r = t;
                    for (let t = 0; t < e; t++) this._children[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                    C._free(t);
                  }
                }
                return this._children;
              }
              get namedChildren() {
                if (!this._namedChildren) {
                  marshalNode(this), C._ts_node_named_children_wasm(this.tree[0]);
                  let e = getValue(TRANSFER_BUFFER, "i32"),
                    t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  if (this._namedChildren = new Array(e), e > 0) {
                    let r = t;
                    for (let t = 0; t < e; t++) this._namedChildren[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                    C._free(t);
                  }
                }
                return this._namedChildren;
              }
              descendantsOfType(e, t, r) {
                Array.isArray(e) || (e = [e]), t || (t = ZERO_POINT), r || (r = ZERO_POINT);
                let _ = [],
                  n = this.tree.language.types;
                for (let t = 0, r = n.length; t < r; t++) e.includes(n[t]) && _.push(t);
                let s = C._malloc(SIZE_OF_INT * _.length);
                for (let e = 0, t = _.length; e < t; e++) setValue(s + e * SIZE_OF_INT, _[e], "i32");
                marshalNode(this), C._ts_node_descendants_of_type_wasm(this.tree[0], s, _.length, t.row, t.column, r.row, r.column);
                let a = getValue(TRANSFER_BUFFER, "i32"),
                  o = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  i = new Array(a);
                if (a > 0) {
                  let e = o;
                  for (let t = 0; t < a; t++) i[t] = unmarshalNode(this.tree, e), e += SIZE_OF_NODE;
                }
                return C._free(o), C._free(s), i;
              }
              get nextSibling() {
                return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get previousSibling() {
                return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get nextNamedSibling() {
                return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get previousNamedSibling() {
                return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get parent() {
                return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              descendantForIndex(e, t = e) {
                if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              namedDescendantForIndex(e, t = e) {
                if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_named_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              descendantForPosition(e, t = e) {
                if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              namedDescendantForPosition(e, t = e) {
                if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_named_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              walk() {
                return marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree);
              }
              toString() {
                marshalNode(this);
                let e = C._ts_node_to_string_wasm(this.tree[0]),
                  t = AsciiToString(e);
                return C._free(e), t;
              }
            }
            class TreeCursor {
              static {
                __name(this, "TreeCursor");
              }
              constructor(e, t) {
                assertInternal(e), this.tree = t, unmarshalTreeCursor(this);
              }
              delete() {
                marshalTreeCursor(this), C._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
              }
              reset(e) {
                marshalNode(e), marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE), C._ts_tree_cursor_reset_wasm(this.tree[0]), unmarshalTreeCursor(this);
              }
              get nodeType() {
                return this.tree.language.types[this.nodeTypeId] || "ERROR";
              }
              get nodeTypeId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
              }
              get nodeId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
              }
              get nodeIsNamed() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
              }
              get nodeIsMissing() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
              }
              get nodeText() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
                  t = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                return getText(this.tree, e, t);
              }
              get startPosition() {
                return marshalTreeCursor(this), C._ts_tree_cursor_start_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get endPosition() {
                return marshalTreeCursor(this), C._ts_tree_cursor_end_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get startIndex() {
                return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0]);
              }
              get endIndex() {
                return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0]);
              }
              currentNode() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              currentFieldId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
              }
              currentFieldName() {
                return this.tree.language.fields[this.currentFieldId()];
              }
              gotoFirstChild() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
              gotoNextSibling() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
              gotoParent() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
            }
            class Language {
              static {
                __name(this, "Language");
              }
              constructor(e, t) {
                assertInternal(e), this[0] = t, this.types = new Array(C._ts_language_symbol_count(this[0]));
                for (let e = 0, t = this.types.length; e < t; e++) C._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = UTF8ToString(C._ts_language_symbol_name(this[0], e)));
                this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
                for (let e = 0, t = this.fields.length; e < t; e++) {
                  let t = C._ts_language_field_name_for_id(this[0], e);
                  this.fields[e] = t !== 0 ? UTF8ToString(t) : null;
                }
              }
              get version() {
                return C._ts_language_version(this[0]);
              }
              get fieldCount() {
                return this.fields.length - 1;
              }
              fieldIdForName(e) {
                let t = this.fields.indexOf(e);
                return t !== -1 ? t : null;
              }
              fieldNameForId(e) {
                return this.fields[e] || null;
              }
              idForNodeType(e, t) {
                let r = lengthBytesUTF8(e),
                  _ = C._malloc(r + 1);
                stringToUTF8(e, _, r + 1);
                let n = C._ts_language_symbol_for_name(this[0], _, r, t);
                return C._free(_), n || null;
              }
              get nodeTypeCount() {
                return C._ts_language_symbol_count(this[0]);
              }
              nodeTypeForId(e) {
                let t = C._ts_language_symbol_name(this[0], e);
                return t ? UTF8ToString(t) : null;
              }
              nodeTypeIsNamed(e) {
                return !!C._ts_language_type_is_named_wasm(this[0], e);
              }
              nodeTypeIsVisible(e) {
                return !!C._ts_language_type_is_visible_wasm(this[0], e);
              }
              query(e) {
                let t = lengthBytesUTF8(e),
                  r = C._malloc(t + 1);
                stringToUTF8(e, r, t + 1);
                let _ = C._ts_query_new(this[0], r, t, TRANSFER_BUFFER, TRANSFER_BUFFER + SIZE_OF_INT);
                if (!_) {
                  let t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    _ = UTF8ToString(r, getValue(TRANSFER_BUFFER, "i32")).length,
                    n = e.substr(_, 100).split(`
`)[0],
                    s,
                    a = n.match(QUERY_WORD_REGEX)[0];
                  switch (t) {
                    case 2:
                      s = new RangeError(`Bad node name '${a}'`);
                      break;
                    case 3:
                      s = new RangeError(`Bad field name '${a}'`);
                      break;
                    case 4:
                      s = new RangeError(`Bad capture name @${a}`);
                      break;
                    case 5:
                      s = new TypeError(`Bad pattern structure at offset ${_}: '${n}'...`), a = "";
                      break;
                    default:
                      s = new SyntaxError(`Bad syntax at offset ${_}: '${n}'...`), a = "";
                  }
                  throw s.index = _, s.length = a.length, C._free(r), s;
                }
                let n = C._ts_query_string_count(_),
                  s = C._ts_query_capture_count(_),
                  a = C._ts_query_pattern_count(_),
                  o = new Array(s),
                  i = new Array(n);
                for (let e = 0; e < s; e++) {
                  let t = C._ts_query_capture_name_for_id(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  o[e] = UTF8ToString(t, r);
                }
                for (let e = 0; e < n; e++) {
                  let t = C._ts_query_string_value_for_id(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  i[e] = UTF8ToString(t, r);
                }
                let l = new Array(a),
                  u = new Array(a),
                  d = new Array(a),
                  c = new Array(a),
                  m = new Array(a);
                for (let e = 0; e < a; e++) {
                  let t = C._ts_query_predicates_for_pattern(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  c[e] = [], m[e] = [];
                  let n = [],
                    s = t;
                  for (let t = 0; t < r; t++) {
                    let t = getValue(s, "i32");
                    s += SIZE_OF_INT;
                    let r = getValue(s, "i32");
                    if (s += SIZE_OF_INT, t === PREDICATE_STEP_TYPE_CAPTURE) n.push({
                      type: "capture",
                      name: o[r]
                    });else if (t === PREDICATE_STEP_TYPE_STRING) n.push({
                      type: "string",
                      value: i[r]
                    });else if (n.length > 0) {
                      if (n[0].type !== "string") throw new Error("Predicates must begin with a literal value");
                      let t = n[0].value,
                        r = !0;
                      switch (t) {
                        case "not-eq?":
                          r = !1;
                        case "eq?":
                          if (n.length !== 3) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (n.length - 1));
                          if (n[1].type !== "capture") throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${n[1].value}"`);
                          if (n[2].type === "capture") {
                            let t = n[1].name,
                              _ = n[2].name;
                            m[e].push(function (e) {
                              let n, s;
                              for (let r of e) r.name === t && (n = r.node), r.name === _ && (s = r.node);
                              return n === void 0 || s === void 0 || n.text === s.text === r;
                            });
                          } else {
                            let t = n[1].name,
                              _ = n[2].value;
                            m[e].push(function (e) {
                              for (let n of e) if (n.name === t) return n.node.text === _ === r;
                              return !0;
                            });
                          }
                          break;
                        case "not-match?":
                          r = !1;
                        case "match?":
                          if (n.length !== 3) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${n.length - 1}.`);
                          if (n[1].type !== "capture") throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${n[1].value}".`);
                          if (n[2].type !== "string") throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${n[2].value}.`);
                          let _ = n[1].name,
                            s = new RegExp(n[2].value);
                          m[e].push(function (e) {
                            for (let t of e) if (t.name === _) return s.test(t.node.text) === r;
                            return !0;
                          });
                          break;
                        case "set!":
                          if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                          if (n.some(e => e.type !== "string")) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                          l[e] || (l[e] = {}), l[e][n[1].value] = n[2] ? n[2].value : null;
                          break;
                        case "is?":
                        case "is-not?":
                          if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                          if (n.some(e => e.type !== "string")) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                          let a = t === "is?" ? u : d;
                          a[e] || (a[e] = {}), a[e][n[1].value] = n[2] ? n[2].value : null;
                          break;
                        default:
                          c[e].push({
                            operator: t,
                            operands: n.slice(1)
                          });
                      }
                      n.length = 0;
                    }
                  }
                  Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e]);
                }
                return C._free(r), new Query(INTERNAL, _, o, m, c, Object.freeze(l), Object.freeze(u), Object.freeze(d));
              }
              static load(e) {
                let t;
                if (e instanceof Uint8Array) t = Promise.resolve(e);else {
                  let r = e;
                  if (typeof process < "u" && process.versions && process.versions.node) {
                    let e = require("fs");
                    t = Promise.resolve(e.readFileSync(r));
                  } else t = fetch(r).then(e => e.arrayBuffer().then(t => {
                    if (e.ok) return new Uint8Array(t);
                    {
                      let r = new TextDecoder("utf-8").decode(t);
                      throw new Error(`Language.load failed with status ${e.status}.

${r}`);
                    }
                  }));
                }
                let r = typeof loadSideModule == "function" ? loadSideModule : loadWebAssemblyModule;
                return t.then(e => r(e, {
                  loadAsync: !0
                })).then(e => {
                  let t = Object.keys(e),
                    r = t.find(e => LANGUAGE_FUNCTION_REGEX.test(e) && !e.includes("external_scanner_"));
                  r || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t, null, 2)}`);
                  let _ = e[r]();
                  return new Language(INTERNAL, _);
                });
              }
            }
            class Query {
              static {
                __name(this, "Query");
              }
              constructor(e, t, r, _, n, s, a, o) {
                assertInternal(e), this[0] = t, this.captureNames = r, this.textPredicates = _, this.predicates = n, this.setProperties = s, this.assertedProperties = a, this.refutedProperties = o, this.exceededMatchLimit = !1;
              }
              delete() {
                C._ts_query_delete(this[0]), this[0] = 0;
              }
              matches(e, t, r, _) {
                t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                let n = _.matchLimit;
                if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                marshalNode(e), C._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                let s = getValue(TRANSFER_BUFFER, "i32"),
                  a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                  i = new Array(s);
                this.exceededMatchLimit = !!o;
                let l = 0,
                  u = a;
                for (let t = 0; t < s; t++) {
                  let r = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let _ = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let n = new Array(_);
                  if (u = unmarshalCaptures(this, e.tree, u, n), this.textPredicates[r].every(e => e(n))) {
                    i[l++] = {
                      pattern: r,
                      captures: n
                    };
                    let e = this.setProperties[r];
                    e && (i[t].setProperties = e);
                    let _ = this.assertedProperties[r];
                    _ && (i[t].assertedProperties = _);
                    let s = this.refutedProperties[r];
                    s && (i[t].refutedProperties = s);
                  }
                }
                return i.length = l, C._free(a), i;
              }
              captures(e, t, r, _) {
                t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                let n = _.matchLimit;
                if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                marshalNode(e), C._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                let s = getValue(TRANSFER_BUFFER, "i32"),
                  a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                  i = [];
                this.exceededMatchLimit = !!o;
                let l = [],
                  u = a;
                for (let t = 0; t < s; t++) {
                  let t = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let r = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let _ = getValue(u, "i32");
                  if (u += SIZE_OF_INT, l.length = r, u = unmarshalCaptures(this, e.tree, u, l), this.textPredicates[t].every(e => e(l))) {
                    let e = l[_],
                      r = this.setProperties[t];
                    r && (e.setProperties = r);
                    let n = this.assertedProperties[t];
                    n && (e.assertedProperties = n);
                    let s = this.refutedProperties[t];
                    s && (e.refutedProperties = s), i.push(e);
                  }
                }
                return C._free(a), i;
              }
              predicatesForPattern(e) {
                return this.predicates[e];
              }
              didExceedMatchLimit() {
                return this.exceededMatchLimit;
              }
            }
            function getText(e, t, r) {
              let _ = r - t,
                n = e.textCallback(t, null, r);
              for (t += n.length; t < r;) {
                let _ = e.textCallback(t, null, r);
                if (!(_ && _.length > 0)) break;
                t += _.length, n += _;
              }
              return t > r && (n = n.slice(0, _)), n;
            }
            __name(getText, "getText");
            function unmarshalCaptures(e, t, r, _) {
              for (let n = 0, s = _.length; n < s; n++) {
                let s = getValue(r, "i32"),
                  a = unmarshalNode(t, r += SIZE_OF_INT);
                r += SIZE_OF_NODE, _[n] = {
                  name: e.captureNames[s],
                  node: a
                };
              }
              return r;
            }
            __name(unmarshalCaptures, "unmarshalCaptures");
            function assertInternal(e) {
              if (e !== INTERNAL) throw new Error("Illegal constructor");
            }
            __name(assertInternal, "assertInternal");
            function isPoint(e) {
              return e && typeof e.row == "number" && typeof e.column == "number";
            }
            __name(isPoint, "isPoint");
            function marshalNode(e) {
              let t = TRANSFER_BUFFER;
              setValue(t, e.id, "i32"), t += SIZE_OF_INT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.row, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.column, "i32"), t += SIZE_OF_INT, setValue(t, e[0], "i32");
            }
            __name(marshalNode, "marshalNode");
            function unmarshalNode(e, t = TRANSFER_BUFFER) {
              let r = getValue(t, "i32");
              if (r === 0) return null;
              let _ = getValue(t += SIZE_OF_INT, "i32"),
                n = getValue(t += SIZE_OF_INT, "i32"),
                s = getValue(t += SIZE_OF_INT, "i32"),
                a = getValue(t += SIZE_OF_INT, "i32"),
                o = new Node(INTERNAL, e);
              return o.id = r, o.startIndex = _, o.startPosition = {
                row: n,
                column: s
              }, o[0] = a, o;
            }
            __name(unmarshalNode, "unmarshalNode");
            function marshalTreeCursor(e, t = TRANSFER_BUFFER) {
              setValue(t + 0 * SIZE_OF_INT, e[0], "i32"), setValue(t + 1 * SIZE_OF_INT, e[1], "i32"), setValue(t + 2 * SIZE_OF_INT, e[2], "i32");
            }
            __name(marshalTreeCursor, "marshalTreeCursor");
            function unmarshalTreeCursor(e) {
              e[0] = getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32"), e[1] = getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32"), e[2] = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
            }
            __name(unmarshalTreeCursor, "unmarshalTreeCursor");
            function marshalPoint(e, t) {
              setValue(e, t.row, "i32"), setValue(e + SIZE_OF_INT, t.column, "i32");
            }
            __name(marshalPoint, "marshalPoint");
            function unmarshalPoint(e) {
              return {
                row: getValue(e, "i32"),
                column: getValue(e + SIZE_OF_INT, "i32")
              };
            }
            __name(unmarshalPoint, "unmarshalPoint");
            function marshalRange(e, t) {
              marshalPoint(e, t.startPosition), marshalPoint(e += SIZE_OF_POINT, t.endPosition), setValue(e += SIZE_OF_POINT, t.startIndex, "i32"), setValue(e += SIZE_OF_INT, t.endIndex, "i32"), e += SIZE_OF_INT;
            }
            __name(marshalRange, "marshalRange");
            function unmarshalRange(e) {
              let t = {};
              return t.startPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.endPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.startIndex = getValue(e, "i32"), e += SIZE_OF_INT, t.endIndex = getValue(e, "i32"), t;
            }
            __name(unmarshalRange, "unmarshalRange");
            function marshalEdit(e) {
              let t = TRANSFER_BUFFER;
              marshalPoint(t, e.startPosition), t += SIZE_OF_POINT, marshalPoint(t, e.oldEndPosition), t += SIZE_OF_POINT, marshalPoint(t, e.newEndPosition), t += SIZE_OF_POINT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.oldEndIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.newEndIndex, "i32"), t += SIZE_OF_INT;
            }
            __name(marshalEdit, "marshalEdit");
            for (let e of Object.getOwnPropertyNames(ParserImpl.prototype)) Object.defineProperty(Parser.prototype, e, {
              value: ParserImpl.prototype[e],
              enumerable: !1,
              writable: !1
            });
            Parser.Language = Language, Module.onRuntimeInitialized = () => {
              ParserImpl.init(), resolveInitPromise();
            };
          }));
        }
      }
      return Parser;
    }();
  typeof exports == "object" && (module.exports = TreeSitter);
});
function isSupportedLanguageId(languageId) {
  return languageId in languageIdToWasmLanguageMapping;
}
function languageIdToWasmLanguage(languageId) {
  if (!(languageId in languageIdToWasmLanguageMapping)) throw new Error(`Unrecognized language: ${languageId}`);
  return languageIdToWasmLanguageMapping[languageId];
}
async function loadWasmLanguage(language) {
  await db.Parser.init();
  let wasmFile = (0, Mte.resolve)(__dirname, "..", "dist", `tree-sitter-${language}.wasm`);
  try {
    return db.Parser.Language.load(wasmFile);
  } catch (e) {
    if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code == "EPERM") && e instanceof Error) {
      let error = new Error(`Could not load tree-sitter-${language}.wasm`);
      throw error.code = "CopilotPromptLoadFailure", error;
    }
    throw e;
  }
}
async function getLanguage(language) {
  let wasmLanguage = languageIdToWasmLanguage(language);
  if (!loadedLanguages.has(wasmLanguage)) {
    let loadedLang = await loadWasmLanguage(wasmLanguage);
    loadedLanguages.set(wasmLanguage, loadedLang);
  }
  return loadedLanguages.get(wasmLanguage);
}
async function parseTreeSitter(language, source) {
  let treeSitterLanguage = await getLanguage(language),
    parser = new db.Parser();
  parser.setLanguage(treeSitterLanguage);
  let parsedTree = parser.parse(source);
  return parser.delete(), parsedTree;
}
async function parsesWithoutError(language, source) {
  let tree = await parseTreeSitter(language, source),
    result = !tree.rootNode.hasError();
  return tree.delete(), result;
}
function getBlockCloseToken(language) {
  switch (languageIdToWasmLanguage(language)) {
    case "python":
      return null;
    case "javascript":
    case "typescript":
    case "tsx":
    case "go":
      return "}";
    case "ruby":
      return "end";
  }
}
function innerQuery(queries, root) {
  let matches = [];
  for (let query of queries) {
    if (!query[1]) {
      let lang = root.tree.getLanguage();
      query[1] = lang.query(query[0]);
    }
    matches.push(...query[1].matches(root));
  }
  return matches;
}
function queryFunctions(language, root) {
  let queries = functionQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryImports(language, root) {
  let queries = importsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryExports(language, root) {
  let queries = exportsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryGlobalVars(language, root) {
  let queries = globalVarsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryPythonIsDocstring(blockNode) {
  return innerQuery([docstringQuery], blockNode).length == 1;
}
function getAncestorWithSiblingFunctions(language, nd) {
  let check = isFunctionParent[languageIdToWasmLanguage(language)];
  for (; nd.parent;) {
    if (check(nd.parent)) return nd;
    nd = nd.parent;
  }
  return nd.parent ? nd : null;
}
function isFunction(language, nd) {
  return functionTypes[languageIdToWasmLanguage(language)].has(nd.type);
}
function isFunctionDefinition(language, nd) {
  switch (languageIdToWasmLanguage(language)) {
    case "python":
    case "go":
    case "ruby":
      return isFunction(language, nd);
    case "javascript":
    case "typescript":
    case "tsx":
      if (nd.type === "function_declaration" || nd.type === "generator_function_declaration" || nd.type === "method_definition") return !0;
      if (nd.type === "lexical_declaration" || nd.type === "variable_declaration") {
        if (nd.namedChildCount > 1) return !1;
        let declarator = nd.namedChild(0);
        if (declarator == null) return !1;
        let init = declarator.namedChild(1);
        return init !== null && isFunction(language, init);
      }
      if (nd.type === "expression_statement") {
        let expr = nd.namedChild(0);
        if (expr?.type === "assignment_expression") {
          let rhs = expr.namedChild(1);
          return rhs !== null && isFunction(language, rhs);
        }
      }
      return !1;
  }
}
function getFirstPrecedingComment(nd) {
  let cur = nd;
  for (; cur.previousSibling?.type === "comment";) {
    let prev = cur.previousSibling;
    if (prev.endPosition.row < cur.startPosition.row - 1) break;
    cur = prev;
  }
  return cur?.type === "comment" ? cur : null;
}
async function getFunctionPositions(language, source) {
  let tree = await parseTreeSitter(language, source),
    positions = queryFunctions(language, tree.rootNode).map(res => {
      let fn = res.captures.find(c => c.name === "function").node;
      return {
        startIndex: fn.startIndex,
        endIndex: fn.endIndex
      };
    });
  return tree.delete(), positions;
}
async function getCallSites(docInfo) {
  if (!(docInfo.languageId in callSiteQuery)) return [];
  let offset = docInfo.offset,
    source = docInfo.source.substring(0, offset),
    pretruncateOffset = Math.max(source.length - 5e3, 0),
    linesBeforeTruncation = source.substring(0, pretruncateOffset).split(`
`).length - 1;
  offset -= pretruncateOffset, source = source.substring(pretruncateOffset), source = source + ")))))";
  let callers = [],
    tree = await parseTreeSitter(docInfo.languageId, source),
    queries = callSiteQuery[languageIdToWasmLanguageMapping[docInfo.languageId]];
  return innerQuery(queries, tree.rootNode).forEach((res, resIndex) => {
    let callerName = "",
      callerLineNo = 0,
      callerStartChar = 0,
      argsStartIndex = 0,
      argsEndIndex = 0;
    if (res.captures.forEach((cap, capIndex) => {
      let node = cap.node;
      cap.name == "caller" ? (callerName = source.substring(node.startIndex, node.endIndex), callerLineNo = node.startPosition.row + linesBeforeTruncation, callerStartChar = node.startPosition.column) : cap.name == "args" && (argsStartIndex = node.startIndex, argsEndIndex = node.endIndex);
    }), offset >= argsStartIndex && offset <= argsEndIndex) {
      let callerLineCol = {
        line: callerLineNo,
        character: callerStartChar
      };
      callers.push([callerName, callerLineCol]);
    }
  }), tree.delete(), callers.map(([name, position]) => ({
    name: name,
    position: position
  }));
}
var import_path,
  import_web_tree_sitter,
  WASMLanguage,
  languageIdToWasmLanguageMapping,
  jsFunctionQuery,
  functionQuery,
  requireCall,
  declaratorWithRequire,
  commonJsImport,
  tsImportQueries,
  importsQuery,
  jsExportQueries,
  exportsQuery,
  globalVarsQuery,
  jsFunctionTypes,
  functionTypes,
  isFunctionParent,
  loadedLanguages,
  docstringQuery,
  callSiteQuery,
  init_parse = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_web_tree_sitter = Ns(Ote()), WASMLanguage = (o => (WASMLanguage.Python = "python", WASMLanguage.JavaScript = "javascript", WASMLanguage.TypeScript = "typescript", WASMLanguage.TSX = "tsx", WASMLanguage.Go = "go", WASMLanguage.Ruby = "ruby", WASMLanguage))(Bte || {}), languageIdToWasmLanguageMapping = {
      python: "python",
      javascript: "javascript",
      javascriptreact: "javascript",
      jsx: "javascript",
      typescript: "typescript",
      typescriptreact: "tsx",
      go: "go",
      ruby: "ruby"
    };
    __name(isSupportedLanguageId, "isSupportedLanguageId");
    __name(languageIdToWasmLanguage, "languageIdToWasmLanguage");
    jsFunctionQuery = `[
    (function body: (statement_block) @body)
    (function_declaration body: (statement_block) @body)
    (generator_function body: (statement_block) @body)
    (generator_function_declaration body: (statement_block) @body)
    (method_definition body: (statement_block) @body)
    (arrow_function body: (statement_block) @body)
  ] @function`, functionQuery = {
      python: [[`(function_definition body: (block
             (expression_statement (string))? @docstring) @body) @function`], ['(ERROR ("def" (identifier) (parameters))) @function']],
      javascript: [[jsFunctionQuery]],
      typescript: [[jsFunctionQuery]],
      tsx: [[jsFunctionQuery]],
      go: [[`[
            (function_declaration body: (block) @body)
            (method_declaration body: (block) @body)
          ] @function`]],
      ruby: [[`[
            (method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
          ] @function`]]
    }, requireCall = '(call_expression function: ((identifier) @req (#eq? @req "require")))', declaratorWithRequire = `(variable_declarator value: ${requireCall})`, commonJsImport = `
    (lexical_declaration ${declaratorWithRequire}+)
    (variable_declaration ${declaratorWithRequire}+)
`, tsImportQueries = [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) (import_alias) ] @import)"]], importsQuery = {
      python: [["(module (future_import_statement) @import)"], ["(module (import_statement) @import)"], ["(module (import_from_statement) @import)"]],
      javascript: [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) ] @import)"]],
      typescript: tsImportQueries,
      tsx: tsImportQueries,
      go: [],
      ruby: []
    }, jsExportQueries = [["(program (export_statement) @export)"]], exportsQuery = {
      python: [],
      javascript: jsExportQueries,
      typescript: jsExportQueries,
      tsx: jsExportQueries,
      go: [],
      ruby: []
    }, globalVarsQuery = {
      python: [["(module (global_statement) @globalVar)"], ["(module (expression_statement) @globalVar)"]],
      javascript: [],
      typescript: [],
      tsx: [],
      go: [],
      ruby: []
    }, jsFunctionTypes = ["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"], functionTypes = {
      python: new Set(["function_definition"]),
      javascript: new Set(jsFunctionTypes),
      typescript: new Set(jsFunctionTypes),
      tsx: new Set(jsFunctionTypes),
      go: new Set(["function_declaration", "method_declaration"]),
      ruby: new Set(["method", "singleton_method"])
    }, isFunctionParent = {
      python: nd => nd.type === "module" || nd.type === "block" && nd.parent?.type === "class_definition",
      javascript: nd => nd.type === "program" || nd.type === "class_body",
      typescript: nd => nd.type === "program" || nd.type === "class_body",
      tsx: nd => nd.type === "program" || nd.type === "class_body",
      go: nd => nd.type === "source_file",
      ruby: nd => nd.type === "program" || nd.type === "class"
    }, loadedLanguages = new Map();
    __name(loadWasmLanguage, "loadWasmLanguage");
    __name(getLanguage, "getLanguage");
    __name(parseTreeSitter, "parseTreeSitter");
    __name(parsesWithoutError, "parsesWithoutError");
    __name(getBlockCloseToken, "getBlockCloseToken");
    __name(innerQuery, "innerQuery");
    __name(queryFunctions, "queryFunctions");
    __name(queryImports, "queryImports");
    __name(queryExports, "queryExports");
    __name(queryGlobalVars, "queryGlobalVars");
    docstringQuery = [`[
    (class_definition (block (expression_statement (string))))
    (function_definition (block (expression_statement (string))))
]`];
    __name(queryPythonIsDocstring, "queryPythonIsDocstring");
    __name(getAncestorWithSiblingFunctions, "getAncestorWithSiblingFunctions");
    __name(isFunction, "isFunction");
    __name(isFunctionDefinition, "isFunctionDefinition");
    __name(getFirstPrecedingComment, "getFirstPrecedingComment");
    __name(getFunctionPositions, "getFunctionPositions");
    callSiteQuery = {
      python: [[`(call
            function:  [
                (identifier) @caller
                (attribute attribute:(identifier) @caller)
            ]
            arguments: (argument_list) @args
        )`]],
      javascript: [],
      tsx: [],
      typescript: [],
      go: [],
      ruby: []
    };
    __name(getCallSites, "getCallSites");
  });
async function getSiblingFunctionStart({
  source: source,
  offset: offset,
  languageId: languageId
}) {
  if (isSupportedLanguageId(languageId)) {
    let tree = await parseTreeSitter(languageId, source);
    try {
      let startingOffset = offset;
      for (; startingOffset >= 0 && /\s/.test(source[startingOffset]);) startingOffset--;
      let nd = tree.rootNode.descendantForIndex(startingOffset),
        anc = getAncestorWithSiblingFunctions(languageId, nd);
      if (anc) {
        for (let sibling = anc.nextSibling; sibling; sibling = sibling.nextSibling) if (isFunctionDefinition(languageId, sibling)) {
          let startIndex = getFirstPrecedingComment(sibling)?.startIndex ?? sibling.startIndex;
          if (startIndex < offset) continue;
          return startIndex;
        }
        if (anc.endIndex >= offset) return anc.endIndex;
      }
    } finally {
      tree.delete();
    }
  }
  return offset;
}
var init_siblingFunctions = __esmMin(() => {
  "use strict";

  init_parse();
  __name(getSiblingFunctionStart, "getSiblingFunctionStart");
});
function cursorContextOptions(options) {
  return {
    ...defaultCursorContextOptions,
    ...options
  };
}
function getCursorContext(doc, options = {}) {
  let completeOptions = cursorContextOptions(options),
    tokenizer = getTokenizer(completeOptions.tokenizerName);
  if (completeOptions.maxLineCount !== void 0 && completeOptions.maxLineCount < 0) throw new Error("maxLineCount must be non-negative if defined");
  if (completeOptions.maxTokenLength !== void 0 && completeOptions.maxTokenLength < 0) throw new Error("maxTokenLength must be non-negative if defined");
  if (completeOptions.maxLineCount === 0 || completeOptions.maxTokenLength === 0) return {
    context: "",
    lineCount: 0,
    tokenLength: 0,
    tokenizerName: completeOptions.tokenizerName
  };
  let context = doc.source.slice(0, doc.offset);
  return completeOptions.maxLineCount !== void 0 && (context = context.split(`
`).slice(-completeOptions.maxLineCount).join(`
`)), completeOptions.maxTokenLength !== void 0 && (context = tokenizer.takeLastLinesTokens(context, completeOptions.maxTokenLength)), {
    context: context,
    lineCount: context.split(`
`).length,
    tokenLength: tokenizer.tokenLength(context),
    tokenizerName: completeOptions.tokenizerName
  };
}
var defaultCursorContextOptions,
  init_cursorContext = __esmMin(() => {
    "use strict";

    init_tokenization();
    defaultCursorContextOptions = {
      tokenizerName: "cl100k"
    };
    __name(cursorContextOptions, "cursorContextOptions");
    __name(getCursorContext, "getCursorContext");
  });
function announceSnippet(snippet, targetDocLanguageId) {
  let semantics = snippetSemanticsToString[snippet.semantics],
    headlinedSnippet = (snippet.relativePath ? `Compare this ${semantics} from ${snippet.relativePath}:` : `Compare this ${semantics}:`) + `
` + snippet.snippet;
  return headlinedSnippet.endsWith(`
`) || (headlinedSnippet += `
`), commentBlockAsSingles(headlinedSnippet, targetDocLanguageId);
}
function normalizeSnippetScore(snippet, providerOptions) {
  let options = providerOptions[snippet.provider];
  if (!options) throw new Error("Unknown snippet provider: " + snippet.provider);
  let {
      score: providerScore,
      ...snippetRem
    } = snippet,
    normalizedScore = providerScore;
  if (options.normalizationFunction === "affine") {
    let [a, b] = options.normalizationParams;
    normalizedScore = a * providerScore + b;
  } else throw new Error(`Unknown normalization function ${options.normalizationFunction} for snippet provider ${snippet.provider}`);
  return {
    ...snippetRem,
    providerScore: providerScore,
    normalizedScore: normalizedScore
  };
}
function sortSnippetsDescending(snippets) {
  snippets.sort((a, b) => b.normalizedScore - a.normalizedScore);
}
function selectSnippets(snippets, numberOfSnippets, providerOptions) {
  if (numberOfSnippets == 0) return {
    reserved: [],
    candidates: []
  };
  let normalizedSnippets = snippets.map(snippet => normalizeSnippetScore(snippet, providerOptions)),
    snippetsByProvider = new Map(),
    provider;
  for (provider in providerOptions) snippetsByProvider.set(provider, []);
  for (let snippet of normalizedSnippets) {
    let snippets = snippetsByProvider.get(snippet.provider);
    if (!snippets) throw new Error("Unknown snippet provider: " + snippet.provider);
    snippets.push(snippet);
  }
  for (let [_provider, snippets] of snippetsByProvider) sortSnippetsDescending(snippets);
  let reserved = [];
  for (provider in providerOptions) {
    let count = providerOptions[provider].reservedSnippetCount || 0;
    if (count > 0) {
      let snippets = snippetsByProvider.get(provider) || [];
      reserved = reserved.concat(snippets.slice(0, count)), snippetsByProvider.set(provider, snippets.slice(count));
    }
  }
  sortSnippetsDescending(reserved);
  let candidates = [];
  if (reserved.length > numberOfSnippets) throw new Error("Reserved snippet count exceeds number of snippets");
  if (reserved.length < numberOfSnippets) {
    let remaining = Array.from(snippetsByProvider.values()).flat();
    sortSnippetsDescending(remaining), candidates = remaining.slice(0, numberOfSnippets - reserved.length);
  }
  return {
    reserved: reserved,
    candidates: candidates
  };
}
function processSnippetsForWishlist(snippets, targetDocLanguageId, tokenizer, providerOptions, priorities, totalPrioritized, highPriorityBudget) {
  let {
      reserved: reserved,
      candidates: candidates
    } = selectSnippets(snippets, totalPrioritized, providerOptions),
    usedBudget = 0,
    processedSnippets = [],
    nextHighPriority = priorities.high,
    nextLowPriority = priorities.low;
  function process(snippet, usedBudget) {
    let announced = announceSnippet(snippet, targetDocLanguageId),
      tokens = tokenizer.tokenLength(announced),
      priority;
    return usedBudget + tokens <= highPriorityBudget ? (priority = nextHighPriority, nextHighPriority = priorities.priorities.justBelow(priority)) : (priority = nextLowPriority, nextLowPriority = priorities.priorities.justBelow(priority)), processedSnippets.push({
      announcedSnippet: announced,
      provider: snippet.provider,
      providerScore: snippet.providerScore,
      normalizedScore: snippet.normalizedScore,
      priority: priority,
      tokens: tokens,
      relativePath: snippet.relativePath
    }), usedBudget + tokens;
  }
  __name(process, "process");
  for (let snippet of [...reserved, ...candidates]) {
    if (processedSnippets.length >= totalPrioritized) break;
    usedBudget = process(snippet, usedBudget);
  }
  return sortSnippetsDescending(processedSnippets), processedSnippets.reverse(), processedSnippets;
}
var SnippetProviderType,
  SnippetSemantics,
  snippetSemanticsToString,
  init_snippets = __esmMin(() => {
    "use strict";

    init_languageMarker();
    SnippetProviderType = (o => (SnippetProviderType.NeighboringTabs = "neighboring-tabs", SnippetProviderType.Retrieval = "retrieval", SnippetProviderType.SymbolDef = "symbol-def", SnippetProviderType.Language = "language", SnippetProviderType.Path = "path", SnippetProviderType.LocalImportContext = "local-import-context", SnippetProviderType))(zf || {}), SnippetSemantics = (d => (SnippetSemantics.Function = "function", SnippetSemantics.Snippet = "snippet", SnippetSemantics.Variable = "variable", SnippetSemantics.Parameter = "parameter", SnippetSemantics.Method = "method", SnippetSemantics.Class = "class", SnippetSemantics.Module = "module", SnippetSemantics.Alias = "alias", SnippetSemantics.Enum = "enum member", SnippetSemantics.Interface = "interface", SnippetSemantics))(s1 || {}), snippetSemanticsToString = {
      function: "function",
      snippet: "snippet",
      variable: "variable",
      parameter: "parameter",
      method: "method",
      class: "class",
      module: "module",
      alias: "alias",
      "enum member": "enum member",
      interface: "interface"
    };
    __name(announceSnippet, "announceSnippet");
    __name(normalizeSnippetScore, "normalizeSnippetScore");
    __name(sortSnippetsDescending, "sortSnippetsDescending");
    __name(selectSnippets, "selectSnippets");
    __name(processSnippetsForWishlist, "processSnippetsForWishlist");
  });
async function getNeighboringFunctions(neighbor) {
  let neighborFuncs = [];
  if (isSupportedLanguageId(neighbor.languageId)) {
    let funcPositions = await getFunctionPositions(neighbor.languageId, neighbor.source);
    for (let i = 0; i < funcPositions.length; i++) {
      let {
          startIndex: startIndex,
          endIndex: endIndex
        } = funcPositions[i],
        func_source = neighbor.source.substring(startIndex, endIndex);
      neighborFuncs.push({
        source: func_source,
        relativePath: neighbor.relativePath,
        languageId: neighbor.languageId,
        uri: neighbor.uri
      });
    }
  }
  return neighborFuncs;
}
function splitIntoWords(a) {
  return a.split(/[^a-zA-Z0-9]/).filter(x => x.length > 0);
}
var FifoCache,
  Tokenizer,
  WINDOWED_TOKEN_SET_CACHE,
  WindowedMatcher,
  FunctionalMatcher,
  ENGLISH_STOPS,
  GENERIC_STOPS,
  SPECIFIC_STOPS,
  init_selectRelevance = __esmMin(() => {
    "use strict";

    init_parse();
    init_prompt();
    init_snippets();
    FifoCache = class {
      constructor(size) {
        this.keys = [];
        this.cache = {};
        this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    }, Tokenizer = class {
      static {
        __name(this, "Tokenizer");
      }
      constructor(doc) {
        this.stopsForLanguage = SPECIFIC_STOPS.get(doc.languageId) ?? GENERIC_STOPS;
      }
      tokenize(a) {
        return new Set(splitIntoWords(a).filter(x => !this.stopsForLanguage.has(x)));
      }
    }, WINDOWED_TOKEN_SET_CACHE = new FifoCache(20), WindowedMatcher = class {
      static {
        __name(this, "WindowedMatcher");
      }
      constructor(referenceDoc) {
        this.referenceDoc = referenceDoc, this.tokenizer = new Tokenizer(referenceDoc);
      }
      get referenceTokens() {
        return this.tokenizer.tokenize(this._getCursorContextInfo(this.referenceDoc).context);
      }
      sortScoredSnippets(snippets, sortOption = "descending") {
        return sortOption == "ascending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "descending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      retrieveAllSnippets(objectDoc, sortOption = "descending") {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
      async findMatches(objectDoc, snippetSelectionOption = "bestMatch", snippetSelectionK) {
        if (snippetSelectionOption == "bestMatch") {
          let snippet = await this.findBestMatch(objectDoc);
          return snippet ? [snippet] : [];
        }
        return snippetSelectionOption == "topK" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        return snippets.length === 0 || snippets[0].score === 0 ? void 0 : {
          snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippets[0]
        };
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        if (snippets.length === 0 || snippets[0].score === 0) return;
        let nonOverlappingSnippets = [snippets[0]];
        for (let currentIndex = 1; currentIndex < snippets.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippets[currentIndex].startLine < snippet.endLine && snippets[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippets[currentIndex]);
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippetMarker
        }));
      }
    };
    __name(getNeighboringFunctions, "getNeighboringFunctions");
    FunctionalMatcher = class extends WindowedMatcher {
      static {
        __name(this, "FunctionalMatcher");
      }
      constructor(referenceDoc) {
        super(referenceDoc);
      }
      getMatchingScore(neighborDoc) {
        let neighborDocTokens = this.tokenizer.tokenize(neighborDoc.source),
          score = this.similarityScore(neighborDocTokens, this.referenceTokens);
        return {
          snippet: neighborDoc.source,
          score: score,
          startLine: 0,
          endLine: 0
        };
      }
      async findBestMatch(objectDoc) {
        let snippets = await this.findMatches(objectDoc);
        if (snippets.length !== 0 && snippets[0].score !== 0) return snippets[0];
      }
      async findMatches(objectDoc, snippetSelectionOption, snippetSelectionK) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return [];
        let neighborFuncs = await getNeighboringFunctions(objectDoc);
        if (neighborFuncs.length == 0) {
          let lines = objectDoc.source.split(`
`),
            snippets = this.retrieveAllSnippets(objectDoc, "descending");
          return snippets.length === 0 ? [] : snippets[0].score === 0 ? [] : [{
            snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
            semantics: "snippet",
            provider: "neighboring-tabs",
            ...snippets[0]
          }];
        }
        let snippets = [];
        for (let func of neighborFuncs) {
          let snippet = this.getMatchingScore(func);
          snippets.push({
            semantics: "function",
            provider: "neighboring-tabs",
            ...snippet
          });
        }
        return snippets;
      }
    };
    __name(splitIntoWords, "splitIntoWords");
    ENGLISH_STOPS = new Set(["we", "our", "you", "it", "its", "they", "them", "their", "this", "that", "these", "those", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "can", "don", "t", "s", "will", "would", "should", "what", "which", "who", "when", "where", "why", "how", "a", "an", "the", "and", "or", "not", "no", "but", "because", "as", "until", "again", "further", "then", "once", "here", "there", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "above", "below", "to", "during", "before", "after", "of", "at", "by", "about", "between", "into", "through", "from", "up", "down", "in", "out", "on", "off", "over", "under", "only", "own", "same", "so", "than", "too", "very", "just", "now"]), GENERIC_STOPS = new Set(["if", "then", "else", "for", "while", "with", "def", "function", "return", "TODO", "import", "try", "catch", "raise", "finally", "repeat", "switch", "case", "match", "assert", "continue", "break", "const", "class", "enum", "struct", "static", "new", "super", "this", "var", ...ENGLISH_STOPS]), SPECIFIC_STOPS = new Map([]);
  });
function getBasicWindowDelineations(windowLength, lines) {
  let windows = [],
    length = lines.length;
  if (length == 0) return [];
  if (length < windowLength) return [[0, length]];
  for (let startLine = 0; startLine < length - windowLength + 1; startLine++) windows.push([startLine, startLine + windowLength]);
  return windows;
}
var init_windowDelineations = __esmMin(() => {
  "use strict";

  init_manipulation();
  init_parsing();
  __name(getBasicWindowDelineations, "getBasicWindowDelineations");
});
function computeScore(a, b) {
  let intersection = new Set();
  return a.forEach(x => {
    b.has(x) && intersection.add(x);
  }), intersection.size / (a.size + b.size - intersection.size);
}
var FixedWindowSizeJaccardMatcher,
  FunctionJaccardMatcher,
  init_jaccardMatching = __esmMin(() => {
    "use strict";

    init_cursorContext();
    init_selectRelevance();
    init_windowDelineations();
    FixedWindowSizeJaccardMatcher = class _FixedWindowSizeJaccardMatcher extends WindowedMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "FixedWindowSizeJaccardMatcher");
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FixedWindowSizeJaccardMatcher(referenceDoc, windowLength)
        });
      }
      id() {
        return "fixed:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    }, FunctionJaccardMatcher = class _FunctionJaccardMatcher extends FunctionalMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "FunctionJaccardMatcher");
      }
      id() {
        return "function:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FunctionJaccardMatcher(referenceDoc, windowLength)
        });
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    };
    __name(computeScore, "computeScore");
  });
var CursorSnippetsPickingStrategy,
  FifoCache,
  WINDOWED_TOKEN_SET_CACHE,
  CustomizedFixedWindowSizeJaccardMatcher,
  CursorHistoryMatcher,
  init_cursorMatching = __esmMin(() => {
    "use strict";

    init_prompt();
    init_cursorContext();
    init_jaccardMatching();
    init_selectRelevance();
    init_snippets();
    init_windowDelineations();
    CursorSnippetsPickingStrategy = (n => (CursorSnippetsPickingStrategy.CursorOnly = "cursoronly", CursorSnippetsPickingStrategy.CursorJaccard = "cursorjaccard", CursorSnippetsPickingStrategy.JaccardCursor = "jaccardcursor", CursorSnippetsPickingStrategy))(bb || {}), FifoCache = class {
      constructor(size) {
        this.keys = [];
        this.cache = {};
        this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    }, WINDOWED_TOKEN_SET_CACHE = new FifoCache(20), CustomizedFixedWindowSizeJaccardMatcher = class extends WindowedMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "CustomizedFixedWindowSizeJaccardMatcher");
      }
      id() {
        return "CustomizedFixedWindowSizeJaccardMatcher:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
      retrieveAllSnippets(objectDoc, sortOption = "descending", candidates) {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          if (candidates !== void 0 && candidates.get(startLine) !== endLine) continue;
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
    }, CursorHistoryMatcher = class _CursorHistoryMatcher {
      static {
        __name(this, "CursorHistoryMatcher");
      }
      constructor(referenceDoc, windowLength, lineCursorHistory, strategy) {
        this.windowLength = windowLength, this.lineCursorHistory = lineCursorHistory, this.jaccardMatcher = new CustomizedFixedWindowSizeJaccardMatcher(referenceDoc, windowLength), this.strategy = strategy;
      }
      static {
        this.FACTORY = (windowLength, lineCursorHistory, strategy) => ({
          to: referenceDoc => new _CursorHistoryMatcher(referenceDoc, windowLength, lineCursorHistory, strategy)
        });
      }
      sortScoredSnippets(snippets, sortOption = "descending") {
        return sortOption == "ascending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "descending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      markerToSnippet(nonOverlappingSnippets, lines) {
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          provider: "neighboring-tabs",
          semantics: "snippet",
          ...snippetMarker
        }));
      }
      async findMatches(objectDoc, snippetSelectionOption = "bestMatch", snippetSelectionK) {
        if (snippetSelectionOption == "bestMatch") {
          let bestMatch = await this.findBestMatch(objectDoc);
          return bestMatch === void 0 ? [] : [bestMatch];
        }
        return snippetSelectionOption == "topK" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length !== 0) {
          if (this.strategy === "cursoronly") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippets = snippetsByCursor.filter(s => s.score === bestCursorScore),
              bestInMiddle = bestSnippets.sort((a, b) => a.startLine - b.startLine)[Math.floor(bestSnippets.length / 2)];
            return {
              snippet: objectDoc.source.split(`
`).slice(bestInMiddle.startLine, bestInMiddle.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestInMiddle
            };
          } else if (this.strategy === "cursorjaccard") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippetsByCursor = [],
              bestSnippetsBoundaryByCursor = new Map();
            for (let snippet of snippetsByCursor) snippet.score === bestCursorScore && (bestSnippetsByCursor.push(snippet), bestSnippetsBoundaryByCursor.set(snippet.startLine, snippet.endLine));
            let bestSnippets = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "descending", bestSnippetsBoundaryByCursor);
            if (bestSnippets.length === 0) return;
            let bestSnippet = bestSnippets[0];
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return {
              snippet: objectDoc.source.split(`
`).slice(bestSnippet.startLine, bestSnippet.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestSnippet
            };
          } else if (this.strategy === "jaccardcursor") {
            let bestSnippet = await this.jaccardMatcher.findBestMatch(objectDoc);
            if (bestSnippet === void 0) return;
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return bestSnippet;
          }
        }
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
        if (snippetsByCursor.length !== 0) {
          if (this.strategy === "cursoronly") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "cursorjaccard") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let snippetCandidates = new Map(snippetsByCursor.map(s => [s.startLine, s.endLine])),
              jaccardMap = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "descending", snippetCandidates).reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            snippetsByCursor.forEach(v => v.score += jaccardMap.get([v.startLine, v.endLine].join(",")) ?? 0), snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "jaccardcursor") {
            let topKByJaccard = await this.jaccardMatcher.findTopKMatches(objectDoc, snippetSelectionK);
            if (topKByJaccard === void 0) return;
            let cursorMap = snippetsByCursor.reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            topKByJaccard.forEach(v => v.score += cursorMap.get([v.startLine, v.endLine].join(",")) ?? 0);
            let resortedTopKByJaccard = this.sortScoredSnippets(topKByJaccard, "descending");
            return this.markerToSnippet(resortedTopKByJaccard, lines);
          }
        }
      }
      gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK) {
        let nonOverlappingSnippets = [snippetsByCursor[0]];
        for (let currentIndex = 1; currentIndex < snippetsByCursor.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippetsByCursor[currentIndex].startLine < snippet.endLine && snippetsByCursor[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippetsByCursor[currentIndex]);
        return nonOverlappingSnippets;
      }
      retrieveCursorSnippets(objectDoc) {
        let snippets = [];
        if (objectDoc.source.length === 0) return snippets;
        let cursors = this.lineCursorHistory.get(objectDoc.uri);
        if (cursors === void 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          pointType;
        (p => (pointType[p.leftBoundary = 0] = "leftBoundary", pointType[p.rightBoundary = 1] = "rightBoundary"))(pointType ||= {});
        let sparsePoints = [];
        for (let [line, num] of cursors.entries()) line >= lines.length || (sparsePoints.push([Math.max(0, line - this.windowLength + 1), 0, num]), sparsePoints.push([line + 1, 1, num]));
        sparsePoints.push([lines.length, 0, 0]), sparsePoints = sparsePoints.sort((a, b) => a[0] - b[0]);
        let numCursors = 0,
          previousLine = 0;
        for (let [line, type, num] of sparsePoints) {
          if (numCursors > 0) for (let index = previousLine; index < line && (index == 0 || index + this.windowLength <= lines.length); index++) snippets.push({
            score: numCursors,
            startLine: index,
            endLine: Math.min(lines.length, index + this.windowLength)
          });
          type === 0 ? numCursors += num : numCursors -= num, previousLine = line;
        }
        return snippets;
      }
    };
  });
function getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy = "cursorjaccard") {
  let matcherFactory;
  return neighboringSnippetTypes === "neighboringSnippet" ? matcherFactory = FixedWindowSizeJaccardMatcher.FACTORY(selection.snippetLength) : neighboringSnippetTypes === "neighboringFunction" ? matcherFactory = FunctionJaccardMatcher.FACTORY(selection.snippetLength) : ((0, zte.ok)(lineCursorHistory !== void 0, "lineCursorHistory should not be undefined"), matcherFactory = CursorHistoryMatcher.FACTORY(selection.snippetLength, lineCursorHistory, cursorSnippetsPickingStrategy)), matcherFactory.to(doc);
}
async function getNeighborSnippets(doc, neighbors, neighboringSnippetTypes, options, snippetSelectionOption, snippetSelectionK, lineCursorHistory, cursorSnippetsPickingStrategy) {
  let selection = {
      ...neighborOptionToSelection[options]
    },
    matcher = getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy);
  return selection.numberOfSnippets === 0 ? [] : (await neighbors.filter(neighbor => neighbor.source.length < MAX_CHARACTERS_PER_FILE && neighbor.source.length > 0).slice(0, MAX_NUMBER_OF_FILES).reduce(async (acc, neighbor) => (await acc).concat((await matcher.findMatches(neighbor, snippetSelectionOption, snippetSelectionK)).map(snippet => ({
    relativePath: neighbor.relativePath,
    ...snippet
  }))), Promise.resolve([]))).filter(neighbor => neighbor.score && neighbor.snippet && neighbor.score > selection.threshold).sort((a, b) => a.score - b.score).slice(-selection.numberOfSnippets);
}
var import_assert,
  NeighboringTabsOption,
  NeighboringSnippetType,
  neighborOptionToSelection,
  MAX_CHARACTERS_PER_FILE,
  MAX_NUMBER_OF_FILES,
  init_neighboringFiles = __esmMin(() => {
    "use strict";

    import_assert = require("assert");
    init_cursorMatching();
    init_jaccardMatching();
    NeighboringTabsOption = (u => (NeighboringTabsOption.None = "none", NeighboringTabsOption.Conservative = "conservative", NeighboringTabsOption.Medium = "medium", NeighboringTabsOption.Eager = "eager", NeighboringTabsOption.EagerButLittle = "eagerButLittle", NeighboringTabsOption.EagerButMedium = "eagerButMedium", NeighboringTabsOption.EagerButMuch = "eagerButMuch", NeighboringTabsOption.RetrievalComparable = "retrievalComparable", NeighboringTabsOption))(p_ || {}), NeighboringSnippetType = (n => (NeighboringSnippetType.NeighboringFunctions = "neighboringFunction", NeighboringSnippetType.NeighboringSnippets = "neighboringSnippet", NeighboringSnippetType.CursorHistoryMatcher = "cursorhistorymatcher", NeighboringSnippetType))(Cb || {}), neighborOptionToSelection = {
      none: {
        snippetLength: 1,
        threshold: -1,
        numberOfSnippets: 0
      },
      conservative: {
        snippetLength: 10,
        threshold: .3,
        numberOfSnippets: 1
      },
      medium: {
        snippetLength: 20,
        threshold: .1,
        numberOfSnippets: 2
      },
      eager: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButLittle: {
        snippetLength: 10,
        threshold: 0,
        numberOfSnippets: 1
      },
      eagerButMedium: {
        snippetLength: 20,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButMuch: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 6
      },
      retrievalComparable: {
        snippetLength: 30,
        threshold: 0,
        numberOfSnippets: 4
      }
    }, MAX_CHARACTERS_PER_FILE = 1e4, MAX_NUMBER_OF_FILES = 20;
    __name(getMatcher, "getMatcher");
    __name(getNeighborSnippets, "getNeighborSnippets");
  });
function findEditDistanceScore(a, b) {
  if (a.length === 0 || b.length === 0) return {
    score: a.length + b.length
  };
  let matrix = Array.from({
    length: a.length
  }).map(() => Array.from({
    length: b.length
  }).map(() => 0));
  for (let i = 0; i < a.length; i++) matrix[i][0] = i;
  for (let i = 0; i < b.length; i++) matrix[0][i] = i;
  for (let j = 0; j < b.length; j++) for (let i = 0; i < a.length; i++) matrix[i][j] = Math.min((i == 0 ? j : matrix[i - 1][j]) + 1, (j == 0 ? i : matrix[i][j - 1]) + 1, (i == 0 || j == 0 ? Math.max(i, j) : matrix[i - 1][j - 1]) + (a[i] == b[j] ? 0 : 1));
  return {
    score: matrix[a.length - 1][b.length - 1]
  };
}
var init_suffixMatchCriteria = __esmMin(() => {
  "use strict";

  __name(findEditDistanceScore, "findEditDistanceScore");
});
var PromptBackground,
  PromptChoices,
  PromptElementRanges,
  PromptWishlist,
  Priorities,
  init_wishlist = __esmMin(() => {
    "use strict";

    init_prompt();
    PromptBackground = class {
      constructor() {
        this.used = new Map();
        this.unused = new Map();
      }
      static {
        __name(this, "PromptBackground");
      }
      markUsed(element) {
        this.IsSnippet(element) && this.used.set(element.id, this.convert(element));
      }
      undoMarkUsed(element) {
        this.IsSnippet(element) && this.used.delete(element.id);
      }
      markUnused(element) {
        this.IsSnippet(element) && this.unused.set(element.id, this.convert(element));
      }
      convert(element) {
        return {
          score: element.score.toFixed(4),
          length: element.text.length
        };
      }
      IsSnippet(element) {
        return element.kind == "SimilarFile" || element.kind == "RetrievalSnippet";
      }
    }, PromptChoices = class {
      constructor() {
        this.used = new Map();
        this.unused = new Map();
        this.usedCounts = new Map();
        this.unusedCounts = new Map();
      }
      static {
        __name(this, "PromptChoices");
      }
      markUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) + element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) + 1);
      }
      undoMarkUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) - element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) - 1);
      }
      markUnused(element) {
        this.unused.set(element.kind, (this.unused.get(element.kind) || 0) + element.tokens), this.unusedCounts.set(element.kind, (this.unusedCounts.get(element.kind) || 0) + 1);
      }
    }, PromptElementRanges = class {
      constructor(usedElements) {
        this.ranges = new Array();
        let nextRangeStart = 0,
          previousKind;
        for (let {
          element: element
        } of usedElements) element.text.length !== 0 && (previousKind === "BeforeCursor" && element.kind === "BeforeCursor" ? this.ranges[this.ranges.length - 1].end += element.text.length : this.ranges.push({
          kind: element.kind,
          start: nextRangeStart,
          end: nextRangeStart + element.text.length
        }), previousKind = element.kind, nextRangeStart += element.text.length);
      }
      static {
        __name(this, "PromptElementRanges");
      }
    }, PromptWishlist = class {
      constructor(tokenizer, lineEndingOption) {
        this.tokenizer = tokenizer;
        this.content = [];
        this.tokenizer = tokenizer, this.lineEndingOption = lineEndingOption;
      }
      static {
        __name(this, "PromptWishlist");
      }
      getContent() {
        return [...this.content];
      }
      convertLineEndings(text) {
        return this.lineEndingOption === "unix" && (text = text.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), text;
      }
      append(text, kind, priority, tokens = this.tokenizer.tokenLength(text), score = NaN) {
        text = this.convertLineEndings(text);
        let id = this.content.length;
        return this.content.push({
          id: id,
          text: text,
          kind: kind,
          priority: priority,
          tokens: tokens,
          requires: [],
          excludes: [],
          score: score
        }), id;
      }
      appendLineForLine(text, kind, priority) {
        text = this.convertLineEndings(text);
        let rawLines = text.split(`
`);
        for (let i = 0; i < rawLines.length - 1; i++) rawLines[i] += `
`;
        let lines = [];
        rawLines.forEach((line, i) => {
          line === `
` && lines.length > 0 && !lines[lines.length - 1].endsWith(`

`) ? lines[lines.length - 1] += `
` : lines.push(line);
        });
        let returns = [];
        return lines.forEach((line, i) => {
          line !== "" && (returns.push(this.append(line, kind, priority)), i > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]));
        }), returns;
      }
      require(dependentId, dependeeId) {
        let dependent = this.content.find(e => e.id === dependentId),
          dependee = this.content.find(e => e.id === dependeeId);
        dependent && dependee && dependent.requires.push(dependee);
      }
      exclude(excludingId, excludedId) {
        let excluding = this.content.find(e => e.id === excludingId),
          excluded = this.content.find(e => e.id === excludedId);
        excluding && excluded && excluding.excludes.push(excluded);
      }
      fulfill(maxPromptLength) {
        let tallyOfChoices = new PromptChoices(),
          promptBackground = new PromptBackground(),
          indexedContent = this.content.map((e, i) => ({
            element: e,
            index: i
          }));
        indexedContent.sort((a, b) => a.element.priority === b.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
        let idsThatHaveAlreadyBeenAdded = new Set(),
          idsConflictingWithAlreadyAddedIds = new Set(),
          budgetBreakingElement,
          remainingContent = [],
          remainingBudget = maxPromptLength;
        indexedContent.forEach(e => {
          let element = e.element;
          if (remainingBudget >= 0 && (remainingBudget > 0 || budgetBreakingElement === void 0) && element.requires.every(r => idsThatHaveAlreadyBeenAdded.has(r.id)) && !idsConflictingWithAlreadyAddedIds.has(element.id)) {
            let budgetUse = element.tokens;
            remainingBudget >= budgetUse ? (remainingBudget -= budgetUse, idsThatHaveAlreadyBeenAdded.add(element.id), element.excludes.forEach(e => idsConflictingWithAlreadyAddedIds.add(e.id)), tallyOfChoices.markUsed(element), promptBackground.markUsed(element), remainingContent.push(e)) : budgetBreakingElement === void 0 ? budgetBreakingElement = e : (tallyOfChoices.markUnused(e.element), promptBackground.markUnused(e.element));
          } else tallyOfChoices.markUnused(element), promptBackground.markUnused(element);
        }), remainingContent.sort((a, b) => a.index - b.index);
        let prompt = remainingContent.reduce((a, b) => a + b.element.text, ""),
          promptLength = this.tokenizer.tokenLength(prompt);
        for (; promptLength > maxPromptLength;) {
          remainingContent.sort((a, b) => b.element.priority === a.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
          let removeAfterAll = remainingContent.pop();
          removeAfterAll && (tallyOfChoices.undoMarkUsed(removeAfterAll.element), tallyOfChoices.markUnused(removeAfterAll.element), promptBackground.undoMarkUsed(removeAfterAll.element), promptBackground.markUnused(removeAfterAll.element), budgetBreakingElement !== void 0 && (tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element)), budgetBreakingElement = void 0), remainingContent.sort((a, b) => a.index - b.index), prompt = remainingContent.reduce((a, b) => a + b.element.text, ""), promptLength = this.tokenizer.tokenLength(prompt);
        }
        let extendedContent = [...remainingContent];
        if (budgetBreakingElement !== void 0) {
          extendedContent.push(budgetBreakingElement), extendedContent.sort((a, b) => a.index - b.index);
          let prompt = extendedContent.reduce((a, b) => a + b.element.text, ""),
            promptLength = this.tokenizer.tokenLength(prompt);
          if (promptLength <= maxPromptLength) {
            tallyOfChoices.markUsed(budgetBreakingElement.element), promptBackground.markUsed(budgetBreakingElement.element);
            let promptElementRanges = new PromptElementRanges(extendedContent);
            return {
              prefix: prompt,
              suffix: "",
              prefixLength: promptLength,
              suffixLength: 0,
              promptChoices: tallyOfChoices,
              promptBackground: promptBackground,
              promptElementRanges: promptElementRanges
            };
          } else tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element);
        }
        let promptElementRanges = new PromptElementRanges(remainingContent);
        return {
          prefix: prompt,
          suffix: "",
          prefixLength: promptLength,
          suffixLength: 0,
          promptChoices: tallyOfChoices,
          promptBackground: promptBackground,
          promptElementRanges: promptElementRanges
        };
      }
    }, Priorities = class _Priorities {
      constructor() {
        this.registeredPriorities = [0, 1];
      }
      static {
        __name(this, "Priorities");
      }
      static {
        this.TOP = 1;
      }
      static {
        this.BOTTOM = 0;
      }
      register(priority) {
        if (priority > _Priorities.TOP || priority < _Priorities.BOTTOM) throw new Error("Priority must be between 0 and 1");
        return this.registeredPriorities.push(priority), priority;
      }
      justAbove(...priorities) {
        let priority = Math.max(...priorities),
          nearestNeighbor = Math.min(...this.registeredPriorities.filter(p => p > priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      justBelow(...priorities) {
        let priority = Math.min(...priorities),
          nearestNeighbor = Math.max(...this.registeredPriorities.filter(p => p < priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      between(lower, higher) {
        if (this.registeredPriorities.some(p => p > lower && p < higher) || !(this.registeredPriorities.includes(lower) && this.registeredPriorities.includes(higher))) throw new Error("Priorities must be adjacent in the list of priorities");
        return this.register((lower + higher) / 2);
      }
    };
  });
function normalizeLanguageId(languageId) {
  return languageId = languageId.toLowerCase(), languageNormalizationMap[languageId] ?? languageId;
}
async function getPrompt(fileSystem, doc, options = {}, snippets = []) {
  let completeOptions = new PromptOptions(fileSystem, options),
    tokenizer = getTokenizer(completeOptions.tokenizerName),
    useCachedSuffix = !1,
    {
      source: source,
      offset: offset
    } = doc;
  if (offset < 0 || offset > source.length) throw new Error(`Offset ${offset} is out of range.`);
  doc.languageId = normalizeLanguageId(doc.languageId);
  let priorities = new Priorities(),
    directContextPriority = priorities.justBelow(Priorities.TOP),
    languageMarkerPriority = completeOptions.languageMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
    pathMarkerPriority = completeOptions.pathMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
    localImportContextPriority = priorities.justBelow(directContextPriority),
    lowSnippetPriority = priorities.justBelow(localImportContextPriority),
    highSnippetPriority = priorities.justAbove(directContextPriority),
    promptWishlist = new PromptWishlist(tokenizer, completeOptions.lineEnding),
    languageSnippet = snippets.find(s => s.provider === "language"),
    languageMarkerLine;
  completeOptions.languageMarker !== "nomarker" && languageSnippet && (languageMarkerLine = promptWishlist.append(languageSnippet.snippet, "LanguageMarker", languageMarkerPriority));
  let pathSnippet = snippets.find(s => s.provider === "path"),
    pathMarkerLine;
  completeOptions.pathMarker !== "nomarker" && pathSnippet !== void 0 && pathSnippet.snippet.length > 0 && (pathMarkerLine = promptWishlist.append(pathSnippet.snippet, "PathMarker", pathMarkerPriority));
  let localImportSnippet = snippets.filter(s => s.provider === "local-import-context");
  if (completeOptions.localImportContext !== "nocontext") for (let localImportContext of localImportSnippet) promptWishlist.append(newLineEnded(localImportContext.snippet), "ImportedFile", localImportContextPriority);
  snippets = snippets.filter(s => s.provider !== "language" && s.provider !== "path" && s.provider !== "local-import-context");
  function addSnippetsNow() {
    let budget = Math.round(completeOptions.snippetPercent / 100 * completeOptions.maxPromptLength);
    processSnippetsForWishlist(snippets, doc.languageId, tokenizer, completeOptions.snippetProviderOptions, {
      priorities: priorities,
      low: lowSnippetPriority,
      high: highSnippetPriority
    }, completeOptions.numberOfSnippets, budget).forEach(snippet => {
      let kind = "SimilarFile";
      snippet.provider === "retrieval" ? kind = "RetrievalSnippet" : snippet.provider == "symbol-def" && (kind = "SymbolDefinition"), promptWishlist.append(snippet.announcedSnippet, kind, snippet.priority, snippet.tokens, snippet.normalizedScore);
    });
  }
  __name(addSnippetsNow, "addSnippetsNow"), completeOptions.snippetPosition === "top" && addSnippetsNow();
  let source_lines = [],
    directContext;
  if (directContext = source.substring(0, offset), completeOptions.snippetPosition === "aboveCursor") {
    let lastLineStart = directContext.lastIndexOf(`
`) + 1,
      directContextBeforePartialLastLine = directContext.substring(0, lastLineStart),
      partialLastLine = directContext.substring(lastLineStart);
    promptWishlist.appendLineForLine(directContextBeforePartialLastLine, "BeforeCursor", directContextPriority).forEach(id => source_lines.push(id)), addSnippetsNow(), partialLastLine.length > 0 && (source_lines.push(promptWishlist.append(partialLastLine, "AfterCursor", directContextPriority)), source_lines.length > 1 && promptWishlist.require(source_lines[source_lines.length - 2], source_lines[source_lines.length - 1]));
  } else promptWishlist.appendLineForLine(directContext, "BeforeCursor", directContextPriority).forEach(id => source_lines.push(id));
  completeOptions.languageMarker === "top" && source_lines.length > 0 && languageMarkerLine !== void 0 && promptWishlist.require(languageMarkerLine, source_lines[0]), completeOptions.pathMarker === "top" && source_lines.length > 0 && pathMarkerLine !== void 0 && (languageMarkerLine ? promptWishlist.require(pathMarkerLine, languageMarkerLine) : promptWishlist.require(pathMarkerLine, source_lines[0])), languageMarkerLine !== void 0 && pathMarkerLine !== void 0 && promptWishlist.exclude(pathMarkerLine, languageMarkerLine);
  let actualSuffix = source.slice(offset);
  if (completeOptions.suffixPercent === 0 || actualSuffix.length <= completeOptions.fimSuffixLengthThreshold) return promptWishlist.fulfill(completeOptions.maxPromptLength);
  {
    let offset = doc.offset;
    completeOptions.suffixStartMode !== "cursor" && completeOptions.suffixStartMode !== "cursortrimstart" && (offset = await getSiblingFunctionStart(doc));
    let availableTokens = completeOptions.maxPromptLength - TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
      prefixTargetTokens = Math.floor(availableTokens * (100 - completeOptions.suffixPercent) / 100),
      promptInfo = promptWishlist.fulfill(prefixTargetTokens),
      suffixTargetTokens = availableTokens - promptInfo.prefixLength,
      suffixText = source.slice(offset);
    (completeOptions.suffixStartMode === "siblingblocktrimstart" || completeOptions.suffixStartMode === "cursortrimstart") && (suffixText = suffixText.trimStart());
    let suffix = tokenizer.takeFirstTokens(suffixText, suffixTargetTokens);
    return suffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - suffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), completeOptions.suffixMatchCriteria === "equal" ? suffix.tokens.length === cachedSuffix.tokens.length && suffix.tokens.every((v, i) => v === cachedSuffix.tokens[i]) && (useCachedSuffix = !0) : completeOptions.suffixMatchCriteria === "levenshteineditdistance" && suffix.tokens.length > 0 && completeOptions.suffixMatchThreshold > 0 && 100 * findEditDistanceScore(suffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH), cachedSuffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH))?.score < completeOptions.suffixMatchThreshold * Math.min(MAX_EDIT_DISTANCE_LENGTH, suffix.tokens.length) && (useCachedSuffix = !0), useCachedSuffix === !0 && cachedSuffix.tokens.length <= suffixTargetTokens ? (cachedSuffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - cachedSuffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), promptInfo.suffix = cachedSuffix.text, promptInfo.suffixLength = cachedSuffix.tokens.length) : (promptInfo.suffix = suffix.text, promptInfo.suffixLength = suffix.tokens.length, cachedSuffix = suffix), promptInfo;
  }
}
var cachedSuffix,
  MAX_PROMPT_LENGTH,
  MAX_EDIT_DISTANCE_LENGTH,
  TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
  DEFAULT_NUM_OF_SNIPPETS,
  LanguageMarkerOption,
  PathMarkerOption,
  SnippetPositionOption,
  SnippetSelectionOption,
  LocalImportContextOption,
  LineEndingOptions,
  SuffixOption,
  SuffixMatchOption,
  SuffixStartMode,
  PromptOptions,
  languageNormalizationMap,
  init_prompt = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_siblingFunctions();
    init_cursorMatching();
    init_neighboringFiles();
    init_snippets();
    init_suffixMatchCriteria();
    init_tokenization();
    init_wishlist();
    cachedSuffix = {
      text: "",
      tokens: []
    }, MAX_PROMPT_LENGTH = 1500, MAX_EDIT_DISTANCE_LENGTH = 50, TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5, DEFAULT_NUM_OF_SNIPPETS = 4, LanguageMarkerOption = (n => (LanguageMarkerOption.NoMarker = "nomarker", LanguageMarkerOption.Top = "top", LanguageMarkerOption.Always = "always", LanguageMarkerOption))(ere || {}), PathMarkerOption = (n => (PathMarkerOption.NoMarker = "nomarker", PathMarkerOption.Top = "top", PathMarkerOption.Always = "always", PathMarkerOption))(tre || {}), SnippetPositionOption = (n => (SnippetPositionOption.TopOfText = "top", SnippetPositionOption.DirectlyAboveCursor = "aboveCursor", SnippetPositionOption.AfterSiblings = "afterSiblings", SnippetPositionOption))(rre || {}), SnippetSelectionOption = (r => (SnippetSelectionOption.BestMatch = "bestMatch", SnippetSelectionOption.TopK = "topK", SnippetSelectionOption))(u_ || {}), LocalImportContextOption = (r => (LocalImportContextOption.NoContext = "nocontext", LocalImportContextOption.Declarations = "declarations", LocalImportContextOption))(aL || {}), LineEndingOptions = (r => (LineEndingOptions.ConvertToUnix = "unix", LineEndingOptions.KeepOriginal = "keep", LineEndingOptions))(oL || {}), SuffixOption = (r => (SuffixOption.None = "none", SuffixOption.FifteenPercent = "fifteenPercent", SuffixOption))(nre || {}), SuffixMatchOption = (r => (SuffixMatchOption.Equal = "equal", SuffixMatchOption.Levenshtein = "levenshteineditdistance", SuffixMatchOption))(ire || {}), SuffixStartMode = (i => (SuffixStartMode.Cursor = "cursor", SuffixStartMode.CursorTrimStart = "cursortrimstart", SuffixStartMode.SiblingBlock = "siblingblock", SuffixStartMode.SiblingBlockTrimStart = "siblingblocktrimstart", SuffixStartMode))(sre || {}), PromptOptions = class {
      constructor(fs, options) {
        this.fs = fs;
        this.maxPromptLength = MAX_PROMPT_LENGTH;
        this.languageMarker = "top";
        this.pathMarker = "top";
        this.localImportContext = "nocontext";
        this.snippetPosition = "top";
        this.numberOfSnippets = DEFAULT_NUM_OF_SNIPPETS;
        this.snippetProviderOptions = {
          "neighboring-tabs": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          retrieval: {
            normalizationFunction: "affine",
            normalizationParams: [-1, 0]
          },
          "symbol-def": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0],
            reservedSnippetCount: 2
          },
          language: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          path: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          "local-import-context": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          }
        };
        this.neighboringTabs = "eager";
        this.neighboringSnippetTypes = "neighboringSnippet";
        this.lineEnding = "unix";
        this.suffixPercent = 0;
        this.snippetPercent = 0;
        this.suffixStartMode = "cursor";
        this.tokenizerName = "cl100k";
        this.suffixMatchThreshold = 0;
        this.suffixMatchCriteria = "levenshteineditdistance";
        this.fimSuffixLengthThreshold = 0;
        this.cursorSnippetsPickingStrategy = "cursorjaccard";
        if (options) {
          let selectionValue = options?.snippetSelection;
          if (selectionValue && !Object.values(SnippetSelectionOption).includes(selectionValue)) throw new Error(`Invalid value for snippetSelection: ${selectionValue}`);
          for (let key in options) if (key !== "snippetProviderOptions") this[key] = options[key];else {
            let newOptions = options.snippetProviderOptions || {},
              provider;
            for (provider in newOptions) {
              let providerOptions = newOptions[provider];
              providerOptions && (this.snippetProviderOptions[provider] = {
                ...this.snippetProviderOptions[provider],
                ...providerOptions
              });
            }
          }
        }
        if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);
        if (this.snippetPercent < 0 || this.snippetPercent > 100) throw new Error(`snippetPercent must be between 0 and 100, but was ${this.snippetPercent}`);
        if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100) throw new Error(`suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`);
        if (this.fimSuffixLengthThreshold < -1) throw new Error(`fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`);
        if (this.snippetSelection === "topK" && this.snippetSelectionK === void 0) throw new Error("snippetSelectionK must be defined.");
        if (this.snippetSelection === "topK" && this.snippetSelectionK && this.snippetSelectionK <= 0) throw new Error(`snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`);
      }
      static {
        __name(this, "PromptOptions");
      }
    }, languageNormalizationMap = {
      javascriptreact: "javascript",
      jsx: "javascript",
      typescriptreact: "typescript",
      jade: "pug",
      cshtml: "razor"
    };
    __name(normalizeLanguageId, "normalizeLanguageId");
    __name(getPrompt, "getPrompt");
  });
var ProviderTimeoutError,
  SnippetProvider,
  init_snippetProvider = __esmMin(() => {
    "use strict";

    init_orchestrator();
    ProviderTimeoutError = class extends Error {
      static {
        __name(this, "ProviderTimeoutError");
      }
      constructor(message) {
        super(message), this.name = "ProviderTimeoutError";
      }
    }, SnippetProvider = class {
      static {
        __name(this, "SnippetProvider");
      }
      constructor(workerProxy) {
        this.api = workerProxy;
      }
      getSnippets(context, signal) {
        return new Promise((resolve, reject) => {
          signal.aborted && reject({
            error: new ProviderTimeoutError("provider aborted"),
            providerType: this.type
          }), signal.addEventListener("abort", () => {
            reject({
              error: new ProviderTimeoutError(`max runtime exceeded: ${TIMEOUT_MS} ms`),
              providerType: this.type
            });
          }, {
            once: !0
          });
          let startTime = performance.now();
          this.buildSnippets(context).then(snippets => {
            let endTime = performance.now();
            resolve({
              snippets: snippets,
              providerType: this.type,
              runtime: endTime - startTime
            });
          }).catch(error => {
            reject({
              error: error,
              providerType: this.type
            });
          });
        });
      }
    };
  });
var LanguageSnippetProvider,
  init_language = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    LanguageSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "language";
      }
      static {
        __name(this, "LanguageSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getLanguageMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    };
  });
var LocalImportContextSnippetProvider,
  init_localImportContext = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    LocalImportContextSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "local-import-context";
      }
      static {
        __name(this, "LocalImportContextSnippetProvider");
      }
      formSnippets(imports, currentFile) {
        return imports.map(importPath => ({
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(importPath),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 1
        }));
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          options: options,
          fileSystem: fileSystem
        } = context;
        if (options.localImportContext == "nocontext") return [];
        let localImportContext = await this.api.extractLocalImportContext(currentFile, fileSystem);
        return this.formSnippets(localImportContext, currentFile);
      }
    };
  });
var NeighborFilesProvider,
  init_neighborFiles = __esmMin(() => {
    "use strict";

    init_lib();
    init_neighboringFiles();
    init_snippetProvider();
    NeighborFilesProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "neighboring-tabs";
      }
      static {
        __name(this, "NeighborFilesProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          neighborFiles: neighborFiles,
          options: options,
          lineCursorHistory: lineCursorHistory
        } = context;
        return options && neighborFiles && neighborFiles.length && options.neighboringTabs !== "none" ? await this.api.getNeighborSnippets(currentFile, neighborFiles, options.neighboringSnippetTypes, options.neighboringTabs, options.snippetSelection, options.snippetSelectionK, lineCursorHistory, options.cursorSnippetsPickingStrategy) : [];
      }
    };
  });
var PathSnippetProvider,
  init_path = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    PathSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "path";
      }
      static {
        __name(this, "PathSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getPathMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    };
  });
function resolveLocalTypeScriptImport(importerPath, imp) {
  let src = imp.namedChild(1)?.text.slice(1, -1);
  if (!src || !src.startsWith(".")) return null;
  if ((0, sh.extname)(src) === "") src = src + ".ts";else if ((0, sh.extname)(src) !== ".ts") return null;
  return (0, sh.join)((0, sh.dirname)(importerPath), src);
}
function getTypescriptImportedNames(imp) {
  let names = [];
  if (imp.namedChild(0)?.type === "import_clause") {
    let importClause = imp.namedChild(0);
    if (importClause?.namedChild(0)?.type === "named_imports") {
      let namedImports = importClause.namedChild(0);
      for (let namedImport of namedImports?.namedChildren ?? []) if (namedImport.type === "import_specifier") {
        let name = namedImport.childForFieldName("name")?.text;
        if (name) {
          let alias = namedImport.childForFieldName("alias")?.text;
          names.push({
            name: name,
            alias: alias
          });
        }
      }
    }
  }
  return names;
}
function extractTypeScriptDeclaration(srcString, defn) {
  let name = defn?.childForFieldName("name")?.text ?? "";
  switch (defn?.type) {
    case "ambient_declaration":
      return extractTypeScriptDeclaration(srcString, defn.namedChild(0));
    case "interface_declaration":
    case "enum_declaration":
    case "type_alias_declaration":
      return {
        name: name,
        decl: defn.text
      };
    case "function_declaration":
    case "function_signature":
      return {
        name: name,
        decl: extractTypeScriptFunctionDeclaration(srcString, defn)
      };
    case "class_declaration":
      {
        let memberDecls = extractTypeScriptBodyDecls(srcString, defn),
          decl = "";
        if (memberDecls) {
          let body = defn.childForFieldName("body");
          decl = `declare ${srcString.substring(defn.startIndex, body.startIndex + 1)}`, decl += memberDecls.map(d => `
` + d).join(""), decl += `
}`;
        }
        return {
          name: name,
          decl: decl
        };
      }
  }
  return {
    name: name,
    decl: ""
  };
}
function extractTypeScriptFunctionDeclaration(srcString, defn) {
  let endIndex = defn.childForFieldName("return_type")?.endIndex ?? defn.childForFieldName("parameters")?.endIndex;
  if (endIndex !== void 0) {
    let signature = srcString.substring(defn.startIndex, endIndex) + ";";
    return defn.type === "function_declaration" || defn.type === "function_signature" ? "declare " + signature : signature;
  }
  return "";
}
function getIndentation(srcString, node) {
  let i = node.startIndex - 1;
  for (; i >= 0 && (srcString[i] === " " || srcString[i] === "	");) i--;
  if (i < 0 || srcString[i] === `
`) return srcString.substring(i + 1, node.startIndex);
}
function getDocComment(srcString, node) {
  let docCommentNode = getFirstPrecedingComment(node);
  return docCommentNode ? srcString.substring(docCommentNode.startIndex, node.startIndex) : "";
}
function extractTypeScriptMemberDeclaration(srcString, defn) {
  if (defn?.firstChild?.type === "accessibility_modifier" && defn.firstChild.text === "private") return "";
  let commentNode = getFirstPrecedingComment(defn),
    indentation = getIndentation(srcString, commentNode ?? defn) ?? "  ",
    docComment = getDocComment(srcString, defn);
  switch (defn.type) {
    case "ambient_declaration":
      let inner = defn.namedChild(0);
      return inner ? indentation + docComment + extractTypeScriptMemberDeclaration(srcString, inner) : "";
    case "method_definition":
    case "method_signature":
      return indentation + docComment + extractTypeScriptFunctionDeclaration(srcString, defn);
    case "public_field_definition":
      {
        let endIndex = defn.childForFieldName("type")?.endIndex ?? defn.childForFieldName("name")?.endIndex;
        if (endIndex !== void 0) return indentation + docComment + srcString.substring(defn.startIndex, endIndex) + ";";
      }
  }
  return "";
}
function extractTypeScriptBodyDecls(srcString, defn) {
  let body = defn.childForFieldName("body");
  return body ? body.namedChildren.map(member => extractTypeScriptMemberDeclaration(srcString, member)).filter(decl => decl) : void 0;
}
async function getExportedDeclarations(uri, lang, fs) {
  let exports = new Map(),
    mtime = -1;
  try {
    mtime = (await fs.stat(uri)).mtime;
  } catch {
    return exports;
  }
  let entry = exportsCache.get(uri);
  if (entry && entry.mtime === mtime) return entry.exports;
  if (lang === "typescript") {
    let tree = null;
    try {
      let srcString = (await fs.readFile(uri)).toString();
      tree = await parseTreeSitter(lang, srcString);
      for (let em of queryExports(lang, tree.rootNode)) for (let ec of em.captures) {
        let exp = ec.node;
        if (exp.type === "export_statement") {
          let decl = exp.childForFieldName("declaration");
          if (decl?.hasError()) continue;
          let {
            name: name,
            decl: exportedDecl
          } = extractTypeScriptDeclaration(srcString, decl);
          if (name) {
            exportedDecl = getDocComment(srcString, exp) + exportedDecl;
            let exportedDecls = exports.get(name);
            exportedDecls || (exportedDecls = [], exports.set(name, exportedDecls)), exportedDecls.push(exportedDecl);
          }
        }
      }
    } catch {} finally {
      tree && tree.delete();
    }
  }
  if (exportsCache.size > EXPORTS_CACHE_HIGH_WATER_MARK) {
    for (let key of exportsCache.keys()) if (exportsCache.delete(key), exports.size <= EXPORTS_CACHE_LOW_WATER_MARK) break;
  }
  return exportsCache.set(uri, {
    mtime: mtime,
    exports: exports
  }), exports;
}
function getTypeScriptImports(root) {
  let imports = [];
  for (let toplevelStmt of root.namedChildren) toplevelStmt.type === "import_statement" && imports.push(toplevelStmt);
  return imports;
}
function lastTypeScriptLocalImportOffset(source) {
  let lastImport = -1;
  localImportRegex.lastIndex = -1;
  let m;
  do m = localImportRegex.exec(source), m && (lastImport = localImportRegex.lastIndex + m.length); while (m);
  if (lastImport === -1) return -1;
  let newlineAfterLastImport = source.indexOf(`
`, lastImport);
  return newlineAfterLastImport !== -1 ? newlineAfterLastImport : source.length;
}
async function extractTypeScriptLocalImportContext(source, uri, fs) {
  let languageId = "typescript",
    localImportContext = [],
    lastImportOffset = lastTypeScriptLocalImportOffset(source);
  if (lastImportOffset === -1) return localImportContext;
  source = source.substring(0, lastImportOffset);
  let tree = await parseTreeSitter(languageId, source);
  try {
    for (let imp of getTypeScriptImports(tree.rootNode)) {
      let srcUri = resolveLocalTypeScriptImport(uri, imp);
      if (!srcUri) continue;
      let importedNames = getTypescriptImportedNames(imp);
      if (importedNames.length === 0) continue;
      let exports = await getExportedDeclarations(srcUri, languageId, fs);
      for (let importedName of importedNames) exports.has(importedName.name) && localImportContext.push(...exports.get(importedName.name));
    }
  } finally {
    tree.delete();
  }
  return localImportContext;
}
async function extractLocalImportContext(doc, fs) {
  let {
      source: source,
      languageId: languageId
    } = doc,
    uri = ure.URI.parse(doc.uri);
  return languageId === "typescript" && uri.scheme === "file" ? extractTypeScriptLocalImportContext(source, uri.fsPath, fs ?? defaultFileSystem) : [];
}
var import_path,
  import_vscode_uri,
  exportsCache,
  EXPORTS_CACHE_LOW_WATER_MARK,
  EXPORTS_CACHE_HIGH_WATER_MARK,
  localImportRegex,
  init_localImportContext = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_vscode_uri = Ns(B1());
    init_fileSystem();
    init_parse();
    __name(resolveLocalTypeScriptImport, "resolveLocalTypeScriptImport");
    __name(getTypescriptImportedNames, "getTypescriptImportedNames");
    exportsCache = new Map(), EXPORTS_CACHE_LOW_WATER_MARK = 1e3, EXPORTS_CACHE_HIGH_WATER_MARK = 2e3;
    __name(extractTypeScriptDeclaration, "extractTypeScriptDeclaration");
    __name(extractTypeScriptFunctionDeclaration, "extractTypeScriptFunctionDeclaration");
    __name(getIndentation, "getIndentation");
    __name(getDocComment, "getDocComment");
    __name(extractTypeScriptMemberDeclaration, "extractTypeScriptMemberDeclaration");
    __name(extractTypeScriptBodyDecls, "extractTypeScriptBodyDecls");
    __name(getExportedDeclarations, "getExportedDeclarations");
    __name(getTypeScriptImports, "getTypeScriptImports");
    localImportRegex = /^\s*import\s*(type|)\s*\{[^}]*\}\s*from\s*['"]\./gm;
    __name(lastTypeScriptLocalImportOffset, "lastTypeScriptLocalImportOffset");
    __name(extractTypeScriptLocalImportContext, "extractTypeScriptLocalImportContext");
    __name(extractLocalImportContext, "extractLocalImportContext");
  });
function sleep(delay) {
  return new Promise(resolve => {
    setTimeout(() => resolve(`delay: ${delay}`), delay);
  });
}
var import_path,
  import_worker_threads,
  workerFns,
  WorkerProxy,
  workerProxy,
  init_workerProxy = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_worker_threads = require("worker_threads");
    init_localImportContext();
    init_neighboringFiles();
    __name(sleep, "sleep");
    workerFns = ["getNeighborSnippets", "extractLocalImportContext", "sleep"], WorkerProxy = class {
      constructor() {
        this.nextHandlerId = 0;
        this.handlers = new Map();
        this.fns = new Map();
        this.extractLocalImportContext = extractLocalImportContext;
        this.getNeighborSnippets = getNeighborSnippets;
        this.sleep = sleep;
        !Kf.isMainThread && Kf.workerData?.port && (wT(), process.cwd = () => Kf.workerData.cwd, this.configureWorkerResponse(Kf.workerData.port));
      }
      static {
        __name(this, "WorkerProxy");
      }
      initWorker() {
        let {
          port1: port1,
          port2: port2
        } = new Kf.MessageChannel();
        this.port = port1, this.worker = new Kf.Worker((0, yre.resolve)(__dirname, "..", "dist", "workerProxy.js"), {
          workerData: {
            port: port2,
            cwd: process.cwd()
          },
          transferList: [port2]
        }), this.port.on("message", m => this.handleMessage(m)), this.port.on("error", e => this.handleError(e));
      }
      startThreading() {
        if (this.worker) throw new Error("Worker thread already initialized.");
        this.proxyFunctions(), this.initWorker();
      }
      stopThreading() {
        this.worker && (this.worker.terminate(), this.worker.removeAllListeners(), this.worker = void 0, this.unproxyFunctions(), this.handlers.clear());
      }
      proxyFunctions() {
        for (let fn of workerFns) this.fns.set(fn, this[fn]), this.proxy(fn);
      }
      unproxyFunctions() {
        for (let fn of workerFns) {
          let originalFn = this.fns.get(fn);
          if (originalFn) this[fn] = originalFn;else throw new Error(`Unproxy function not found: ${fn}`);
        }
      }
      configureWorkerResponse(port) {
        this.port = port, this.port.on("message", async ({
          id: id,
          fn: fn,
          args: args
        }) => {
          let proxiedFunction = this[fn];
          if (!proxiedFunction) throw new Error(`Function not found: ${fn}`);
          try {
            let res = await proxiedFunction.apply(this, args);
            this.port.postMessage({
              id: id,
              res: res
            });
          } catch (err) {
            if (!(err instanceof Error)) throw err;
            typeof err.code == "string" ? this.port.postMessage({
              id: id,
              err: err,
              code: err.code
            }) : this.port.postMessage({
              id: id,
              err: err
            });
          }
        });
      }
      handleMessage({
        id: id,
        err: err,
        code: code,
        res: res
      }) {
        let handler = this.handlers.get(id);
        handler && (this.handlers.delete(id), err ? (err.code = code, handler.reject(err)) : handler.resolve(res));
      }
      handleError(maybeError) {
        console.log(maybeError);
        let err;
        if (maybeError instanceof Error) {
          err = maybeError, err.code === "MODULE_NOT_FOUND" && err.message?.endsWith("workerProxy.js'") && (err = new Error("Failed to load workerProxy.js"), err.code = "CopilotPromptLoadFailure");
          let ourStack = new Error().stack;
          err.stack && ourStack?.match(/^Error\n/) && (err.stack += ourStack.replace(/^Error/, ""));
        } else maybeError?.name === "ExitStatus" && typeof maybeError.status == "number" ? (err = new Error(`workerProxy.js exited with status ${maybeError.status}`), err.code = `CopilotPromptWorkerExit${maybeError.status}`) : err = new Error(`Non-error thrown: ${maybeError}`);
        for (let handler of this.handlers.values()) handler.reject(err);
        throw err;
      }
      proxy(fn) {
        this[fn] = function (...args) {
          let id = this.nextHandlerId++;
          return new Promise((resolve, reject) => {
            this.handlers.set(id, {
              resolve: resolve,
              reject: reject
            }), this.port?.postMessage({
              id: id,
              fn: fn,
              args: args
            });
          });
        };
      }
    }, workerProxy = new WorkerProxy();
  });
function isFulfilledResult(result) {
  return result.status === "fulfilled";
}
function isRejectedResult(result) {
  return result.status === "rejected";
}
function providersSnippets(results) {
  return results.filter(isFulfilledResult).flatMap(r => r.value.snippets);
}
function providersErrors(results) {
  return results.filter(isRejectedResult).flatMap(r => r.reason);
}
function providersPerformance(results) {
  let runtimes = {},
    timeouts = {};
  return results.forEach(result => {
    isFulfilledResult(result) ? runtimes[result.value.providerType] = Math.round(result.value.runtime) : result.reason.error instanceof ProviderTimeoutError && (timeouts[result.reason.providerType] = !0);
  }), {
    runtimes: runtimes,
    timeouts: timeouts
  };
}
var TIMEOUT_MS,
  defaultProviders,
  SnippetOrchestrator,
  init_orchestrator = __esmMin(() => {
    "use strict";

    init_language();
    init_localImportContext();
    init_neighborFiles();
    init_path();
    init_snippetProvider();
    init_workerProxy();
    TIMEOUT_MS = 300, defaultProviders = [LanguageSnippetProvider, PathSnippetProvider, NeighborFilesProvider, LocalImportContextSnippetProvider];
    __name(isFulfilledResult, "isFulfilledResult");
    __name(isRejectedResult, "isRejectedResult");
    __name(providersSnippets, "providersSnippets");
    __name(providersErrors, "providersErrors");
    __name(providersPerformance, "providersPerformance");
    SnippetOrchestrator = class {
      constructor(providers = defaultProviders) {
        this.startThreading = () => workerProxy.startThreading();
        this.stopThreading = () => workerProxy.stopThreading();
        this.providers = providers.map(provider => new provider(workerProxy));
      }
      static {
        __name(this, "SnippetOrchestrator");
      }
      async getSnippets(context) {
        let signal = AbortSignal.timeout(TIMEOUT_MS);
        return Promise.allSettled(this.providers.map(provider => provider.getSnippets(context, signal)));
      }
    };
  });
function getLineAtOffset(text, offset) {
  let prevNewline = text.lastIndexOf(`
`, offset - 1),
    nextNewline = text.indexOf(`
`, offset);
  return nextNewline < 0 && (nextNewline = text.length), text.slice(prevNewline + 1, nextNewline);
}
function rewindToNearestNonWs(text, offset) {
  let result = offset;
  for (; result > 0 && /\s/.test(text.charAt(result - 1));) result--;
  return result;
}
function indent(nd, source) {
  let startIndex = nd.startIndex,
    lineStart = nd.startIndex - nd.startPosition.column,
    prefix = source.substring(lineStart, startIndex);
  if (/^\s*$/.test(prefix)) return prefix;
}
function outdented(fst, snd, source) {
  if (snd.startPosition.row <= fst.startPosition.row) return !1;
  let fstIndent = indent(fst, source),
    sndIndent = indent(snd, source);
  return fstIndent !== void 0 && sndIndent !== void 0 && fstIndent.startsWith(sndIndent);
}
function getBlockParser(languageId) {
  return wasmLanguageToBlockParser[languageIdToWasmLanguage(languageId)];
}
async function isEmptyBlockStart(languageId, text, offset) {
  return isSupportedLanguageId(languageId) ? getBlockParser(languageId).isEmptyBlockStart(text, offset) : !1;
}
async function isBlockBodyFinished(languageId, prefix, completion, offset) {
  if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).isBlockBodyFinished(prefix, completion, offset);
}
async function getNodeStart(languageId, text, offset) {
  if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).getNodeStart(text, offset);
}
var BaseBlockParser,
  RegexBasedBlockParser,
  TreeSitterBasedBlockParser,
  wasmLanguageToBlockParser,
  init_parseBlock = __esmMin(() => {
    "use strict";

    init_parse();
    BaseBlockParser = class {
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        this.languageId = languageId;
        this.nodeMatch = nodeMatch;
        this.nodeTypesWithBlockOrStmtChild = nodeTypesWithBlockOrStmtChild;
      }
      static {
        __name(this, "BaseBlockParser");
      }
      async getNodeMatchAtPosition(text, offset, cb) {
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeToComplete = tree.rootNode.descendantForIndex(offset);
          for (; nodeToComplete;) {
            let blockNodeType = this.nodeMatch[nodeToComplete.type];
            if (blockNodeType) {
              if (!this.nodeTypesWithBlockOrStmtChild.has(nodeToComplete.type)) break;
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(nodeToComplete.type);
              if ((fieldLabel == "" ? nodeToComplete.namedChildren[0] : nodeToComplete.childForFieldName(fieldLabel))?.type == blockNodeType) break;
            }
            nodeToComplete = nodeToComplete.parent;
          }
          return nodeToComplete ? cb(nodeToComplete) : void 0;
        } finally {
          tree.delete();
        }
      }
      getNextBlockAtPosition(text, offset, cb) {
        return this.getNodeMatchAtPosition(text, offset, nodeToComplete => {
          let block = nodeToComplete.children.reverse().find(x => x.type == this.nodeMatch[nodeToComplete.type]);
          if (block) {
            if (this.languageId == "python" && block.parent) {
              let parent = block.parent.type == ":" ? block.parent.parent : block.parent,
                nextComment = parent?.nextSibling;
              for (; nextComment && nextComment.type == "comment";) {
                let commentInline = nextComment.startPosition.row == block.endPosition.row && nextComment.startPosition.column >= block.endPosition.column,
                  commentAtEnd = nextComment.startPosition.row > parent.endPosition.row && nextComment.startPosition.column > parent.startPosition.column;
                if (commentInline || commentAtEnd) block = nextComment, nextComment = nextComment.nextSibling;else break;
              }
            }
            if (!(block.endIndex >= block.tree.rootNode.endIndex - 1 && (block.hasError() || block.parent.hasError()))) return cb(block);
          }
        });
      }
      async isBlockBodyFinished(prefix, completion, offset) {
        let solution = (prefix + completion).trimEnd(),
          endIndex = await this.getNextBlockAtPosition(solution, offset, block => block.endIndex);
        if (endIndex !== void 0 && endIndex < solution.length) {
          let lengthOfBlock = endIndex - prefix.length;
          return lengthOfBlock > 0 ? lengthOfBlock : void 0;
        }
      }
      getNodeStart(text, offset) {
        let solution = text.trimEnd();
        return this.getNodeMatchAtPosition(solution, offset, block => block.startIndex);
      }
    }, RegexBasedBlockParser = class extends BaseBlockParser {
      constructor(languageId, blockEmptyMatch, lineMatch, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild);
        this.blockEmptyMatch = blockEmptyMatch;
        this.lineMatch = lineMatch;
      }
      static {
        __name(this, "RegexBasedBlockParser");
      }
      isBlockStart(line) {
        return this.lineMatch.test(line.trimStart());
      }
      async isBlockBodyEmpty(text, offset) {
        let res = await this.getNextBlockAtPosition(text, offset, block => {
          block.startIndex < offset && (offset = block.startIndex);
          let blockText = text.substring(offset, block.endIndex).trim();
          return blockText == "" || blockText.replace(/\s/g, "") == this.blockEmptyMatch;
        });
        return res === void 0 || res;
      }
      async isEmptyBlockStart(text, offset) {
        return offset = rewindToNearestNonWs(text, offset), this.isBlockStart(getLineAtOffset(text, offset)) && this.isBlockBodyEmpty(text, offset);
      }
    };
    __name(getLineAtOffset, "getLineAtOffset");
    __name(rewindToNearestNonWs, "rewindToNearestNonWs");
    __name(indent, "indent");
    __name(outdented, "outdented");
    TreeSitterBasedBlockParser = class extends BaseBlockParser {
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild, startKeywords, blockNodeType, emptyStatementType, curlyBraceLanguage) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild);
        this.startKeywords = startKeywords;
        this.blockNodeType = blockNodeType;
        this.emptyStatementType = emptyStatementType;
        this.curlyBraceLanguage = curlyBraceLanguage;
      }
      static {
        __name(this, "TreeSitterBasedBlockParser");
      }
      isBlockEmpty(block, offset) {
        let trimmed = block.text.trim();
        return this.curlyBraceLanguage && (trimmed.startsWith("{") && (trimmed = trimmed.slice(1)), trimmed.endsWith("}") && (trimmed = trimmed.slice(0, -1)), trimmed = trimmed.trim()), !!(trimmed.length == 0 || this.languageId == "python" && (block.parent?.type == "class_definition" || block.parent?.type == "function_definition") && block.children.length == 1 && queryPythonIsDocstring(block.parent));
      }
      async isEmptyBlockStart(text, offset) {
        if (offset > text.length) throw new RangeError("Invalid offset");
        for (let i = offset; i < text.length && text.charAt(i) != `
`; i++) if (/\S/.test(text.charAt(i))) return !1;
        offset = rewindToNearestNonWs(text, offset);
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeAtPos = tree.rootNode.descendantForIndex(offset - 1);
          if (nodeAtPos == null || this.curlyBraceLanguage && nodeAtPos.type == "}") return !1;
          if ((this.languageId == "javascript" || this.languageId == "typescript") && nodeAtPos.parent && nodeAtPos.parent.type == "object" && nodeAtPos.parent.text.trim() == "{") return !0;
          if (this.languageId == "typescript") {
            let currNode = nodeAtPos;
            for (; currNode.parent;) {
              if (currNode.type == "function_signature" || currNode.type == "method_signature") {
                let next = nodeAtPos.nextSibling;
                return next && currNode.hasError() && outdented(currNode, next, text) ? !0 : !currNode.children.find(c => c.type == ";") && currNode.endIndex <= offset;
              }
              currNode = currNode.parent;
            }
          }
          let errorNode = null,
            blockNode = null,
            blockParentNode = null,
            currNode = nodeAtPos;
          for (; currNode != null;) {
            if (currNode.type == this.blockNodeType) {
              blockNode = currNode;
              break;
            }
            if (this.nodeMatch[currNode.type]) {
              blockParentNode = currNode;
              break;
            }
            if (currNode.type == "ERROR") {
              errorNode = currNode;
              break;
            }
            currNode = currNode.parent;
          }
          if (blockNode != null) {
            if (!blockNode.parent || !this.nodeMatch[blockNode.parent.type]) return !1;
            if (this.languageId == "python") {
              let prevSibling = blockNode.previousSibling;
              if (prevSibling != null && prevSibling.hasError() && (prevSibling.text.startsWith('"""') || prevSibling.text.startsWith("'''"))) return !0;
            }
            return this.isBlockEmpty(blockNode, offset);
          }
          if (errorNode != null) {
            if (errorNode.previousSibling?.type == "module" || errorNode.previousSibling?.type == "internal_module" || errorNode.previousSibling?.type == "def") return !0;
            let children = [...errorNode.children].reverse(),
              keyword = children.find(child => this.startKeywords.includes(child.type)),
              block = children.find(child => child.type == this.blockNodeType);
            if (keyword) {
              switch (this.languageId) {
                case "python":
                  {
                    keyword.type == "try" && nodeAtPos.type == "identifier" && nodeAtPos.text.length > 4 && (block = children.find(child => child.hasError())?.children.find(child => child.type == "block"));
                    let colonNode,
                      parenCount = 0;
                    for (let child of errorNode.children) {
                      if (child.type == ":" && parenCount == 0) {
                        colonNode = child;
                        break;
                      }
                      child.type == "(" && (parenCount += 1), child.type == ")" && (parenCount -= 1);
                    }
                    if (colonNode && keyword.endIndex <= colonNode.startIndex && colonNode.nextSibling) {
                      if (keyword.type == "def") {
                        let sibling = colonNode.nextSibling;
                        if (sibling.type == '"' || sibling.type == "'" || sibling.type == "ERROR" && (sibling.text == '"""' || sibling.text == "'''")) return !0;
                      }
                      return !1;
                    }
                    break;
                  }
                case "javascript":
                  {
                    let formalParameters = children.find(child => child.type == "formal_parameters");
                    if (keyword.type == "class" && formalParameters) return !0;
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
                case "typescript":
                  {
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
              }
              return block && block.startIndex > keyword.endIndex ? this.isBlockEmpty(block, offset) : !0;
            }
          }
          if (blockParentNode != null) {
            let expectedType = this.nodeMatch[blockParentNode.type],
              block = blockParentNode.children.slice().reverse().find(x => x.type == expectedType);
            if (block) return this.isBlockEmpty(block, offset);
            if (this.nodeTypesWithBlockOrStmtChild.has(blockParentNode.type)) {
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(blockParentNode.type),
                child = fieldLabel == "" ? blockParentNode.children[0] : blockParentNode.childForFieldName(fieldLabel);
              if (child && child.type != this.blockNodeType && child.type != this.emptyStatementType) return !1;
            }
            return !0;
          }
          return !1;
        } finally {
          tree.delete();
        }
      }
    }, wasmLanguageToBlockParser = {
      python: new TreeSitterBasedBlockParser("python", {
        class_definition: "block",
        elif_clause: "block",
        else_clause: "block",
        except_clause: "block",
        finally_clause: "block",
        for_statement: "block",
        function_definition: "block",
        if_statement: "block",
        try_statement: "block",
        while_statement: "block",
        with_statement: "block"
      }, new Map(), ["def", "class", "if", "elif", "else", "for", "while", "try", "except", "finally", "with"], "block", null, !1),
      javascript: new TreeSitterBasedBlockParser("javascript", {
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        method_definition: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        with_statement: "statement_block",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      typescript: new TreeSitterBasedBlockParser("typescript", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      tsx: new TreeSitterBasedBlockParser("typescriptreact", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      go: new RegexBasedBlockParser("go", "{}", /\b(func|if|else|for)\b/, {
        communication_case: "block",
        default_case: "block",
        expression_case: "block",
        for_statement: "block",
        func_literal: "block",
        function_declaration: "block",
        if_statement: "block",
        labeled_statement: "block",
        method_declaration: "block",
        type_case: "block"
      }, new Map()),
      ruby: new RegexBasedBlockParser("ruby", "end", /\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\b|->/, {
        begin_block: "}",
        block: "}",
        end_block: "}",
        lambda: "block",
        for: "do",
        until: "do",
        while: "do",
        case: "end",
        do: "end",
        if: "end",
        method: "end",
        module: "end",
        unless: "end",
        do_block: "end"
      }, new Map())
    };
    __name(getBlockParser, "getBlockParser");
    __name(isEmptyBlockStart, "isEmptyBlockStart");
    __name(isBlockBodyFinished, "isBlockBodyFinished");
    __name(getNodeStart, "getNodeStart");
  });
var lib_exports = {};
__export(lib_exports, {
  CursorHistoryMatcher: () => CursorHistoryMatcher,
  CursorSnippetsPickingStrategy: () => CursorSnippetsPickingStrategy,
  DEFAULT_NUM_OF_SNIPPETS: () => DEFAULT_NUM_OF_SNIPPETS,
  DEFAULT_TREE_TRAVERSAL_CONFIG: () => DEFAULT_TREE_TRAVERSAL_CONFIG,
  ElidableText: () => ElidableText,
  FileSystem: () => FileSystem,
  LanguageMarkerOption: () => LanguageMarkerOption,
  LineEndingOptions: () => LineEndingOptions,
  LineWithValueAndCost: () => LineWithValueAndCost,
  LocalImportContextOption: () => LocalImportContextOption,
  MAX_EDIT_DISTANCE_LENGTH: () => MAX_EDIT_DISTANCE_LENGTH,
  MAX_PROMPT_LENGTH: () => MAX_PROMPT_LENGTH,
  NeighboringSnippetType: () => NeighboringSnippetType,
  NeighboringTabsOption: () => NeighboringTabsOption,
  PathMarkerOption: () => PathMarkerOption,
  PromptOptions: () => PromptOptions,
  ProviderTimeoutError: () => ProviderTimeoutError,
  SnippetOrchestrator: () => SnippetOrchestrator,
  SnippetPositionOption: () => SnippetPositionOption,
  SnippetProviderType: () => SnippetProviderType,
  SnippetSelectionOption: () => SnippetSelectionOption,
  SnippetSemantics: () => SnippetSemantics,
  SuffixMatchOption: () => SuffixMatchOption,
  SuffixOption: () => SuffixOption,
  SuffixStartMode: () => SuffixStartMode,
  TOKENS_RESERVED_FOR_SUFFIX_ENCODING: () => TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
  TokenizerName: () => TokenizerName,
  WASMLanguage: () => WASMLanguage,
  blankNode: () => blankNode,
  buildLabelRules: () => buildLabelRules,
  clearLabels: () => clearLabels,
  clearLabelsIf: () => clearLabelsIf,
  combineClosersAndOpeners: () => combineClosersAndOpeners,
  comment: () => comment,
  commentBlockAsSingles: () => commentBlockAsSingles,
  createWorker: () => createWorker,
  cutTreeAfterLine: () => cutTreeAfterLine,
  deparseAndCutTree: () => deparseAndCutTree,
  deparseLine: () => deparseLine,
  deparseTree: () => deparseTree,
  describeTree: () => describeTree,
  duplicateTree: () => duplicateTree,
  elidableTextForDiff: () => elidableTextForDiff,
  elidableTextForSourceCode: () => elidableTextForSourceCode,
  encodeTree: () => encodeTree,
  firstLineOf: () => firstLineOf,
  flattenVirtual: () => flattenVirtual,
  foldTree: () => foldTree,
  fromTreeWithFocussedLines: () => fromTreeWithFocussedLines,
  fromTreeWithValuedLines: () => fromTreeWithValuedLines,
  getAncestorWithSiblingFunctions: () => getAncestorWithSiblingFunctions,
  getBlockCloseToken: () => getBlockCloseToken,
  getBlockParser: () => getBlockParser,
  getCallSites: () => getCallSites,
  getCursorContext: () => getCursorContext,
  getFirstPrecedingComment: () => getFirstPrecedingComment,
  getFunctionPositions: () => getFunctionPositions,
  getLanguage: () => getLanguage,
  getNodeStart: () => getNodeStart,
  getPrompt: () => getPrompt,
  getTokenizer: () => getTokenizer,
  groupBlocks: () => groupBlocks,
  isBlank: () => isBlank,
  isBlockBodyFinished: () => isBlockBodyFinished,
  isEmptyBlockStart: () => isEmptyBlockStart,
  isFunction: () => isFunction,
  isFunctionDefinition: () => isFunctionDefinition,
  isLine: () => isLine,
  isSupportedLanguageId: () => isSupportedLanguageId,
  isTop: () => isTop,
  isVirtual: () => isVirtual,
  labelLines: () => labelLines,
  labelVirtualInherited: () => labelVirtualInherited,
  languageCommentMarkers: () => languageCommentMarkers,
  languageIdToWasmLanguage: () => languageIdToWasmLanguage,
  lastLineOf: () => lastLineOf,
  lineNode: () => lineNode,
  mapLabels: () => mapLabels,
  normalizeLanguageId: () => normalizeLanguageId,
  parseRaw: () => parseRaw,
  parseTree: () => parseTree,
  parseTreeSitter: () => parseTreeSitter,
  parsesWithoutError: () => parsesWithoutError,
  providersErrors: () => providersErrors,
  providersPerformance: () => providersPerformance,
  providersSnippets: () => providersSnippets,
  queryExports: () => queryExports,
  queryFunctions: () => queryFunctions,
  queryGlobalVars: () => queryGlobalVars,
  queryImports: () => queryImports,
  queryPythonIsDocstring: () => queryPythonIsDocstring,
  rebuildTree: () => rebuildTree,
  registerLanguageSpecificParser: () => registerLanguageSpecificParser,
  resetLineNumbers: () => resetLineNumbers,
  topNode: () => topNode,
  virtualNode: () => virtualNode,
  visitTree: () => visitTree,
  visitTreeConditionally: () => visitTreeConditionally
});
function createWorker() {
  return new Are.Worker((0, Ire.resolve)(__dirname, "..", "dist", "worker.js"), {
    workerData: {
      cwd: process.cwd()
    }
  });
}
var import_path,
  import_worker_threads,
  init_lib = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_worker_threads = require("worker_threads");
    init_elidableText();
    init_fileSystem();
    init_indentation();
    init_languageMarker();
    init_orchestrator();
    init_parse();
    init_parseBlock();
    init_prompt();
    init_cursorContext();
    init_cursorMatching();
    init_neighboringFiles();
    init_selectRelevance();
    init_snippets();
    init_snippetProvider();
    init_tokenization();
    __name(createWorker, "createWorker");
  });

var extension_exports = {};
__export(extension_exports, {
  Extension: () => Extension,
  activate: () => activate,
  createExtensionContext: () => createExtensionContext,
  onDeactivate: () => onDeactivate
});
module.exports = __toCommonJS(extension_exports);
var import_register = Ns(wT()),
  import_copilot_promptlib = Ns(Dc()),
  import_vscode = require("vscode");
var import_events = require("events");
var Clock = class {
  static {
    __name(this, "Clock");
  }
  now() {
    return new Date();
  }
};
var import_copilot_promptlib = Ns(Dc());
var CopilotConfigPrefix = "github.copilot";
var import_copilot_promptlib = Ns(Dc());
var import_crypto_js = Ns(o8());
function keyForPrompt(prompt) {
  return (0, a8.SHA256)(a8.enc.Utf16.parse(prompt.prefix + prompt.suffix)).toString();
}
__name(keyForPrompt, "keyForPrompt");
var LRUCacheMap = class {
  constructor(size = 10) {
    this.valueMap = new Map();
    this.lruKeys = [];
    this.sizeLimit = size;
  }
  static {
    __name(this, "LRUCacheMap");
  }
  set(key, value) {
    let maybeKeyToDelete;
    return this.valueMap.has(key) ? maybeKeyToDelete = key : this.lruKeys.length >= this.sizeLimit && (maybeKeyToDelete = this.lruKeys[0]), maybeKeyToDelete !== void 0 && this.delete(maybeKeyToDelete), this.valueMap.set(key, value), this.touchKeyInLRU(key), this;
  }
  get(key) {
    if (this.valueMap.has(key)) {
      let entry = this.valueMap.get(key);
      return this.touchKeyInLRU(key), entry;
    }
  }
  delete(key) {
    return this.has(key) ? (this.removeKeyFromLRU(key), this.valueMap.get(key) !== void 0 && this.valueMap.delete(key), !0) : !1;
  }
  clear() {
    this.valueMap.clear(), this.lruKeys = [];
  }
  get size() {
    return this.valueMap.size;
  }
  keys() {
    return this.lruKeys.slice().values();
  }
  values() {
    return new Map(this.valueMap).values();
  }
  entries() {
    return new Map(this.valueMap).entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  has(key) {
    return this.valueMap.has(key);
  }
  forEach(callbackfn, thisArg) {
    new Map(this.valueMap).forEach(callbackfn, thisArg);
  }
  get [Symbol.toStringTag]() {
    return "LRUCacheMap";
  }
  peek(key) {
    return this.valueMap.get(key);
  }
  removeKeyFromLRU(key) {
    let index = this.lruKeys.indexOf(key);
    index !== -1 && this.lruKeys.splice(index, 1);
  }
  touchKeyInLRU(key) {
    this.removeKeyFromLRU(key), this.lruKeys.push(key);
  }
};
var contextualFilterIntercept = -.3043572714994554,
  contextualFilterWeights = [.9978708359643611, .7001905605239328, -.1736749244124868, -.22994157947320112, .13406692641682572, -.007751370662011853, .0057783222035240715, .41910878254476003, -.1621657125711092, .13770814958908187, -.06036011308184006, -.07351180985800129, 0, -.05584878151248109, .30618794079412015, -.1282197982598485, .10951859303997555, .1700461782788777, -.3346057842644757, .22497985923128136, 0, -.44038101825774356, -.6540115939236782, .16595600081341702, .20733910722385135, -.1337033766105696, -.06923072125290894, -.05806684191976292, .3583334671633344, -.47357732824944315, .17810871365594377, .42268219963946685, 0, 0, -.16379620467004602, -.43893868831061167, 0, .11570094006709251, .9326431262654882, -.9990110509203912, -.44125275652726503, -.15840786997162004, -.4600396256644451, -.018814811994044403, .09230944537175266, .025814790934742798, -1.0940162204190154, -.9407503631235489, -.9854303778694269, -1.1045822488262245, -1.1417299456573262, -1.5623704405345513, -.4157473855795939, -1.0244257735561713, -.7477401944601753, -1.1275109699068402, -.0714715633552533, -1.1408628006786907, -1.0409898655074672, -.2288889836518878, -.5469549893760344, -.181946611106845, .1264329316374918, 0, 0, .312206968554707, -.3656436392517924, .23655650686038968, .1014912419901576, 0, .06287549221765308, 0, 0, .19027065218932154, -.8519502045974378, 0, .23753599905971923, .2488809322489166, .019969251907983224, 0, .06916505526229488, .29053356359188204, -.14484456555431657, .014768129429370188, -.15051464926341374, .07614835502776021, -.3317489901313935, 0, 0, .04921938684669103, -.28248576768353445, -.9708816204525345, -1.3560464522265527, .014165375212383239, -.23924166472544983, .10006595730248855, .09867233147279562, .32330430333220644, -.058625706114180595, .17149853105783947, .4436484054395367, .047189049576707255, .16832520944790552, .1117259900942179, -.35469010329927253, 0, -.1528189124465582, -.3804848349564939, .07278077320753953, .13263786480064088, .22920682659292527, 1.1512955314336537, 0, .016939862282340023, .4242994650403408, .12759835577444986, -.5577261135825583, -.19764560943067672, -.4042102444736004, .12063461617733708, -.2933966817484834, .2715683893968593, 0, -.7138548251238751, 0, -.023066228703035277, 0, -.06383043976746139, .09683723720709651, -.7337151424080791, 0, -.27191370124625525, .2819781269656171, -.08711496549050252, .11048604909969338, -.0934849550450534, .0721001250772912, .2589126797890794, .6729582659532254, -.21921032738244908, -.21535277468651456, -.45474006124091354, -.05861820126419139, -.007875306207720204, -.056661261678809284, .17727881404222662, .23603713348534658, .17485861412377932, -.5737483768696752, -.38220029570342745, -.5202722985519168, -.37187947527657256, .47155277792990113, -.12077912346691123, .47825628981545326, .4736704404000214, -.1615218651546898, .18362447973513005, 0, 0, -.18183417425866824, 0, 0, -.2538532305733833, -.1303692690676528, -.4073577969188216, .04172985870928789, -.1704527388573901, 0, 0, .7536858953385828, -.44703159588787644, 0, -.7246484085580873, -.21378128540782063, 0, .037461090552656146, -.16205852364367032, -.10973952064404884, .017468043407647377, -.1288980387397392, 0, 0, 0, -1.218692715379445, .05536949662193305, -.3763799844799116, -.1845001725624579, -.1615576298149558, 0, -.15373262203249874, -.04603412604270418, 0, -.3068149681460828, .09412352468269412, 0, .09116543650609721, .06065865264082559, .05688267379386188, -.05873945477722306, 0, .14532465133322153, .1870857769705463, .36304258043185555, .1411392422180405, .0630388629716367, 0, -1.1170522012450395, .16133697772771127, .15908534390781448, -.23485453704002232, -.1419980841417892, .21909510179526218, .39948420260153766, .40802294284289187, .15403767653746853, 0, .19764784115096676, .584914157527457, 0, -.4573883817015294],
  contextualFilterLanguageMap = {
    javascript: 1,
    typescript: 2,
    typescriptreact: 3,
    python: 4,
    vue: 5,
    php: 6,
    dart: 7,
    javascriptreact: 8,
    go: 9,
    css: 10,
    cpp: 11,
    html: 12,
    scss: 13,
    markdown: 14,
    csharp: 15,
    java: 16,
    json: 17,
    rust: 18,
    ruby: 19,
    c: 20
  },
  contextualFilterCharacterMap = {
    " ": 1,
    "!": 2,
    '"': 3,
    "#": 4,
    $: 5,
    "%": 6,
    "&": 7,
    "'": 8,
    "(": 9,
    ")": 10,
    "*": 11,
    "+": 12,
    ",": 13,
    "-": 14,
    ".": 15,
    "/": 16,
    0: 17,
    1: 18,
    2: 19,
    3: 20,
    4: 21,
    5: 22,
    6: 23,
    7: 24,
    8: 25,
    9: 26,
    ":": 27,
    ";": 28,
    "<": 29,
    "=": 30,
    ">": 31,
    "?": 32,
    "@": 33,
    A: 34,
    B: 35,
    C: 36,
    D: 37,
    E: 38,
    F: 39,
    G: 40,
    H: 41,
    I: 42,
    J: 43,
    K: 44,
    L: 45,
    M: 46,
    N: 47,
    O: 48,
    P: 49,
    Q: 50,
    R: 51,
    S: 52,
    T: 53,
    U: 54,
    V: 55,
    W: 56,
    X: 57,
    Y: 58,
    Z: 59,
    "[": 60,
    "\\": 61,
    "]": 62,
    "^": 63,
    _: 64,
    "`": 65,
    a: 66,
    b: 67,
    c: 68,
    d: 69,
    e: 70,
    f: 71,
    g: 72,
    h: 73,
    i: 74,
    j: 75,
    k: 76,
    l: 77,
    m: 78,
    n: 79,
    o: 80,
    p: 81,
    q: 82,
    r: 83,
    s: 84,
    t: 85,
    u: 86,
    v: 87,
    w: 88,
    x: 89,
    y: 90,
    z: 91,
    "{": 92,
    "|": 93,
    "}": 94,
    "~": 95
  };
var CommitFileResolver = class {
  static {
    __name(this, "CommitFileResolver");
  }
};
var path = require("path");
function getRelativePath(workspaceFolders, docURI) {
  for (let uri of workspaceFolders) {
    let parentURI = `${uri}/`;
    if (docURI.toString().startsWith(parentURI)) return docURI.toString().slice(parentURI.length);
  }
}
__name(getRelativePath, "getRelativePath");
var TextDocumentManager = class {
  static {
    __name(this, "TextDocumentManager");
  }
  async getWorkspaceFolder(doc) {
    return this.getWorkspaceFolders().find(folder => {
      if (doc.uri.toString().startsWith(folder.toString())) return folder;
    });
  }
  async getRelativePath(doc) {
    if (doc.uri.scheme !== "untitled") return getRelativePath(this.getWorkspaceFolders(), doc.uri) ?? path.basename(doc.uri.fsPath);
  }
};
var WorkspaceFileSystem = class {
  static {
    __name(this, "WorkspaceFileSystem");
  }
};
var import_vscode_uri = Ns(B1());
var MAX_NUM_FILES = 100,
  CursorHistoryManager = class {
    static {
      __name(this, "CursorHistoryManager");
    }
    constructor() {
      this.lineCursorHistory = new LRUCacheMap(MAX_NUM_FILES), this.fileCursorHistory = new LRUCacheMap(MAX_NUM_FILES);
    }
    add(doc, line, timestamp) {
      let uri = doc.uri.toString(),
        singleFile = this.lineCursorHistory.get(uri) ?? new Map(),
        numFocused = singleFile.get(line) ?? 0;
      singleFile.set(line, numFocused + 1), this.lineCursorHistory.set(uri, singleFile), this.fileCursorHistory.set(uri, {
        uri: uri,
        doc: doc,
        clickCount: (this.fileCursorHistory.get(uri)?.clickCount ?? 0) + 1,
        lastClickTime: timestamp
      });
    }
    getDocs() {
      let docs = [];
      for (let key of this.fileCursorHistory.keys()) {
        let docTime = this.fileCursorHistory.get(key);
        docTime !== void 0 && docs.push(docTime);
      }
      return docs;
    }
    sortedDocsByClickTime() {
      return this.getDocs().sort((a, b) => b.lastClickTime - a.lastClickTime).map(f => f.doc);
    }
    sortedDocsByClickCount() {
      return this.getDocs().sort((a, b) => b.clickCount === a.clickCount ? b.lastClickTime - a.lastClickTime : b.clickCount - a.clickCount).map(f => f.doc);
    }
  };
var accessTimes = new LRUCacheMap();
function sortByAccessTimes(docs) {
  return [...docs].sort((a, b) => {
    let aAccessTime = accessTimes.get(a.uri.toString()) ?? 0;
    return (accessTimes.get(b.uri.toString()) ?? 0) - aAccessTime;
  });
}
__name(sortByAccessTimes, "sortByAccessTimes");
var registerDocumentTracker = __name(ctx => ctx.get(TextDocumentManager).onDidFocusTextDocument(e => {
    e && accessTimes.set(e.document.uri.toString(), Date.now());
  }), "registerDocumentTracker"),
  cursorHistoryManager = new CursorHistoryManager(),
  registerCursorTracker = __name(ctx => ctx.get(TextDocumentManager).onDidChangeCursor(e => {
    if (e && e.selections) for (let selection of e.selections) cursorHistoryManager.add(e.textEditor.document, selection.anchor.line, Date.now()), cursorHistoryManager.add(e.textEditor.document, selection.active.line, Date.now());
  }), "registerCursorTracker");
var CoCommittedFiles = class _CoCommittedFiles {
  constructor(docManager, commitFileResolver) {
    this.docManager = docManager;
    this.commitFileResolver = commitFileResolver;
    this.cocommittedFilesCache = this.computeInBackgroundAndMemoize(_CoCommittedFiles.getCoCommittedFiles, 1);
  }
  static {
    __name(this, "CoCommittedFiles");
  }
  async tryGetTextDocument(uri) {
    try {
      return await this.docManager.getTextDocument(FB.URI.parse(uri));
    } catch {
      return;
    }
  }
  static async getCoCommittedFiles(ns, fileURI, neighboringFileType, languageId, maxNumFiles) {
    if (ns.commitFileResolver === void 0) return [];
    let coCommittedFiles = await ns.commitFileResolver.getCoCommitResult(fileURI, maxNumFiles),
      totalLen = 0,
      files = [];
    for (let cocommittedFile of coCommittedFiles) {
      if (cocommittedFile.toString() === fileURI.toString()) continue;
      let doc = await ns.tryGetTextDocument(cocommittedFile.toString());
      if (!(doc === void 0 || totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && doc.uri.scheme == "file" && doc.languageId === languageId && (files.push({
        uri: doc.uri.toString(),
        relativePath: await ns.docManager.getRelativePath(doc),
        languageId: doc.languageId,
        source: doc.getText()
      }), totalLen += doc.getText().length, files.length >= maxNumFiles)) break;
    }
    return files;
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && doc.languageId === languageId && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  computeInBackgroundAndMemoize(fct, cacheSize) {
    let resultsCache = new LRUCacheMap(cacheSize),
      inComputation = new Set();
    return (fileURI, type, ...args) => {
      let key = fileURI.toString() + type,
        memorizedComputation = resultsCache.get(key);
      if (memorizedComputation) return memorizedComputation;
      if (inComputation.has(key)) return null;
      let computation = fct(this, fileURI, type, ...args);
      return inComputation.add(key), computation.then(computedResult => {
        resultsCache.set(key, computedResult), inComputation.delete(key);
      }), null;
    };
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    if (neighborFiles = await this.truncateDocs(sortByAccessTimes((await this.docManager.textDocuments()).filter(doc => accessTimes.get(doc.uri.toString()) !== void 0)), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), neighborFiles.length < maxNumNeighborFiles) {
      let cocommittedFiles = this.cocommittedFilesCache(uri, neighboringFileType, languageId, maxNumNeighborFiles);
      if (cocommittedFiles !== null) {
        let neighborFileUriSet = new Set(neighborFiles.map(f => f.uri));
        cocommittedFiles = cocommittedFiles.filter(f => !neighborFileUriSet.has(f.uri)).slice(0, maxNumNeighborFiles - neighborFiles.length), neighborFiles.push(...cocommittedFiles), neighborSource.set(neighboringFileType, cocommittedFiles.map(f => f.uri));
      }
    }
    return {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var CursorHistoryFiles = class {
  constructor(docManager) {
    this.docManager = docManager;
  }
  static {
    __name(this, "CursorHistoryFiles");
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    return neighboringFileType === "cursormostrecent" ? (neighborFiles = await this.truncateDocs(cursorHistoryManager.sortedDocsByClickTime(), uri, languageId, maxNumNeighborFiles), neighborSource.set("cursormostrecent", neighborFiles.map(f => f.uri))) : neighboringFileType === "cursormostcount" && (neighborFiles = await this.truncateDocs(cursorHistoryManager.sortedDocsByClickCount(), uri, languageId, maxNumNeighborFiles), neighborSource.set("cursormostcount", neighborFiles.map(f => f.uri))), {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var OpenTabFiles = class {
  constructor(docManager) {
    this.docManager = docManager;
  }
  static {
    __name(this, "OpenTabFiles");
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    return neighborFiles = await this.truncateDocs(sortByAccessTimes(await this.docManager.textDocuments()), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var path = Ns(require("path")),
  import_vscode_uri = Ns(B1());
var knownLanguages = {
  abap: {
    extensions: [".abap"]
  },
  bat: {
    extensions: [".bat", ".cmd"]
  },
  bibtex: {
    extensions: [".bib", ".bibtex"]
  },
  blade: {
    extensions: [".blade", ".blade.php"]
  },
  c: {
    extensions: [".c", ".cats", ".h", ".idc"]
  },
  csharp: {
    extensions: [".cake", ".cs", ".csx", ".linq"]
  },
  cpp: {
    extensions: [".c++", ".cc", ".cp", ".cpp", ".cxx", ".h", ".h++", ".hh", ".hpp", ".hxx", ".inc", ".inl", ".ino", ".ipp", ".ixx", ".re", ".tcc", ".tpp", ".i"]
  },
  css: {
    extensions: [".css", ".wxss"]
  },
  clojure: {
    extensions: [".bb", ".boot", ".cl2", ".clj", ".cljc", ".cljs", ".cljs.hl", ".cljscm", ".cljx", ".edn", ".hic"],
    filenames: ["riemann.config"]
  },
  ql: {
    extensions: [".ql", ".qll"]
  },
  coffeescript: {
    extensions: ["._coffee", ".cake", ".cjsx", ".coffee", ".iced"],
    filenames: ["Cakefile"]
  },
  dart: {
    extensions: [".dart"]
  },
  dockerfile: {
    extensions: [".dockerfile"],
    filenames: ["Containerfile", "Dockerfile"]
  },
  html: {
    extensions: [".ect", ".ejs", ".ejs.t", ".jst", ".hta", ".htm", ".html", ".html.hl", ".html5", ".inc", ".jsp", ".tpl", ".twig", ".wxml", ".xht", ".xhtml", ".phtml", ".liquid"]
  },
  elixir: {
    extensions: [".ex", ".exs"],
    filenames: ["mix.lock"]
  },
  erlang: {
    extensions: [".app.src", ".erl", ".es", ".escript", ".hrl", ".xrl", ".yrl"],
    filenames: ["Emakefile", "rebar.config", "rebar.config.lock", "rebar.lock"]
  },
  fsharp: {
    extensions: [".fs", ".fsi", ".fsx"]
  },
  go: {
    extensions: [".go"]
  },
  groovy: {
    extensions: [".gradle", ".groovy", ".grt", ".gtpl", ".gvy", ".jenkinsfile"],
    filenames: ["Jenkinsfile", "Jenkinsfile"]
  },
  terraform: {
    extensions: [".hcl", ".nomad", ".tf", ".tfvars", ".workflow"]
  },
  erb: {
    extensions: [".erb", ".erb.deface", ".rhtml"]
  },
  razor: {
    extensions: [".cshtml", ".razor"]
  },
  haml: {
    extensions: [".haml", ".haml.deface"]
  },
  handlebars: {
    extensions: [".handlebars", ".hbs"]
  },
  haskell: {
    extensions: [".hs", ".hs-boot", ".hsc"]
  },
  ini: {
    extensions: [".cfg", ".dof", ".ini", ".lektorproject", ".prefs", ".pro", ".properties", ".url"],
    filenames: [".coveragerc", ".flake8", ".pylintrc", "buildozer.spec", "pylintrc"]
  },
  jsonc: {
    extensions: [".code-snippets", ".code-workspace", ".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"],
    filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "launch.json", "settings.json", "tsconfig.json", "tslint.json"]
  },
  java: {
    extensions: [".jav", ".java", ".jsh"]
  },
  javascript: {
    extensions: ["._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".js", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"],
    filenames: ["Jakefile"]
  },
  julia: {
    extensions: [".jl"]
  },
  python: {
    extensions: [".ipynb", ".cgi", ".codon", ".fcgi", ".gyp", ".gypi", ".lmi", ".py", ".py3", ".pyde", ".pyi", ".pyp", ".pyt", ".pyw", ".rpy", ".smk", ".spec", ".tac", ".wsgi", ".xpy"],
    filenames: ["Notebook", ".gclient", "DEPS", "SConscript", "SConstruct", "Snakefile", "wscript"]
  },
  kotlin: {
    extensions: [".kt", ".ktm", ".kts"]
  },
  less: {
    extensions: [".less"]
  },
  lua: {
    extensions: [".fcgi", ".lua", ".luau", ".nse", ".p8", ".pd_lua", ".rbxs", ".rockspec", ".wlua"],
    filenames: [".luacheckrc"]
  },
  makefile: {
    extensions: [".d", ".mak", ".make", ".makefile", ".mk", ".mkfile"],
    filenames: ["BSDmakefile", "GNUmakefile", "Kbuild", "Makefile", "Makefile.am", "Makefile.boot", "Makefile.frag", "Makefile.in", "Makefile.inc", "Makefile.wat", "makefile", "makefile.sco", "mkfile"]
  },
  markdown: {
    extensions: [".livemd", ".markdown", ".md", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"],
    filenames: ["contents.lr"]
  },
  "objective-c": {
    extensions: [".h", ".m"]
  },
  "objective-cpp": {
    extensions: [".mm"]
  },
  php: {
    extensions: [".aw", ".ctp", ".fcgi", ".inc", ".php", ".php3", ".php4", ".php5", ".phps", ".phpt"],
    filenames: [".php", ".php_cs", ".php_cs.dist", "Phakefile"]
  },
  perl: {
    extensions: [".al", ".cgi", ".fcgi", ".perl", ".ph", ".pl", ".plx", ".pm", ".psgi", ".t"],
    filenames: [".latexmkrc", "Makefile.PL", "Rexfile", "ack", "cpanfile", "latexmkrc"]
  },
  powershell: {
    extensions: [".ps1", ".psd1", ".psm1"]
  },
  pug: {
    extensions: [".jade", ".pug"]
  },
  r: {
    extensions: [".r", ".rd", ".rsx"],
    filenames: [".Rprofile", "expr-dist"]
  },
  ruby: {
    extensions: [".builder", ".eye", ".fcgi", ".gemspec", ".god", ".jbuilder", ".mspec", ".pluginspec", ".podspec", ".prawn", ".rabl", ".rake", ".rb", ".rbi", ".rbuild", ".rbw", ".rbx", ".ru", ".ruby", ".spec", ".thor", ".watchr"],
    filenames: [".irbrc", ".pryrc", ".simplecov", "Appraisals", "Berksfile", "Brewfile", "Buildfile", "Capfile", "Dangerfile", "Deliverfile", "Fastfile", "Gemfile", "Guardfile", "Jarfile", "Mavenfile", "Podfile", "Puppetfile", "Rakefile", "Snapfile", "Steepfile", "Thorfile", "Vagrantfile", "buildfile"]
  },
  rust: {
    extensions: [".rs", ".rs.in"]
  },
  scss: {
    extensions: [".scss"]
  },
  sql: {
    extensions: [".cql", ".ddl", ".inc", ".mysql", ".prc", ".sql", ".tab", ".udf", ".viw"]
  },
  sass: {
    extensions: [".sass"]
  },
  scala: {
    extensions: [".kojo", ".sbt", ".sc", ".scala"]
  },
  shellscript: {
    extensions: [".bash", ".bats", ".cgi", ".command", ".fcgi", ".ksh", ".sh", ".sh.in", ".tmux", ".tool", ".zsh", ".zsh-theme"],
    filenames: [".bash_aliases", ".bash_functions", ".bash_history", ".bash_logout", ".bash_profile", ".bashrc", ".cshrc", ".flaskenv", ".kshrc", ".login", ".profile", ".zlogin", ".zlogout", ".zprofile", ".zshenv", ".zshrc", "9fs", "PKGBUILD", "bash_aliases", "bash_logout", "bash_profile", "bashrc", "cshrc", "gradlew", "kshrc", "login", "man", "profile", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc"]
  },
  slim: {
    extensions: [".slim"]
  },
  solidity: {
    extensions: [".sol"]
  },
  stylus: {
    extensions: [".styl"]
  },
  svelte: {
    extensions: [".svelte"]
  },
  swift: {
    extensions: [".swift"]
  },
  typescriptreact: {
    extensions: [".tsx"]
  },
  latex: {
    extensions: [".aux", ".bbx", ".cbx", ".cls", ".dtx", ".ins", ".lbx", ".ltx", ".mkii", ".mkiv", ".mkvi", ".sty", ".tex", ".toc"]
  },
  typescript: {
    extensions: [".cts", ".mts", ".ts"]
  },
  verilog: {
    extensions: [".v", ".veo"]
  },
  vb: {
    extensions: [".vb", ".vbhtml", ".Dsr", ".bas", ".cls", ".ctl", ".frm"]
  },
  vue: {
    extensions: [".nvue", ".vue"]
  },
  xml: {
    extensions: [".adml", ".admx", ".ant", ".axaml", ".axml", ".builds", ".ccproj", ".ccxml", ".clixml", ".cproject", ".cscfg", ".csdef", ".csl", ".csproj", ".ct", ".depproj", ".dita", ".ditamap", ".ditaval", ".dll.config", ".dotsettings", ".filters", ".fsproj", ".fxml", ".glade", ".gml", ".gmx", ".grxml", ".gst", ".hzp", ".iml", ".ivy", ".jelly", ".jsproj", ".kml", ".launch", ".mdpolicy", ".mjml", ".mm", ".mod", ".mxml", ".natvis", ".ncl", ".ndproj", ".nproj", ".nuspec", ".odd", ".osm", ".pkgproj", ".plist", ".pluginspec", ".proj", ".props", ".ps1xml", ".psc1", ".pt", ".qhelp", ".rdf", ".res", ".resx", ".rss", ".sch", ".scxml", ".sfproj", ".shproj", ".srdf", ".storyboard", ".sublime-snippet", ".svg", ".targets", ".tml", ".ui", ".urdf", ".ux", ".vbproj", ".vcxproj", ".vsixmanifest", ".vssettings", ".vstemplate", ".vxml", ".wixproj", ".workflow", ".wsdl", ".wsf", ".wxi", ".wxl", ".wxs", ".x3d", ".xacro", ".xaml", ".xib", ".xlf", ".xliff", ".xmi", ".xml", ".xml.dist", ".xmp", ".xproj", ".xsd", ".xspec", ".xul", ".zcml"],
    filenames: [".classpath", ".cproject", ".project", "App.config", "NuGet.config", "Settings.StyleCop", "Web.Debug.config", "Web.Release.config", "Web.config", "packages.config"]
  },
  xsl: {
    extensions: [".xsl", ".xslt"]
  },
  yaml: {
    extensions: [".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml", ".yml.mysql"],
    filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"]
  },
  javascriptreact: {
    extensions: [".jsx"]
  }
};
var WorkspaceFiles = class _WorkspaceFiles {
  constructor(docManager, workspaceFileSystem) {
    this.docManager = docManager;
    this.workspaceFileSystem = workspaceFileSystem;
    this.workspaceFilesCache = this.computeInBackgroundAndMemoize(_WorkspaceFiles.getWorkspaceFiles, 1);
  }
  static {
    __name(this, "WorkspaceFiles");
  }
  static {
    this.EXCLUDED_NEIGHBORS = ["node_modules", "dist", "site-packages"];
  }
  async tryGetTextDocument(uri) {
    try {
      return await this.docManager.getTextDocument(m8.URI.parse(uri));
    } catch {
      return;
    }
  }
  filePathDistance(filePath, targetFilePath) {
    let distance = Mc.relative(filePath, targetFilePath).split(Mc.sep).length;
    return {
      dist: distance,
      lca: (filePath.split(Mc.sep).length + targetFilePath.split(Mc.sep).length - distance) / 2
    };
  }
  static async getWorkspaceFiles(ns, filePath, neighboringFileType, languageId, maxNumWorkspaceFiles, blacklist) {
    if (ns.workspaceFileSystem === void 0 || ns.workspaceFilesCache === void 0) return [];
    let workspaceUri = await ns.workspaceFileSystem.getWorkspaceFolder(m8.URI.file(filePath));
    if (workspaceUri === void 0) return [];
    let include = `**/*.{${knownLanguages[languageId].extensions.map(ext => ext.replace(/^\.+/g, "")).join(",")}}`;
    if (neighboringFileType === "workspacesmallestpathdist") {
      let currentFileRepository = (await ns.workspaceFileSystem.findFiles("**/.git/config")).map(f => Mc.dirname(Mc.dirname(f.fsPath))).sort((a, b) => b.split(Mc.sep).length - a.split(Mc.sep).length).find(repo => filePath.startsWith(repo));
      currentFileRepository !== void 0 && currentFileRepository !== "" && (include = `${currentFileRepository}/${include}`);
    } else {
      let fileRelativePath = Mc.relative(workspaceUri.fsPath, Mc.dirname(filePath));
      fileRelativePath !== "" && (include = `${fileRelativePath}/${include}`);
    }
    let visitedFiles = new Set(blacklist.map(f => m8.URI.parse(f.uri).fsPath));
    visitedFiles.add(filePath);
    let exclude = `**/{${_WorkspaceFiles.EXCLUDED_NEIGHBORS.join(",")},.*}/**`,
      workspaceFiles = (await ns.workspaceFileSystem.findFiles(include, exclude)).filter(f => !visitedFiles.has(f.fsPath)).sort((a, b) => {
        let aDist = ns.filePathDistance(a.fsPath, filePath),
          bDist = ns.filePathDistance(b.fsPath, filePath);
        return aDist.dist !== bDist.dist ? aDist.dist - bDist.dist : bDist.lca - aDist.lca;
      }),
      files = [],
      totalLen = 0;
    for (let workspaceFile of workspaceFiles) {
      let doc = await ns.tryGetTextDocument(workspaceFile.toString());
      if (!(doc === void 0 || totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && doc.uri.scheme == "file" && considerNeighborFile(languageId, doc.languageId) && (files.push({
        uri: doc.uri.toString(),
        relativePath: await ns.docManager.getRelativePath(doc),
        languageId: doc.languageId,
        source: doc.getText()
      }), totalLen += doc.getText().length, files.length >= maxNumWorkspaceFiles)) break;
    }
    return files;
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  computeInBackgroundAndMemoize(fct, cacheSize) {
    let resultsCache = new LRUCacheMap(cacheSize),
      inComputation = new Set();
    return (filePath, type, ...args) => {
      let key = filePath + type,
        memorizedComputation = resultsCache.get(key);
      if (memorizedComputation) return memorizedComputation;
      if (inComputation.has(key)) return null;
      let computation = fct(this, filePath, type, ...args);
      return inComputation.add(key), computation.then(computedResult => {
        resultsCache.set(key, computedResult), inComputation.delete(key);
      }), null;
    };
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    if (neighborFiles = await this.truncateDocs(sortByAccessTimes((await this.docManager.textDocuments()).filter(doc => accessTimes.get(doc.uri.toString()) !== void 0)), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), neighborFiles.length < maxNumNeighborFiles) {
      let workspaceFiles = this.workspaceFilesCache(uri.fsPath, neighboringFileType, languageId, maxNumNeighborFiles, neighborFiles);
      if (workspaceFiles !== null) {
        let neighborFileUriSet = new Set(neighborFiles.map(f => f.uri));
        workspaceFiles = workspaceFiles.filter(f => !neighborFileUriSet.has(f.uri)).slice(0, maxNumNeighborFiles - neighborFiles.length), neighborFiles.push(...workspaceFiles), neighborSource.set(neighboringFileType, workspaceFiles.map(f => f.uri));
      }
    }
    return {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
function considerNeighborFile(languageId, neighborLanguageId) {
  return languageId === neighborLanguageId;
}
__name(considerNeighborFile, "considerNeighborFile");
var NeighborSource = class _NeighborSource {
  static {
    __name(this, "NeighborSource");
  }
  static {
    this.MAX_NEIGHBOR_AGGREGATE_LENGTH = 2e5;
  }
  static {
    this.MAX_NEIGHBOR_FILES = 20;
  }
  static {
    this.EXCLUDED_NEIGHBORS = ["node_modules", "dist", "site-packages"];
  }
  static reset() {
    _NeighborSource.instance = void 0;
  }
  static async getNeighborFiles(ctx, uri, featuresFilterArgs) {
    let neighboringFileType = await ctx.get(Features).neighboringFileType(featuresFilterArgs);
    if (neighboringFileType === "none") return {
      docs: [],
      neighborSource: new Map()
    };
    if (_NeighborSource.instance === void 0) {
      let docManager = ctx.get(TextDocumentManager);
      if (neighboringFileType === "workspacesharingsamefolder" || neighboringFileType === "workspacesmallestpathdist") {
        let workspaceFileSystem = ctx.get(WorkspaceFileSystem);
        _NeighborSource.instance = new WorkspaceFiles(docManager, workspaceFileSystem);
      } else if (neighboringFileType == "opentabsandcocommitted") {
        let commitFileResolver = ctx.get(CommitFileResolver);
        _NeighborSource.instance = new CoCommittedFiles(docManager, commitFileResolver);
      } else neighboringFileType === "cursormostcount" || neighboringFileType === "cursormostrecent" ? _NeighborSource.instance = new CursorHistoryFiles(docManager) : _NeighborSource.instance = new OpenTabFiles(docManager);
    }
    return await _NeighborSource.instance.getNeighborFiles(uri, neighboringFileType, featuresFilterArgs.fileType, _NeighborSource.MAX_NEIGHBOR_FILES);
  }
};
var import_typebox = Ns(ou()),
  import_compiler = Ns(rF()),
  import_system = Ns(q3());
var import_crypto = Ns(require("crypto"));
var rnds8Pool = new Uint8Array(256),
  poolPtr = rnds8Pool.length;
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (nF.crypto.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
__name(rng, "rng");
var byteToHex = [];
for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
__name(unsafeStringify, "unsafeStringify");
var import_crypto = Ns(require("crypto")),
  native_default = {
    randomUUID: sF.crypto.randomUUID
  };
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) return native_default.randomUUID();
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;
var CopilotAuthError = class extends Error {
  static {
    __name(this, "CopilotAuthError");
  }
  constructor(message) {
    super(message), this.name = "CopilotAuthError";
  }
};
var import_index = Ns(xU(), 1),
  ALPNProtocol = {
    ALPN_HTTP2: Gh.api.ALPN_HTTP2,
    ALPN_HTTP2C: Gh.api.ALPN_HTTP2C,
    ALPN_HTTP1_1: Gh.api.ALPN_HTTP1_1,
    ALPN_HTTP1_0: Gh.api.ALPN_HTTP1_0
  },
  {
    fetch: fetch,
    context: context,
    reset: reset,
    noCache: noCache,
    h1: h1,
    keepAlive: keepAlive,
    h1NoCache: h1NoCache,
    keepAliveNoCache: keepAliveNoCache,
    cacheStats: cacheStats,
    clearCache: clearCache,
    offPush: offPush,
    onPush: onPush,
    createUrl: createUrl,
    timeoutSignal: timeoutSignal,
    Body: Body,
    Headers: Headers,
    Request: Request,
    Response: Response,
    AbortController: AbortController,
    AbortError: AbortError,
    AbortSignal: AbortSignal,
    FetchBaseError: FetchBaseError,
    FetchError: FetchError,
    ALPN_HTTP2: ALPN_HTTP2,
    ALPN_HTTP2C: ALPN_HTTP2C,
    ALPN_HTTP1_1: ALPN_HTTP1_1,
    ALPN_HTTP1_0: ALPN_HTTP1_0
  } = Gh.api;
var util = Ns(require("util")),
  import_util = require("util");
var HeaderContributors = class {
  constructor() {
    this.contributors = [];
  }
  static {
    __name(this, "HeaderContributors");
  }
  add(contributor) {
    this.contributors.push(contributor);
  }
  remove(contributor) {
    let index = this.contributors.indexOf(contributor);
    index !== -1 && this.contributors.splice(index, 1);
  }
  contributeHeaders(headers) {
    for (let contributor of this.contributors) contributor.contributeHeaderValues(headers);
  }
  size() {
    return this.contributors.length;
  }
};
var Fetcher = class {
  static {
    __name(this, "Fetcher");
  }
  set rejectUnauthorized(value) {
    this._rejectUnauthorized = value;
  }
  get rejectUnauthorized() {
    return this._rejectUnauthorized;
  }
};
function isAbortError(e) {
  return e instanceof AbortError || e.name === "AbortError" && e.code === "ABORT_ERR" && e instanceof Error || e instanceof FetchError && e.code === "ABORT_ERR";
}
__name(isAbortError, "isAbortError");
var JsonParseError = class extends SyntaxError {
    constructor(message, code) {
      super(message);
      this.code = code;
      this.name = "JsonParseError";
    }
    static {
      __name(this, "JsonParseError");
    }
  },
  networkErrorCodes = new Set(["ECONNABORTED", "ECONNRESET", "EHOSTUNREACH", "ENETUNREACH", "ENOTCONN", "ETIMEDOUT", "ERR_HTTP2_STREAM_ERROR", "ERR_SSL_BAD_DECRYPT", "ERR_SSL_DECRYPTION_FAILED_OR_BAD_RECORD_MAC", "ERR_STREAM_PREMATURE_CLOSE"]);
function isNetworkError(e) {
  return e instanceof FetchError || e instanceof JsonParseError || e instanceof Error && networkErrorCodes.has(e.code);
}
__name(isNetworkError, "isNetworkError");
var Response = class {
    constructor(status, statusText, headers, getText, getBody) {
      this.status = status;
      this.statusText = statusText;
      this.headers = headers;
      this.getText = getText;
      this.getBody = getBody;
      this.ok = this.status >= 200 && this.status < 300;
    }
    static {
      __name(this, "Response");
    }
    async text() {
      return this.getText();
    }
    async json() {
      let text = await this.text(),
        contentType = this.headers.get("content-type");
      if (!contentType || !contentType.includes("json")) throw new JsonParseError(`Response content-type is ${contentType ?? "missing"} (status=${this.status})`, `ContentType=${contentType}`);
      try {
        return JSON.parse(text);
      } catch (e) {
        if (e instanceof SyntaxError) {
          let posMatch = e.message.match(/^(.*?) in JSON at position (\d+)$/);
          if (posMatch && parseInt(posMatch[2], 10) == text.length || e.message === "Unexpected end of JSON input") {
            let actualLength = new wU.TextEncoder().encode(text).length,
              headerLength = this.headers.get("content-length");
            throw headerLength === null ? new JsonParseError(`Response body truncated: actualLength=${actualLength}`, "Truncated") : new JsonParseError(`Response body truncated: actualLength=${actualLength}, headerLength=${headerLength}`, "Truncated");
          }
        }
        throw e;
      }
    }
    async body() {
      return this.getBody();
    }
  },
  requestTimeoutMs = 30 * 1e3;
function postRequest(ctx, url, secretKey, intent, requestId, body, cancelToken) {
  let headers = {
    Authorization: SU.format("Bearer %s", secretKey),
    "X-Request-Id": requestId,
    "Openai-Organization": "github-copilot",
    "VScode-SessionId": ctx.get(EditorSession).sessionId,
    "VScode-MachineId": ctx.get(EditorSession).machineId,
    ...editorVersionHeaders(ctx)
  };
  ctx.get(HeaderContributors).contributeHeaders(headers), intent && (headers["OpenAI-Intent"] = intent);
  let request = {
      method: "POST",
      headers: headers,
      json: body,
      timeout: requestTimeoutMs
    },
    fetcher = ctx.get(Fetcher);
  if (cancelToken) {
    let abort = fetcher.makeAbortController();
    cancelToken.onCancellationRequested(() => {
      telemetry(ctx, "networking.cancelRequest", TelemetryData.createAndMarkAsIssued({
        headerRequestId: requestId
      })), abort.abort();
    }), request.signal = abort.signal;
  }
  return fetcher.fetch(url, request).catch(reason => {
    if (reason.code == "ECONNRESET" || reason.code == "ETIMEDOUT" || reason.code == "ERR_HTTP2_INVALID_SESSION" || reason.message == "ERR_HTTP2_GOAWAY_SESSION") return telemetry(ctx, "networking.disconnectAll"), fetcher.disconnectAll().then(() => fetcher.fetch(url, request));
    throw reason;
  });
}
__name(postRequest, "postRequest");
var import_crypto_js = Ns(o8()),
  os = Ns(require("os"));
var EventEmitter = require("events"),
  CopilotTokenNotifier = class extends EventEmitter {
    static {
      __name(this, "CopilotTokenNotifier");
    }
    constructor() {
      super();
    }
    emit(event, token, envelope) {
      return super.emit(event, token, envelope);
    }
  };
var TelemetryUserConfig = class {
  static {
    __name(this, "TelemetryUserConfig");
  }
  constructor(ctx, trackingId, optedIn, ftFlag) {
    this.trackingId = trackingId, this.optedIn = optedIn ?? !1, this.ftFlag = ftFlag ?? "", this.setupUpdateOnToken(ctx);
  }
  setupUpdateOnToken(ctx) {
    ctx.get(CopilotTokenNotifier).on("onCopilotToken", copilotToken => {
      let restrictedTelemetry = copilotToken.getTokenValue("rt") === "1",
        ftFlag = copilotToken.getTokenValue("ft") ?? "",
        trackingId = copilotToken.getTokenValue("tid"),
        organizationsList = copilotToken.organization_list,
        enterpriseList = copilotToken.enterprise_list,
        sku = copilotToken.getTokenValue("sku");
      trackingId !== void 0 && (this.trackingId = trackingId, this.organizationsList = organizationsList?.toString(), this.enterpriseList = enterpriseList?.toString(), this.sku = sku, this.optedIn = restrictedTelemetry, this.ftFlag = ftFlag);
    });
  }
};
var frameRegexp = /^(\s+at)?(.*?)(@|\s\(|\s)([^(\n]+?)(:\d+)?(:\d+)?(\)?)$/;
function buildExceptionDetail(error) {
  let exceptionDetail = {
      type: error.name,
      value: error.message
    },
    originalStack = error.stack?.replace(/^.*?:\d+\n.*\n *\^?\n\n/, "");
  if (originalStack?.startsWith(error.toString() + `
`)) {
    exceptionDetail.stacktrace = [];
    for (let assembly of originalStack.slice(error.toString().length + 1).split(/\n/).reverse()) {
      let matches = assembly.match(frameRegexp),
        frame = {
          filename: "",
          function: ""
        };
      matches && (frame.function = matches[2]?.trim()?.replace(/^[^.]{1,2}(\.|$)/, "_$1") ?? frame.function, frame.filename = matches[4]?.trim() ?? frame.filename, matches[5] && matches[5] !== ":0" && (frame.lineno = matches[5].slice(1)), matches[6] && matches[5] !== ":0" && (frame.colno = matches[6].slice(1)), frame.in_app = !/[[<:]|(?:^|\/)node_modules\//.test(frame.filename)), exceptionDetail.stacktrace.push(frame);
    }
  }
  return exceptionDetail;
}
__name(buildExceptionDetail, "buildExceptionDetail");
function buildPayload(ctx, redactedError, properties = {}) {
  let buildInfo = ctx.get(BuildInfo),
    epinfo = ctx.get(EditorAndPluginInfo),
    payload = {
      app: "copilot-client",
      rollup_id: "auto",
      platform: "node",
      release: buildInfo.getBuildType() !== "dev" ? `copilot-client@${buildInfo.getVersion()}` : void 0,
      deployed_to: buildInfo.getBuildType(),
      catalog_service: epinfo.getEditorInfo().name === "vscode" ? "CopilotCompletionsVSCode" : "CopilotIDEAgent",
      context: {
        ...properties,
        "#editor": epinfo.getEditorInfo().name,
        "#editor_version": formatNameAndVersion(epinfo.getEditorInfo()),
        "#editor_remote_name": `${epinfo.getEditorInfo().name}/${epinfo.getEditorInfo().remoteName ?? "none"}`,
        "#plugin": epinfo.getEditorPluginInfo().name,
        "#plugin_version": formatNameAndVersion(epinfo.getEditorPluginInfo()),
        "#session_id": ctx.get(EditorSession).sessionId,
        "#machine_id": ctx.get(EditorSession).machineId,
        "#node_version": process.versions.node,
        "#architecture": r6.arch(),
        "#os_platform": r6.platform()
      },
      sensitive_context: {}
    },
    telemetryConfig = ctx.get(TelemetryUserConfig);
  telemetryConfig.trackingId && (payload.context.user = telemetryConfig.trackingId, payload.context["#tracking_id"] = telemetryConfig.trackingId);
  let exceptionsWithDetails = [];
  payload.exception_detail = [];
  let i = 0,
    exception = redactedError;
  for (; exception instanceof Error && i < 10;) {
    let detail = buildExceptionDetail(exception);
    payload.exception_detail.unshift(detail), exceptionsWithDetails.unshift([exception, detail]), i += 1, exception = exception.cause;
  }
  let rollup = [];
  for (let [exception, detail] of exceptionsWithDetails) if (detail.stacktrace && detail.stacktrace.length > 0) {
    rollup.push(`${detail.type}: ${exception.code ?? ""}`);
    let stacktrace = [...detail.stacktrace].reverse();
    for (let frame of stacktrace) if (frame.in_app) {
      rollup.push(`${frame.filename}:${frame.lineno}:${frame.colno}`);
      break;
    }
    rollup.push(`${stacktrace[0].filename}`);
  } else return payload;
  return payload.exception_detail.length > 0 && (payload.rollup_id = (0, t6.SHA256)(t6.enc.Utf16.parse(rollup.join(`
`))).toString()), payload;
}
__name(buildPayload, "buildPayload");
var RuntimeMode = class _RuntimeMode {
  constructor(flags) {
    this.flags = flags;
  }
  static {
    __name(this, "RuntimeMode");
  }
  static fromEnvironment(isRunningInTest) {
    return new _RuntimeMode({
      debug: determineDebugFlag(process.argv, process.env),
      verboseLogging: determineVerboseLoggingEnabled(process.env),
      telemetryLogging: determineTelemetryLoggingEnabled(process.env),
      testMode: isRunningInTest,
      recordInput: determineRecordInput(process.argv, process.env)
    });
  }
};
function isRunningInTest(ctx) {
  return ctx.get(RuntimeMode).flags.testMode;
}
__name(isRunningInTest, "isRunningInTest");
function shouldFailForDebugPurposes(ctx) {
  return isRunningInTest(ctx);
}
__name(shouldFailForDebugPurposes, "shouldFailForDebugPurposes");
function isVerboseLoggingEnabled(ctx) {
  return ctx.get(RuntimeMode).flags.verboseLogging;
}
__name(isVerboseLoggingEnabled, "isVerboseLoggingEnabled");
function determineDebugFlag(argv, env) {
  return argv.includes("--debug") || determineEnvFlagEnabled(env, "GITHUB_COPILOT_DEBUG");
}
__name(determineDebugFlag, "determineDebugFlag");
function determineVerboseLoggingEnabled(env) {
  return determineEnvFlagEnabled(env, "COPILOT_AGENT_VERBOSE");
}
__name(determineVerboseLoggingEnabled, "determineVerboseLoggingEnabled");
function determineTelemetryLoggingEnabled(env) {
  return determineEnvFlagEnabled(env, "COPILOT_LOG_TELEMETRY");
}
__name(determineTelemetryLoggingEnabled, "determineTelemetryLoggingEnabled");
function determineRecordInput(argv, env) {
  return argv.includes("--record") || determineEnvFlagEnabled(env, "GITHUB_COPILOT_RECORD");
}
__name(determineRecordInput, "determineRecordInput");
function determineEnvFlagEnabled(env, key) {
  if (key in env) {
    let val = env[key];
    return val === "1" || val?.toLowerCase() === "true";
  }
  return !1;
}
__name(determineEnvFlagEnabled, "determineEnvFlagEnabled");
var assert = Ns(require("assert"));
var Context = class {
  constructor(baseContext) {
    this.baseContext = baseContext;
    this.constructionStack = [];
    this.instances = new Map();
    let stack = new Error().stack?.split(`
`);
    stack && this.constructionStack.push(...stack.slice(1));
  }
  static {
    __name(this, "Context");
  }
  get(ctor) {
    let value = this.tryGet(ctor);
    if (value) return value;
    throw new Error(`No instance of ${ctor.name} has been registered.`);
  }
  tryGet(ctor) {
    let value = this.instances.get(ctor);
    if (value) return value;
    if (this.baseContext) return this.baseContext.tryGet(ctor);
  }
  set(ctor, instance) {
    if (this.tryGet(ctor)) throw new Error(`An instance of ${ctor.name} has already been registered. Use forceSet() if you're sure it's a good idea.`);
    this.assertIsInstance(ctor, instance), this.instances.set(ctor, instance);
  }
  forceSet(ctor, instance) {
    this.assertIsInstance(ctor, instance), this.instances.set(ctor, instance);
  }
  assertIsInstance(ctor, instance) {
    if (!(instance instanceof ctor)) {
      let inst = JSON.stringify(instance);
      throw new Error(`The instance you're trying to register for ${ctor.name} is not an instance of it (${inst}).`);
    }
  }
  toString() {
    let lines = `    Context created at:
`;
    for (let stackEntry of this.constructionStack || []) lines += `    ${stackEntry}
`;
    return lines += this.baseContext?.toString() ?? "", lines;
  }
};
var appInsights = Ns(TJ()),
  os = Ns(require("os")),
  import_stream = require("stream");
var IngestionEndpointPattern = /^https:\/\/[^.]*\.in\.applicationinsights\.azure\.com\//,
  Util = il(),
  originalMakeRequest = Util.makeRequest.bind(Util),
  AzureInsightReporter = class {
    constructor(ctx, namespace, key) {
      this.namespace = namespace;
      this.client = createAppInsightsClient(ctx, key), configureReporter(ctx, this.client), ctx.get(CopilotTokenNotifier).on("onCopilotToken", copilotToken => {
        let userId = copilotToken.getTokenValue("tid");
        userId !== void 0 && updateReporterUserId(userId, this.client);
      });
    }
    static {
      __name(this, "AzureInsightReporter");
    }
    sendTelemetryEvent(eventName, properties, measurements) {
      this.client.trackEvent({
        name: this.qualifyEventName(eventName),
        properties: properties,
        measurements: measurements
      });
    }
    sendTelemetryErrorEvent(eventName, properties, measurements) {
      this.sendTelemetryEvent(this.qualifyEventName(eventName), properties, measurements);
    }
    sendTelemetryException(error, properties, measurements) {
      this.client.trackException({
        exception: error,
        properties: properties,
        measurements: measurements
      });
    }
    dispose() {
      return new Promise(resolve => {
        this.client.flush({
          callback: s => {
            resolve(void 0);
          }
        });
      });
    }
    qualifyEventName(eventName) {
      return eventName.startsWith(this.namespace) ? eventName : `${this.namespace}/${eventName}`;
    }
  };
function monkeyPatchMakeRequest(ctx) {
  Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback, ...rest) {
    if (!ctx.get(Fetcher).proxySettings) return originalMakeRequest(config, requestUrl, requestOptions, requestCallback, ...rest);
    requestUrl && requestUrl.indexOf("//") === 0 && (requestUrl = "https:" + requestUrl);
    let fakeResponse = new $N.EventEmitter();
    fakeResponse.setEncoding = () => fakeResponse;
    let fakeRequest = new $N.EventEmitter(),
      body;
    return fakeRequest.write = (chunk, _, __) => {
      body = chunk;
    }, fakeRequest.end = () => {
      if (requestUrl.includes("169.254.169.254")) return fakeRequest.emit("error", new Error("UNREACH")), fakeRequest;
      if (IngestionEndpointPattern.test(requestUrl)) return fakeRequest.emit("error", new Error("UNKNOWN")), fakeRequest;
      let method = requestOptions.method,
        headers = requestOptions.headers;
      return ctx.get(Fetcher).fetch(requestUrl, {
        method: method,
        headers: headers,
        body: body
      }).then(res => {
        res.text().then(text => {
          fakeResponse.emit("data", text), fakeResponse.emit("end");
        });
      }).catch(err => {
        fakeRequest.emit("error", err);
      }), fakeRequest;
    }, fakeRequest.setTimeout = () => fakeRequest, fakeRequest.abort = () => {}, requestCallback(fakeResponse), fakeRequest;
  };
}
__name(monkeyPatchMakeRequest, "monkeyPatchMakeRequest");
function createAppInsightsClient(ctx, key) {
  monkeyPatchMakeRequest(ctx);
  let client = new SJ.TelemetryClient(key);
  return client.config.enableAutoCollectRequests = !1, client.config.enableAutoCollectPerformance = !1, client.config.enableAutoCollectExceptions = !1, client.config.enableAutoCollectConsole = !1, client.config.enableAutoCollectDependencies = !1, client.config.noDiagnosticChannel = !0, configureReporter(ctx, client), client;
}
__name(createAppInsightsClient, "createAppInsightsClient");
function configureReporter(ctx, client) {
  client.commonProperties = decorateWithCommonProperties(client.commonProperties, ctx);
  let editorSession = ctx.get(EditorSession);
  client.context.tags[client.context.keys.sessionId] = editorSession.sessionId;
  let telemetryConfig = ctx.get(TelemetryUserConfig);
  telemetryConfig.trackingId && (client.context.tags[client.context.keys.userId] = telemetryConfig.trackingId), client.context.tags[client.context.keys.cloudRoleInstance] = "REDACTED", client.config.endpointUrl = ctx.get(TelemetryEndpointUrl).getUrl();
}
__name(configureReporter, "configureReporter");
function updateReporterUserId(userId, client) {
  client.context.tags[client.context.keys.userId] = userId;
}
__name(updateReporterUserId, "updateReporterUserId");
function decorateWithCommonProperties(properties, ctx) {
  properties = properties || {}, properties.common_os = Ex.platform(), properties.common_platformversion = Ex.release();
  let editorSession = ctx.get(EditorSession);
  return properties.common_vscodemachineid = editorSession.machineId, properties.common_vscodesessionid = editorSession.sessionId, properties.common_uikind = "desktop", properties.common_remotename = "none", properties.common_isnewappinstall = "", properties;
}
__name(decorateWithCommonProperties, "decorateWithCommonProperties");
var APP_INSIGHTS_KEY = "7d7048df-6dd0-4048-bb23-b716c1461f8f",
  APP_INSIGHTS_KEY_SECURE = "3fdd7f28-937a-48c8-9a21-ba337db23bd1",
  APP_INSIGHTS_KEY_FT = "f0000000-0000-0000-0000-000000000000";
async function setupTelemetryReporters(ctx, telemetryNamespace, telemetryEnabled) {
  let deactivation = ctx.get(TelemetryReporters).deactivate();
  if (telemetryEnabled) {
    let container = ctx.get(TelemetryReporters),
      reporter = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY);
    container.setReporter(reporter);
    let reporterRestricted = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY_SECURE);
    container.setRestrictedReporter(reporterRestricted);
    let reporterFt = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY_FT);
    container.setFTReporter(reporterFt);
  }
  await deactivation;
}
__name(setupTelemetryReporters, "setupTelemetryReporters");
var path = Ns(require("path")),
  import_worker_threads = require("worker_threads");
var path = Ns(require("path")),
  packageRoot = H4.basename(__dirname) === "dist" ? H4.resolve(__dirname, "..") : H4.resolve(__dirname, "..", "..", "..");
var fakeTelemetryServerPortPromise;
async function startFakeTelemetryServerIfNecessary() {
  return fakeTelemetryServerPortPromise === void 0 && (fakeTelemetryServerPortPromise = new Promise((r, err) => {
    console.warn("Launching fake telemetry server");
    let fakeTelemetryServer = new NJ.Worker(RJ.join(packageRoot, "lib", "src", "testing", "telemetryFakeWorker.js"));
    fakeTelemetryServer.on("message", ({
      port: port
    }) => {
      console.warn(`Telemetry server ready on port ${port}`), r(port);
    }), fakeTelemetryServer.on("error", err);
  })), fakeTelemetryServerPortPromise;
}
__name(startFakeTelemetryServerIfNecessary, "startFakeTelemetryServerIfNecessary");
var PromiseQueue = class {
    static {
      __name(this, "PromiseQueue");
    }
    async register(promise) {
      return promise;
    }
  },
  TestPromiseQueue = class extends PromiseQueue {
    constructor() {
      super(...arguments);
      this.promises = [];
    }
    static {
      __name(this, "TestPromiseQueue");
    }
    async register(promise) {
      return this.promises.push(promise), promise;
    }
    async awaitPromises() {
      await Promise.all(this.promises);
    }
  };
async function collectCapturedTelemetry(ctx) {
  let url = ctx.get(TelemetryEndpointUrl).getUrl(),
    messages = (await (await ctx.get(Fetcher).fetch(url, {})).json()).messages ?? [];
  for (let message of messages) WN.strictEqual(message.tags["ai.cloud.roleInstance"], "REDACTED");
  return messages;
}
__name(collectCapturedTelemetry, "collectCapturedTelemetry");
async function withInlineTelemetryCapture(ctx, work) {
  return _withTelemetryCapture(ctx, !0, work);
}
__name(withInlineTelemetryCapture, "withInlineTelemetryCapture");
async function _withTelemetryCapture(ctx, forceTelemetry, work) {
  let port = await startFakeTelemetryServerIfNecessary(),
    extensionId = "copilot-test",
    endpoint = Math.floor(Math.random() * 1e5).toString();
  delete process.env.http_proxy, delete process.env.https_proxy;
  let oldUrl = ctx.get(TelemetryEndpointUrl).getUrl();
  ctx.get(TelemetryEndpointUrl).setUrlForTesting(`http://localhost:${port}/${endpoint}`), setupTelemetryReporters(ctx, extensionId, forceTelemetry);
  try {
    let queue = new TestPromiseQueue();
    ctx.forceSet(PromiseQueue, queue);
    let result = await work(ctx);
    return await queue.awaitPromises(), await ctx.get(TelemetryReporters).deactivate(), [await collectMessagesWithRetry(ctx), result];
  } finally {
    ctx.get(TelemetryEndpointUrl).setUrlForTesting(oldUrl);
  }
}
__name(_withTelemetryCapture, "_withTelemetryCapture");
async function collectMessagesWithRetry(ctx) {
  for (let waitTimeMultiplier = 0; waitTimeMultiplier < 3; waitTimeMultiplier++) {
    await new Promise(resolve => setTimeout(resolve, waitTimeMultiplier * 1e3));
    let messages = await collectCapturedTelemetry(ctx);
    if (messages.length > 0) return messages;
    console.warn("Retrying to collect telemetry messages #" + (waitTimeMultiplier + 1));
  }
  return [];
}
__name(collectMessagesWithRetry, "collectMessagesWithRetry");
var FailingTelemetryReporter = class {
  static {
    __name(this, "FailingTelemetryReporter");
  }
  sendTelemetryEvent(eventName, properties, measurements) {
    throw new Error("Telemetry disabled");
  }
  sendTelemetryErrorEvent(eventName, properties, measurements, errorProps) {
    throw new Error("Telemetry disabled");
  }
  sendTelemetryException(error, properties, measurements) {
    throw new Error("Telemetry disabled");
  }
  dispose() {
    return Promise.resolve();
  }
  hackOptOutListener() {}
};
var import_os = require("os"),
  path = Ns(require("path"));
function redactPaths(input) {
  return input.replace(/([\s|(]|file:\/\/)(\/[^\s]+)/g, "$1[redacted]").replace(/([\s|(]|file:\/\/)([a-zA-Z]:[\\/]{1,2}[^\s]+)/gi, "$1[redacted]").replace(/([\s|(]|file:\/\/)(\\[^\s]+)/gi, "$1[redacted]");
}
__name(redactPaths, "redactPaths");
function escapeForRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeForRegExp, "escapeForRegExp");
var homedirRegExp = new RegExp("(?<=^|[\\s|(\"'`]|file://)" + escapeForRegExp((0, MJ.homedir)()) + "(?=$|[\\\\/:\"'`])", "gi");
function redactHomeDir(input) {
  return input.replace(homedirRegExp, "~");
}
__name(redactHomeDir, "redactHomeDir");
var relativePathSuffix = "[\\\\/]?([^:)]*)(?=:\\d)",
  pathSepRegExp = new RegExp(escapeForRegExp(BJ.sep), "g"),
  rootDirRegExp = new RegExp(escapeForRegExp(__dirname.replace(/[\\/]lib[\\/]src[\\/]util$|[\\/]dist$/, "")) + relativePathSuffix, "gi");
function cloneError(original, prepareMessage, allowUnknownPaths = !1, replacements = []) {
  let error = new Error(prepareMessage(original));
  error.name = original.name, typeof original.syscall == "string" && (error.syscall = original.syscall), typeof original.code == "string" && (error.code = original.code), typeof original.errno == "number" && (error.errno = original.errno), error.stack = void 0;
  let originalStack = original.stack?.replace(/^.*?:\d+\n.*\n *\^?\n\n/, "");
  if (originalStack?.startsWith(original.toString() + `
`)) {
    error.stack = error.toString();
    for (let frame of originalStack.slice(original.toString().length + 1).split(/\n/)) if (rootDirRegExp.test(frame)) error.stack += `
${redactPaths(frame.replace(rootDirRegExp, (_, relative) => relative.replace(pathSepRegExp, "/")))}`;else if (/[ (]node:|[ (]wasm:\/\/wasm\/| \(<anonymous>\)$/.test(frame)) error.stack += `
${redactPaths(frame)}`;else {
      let found = !1;
      for (let {
        prefix: prefix,
        path: dir
      } of replacements) {
        let dirRegExp = new RegExp(escapeForRegExp(dir.replace(/[\\/]$/, "")) + relativePathSuffix, "gi");
        if (dirRegExp.test(frame)) {
          error.stack += `
${redactPaths(frame.replace(dirRegExp, (_, relative) => prefix + relative.replace(pathSepRegExp, "/")))}`, found = !0;
          break;
        }
      }
      if (found) continue;
      allowUnknownPaths ? error.stack += `
${redactHomeDir(frame)}` : error.stack += `
    at [redacted]:0:0`;
    }
  } else allowUnknownPaths && originalStack && (error.stack = redactHomeDir(originalStack));
  return original.cause instanceof Error && (error.cause = cloneError(original.cause, prepareMessage, allowUnknownPaths, replacements)), error;
}
__name(cloneError, "cloneError");
function prepareErrorForRestrictedTelemetry(original, replacements) {
  return cloneError(original, __name(function (e) {
    let message = e.message;
    return typeof e.path == "string" && e.path.length > 0 && (message = message.replaceAll(e.path, "<path>")), redactHomeDir(message);
  }, "prepareMessage"), !0, replacements);
}
__name(prepareErrorForRestrictedTelemetry, "prepareErrorForRestrictedTelemetry");
function redactError(original, replacements) {
  return cloneError(original, __name(function (e) {
    let message = "[redacted]";
    return e.syscall && e.code !== void 0 ? message = `${redactPaths(e.syscall.toString())} ${e.code} ${message}` : e instanceof FetchError && e.erroredSysCall && e.code !== void 0 ? message = `${e.erroredSysCall} ${e.code} ${message}` : e.code !== void 0 && (message = `${e.code} ${message}`), message;
  }, "redactMessage"), !1, replacements);
}
__name(redactError, "redactError");
function isRestricted(store) {
  return store === 1;
}
__name(isRestricted, "isRestricted");
var ftTelemetryEvents = ["engine.prompt", "engine.completion", "ghostText.capturedAfterAccepted", "ghostText.capturedAfterRejected"];
var TelemetryReporters = class {
  static {
    __name(this, "TelemetryReporters");
  }
  getReporter(ctx, store = 0) {
    return isRestricted(store) ? this.getRestrictedReporter(ctx) : this.reporter;
  }
  getRestrictedReporter(ctx) {
    if (shouldSendRestricted(ctx)) return this.reporterRestricted;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  getFTReporter(ctx) {
    if (shouldSendFinetuningTelemetry(ctx)) return this.reporterFT;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  setReporter(reporter) {
    this.reporter = reporter;
  }
  setRestrictedReporter(reporter) {
    this.reporterRestricted = reporter;
  }
  setFTReporter(reporter) {
    this.reporterFT = reporter;
  }
  async deactivate() {
    let disposeReporter = Promise.resolve();
    this.reporter && (disposeReporter = this.reporter.dispose(), this.reporter = void 0);
    let disposeReporterRestricted = Promise.resolve();
    this.reporterRestricted && (disposeReporterRestricted = this.reporterRestricted.dispose(), this.reporterRestricted = void 0);
    let disposeReporterFT = Promise.resolve();
    this.reporterFT && (disposeReporterFT = this.reporterFT.dispose(), this.reporterFT = void 0), await Promise.all([disposeReporter, disposeReporterRestricted, disposeReporterFT]);
  }
};
HJ.TypeSystem.AllowNaN = !0;
var propertiesSchema = jd.Type.Object({}, {
    additionalProperties: jd.Type.String()
  }),
  measurementsSchema = jd.Type.Object({
    meanLogProb: jd.Type.Optional(jd.Type.Number()),
    meanAlternativeLogProb: jd.Type.Optional(jd.Type.Number())
  }, {
    additionalProperties: jd.Type.Number()
  }),
  oomCodes = new Set(["ERR_WORKER_OUT_OF_MEMORY", "ENOMEM"]);
function isOomError(error) {
  return oomCodes.has(error.code ?? "") || error.name === "RangeError" && error.message === "WebAssembly.Memory(): could not allocate memory";
}
__name(isOomError, "isOomError");
function getErrorType(error) {
  return isNetworkError(error) ? "network" : isOomError(error) || error.code === "EMFILE" || error.code === "ENFILE" || error.syscall === "uv_cwd" && (error.code === "ENOENT" || error.code == "EIO") || error.code === "CopilotPromptLoadFailure" || `${error.code}`.startsWith("CopilotPromptWorkerExit") ? "local" : "exception";
}
__name(getErrorType, "getErrorType");
var TelemetryData = class _TelemetryData {
  static {
    __name(this, "TelemetryData");
  }
  static {
    this.validateTelemetryProperties = YN.TypeCompiler.Compile(propertiesSchema);
  }
  static {
    this.validateTelemetryMeasurements = YN.TypeCompiler.Compile(measurementsSchema);
  }
  static {
    this.keysExemptedFromSanitization = ["abexp.assignmentcontext", "VSCode.ABExp.Features"];
  }
  constructor(properties, measurements, issuedTime) {
    this.properties = properties, this.measurements = measurements, this.issuedTime = issuedTime;
  }
  static createAndMarkAsIssued(properties, measurements) {
    return new _TelemetryData(properties || {}, measurements || {}, now());
  }
  extendedBy(properties, measurements) {
    let newProperties = {
        ...this.properties,
        ...properties
      },
      newMeasurements = {
        ...this.measurements,
        ...measurements
      },
      newData = new _TelemetryData(newProperties, newMeasurements, this.issuedTime);
    return newData.displayedTime = this.displayedTime, newData.filtersAndExp = this.filtersAndExp, newData;
  }
  markAsDisplayed() {
    this.displayedTime === void 0 && (this.displayedTime = now());
  }
  async extendWithExpTelemetry(ctx) {
    this.filtersAndExp || (await ctx.get(Features).addExpAndFilterToTelemetry(this)), this.filtersAndExp.exp.addToTelemetry(this), this.filtersAndExp.filters.addToTelemetry(this);
  }
  extendWithEditorAgnosticFields(ctx) {
    this.properties.editor_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorInfo()), this.properties.editor_plugin_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorPluginInfo());
    let editorSession = ctx.get(EditorSession);
    this.properties.client_machineid = editorSession.machineId, this.properties.client_sessionid = editorSession.sessionId, this.properties.copilot_version = `copilot/${getVersion(ctx)}`, this.properties.runtime_version = `node/${process.versions.node}`;
    let editorInfo = ctx.get(EditorAndPluginInfo);
    this.properties.common_extname = editorInfo.getEditorPluginInfo().name, this.properties.common_extversion = editorInfo.getEditorPluginInfo().version, this.properties.common_vscodeversion = formatNameAndVersion(editorInfo.getEditorInfo());
    let fetcher = ctx.get(Fetcher),
      proxySettings = fetcher.proxySettings;
    this.properties.proxy_enabled = proxySettings ? "true" : "false", this.properties.proxy_auth = proxySettings?.proxyAuth ? "true" : "false", this.properties.proxy_kerberos_spn = proxySettings?.kerberosServicePrincipal ? "true" : "false", this.properties.reject_unauthorized = fetcher.rejectUnauthorized ? "true" : "false";
  }
  extendWithConfigProperties(ctx) {
    let configProperties = dumpConfig(ctx);
    configProperties["copilot.build"] = getBuild(ctx), configProperties["copilot.buildType"] = getBuildType(ctx);
    let telemetryConfig = ctx.get(TelemetryUserConfig);
    telemetryConfig.trackingId && (configProperties["copilot.trackingId"] = telemetryConfig.trackingId), telemetryConfig.organizationsList && (configProperties.organizations_list = telemetryConfig.organizationsList), telemetryConfig.enterpriseList && (configProperties.enterprise_list = telemetryConfig.enterpriseList), telemetryConfig.sku && (configProperties.sku = telemetryConfig.sku), this.properties = {
      ...this.properties,
      ...configProperties
    };
  }
  extendWithRequestId(requestId) {
    let requestProperties = {
      completionId: requestId.completionId,
      created: requestId.created.toString(),
      headerRequestId: requestId.headerRequestId,
      serverExperiments: requestId.serverExperiments,
      deploymentId: requestId.deploymentId
    };
    this.properties = {
      ...this.properties,
      ...requestProperties
    };
  }
  static {
    this.keysToRemoveFromStandardTelemetryHack = ["gitRepoHost", "gitRepoName", "gitRepoOwner", "gitRepoUrl", "gitRepoPath", "repo", "request_option_nwo", "userKind"];
  }
  static maybeRemoveRepoInfoFromPropertiesHack(store, map) {
    if (isRestricted(store)) return map;
    let returnValue = {};
    for (let key in map) _TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(key) || (returnValue[key] = map[key]);
    return returnValue;
  }
  sanitizeKeys() {
    this.properties = _TelemetryData.sanitizeKeys(this.properties), this.measurements = _TelemetryData.sanitizeKeys(this.measurements);
  }
  static sanitizeKeys(map) {
    map = map || {};
    let returnValue = {};
    for (let key in map) {
      let newKey = _TelemetryData.keysExemptedFromSanitization.includes(key) ? key : key.replace(/\./g, "_");
      returnValue[newKey] = map[key];
    }
    return returnValue;
  }
  updateTimeSinceIssuedAndDisplayed() {
    let timeSinceIssued = now() - this.issuedTime;
    if (this.measurements.timeSinceIssuedMs = timeSinceIssued, this.displayedTime !== void 0) {
      let timeSinceDisplayed = now() - this.displayedTime;
      this.measurements.timeSinceDisplayedMs = timeSinceDisplayed;
    }
  }
  validateData(ctx, store) {
    let invalid;
    if (_TelemetryData.validateTelemetryProperties.Check(this.properties) || (invalid = {
      problem: "properties",
      error: JSON.stringify([..._TelemetryData.validateTelemetryProperties.Errors(this.properties)])
    }), !_TelemetryData.validateTelemetryMeasurements.Check(this.measurements)) {
      let m_err = JSON.stringify([..._TelemetryData.validateTelemetryMeasurements.Errors(this.measurements)]);
      invalid === void 0 ? invalid = {
        problem: "measurements",
        error: m_err
      } : (invalid.problem = "both", invalid.error += `; ${m_err}`);
    }
    if (invalid === void 0) return !0;
    if (shouldFailForDebugPurposes(ctx)) throw new Error(`Invalid telemetry data: ${invalid.problem} ${invalid.error} properties=${JSON.stringify(this.properties)} measurements=${JSON.stringify(this.measurements)}`);
    return telemetryError(ctx, "invalidTelemetryData", _TelemetryData.createAndMarkAsIssued({
      properties: JSON.stringify(this.properties),
      measurements: JSON.stringify(this.measurements),
      problem: invalid.problem,
      validationError: invalid.error
    }), store), isRestricted(store) && telemetryError(ctx, "invalidTelemetryData_in_secure", _TelemetryData.createAndMarkAsIssued({
      problem: invalid.problem,
      requestId: this.properties.requestId ?? "unknown"
    }), 0), !1;
  }
  async makeReadyForSending(ctx, store, includeExp) {
    this.extendWithConfigProperties(ctx), this.extendWithEditorAgnosticFields(ctx), this.sanitizeKeys(), includeExp === "IncludeExp" && (await this.extendWithExpTelemetry(ctx)), this.updateTimeSinceIssuedAndDisplayed(), this.validateData(ctx, store) || (this.properties.telemetry_failed_validation = "true"), addRequiredProperties(ctx, this.properties);
  }
};
function sendTelemetryEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryEvent, "sendTelemetryEvent");
function sendTelemetryException(ctx, store, error, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryException(error, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryException, "sendTelemetryException");
function sendTelemetryErrorEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryErrorEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryErrorEvent, "sendTelemetryErrorEvent");
function sendFTTelemetryEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getFTReporter(ctx)?.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendFTTelemetryEvent, "sendFTTelemetryEvent");
function telemetrizePromptLength(prompt) {
  return prompt.isFimEnabled ? {
    promptPrefixCharLen: prompt.prefix.length,
    promptSuffixCharLen: prompt.suffix.length
  } : {
    promptCharLen: prompt.prefix.length
  };
}
__name(telemetrizePromptLength, "telemetrizePromptLength");
function now() {
  return new Date().getTime();
}
__name(now, "now");
var COPILOT_TELEMETRY_SERVICE_ENDPOINT = "https://copilot-telemetry.githubusercontent.com/telemetry",
  TelemetryEndpointUrl = class {
    constructor(url = COPILOT_TELEMETRY_SERVICE_ENDPOINT) {
      this.url = url;
    }
    static {
      __name(this, "TelemetryEndpointUrl");
    }
    getUrl() {
      return this.url;
    }
    setUrlForTesting(url) {
      this.url = url;
    }
  };
function shouldSendRestricted(ctx) {
  return ctx.get(TelemetryUserConfig).optedIn;
}
__name(shouldSendRestricted, "shouldSendRestricted");
function shouldSendFinetuningTelemetry(ctx) {
  return ctx.get(TelemetryUserConfig).ftFlag !== "";
}
__name(shouldSendFinetuningTelemetry, "shouldSendFinetuningTelemetry");
async function telemetry(ctx, name, telemetryData, store) {
  await ctx.get(PromiseQueue).register(_telemetry(ctx, name, telemetryData, store));
}
__name(telemetry, "telemetry");
async function _telemetry(ctx, name, telemetryData, store = 0) {
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store ?? !1, "IncludeExp"), (!isRestricted(store) || shouldSendRestricted(ctx)) && sendTelemetryEvent(ctx, store, name, definedTelemetryData), isRestricted(store) && ftTelemetryEvents.includes(name) && shouldSendFinetuningTelemetry(ctx) && sendFTTelemetryEvent(ctx, store, name, definedTelemetryData);
}
__name(_telemetry, "_telemetry");
async function telemetryExpProblem(ctx, telemetryProperties) {
  await ctx.get(PromiseQueue).register(_telemetryExpProblem(ctx, telemetryProperties));
}
__name(telemetryExpProblem, "telemetryExpProblem");
async function _telemetryExpProblem(ctx, telemetryProperties) {
  let name = "expProblem",
    definedTelemetryData = TelemetryData.createAndMarkAsIssued(telemetryProperties, {});
  await definedTelemetryData.makeReadyForSending(ctx, 0, "SkipExp"), sendTelemetryEvent(ctx, 0, name, definedTelemetryData);
}
__name(_telemetryExpProblem, "_telemetryExpProblem");
async function telemetryRaw(ctx, name, properties, measurements) {
  await ctx.get(PromiseQueue).register(_telemetryRaw(ctx, name, properties, measurements));
}
__name(telemetryRaw, "telemetryRaw");
async function _telemetryRaw(ctx, name, properties, measurements) {
  addRequiredProperties(ctx, properties), sendTelemetryEvent(ctx, 0, name, {
    properties: properties,
    measurements: measurements
  });
}
__name(_telemetryRaw, "_telemetryRaw");
function addRequiredProperties(ctx, properties) {
  properties.unique_id = v4_default();
  let editorInfo = ctx.get(EditorAndPluginInfo);
  properties.common_extname = editorInfo.getEditorPluginInfo().name, properties.common_extversion = editorInfo.getEditorPluginInfo().version, properties.common_vscodeversion = formatNameAndVersion(editorInfo.getEditorInfo());
}
__name(addRequiredProperties, "addRequiredProperties");
var CopilotNonError = class extends Error {
  static {
    __name(this, "CopilotNonError");
  }
  constructor(thrown) {
    let message;
    try {
      message = JSON.stringify(thrown);
    } catch {
      message = thrown.toString();
    }
    super(message), this.name = "CopilotNonError";
  }
};
async function telemetryException(ctx, maybeError, origin, properties) {
  let error;
  if (maybeError instanceof Error) {
    if (error = maybeError, error.name === "Canceled" && error.message === "Canceled" || error.name === "CodeExpectedError" || error instanceof CopilotAuthError) return;
  } else if (error = new CopilotNonError(maybeError), error.stack?.startsWith(`${error}
`)) {
    let frames = error.stack.slice(`${error}
`.length).split(`
`);
    /^\s*(?:at )?(?:\w+\.)*telemetryException\b/.test(frames[0]) && frames.shift(), error.stack = `${error}
${frames.join(`
`)}`;
  }
  await ctx.get(PromiseQueue).register(_telemetryException(ctx, error, origin, properties));
}
__name(telemetryException, "telemetryException");
async function _telemetryException(ctx, error, origin, properties) {
  let editorInfo = ctx.get(EditorAndPluginInfo).getEditorInfo(),
    stackPaths;
  editorInfo.root && (stackPaths = [{
    prefix: `${editorInfo.name}:`,
    path: editorInfo.root
  }]);
  let redactedError = redactError(error, stackPaths),
    sendRestricted = shouldSendRestricted(ctx),
    errorType = getErrorType(error),
    sendAsException = errorType === "exception",
    definedTelemetryDataStub = TelemetryData.createAndMarkAsIssued({
      origin: redactPaths(origin),
      type: error.name,
      code: `${error.code ?? ""}`,
      reason: redactedError.stack || redactedError.toString(),
      message: redactedError.message,
      ...properties
    });
  await definedTelemetryDataStub.makeReadyForSending(ctx, 0, "IncludeExp");
  let failbotPayload = buildPayload(ctx, redactedError, {
    "#origin": origin,
    "copilot_event.unique_id": definedTelemetryDataStub.properties.unique_id,
    "#restricted_telemetry": sendRestricted ? "true" : "false"
  });
  if (failbotPayload.rollup_id !== "auto" && (definedTelemetryDataStub.properties.errno = failbotPayload.rollup_id), failbotPayload.created_at = new Date(definedTelemetryDataStub.issuedTime).toISOString(), sendRestricted) {
    let restrictedError = prepareErrorForRestrictedTelemetry(error, stackPaths),
      definedTelemetryDataRestricted = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        type: error.name,
        code: `${error.code ?? ""}`,
        reason: restrictedError.stack || restrictedError.toString(),
        message: restrictedError.message,
        ...properties
      });
    failbotPayload.rollup_id !== "auto" && (definedTelemetryDataRestricted.properties.errno = failbotPayload.rollup_id), await definedTelemetryDataRestricted.makeReadyForSending(ctx, 1, "IncludeExp"), definedTelemetryDataRestricted.properties.unique_id = definedTelemetryDataStub.properties.unique_id, definedTelemetryDataStub.properties.restricted_unique_id = definedTelemetryDataRestricted.properties.unique_id, sendAsException && sendTelemetryException(ctx, 1, restrictedError, definedTelemetryDataRestricted), sendTelemetryEvent(ctx, 1, `error.${errorType}`, definedTelemetryDataRestricted);
  }
  sendAsException && (sendTelemetryException(ctx, 0, redactedError, definedTelemetryDataStub), definedTelemetryDataStub.properties.failbot_payload = JSON.stringify(failbotPayload)), sendTelemetryEvent(ctx, 0, `error.${errorType}`, definedTelemetryDataStub);
}
__name(_telemetryException, "_telemetryException");
async function telemetryError(ctx, name, telemetryData, store) {
  await ctx.get(PromiseQueue).register(_telemetryError(ctx, name, telemetryData, store));
}
__name(telemetryError, "telemetryError");
async function _telemetryError(ctx, name, telemetryData, store = 0) {
  if (isRestricted(store) && !shouldSendRestricted(ctx)) return;
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store, "IncludeExp"), sendTelemetryErrorEvent(ctx, store, name, definedTelemetryData);
}
__name(_telemetryError, "_telemetryError");
async function logEngineCompletion(ctx, completionText, jsonData, requestId, choiceIndex) {
  let telemetryData = TelemetryData.createAndMarkAsIssued({
    completionTextJson: JSON.stringify(completionText),
    choiceIndex: choiceIndex.toString()
  });
  if (jsonData.logprobs) for (let [key, value] of Object.entries(jsonData.logprobs)) telemetryData.properties["logprobs_" + key] = JSON.stringify(value) ?? "unset";
  telemetryData.extendWithRequestId(requestId), await telemetry(ctx, "engine.completion", telemetryData, 1);
}
__name(logEngineCompletion, "logEngineCompletion");
async function logEnginePrompt(ctx, prompt, telemetryData) {
  let promptTelemetry;
  prompt.isFimEnabled ? promptTelemetry = {
    promptPrefixJson: JSON.stringify(prompt.prefix),
    promptSuffixJson: JSON.stringify(prompt.suffix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  } : promptTelemetry = {
    promptJson: JSON.stringify(prompt.prefix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  };
  let telemetryDataWithPrompt = telemetryData.extendedBy(promptTelemetry);
  await telemetry(ctx, "engine.prompt", telemetryDataWithPrompt, 1);
}
__name(logEnginePrompt, "logEnginePrompt");
var ExpConfig = class _ExpConfig {
  static {
    __name(this, "ExpConfig");
  }
  constructor(variables, assignmentContext, features) {
    this.variables = variables, this.assignmentContext = assignmentContext, this.features = features;
  }
  static createFallbackConfig(ctx, reason) {
    return telemetryExpProblem(ctx, {
      reason: reason
    }), this.createEmptyConfig();
  }
  static createEmptyConfig() {
    return new _ExpConfig({}, "", "");
  }
  addToTelemetry(telemetryData) {
    telemetryData.properties["VSCode.ABExp.Features"] = this.features, telemetryData.properties["abexp.assignmentcontext"] = this.assignmentContext;
  }
};
var ExpConfigMaker = class {
    static {
      __name(this, "ExpConfigMaker");
    }
  },
  ExpConfigFromTAS = class extends ExpConfigMaker {
    static {
      __name(this, "ExpConfigFromTAS");
    }
    async fetchExperiments(ctx, filterHeaders) {
      let fetcher = ctx.get(Fetcher),
        resp;
      try {
        resp = await fetcher.fetch("https://default.exp-tas.com/vscode/ab", {
          method: "GET",
          headers: filterHeaders
        });
      } catch (e) {
        return ExpConfig.createFallbackConfig(ctx, `Error fetching ExP config: ${e}`);
      }
      if (!resp.ok) return ExpConfig.createFallbackConfig(ctx, `ExP responded with ${resp.status}`);
      let json;
      try {
        json = await resp.json();
      } catch (e) {
        if (e instanceof SyntaxError) return telemetryException(ctx, e, "fetchExperiments"), ExpConfig.createFallbackConfig(ctx, "ExP responded with invalid JSON");
        throw e;
      }
      let vscodeConfig = json.Configs.find(c => c.Id === "vscode") ?? {
          Id: "vscode",
          Parameters: {}
        },
        features = Object.entries(vscodeConfig.Parameters).map(([name, value]) => name + (value ? "" : "cf"));
      return new ExpConfig(vscodeConfig.Parameters, json.AssignmentContext, features.join(";"));
    }
  },
  ExpConfigNone = class extends ExpConfigMaker {
    static {
      __name(this, "ExpConfigNone");
    }
    async fetchExperiments(ctx, filterHeaders) {
      return ExpConfig.createEmptyConfig();
    }
  };
var telmetryNames = {
    "X-Copilot-ClientTimeBucket": "timeBucket",
    "X-Copilot-OverrideEngine": "engine",
    "X-Copilot-Repository": "repo",
    "X-Copilot-FileType": "fileType",
    "X-Copilot-UserKind": "userKind"
  },
  FilterSettings = class _FilterSettings {
    constructor(filters) {
      this.filters = filters;
      for (let [filter, value] of Object.entries(this.filters)) value === "" && delete this.filters[filter];
    }
    static {
      __name(this, "FilterSettings");
    }
    extends(otherFilterSettings) {
      for (let [filter, value] of Object.entries(otherFilterSettings.filters)) if (this.filters[filter] !== value) return !1;
      return !0;
    }
    addToTelemetry(telemetryData) {
      for (let [filter, value] of Object.entries(this.filters)) {
        let telemetryName = telmetryNames[filter];
        telemetryName !== void 0 && (telemetryData.properties[telemetryName] = value);
      }
    }
    stringify() {
      let keys = Object.keys(this.filters);
      return keys.sort(), keys.map(key => `${key}:${this.filters[key]}`).join(";");
    }
    toHeaders() {
      return {
        ...this.filters
      };
    }
    withChange(filter, value) {
      return new _FilterSettings({
        ...this.filters,
        [filter]: value
      });
    }
  };
var GranularityImplementation = class {
    constructor(prefix) {
      this.prefix = prefix;
    }
    static {
      __name(this, "GranularityImplementation");
    }
    getCurrentAndUpComingValues(now) {
      let currentValue = this.getValue(now),
        upcomingValues = this.getUpcomingValues(now);
      return [currentValue, upcomingValues];
    }
  },
  ConstantGranularity = class extends GranularityImplementation {
    static {
      __name(this, "ConstantGranularity");
    }
    getValue(now) {
      return this.prefix;
    }
    getUpcomingValues(now) {
      return [];
    }
  },
  DEFAULT_GRANULARITY = __name(prefix => new ConstantGranularity(prefix), "DEFAULT_GRANULARITY"),
  TimeBucketGranularity = class extends GranularityImplementation {
    constructor(prefix, fetchBeforeFactor = .5, anchor = new Date().setUTCHours(0, 0, 0, 0)) {
      super(prefix);
      this.prefix = prefix;
      this.fetchBeforeFactor = fetchBeforeFactor;
      this.anchor = anchor;
    }
    static {
      __name(this, "TimeBucketGranularity");
    }
    setTimePeriod(lengthMs) {
      isNaN(lengthMs) ? this.timePeriodLengthMs = void 0 : this.timePeriodLengthMs = lengthMs;
    }
    setByCallBuckets(numBuckets) {
      isNaN(numBuckets) ? this.numByCallBuckets = void 0 : this.numByCallBuckets = numBuckets;
    }
    getValue(now) {
      return this.prefix + this.getTimePeriodBucketString(now) + (this.numByCallBuckets ? this.timeHash(now) : "");
    }
    getTimePeriodBucketString(now) {
      return this.timePeriodLengthMs ? this.dateToTimePartString(now) : "";
    }
    getUpcomingValues(now) {
      let upcomingValues = [],
        upcomingTimePeriodBucketStrings = this.getUpcomingTimePeriodBucketStrings(now),
        upcomingByCallBucketStrings = this.getUpcomingByCallBucketStrings();
      for (let upcomingTimePeriodBucketString of upcomingTimePeriodBucketStrings) for (let upcomingByCallBucketString of upcomingByCallBucketStrings) upcomingValues.push(this.prefix + upcomingTimePeriodBucketString + upcomingByCallBucketString);
      return upcomingValues;
    }
    getUpcomingTimePeriodBucketStrings(now) {
      if (this.timePeriodLengthMs === void 0) return [""];
      if ((now.getTime() - this.anchor) % this.timePeriodLengthMs < this.fetchBeforeFactor * this.timePeriodLengthMs) return [this.getTimePeriodBucketString(now)];
      {
        let inABit = new Date(now.getTime() + this.timePeriodLengthMs);
        return [this.getTimePeriodBucketString(now), this.getTimePeriodBucketString(inABit)];
      }
    }
    getUpcomingByCallBucketStrings() {
      return this.numByCallBuckets === void 0 ? [""] : Array.from(Array(this.numByCallBuckets).keys()).map(x => x.toString());
    }
    timeHash(time) {
      return this.numByCallBuckets == null ? 0 : 7883 * (time.getTime() % this.numByCallBuckets) % this.numByCallBuckets;
    }
    dateToTimePartString(date) {
      return this.timePeriodLengthMs == null ? "" : Math.floor((date.getTime() - this.anchor) / this.timePeriodLengthMs).toString();
    }
  };
var BUCKETFILTER = "X-Copilot-ClientTimeBucket",
  GranularityDirectory = class {
    constructor(prefix, clock) {
      this.specs = new Map();
      this.prefix = prefix, this.clock = clock, this.defaultGranularity = DEFAULT_GRANULARITY(prefix);
    }
    static {
      __name(this, "GranularityDirectory");
    }
    selectGranularity(filters) {
      for (let [rememberedFilters, granularity] of this.specs.entries()) if (filters.extends(rememberedFilters)) return granularity;
      return this.defaultGranularity;
    }
    update(filters, byCallBuckets, timePeriodSizeInH) {
      if (byCallBuckets = byCallBuckets > 1 ? byCallBuckets : NaN, timePeriodSizeInH = timePeriodSizeInH > 0 ? timePeriodSizeInH : NaN, isNaN(byCallBuckets) && isNaN(timePeriodSizeInH)) this.specs.delete(filters);else {
        let newGranularity = new TimeBucketGranularity(this.prefix);
        isNaN(byCallBuckets) || newGranularity.setByCallBuckets(byCallBuckets), isNaN(timePeriodSizeInH) || newGranularity.setTimePeriod(timePeriodSizeInH * 3600 * 1e3), this.specs.set(filters, newGranularity);
      }
    }
    extendFilters(filters) {
      let implementation = this.selectGranularity(filters),
        [value, upcomingValues] = implementation.getCurrentAndUpComingValues(this.clock.now());
      return {
        newFilterSettings: filters.withChange(BUCKETFILTER, value),
        otherFilterSettingsToPrefetch: upcomingValues.map(value => filters.withChange(BUCKETFILTER, value))
      };
    }
  };
var FilterSettingsToExpConfigs = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.cache = new LRUCacheMap(200);
    }
    static {
      __name(this, "FilterSettingsToExpConfigs");
    }
    async fetchExpConfig(settings) {
      let task = this.cache.get(settings.stringify());
      return task || (task = new Task(() => this.ctx.get(ExpConfigMaker).fetchExperiments(this.ctx, settings.toHeaders()), 1e3 * 60 * 60), this.cache.set(settings.stringify(), task)), task.run();
    }
    getCachedExpConfig(settings) {
      return this.cache.get(settings.stringify())?.value();
    }
  },
  Task = class {
    constructor(producer, expirationMs = 1 / 0) {
      this.producer = producer;
      this.expirationMs = expirationMs;
    }
    static {
      __name(this, "Task");
    }
    async run() {
      return this.promise === void 0 && (this.promise = this.producer(), this.storeResult(this.promise).then(() => {
        this.expirationMs < 1 / 0 && this.promise !== void 0 && setTimeout(() => this.promise = void 0, this.expirationMs);
      })), this.promise;
    }
    async storeResult(promise) {
      try {
        this.result = await promise;
      } finally {
        this.result === void 0 && (this.promise = void 0);
      }
    }
    value() {
      return this.result;
    }
  },
  Features = class _Features {
    constructor(ctx) {
      this.ctx = ctx;
      this.staticFilters = {};
      this.dynamicFilters = {};
      this.upcomingDynamicFilters = {};
      this.assignments = new FilterSettingsToExpConfigs(this.ctx);
    }
    static {
      __name(this, "Features");
    }
    static {
      this.upcomingDynamicFilterCheckDelayMs = 20;
    }
    static {
      this.upcomingTimeBucketMinutes = 5 + Math.floor(Math.random() * 11);
    }
    registerStaticFilters(filters) {
      Object.assign(this.staticFilters, filters);
    }
    registerDynamicFilter(filter, generator) {
      this.dynamicFilters[filter] = generator;
    }
    getDynamicFilterValues() {
      let values = {};
      for (let [filter, generator] of Object.entries(this.dynamicFilters)) values[filter] = generator();
      return values;
    }
    registerUpcomingDynamicFilter(filter, generator) {
      this.upcomingDynamicFilters[filter] = generator;
    }
    async getAssignment(feature, requestFilters = {}, telemetryData) {
      let granularityDirectory = this.getGranularityDirectory(),
        preGranularityFilters = this.makeFilterSettings(requestFilters),
        rememberedGranularityExtension = granularityDirectory.extendFilters(preGranularityFilters),
        expAccordingToRememberedExtension = await this.getExpConfig(rememberedGranularityExtension.newFilterSettings);
      granularityDirectory.update(preGranularityFilters, +(expAccordingToRememberedExtension.variables.copilotbycallbuckets ?? NaN), +(expAccordingToRememberedExtension.variables.copilottimeperiodsizeinh ?? NaN));
      let currentGranularityExtension = granularityDirectory.extendFilters(preGranularityFilters),
        filters = currentGranularityExtension.newFilterSettings,
        exp = await this.getExpConfig(filters),
        backgroundQueue = new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs));
      for (let upcomingFilter of currentGranularityExtension.otherFilterSettingsToPrefetch) backgroundQueue = backgroundQueue.then(async () => {
        await new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs)), this.getExpConfig(upcomingFilter);
      });
      return this.prepareForUpcomingFilters(filters), telemetryData && (telemetryData.filtersAndExp = {
        exp: exp,
        filters: filters
      }), exp.variables[feature];
    }
    getGranularityDirectory() {
      if (!this.granularityDirectory) {
        let machineId = this.ctx.get(EditorSession).machineId;
        this.granularityDirectory = new GranularityDirectory(machineId, this.ctx.get(Clock));
      }
      return this.granularityDirectory;
    }
    makeFilterSettings(requestFilters) {
      return new FilterSettings({
        ...this.staticFilters,
        ...this.getDynamicFilterValues(),
        ...requestFilters
      });
    }
    async getExpConfig(settings) {
      try {
        return this.assignments.fetchExpConfig(settings);
      } catch (e) {
        return ExpConfig.createFallbackConfig(this.ctx, `Error fetching ExP config: ${e}`);
      }
    }
    async prepareForUpcomingFilters(filters) {
      if (!(new Date().getMinutes() < 60 - _Features.upcomingTimeBucketMinutes)) for (let [filter, generator] of Object.entries(this.upcomingDynamicFilters)) await new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs)), this.getExpConfig(filters.withChange(filter, generator()));
    }
    stringify() {
      let defaultExpConfig = this.assignments.getCachedExpConfig(new FilterSettings({}));
      return JSON.stringify(defaultExpConfig?.variables ?? {});
    }
    async addExpAndFilterToTelemetry(telemetryData) {
      let filters = this.makeFilterSettings({});
      telemetryData.filtersAndExp = {
        filters: filters,
        exp: await this.getExpConfig(filters)
      };
    }
    async debounceMs() {
      return (await this.getAssignment("copilotdebouncems")) ?? 0;
    }
    async debouncePredict() {
      return (await this.getAssignment("copilotdebouncepredict")) ?? !1;
    }
    async contextualFilterEnable() {
      return (await this.getAssignment("copilotcontextualfilterenable")) ?? !0;
    }
    async contextualFilterEnableTree() {
      return (await this.getAssignment("copilotcontextualfilterenabletree")) ?? !0;
    }
    async contextualFilterAcceptThreshold() {
      return (await this.getAssignment("copilotcontextualfilteracceptthreshold")) ?? 35;
    }
    async contextualFilterExplorationTraffic() {
      return (await this.getAssignment("copilotcontextualfilterexplorationtraffic")) ?? 1;
    }
    async disableLogProb() {
      return (await this.getAssignment("copilotdisablelogprob")) ?? !0;
    }
    async overrideBlockMode() {
      return (await this.getAssignment("copilotoverrideblockmode")) || void 0;
    }
    async fastCancellation() {
      return (await this.getAssignment("copilotoverridefastcancellation")) ?? !0;
    }
    async overrideNumGhostCompletions() {
      return await this.getAssignment("copilotoverridednumghostcompletions");
    }
    async dropCompletionReasons() {
      let reasons = await this.getAssignment("copilotdropcompletionreasons");
      if (reasons) return reasons.split(",");
    }
    async customEngine({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotcustomengine", filters, telemetryData)) ?? "";
    }
    async beforeRequestWaitMs({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotlms", filters, telemetryData)) ?? 0;
    }
    async multiLogitBias({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotlbeot", filters, telemetryData)) ?? !1;
    }
    async requestMultilineExploration({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultilineexploration", filters, telemetryData)) ?? !1;
    }
    async suffixPercent({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return getConfig(this.ctx, ConfigKey.DebugOverrideEngine) ? 0 : (await this.getAssignment("CopilotSuffixPercent", filters)) ?? 15;
    }
    async suffixMatchThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotsuffixmatchthreshold", filters)) ?? 10;
    }
    async fimSuffixLengthThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotfimsuffixlenthreshold", filters)) ?? 0;
    }
    async suffixStartMode({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotsuffixstartmode", filters)) {
        case "cursor":
          return $a.SuffixStartMode.Cursor;
        case "cursortrimstart":
          return $a.SuffixStartMode.CursorTrimStart;
        case "siblingblock":
          return $a.SuffixStartMode.SiblingBlock;
        case "siblingblocktrimstart":
          return $a.SuffixStartMode.SiblingBlockTrimStart;
        default:
          return $a.SuffixStartMode.CursorTrimStart;
      }
    }
    async numberOfSnippets({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotnumberofsnippets", filters)) ?? $a.DEFAULT_NUM_OF_SNIPPETS;
    }
    async snippetPercent({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("snippetpercent", filters)) ?? 0;
    }
    async neighboringTabsOption({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringtabs", filters)) {
        case "none":
          return $a.NeighboringTabsOption.None;
        case "conservative":
          return $a.NeighboringTabsOption.Conservative;
        case "medium":
          return $a.NeighboringTabsOption.Medium;
        case "eager":
          return $a.NeighboringTabsOption.Eager;
        case "eagerbutlittle":
          return $a.NeighboringTabsOption.EagerButLittle;
        case "eagerbutmedium":
          return $a.NeighboringTabsOption.EagerButMedium;
        case "eagerbutmuch":
          return $a.NeighboringTabsOption.EagerButMuch;
        case "retrievalcomparable":
          return $a.NeighboringTabsOption.RetrievalComparable;
        default:
          return $a.NeighboringTabsOption.Eager;
      }
    }
    async neighboringSnippetTypes({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringsnippettypes", filters)) {
        case "function":
          return $a.NeighboringSnippetType.NeighboringFunctions;
        case "snippet":
          return $a.NeighboringSnippetType.NeighboringSnippets;
        case "cursor":
          return $a.NeighboringSnippetType.CursorHistoryMatcher;
        default:
          return $a.NeighboringSnippetType.NeighboringSnippets;
      }
    }
    async neighboringFileType({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringfiletype", filters)) {
        case "none":
          return "none";
        case "cursormostrecent":
          return "cursormostrecent";
        case "cursormostcount":
          return "cursormostcount";
        case "workspacesharingsamefolder":
          return "workspacesharingsamefolder";
        case "workspacesmallestpathdist":
          return "workspacesmallestpathdist";
        case "cocommitted":
          return "opentabsandcocommitted";
        case "opentabs":
        default:
          return "opentabs";
      }
    }
    async cursorSnippetsPickingStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("cursorsnippetspickingstrategy", filters)) {
        case "cursoronly":
          return $a.CursorSnippetsPickingStrategy.CursorOnly;
        case "jaccardcursor":
          return $a.CursorSnippetsPickingStrategy.JaccardCursor;
        case "cursorjaccard":
        default:
          return $a.CursorSnippetsPickingStrategy.CursorJaccard;
      }
    }
    async retrievalStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("retrieval", filters, telemetryData)) ?? !1;
    }
    async retrievalServerRoute({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
          "X-Copilot-Repository": repoNwo,
          "X-Copilot-FileType": fileType,
          "X-Copilot-UserKind": userKind,
          "X-Copilot-Dogfood": dogFood,
          "X-Copilot-CustomModel": customModel,
          "X-Copilot-RetrievalOrg": retrievalOrg
        },
        expvalue = await this.getAssignment("retrievalserverroute", filters, telemetryData);
      switch (expvalue) {
        case "aims":
          return "2";
        case "devdiv":
          return "1";
        case "githubnext":
          return "0";
        default:
          return expvalue ?? "0";
      }
    }
    async symbolDefinitionStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotsymboldefinitionstrategy", filters)) ?? !1;
    }
    async localImportContext({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("localimportcontext", filters)) {
        case !0:
          return $a.LocalImportContextOption.Declarations;
        case !1:
        default:
          return $a.LocalImportContextOption.NoContext;
      }
    }
    async maxPromptCompletionTokens({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, def) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("maxpromptcompletionTokens", filters)) ?? def;
    }
    async hybridInference({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("hybridinference", filters)) ?? !1;
    }
    async hybridInferenceThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return ((await this.getAssignment("hybridinferencethreshold", filters)) ?? -100) / 100;
    }
    async requestMultiOnNewLine({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultionnewline", filters)) ?? !1;
    }
    async requestMultiModel({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultimodel", filters)) ?? !1;
    }
    async requestMultiModelThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return ((await this.getAssignment("copilotrequestmultimodelthreshold", filters)) ?? 100) / 100;
    }
  };
var packageJson = rO(),
  ConfigKey = {
    Enable: "enable",
    InlineSuggestEnable: "inlineSuggest.enable",
    ShowEditorCompletions: ["editor", "showEditorCompletions"],
    EnableAutoCompletions: ["editor", "enableAutoCompletions"],
    DelayCompletions: ["editor", "delayCompletions"],
    FilterCompletions: ["editor", "filterCompletions"],
    DisplayStyle: ["advanced", "displayStyle"],
    SecretKey: ["advanced", "secret_key"],
    SolutionLength: ["advanced", "length"],
    Stops: ["advanced", "stops"],
    Temperature: ["advanced", "temperature"],
    TopP: ["advanced", "top_p"],
    IndentationMode: ["advanced", "indentationMode"],
    InlineSuggestCount: ["advanced", "inlineSuggestCount"],
    ListCount: ["advanced", "listCount"],
    DebugOverrideCapiUrl: ["advanced", "debug.overrideCapiUrl"],
    DebugTestOverrideCapiUrl: ["advanced", "debug.testOverrideCapiUrl"],
    DebugOverrideProxyUrl: ["advanced", "debug.overrideProxyUrl"],
    DebugTestOverrideProxyUrl: ["advanced", "debug.testOverrideProxyUrl"],
    DebugOverrideEngine: ["advanced", "debug.overrideEngine"],
    DebugShowScores: ["advanced", "debug.showScores"],
    DebugOverrideLogLevels: ["advanced", "debug.overrideLogLevels"],
    DebugFilterLogCategories: ["advanced", "debug.filterLogCategories"],
    DebugSnippyOverrideUrl: ["advanced", "debug.codeRefOverrideUrl"],
    DebugTruncationKiwi: ["advanced", "debug.truncationKiwi"],
    KerberosServicePrincipal: ["advanced", "kerberosServicePrincipal"]
  };
function shouldDoParsingTrimming(blockMode) {
  return ["parsing", "parsingandserver"].includes(blockMode);
}
__name(shouldDoParsingTrimming, "shouldDoParsingTrimming");
function shouldDoServerTrimming(blockMode) {
  return ["server", "parsingandserver"].includes(blockMode);
}
__name(shouldDoServerTrimming, "shouldDoServerTrimming");
var BlockModeConfig = class {
    static {
      __name(this, "BlockModeConfig");
    }
  },
  ConfigBlockModeConfig = class extends BlockModeConfig {
    static {
      __name(this, "ConfigBlockModeConfig");
    }
    async forLanguage(ctx, languageId) {
      if (ctx.get(ConfigProvider).isDefaultSettingOverwritten(ConfigKey.IndentationMode)) switch (ctx.get(ConfigProvider).getLanguageConfig(ConfigKey.IndentationMode, languageId)) {
        case "client":
        case !0:
        case "server":
          return "server";
        case "clientandserver":
          return toApplicableBlockMode("parsingandserver", languageId);
        default:
          return "parsing";
      }
      let overrideBlockMode = await ctx.get(Features).overrideBlockMode();
      return overrideBlockMode ? toApplicableBlockMode(overrideBlockMode, languageId) : languageId == "ruby" ? "parsing" : (0, Ox.isSupportedLanguageId)(languageId) ? "parsingandserver" : "server";
    }
  };
function toApplicableBlockMode(blockMode, languageId) {
  switch (blockMode) {
    case "parsing":
      return (0, Ox.isSupportedLanguageId)(languageId) ? "parsing" : "server";
    case "server":
      return "server";
    case "parsingandserver":
    default:
      return (0, Ox.isSupportedLanguageId)(languageId) ? "parsingandserver" : "server";
  }
}
__name(toApplicableBlockMode, "toApplicableBlockMode");
var ConfigProvider = class {
  static {
    __name(this, "ConfigProvider");
  }
};
function getConfigDefaultForObjectKey(key, objectKey) {
  try {
    let value = packageJson.contributes.configuration[0].properties[`${CopilotConfigPrefix}.${key}`].properties[objectKey].default;
    if (value === void 0) throw new Error(`Missing config default value: ${CopilotConfigPrefix}.${key}`);
    return value;
  } catch (e) {
    throw new Error(`Error inspecting config default value ${CopilotConfigPrefix}.${key}.${objectKey}: ${e}`);
  }
}
__name(getConfigDefaultForObjectKey, "getConfigDefaultForObjectKey");
function getConfig(ctx, key) {
  return ctx.get(ConfigProvider).getConfig(key);
}
__name(getConfig, "getConfig");
function isDefaultSettingOverwritten(ctx, key) {
  return ctx.get(ConfigProvider).isDefaultSettingOverwritten(key);
}
__name(isDefaultSettingOverwritten, "isDefaultSettingOverwritten");
function getHiddenConfig(ctx, key, options) {
  return isDefaultSettingOverwritten(ctx, key) ? getConfig(ctx, key) : options.default;
}
__name(getHiddenConfig, "getHiddenConfig");
function dumpConfig(ctx) {
  return ctx.get(ConfigProvider).dumpConfig();
}
__name(dumpConfig, "dumpConfig");
function getLanguageConfig(ctx, key, language) {
  return ctx.get(ConfigProvider).getLanguageConfig(key, language);
}
__name(getLanguageConfig, "getLanguageConfig");
function getEnabledConfig(ctx, language) {
  return getLanguageConfig(ctx, ConfigKey.Enable, language);
}
__name(getEnabledConfig, "getEnabledConfig");
var BuildInfo = class {
  constructor() {
    this.packageJson = packageJson;
  }
  static {
    __name(this, "BuildInfo");
  }
  isProduction() {
    return this.getBuildType() != "dev";
  }
  getBuildType() {
    return this.packageJson.buildType;
  }
  getVersion() {
    return this.packageJson.version;
  }
  getBuild() {
    return this.packageJson.build;
  }
  getName() {
    return this.packageJson.name;
  }
};
function isProduction(ctx) {
  return ctx.get(BuildInfo).isProduction();
}
__name(isProduction, "isProduction");
function getBuildType(ctx) {
  return ctx.get(BuildInfo).getBuildType();
}
__name(getBuildType, "getBuildType");
function getBuild(ctx) {
  return ctx.get(BuildInfo).getBuild();
}
__name(getBuild, "getBuild");
function getVersion(ctx) {
  return ctx.get(BuildInfo).getVersion();
}
__name(getVersion, "getVersion");
var EditorSession = class {
  constructor(sessionId, machineId) {
    this.sessionId = sessionId;
    this.machineId = machineId;
  }
  static {
    __name(this, "EditorSession");
  }
};
function formatNameAndVersion({
  name: name,
  version: version
}) {
  return `${name}/${version}`;
}
__name(formatNameAndVersion, "formatNameAndVersion");
var EditorAndPluginInfo = class {
  static {
    __name(this, "EditorAndPluginInfo");
  }
};
function editorVersionHeaders(ctx) {
  let info = ctx.get(EditorAndPluginInfo);
  return {
    "Editor-Version": formatNameAndVersion(info.getEditorInfo()),
    "Editor-Plugin-Version": formatNameAndVersion(info.getEditorPluginInfo())
  };
}
__name(editorVersionHeaders, "editorVersionHeaders");
var LogLevel = (i => (LogLevel[i.DEBUG = 0] = "DEBUG", LogLevel[i.INFO = 1] = "INFO", LogLevel[i.WARN = 2] = "WARN", LogLevel[i.ERROR = 3] = "ERROR", LogLevel))(g0 || {}),
  LogVerbose = class {
    constructor(logVerbose) {
      this.logVerbose = logVerbose;
    }
    static {
      __name(this, "LogVerbose");
    }
  };
function verboseLogging(ctx) {
  return ctx.get(LogVerbose).logVerbose;
}
__name(verboseLogging, "verboseLogging");
var LogTarget = class {
    static {
      __name(this, "LogTarget");
    }
    shouldLog(ctx, level) {}
  },
  ConsoleLog = class extends LogTarget {
    constructor(console) {
      super();
      this.console = console;
    }
    static {
      __name(this, "ConsoleLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      verboseLogging(ctx) || level == 3 ? this.console.error(metadataStr, ...extra) : level == 2 && this.console.warn(metadataStr, ...extra);
    }
  },
  OutputChannelLog = class extends LogTarget {
    constructor(output) {
      super();
      this.output = output;
    }
    static {
      __name(this, "OutputChannelLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      this.output.appendLine(`${metadataStr} ${extra.map(toPlainText)}`);
    }
  },
  MultiLog = class extends LogTarget {
    constructor(targets) {
      super();
      this.targets = targets;
    }
    static {
      __name(this, "MultiLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      this.targets.forEach(t => t.logIt(ctx, level, metadataStr, ...extra));
    }
  },
  Logger = class {
    static {
      __name(this, "Logger");
    }
    constructor(minLoggedLevel, context) {
      this.minLoggedLevel = minLoggedLevel, this.context = context;
    }
    setLevel(level) {
      this.minLoggedLevel = level;
    }
    stringToLevel(s) {
      return LogLevel[s];
    }
    log(ctx, level, ...extra) {
      let levelString = LogLevel[level],
        logTarget = ctx.get(LogTarget),
        targetOverride = logTarget.shouldLog(ctx, level);
      if (targetOverride === !1 || targetOverride === void 0 && !this.shouldLog(ctx, level, this.context)) return;
      let timestamp = ctx.get(Clock).now().toISOString(),
        metadataStr = `[${levelString}] [${this.context}] [${timestamp}]`;
      logTarget.logIt(ctx, level, metadataStr, ...extra);
    }
    sendErrorTelemetry(ctx, name, secureMessage, standardMessage) {
      telemetryError(ctx, name, TelemetryData.createAndMarkAsIssued({
        context: this.context,
        level: LogLevel[3],
        message: secureMessage
      }), 1), telemetryError(ctx, name, TelemetryData.createAndMarkAsIssued({
        context: this.context,
        level: LogLevel[3],
        message: standardMessage
      }), 0);
    }
    telemetryMessage(...extra) {
      return extra.length > 0 ? JSON.stringify(extra) : "no msg";
    }
    shouldLog(ctx, level, category) {
      if (verboseLogging(ctx)) return !0;
      let levels = getConfig(ctx, ConfigKey.DebugFilterLogCategories);
      if (levels.length > 0 && !levels.includes(category)) return !1;
      if (isProduction(ctx)) return level >= this.minLoggedLevel;
      let overrides = getConfig(ctx, ConfigKey.DebugOverrideLogLevels),
        minLevel = this.stringToLevel(overrides["*"]) ?? this.stringToLevel(overrides[this.context]) ?? this.minLoggedLevel;
      return level >= minLevel;
    }
    debug(ctx, ...extra) {
      this.log(ctx, 0, ...extra);
    }
    info(ctx, ...extra) {
      this.log(ctx, 1, ...extra);
    }
    warn(ctx, ...extra) {
      this.log(ctx, 2, ...extra);
    }
    error(ctx, ...extra) {
      this.sendErrorTelemetry(ctx, "log", this.telemetryMessage(...extra), "[redacted]"), this.log(ctx, 3, ...extra);
    }
    exception(ctx, error, message) {
      if (error instanceof Error && error.name === "Canceled" && error.message === "Canceled") return;
      telemetryException(ctx, error, message ?? "logger.exception");
      let prefix = message ? `${message}: ` : "",
        safeError = error instanceof Error ? error : new Error("Non-error thrown: " + error);
      this.log(ctx, 3, `${prefix}(${safeError.constructor.name}) ${safeError.message}`);
    }
  };
function toPlainText(x) {
  switch (typeof x) {
    case "object":
      return JSON.stringify(x);
    default:
      return String(x);
  }
}
__name(toPlainText, "toPlainText");
var logger = new Logger(1, "default");
var NotificationSender = class {
  static {
    __name(this, "NotificationSender");
  }
};
var open = yee(),
  UrlOpener = class {
    static {
      __name(this, "UrlOpener");
    }
  },
  RealUrlOpener = class extends UrlOpener {
    static {
      __name(this, "RealUrlOpener");
    }
    async open(target) {
      await open(target);
    }
  };
var CERTIFICATE_ERRORS = ["UNABLE_TO_VERIFY_LEAF_SIGNATURE", "CERT_SIGNATURE_FAILURE"],
  UserErrorNotifier = class {
    constructor(ctx) {
      this.notifiedErrorCodes = [];
      ctx.get(CopilotTokenNotifier).on("onCopilotToken", token => {
        this.supportsSSC = token.getTokenValue("ssc") === "1";
      });
    }
    static {
      __name(this, "UserErrorNotifier");
    }
    async notifyUser(ctx, error) {
      CERTIFICATE_ERRORS.includes(error.code) && !this.didNotifyBefore(error.code) && (this.displayCertificateErrorNotification(ctx, error), this.notifiedErrorCodes.push(error.code));
    }
    displayCertificateErrorNotification(ctx, err) {
      let learnMoreLink = "https://gh.io/copilot-network-errors",
        errorMsg = this.certificateErrorMessage();
      new Logger(3, "certificates").error(ctx, `${errorMsg} Please visit ${learnMoreLink} to learn more. Original cause: ${JSON.stringify(err)}`), this.showCertificateWarningMessage(ctx, errorMsg, learnMoreLink);
    }
    certificateErrorMessage() {
      return this.supportsSSC === void 0 ? "The proxy connection couldn't be established due to an untrusted custom certificate, or your Copilot license might not support their use." : this.supportsSSC ? "Your proxy connection requires a trusted certificate. Please make sure the proxy certificate and any issuers are configured correctly and trusted by your operating system." : "Your current Copilot license doesn't support proxy connections with custom certificates.";
    }
    showCertificateWarningMessage(ctx, errorMsg, learnMoreLink) {
      let learnMoreAction = {
        title: "Learn more"
      };
      ctx.get(NotificationSender).showWarningMessage(errorMsg, learnMoreAction).then(userResponse => {
        userResponse?.title === learnMoreAction.title && ctx.get(UrlOpener).open(learnMoreLink);
      });
    }
    didNotifyBefore(code) {
      return this.notifiedErrorCodes.indexOf(code) !== -1;
    }
  };
var import_vscode_uri = Ns(B1());
var DotComAuthority = "github.com",
  DotComUrl = `https://${DotComAuthority}`,
  NetworkConfiguration = class {
    static {
      __name(this, "NetworkConfiguration");
    }
  },
  DefaultNetworkConfiguration = class extends NetworkConfiguration {
    constructor(url = DotComUrl, env = process.env) {
      super();
      this.env = env;
      this.recalculateUrls(url);
    }
    static {
      __name(this, "DefaultNetworkConfiguration");
    }
    isGitHubEnterprise() {
      return this.isEnterprise;
    }
    getAuthAuthority() {
      return this.baseUri.authority;
    }
    getTokenUrl(githubToken) {
      return githubToken.devOverride?.copilotTokenUrl ?? this.tokenUrl;
    }
    getNotificationUrl(githubToken) {
      return githubToken.devOverride?.notificationUrl ?? this.notificationUrl;
    }
    getContentRestrictionsUrl(githubToken) {
      return githubToken.devOverride?.contentRestrictionsUrl ?? this.contentRestrictionsUrl;
    }
    getDeviceFlowStartUrl() {
      return this.deviceFlowStartUrl;
    }
    getDeviceFlowCompletionUrl() {
      return this.deviceFlowCompletionUrl;
    }
    getUserInfoUrl() {
      return this.userInfoUrl;
    }
    updateBaseUrl(ctx, newUrl = DotComUrl) {
      let oldUri = this.baseUri;
      this.recalculateUrls(newUrl), oldUri.toString() !== this.baseUri.toString() && ctx.get(CopilotTokenManager).resetCopilotToken(ctx);
    }
    recalculateUrls(url) {
      let uris = this.parseUris(url);
      this.baseUri = uris.base;
      let apiUri = uris.api;
      this.isEnterprise = this.baseUri.authority !== DotComAuthority, this.tokenUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/v2/token").toString(), this.notificationUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/notification").toString(), this.contentRestrictionsUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/content_exclusion").toString(), this.deviceFlowStartUrl = Pu.Utils.joinPath(this.baseUri, "/login/device/code").toString(), this.deviceFlowCompletionUrl = Pu.Utils.joinPath(this.baseUri, "/login/oauth/access_token").toString(), this.userInfoUrl = Pu.Utils.joinPath(apiUri, "/user").toString();
    }
    parseUris(url) {
      if (this.env.CODESPACES === "true" && this.env.GITHUB_TOKEN && this.env.GITHUB_SERVER_URL && this.env.GITHUB_API_URL) try {
        return {
          base: Pu.URI.parse(this.env.GITHUB_SERVER_URL, !0),
          api: Pu.URI.parse(this.env.GITHUB_API_URL, !0)
        };
      } catch {}
      let base = Pu.URI.parse(url),
        api = Pu.URI.parse(`${base.scheme}://api.${base.authority}`);
      return {
        base: base,
        api: api
      };
    }
  };
var authLogger = new Logger(1, "auth"),
  REFRESH_BUFFER_SECONDS = 60,
  refreshRunningCount = 0,
  TOKEN_REFRESHED_EVENT = "token_refreshed";
function nowSeconds() {
  return Math.floor(Date.now() / 1e3);
}
__name(nowSeconds, "nowSeconds");
async function authFromGitHubToken(ctx, githubToken) {
  telemetry(ctx, "auth.new_login");
  let response = await fetchCopilotToken(ctx, githubToken),
    tokenInfo = await response.json();
  if (!tokenInfo) return authLogger.info(ctx, "Failed to get copilot token"), telemetryError(ctx, "auth.request_read_failed"), {
    kind: "failure",
    reason: "FailedToGetToken"
  };
  let notification = tokenInfo.user_notification;
  if (notifyUser(ctx, notification, githubToken), response.status === 401) {
    let message = "Failed to get copilot token due to 401 status. Please sign out and try again.";
    return authLogger.info(ctx, message), telemetryError(ctx, "auth.unknown_401"), {
      kind: "failure",
      reason: "HTTP401",
      message: message
    };
  }
  if (!response.ok || !tokenInfo.token) {
    authLogger.info(ctx, `Invalid copilot token: missing token: ${response.status} ${response.statusText}`), telemetryError(ctx, "auth.invalid_token", TelemetryData.createAndMarkAsIssued({
      status: response.status.toString(),
      status_text: response.statusText
    }));
    let error_details = tokenInfo.error_details;
    return notifyUser(ctx, error_details, githubToken), {
      kind: "failure",
      reason: "NotAuthorized",
      message: "User not authorized",
      ...error_details
    };
  }
  let expires_at = tokenInfo.expires_at;
  tokenInfo.expires_at = nowSeconds() + tokenInfo.refresh_in + REFRESH_BUFFER_SECONDS;
  let {
      token: token,
      organization_list: organization_list,
      enterprise_list: enterprise_list,
      ...tokenEnvelope
    } = tokenInfo,
    copilotToken = new CopilotToken(token, organization_list, enterprise_list);
  return ctx.get(CopilotTokenNotifier).emit("onCopilotToken", copilotToken, tokenEnvelope), telemetry(ctx, "auth.new_token", TelemetryData.createAndMarkAsIssued({}, {
    adjusted_expires_at: tokenInfo.expires_at,
    expires_at: expires_at,
    current_time: nowSeconds()
  })), {
    kind: "success",
    ...tokenInfo
  };
}
__name(authFromGitHubToken, "authFromGitHubToken");
async function fetchCopilotToken(ctx, githubToken) {
  let copilotTokenUrl = ctx.get(NetworkConfiguration).getTokenUrl(githubToken);
  try {
    return await ctx.get(Fetcher).fetch(copilotTokenUrl, {
      headers: {
        Authorization: `token ${githubToken.token}`,
        ...editorVersionHeaders(ctx)
      }
    });
  } catch (err) {
    throw ctx.get(UserErrorNotifier).notifyUser(ctx, err), err;
  }
}
__name(fetchCopilotToken, "fetchCopilotToken");
var recentNotifications = new Map();
function notifyUser(ctx, notification, githubToken) {
  if (!notification) return;
  let now = nowSeconds();
  recentNotifications.get(notification.message) || (recentNotifications.set(notification.message, now), ctx.get(NotificationSender).showWarningMessage(notification.message, {
    title: notification.title
  }, {
    title: "Dismiss"
  }).then(async r => {
    let showUrl = r?.title === notification.title,
      ackNotification = showUrl || r?.title === "Dismiss";
    if (showUrl) {
      let editorInfo = ctx.get(EditorAndPluginInfo).getEditorPluginInfo(),
        urlWithContext = notification.url.replace("{EDITOR}", encodeURIComponent(editorInfo.name + "_" + editorInfo.version));
      await ctx.get(UrlOpener).open(urlWithContext);
    }
    "notification_id" in notification && ackNotification && (await sendNotificationResultToGitHub(ctx, notification.notification_id, githubToken));
  }).catch(error => {
    authLogger.exception(ctx, error, "copilotToken.notification");
  }));
}
__name(notifyUser, "notifyUser");
async function sendNotificationResultToGitHub(ctx, notification_id, githubToken) {
  let notificationUrl = ctx.get(NetworkConfiguration).getNotificationUrl(githubToken),
    response = await ctx.get(Fetcher).fetch(notificationUrl, {
      headers: {
        Authorization: `token ${githubToken.token}`,
        ...editorVersionHeaders(ctx)
      },
      method: "POST",
      body: JSON.stringify({
        notification_id: notification_id
      })
    });
  (!response || !response.ok) && authLogger.error(ctx, `Failed to send notification result to GitHub: ${response?.status} ${response?.statusText}`);
}
__name(sendNotificationResultToGitHub, "sendNotificationResultToGitHub");
var CopilotToken = class {
  constructor(token, organization_list, enterprise_list) {
    this.token = token;
    this.organization_list = organization_list;
    this.enterprise_list = enterprise_list;
    this.tokenMap = this.parseToken(token);
  }
  static {
    __name(this, "CopilotToken");
  }
  parseToken(token) {
    let result = new Map(),
      fields = token?.split(":")[0]?.split(";");
    for (let field of fields) {
      let [key, value] = field.split("=");
      result.set(key, value);
    }
    return result;
  }
  getTokenValue(key) {
    return this.tokenMap.get(key);
  }
};
function refreshToken(ctx, tokenManager, refreshIn) {
  let now = nowSeconds();
  refreshRunningCount > 0 || (refreshRunningCount++, setTimeout(async () => {
    let kind,
      error = "";
    try {
      refreshRunningCount--, await tokenManager.getCopilotToken(ctx, !0), kind = "success", tokenManager.tokenRefreshEventEmitter.emit(TOKEN_REFRESHED_EVENT);
    } catch (e) {
      kind = "failure", error = e.toString();
    }
    let data = TelemetryData.createAndMarkAsIssued({
      result: kind
    }, {
      time_taken: nowSeconds() - now,
      refresh_count: refreshRunningCount
    });
    error && (data.properties.reason = error), telemetry(ctx, "auth.token_refresh", data);
  }, refreshIn * 1e3));
}
__name(refreshToken, "refreshToken");
var authLogger = new Logger(1, "auth"),
  CopilotTokenManager = class {
    static {
      __name(this, "CopilotTokenManager");
    }
    constructor() {
      this.tokenRefreshEventEmitter = new Cee.EventEmitter();
    }
    async getGitHubToken(ctx) {
      return (await this.getGitHubSession(ctx))?.token;
    }
  },
  CopilotTokenManagerFromGitHubTokenBase = class extends CopilotTokenManager {
    constructor() {
      super();
      this.copilotToken = void 0;
    }
    static {
      __name(this, "CopilotTokenManagerFromGitHubTokenBase");
    }
    async getCopilotToken(ctx, force) {
      if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds() || force) {
        let gitHubToken = await this.getGitHubSession(ctx);
        if (!gitHubToken) throw new CopilotAuthError("Not signed in");
        let tokenResult = await authFromGitHubToken(ctx, gitHubToken);
        if (tokenResult.kind === "failure") {
          if (tokenResult.message) throw new CopilotAuthError(tokenResult.message);
          let error = new Error(`Unexpected error getting Copilot token: ${tokenResult.reason}`);
          throw error.code = `CopilotToken.${tokenResult.reason}`, error;
        }
        this.copilotToken = {
          ...tokenResult
        }, refreshToken(ctx, this, tokenResult.refresh_in);
      }
      return new CopilotToken(this.copilotToken.token, this.copilotToken.organization_list);
    }
    async checkCopilotToken(ctx) {
      if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {
        let gitHubToken = await this.getGitHubSession(ctx);
        if (!gitHubToken) throw new CopilotAuthError("Not signed in");
        let tokenResult = await authFromGitHubToken(ctx, gitHubToken);
        if (tokenResult.kind === "failure") return tokenResult;
        this.copilotToken = {
          ...tokenResult
        }, refreshToken(ctx, this, tokenResult.refresh_in);
      }
      return {
        status: "OK"
      };
    }
    resetCopilotToken(ctx, httpError) {
      httpError !== void 0 && telemetry(ctx, "auth.reset_token_" + httpError), authLogger.debug(ctx, `Resetting copilot token on HTTP error ${httpError || "unknown"}`), this.copilotToken = void 0;
    }
  };
var Debouncer = class {
  static {
    __name(this, "Debouncer");
  }
  async debounce(ms) {
    return this.state && (clearTimeout(this.state.timer), this.state.reject(), this.state = void 0), new Promise((resolve, reject) => {
      this.state = {
        timer: setTimeout(() => resolve(), ms),
        reject: reject
      };
    });
  }
};
function debounce(ms, callback) {
  let timer;
  return (...args) => (timer && clearTimeout(timer), new Promise(resolve => {
    timer = setTimeout(() => {
      let returnValue = callback(...args);
      resolve(returnValue);
    }, ms);
  }));
}
__name(debounce, "debounce");
var import_copilot_promptlib = Ns(Dc());
var CompletionsCache = class {
  static {
    __name(this, "CompletionsCache");
  }
  constructor() {
    this._cache = new LRUCacheMap(100);
  }
  get(promptKey) {
    return this._cache.get(promptKey);
  }
  set(promptKey, contents) {
    this._cache.set(promptKey, contents);
  }
  clear() {
    this._cache.clear();
  }
};
function treeScore(input) {
  let var0;
  input[0] > 1e-35 ? input[29] > 1e-35 ? input[138] > 1e-35 ? var0 = .49496579646815353 : var0 = .47546580490346646 : input[30] > 1e-35 ? var0 = .4456371992737078 : input[4] > 3.238486181444842 ? input[135] > 1e-35 ? var0 = .2645576817782658 : input[46] > 1e-35 ? var0 = .20251922126765812 : var0 = .37359143313367105 : input[7] > .9662372103242399 ? var0 = .44975631109230374 : var0 = .4067133376207218 : input[7] > .960816451500545 ? input[29] > 1e-35 ? input[4] > 1.7005986908310777 ? var0 = .4240336839258693 : var0 = .35414085998710754 : input[4] > 3.238486181444842 ? var0 = .353882328354817 : input[100] > 1e-35 ? var0 = .48783079865293355 : input[30] > 1e-35 ? var0 = .419904106522537 : var0 = .38599249795612806 : input[4] > 3.6242520361853052 ? input[29] > 1e-35 ? input[7] > .5086748127709895 ? var0 = .37522628419389664 : var0 = .3359393805000766 : input[30] > 1e-35 ? var0 = .3685210833144829 : input[135] > 1e-35 ? var0 = .22140958666091123 : input[134] > 1e-35 ? var0 = .38379851487275685 : input[46] > 1e-35 ? var0 = .1926283522107934 : var0 = .3098162447812857 : input[46] > 1e-35 ? var0 = .22698331991181095 : input[4] > 1.4978661367769956 ? input[30] > 1e-35 ? input[4] > 2.138333059508028 ? var0 = .39709448374768985 : var0 = .34711865383837703 : input[134] > 1e-35 ? var0 = .40608455346469957 : input[135] > 1e-35 ? var0 = .3084120164848763 : input[48] > 1e-35 ? var0 = .24193590696691425 : input[51] > 1e-35 ? var0 = .2087938690163009 : input[4] > 3.1984648276080736 ? var0 = .3529508564858481 : var0 = .3698795818909763 : var0 = .30210240039979064;
  let var1;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[2] > 3.676220550121792 ? input[7] > .9246495578512688 ? var1 = .0570428673081833 : var1 = .019779482100154476 : input[7] > .9705672697050661 ? var1 = .1023948532887641 : var1 = .06265430080550045 : input[29] > 1e-35 ? input[5] > 4.658699722134796 ? input[2] > 1.2424533248940002 ? var1 = .12784241430585772 : var1 = .15126156743993927 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var1 = .10624230855386699 : var1 = -.1699142543394302 : var1 = .10290106276456985 : input[5] > 3.5694334999727624 ? var1 = .09368877801612557 : var1 = .1552615744687782 : input[2] > 3.3842466058243152 ? input[4] > 3.5694334999727624 ? input[29] > 1e-35 ? input[7] > .7022798213723723 ? var1 = .02282408308012389 : var1 = -.032610792718175546 : var1 = -.04405498437523181 : input[46] > 1e-35 ? var1 = -.14475563528583885 : input[7] > .9159108669154322 ? var1 = .02539215399728953 : input[134] > 1e-35 ? var1 = .04720629593220485 : input[4] > 1.8688348091416842 ? var1 = -.00150052748656963 : var1 = -.04528409340753242 : input[5] > 3.5694334999727624 ? input[4] > 3.6505739029280164 ? input[29] > 1e-35 ? var1 = .050909089229765704 : input[39] > 1e-35 ? var1 = -.08747827386821926 : input[46] > 1e-35 ? var1 = -.11300671054986217 : var1 = -.002669293928522137 : input[46] > 1e-35 ? var1 = -.07873653229849684 : input[39] > 1e-35 ? var1 = -.06389470798465265 : input[2] > .8958797346140276 ? input[47] > 1e-35 ? var1 = -.07102696386827136 : input[4] > 1.8688348091416842 ? var1 = .04567768852273886 : var1 = .016429189359442275 : var1 = .024223384872688037 : input[7] > .9569480028661056 ? var1 = .12458720561596202 : var1 = -.006224718391409129;
  let var2;
  input[29] > 1e-35 ? input[2] > 2.602003343538398 ? input[2] > 4.166635176627655 ? input[7] > .8375851232899904 ? var2 = .027219239366992384 : var2 = -.023288925509443156 : input[7] > .5866799179067689 ? var2 = .05780689652787357 : var2 = .019914206435185725 : input[2] > 1.2424533248940002 ? input[7] > .9246495578512688 ? var2 = .1091540005913688 : var2 = .08430043254349175 : input[6] > 4.832297822126891 ? input[125] > 1e-35 ? var2 = .029350728374412424 : var2 = .1327178977041336 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var2 = -.10742256752042179 : var2 = .10128035205992136 : var2 = .08719230025231978 : input[5] > 3.772694874805912 ? input[39] > 1e-35 ? var2 = -.07712063687837625 : input[46] > 1e-35 ? var2 = -.09987046122905541 : input[2] > 3.6242520361853052 ? input[134] > 1e-35 ? var2 = .0549278412468898 : input[155] > 1e-35 ? var2 = .0628934857241284 : input[47] > 1e-35 ? var2 = -.14605662411148382 : input[48] > 1e-35 ? var2 = -.1460221669882455 : var2 = .002073957868392086 : input[2] > 1e-35 ? input[47] > 1e-35 ? var2 = -.0769198367034467 : input[155] > 1e-35 ? var2 = .0769122902449957 : input[134] > 1e-35 ? var2 = .06856131328753592 : input[152] > 1e-35 ? var2 = .07081107422282688 : input[51] > 1e-35 ? var2 = -.11095669360187602 : input[91] > 1e-35 ? var2 = -.08136006552659215 : input[48] > 1e-35 ? var2 = -.07180356044417698 : input[18] > 1e-35 ? var2 = -.029572927306223313 : input[50] > 1e-35 ? var2 = -.11419309779400831 : var2 = .03331652781327257 : var2 = .0015747823792064454 : input[7] > .9662372103242399 ? var2 = .1203598683210537 : var2 = .011240838199712565;
  let var3;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[1] > 1e-35 ? input[2] > 4.03420147928485 ? var3 = .03823654007072966 : input[7] > .9033253454895247 ? var3 = .09329944316059466 : var3 = .06705865009439997 : input[134] > 1e-35 ? var3 = .06865805795066232 : input[30] > 1e-35 ? var3 = .05189058132179502 : input[217] > 1e-35 ? var3 = .044913757044379055 : var3 = -.05078929160105722 : input[1] > 1e-35 ? input[6] > 5.161920636569023 ? input[2] > 1.4978661367769956 ? var3 = .10652732380394028 : var3 = .13307829460294332 : input[7] > .985694415330804 ? var3 = .06936133858882627 : var3 = .11090193559908544 : input[30] > 1e-35 ? var3 = .10406540623634791 : var3 = .03985408831881549 : input[1] > 1e-35 ? input[2] > 3.772694874805912 ? input[29] > 1e-35 ? input[7] > .7316379010844482 ? var3 = .012897973304512032 : var3 = -.028068579877067623 : var3 = .024577017676752924 : input[5] > 3.417592293073651 ? input[22] > 1e-35 ? var3 = -.023871063947594612 : input[7] > .8255520169851381 ? var3 = .0513970804870914 : input[153] > 1e-35 ? var3 = .0032035784177419503 : var3 = .038713568639820416 : input[7] > .9527510849235538 ? var3 = .10975706910869304 : var3 = -.009433959232316078 : input[38] > 1e-35 ? var3 = .05195298239886214 : input[30] > 1e-35 ? var3 = .02476336300816124 : input[2] > 2.524928003624769 ? input[217] > 1e-35 ? var3 = .0135414448190362 : input[135] > 1e-35 ? var3 = -.14660288310803915 : var3 = -.07298980826531443 : input[135] > 1e-35 ? var3 = -.11136111748165503 : input[123] > 1e-35 ? var3 = -.1489448617480049 : input[46] > 1e-35 ? var3 = -.0922792773195811 : var3 = -.024587716086845016;
  let var4;
  input[0] > 1e-35 ? input[2] > 2.249904835165133 ? input[1] > 1e-35 ? input[2] > 3.540854293052788 ? input[3] > 2.249904835165133 ? var4 = .0590142410559562 : input[7] > .6376007852429183 ? var4 = .043799948513989724 : var4 = -4018626768373957e-20 : var4 = .0790082705503403 : input[38] > 1e-35 ? var4 = .06581244939148062 : input[30] > 1e-35 ? var4 = .04874874335011108 : var4 = -.03908081910821116 : input[3] > 2.602003343538398 ? input[1] > 1e-35 ? var4 = .0902076086329385 : input[30] > 1e-35 ? var4 = .10143876154366023 : var4 = .021304615514737626 : input[2] > 1.4978661367769956 ? var4 = .10248710197602005 : input[8] > 1e-35 ? input[125] > 1e-35 ? var4 = -.1652240484643952 : var4 = .09695355914385996 : var4 = .12574960258243387 : input[1] > 1e-35 ? input[2] > 3.8815106545092593 ? input[3] > 2.249904835165133 ? var4 = .030411053020370282 : input[7] > .8375851232899904 ? var4 = .01347947217941036 : var4 = -.02329004077119854 : input[7] > .9480659774309611 ? input[22] > 1e-35 ? var4 = -.021734552060979462 : input[100] > 1e-35 ? var4 = .12154672718218543 : input[3] > 1e-35 ? var4 = .0467045097539336 : var4 = .07133232987671506 : input[4] > 2.012675845367575 ? input[4] > 3.9219243190762363 ? var4 = .018631928508103857 : var4 = .04026129961424531 : var4 = -.0060403819170799225 : input[38] > 1e-35 ? var4 = .04740678443866351 : input[30] > 1e-35 ? var4 = .022411595432555845 : input[2] > 2.970085626360216 ? input[121] > 1e-35 ? var4 = .016385457091892035 : var4 = -.07115043890873148 : input[4] > 3.417592293073651 ? var4 = -.04057726754591634 : input[29] > 1e-35 ? var4 = -.10601923621749415 : var4 = -.013474385705240824;
  let var5;
  input[3] > 1e-35 ? input[3] > 3.481121732133104 ? input[30] > 1e-35 ? var5 = .03419190074885174 : input[39] > 1e-35 ? var5 = -.07596248521514803 : input[142] > 1e-35 ? var5 = -.09906305142951233 : input[143] > 1e-35 ? var5 = -.11544208927241095 : input[134] > 1e-35 ? var5 = .03231677158309109 : input[217] > 1e-35 ? var5 = .04584520241402839 : var5 = -.014587374070287719 : input[30] > 1e-35 ? input[141] > 1e-35 ? var5 = -.05022127515891476 : input[6] > 3.540854293052788 ? var5 = .046006786519929344 : input[3] > 2.3502401828962087 ? var5 = .03746852485580482 : var5 = .11887634683908754 : input[142] > 1e-35 ? var5 = -.0715680845257123 : input[134] > 1e-35 ? var5 = .05310603374316432 : input[39] > 1e-35 ? var5 = -.05301061369502469 : input[143] > 1e-35 ? var5 = -.06806923450459589 : input[21] > 1e-35 ? var5 = -.054617004299251364 : input[113] > 1e-35 ? input[6] > 3.795426061844291 ? var5 = .03901365322581413 : var5 = .11833310693969545 : input[141] > 1e-35 ? var5 = -.039041289505442084 : input[3] > 3.0677824455408698 ? var5 = .010823236602311471 : input[29] > 1e-35 ? var5 = -.062100944449970996 : input[58] > 1e-35 ? var5 = -.04585181543113668 : input[99] > 1e-35 ? var5 = .053796582993543764 : input[100] > 1e-35 ? input[6] > 3.676220550121792 ? var5 = .02800134029424525 : var5 = .12622387863644666 : input[98] > 1e-35 ? var5 = .06289940430905602 : var5 = .023655750883710656 : input[138] > 1e-35 ? var5 = .09902929683374195 : input[6] > 5.161920636569023 ? var5 = .07160940969782595 : input[141] > 1e-35 ? var5 = .11975693334861698 : var5 = .03480602671098732;
  let var6;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[1] > 1e-35 ? input[2] > 4.600145018061341 ? var6 = .02024868069387139 : input[2] > 3.1984648276080736 ? var6 = .048682024362267456 : var6 = .07158946327961134 : input[134] > 1e-35 ? var6 = .05360858064017479 : input[30] > 1e-35 ? var6 = .03969788038954029 : input[39] > 1e-35 ? var6 = -.1339275468398512 : var6 = -.03340699462411555 : input[1] > 1e-35 ? input[2] > 1.2424533248940002 ? var6 = .09338368602561321 : input[5] > 4.5379471377116305 ? var6 = .11818377094705468 : var6 = .02406138301472482 : input[30] > 1e-35 ? var6 = .08786833398626331 : var6 = .031294938606502315 : input[1] > 1e-35 ? input[2] > 2.970085626360216 ? input[29] > 1e-35 ? input[2] > 4.923617305492666 ? var6 = -.0247806554659429 : var6 = .00415615978158072 : input[4] > 2.138333059508028 ? input[4] > 3.6505739029280164 ? var6 = -.0025888569756007704 : var6 = .033556460788819964 : var6 = -.011238496891848667 : input[5] > 3.5694334999727624 ? input[4] > 2.012675845367575 ? input[2] > .8958797346140276 ? var6 = .03964701920383755 : var6 = .024902380380505313 : input[141] > 1e-35 ? var6 = -.07221122170573789 : var6 = .009221806859728395 : input[2] > .8958797346140276 ? var6 = .09633850035166669 : var6 = .007323280248710229 : input[134] > 1e-35 ? var6 = .038330704525669945 : input[30] > 1e-35 ? var6 = .01660549386778516 : input[2] > 2.524928003624769 ? input[217] > 1e-35 ? var6 = .008967266036665084 : input[29] > 1e-35 ? var6 = -.12693911437262784 : var6 = -.05779560753585583 : input[29] > 1e-35 ? var6 = -.0908743155940788 : input[4] > 3.314020688089767 ? var6 = -.030882471980034343 : var6 = -.010429019903489632;
  let var7;
  input[0] > 1e-35 ? input[2] > 2.138333059508028 ? input[1] > 1e-35 ? input[2] > 3.4498615536424366 ? input[3] > 2.249904835165133 ? var7 = .04956831432894648 : input[2] > 5.223051249395764 ? var7 = -.010305811579773205 : var7 = .027491320728082233 : var7 = .06656735137915168 : input[38] > 1e-35 ? var7 = .05309749470598965 : input[30] > 1e-35 ? var7 = .03843762763805799 : var7 = -.030980078724697425 : input[3] > 1e-35 ? input[1] > 1e-35 ? var7 = .08089335516186445 : var7 = .04120452858949669 : input[6] > 4.832297822126891 ? input[2] > .8958797346140276 ? var7 = .10006865536846919 : var7 = .11917243570572485 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var7 = .06704577104028654 : var7 = -.1454046740476985 : input[219] > 1e-35 ? var7 = -.13678871665753098 : var7 = .07859247859374968 : input[1] > 1e-35 ? input[2] > 3.314020688089767 ? input[3] > 2.249904835165133 ? var7 = .024623237775190106 : input[2] > 4.73179313355342 ? var7 = -.02080435685185878 : var7 = .0026175118278487855 : input[6] > 3.417592293073651 ? input[22] > 1e-35 ? var7 = -.025465692791530083 : input[45] > 1e-35 ? var7 = -.044807460105408044 : input[8] > 1e-35 ? var7 = .008766235663186964 : var7 = .032712521408248645 : input[3] > 2.602003343538398 ? var7 = -.0056332432294706036 : input[6] > 2.524928003624769 ? var7 = .09592889105245415 : var7 = -.013339150198983546 : input[38] > 1e-35 ? var7 = .03563564253379704 : input[30] > 1e-35 ? var7 = .014870517098142924 : input[2] > 2.970085626360216 ? var7 = -.054537994223319376 : input[219] > 1e-35 ? var7 = -.13242819761683536 : input[39] > 1e-35 ? var7 = -.0910629106840573 : var7 = -.01970485337755703;
  let var8;
  input[0] > 1e-35 ? input[2] > 2.012675845367575 ? input[1] > 1e-35 ? input[2] > 3.4498615536424366 ? input[7] > .9246495578512688 ? var8 = .04812308497880073 : input[29] > 1e-35 ? var8 = .0005380021336956461 : var8 = .03361690381564229 : input[5] > 3.5694334999727624 ? var8 = .05947219194425965 : var8 = .11024468105183681 : input[134] > 1e-35 ? var8 = .04905351957215242 : input[138] > 1e-35 ? var8 = .05554447267811877 : var8 = -.021863233324542066 : input[29] > 1e-35 ? input[5] > 4.855921334140645 ? input[2] > .8958797346140276 ? var8 = .09590438270550732 : var8 = .11498869480105023 : var8 = .04093609484315685 : var8 = .06588820186431316 : input[1] > 1e-35 ? input[2] > 2.970085626360216 ? input[29] > 1e-35 ? input[7] > .41763374498947375 ? var8 = .0043146758499583255 : var8 = -.03443798345003191 : input[58] > 1e-35 ? var8 = -.08355523706358281 : var8 = .017928058505534663 : input[5] > 3.5694334999727624 ? input[22] > 1e-35 ? var8 = -.02209335592785362 : input[2] > .8958797346140276 ? var8 = .03223396066919647 : var8 = .0170789547385017 : input[7] > .9546729796082215 ? input[2] > .8958797346140276 ? var8 = .09545837551902411 : var8 = .008923660539643153 : var8 = -.012322532316048181 : input[134] > 1e-35 ? var8 = .03182502017906531 : input[138] > 1e-35 ? input[29] > 1e-35 ? var8 = -.06617589040350445 : var8 = .040440282181288686 : input[2] > 2.802901033147999 ? var8 = -.043412758816960974 : input[219] > 1e-35 ? var8 = -.11700143817568372 : input[48] > 1e-35 ? var8 = -.11379636451926181 : input[49] > 1e-35 ? var8 = -.14202838670262277 : input[39] > 1e-35 ? var8 = -.08160450909782378 : var8 = -.013448620144296253;
  let var9;
  input[1] > 1e-35 ? input[2] > 2.602003343538398 ? input[3] > 2.249904835165133 ? input[4] > 3.6505739029280164 ? var9 = .004170792297448336 : var9 = .0368033867902024 : input[7] > .8333442551332461 ? input[2] > 4.677480030793064 ? var9 = .009136341105716223 : var9 = .03568813371096505 : input[7] > .22301866079069904 ? input[2] > 5.1209788959100075 ? var9 = -.02365589472388456 : var9 = .00919157417627931 : var9 = -.0379399276194825 : input[3] > 1e-35 ? input[5] > 3.5694334999727624 ? input[2] > .8958797346140276 ? input[22] > 1e-35 ? var9 = -.019258819649469603 : var9 = .03709105125649261 : var9 = .016860660630369267 : input[3] > 2.602003343538398 ? var9 = -.00991261350028801 : input[7] > .9626084674797213 ? var9 = .11517814309711256 : var9 = -.009719045525281071 : input[2] > 1.2424533248940002 ? input[7] > .7316379010844482 ? var9 = .07097600019370685 : var9 = .04586465946843457 : input[6] > 4.783307617946789 ? var9 = .09722756919612678 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var9 = -.11805054859481241 : var9 = .07110946491407406 : var9 = .05402719662002902 : input[134] > 1e-35 ? var9 = .03393227005537922 : input[30] > 1e-35 ? var9 = .023661319650909306 : input[2] > 2.970085626360216 ? input[121] > 1e-35 ? var9 = .031049210793405797 : input[135] > 1e-35 ? var9 = -.10837216222444626 : input[219] > 1e-35 ? var9 = -.14640457784236915 : var9 = -.03965818070110935 : input[121] > 1e-35 ? var9 = .039992710146502054 : input[143] > 1e-35 ? var9 = -.09311937611688731 : input[46] > 1e-35 ? var9 = -.07559392834101462 : input[219] > 1e-35 ? var9 = -.09895720087616466 : input[135] > 1e-35 ? var9 = -.07586062007425573 : var9 = -.011775153504486295;
  let var10;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[141] > 1e-35 ? var10 = -.03681630636575175 : input[22] > 1e-35 ? var10 = -.024594313135047084 : input[7] > .9626084674797213 ? input[6] > 3.676220550121792 ? var10 = .03355559026428929 : input[3] > 2.602003343538398 ? var10 = .012516956280523336 : var10 = .1113827943542528 : input[3] > 2.3502401828962087 ? input[39] > 1e-35 ? var10 = -.03483153469277968 : input[29] > 1e-35 ? var10 = -.06012725416594425 : var10 = .03180949281577552 : input[3] > 1.2424533248940002 ? var10 = .007572391854701212 : var10 = -.04833059473573461 : input[7] > .5866799179067689 ? input[138] > 1e-35 ? var10 = .084956566507563 : input[7] > .9407436463973539 ? input[6] > 5.161920636569023 ? var10 = .07174368742657447 : input[7] > .9793410316570949 ? var10 = .024186357466630726 : var10 = .07739671408330714 : var10 = .048429456456843774 : input[6] > 5.078289090109146 ? input[138] > 1e-35 ? var10 = .07555203090037793 : var10 = .033181836695182196 : var10 = -.02197298038836975 : input[38] > 1e-35 ? var10 = .031334580210504996 : input[30] > 1e-35 ? var10 = .021270582199851534 : input[121] > 1e-35 ? var10 = .0329970846397004 : input[42] > 1e-35 ? var10 = .04064092183581017 : input[135] > 1e-35 ? var10 = -.08440485061890712 : input[219] > 1e-35 ? var10 = -.10638369254266776 : input[143] > 1e-35 ? var10 = -.09755269717731242 : input[144] > 1e-35 ? var10 = -.1173397395002877 : input[51] > 1e-35 ? var10 = -.1288517354356988 : input[49] > 1e-35 ? var10 = -.13923283846721088 : input[91] > 1e-35 ? var10 = -.1224188861275682 : input[3] > 3.156774023138548 ? var10 = -.02477169567121223 : var10 = -.006917307470148426;
  let var11;
  input[2] > 2.802901033147999 ? input[7] > .9159108669154322 ? input[3] > 3.314020688089767 ? var11 = -.0010700017432373199 : input[2] > 4.832297822126891 ? var11 = .009582861728698568 : var11 = .029780100164495754 : input[30] > 1e-35 ? input[210] > 1e-35 ? var11 = -.028942339056712313 : var11 = .020599853201598167 : input[3] > 3.540854293052788 ? var11 = -.030156164189210577 : input[2] > 4.620046665062766 ? input[3] > 1.8688348091416842 ? var11 = -.00103151911027294 : input[217] > 1e-35 ? var11 = .005930672148987754 : var11 = -.03586108945255643 : var11 = .004417350848115493 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[5] > 3.5694334999727624 ? input[3] > 3.6242520361853052 ? input[30] > 1e-35 ? var11 = .02388317653477103 : var11 = -.0034021644637823034 : input[125] > 1e-35 ? var11 = -.059034648546006076 : input[18] > 1e-35 ? var11 = -.02514305472376584 : input[46] > 1e-35 ? var11 = -.05290744310611087 : input[21] > 1e-35 ? var11 = -.03750702516022783 : input[39] > 1e-35 ? var11 = -.031092446888446753 : var11 = .028272541588979773 : input[7] > .9676186228082213 ? input[3] > 2.602003343538398 ? var11 = -.009169247394016047 : var11 = .11347856526033356 : var11 = -.00310251177264949 : input[2] > 1e-35 ? var11 = .00844340216096322 : var11 = -.00894414829369423 : input[2] > 1.4978661367769956 ? input[7] > .6223082132708274 ? input[6] > 3.0677824455408698 ? var11 = .04885293193722139 : var11 = .10736598620828455 : var11 = .026545392586289893 : input[6] > 4.938058177869999 ? input[2] > .8958797346140276 ? var11 = .07355143458077283 : var11 = .09420954595651049 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var11 = .07966619891180966 : var11 = -.10471235843714122 : var11 = .04867207725748343;
  let var12;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[5] > 3.5694334999727624 ? input[3] > 2.249904835165133 ? input[22] > 1e-35 ? var12 = -.0262424908256809 : input[8] > 1e-35 ? var12 = .001637419319408071 : input[155] > 1e-35 ? var12 = .053444838794586114 : input[99] > 1e-35 ? var12 = .05039717103923269 : var12 = .02448689278350471 : input[141] > 1e-35 ? var12 = -.05723199469388615 : var12 = .005411562031545046 : input[7] > .9626084674797213 ? input[3] > 2.602003343538398 ? var12 = .00980665121101267 : var12 = .10420505846679201 : var12 = -.001639851950872336 : input[7] > .26911173821332884 ? input[138] > 1e-35 ? var12 = .07591724033622518 : input[7] > .9275861021112151 ? input[5] > 5.173316863805991 ? var12 = .06276466446882598 : input[194] > 1e-35 ? var12 = -.1330802382498368 : input[5] > 3.156774023138548 ? input[8] > 1e-35 ? var12 = -.027034262965141144 : var12 = .03949417085855365 : var12 = .08851962788853085 : input[9] > 1e-35 ? var12 = .05379608621573637 : var12 = .032253635727649325 : input[138] > 1e-35 ? var12 = .058048925881989615 : var12 = .005620237500451222 : input[134] > 1e-35 ? var12 = .02734220426041116 : input[30] > 1e-35 ? var12 = .017746745665275825 : input[142] > 1e-35 ? var12 = -.07814745820732061 : input[143] > 1e-35 ? var12 = -.08860968498533135 : input[14] > 1e-35 ? var12 = .01954819512523945 : input[42] > 1e-35 ? var12 = .03333354798081121 : input[147] > 1e-35 ? var12 = -.11642554317575503 : input[49] > 1e-35 ? var12 = -.12425086420883341 : input[146] > 1e-35 ? var12 = -.12996952774815626 : input[3] > 3.817651943129708 ? var12 = -.03275661606585881 : var12 = -.014860694091417102;
  let var13;
  input[1] > 1e-35 ? input[2] > 2.524928003624769 ? input[3] > 2.249904835165133 ? input[3] > 3.725620842493839 ? var13 = -.000906155627647317 : input[24] > 1e-35 ? var13 = .0785324151067157 : input[154] > 1e-35 ? var13 = -.058309500036909157 : var13 = .026762512119806844 : input[7] > .26911173821332884 ? input[2] > 4.505334588423558 ? var13 = -.010584135839537876 : var13 = .013982545022862853 : var13 = -.03208712711019827 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[5] > 3.5694334999727624 ? var13 = .026401003398891884 : input[3] > 2.602003343538398 ? var13 = -.008168418058515686 : input[7] > .9662372103242399 ? var13 = .10626422692131453 : var13 = -.01031637351522216 : var13 = .010358942714602982 : input[2] > 1.2424533248940002 ? input[2] > 2.012675845367575 ? var13 = .0312811686023135 : var13 = .05423507965224627 : input[6] > 4.832297822126891 ? var13 = .08479742987484738 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var13 = -.09338070882722671 : var13 = .058145805002919916 : var13 = .04227449937397909 : input[38] > 1e-35 ? var13 = .025289091019879376 : input[2] > 3.1132683346437333 ? input[3] > .8958797346140276 ? input[46] > 1e-35 ? var13 = -.09114331684757576 : input[135] > 1e-35 ? var13 = -.07948190608487016 : input[48] > 1e-35 ? var13 = -.12911151777601662 : input[143] > 1e-35 ? var13 = -.09735205976374478 : var13 = -.017192402584465798 : var13 = -.08661537827420282 : input[217] > 1e-35 ? var13 = .033425023239885124 : input[14] > 1e-35 ? var13 = .02729990952110066 : input[48] > 1e-35 ? var13 = -.09098188061865646 : input[46] > 1e-35 ? var13 = -.05848458618550134 : input[91] > 1e-35 ? var13 = -.10969774095556883 : var13 = -.0068971807474334365;
  let var14;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[3] > 1.2424533248940002 ? input[125] > 1e-35 ? var14 = -.06150017523108556 : input[39] > 1e-35 ? var14 = -.03350257370473994 : input[22] > 1e-35 ? var14 = -.02193617429266551 : input[8] > 1e-35 ? var14 = 7274245146620154e-20 : input[6] > 3.676220550121792 ? input[4] > 2.3502401828962087 ? var14 = .026702786904914785 : var14 = .00851181280021978 : input[4] > 2.673553765358735 ? var14 = .010358811529123666 : input[6] > 2.802901033147999 ? var14 = .08891517935366504 : var14 = .023114323891227237 : var14 = -.02875694375159779 : input[4] > 1.7005986908310777 ? input[138] > 1e-35 ? var14 = .06720372648635974 : input[6] > 5.427147823217923 ? input[9] > 1e-35 ? var14 = .0544777682515472 : var14 = .037060547607205986 : input[6] > 1e-35 ? var14 = .022016394753027843 : var14 = -.1559604133821172 : input[6] > 3.540854293052788 ? var14 = -.009372509268454739 : var14 = -.24388295956457617 : input[38] > 1e-35 ? var14 = .023012278764368795 : input[138] > 1e-35 ? var14 = .03564423186175008 : input[30] > 1e-35 ? var14 = .008093643695090883 : input[217] > 1e-35 ? var14 = .028810461962454004 : input[135] > 1e-35 ? var14 = -.07120877224354143 : input[46] > 1e-35 ? var14 = -.06546454537408128 : input[144] > 1e-35 ? var14 = -.09534262423492412 : input[143] > 1e-35 ? var14 = -.0770344566882831 : input[29] > 1e-35 ? var14 = -.06285371287531509 : input[14] > 1e-35 ? var14 = .02073120300153793 : input[123] > 1e-35 ? var14 = -.09016320513643451 : input[51] > 1e-35 ? var14 = -.10496442920973255 : input[3] > 3.1132683346437333 ? var14 = -.019949599427836494 : var14 = -.0019060085544902166;
  let var15;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 3.1984648276080736 ? input[1] > 1e-35 ? input[3] > 2.249904835165133 ? var15 = .03174009468268253 : input[2] > 5.363634090365639 ? var15 = -.019608371322822362 : var15 = .012560836552403976 : var15 = -.006925466014569184 : input[1] > 1e-35 ? var15 = .047796055675515446 : var15 = .014363935217773802 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var15 = .05193425865217324 : var15 = .07891754708034264 : var15 = .09859506024630252 : input[8] > 1e-35 ? input[5] > 4.424828703319957 ? var15 = .0288226384042998 : var15 = -.09397342098461306 : input[4] > .8958797346140276 ? var15 = .06181532763949055 : input[3] > 1e-35 ? var15 = .0661728888522049 : var15 = -.18938681666136592 : input[2] > 3.6242520361853052 ? input[30] > 1e-35 ? var15 = .005754128097002715 : input[4] > 1.7005986908310777 ? input[1] > 1e-35 ? input[3] > 1.8688348091416842 ? var15 = .003940381852503271 : var15 = -.01767544594631589 : input[134] > 1e-35 ? var15 = .005683243725945637 : var15 = -.033167818200618454 : var15 = -.049739953036904844 : input[1] > 1e-35 ? input[5] > 3.417592293073651 ? input[3] > 2.249904835165133 ? input[3] > 4.051747139190486 ? var15 = -.013281167238314323 : var15 = .016971087295600894 : var15 = -.0032296953806057044 : input[8] > 1e-35 ? input[3] > 1e-35 ? var15 = -.09772932329003692 : var15 = .10215199291158968 : input[3] > 1e-35 ? var15 = .04042124133857408 : input[4] > 1.7005986908310777 ? var15 = -.03780917296974188 : var15 = -.29617407728303585 : input[3] > 1.2424533248940002 ? input[134] > 1e-35 ? var15 = .019695468056761475 : var15 = -.008073287117671947 : var15 = -.07196945037292647;
  let var16;
  input[0] > 1e-35 ? input[3] > 1e-35 ? input[30] > 1e-35 ? var16 = .04565870990720628 : input[4] > 3.481121732133104 ? var16 = -.0010242035152053465 : input[46] > 1e-35 ? var16 = -.06735757101078846 : var16 = .028047085557873476 : input[4] > .8958797346140276 ? var16 = .061451212522936484 : var16 = -.008994471708946133 : input[4] > 3.8815106545092593 ? var16 = -.015862290359637304 : input[4] > 1.2424533248940002 ? input[156] > 1e-35 ? var16 = -.0353203284829365 : input[135] > 1e-35 ? var16 = -.029955239188290975 : input[153] > 1e-35 ? var16 = -.024262881593313065 : input[21] > 1e-35 ? var16 = -.04039396048201336 : input[155] > 1e-35 ? var16 = .031605649750965394 : input[46] > 1e-35 ? var16 = -.0412690351363074 : input[18] > 1e-35 ? var16 = -.02516534034859168 : input[51] > 1e-35 ? var16 = -.09383050740007202 : input[219] > 1e-35 ? input[30] > 1e-35 ? var16 = .05781620337941066 : var16 = -.031029108058883783 : input[54] > 1e-35 ? var16 = -.1312103962175427 : input[14] > 1e-35 ? var16 = .029309503966067275 : input[52] > 1e-35 ? var16 = -.12376041877584809 : input[49] > 1e-35 ? var16 = -.08405476403385437 : input[129] > 1e-35 ? var16 = -.07017699310303659 : input[3] > 3.238486181444842 ? var16 = .0005864979938663785 : input[90] > 1e-35 ? var16 = -.19027994988708324 : input[4] > 2.4414009612931857 ? var16 = .013036973814688194 : input[141] > 1e-35 ? var16 = -.05866284827055356 : input[196] > 1e-35 ? input[3] > 1.2424533248940002 ? input[3] > 1.4978661367769956 ? var16 = .021738540839636195 : var16 = .10410506831002041 : var16 = -.25590968590756463 : var16 = .0023982515170817725 : var16 = -.04143304307857132;
  let var17;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 3.417592293073651 ? input[2] > 5.335128436483344 ? var17 = -.011443269019739626 : input[1] > 1e-35 ? var17 = .015228192424880932 : var17 = -.005492858431736962 : input[1] > 1e-35 ? input[5] > 3.5694334999727624 ? var17 = .03605247912942737 : var17 = .08439131345296227 : var17 = .009650676995478455 : input[5] > 5.096808314315481 ? input[2] > .8958797346140276 ? input[29] > 1e-35 ? var17 = .07077360688836766 : var17 = .044754385330663386 : var17 = .09313294724999382 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var17 = .04214845406094496 : var17 = -.10283747682230321 : input[4] > .8958797346140276 ? var17 = .05232959789940822 : input[2] > .8958797346140276 ? var17 = .00730829946441921 : var17 = -.23825070451282065 : input[7] > .9358314658959646 ? input[5] > 3.417592293073651 ? input[8] > 1e-35 ? var17 = -.013117301012430346 : var17 = .010418379595902224 : input[19] > 1e-35 ? var17 = -.07514668047310291 : var17 = .05032486941219513 : input[29] > 1e-35 ? input[1] > 1e-35 ? input[7] > .14547530463198097 ? input[4] > 2.138333059508028 ? var17 = -.009576060406554683 : var17 = -.04582944318062007 : var17 = -.04685159067258116 : var17 = -.07022291581850879 : input[1] > 1e-35 ? input[4] > 2.3502401828962087 ? input[4] > 3.8815106545092593 ? var17 = -.008313873320272646 : input[140] > 1e-35 ? var17 = -.029352675967497712 : input[37] > 1e-35 ? var17 = -.09937923794037767 : var17 = .015967772276156707 : var17 = -.009857373135428817 : input[38] > 1e-35 ? var17 = .011345159604794278 : input[2] > 2.4414009612931857 ? input[30] > 1e-35 ? var17 = .001522017389940959 : var17 = -.026992183902105407 : var17 = -.006358778971076675;
  let var18;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 2.970085626360216 ? input[7] > .8649016459419877 ? var18 = .018617011644318126 : input[29] > 1e-35 ? input[2] > 4.832297822126891 ? var18 = -.03407648259949232 : var18 = -.0036502511604675977 : input[4] > 3.540854293052788 ? var18 = -.00934040898683245 : var18 = .010922739771398862 : input[7] > .9676186228082213 ? var18 = .05137169375874399 : var18 = .02682190004807807 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? var18 = .065076078729683 : input[8] > 1e-35 ? input[7] > .9750059495478345 ? input[7] > .996914501566243 ? var18 = .08915557171019604 : var18 = -.06286636147644172 : var18 = .0902247220475161 : input[4] > .8958797346140276 ? var18 = .09051085461905525 : input[9] > 1e-35 ? var18 = -.19701197524821418 : var18 = .005536577088671752 : input[30] > 1e-35 ? var18 = .0682573098268795 : var18 = .031380692115494484 : input[2] > 4.151008904875603 ? input[155] > 1e-35 ? var18 = .026867659395235544 : input[7] > .5866799179067689 ? var18 = -.008345671861059714 : var18 = -.02185200164340811 : input[7] > .9626084674797213 ? input[22] > 1e-35 ? var18 = -.024341883095402903 : input[141] > 1e-35 ? input[29] > 1e-35 ? var18 = .08888912525147288 : var18 = -.040584195806350004 : var18 = .014817521849450843 : input[4] > 1.7005986908310777 ? input[4] > 3.9219243190762363 ? var18 = -.01259238316205765 : input[156] > 1e-35 ? var18 = -.03305969547622109 : input[50] > 1e-35 ? var18 = -.10133912689920138 : input[155] > 1e-35 ? var18 = .025358210175047153 : input[55] > 1e-35 ? var18 = -.14645261489281414 : input[9] > 1e-35 ? var18 = .012035823488806215 : var18 = .0010743871783232305 : var18 = -.030440082321355873;
  let var19;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[7] > .30853255358841714 ? input[4] > .8958797346140276 ? input[138] > 1e-35 ? var19 = .0708169212387357 : input[7] > .9974623466432676 ? var19 = .06323909894881967 : var19 = .04463133906529934 : var19 = -.006876640569960593 : input[4] > 2.138333059508028 ? var19 = .02983313061920756 : var19 = -.012849740499321841 : input[138] > 1e-35 ? var19 = .05170725384597862 : input[134] > 1e-35 ? var19 = .03407970940934425 : input[32] > 1e-35 ? var19 = .04641257566344885 : input[217] > 1e-35 ? var19 = .04726549849359106 : input[152] > 1e-35 ? var19 = .04284855498215312 : var19 = -.018635981778740818 : input[7] > .9358314658959646 ? input[1] > 1e-35 ? var19 = .013495195381145214 : var19 = -.0017562536904350947 : input[153] > 1e-35 ? var19 = -.035450683955968364 : input[135] > 1e-35 ? var19 = -.033677490938511655 : input[1] > 1e-35 ? input[156] > 1e-35 ? var19 = -.03492338371344172 : input[4] > 2.012675845367575 ? input[8] > 1e-35 ? var19 = -.012478407554855247 : input[58] > 1e-35 ? var19 = -.06588308463544146 : var19 = .01024668455910621 : var19 = -.017964352445712636 : input[138] > 1e-35 ? var19 = .023509519134334668 : input[134] > 1e-35 ? var19 = .009985116251562821 : input[219] > 1e-35 ? var19 = -.08089904073615993 : input[144] > 1e-35 ? var19 = -.08668450969211726 : input[146] > 1e-35 ? var19 = -.11193950701534479 : input[91] > 1e-35 ? var19 = -.09510832561737878 : input[47] > 1e-35 ? var19 = -.06671901650698997 : input[145] > 1e-35 ? var19 = -.10185972302071798 : input[142] > 1e-35 ? var19 = -.050979038763275586 : var19 = -.008318124414257324;
  let var20;
  input[2] > 2.4414009612931857 ? input[7] > .5866799179067689 ? input[1] > 1e-35 ? input[2] > 5.059420419187638 ? var20 = -.004966114458456121 : input[3] > 1.4978661367769956 ? input[6] > 3.9219243190762363 ? var20 = .016160825033090097 : input[4] > 2.673553765358735 ? var20 = -.008119911797705546 : input[7] > .9676186228082213 ? var20 = .10191214482603793 : var20 = .010406721157764452 : input[4] > 2.602003343538398 ? var20 = .011963972867583182 : input[209] > 1e-35 ? input[24] > 1e-35 ? var20 = -.4633165603515741 : var20 = -.027241411195905924 : var20 = -.01021341522779383 : input[3] > .8958797346140276 ? input[39] > 1e-35 ? var20 = -.07106669495723826 : var20 = -.003949154414882924 : var20 = -.06434150131915288 : input[3] > 1.7005986908310777 ? input[1] > 1e-35 ? var20 = .005050893558647285 : var20 = -.01649483548684653 : input[217] > 1e-35 ? var20 = .0027009145619870485 : input[7] > .16413460456379095 ? var20 = -.021492035902356262 : var20 = -.04956173856083012 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[4] > 3.314020688089767 ? var20 = .004614615289098078 : input[125] > 1e-35 ? var20 = -.053838919278819175 : input[141] > 1e-35 ? var20 = -.031232660335016666 : input[7] > .9676186228082213 ? var20 = .031522536832188655 : var20 = .016369948821613637 : var20 = -.001970208279177045 : input[2] > 1.2424533248940002 ? input[7] > .8045995506441456 ? input[6] > 3.0677824455408698 ? var20 = .035653122678366796 : var20 = .09668798382116887 : var20 = .017192957672541906 : input[6] > 5.427147823217923 ? input[2] > .8958797346140276 ? var20 = .05167603828162103 : var20 = .07201242912898732 : input[4] > .8958797346140276 ? input[6] > 4.3882378946731615 ? var20 = .04079789432551034 : var20 = -.00477197753110532 : var20 = -.1330224689055222;
  let var21;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[6] > 5.519456907163478 ? input[3] > 1e-35 ? var21 = .025938224253040522 : input[7] > .9480659774309611 ? var21 = .06369970668749851 : var21 = .04567224211157202 : input[8] > 1e-35 ? var21 = -.03272937728465352 : input[7] > .8002228006195066 ? input[219] > 1e-35 ? var21 = -.06304921759586735 : var21 = .04293432033794005 : var21 = .0034607309539607385 : input[30] > 1e-35 ? var21 = .03333728636724803 : input[134] > 1e-35 ? var21 = .03171739664928598 : input[32] > 1e-35 ? var21 = .04247521237473512 : input[217] > 1e-35 ? var21 = .04515237436183519 : input[138] > 1e-35 ? var21 = .043674672816657406 : var21 = -.021495642896979555 : input[153] > 1e-35 ? input[7] > .7405695827634472 ? var21 = -.005353425538700483 : var21 = -.03818743916821677 : input[1] > 1e-35 ? input[156] > 1e-35 ? var21 = -.026937004040991603 : input[9] > 1e-35 ? var21 = .01687211330975012 : input[129] > 1e-35 ? var21 = -.06344334253531962 : input[5] > 3.276966702012906 ? input[3] > 2.4414009612931857 ? input[3] > 4.3882378946731615 ? var21 = -.029787052855333836 : input[140] > 1e-35 ? var21 = -.0315337765152156 : var21 = .01010125865272709 : var21 = -.003643087951301554 : input[3] > 1.8688348091416842 ? var21 = -.009293469974765106 : input[7] > .9407436463973539 ? input[19] > 1e-35 ? var21 = -.10837629052758145 : var21 = .08012552652666853 : var21 = -.03240188731353479 : input[3] > .8958797346140276 ? input[138] > 1e-35 ? var21 = .028089541906112948 : input[134] > 1e-35 ? var21 = .011775653029555359 : input[54] > 1e-35 ? var21 = -.1329256322319015 : var21 = -.010520589644656487 : var21 = -.058476715353390545;
  let var22;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 2.970085626360216 ? input[3] > 1.4978661367769956 ? input[1] > 1e-35 ? var22 = .015966021866473425 : var22 = -.004942501766182043 : input[7] > .7646034107159144 ? var22 = .0008922354520049755 : var22 = -.02377096637770522 : input[1] > 1e-35 ? var22 = .03185471115279236 : var22 = .009030463601278762 : input[6] > 5.033695261903033 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var22 = .03583918176912262 : var22 = .05978765203310842 : input[3] > 1.4978661367769956 ? var22 = .04363706154403441 : var22 = .08596238935719265 : input[8] > 1e-35 ? input[4] > 3.676220550121792 ? var22 = -.14139420543234502 : input[6] > 4.135134555718313 ? var22 = .06641653507737781 : var22 = -.08482961471233386 : input[219] > 1e-35 ? var22 = -.08432601495298837 : var22 = .036383288293587494 : input[2] > 4.212100162283537 ? input[4] > 4.06899022722607 ? var22 = -.027653216441781994 : input[4] > 1.2424533248940002 ? var22 = -.0074990353344818825 : var22 = -.047274115298751654 : input[3] > 4.350257124271638 ? var22 = -.021535524001034215 : input[7] > .9626084674797213 ? input[6] > 3.314020688089767 ? var22 = .008343192891130257 : input[3] > 2.602003343538398 ? var22 = -.029175290449111352 : input[19] > 1e-35 ? var22 = -.0982821612709299 : var22 = .07967468666491928 : input[3] > 2.012675845367575 ? input[1] > 1e-35 ? input[141] > 1e-35 ? var22 = -.050000478457880464 : input[99] > 1e-35 ? var22 = .03066844761711629 : var22 = .00757148708610041 : input[14] > 1e-35 ? var22 = .030325269400598688 : input[138] > 1e-35 ? var22 = .029925649226634522 : var22 = -.005865781126590595 : input[7] > .14547530463198097 ? var22 = -.006746433384005582 : var22 = -.03419211369300411;
  let var23;
  input[7] > .8453853180651066 ? input[9] > 1e-35 ? input[204] > 1e-35 ? input[5] > 3.979637980058199 ? var23 = .03492440471960614 : var23 = .10640952227810228 : var23 = .024674544399570984 : input[21] > 1e-35 ? var23 = -.03056548710005192 : input[24] > 1e-35 ? var23 = .04417102228084844 : input[18] > 1e-35 ? input[5] > 3.417592293073651 ? var23 = -.01915628728670732 : var23 = .08218968786016527 : input[22] > 1e-35 ? var23 = -.015022557207326592 : input[7] > .9941118339384912 ? var23 = .024199625103362956 : input[135] > 1e-35 ? var23 = -.01204089678887213 : input[5] > 3.156774023138548 ? input[14] > 1e-35 ? var23 = .03343354440638259 : input[144] > 1e-35 ? var23 = -.06832894943893354 : var23 = .0114980261254499 : input[12] > 1e-35 ? input[100] > 1e-35 ? var23 = .09915326976032354 : var23 = -.011405707270850872 : var23 = .05400113313957842 : input[138] > 1e-35 ? var23 = .029070115198082648 : input[7] > .11348809759407426 ? input[9] > 1e-35 ? var23 = .0124381999772114 : input[14] > 1e-35 ? var23 = .021548670539672424 : input[152] > 1e-35 ? var23 = .02386756199239544 : input[155] > 1e-35 ? var23 = .024879667358339554 : input[217] > 1e-35 ? var23 = .014495299809094343 : input[17] > 1e-35 ? var23 = .023665548251738264 : input[21] > 1e-35 ? var23 = -.04352613176288253 : input[142] > 1e-35 ? var23 = -.041479100066479035 : input[47] > 1e-35 ? var23 = -.054730987834988636 : input[135] > 1e-35 ? var23 = -.02041552814087628 : input[12] > 1e-35 ? var23 = .00599257601351913 : input[19] > 1e-35 ? var23 = .017289098956116435 : var23 = -.005346146967029123 : var23 = -.015035114021856248;
  let var24;
  input[2] > 2.524928003624769 ? input[39] > 1e-35 ? var24 = -.054727205204329936 : input[2] > 5.1209788959100075 ? input[3] > 1.7005986908310777 ? var24 = -.006846267565269392 : input[5] > 6.826002629905951 ? var24 = -.031164989612379426 : var24 = -.002741497453668024 : input[91] > 1e-35 ? var24 = -.09671408062751485 : input[4] > 1.4978661367769956 ? input[1] > 1e-35 ? input[3] > 2.249904835165133 ? var24 = .01457038163563883 : input[7] > .1998775237752378 ? var24 = .0022386178156093236 : var24 = -.023878153904868322 : input[138] > 1e-35 ? var24 = .02577301491883366 : input[134] > 1e-35 ? var24 = .012196636151923639 : var24 = -.011620066788940737 : var24 = -.02547345266933859 : input[3] > 1e-35 ? input[2] > 1e-35 ? input[1] > 1e-35 ? input[125] > 1e-35 ? var24 = -.054140900037670386 : input[5] > 3.5694334999727624 ? var24 = .011956526123643832 : input[3] > 2.602003343538398 ? var24 = -.02114925328017154 : input[7] > .9662372103242399 ? var24 = .08782010508103752 : var24 = -.017223208918198857 : input[138] > 1e-35 ? var24 = .03552967765214556 : input[134] > 1e-35 ? var24 = .02029988465200251 : var24 = -.0027071098830831453 : var24 = -.010563423003945922 : input[2] > 1.2424533248940002 ? input[1] > 1e-35 ? input[5] > 3.156774023138548 ? var24 = .020789754957971127 : input[8] > 1e-35 ? var24 = .09676607622337308 : var24 = -.13431522143386382 : var24 = -.04328684841078818 : input[6] > 5.427147823217923 ? input[2] > .8958797346140276 ? var24 = .04286558286931383 : var24 = .0632450248289209 : input[4] > .8958797346140276 ? input[8] > 1e-35 ? input[4] > 3.676220550121792 ? var24 = -.12134536828900527 : var24 = -.0021406313647826976 : var24 = .02703554321037796 : var24 = -.10987991092748431;
  let var25;
  input[3] > 3.238486181444842 ? input[30] > 1e-35 ? var25 = .009506310623811853 : input[39] > 1e-35 ? var25 = -.0390989997202559 : input[187] > 1e-35 ? var25 = -.07249802958837052 : input[46] > 1e-35 ? var25 = -.05080833699879983 : input[143] > 1e-35 ? var25 = -.06014247774751084 : input[219] > 1e-35 ? var25 = -.05179602905357869 : input[6] > 6.1537953943602615 ? input[15] > 1e-35 ? var25 = -.025022238573512268 : var25 = .0011147676050071987 : var25 = -.013840284878987585 : input[7] > .9626084674797213 ? input[5] > 3.417592293073651 ? input[3] > 1e-35 ? input[6] > 3.9219243190762363 ? var25 = .008593726678003006 : var25 = .05272960047875293 : input[5] > 4.424828703319957 ? var25 = .03164186747443643 : var25 = -.019512539098210834 : input[3] > 2.602003343538398 ? var25 = -.0016290671598964486 : input[3] > 1.2424533248940002 ? input[8] > 1e-35 ? var25 = -.1920669264002081 : var25 = .09024848315677546 : input[8] > 1e-35 ? var25 = .06434775905745808 : input[44] > 1e-35 ? var25 = .11389595321585716 : var25 = -.036695137521575945 : input[6] > 4.987019604243537 ? input[141] > 1e-35 ? var25 = -.03813401544172915 : input[138] > 1e-35 ? var25 = .029859363038130183 : input[58] > 1e-35 ? var25 = -.06135288076045784 : input[39] > 1e-35 ? var25 = -.04609789446034826 : input[7] > .14547530463198097 ? input[11] > 1e-35 ? var25 = .0007666746170242386 : input[129] > 1e-35 ? var25 = -.04984156530077896 : input[18] > 1e-35 ? var25 = -.01554744241744757 : input[10] > 1e-35 ? input[219] > 1e-35 ? var25 = -.043774129950223145 : var25 = .0062051346459236715 : var25 = .014331149613197688 : var25 = -.004868728135790881 : var25 = -.009310258638274059;
  let var26;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 3.817651943129708 ? input[3] > 1.8688348091416842 ? var26 = .0015603015891380355 : var26 = -.018128739944024166 : input[5] > 3.5694334999727624 ? input[6] > 5.427147823217923 ? var26 = .017445711714402918 : var26 = -.006013735620008879 : input[3] > 1.2424533248940002 ? var26 = .08568755276415789 : input[4] > 2.602003343538398 ? var26 = .03195371214541369 : input[6] > 2.970085626360216 ? var26 = -.3506562612672139 : var26 = -.038898555979475155 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? var26 = .04755052122467952 : input[3] > 1.4978661367769956 ? var26 = .03861414711908666 : var26 = .08185303441168128 : input[8] > 1e-35 ? input[5] > 4.424828703319957 ? var26 = .016473058697350277 : var26 = -.08025494910794358 : input[219] > 1e-35 ? var26 = -.06606152909975703 : var26 = .033955083083682974 : input[153] > 1e-35 ? var26 = -.022769519242142378 : input[155] > 1e-35 ? var26 = .021917770434351808 : input[3] > 4.051747139190486 ? var26 = -.016298405734735375 : input[4] > 1.2424533248940002 ? input[156] > 1e-35 ? var26 = -.023334559703496013 : input[91] > 1e-35 ? var26 = -.07354920004445119 : input[21] > 1e-35 ? var26 = -.03472005783841508 : input[9] > 1e-35 ? var26 = .0088614848397155 : input[152] > 1e-35 ? var26 = .01650058356046536 : input[50] > 1e-35 ? var26 = -.08689386936995537 : input[219] > 1e-35 ? var26 = -.025293957964644554 : input[22] > 1e-35 ? var26 = -.02911571993589908 : input[52] > 1e-35 ? var26 = -.10060771324188006 : input[151] > 1e-35 ? var26 = -.11187645020980451 : input[49] > 1e-35 ? var26 = -.07269389735370566 : var26 = .00010096962399904588 : var26 = -.0308050484468705;
  let var27;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 3.1132683346437333 ? input[2] > 5.589117819455554 ? var27 = -.01634394676179118 : input[135] > 1e-35 ? var27 = -.025978770194490092 : var27 = .003478202132522329 : input[5] > 3.772694874805912 ? input[6] > 5.55101783490842 ? var27 = .0201238113260563 : var27 = -.003889163967162744 : var27 = .0619995705843029 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? var27 = .04441301244720888 : var27 = .07580163057048642 : input[5] > 4.424828703319957 ? var27 = .030400021609279876 : input[135] > 1e-35 ? input[6] > 4.03420147928485 ? var27 = -.1614949959350695 : var27 = .011868201115510678 : input[144] > 1e-35 ? var27 = -.24480189212017833 : var27 = .00743113235503554 : input[135] > 1e-35 ? var27 = -.02500550080046047 : input[155] > 1e-35 ? var27 = .019914668189284807 : input[14] > 1e-35 ? var27 = .016272311078771865 : input[2] > 4.436734027666816 ? var27 = -.010942143677155697 : input[152] > 1e-35 ? var27 = .01655515192923104 : input[5] > 3.276966702012906 ? input[208] > 1e-35 ? var27 = .01544696196221499 : input[209] > 1e-35 ? var27 = .011686634595667988 : input[204] > 1e-35 ? var27 = .012948259428096241 : input[54] > 1e-35 ? var27 = -.0987840586310838 : input[17] > 1e-35 ? var27 = .019642065140602974 : input[9] > 1e-35 ? var27 = .002408217148588979 : input[129] > 1e-35 ? var27 = -.051760999013377655 : input[53] > 1e-35 ? var27 = -.12326801905337725 : input[156] > 1e-35 ? var27 = -.027148214121600067 : var27 = -.00591946140033722 : input[141] > 1e-35 ? var27 = .08076229481403298 : input[100] > 1e-35 ? var27 = .09029873540689846 : var27 = .004633440115146894;
  let var28;
  input[1] > 1e-35 ? input[4] > 2.138333059508028 ? input[9] > 1e-35 ? input[7] > .9738681190948303 ? input[4] > 2.249904835165133 ? var28 = .0335386338744903 : var28 = .08871810783567416 : var28 = .019225035967642936 : input[7] > .5866799179067689 ? input[44] > 1e-35 ? var28 = -.028577747938027556 : input[22] > 1e-35 ? var28 = -.017080349342057245 : input[123] > 1e-35 ? var28 = -.06459630434555787 : var28 = .01496396100048332 : input[7] > .04507521918085865 ? var28 = .0037545927605624665 : var28 = -.024364818555823085 : input[7] > .3301972011875425 ? input[4] > .8958797346140276 ? var28 = .003955118988355861 : var28 = -.024852972286710795 : input[210] > 1e-35 ? var28 = -.06918033561606161 : var28 = -.016436360434421187 : input[219] > 1e-35 ? var28 = -.07074619361594191 : input[14] > 1e-35 ? var28 = .02288621182895308 : input[30] > 1e-35 ? var28 = .009951065285890723 : input[4] > 3.0677824455408698 ? input[48] > 1e-35 ? var28 = -.08645289278185848 : input[18] > 1e-35 ? var28 = -.07128859518483391 : input[46] > 1e-35 ? var28 = -.059012415377229614 : input[51] > 1e-35 ? var28 = -.09897820075751956 : input[143] > 1e-35 ? var28 = -.0658809793369211 : input[39] > 1e-35 ? var28 = -.05072244120975425 : input[145] > 1e-35 ? var28 = -.1041573357946847 : input[21] > 1e-35 ? var28 = -.07265724033978356 : input[121] > 1e-35 ? var28 = .032340406020414894 : input[150] > 1e-35 ? var28 = -.12780465144045577 : input[50] > 1e-35 ? var28 = -.10084067045905792 : var28 = -.008282579596590931 : input[31] > 1e-35 ? var28 = .09475423612489574 : input[134] > 1e-35 ? var28 = .016436600209473996 : var28 = -.0032052350949025154;
  let var29;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[6] > 5.980149988077803 ? input[3] > 1e-35 ? var29 = .016868562767356994 : input[7] > .9480659774309611 ? var29 = .0490126593301439 : var29 = .03183712887814021 : input[4] > .8958797346140276 ? input[8] > 1e-35 ? var29 = -.018344689935240077 : input[7] > .5762123732244849 ? var29 = .027823839417468396 : var29 = .0022237549483396734 : var29 = -.049221463486990365 : input[30] > 1e-35 ? var29 = .024881540664409785 : input[4] > 3.0677824455408698 ? var29 = -.012956173562801246 : var29 = .010844244442972509 : input[153] > 1e-35 ? var29 = -.021011529883710918 : input[135] > 1e-35 ? var29 = -.022862755771243214 : input[91] > 1e-35 ? var29 = -.06523564179230792 : input[3] > 4.3372693810700085 ? var29 = -.01836396186345982 : input[4] > 1.2424533248940002 ? input[14] > 1e-35 ? var29 = .018063557788938384 : input[1] > 1e-35 ? input[58] > 1e-35 ? var29 = -.05666864992513037 : input[37] > 1e-35 ? var29 = -.09859173931566362 : input[140] > 1e-35 ? var29 = -.026368697925604742 : input[139] > 1e-35 ? var29 = -.06458698835998881 : input[3] > 2.4414009612931857 ? input[8] > 1e-35 ? var29 = -.012750470980894203 : input[128] > 1e-35 ? var29 = -.06062526587440112 : var29 = .011637315217958607 : input[7] > .9569480028661056 ? input[6] > 3.314020688089767 ? input[6] > 8.256477558772088 ? var29 = -.01867324944649552 : var29 = .013333709765106694 : input[19] > 1e-35 ? var29 = -.0862336521704207 : var29 = .06263843669460754 : var29 = -.005209374987876728 : input[29] > 1e-35 ? var29 = -.05314556259108334 : input[144] > 1e-35 ? var29 = -.06747511467043471 : var29 = -.0032459743896180644 : var29 = -.025647852465095045;
  let var30;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.802901033147999 ? input[153] > 1e-35 ? var30 = -.028446025186518367 : input[135] > 1e-35 ? var30 = -.030498458478750823 : input[4] > 1.4978661367769956 ? var30 = .0028332406263713176 : var30 = -.029966327008991617 : var30 = .018714561890725637 : input[6] > 5.033695261903033 ? input[2] > .8958797346140276 ? var30 = .041738631496127304 : var30 = .0701395739744944 : input[7] > .9811887196001154 ? input[28] > 1e-35 ? input[194] > 1e-35 ? var30 = -.6270617037879163 : var30 = -.14198370205598315 : var30 = -.008029082191082339 : var30 = .03966126215239892 : input[153] > 1e-35 ? var30 = -.018792731305353614 : input[135] > 1e-35 ? var30 = -.020500053366640306 : input[156] > 1e-35 ? input[11] > 1e-35 ? var30 = -.05063175110475535 : var30 = -.0120172710473678 : input[147] > 1e-35 ? var30 = -.06181360325166399 : input[7] > .06275229375044648 ? input[52] > 1e-35 ? var30 = -.09381845963236321 : input[4] > 4.424828703319957 ? var30 = -.015836182358134197 : input[4] > 1.2424533248940002 ? input[48] > 1e-35 ? var30 = -.047387335727107405 : input[50] > 1e-35 ? var30 = -.07061356901704502 : input[151] > 1e-35 ? var30 = -.09680213548388712 : input[46] > 1e-35 ? var30 = -.028970851669790916 : input[123] > 1e-35 ? var30 = -.035197840867969954 : input[49] > 1e-35 ? var30 = -.06299268464836878 : input[149] > 1e-35 ? var30 = -.10197175263174806 : input[58] > 1e-35 ? var30 = -.03908263666673043 : input[22] > 1e-35 ? var30 = -.021903737116021876 : input[2] > .8958797346140276 ? var30 = .005307704388235018 : var30 = -.0020984759645931708 : var30 = -.021935509998616008 : var30 = -.01887705116018838;
  let var31;
  input[2] > 2.4414009612931857 ? input[2] > 4.749261159734808 ? input[219] > 1e-35 ? var31 = -.0427111578574511 : input[153] > 1e-35 ? var31 = -.030189831687705213 : input[135] > 1e-35 ? var31 = -.03512251542671204 : var31 = -.005813108237155817 : input[39] > 1e-35 ? var31 = -.03612853474204475 : input[91] > 1e-35 ? var31 = -.07347487395456895 : input[142] > 1e-35 ? var31 = -.04314124434818331 : input[21] > 1e-35 ? var31 = -.03933135423264962 : input[29] > 1e-35 ? input[6] > 4.3882378946731615 ? input[1] > 1e-35 ? var31 = -.0015250307417007892 : var31 = -.0490054084929899 : input[209] > 1e-35 ? var31 = -.19107169934362123 : var31 = -.032434842765588306 : input[18] > 1e-35 ? var31 = -.04413318629193353 : input[5] > 3.772694874805912 ? var31 = .004026864766696988 : input[7] > .9705672697050661 ? input[4] > 2.602003343538398 ? var31 = -.0184663870129198 : var31 = .08888448773905216 : var31 = -.0040785146358560806 : input[29] > 1e-35 ? input[2] > 1.2424533248940002 ? input[1] > 1e-35 ? input[5] > 3.156774023138548 ? var31 = .012676257607559291 : input[4] > 2.012675845367575 ? var31 = .07794141958502514 : var31 = -.23905004122480836 : var31 = -.03904279404529968 : input[6] > 5.818597045157784 ? input[1] > 1e-35 ? var31 = .04439337662833094 : var31 = -.009601154125838422 : input[28] > 1e-35 ? input[7] > .9926276364955392 ? input[156] > 1e-35 ? var31 = .08495906118788314 : input[153] > 1e-35 ? var31 = .09808912606252018 : var31 = -.41470362752984724 : var31 = .024659633328041372 : input[6] > 4.3882378946731615 ? var31 = .02348696158531392 : var31 = -.011219631635525798 : input[2] > .8958797346140276 ? var31 = .00764827947682953 : var31 = -.002636723662133651;
  let var32;
  input[0] > 1e-35 ? input[138] > 1e-35 ? var32 = .04040206743401164 : input[7] > .47159631571429605 ? input[39] > 1e-35 ? var32 = -.04204265697956852 : input[18] > 1e-35 ? var32 = -.02345608311313191 : input[46] > 1e-35 ? var32 = -.07250113205332377 : input[47] > 1e-35 ? var32 = -.06901706560471924 : input[123] > 1e-35 ? var32 = -.02471508138476658 : input[91] > 1e-35 ? var32 = -.08527667683257537 : input[6] > 5.519456907163478 ? input[7] > .9811887196001154 ? var32 = .033642311398086024 : var32 = .019968221974742344 : input[6] > 3.540854293052788 ? input[28] > 1e-35 ? input[7] > .9914949911911836 ? var32 = -.17171139407761582 : var32 = .033182911468765224 : var32 = .0060896749985828915 : input[7] > .9626084674797213 ? var32 = .050178751374534494 : var32 = -.008697473314227091 : input[6] > 5.957131031247307 ? var32 = .008840008772752947 : var32 = -.00839587224544437 : input[57] > 1e-35 ? var32 = -.11000065936717814 : input[187] > 1e-35 ? var32 = -.039919217528968265 : input[135] > 1e-35 ? var32 = -.01777859479698383 : input[7] > .841541958453746 ? input[6] > 8.681774988134558 ? var32 = -.006645633391127337 : var32 = .005363553180866138 : input[7] > .06275229375044648 ? input[141] > 1e-35 ? var32 = -.028575934798358252 : input[147] > 1e-35 ? var32 = -.06523418671938815 : input[53] > 1e-35 ? var32 = -.12439699935111644 : input[47] > 1e-35 ? var32 = -.04201034294282216 : input[21] > 1e-35 ? var32 = -.029998534764449716 : input[11] > 1e-35 ? var32 = -.008349262144218515 : input[10] > 1e-35 ? input[152] > 1e-35 ? var32 = .03211843381827455 : var32 = -.009616753935387912 : var32 = .001507728277179471 : var32 = -.018453367252451447;
  let var33;
  input[2] > 2.4414009612931857 ? input[155] > 1e-35 ? var33 = .02097415247337288 : input[2] > 5.1209788959100075 ? input[219] > 1e-35 ? var33 = -.04107586321461544 : input[153] > 1e-35 ? var33 = -.030708779452328257 : var33 = -.008547089256234949 : input[24] > 1e-35 ? input[113] > 1e-35 ? var33 = .10372474211849725 : var33 = .010871474495452506 : input[46] > 1e-35 ? var33 = -.048875079231930615 : input[152] > 1e-35 ? var33 = .0169028183837229 : input[91] > 1e-35 ? var33 = -.06545106192484919 : input[7] > .5395500104437768 ? input[21] > 1e-35 ? var33 = -.03634133884877529 : input[123] > 1e-35 ? var33 = -.04524486315275367 : var33 = .0007726000210664368 : input[153] > 1e-35 ? var33 = -.026631444280113794 : var33 = -.005897540198114922 : input[29] > 1e-35 ? input[2] > 1.2424533248940002 ? input[141] > 1e-35 ? var33 = .06938494238244022 : input[1] > 1e-35 ? input[4] > 2.602003343538398 ? input[7] > .21160651352969054 ? var33 = .016731168841731828 : var33 = -.009280453313693341 : var33 = -.006549806005743951 : var33 = -.035447929694275064 : input[8] > 1e-35 ? var33 = -.0032912467465369953 : input[4] > 1.2424533248940002 ? input[1] > 1e-35 ? input[2] > .8958797346140276 ? var33 = .024369266212637037 : input[138] > 1e-35 ? var33 = .06205121318768558 : var33 = .03811769435016647 : var33 = -.009452348851889555 : var33 = -.025248141993897872 : input[2] > 1e-35 ? input[57] > 1e-35 ? var33 = -.12191990737301042 : input[4] > 3.3842466058243152 ? var33 = .00020591213976092076 : input[141] > 1e-35 ? var33 = -.03252260939244301 : input[186] > 1e-35 ? var33 = -.13818838492678748 : var33 = .009368844137034227 : var33 = -.007973426105216213;
  let var34;
  input[2] > 2.3502401828962087 ? input[14] > 1e-35 ? var34 = .015015656987761437 : input[30] > 1e-35 ? input[210] > 1e-35 ? input[7] > .6876768869498817 ? var34 = .00543900892248828 : var34 = -.04253496769494065 : input[141] > 1e-35 ? var34 = -.052958350924390156 : input[140] > 1e-35 ? var34 = -.10364099832282586 : var34 = .010452960405207413 : input[24] > 1e-35 ? input[113] > 1e-35 ? var34 = .09898709072741292 : input[209] > 1e-35 ? input[7] > .9821472231924556 ? var34 = -.26615665549082984 : var34 = .09636256138859388 : var34 = .01708542025496261 : input[217] > 1e-35 ? var34 = .008049408683788317 : input[21] > 1e-35 ? var34 = -.04590265539954756 : input[90] > 1e-35 ? var34 = -.13784770816769107 : input[142] > 1e-35 ? var34 = -.04628126597884301 : input[47] > 1e-35 ? var34 = -.05827975565933709 : input[135] > 1e-35 ? var34 = -.0223224900840969 : input[18] > 1e-35 ? var34 = -.03220713396184497 : input[91] > 1e-35 ? var34 = -.06447405488640102 : input[58] > 1e-35 ? var34 = -.05284544446869763 : input[48] > 1e-35 ? var34 = -.06649148594881385 : input[123] > 1e-35 ? var34 = -.04383701454842744 : input[7] > .07815070294696584 ? input[52] > 1e-35 ? var34 = -.11846610284210293 : input[50] > 1e-35 ? var34 = -.08907531725085399 : input[156] > 1e-35 ? var34 = -.018270336483319834 : input[150] > 1e-35 ? var34 = -.1090721461891663 : input[151] > 1e-35 ? var34 = -.12157322199183473 : var34 = -.001565820654257863 : var34 = -.02380240397829804 : input[7] > .7957410883753849 ? var34 = .01267070049428537 : input[9] > 1e-35 ? var34 = .012970301396505988 : var34 = .0031136826722851885;
  let var35;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 3.817651943129708 ? input[29] > 1e-35 ? var35 = -.01811927921170173 : var35 = -.0007182192063435364 : input[30] > 1e-35 ? var35 = .024303187146750442 : input[1] > 1e-35 ? var35 = .011106265465270054 : input[134] > 1e-35 ? var35 = .029835980521591587 : var35 = -.011058553872914158 : input[29] > 1e-35 ? input[4] > .8958797346140276 ? input[2] > .8958797346140276 ? var35 = .038081831260496 : input[7] > .9761943980359399 ? input[7] > .9974623466432676 ? var35 = .0678338591810893 : var35 = .02371719224774027 : var35 = .0682898584583309 : var35 = -.023148464063014726 : input[30] > 1e-35 ? var35 = .04610988679672867 : var35 = .003060113702583105 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[4] > 2.4414009612931857 ? input[7] > .9587163092581167 ? var35 = .01081564552001606 : var35 = -.006807357600587744 : var35 = -.02409609521595022 : var35 = -.033329165496176885 : input[4] > 4.051747139190486 ? var35 = -.01130115168237245 : input[129] > 1e-35 ? var35 = -.04589370141507604 : input[21] > 1e-35 ? var35 = -.029442074982620643 : input[14] > 1e-35 ? var35 = .016895124578179443 : input[186] > 1e-35 ? var35 = -.11907557430036886 : input[1] > 1e-35 ? input[139] > 1e-35 ? var35 = -.06194447560538838 : input[133] > 1e-35 ? var35 = -.0758465323292204 : input[58] > 1e-35 ? var35 = -.04330766372695393 : input[138] > 1e-35 ? var35 = -.04155491116231014 : input[156] > 1e-35 ? var35 = -.04841608169206507 : input[44] > 1e-35 ? var35 = -.01948221703985556 : var35 = .006580878599054945 : input[217] > 1e-35 ? var35 = .022433802380447482 : var35 = -.00412091757515532;
  let var36;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.970085626360216 ? input[153] > 1e-35 ? var36 = -.024502725801264887 : input[2] > 5.589117819455554 ? var36 = -.01230190569981064 : var36 = .0013078979950003464 : input[1] > 1e-35 ? var36 = .016172143068823742 : var36 = .0006345060509537773 : input[2] > .8958797346140276 ? var36 = .030005982109869073 : input[7] > .9811887196001154 ? input[7] > .9983480540068196 ? var36 = .0671951915420627 : input[4] > .8958797346140276 ? input[204] > 1e-35 ? input[4] > 2.4414009612931857 ? var36 = .044068636573383585 : var36 = -.6634026033584294 : input[28] > 1e-35 ? input[194] > 1e-35 ? var36 = -.3139210817530322 : var36 = -.030502668897116853 : var36 = .02841326513237545 : var36 = -.12080826254458728 : var36 = .05983169094937563 : input[25] > 1e-35 ? var36 = -.03468266531519899 : input[17] > 1e-35 ? var36 = .018557285805987474 : input[91] > 1e-35 ? var36 = -.051420462987159146 : input[153] > 1e-35 ? input[24] > 1e-35 ? var36 = .04301006671297924 : input[57] > 1e-35 ? var36 = -.09748386515224282 : input[7] > .43956365248689394 ? var36 = -.00756781004151352 : var36 = -.03008603678955382 : input[40] > 1e-35 ? var36 = -.06712212199178254 : input[9] > 1e-35 ? input[99] > 1e-35 ? var36 = .02709638137622776 : var36 = .00311232737924217 : input[219] > 1e-35 ? var36 = -.021650545703290135 : input[129] > 1e-35 ? var36 = -.04139534817677377 : input[4] > 4.482986592105174 ? var36 = -.01666373169408667 : input[7] > .14547530463198097 ? input[28] > 1e-35 ? var36 = .0203181446326991 : input[24] > 1e-35 ? var36 = .019321702534414745 : var36 = -.0013149142637674523 : var36 = -.010572437649803333;
  let var37;
  input[1] > 1e-35 ? input[99] > 1e-35 ? var37 = .024922390516579074 : input[7] > .6223082132708274 ? input[5] > 8.674624195715621 ? var37 = -.0013697481432616754 : input[8] > 1e-35 ? input[5] > 3.0201273556387074 ? input[5] > 4.855921334140645 ? var37 = -.0034268395365245545 : var37 = -.034186463672076346 : input[29] > 1e-35 ? var37 = .07759914281958613 : var37 = -.07773573805144608 : input[22] > 1e-35 ? var37 = -.0175879419801366 : input[7] > .9626084674797213 ? var37 = .016773359142537643 : var37 = .008028381804196754 : input[133] > 1e-35 ? var37 = -.0535216100744091 : var37 = -.0005000628423357899 : input[38] > 1e-35 ? input[14] > 1e-35 ? var37 = .05090247458630403 : var37 = .007750826606170666 : input[30] > 1e-35 ? var37 = .007698939719746262 : input[121] > 1e-35 ? var37 = .02303487268261317 : input[56] > 1e-35 ? var37 = .04301822779572479 : input[219] > 1e-35 ? var37 = -.061056125991793546 : input[49] > 1e-35 ? var37 = -.08519783826666813 : input[54] > 1e-35 ? var37 = -.11098408863832084 : input[51] > 1e-35 ? var37 = -.07495147940928196 : input[52] > 1e-35 ? var37 = -.10268521021357209 : input[143] > 1e-35 ? var37 = -.050337621945760906 : input[50] > 1e-35 ? var37 = -.08215637358309871 : input[135] > 1e-35 ? var37 = -.037923453156281546 : input[29] > 1e-35 ? var37 = -.03275476659364492 : input[118] > 1e-35 ? var37 = -.05655325181162936 : input[46] > 1e-35 ? var37 = -.03579874818682071 : input[55] > 1e-35 ? var37 = -.10858775815345066 : input[98] > 1e-35 ? var37 = -.02949179817285505 : input[91] > 1e-35 ? var37 = -.06114394873657414 : var37 = -.0024381269826722327;
  let var38;
  input[0] > 1e-35 ? input[138] > 1e-35 ? var38 = .03188433658945665 : input[6] > 5.957131031247307 ? input[29] > 1e-35 ? var38 = .02161439640262312 : input[46] > 1e-35 ? var38 = -.05856082884648366 : var38 = .00579188508436574 : input[5] > 3.417592293073651 ? var38 = -.0023781291067078423 : input[6] > 2.524928003624769 ? input[29] > 1e-35 ? var38 = -.009165058612451055 : var38 = .06060298049441096 : var38 = -.024654633200924148 : input[29] > 1e-35 ? input[141] > 1e-35 ? var38 = .047057536167451744 : input[5] > 7.751690325550034 ? var38 = -.014630738159823437 : input[6] > 1e-35 ? var38 = -.0022830386545257364 : var38 = -.1244934159203967 : input[141] > 1e-35 ? var38 = -.03108265181870111 : input[151] > 1e-35 ? var38 = -.0899976208431091 : input[53] > 1e-35 ? var38 = -.10125439914522794 : input[57] > 1e-35 ? var38 = -.08285049636367613 : input[48] > 1e-35 ? var38 = -.04071723813859757 : input[147] > 1e-35 ? var38 = -.05043191744833317 : input[49] > 1e-35 ? var38 = -.05480244282058292 : input[52] > 1e-35 ? var38 = -.07341553831872409 : input[91] > 1e-35 ? var38 = -.04164336745260387 : input[50] > 1e-35 ? var38 = -.05943962674275153 : input[40] > 1e-35 ? var38 = -.054773037913883875 : input[129] > 1e-35 ? var38 = -.03640370706396673 : input[54] > 1e-35 ? var38 = -.07483146938849299 : input[22] > 1e-35 ? var38 = -.02027834075472462 : input[186] > 1e-35 ? var38 = -.08116240011202293 : input[143] > 1e-35 ? var38 = -.028437692949603324 : input[21] > 1e-35 ? var38 = -.02421670339700474 : input[46] > 1e-35 ? var38 = -.02303808594532841 : var38 = .0030552215125396933;
  let var39;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[4] > 2.138333059508028 ? input[9] > 1e-35 ? var39 = .02933727780739186 : input[6] > 4.722943345003718 ? input[7] > .9246495578512688 ? var39 = .024680404379144982 : var39 = .012015730636539185 : input[113] > 1e-35 ? var39 = .09112392780348796 : input[135] > 1e-35 ? input[7] > .990877425524446 ? var39 = -.11617284449593282 : var39 = -.005246041787488675 : var39 = -.011069319481086321 : input[90] > 1e-35 ? var39 = -.2763006993902732 : input[7] > .9546729796082215 ? input[6] > 3.0677824455408698 ? var39 = .009233858920042097 : var39 = .08920751503262825 : var39 = -.008824102277148265 : input[138] > 1e-35 ? var39 = .02736126919460762 : input[4] > 2.917405368531303 ? input[30] > 1e-35 ? var39 = .013112272135200274 : input[217] > 1e-35 ? var39 = .035799930603658235 : var39 = -.015618218537266096 : var39 = .010656981322113845 : input[14] > 1e-35 ? var39 = .01147191978691208 : input[17] > 1e-35 ? var39 = .016681596753170068 : input[135] > 1e-35 ? var39 = -.017396147137824756 : input[4] > 1.8688348091416842 ? input[4] > 4.03420147928485 ? var39 = -.008863534867945834 : input[31] > 1e-35 ? var39 = .05416038384474034 : input[113] > 1e-35 ? var39 = .012656827040897288 : input[204] > 1e-35 ? var39 = .011410879858785482 : input[208] > 1e-35 ? input[1] > 1e-35 ? var39 = .02085606775425661 : var39 = -.008618410086291444 : input[53] > 1e-35 ? var39 = -.09674487817291225 : input[155] > 1e-35 ? var39 = .010841012663281826 : var39 = -.0027234799964982103 : input[100] > 1e-35 ? input[6] > 4.226807104886684 ? var39 = -.02684998739505702 : var39 = .09196076999373319 : var39 = -.014557367931257406;
  let var40;
  input[1] > 1e-35 ? input[4] > 2.4414009612931857 ? input[140] > 1e-35 ? var40 = -.020508725755139606 : input[9] > 1e-35 ? var40 = .014160204295049248 : input[37] > 1e-35 ? var40 = -.06190233326923697 : input[6] > 1e-35 ? var40 = .005164496028342236 : var40 = -.11389189550910446 : input[141] > 1e-35 ? var40 = -.04125881484049697 : input[186] > 1e-35 ? var40 = -.17160163910476212 : input[29] > 1e-35 ? input[6] > 3.676220550121792 ? var40 = -.010283419868136159 : input[7] > .9626084674797213 ? var40 = -.1716178372310524 : var40 = -.008856137283327148 : input[28] > 1e-35 ? var40 = .05315666786902214 : input[129] > 1e-35 ? var40 = -.04136913767615559 : input[7] > .9705672697050661 ? input[6] > 3.540854293052788 ? var40 = .00751812285476753 : input[8] > 1e-35 ? var40 = -.11960098941111366 : var40 = .06631760098044483 : input[210] > 1e-35 ? input[30] > 1e-35 ? var40 = -.05338190010412709 : var40 = .017275201286894953 : input[30] > 1e-35 ? var40 = .014424216946760394 : input[99] > 1e-35 ? var40 = .027062693955934525 : var40 = -.006762492910108134 : input[219] > 1e-35 ? var40 = -.0534489198792768 : input[138] > 1e-35 ? var40 = .017328465617667224 : input[4] > 2.970085626360216 ? input[144] > 1e-35 ? var40 = -.0662951231725991 : input[143] > 1e-35 ? var40 = -.04739088646917139 : input[145] > 1e-35 ? var40 = -.07635546796992515 : input[14] > 1e-35 ? var40 = .012433708195861912 : input[217] > 1e-35 ? var40 = .021046036228368578 : input[51] > 1e-35 ? var40 = -.07024391932712475 : var40 = -.007585229386863768 : input[127] > 1e-35 ? var40 = .0788172427657374 : var40 = .0036475442240054556;
  let var41;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.802901033147999 ? input[153] > 1e-35 ? var41 = -.02488671343402725 : input[135] > 1e-35 ? var41 = -.026342401137212534 : input[4] > 1.4978661367769956 ? var41 = -.0002120610158998857 : var41 = -.02619014803287452 : input[5] > 3.772694874805912 ? var41 = .00791871819482647 : var41 = .05245006986819034 : input[5] > 5.431533816254341 ? input[2] > .8958797346140276 ? var41 = .026755493155023333 : var41 = .05657996196424821 : input[5] > 4.424828703319957 ? input[28] > 1e-35 ? var41 = -.12833948112036647 : var41 = .02009706276124955 : input[135] > 1e-35 ? var41 = -.1062651205805238 : var41 = -.014392542658357654 : input[156] > 1e-35 ? input[11] > 1e-35 ? var41 = -.0426876288098691 : var41 = -.009210886749467585 : input[25] > 1e-35 ? var41 = -.029685120249418873 : input[153] > 1e-35 ? input[24] > 1e-35 ? var41 = .039675921298659045 : var41 = -.01470247025894634 : input[135] > 1e-35 ? var41 = -.013162475027411236 : input[2] > 1e-35 ? input[22] > 1e-35 ? var41 = -.01924589513592333 : input[21] > 1e-35 ? var41 = -.02301719200164619 : input[5] > 8.75754777636908 ? input[4] > 2.602003343538398 ? var41 = -.0007468484638490539 : var41 = -.0158247553028744 : input[1] > 1e-35 ? input[99] > 1e-35 ? var41 = .024493682002973784 : input[42] > 1e-35 ? var41 = -.07469088345156226 : input[45] > 1e-35 ? var41 = -.03838380763638677 : input[114] > 1e-35 ? var41 = .02409327545276692 : input[154] > 1e-35 ? var41 = -.038977286951036944 : input[208] > 1e-35 ? var41 = .021915882358345885 : var41 = .003839964304606302 : var41 = -.0014382346596150915 : var41 = -.008713493537728363;
  let var42;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 4.119004124609202 ? input[3] > 1.2424533248940002 ? var42 = -.0017308950709495397 : var42 = -.020269742816377157 : input[5] > 3.5694334999727624 ? input[6] > 6.468474521450064 ? var42 = .007854184286630537 : var42 = -.005163758444496073 : input[3] > 1.2424533248940002 ? input[12] > 1e-35 ? var42 = -.009039854020477722 : var42 = .08762320620103459 : input[194] > 1e-35 ? var42 = -.3433922378591172 : input[24] > 1e-35 ? var42 = -.2523113760729937 : var42 = -.000461371156912453 : input[5] > 5.692045796563381 ? input[3] > 1.4978661367769956 ? var42 = .007177758561499448 : input[2] > .8958797346140276 ? var42 = .03195343200682438 : var42 = .059909349900388334 : input[5] > 4.424828703319957 ? input[28] > 1e-35 ? var42 = -.10695282804536732 : var42 = .019125081292682575 : input[135] > 1e-35 ? var42 = -.09257011968677195 : var42 = -.012855523323410875 : input[14] > 1e-35 ? var42 = .010052176448775013 : input[152] > 1e-35 ? var42 = .011482760058014926 : input[156] > 1e-35 ? var42 = -.017677609761538152 : input[24] > 1e-35 ? var42 = .01670301885059328 : input[39] > 1e-35 ? var42 = -.02425844450882272 : input[12] > 1e-35 ? input[3] > 1.2424533248940002 ? input[6] > 5.980149988077803 ? var42 = .01117036123239103 : input[3] > 1.4978661367769956 ? var42 = -.005154239762347923 : var42 = .06349844063391799 : var42 = -.011876368966362884 : input[4] > 3.772694874805912 ? var42 = -.010120762110714197 : input[5] > 3.276966702012906 ? input[4] > 2.4414009612931857 ? input[4] > 3.1132683346437333 ? var42 = -.0035902728428789336 : var42 = .003411450739155564 : input[5] > 8.17933999189099 ? var42 = -.018866709049095685 : var42 = -.0038747233097564068 : var42 = .024379138339081993;
  let var43;
  input[7] > .5866799179067689 ? input[11] > 1e-35 ? input[217] > 1e-35 ? var43 = .01816196279626246 : var43 = -.008720340174685528 : input[14] > 1e-35 ? var43 = .017422275374961747 : input[3] > 2.802901033147999 ? input[6] > 6.0026509725338455 ? input[18] > 1e-35 ? var43 = -.035421013136394335 : input[219] > 1e-35 ? var43 = -.03997357699142973 : input[3] > 4.993822430271426 ? var43 = -.03250278247092862 : var43 = .004080430247607075 : var43 = -.010055330454519094 : input[5] > 9.345963324807864 ? var43 = -.008136951493137817 : input[90] > 1e-35 ? var43 = -.16414188828180187 : input[45] > 1e-35 ? var43 = -.0395103723535772 : input[17] > 1e-35 ? input[6] > 3.314020688089767 ? var43 = .03144428117941763 : var43 = -.12305809642153893 : input[5] > 3.417592293073651 ? var43 = .006863569747629234 : input[7] > .9626084674797213 ? input[204] > 1e-35 ? var43 = .08986402088848823 : input[100] > 1e-35 ? var43 = .09658177526577977 : input[141] > 1e-35 ? var43 = .06795495668113817 : input[28] > 1e-35 ? input[3] > 1e-35 ? var43 = .10311172778826272 : var43 = -.12367638872784459 : input[209] > 1e-35 ? var43 = .06796205879581844 : input[6] > 3.0677824455408698 ? input[3] > 2.012675845367575 ? var43 = -.1815028770626217 : var43 = -.027600842388305583 : var43 = .013979123567456554 : var43 = -.003475039039176338 : input[6] > 4.3882378946731615 ? input[3] > 3.6242520361853052 ? var43 = -.008151073332139989 : input[3] > 2.4414009612931857 ? input[48] > 1e-35 ? var43 = -.05732062477153205 : var43 = .0038104987226822806 : input[7] > .14547530463198097 ? var43 = -.0015360108147469411 : var43 = -.014797616303672155 : input[3] > .8958797346140276 ? var43 = -.010446976011382926 : var43 = -.039018423658353285;
  let var44;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 4.620046665062766 ? input[3] > 1.8688348091416842 ? var44 = -.0031733808376565214 : var44 = -.019463570735432378 : var44 = .0032566959999593536 : input[5] > 5.692045796563381 ? input[3] > 1.4978661367769956 ? var44 = .006472511895453073 : input[2] > .8958797346140276 ? var44 = .029439910335277677 : var44 = .05703290277034656 : input[219] > 1e-35 ? var44 = -.06489530937321614 : input[5] > 4.424828703319957 ? var44 = .017756995160153607 : input[125] > 1e-35 ? var44 = -.13863131633711023 : var44 = -.011337464460106939 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var44 = -.04822012795561216 : input[125] > 1e-35 ? var44 = .06083023155995546 : input[141] > 1e-35 ? var44 = .04503531231698771 : input[5] > 7.751690325550034 ? var44 = -.008826435995092507 : var44 = .0004769856196102064 : input[5] > 5.895778350950796 ? var44 = -.03439788269853701 : var44 = .0012862199645308793 : input[141] > 1e-35 ? input[3] > 3.0677824455408698 ? var44 = .0046610227653059695 : var44 = -.04504560149384845 : input[3] > 4.3372693810700085 ? var44 = -.011924612526365003 : input[151] > 1e-35 ? var44 = -.07909878419302184 : input[40] > 1e-35 ? var44 = -.04837106565429512 : input[52] > 1e-35 ? var44 = -.06478730352567258 : input[18] > 1e-35 ? input[46] > 1e-35 ? var44 = .060888920864590634 : input[5] > 3.5694334999727624 ? var44 = -.02601024872439008 : var44 = .07960150564774994 : input[46] > 1e-35 ? var44 = -.027213119561154103 : input[51] > 1e-35 ? var44 = -.054081846676903716 : input[54] > 1e-35 ? var44 = -.07375359621246233 : input[50] > 1e-35 ? var44 = -.0570341640965886 : var44 = .0021129818482267812;
  let var45;
  input[2] > 2.861792550976191 ? input[11] > 1e-35 ? input[58] > 1e-35 ? var45 = -.09222476830824185 : input[156] > 1e-35 ? var45 = -.044357001480428 : var45 = -.009033627105152873 : input[8] > 1e-35 ? input[5] > 7.429817490674132 ? var45 = -.007435399919321396 : var45 = -.025630334739367253 : input[155] > 1e-35 ? var45 = .02064199664419035 : input[5] > 8.75754777636908 ? input[2] > 4.119004124609202 ? var45 = -.012759040985224594 : var45 = -.0009375109950390992 : input[21] > 1e-35 ? var45 = -.028664595543047417 : input[187] > 1e-35 ? var45 = -.03837361994986333 : input[22] > 1e-35 ? var45 = -.027274995074267547 : input[14] > 1e-35 ? var45 = .016392245342055616 : input[17] > 1e-35 ? var45 = .022509678093313362 : input[28] > 1e-35 ? var45 = .025145343126000193 : input[39] > 1e-35 ? var45 = -.02939647868188604 : var45 = .00042395552644239256 : input[29] > 1e-35 ? input[2] > 2.012675845367575 ? var45 = -.0030925701821976686 : input[5] > 6.0390628155997765 ? input[2] > .8958797346140276 ? var45 = .010736817315927911 : var45 = .02426980448005241 : input[28] > 1e-35 ? input[194] > 1e-35 ? var45 = -.3070569158934055 : input[196] > 1e-35 ? var45 = -.5506885961570867 : var45 = -.033353293982668515 : var45 = .006553036790621832 : input[2] > 1.2424533248940002 ? input[5] > 3.5694334999727624 ? input[155] > 1e-35 ? var45 = .02102370525016274 : var45 = .003409533559556135 : input[204] > 1e-35 ? var45 = .08873962123163927 : input[24] > 1e-35 ? var45 = .10555359938821945 : input[28] > 1e-35 ? var45 = .09719645392539251 : input[196] > 1e-35 ? var45 = .08224623369607056 : var45 = -.020134405544960793 : var45 = -.0015937623030202052;
  let var46;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[3] > 1.4978661367769956 ? input[3] > 3.540854293052788 ? var46 = -.0076758153562413375 : input[18] > 1e-35 ? var46 = -.04295196457825341 : input[51] > 1e-35 ? var46 = -.13248011320062422 : var46 = .008952360414023641 : input[7] > .987306237235768 ? var46 = .006439776900137331 : var46 = -.012660562195035134 : input[3] > 2.861792550976191 ? input[30] > 1e-35 ? var46 = .026757175255811883 : var46 = -.01062556784320532 : input[2] > .8958797346140276 ? var46 = .02114926571950188 : input[8] > 1e-35 ? input[7] > .9738681190948303 ? input[7] > .996914501566243 ? var46 = .039844832378913425 : var46 = -.06690456482695102 : var46 = .05010759067838343 : input[7] > .9901971344332651 ? input[204] > 1e-35 ? input[7] > .9945060383544003 ? var46 = .03772632631184001 : var46 = -.28522617893050056 : input[28] > 1e-35 ? var46 = -.060992612788434375 : var46 = .03341245674945403 : var46 = .051288950777861456 : input[8] > 1e-35 ? var46 = -.010769283931178146 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[1] > 1e-35 ? input[7] > .98482287934795 ? var46 = .009069204772381522 : var46 = -.004081394384581673 : var46 = -.03594060084257492 : input[7] > .9216401592048815 ? var46 = -.00442206228805168 : var46 = -.03576891499137606 : input[55] > 1e-35 ? var46 = -.08223884312902127 : input[57] > 1e-35 ? var46 = -.0742535346669798 : input[149] > 1e-35 ? var46 = -.07940704728071792 : input[39] > 1e-35 ? var46 = -.017161105634171125 : input[49] > 1e-35 ? var46 = -.04763279499691125 : input[139] > 1e-35 ? var46 = -.027192821855546695 : input[10] > 1e-35 ? var46 = -.0036316338579956914 : var46 = .0026484338648234077;
  let var47;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 5.527441013321604 ? var47 = -.012306712525171806 : input[7] > .26911173821332884 ? input[18] > 1e-35 ? var47 = -.027850707388722303 : input[91] > 1e-35 ? var47 = -.07216882827488169 : input[2] > 2.740319461670996 ? input[3] > 1.4978661367769956 ? var47 = .005596837686865309 : var47 = -.0059429747278747225 : var47 = .009524033665726878 : var47 = -.0077898166249992535 : input[6] > 5.912149824839399 ? input[3] > 1.4978661367769956 ? input[30] > 1e-35 ? var47 = .032201880996274065 : var47 = -.009587971174292791 : input[2] > .8958797346140276 ? var47 = .02761965407835318 : var47 = .05238312639482409 : input[7] > .990877425524446 ? input[28] > 1e-35 ? input[156] > 1e-35 ? var47 = .08220352701195494 : var47 = -.16200772313735304 : input[135] > 1e-35 ? input[6] > 4.310776603370241 ? var47 = -.03126230621131264 : var47 = -.15437767199900418 : input[219] > 1e-35 ? input[2] > .8958797346140276 ? var47 = .018944713961164792 : input[3] > 1e-35 ? var47 = .06629929139668997 : var47 = -.16790799717043633 : input[192] > 1e-35 ? var47 = -.3320398525405097 : var47 = .009790162291004705 : input[125] > 1e-35 ? var47 = -.0996239956884951 : var47 = .017982806591038288 : input[25] > 1e-35 ? var47 = -.02642518530716432 : input[6] > 9.286096980078398 ? input[3] > 2.740319461670996 ? var47 = -.0027582177390145703 : var47 = -.02047492290459601 : input[17] > 1e-35 ? var47 = .01622159988588393 : input[7] > .5866799179067689 ? var47 = .0012556670436606133 : input[3] > 2.3502401828962087 ? input[3] > 3.314020688089767 ? var47 = -.00567335909535631 : var47 = .0036605424249172938 : input[7] > .085616240166877 ? var47 = -.00662352094724046 : var47 = -.024196995936398374;
  let var48;
  input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[2] > 2.802901033147999 ? input[3] > 1.8688348091416842 ? input[4] > 3.6242520361853052 ? var48 = -.008283589876968955 : var48 = .005263882290960596 : input[7] > .9662372103242399 ? var48 = .0028703212438091555 : var48 = -.014488335095453487 : input[5] > 3.5694334999727624 ? var48 = .006182444666070272 : var48 = .04834325475124454 : input[5] > 5.821564412917691 ? input[3] > 1.4978661367769956 ? var48 = .006862035478899274 : input[2] > 1e-35 ? var48 = .03694434517261685 : var48 = .06818308291563471 : input[8] > 1e-35 ? input[4] > 3.979637980058199 ? var48 = -.14792403668068005 : input[5] > 4.297262267176281 ? var48 = .04085199387960594 : var48 = -.08112459203056922 : input[7] > .990877425524446 ? input[204] > 1e-35 ? input[4] > 2.4414009612931857 ? var48 = .040094872099644886 : var48 = -.37432021591644105 : input[128] > 1e-35 ? input[17] > 1e-35 ? var48 = .11216772098992614 : var48 = -.39517539261887863 : var48 = -.006202508512715542 : var48 = .031730389306944315 : input[8] > 1e-35 ? input[5] > 3.156774023138548 ? var48 = -.011787620507206525 : input[3] > 1.2424533248940002 ? var48 = -.0681989521208321 : var48 = .06597717957453096 : input[2] > 1e-35 ? input[25] > 1e-35 ? var48 = -.024543929344106336 : input[5] > 8.193814844759492 ? input[4] > 2.602003343538398 ? input[2] > 5.167634984480833 ? var48 = -.00996811570890536 : var48 = .001134417943860963 : var48 = -.013004815776467261 : input[1] > 1e-35 ? input[22] > 1e-35 ? var48 = -.019057324908699217 : input[141] > 1e-35 ? var48 = -.026707851278989517 : var48 = .005608056403567553 : var48 = -.0017699070677530831 : input[3] > 1.4978661367769956 ? var48 = -.005457163739006659 : var48 = -.02994467745413277;
  let var49;
  input[11] > 1e-35 ? input[154] > 1e-35 ? var49 = -.07640004589975245 : input[153] > 1e-35 ? var49 = -.027921183286970398 : input[156] > 1e-35 ? var49 = -.02508900369371103 : input[47] > 1e-35 ? var49 = -.09621039139423637 : input[46] > 1e-35 ? var49 = -.05890206826599292 : var49 = -.0018521707885188695 : input[7] > .1998775237752378 ? input[39] > 1e-35 ? var49 = -.02026563108381904 : input[91] > 1e-35 ? var49 = -.03979999802398471 : input[14] > 1e-35 ? input[134] > 1e-35 ? var49 = .044705853812635206 : var49 = .01112016315736189 : input[24] > 1e-35 ? input[6] > 3.417592293073651 ? var49 = .01585670681557334 : var49 = .0820229237073549 : input[9] > 1e-35 ? input[204] > 1e-35 ? input[6] > 3.9219243190762363 ? var49 = .01475544028693712 : input[30] > 1e-35 ? var49 = .10219265831102325 : var49 = -.0567832116465987 : input[154] > 1e-35 ? var49 = -.04682869193620295 : var49 = .0058147572533605784 : input[123] > 1e-35 ? var49 = -.04011640490395746 : input[17] > 1e-35 ? input[6] > 3.314020688089767 ? var49 = .016472642951500794 : var49 = -.10372235311156908 : input[19] > 1e-35 ? var49 = .013619887374131652 : input[28] > 1e-35 ? input[6] > 3.1984648276080736 ? input[6] > 5.5816130673839615 ? var49 = .021404525777064917 : var49 = -.022090537029637168 : var49 = .07927547222505857 : input[129] > 1e-35 ? var49 = -.0315112950229846 : input[90] > 1e-35 ? var49 = -.08016175793969123 : input[60] > 1e-35 ? var49 = -.044255594885932 : input[150] > 1e-35 ? var49 = -.0643645650066138 : var49 = 18071436579202054e-21 : input[6] > 6.132312266239896 ? var49 = .00017227075512669227 : var49 = -.010904669702571911;
  let var50;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[7] > .30853255358841714 ? input[154] > 1e-35 ? var50 = -.053460642910797676 : var50 = .009652079082741289 : var50 = -.0017676195976280011 : input[134] > 1e-35 ? var50 = .01746182064829904 : input[32] > 1e-35 ? var50 = .033149881191962445 : input[138] > 1e-35 ? var50 = .02149173543949675 : input[37] > 1e-35 ? var50 = .028519159270523897 : input[152] > 1e-35 ? var50 = .023352031441951773 : input[217] > 1e-35 ? var50 = .02290558132732214 : var50 = -.01850975101703459 : input[152] > 1e-35 ? var50 = .010488854074509982 : input[155] > 1e-35 ? input[12] > 1e-35 ? var50 = .027490522294963154 : var50 = .002575743497494008 : input[131] > 1e-35 ? var50 = -.07138027268500055 : input[57] > 1e-35 ? var50 = -.06658662137088783 : input[28] > 1e-35 ? var50 = .015141080652315508 : input[55] > 1e-35 ? var50 = -.07156337757427284 : input[204] > 1e-35 ? var50 = .008085415901726045 : input[99] > 1e-35 ? input[1] > 1e-35 ? var50 = .01803019280250009 : var50 = -.012275416064615064 : input[113] > 1e-35 ? var50 = .007680714218522011 : input[102] > 1e-35 ? var50 = .01923593781092882 : input[38] > 1e-35 ? var50 = .00598208846998872 : input[112] > 1e-35 ? var50 = .00895148693111358 : input[217] > 1e-35 ? var50 = .004322676779141819 : input[114] > 1e-35 ? input[1] > 1e-35 ? var50 = .019173900241286065 : input[18] > 1e-35 ? var50 = -.1302545616586715 : var50 = -.012219608237225175 : input[89] > 1e-35 ? var50 = .019080595932083305 : input[95] > 1e-35 ? var50 = .009182530113836561 : var50 = -.006531048204768366;
  let var51;
  input[2] > 4.135134555718313 ? input[47] > 1e-35 ? var51 = -.06057129526622943 : input[5] > 6.805168536739806 ? input[3] > 2.4414009612931857 ? input[1] > 1e-35 ? input[32] > 1e-35 ? var51 = -.09672976728291365 : input[217] > 1e-35 ? var51 = -.09138286775903748 : input[114] > 1e-35 ? var51 = .034435801312936894 : var51 = .003550781249532139 : input[56] > 1e-35 ? var51 = .06582022232543998 : input[144] > 1e-35 ? var51 = -.08601101006110747 : var51 = -.006766914059699758 : input[217] > 1e-35 ? var51 = .001822103802069182 : var51 = -.013646878234832634 : input[8] > 1e-35 ? var51 = -.02495807137678248 : input[1] > 1e-35 ? var51 = .009517017217557915 : var51 = -.007488737506950444 : input[6] > 6.1537953943602615 ? input[140] > 1e-35 ? var51 = -.013180308369805589 : input[51] > 1e-35 ? var51 = -.0496089337787575 : input[15] > 1e-35 ? input[30] > 1e-35 ? var51 = .017032153502995334 : var51 = -.01330098154550191 : input[10] > 1e-35 ? input[56] > 1e-35 ? var51 = .04713518460375107 : var51 = -.0016223104582873055 : input[131] > 1e-35 ? var51 = -.07291331059881433 : input[27] > 1e-35 ? var51 = -.015619378359486803 : var51 = .006051005570772542 : input[3] > 3.1132683346437333 ? input[8] > 1e-35 ? var51 = -.02945681137428643 : var51 = -.00725026522062693 : input[6] > 1e-35 ? input[3] > 1.2424533248940002 ? var51 = .0035081297381004684 : input[194] > 1e-35 ? input[5] > 3.772694874805912 ? var51 = -.03142097937872678 : var51 = -.17253564001853064 : input[5] > 3.156774023138548 ? var51 = -.004860170522962415 : input[12] > 1e-35 ? var51 = -.04169370739781986 : var51 = .05886396855048806 : var51 = -.10415236736977414;
  let var52;
  input[2] > 2.3502401828962087 ? input[11] > 1e-35 ? input[58] > 1e-35 ? var52 = -.07548370555339029 : var52 = -.009060327134219393 : input[21] > 1e-35 ? var52 = -.02536204329245056 : input[155] > 1e-35 ? var52 = .01626198918750622 : input[142] > 1e-35 ? var52 = -.029262265693304763 : input[4] > 1.8688348091416842 ? input[48] > 1e-35 ? var52 = -.0522966414357639 : input[47] > 1e-35 ? var52 = -.03867213359133592 : input[149] > 1e-35 ? var52 = -.10392339919606915 : input[135] > 1e-35 ? var52 = -.010541433982611018 : input[51] > 1e-35 ? var52 = -.06273170107556418 : input[54] > 1e-35 ? var52 = -.08769404750229767 : input[18] > 1e-35 ? input[1] > 1e-35 ? var52 = .0022966362330231133 : input[31] > 1e-35 ? var52 = .19571528454816625 : var52 = -.04919246049942885 : input[50] > 1e-35 ? var52 = -.06766114512966344 : input[7] > .9793410316570949 ? var52 = .00837983401462093 : var52 = .0007986280224776339 : input[186] > 1e-35 ? var52 = -.16446174535054356 : input[62] > 1e-35 ? var52 = .06508947502037822 : var52 = -.010260699234562241 : input[6] > 5.486867329823672 ? input[140] > 1e-35 ? var52 = -.01589822136096899 : input[125] > 1e-35 ? var52 = -.025465846683560996 : input[190] > 1e-35 ? var52 = -.03671457167643481 : input[91] > 1e-35 ? var52 = -.03821691103237143 : input[57] > 1e-35 ? var52 = -.07502589184745939 : input[50] > 1e-35 ? var52 = -.05395522531288487 : var52 = .005241788285288346 : input[4] > 3.1132683346437333 ? var52 = -.008741587825172916 : input[12] > 1e-35 ? input[100] > 1e-35 ? var52 = .06608964318040904 : var52 = -.012827641806975033 : var52 = .004744161815471635;
  let var53;
  input[4] > .8958797346140276 ? input[2] > 5.4049245766661995 ? input[5] > 6.0051201133541365 ? var53 = -.008352440702113342 : var53 = .00818161196788124 : input[123] > 1e-35 ? var53 = -.02387242845183433 : input[190] > 1e-35 ? var53 = -.03574127589374163 : input[152] > 1e-35 ? var53 = .01262147105943106 : input[11] > 1e-35 ? input[58] > 1e-35 ? var53 = -.05955906348417553 : var53 = -.003717083835106387 : input[6] > 6.0026509725338455 ? input[15] > 1e-35 ? input[30] > 1e-35 ? var53 = .023589988800048537 : var53 = -.01290090410411923 : input[38] > 1e-35 ? var53 = .015295369946508892 : input[1] > 1e-35 ? input[4] > 2.740319461670996 ? input[22] > 1e-35 ? var53 = -.01614208413608714 : input[42] > 1e-35 ? var53 = -.05454658382875832 : var53 = .008894057269932708 : input[141] > 1e-35 ? var53 = -.029660896741885025 : var53 = .0007918628584206305 : input[12] > 1e-35 ? var53 = .010735865892076339 : input[218] > 1e-35 ? var53 = .06499398466334683 : input[29] > 1e-35 ? var53 = -.02987220407530282 : input[118] > 1e-35 ? var53 = -.05994319680494358 : var53 = -.0022119035344297464 : input[113] > 1e-35 ? input[24] > 1e-35 ? var53 = .09992180359591052 : var53 = .003953091072683087 : input[204] > 1e-35 ? input[4] > 2.249904835165133 ? var53 = .0012737346185997833 : input[5] > 3.979637980058199 ? var53 = .012350990163327259 : input[29] > 1e-35 ? var53 = -.4173182186315585 : var53 = .09483857671510697 : var53 = -.0034771114722081282 : input[19] > 1e-35 ? var53 = .04818172610227253 : input[158] > 1e-35 ? var53 = .09085872490042819 : input[123] > 1e-35 ? var53 = .046170414156546824 : var53 = -.030833991141721785;
  let var54;
  input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[2] > 2.138333059508028 ? input[3] > 1.4978661367769956 ? input[3] > 4.197173680708697 ? var54 = -.015067858446918237 : input[5] > 3.979637980058199 ? var54 = .0025493966284458503 : input[24] > 1e-35 ? var54 = .10170949517680355 : input[3] > 2.3502401828962087 ? var54 = -.010182198776560389 : input[7] > .9662372103242399 ? var54 = .0855616171705204 : var54 = -.0044290837387121786 : input[7] > .992067132663463 ? var54 = .006950766900495411 : var54 = -.011703657118613042 : input[3] > 3.314020688089767 ? var54 = -.007590151825214328 : var54 = .011931088318037653 : input[5] > 4.424828703319957 ? input[3] > 1.4978661367769956 ? var54 = .003895993078605918 : input[2] > 1e-35 ? input[5] > 5.859359688974663 ? var54 = .03311360926528595 : input[7] > .9936484368123463 ? input[28] > 1e-35 ? var54 = -.1296383065201116 : input[18] > 1e-35 ? var54 = -.2304238024287801 : var54 = -.0007035160942990814 : var54 = .03872938637191365 : var54 = .05931958562003542 : input[204] > 1e-35 ? input[7] > .9926276364955392 ? var54 = -.2503820824196552 : var54 = .01514980593659256 : input[135] > 1e-35 ? input[7] > .990877425524446 ? var54 = -.12146435764173391 : var54 = .03579230653026111 : input[125] > 1e-35 ? var54 = -.11990587076136816 : var54 = -.0017264106529335022 : input[2] > .8958797346140276 ? input[3] > 4.878999622893762 ? var54 = -.028006872909888104 : input[17] > 1e-35 ? var54 = .015327119563713427 : input[14] > 1e-35 ? var54 = .008966123864441086 : input[24] > 1e-35 ? var54 = .014884319812071584 : var54 = -.0008180929266082377 : input[29] > 1e-35 ? input[5] > 5.895778350950796 ? var54 = -.02927173520516398 : var54 = .004256706136162408 : var54 = -.0030692852485265805;
  let var55;
  input[39] > 1e-35 ? var55 = -.019116728566000912 : input[152] > 1e-35 ? var55 = .011159312353677259 : input[52] > 1e-35 ? var55 = -.06556505864685434 : input[7] > .14547530463198097 ? input[187] > 1e-35 ? var55 = -.02203060071288757 : input[48] > 1e-35 ? var55 = -.03406851575382452 : input[10] > 1e-35 ? input[219] > 1e-35 ? var55 = -.026242020752538932 : var55 = -.0026163734864036088 : input[21] > 1e-35 ? var55 = -.016803181860075653 : input[8] > 1e-35 ? input[5] > 3.0201273556387074 ? input[6] > 4.722943345003718 ? input[125] > 1e-35 ? var55 = -.07907862980413462 : var55 = -.0024968534057976956 : input[141] > 1e-35 ? var55 = .01751368963010255 : var55 = -.035334686232177996 : input[3] > 1e-35 ? var55 = -.049727650261844114 : var55 = .06649006602788514 : input[51] > 1e-35 ? var55 = -.047051279496267896 : input[58] > 1e-35 ? input[19] > 1e-35 ? var55 = .06794814379814933 : var55 = -.033933057704283995 : input[6] > 8.681774988134558 ? var55 = -.001906867260604815 : input[3] > 3.3842466058243152 ? input[23] > 1e-35 ? var55 = .029126145919054786 : input[12] > 1e-35 ? input[59] > 1e-35 ? var55 = .06547842372312768 : var55 = .005706402727440608 : input[89] > 1e-35 ? var55 = .05238448470974841 : var55 = -.003970577798047124 : input[141] > 1e-35 ? input[3] > 1e-35 ? var55 = -.02994666941636212 : var55 = .029175297065511276 : input[139] > 1e-35 ? var55 = -.03926804943552878 : input[7] > .9626084674797213 ? var55 = .010270060885238803 : input[6] > 4.5379471377116305 ? var55 = .0051640733904868355 : var55 = -.006326617548806485 : input[3] > 2.3502401828962087 ? var55 = -.001064039369711557 : var55 = -.015232776877478657;
  let var56;
  input[4] > .8958797346140276 ? input[0] > 1e-35 ? input[3] > 3.540854293052788 ? input[138] > 1e-35 ? var56 = .020620751195117866 : var56 = -.007657642824282572 : input[9] > 1e-35 ? var56 = .013255738783000171 : input[123] > 1e-35 ? var56 = -.04553588467808997 : input[14] > 1e-35 ? var56 = .020257942633657516 : input[17] > 1e-35 ? var56 = .02379466680602821 : input[7] > .26911173821332884 ? var56 = .004563013176326579 : var56 = -.006044878247080096 : input[208] > 1e-35 ? input[1] > 1e-35 ? var56 = .016583051243963785 : var56 = -.005473696128326885 : input[53] > 1e-35 ? var56 = -.07392011100318682 : input[3] > 4.840234496705036 ? var56 = -.022277334024938686 : input[49] > 1e-35 ? var56 = -.04140311782670083 : input[40] > 1e-35 ? var56 = -.041278341040658334 : input[156] > 1e-35 ? var56 = -.01087788432462589 : input[8] > 1e-35 ? input[141] > 1e-35 ? var56 = .032404890147508435 : var56 = -.008762958389316138 : input[153] > 1e-35 ? input[18] > 1e-35 ? var56 = .03064796696780178 : input[19] > 1e-35 ? var56 = .025912082684934896 : input[7] > .9033253454895247 ? var56 = .00010665286308939541 : var56 = -.019390651252802232 : input[133] > 1e-35 ? var56 = -.013215417920201165 : input[35] > 1e-35 ? var56 = -.07409193965805899 : input[16] > 1e-35 ? var56 = .010595288788401727 : var56 = .0004445963442680354 : input[19] > 1e-35 ? var56 = .043800560164078434 : input[62] > 1e-35 ? var56 = .08440762960688118 : input[123] > 1e-35 ? var56 = .04196062757398021 : input[44] > 1e-35 ? input[7] > .9880960409521241 ? var56 = -.14025705728324367 : var56 = .07605327900446729 : var56 = -.030453882536033008;
  let var57;
  input[14] > 1e-35 ? input[134] > 1e-35 ? var57 = .03807815059641535 : var57 = .007895137847547357 : input[39] > 1e-35 ? var57 = -.019172673927560828 : input[138] > 1e-35 ? var57 = .009207480510332959 : input[152] > 1e-35 ? input[10] > 1e-35 ? var57 = .029310247627617716 : var57 = .006422126177312616 : input[3] > 3.5114340430413216 ? input[155] > 1e-35 ? var57 = .02869511059037871 : input[137] > 1e-35 ? var57 = .048763707543632046 : input[218] > 1e-35 ? var57 = .0393143924208134 : var57 = -.0065205942363783 : input[4] > 2.4414009612931857 ? input[113] > 1e-35 ? var57 = .016047178137914484 : input[35] > 1e-35 ? var57 = -.09486179869071369 : input[118] > 1e-35 ? var57 = -.032706818831570415 : input[0] > 1e-35 ? var57 = .004733859562945298 : var57 = -4345884264792552e-20 : input[29] > 1e-35 ? input[204] > 1e-35 ? input[4] > 2.3502401828962087 ? var57 = -.23804773582311067 : var57 = .0015066742334155967 : input[194] > 1e-35 ? input[4] > 1.7005986908310777 ? var57 = -.013296404682101122 : var57 = -.14340192620927933 : input[196] > 1e-35 ? var57 = -.17446678790111786 : var57 = -.01140535620661492 : input[141] > 1e-35 ? var57 = -.03362328403627273 : input[99] > 1e-35 ? var57 = .02082592497315901 : input[196] > 1e-35 ? var57 = .02125156827172031 : input[204] > 1e-35 ? var57 = .018738441981476887 : input[194] > 1e-35 ? var57 = .022230335367621302 : input[114] > 1e-35 ? var57 = .017460982004618885 : input[210] > 1e-35 ? input[11] > 1e-35 ? var57 = -.07421933796695453 : var57 = -.02600449772874995 : input[62] > 1e-35 ? var57 = .0435295764572802 : var57 = -.0036358741919687645;
  let var58;
  input[2] > 4.749261159734808 ? input[5] > 6.826002629905951 ? input[29] > 1e-35 ? var58 = -.012866931871530748 : input[47] > 1e-35 ? var58 = -.06511122680099479 : var58 = -.0033152297369715466 : input[1] > 1e-35 ? var58 = .00634942519508748 : var58 = -.008516826211528918 : input[6] > 6.1537953943602615 ? input[11] > 1e-35 ? input[121] > 1e-35 ? input[1] > 1e-35 ? var58 = -.06214080664476329 : var58 = .037029947625630194 : input[47] > 1e-35 ? var58 = -.08203414630098728 : var58 = -.0044122376347199765 : input[15] > 1e-35 ? input[30] > 1e-35 ? var58 = .012452689013210465 : var58 = -.011970977023212193 : input[10] > 1e-35 ? input[152] > 1e-35 ? var58 = .02888624440861723 : var58 = -.0026872248277927456 : input[27] > 1e-35 ? var58 = -.01471521834054285 : input[21] > 1e-35 ? var58 = -.014970363019863132 : input[13] > 1e-35 ? var58 = -.0057151868439017945 : input[38] > 1e-35 ? var58 = .01633003881478886 : var58 = .005850603591179588 : input[113] > 1e-35 ? input[5] > 3.979637980058199 ? var58 = .006600693642185256 : input[6] > 3.1984648276080736 ? var58 = .07576534772024612 : var58 = -.013028252220942527 : input[204] > 1e-35 ? input[9] > 1e-35 ? input[6] > 3.9219243190762363 ? var58 = .01266221511189265 : input[29] > 1e-35 ? var58 = -.20167612409830682 : var58 = .09361829582187109 : var58 = .0016303497789744046 : input[6] > 4.310776603370241 ? var58 = -.0015960016142716584 : input[141] > 1e-35 ? input[2] > 2.249904835165133 ? input[6] > 2.970085626360216 ? var58 = -.05054316446311788 : var58 = .06528096075929847 : input[29] > 1e-35 ? var58 = .07763431964140277 : var58 = -.017239135292908336 : var58 = -.011068823413100247;
  let var59;
  input[91] > 1e-35 ? var59 = -.03524202222673902 : input[55] > 1e-35 ? var59 = -.07505808762820981 : input[47] > 1e-35 ? var59 = -.026314216162986376 : input[49] > 1e-35 ? var59 = -.045488810456426665 : input[54] > 1e-35 ? var59 = -.06424779605129435 : input[0] > 1e-35 ? input[39] > 1e-35 ? var59 = -.03267263134559766 : input[46] > 1e-35 ? var59 = -.049285436356671077 : input[51] > 1e-35 ? var59 = -.09277060040547602 : input[4] > .8958797346140276 ? input[123] > 1e-35 ? var59 = -.027164727231258436 : input[7] > .4232249052377311 ? input[14] > 1e-35 ? var59 = .021561483416797714 : input[9] > 1e-35 ? input[58] > 1e-35 ? var59 = -.08387877475105178 : var59 = .014404401501386124 : var59 = .004694473365260974 : var59 = -.0001897538693116325 : var59 = -.017140588284242805 : input[5] > 9.119594757170685 ? input[3] > 2.740319461670996 ? var59 = -.0007153953072197825 : var59 = -.010378474356201449 : input[8] > 1e-35 ? input[5] > 3.276966702012906 ? input[125] > 1e-35 ? var59 = -.06966241558514917 : input[4] > 4.82429765145367 ? var59 = -.05703428861212874 : var59 = -.007549683006633188 : input[3] > 1.2424533248940002 ? var59 = -.05340556429257431 : var59 = .0524214727387076 : input[22] > 1e-35 ? var59 = -.012756524179901607 : input[186] > 1e-35 ? var59 = -.06578146880564559 : input[208] > 1e-35 ? var59 = .011189277267677045 : input[11] > 1e-35 ? input[58] > 1e-35 ? var59 = -.05051984734793551 : input[3] > 1.2424533248940002 ? var59 = -.0002576217567062796 : input[134] > 1e-35 ? var59 = -.07452351335236179 : var59 = -.010366062496356129 : input[94] > 1e-35 ? var59 = -.04206673603732986 : var59 = .0017654268359667174;
  let var60;
  input[2] > 2.3502401828962087 ? input[28] > 1e-35 ? var60 = .018743416209068924 : input[142] > 1e-35 ? var60 = -.027628078748284907 : input[4] > 1.7005986908310777 ? input[123] > 1e-35 ? var60 = -.039485087567133176 : input[48] > 1e-35 ? var60 = -.04707407726639779 : input[49] > 1e-35 ? var60 = -.0644727439161007 : input[47] > 1e-35 ? var60 = -.03586301268310228 : input[52] > 1e-35 ? var60 = -.08213761833929575 : input[60] > 1e-35 ? var60 = -.036939376764301805 : input[22] > 1e-35 ? var60 = -.02264827779335228 : input[153] > 1e-35 ? input[24] > 1e-35 ? var60 = .03651632275248908 : var60 = -.010403215174169965 : input[18] > 1e-35 ? input[31] > 1e-35 ? var60 = .17011943799802248 : var60 = -.024083374989820074 : input[147] > 1e-35 ? var60 = -.05792387046048145 : input[39] > 1e-35 ? var60 = -.019000152117179 : input[54] > 1e-35 ? var60 = -.09256681585621543 : input[50] > 1e-35 ? var60 = -.06535283940797192 : input[187] > 1e-35 ? var60 = -.023020538580498528 : input[149] > 1e-35 ? var60 = -.09670391878996044 : input[8] > 1e-35 ? input[6] > 5.865049616265698 ? var60 = .0007122257672540384 : var60 = -.024203929126070334 : input[55] > 1e-35 ? var60 = -.10687519344783902 : input[21] > 1e-35 ? var60 = -.019836359134795922 : var60 = .0028141634686288143 : input[153] > 1e-35 ? var60 = -.044827592367532504 : var60 = -.009894012855110334 : input[140] > 1e-35 ? input[18] > 1e-35 ? var60 = .060584003745668275 : var60 = -.015006980258423744 : input[6] > 5.161920636569023 ? input[125] > 1e-35 ? var60 = -.021624709427283298 : var60 = .0035264081894521636 : var60 = -.0030260520850755417;
  let var61;
  input[57] > 1e-35 ? var61 = -.06665941268716478 : input[2] > 5.4049245766661995 ? var61 = -.0048763725607228565 : input[17] > 1e-35 ? var61 = .012937023835595996 : input[91] > 1e-35 ? var61 = -.032642493399923284 : input[40] > 1e-35 ? var61 = -.04355571234278559 : input[14] > 1e-35 ? input[217] > 1e-35 ? var61 = -.030555708374197955 : var61 = .010895997063478696 : input[1] > 1e-35 ? input[99] > 1e-35 ? var61 = .016029829045206837 : input[114] > 1e-35 ? var61 = .017475123428921584 : input[139] > 1e-35 ? var61 = -.042037981483985604 : input[210] > 1e-35 ? input[29] > 1e-35 ? var61 = .015395913258454092 : var61 = -.024779051599098958 : input[90] > 1e-35 ? var61 = -.09436512907953146 : input[25] > 1e-35 ? var61 = -.0385103760507401 : input[113] > 1e-35 ? var61 = .014955995782471 : input[208] > 1e-35 ? var61 = .01363101947809469 : var61 = .0004708078358576994 : input[29] > 1e-35 ? var61 = -.02567148566035587 : input[217] > 1e-35 ? var61 = .017896286118860596 : input[118] > 1e-35 ? var61 = -.04366196842115269 : input[144] > 1e-35 ? var61 = -.04332564222613586 : input[54] > 1e-35 ? var61 = -.08095356842154083 : input[31] > 1e-35 ? input[15] > 1e-35 ? var61 = -.12797365603832508 : var61 = .05407709367007049 : input[56] > 1e-35 ? var61 = .030874690971051524 : input[148] > 1e-35 ? var61 = -.06664437092250396 : input[50] > 1e-35 ? var61 = -.05710031053092695 : input[114] > 1e-35 ? input[18] > 1e-35 ? var61 = -.12348764088627251 : var61 = -.014081947133593207 : input[147] > 1e-35 ? var61 = -.044629298717173554 : var61 = -.000742893245658901;
  let var62;
  input[138] > 1e-35 ? var62 = .008266725465725232 : input[1] > 1e-35 ? input[37] > 1e-35 ? var62 = -.06288072801700428 : input[114] > 1e-35 ? var62 = .01701875404216428 : input[128] > 1e-35 ? var62 = -.022207708344996902 : input[113] > 1e-35 ? input[24] > 1e-35 ? var62 = .08078133512323216 : var62 = .010126216487392538 : input[11] > 1e-35 ? input[58] > 1e-35 ? var62 = -.0542116306120395 : var62 = -.004962440421854299 : input[155] > 1e-35 ? input[30] > 1e-35 ? var62 = .02107443326718807 : var62 = -.01069225359959257 : var62 = .0009105709984003484 : input[218] > 1e-35 ? var62 = .05160355321154702 : input[134] > 1e-35 ? var62 = .006114948378400552 : input[121] > 1e-35 ? var62 = .016106484014031797 : input[89] > 1e-35 ? var62 = .01912348851711998 : input[56] > 1e-35 ? var62 = .029777849606436514 : input[157] > 1e-35 ? var62 = .04060172642469715 : input[31] > 1e-35 ? var62 = .040190765597096945 : input[115] > 1e-35 ? var62 = .038285461163007885 : input[144] > 1e-35 ? var62 = -.04397941351839926 : input[53] > 1e-35 ? var62 = -.09153555712989248 : input[34] > 1e-35 ? var62 = .05063635650139542 : input[145] > 1e-35 ? var62 = -.05531793235403996 : input[18] > 1e-35 ? input[142] > 1e-35 ? var62 = .050915836711889595 : var62 = -.038668153033606156 : input[142] > 1e-35 ? var62 = -.03161888799270195 : input[21] > 1e-35 ? var62 = -.039152400008548416 : input[147] > 1e-35 ? var62 = -.06369054146375448 : input[146] > 1e-35 ? var62 = -.06687062048733548 : input[143] > 1e-35 ? var62 = -.0374398909044375 : var62 = -.004075281311375503;
  let var63;
  input[19] > 1e-35 ? var63 = .011138060439416179 : input[7] > .054053454943712505 ? input[17] > 1e-35 ? input[30] > 1e-35 ? var63 = .031458353209402545 : var63 = .006712963530887799 : input[135] > 1e-35 ? var63 = -.008268741342836259 : input[60] > 1e-35 ? var63 = -.026373116795568554 : input[7] > .8375851232899904 ? input[3] > 2.602003343538398 ? input[6] > 4.832297822126891 ? var63 = .001164103411669833 : input[8] > 1e-35 ? var63 = -.04419920795209664 : var63 = -.007580602414427876 : input[6] > 3.417592293073651 ? input[6] > 8.80963889693121 ? var63 = -.00653283113371423 : input[8] > 1e-35 ? input[125] > 1e-35 ? var63 = -.10156793652811894 : var63 = -.004200534838133274 : input[18] > 1e-35 ? var63 = -.01192673279840267 : var63 = .007421951916920296 : input[7] > .9626084674797213 ? input[29] > 1e-35 ? input[6] > 2.970085626360216 ? var63 = -.0032059430383565256 : var63 = .05159315082197918 : input[8] > 1e-35 ? var63 = -.0890031715943104 : input[22] > 1e-35 ? var63 = -.16814104441488775 : input[12] > 1e-35 ? input[100] > 1e-35 ? var63 = .1021284677424052 : var63 = -.13655977142603173 : var63 = .09393254504800182 : var63 = -.0008030674521708154 : input[153] > 1e-35 ? input[18] > 1e-35 ? var63 = .028570793527563892 : var63 = -.01146507406243734 : input[125] > 1e-35 ? input[3] > 1e-35 ? var63 = -.04344386283066575 : var63 = .049543778722220704 : input[47] > 1e-35 ? var63 = -.025602694767462936 : var63 = 41633336342102227e-21 : input[3] > 2.3502401828962087 ? input[3] > 3.3497501700808394 ? var63 = -.018924000087166926 : var63 = .005374758944061522 : input[14] > 1e-35 ? var63 = .02825013192303339 : var63 = -.028367959366723622;
  let var64;
  input[190] > 1e-35 ? var64 = -.033259392758942484 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var64 = -.030965448877928344 : input[150] > 1e-35 ? var64 = -.05353588365501967 : input[53] > 1e-35 ? var64 = -.07322459471644706 : input[0] > 1e-35 ? input[6] > 6.9012339353508745 ? var64 = .007566110700214329 : input[4] > 3.0677824455408698 ? input[7] > .5242163672259389 ? input[8] > 1e-35 ? input[6] > 4.722943345003718 ? var64 = -.00508197369229565 : input[4] > 3.5694334999727624 ? var64 = -.09566908841488272 : var64 = -.009799018561370653 : input[29] > 1e-35 ? var64 = .01134634874419129 : var64 = -.008480456528154491 : var64 = -.010775036248093376 : var64 = .006611525544742429 : input[23] > 1e-35 ? var64 = .01761735039511882 : input[19] > 1e-35 ? var64 = .01278442042249664 : var64 = -.0002242132003162585 : input[186] > 1e-35 ? var64 = -.1282956565830828 : input[99] > 1e-35 ? var64 = .018493666625505303 : input[141] > 1e-35 ? var64 = -.026024552608676074 : input[29] > 1e-35 ? input[5] > 3.5694334999727624 ? input[217] > 1e-35 ? var64 = .010089877008871859 : input[7] > .9569480028661056 ? var64 = -.0021891593882122327 : var64 = -.019455050281455402 : input[7] > .960816451500545 ? var64 = -.13777176433158442 : var64 = .02722608122697913 : input[28] > 1e-35 ? input[194] > 1e-35 ? var64 = .09549833737461155 : var64 = .012447932823540411 : input[129] > 1e-35 ? input[26] > 1e-35 ? var64 = .147381625399948 : var64 = -.03418523266130075 : input[7] > .26911173821332884 ? var64 = .0014660191124088442 : input[217] > 1e-35 ? var64 = -.08282397562490618 : input[210] > 1e-35 ? var64 = -.0386848317545183 : var64 = -.001892646396528824;
  let var65;
  input[57] > 1e-35 ? var65 = -.059790543460520464 : input[55] > 1e-35 ? var65 = -.06524069243313577 : input[3] > 4.283562780082224 ? input[37] > 1e-35 ? var65 = -.054605342954169904 : var65 = -.006343751747681404 : input[17] > 1e-35 ? var65 = .011961708215735271 : input[40] > 1e-35 ? var65 = -.04296088601962452 : input[6] > 1e-35 ? input[24] > 1e-35 ? input[113] > 1e-35 ? input[6] > 4.460127707454046 ? var65 = -.026498922218692673 : var65 = .10501477027016158 : input[6] > 4.03420147928485 ? var65 = .012792216148037112 : input[7] > .9830997303909479 ? var65 = -.2271005546552327 : var65 = -.008348690537914538 : input[9] > 1e-35 ? input[153] > 1e-35 ? input[7] > .20588252599634785 ? var65 = -.004842123367456505 : var65 = -.03575275485660392 : input[99] > 1e-35 ? input[1] > 1e-35 ? var65 = .032397176999597294 : var65 = -.0033271937210452387 : input[204] > 1e-35 ? var65 = .02154799118278769 : var65 = .0034498877728340095 : input[28] > 1e-35 ? input[6] > 3.0677824455408698 ? input[6] > 5.5816130673839615 ? var65 = .01602715871650751 : input[7] > .9901971344332651 ? input[194] > 1e-35 ? var65 = -.21161676626091178 : input[127] > 1e-35 ? var65 = -.4024450297968636 : var65 = -.030976570087232314 : var65 = .0031980605341801454 : var65 = .07943810970798848 : input[135] > 1e-35 ? var65 = -.00869354055420051 : input[123] > 1e-35 ? var65 = -.022241787113206086 : input[62] > 1e-35 ? var65 = .037165483434744594 : input[7] > .04507521918085865 ? input[21] > 1e-35 ? var65 = -.013433718654288605 : input[155] > 1e-35 ? var65 = .00919342834132915 : var65 = -.0002729025327531227 : var65 = -.012537468897218136 : var65 = -.07894994665155514;
  let var66;
  input[4] > .8958797346140276 ? input[14] > 1e-35 ? var66 = .007800140351631253 : input[138] > 1e-35 ? var66 = .007294945388686309 : input[1] > 1e-35 ? input[32] > 1e-35 ? input[28] > 1e-35 ? var66 = .09462192942805535 : var66 = -.06376046128949985 : input[37] > 1e-35 ? var66 = -.06442220885770956 : input[140] > 1e-35 ? input[30] > 1e-35 ? var66 = -.09261012186873348 : var66 = -.015294712278584928 : input[98] > 1e-35 ? var66 = .019329173498247088 : input[58] > 1e-35 ? var66 = -.026405515460271967 : input[5] > 8.608586615680721 ? input[4] > 2.602003343538398 ? var66 = 6125118307170923e-20 : var66 = -.009497787119169794 : input[40] > 1e-35 ? var66 = -.05491317248554455 : input[7] > .30853255358841714 ? var66 = .003951848833690266 : var66 = -.0021827028977256715 : input[219] > 1e-35 ? var66 = -.03918852409108207 : input[98] > 1e-35 ? var66 = -.025490621458423603 : input[218] > 1e-35 ? var66 = .04685239586600909 : input[4] > 2.970085626360216 ? input[152] > 1e-35 ? var66 = .019288400231624092 : input[132] > 1e-35 ? var66 = .04845025214421127 : input[157] > 1e-35 ? var66 = .03681235344369351 : input[18] > 1e-35 ? var66 = -.034132162265456074 : input[48] > 1e-35 ? var66 = -.04861483835690636 : input[142] > 1e-35 ? var66 = -.031057400959951156 : input[148] > 1e-35 ? var66 = -.06903688486009983 : var66 = -.004426858558248682 : input[31] > 1e-35 ? var66 = .06983425899920179 : var66 = .002335587968443938 : input[19] > 1e-35 ? var66 = .04178364096434334 : input[123] > 1e-35 ? var66 = .03954255208630935 : input[62] > 1e-35 ? var66 = .07169067239737285 : var66 = -.022094630155173406;
  let var67;
  input[190] > 1e-35 ? var67 = -.029705030481716018 : input[2] > 2.4414009612931857 ? input[125] > 1e-35 ? input[3] > 1e-35 ? var67 = -.052080713549693486 : var67 = .015237248725743169 : input[49] > 1e-35 ? var67 = -.05738028956460733 : input[28] > 1e-35 ? var67 = .015629889576502864 : input[14] > 1e-35 ? var67 = .007178838639724632 : input[217] > 1e-35 ? var67 = .006873744757442591 : input[3] > .8958797346140276 ? var67 = -.0009297977761919447 : input[4] > 2.740319461670996 ? var67 = -.0032588616048005344 : input[209] > 1e-35 ? var67 = -.09352716353634213 : var67 = -.015820890219545396 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[30] > 1e-35 ? var67 = .019248760742983276 : input[3] > 2.861792550976191 ? input[6] > 8.372051799062541 ? var67 = .011687619771455333 : var67 = -.014380012538782239 : var67 = .007119108038702808 : input[5] > 4.424828703319957 ? input[3] > 2.249904835165133 ? var67 = -.004571416888569663 : input[4] > .8958797346140276 ? input[2] > 1e-35 ? var67 = .03291298609827498 : var67 = .056149641245301286 : input[6] > 5.66469358412419 ? var67 = .03259771207074825 : var67 = -.09357704176112766 : input[135] > 1e-35 ? input[4] > 3.1132683346437333 ? input[4] > 3.276966702012906 ? var67 = -.061655392996083594 : var67 = -.32745698278768204 : var67 = .05791789791717941 : var67 = -.018505458368810124 : input[2] > 1.2424533248940002 ? var67 = .0026761409362875913 : input[3] > 1e-35 ? input[30] > 1e-35 ? input[210] > 1e-35 ? var67 = -.039544237504098204 : var67 = -.00840469876565937 : input[138] > 1e-35 ? var67 = -.03964217397514852 : var67 = -4311139741723525e-22 : input[5] > 6.136645972583987 ? var67 = -.022772355719852342 : var67 = .00817231129409795;
  let var68;
  input[91] > 1e-35 ? var68 = -.028069212077752072 : input[2] > 5.1209788959100075 ? input[25] > 1e-35 ? input[4] > 3.314020688089767 ? var68 = -.07374751231467579 : var68 = -.012603466600012023 : var68 = -.003323309316995181 : input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[11] > 1e-35 ? var68 = -.008138434386494645 : input[2] > 1.8688348091416842 ? input[18] > 1e-35 ? var68 = -.021752576521312197 : input[142] > 1e-35 ? var68 = -.03703704004008216 : input[21] > 1e-35 ? var68 = -.031901873695323615 : var68 = .0007949433315561949 : input[156] > 1e-35 ? var68 = .04622194605125366 : var68 = .007164185384903575 : input[156] > 1e-35 ? var68 = .05649230717257425 : input[192] > 1e-35 ? var68 = -.14560972428612223 : input[144] > 1e-35 ? var68 = -.0847860756426489 : input[4] > .8958797346140276 ? input[2] > .8958797346140276 ? var68 = .009443385055723438 : input[9] > 1e-35 ? var68 = .0384706300742172 : input[7] > .9738681190948303 ? input[7] > .9983480540068196 ? var68 = .03566002120217884 : input[125] > 1e-35 ? var68 = -.08601531943220733 : input[28] > 1e-35 ? var68 = -.07136595081940608 : var68 = .005430826378707227 : var68 = .026279964393698674 : input[2] > .8958797346140276 ? var68 = .025916235406054845 : var68 = -.05093685243097706 : input[2] > .8958797346140276 ? input[4] > 2.4414009612931857 ? input[22] > 1e-35 ? var68 = -.018458649485324576 : input[123] > 1e-35 ? var68 = -.027048533130577097 : input[9] > 1e-35 ? var68 = .005768627348361876 : var68 = .0011976274380886302 : input[196] > 1e-35 ? var68 = .024074476840894424 : var68 = -.0040891042038809855 : input[156] > 1e-35 ? var68 = -.03722816735059365 : var68 = -.004021663177778795;
  let var69;
  input[57] > 1e-35 ? var69 = -.054174378986311306 : input[55] > 1e-35 ? var69 = -.05937408126377534 : input[35] > 1e-35 ? var69 = -.06355743050048665 : input[52] > 1e-35 ? var69 = -.049028563645544726 : input[10] > 1e-35 ? input[152] > 1e-35 ? var69 = .023779508772836917 : input[217] > 1e-35 ? var69 = .00760039749111183 : var69 = -.005758267779536595 : input[6] > 1e-35 ? input[50] > 1e-35 ? var69 = -.03899686693288482 : input[53] > 1e-35 ? var69 = -.06158372699069763 : input[19] > 1e-35 ? var69 = .009506113370718208 : input[154] > 1e-35 ? var69 = -.021220440237800273 : input[129] > 1e-35 ? input[26] > 1e-35 ? var69 = .12643307498280917 : var69 = -.02322694568396696 : input[49] > 1e-35 ? var69 = -.03489161935560748 : input[173] > 1e-35 ? var69 = -.041310484369004336 : input[116] > 1e-35 ? var69 = -.026931019221510855 : input[150] > 1e-35 ? var69 = -.04336081700276943 : input[46] > 1e-35 ? var69 = -.01503021840754708 : input[21] > 1e-35 ? var69 = -.011723313966476847 : input[187] > 1e-35 ? input[30] > 1e-35 ? var69 = .029035482597327224 : var69 = -.020238143126606493 : input[22] > 1e-35 ? var69 = -.0092659038594408 : input[6] > 8.954867306462836 ? var69 = -.002270298325316596 : input[25] > 1e-35 ? input[1] > 1e-35 ? input[152] > 1e-35 ? var69 = .025059955137215612 : var69 = -.058962720741665454 : var69 = 4061285457160542e-20 : input[7] > .787025207541384 ? var69 = .0045073893285534905 : input[156] > 1e-35 ? var69 = -.00956127321029558 : input[153] > 1e-35 ? var69 = -.006428735642845697 : var69 = .0020065887307204903 : var69 = -.07142994726664682;
  let var70;
  input[190] > 1e-35 ? var70 = -.026482483927372538 : input[11] > 1e-35 ? input[153] > 1e-35 ? var70 = -.019448665116575673 : input[46] > 1e-35 ? var70 = -.046207503035123526 : input[143] > 1e-35 ? var70 = -.060693025841649276 : input[125] > 1e-35 ? var70 = -.0635615784828548 : var70 = -.0020226769939179086 : input[10] > 1e-35 ? input[152] > 1e-35 ? var70 = .021657999498329004 : input[217] > 1e-35 ? var70 = .006867901248533881 : input[186] > 1e-35 ? var70 = -.17526174685635476 : input[7] > .3736576099860928 ? input[125] > 1e-35 ? var70 = -.06860813037660739 : var70 = -.0030373931794416857 : input[153] > 1e-35 ? var70 = -.036659407900460406 : var70 = -.009138716679401575 : input[8] > 1e-35 ? input[141] > 1e-35 ? var70 = .022488528656368925 : var70 = -.004824813956579289 : input[155] > 1e-35 ? input[29] > 1e-35 ? var70 = -.0923825728762917 : var70 = .013279779321478072 : input[13] > 1e-35 ? input[29] > 1e-35 ? var70 = -.02015430689927317 : var70 = -.0014075476679032272 : input[21] > 1e-35 ? var70 = -.010052866682366596 : input[15] > 1e-35 ? input[127] > 1e-35 ? var70 = -.11613127921904604 : var70 = -.004425492436566155 : input[61] > 1e-35 ? var70 = -.04761391619756717 : input[38] > 1e-35 ? var70 = .010790742168686546 : input[138] > 1e-35 ? input[25] > 1e-35 ? var70 = -.03936956646884221 : var70 = .012187893435100131 : input[18] > 1e-35 ? input[46] > 1e-35 ? var70 = .052404637972043124 : input[29] > 1e-35 ? input[219] > 1e-35 ? var70 = -.026128288926960785 : var70 = .01402455905339408 : var70 = -.018095204676971146 : var70 = .002238241111198228;
  let var71;
  input[3] > 4.993822430271426 ? var71 = -.021704560089024494 : input[39] > 1e-35 ? var71 = -.012978601337522922 : input[57] > 1e-35 ? var71 = -.04850734344953324 : input[190] > 1e-35 ? var71 = -.02323817835232452 : input[55] > 1e-35 ? var71 = -.054265924680079236 : input[144] > 1e-35 ? var71 = -.020797331827991154 : input[52] > 1e-35 ? var71 = -.04407078296749134 : input[50] > 1e-35 ? var71 = -.03531075513550682 : input[14] > 1e-35 ? input[217] > 1e-35 ? var71 = -.02603818360896512 : var71 = .00845420085528292 : input[90] > 1e-35 ? input[3] > 3.5114340430413216 ? var71 = .010289606334961197 : var71 = -.10259966877314837 : input[139] > 1e-35 ? var71 = -.01903913128660918 : input[17] > 1e-35 ? input[30] > 1e-35 ? var71 = .027295226228104732 : input[38] > 1e-35 ? var71 = .036847447575421244 : input[3] > 2.861792550976191 ? var71 = -.016454620470329126 : var71 = .010475083165212631 : input[19] > 1e-35 ? var71 = .008675111927467 : input[40] > 1e-35 ? var71 = -.036362054443170776 : input[9] > 1e-35 ? var71 = .0031294075955568394 : input[123] > 1e-35 ? var71 = -.02131953072683769 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[3] > 2.602003343538398 ? var71 = -.005045224468848018 : input[3] > 2.3502401828962087 ? var71 = .1006727710215487 : var71 = -.21606952724358763 : input[209] > 1e-35 ? var71 = -.07903381656359819 : var71 = .0099843967860757 : input[28] > 1e-35 ? var71 = .009909672751437115 : input[155] > 1e-35 ? input[3] > 3.941534675652877 ? var71 = .04961274235179155 : var71 = .005113567009198253 : input[158] > 1e-35 ? var71 = .031566828492110836 : var71 = -.0012534895812835874;
  let var72;
  input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var72 = -.022743199998420272 : input[47] > 1e-35 ? var72 = -.02199867034393067 : input[3] > 3.238486181444842 ? input[155] > 1e-35 ? var72 = .015256601991879549 : input[23] > 1e-35 ? var72 = .01997791344831838 : input[97] > 1e-35 ? var72 = .024977281654938052 : input[218] > 1e-35 ? var72 = .031730655567930977 : input[32] > 1e-35 ? input[1] > 1e-35 ? var72 = -.05855958691798028 : var72 = -.009630189044251312 : input[195] > 1e-35 ? var72 = -.009842090802252708 : input[125] > 1e-35 ? var72 = -.030084333742373532 : var72 = -.0009935375527704107 : input[135] > 1e-35 ? var72 = -.006040875366017567 : input[43] > 1e-35 ? var72 = -.03616920022546756 : input[44] > 1e-35 ? var72 = -.014787601622259254 : input[0] > 1e-35 ? var72 = .005949240867095038 : var72 = .0018435357767462809 : input[141] > 1e-35 ? input[3] > 1e-35 ? var72 = -.030610116678182732 : var72 = .01960307197844505 : input[3] > 1.2424533248940002 ? input[101] > 1e-35 ? var72 = -.04366907994393087 : input[28] > 1e-35 ? input[194] > 1e-35 ? var72 = .0927536258129216 : var72 = .00806369969474508 : input[198] > 1e-35 ? var72 = .03402296877725087 : var72 = -.00033907517363096143 : input[194] > 1e-35 ? input[19] > 1e-35 ? var72 = -.16957712930341856 : input[28] > 1e-35 ? var72 = -.2078243840685859 : var72 = -.01982072284112783 : input[134] > 1e-35 ? var72 = -.059093837808976674 : input[155] > 1e-35 ? var72 = -.11429749518431415 : input[1] > 1e-35 ? input[123] > 1e-35 ? var72 = .04159085402090426 : var72 = -.0053579302271092874 : var72 = -.038428527597709254;
  let var73;
  input[2] > 2.249904835165133 ? input[53] > 1e-35 ? var73 = -.09149569302330776 : input[142] > 1e-35 ? var73 = -.020143603866796752 : input[29] > 1e-35 ? input[1] > 1e-35 ? input[4] > 2.740319461670996 ? input[0] > 1e-35 ? var73 = -.005838073295705989 : var73 = .0025448179376697196 : input[217] > 1e-35 ? var73 = .010391363152324442 : input[6] > 3.9219243190762363 ? input[7] > .9546729796082215 ? var73 = .00016709708501075782 : var73 = -.019274537854809464 : input[7] > .9717523368299734 ? input[2] > 4.848108675189105 ? var73 = .0038332904395533517 : input[141] > 1e-35 ? input[6] > 3.0677824455408698 ? var73 = -.12592300140122323 : var73 = -1.2073741246841418 : var73 = -.17682453022795175 : var73 = -.004373737265888883 : var73 = -.032810714691009164 : input[18] > 1e-35 ? var73 = -.024280045660709612 : input[156] > 1e-35 ? var73 = -.023509654115095334 : input[1] > 1e-35 ? input[141] > 1e-35 ? var73 = -.032438707623116556 : input[32] > 1e-35 ? var73 = -.061272201063817755 : var73 = .004415514992097752 : var73 = -.0017176659108089432 : input[0] > 1e-35 ? input[6] > 6.288787065535392 ? input[2] > .8958797346140276 ? var73 = .008680085548304642 : input[29] > 1e-35 ? var73 = .03767506445697859 : var73 = -.0007537359215762705 : input[4] > .8958797346140276 ? var73 = .0002799056937607271 : var73 = -.039667032027283916 : input[2] > 1.2424533248940002 ? var73 = .002506908961838236 : input[29] > 1e-35 ? input[7] > .950335336459789 ? var73 = .0027367426972748597 : var73 = -.021265206402010337 : input[30] > 1e-35 ? input[210] > 1e-35 ? var73 = -.03496264625173957 : var73 = -.007705718616493613 : input[138] > 1e-35 ? var73 = -.035840689909527164 : var73 = .0006855012949462712;
  let var74;
  input[2] > 5.418317700738354 ? input[5] > 6.0051201133541365 ? input[156] > 1e-35 ? var74 = -.024776046248283234 : var74 = -.004761578172448051 : input[8] > 1e-35 ? var74 = -.025343070913887773 : var74 = .012224469039913016 : input[150] > 1e-35 ? var74 = -.04079051452350429 : input[10] > 1e-35 ? input[152] > 1e-35 ? var74 = .019743419118584654 : input[186] > 1e-35 ? var74 = -.15575093795294756 : input[217] > 1e-35 ? var74 = .0056968023991711995 : var74 = -.004356449942923164 : input[5] > 6.0051201133541365 ? input[125] > 1e-35 ? var74 = -.01597803134795572 : input[151] > 1e-35 ? var74 = -.05058454115923059 : input[50] > 1e-35 ? var74 = -.03619853041443809 : input[49] > 1e-35 ? var74 = -.03261722685392842 : input[24] > 1e-35 ? var74 = .011909155984778505 : input[2] > 2.012675845367575 ? var74 = .0004933624031973823 : input[219] > 1e-35 ? var74 = .015579421213152617 : var74 = .002812703494519415 : input[113] > 1e-35 ? input[24] > 1e-35 ? var74 = .09675188599473092 : var74 = .0008025077587732017 : input[204] > 1e-35 ? input[9] > 1e-35 ? input[5] > 3.772694874805912 ? var74 = .02609533140492082 : input[29] > 1e-35 ? var74 = -.21256031284758028 : var74 = .09442590919716193 : var74 = -.004086903422513798 : input[24] > 1e-35 ? input[5] > 3.979637980058199 ? var74 = -.011071875945121415 : input[209] > 1e-35 ? var74 = -.19367443751378252 : var74 = -.04414838576908475 : input[178] > 1e-35 ? var74 = -.06538606241685795 : input[100] > 1e-35 ? input[5] > 3.772694874805912 ? var74 = -.01294941588968201 : input[5] > 2.673553765358735 ? var74 = .08150000027300734 : var74 = -.08989919051554107 : var74 = -.0032151101072856354;
  let var75;
  input[35] > 1e-35 ? var75 = -.05704221149718709 : input[91] > 1e-35 ? var75 = -.023832002943165256 : input[102] > 1e-35 ? var75 = .015441451551750014 : input[3] > 4.993822430271426 ? var75 = -.020159490027748073 : input[4] > 2.3502401828962087 ? input[144] > 1e-35 ? var75 = -.022873219553742163 : input[22] > 1e-35 ? var75 = -.01287591196884623 : input[47] > 1e-35 ? input[18] > 1e-35 ? var75 = .07657102696661595 : var75 = -.0243921910773003 : input[150] > 1e-35 ? var75 = -.043982850497096056 : input[138] > 1e-35 ? input[25] > 1e-35 ? var75 = -.03740348349716821 : var75 = .008237493112057112 : input[49] > 1e-35 ? var75 = -.03254806921800082 : input[53] > 1e-35 ? var75 = -.057370285686186163 : input[3] > 4.085941003063911 ? input[37] > 1e-35 ? var75 = -.04084726667137505 : input[155] > 1e-35 ? var75 = .0323666619020495 : var75 = -.0038866525930422893 : input[118] > 1e-35 ? input[18] > 1e-35 ? var75 = -.0975422096275863 : var75 = -.014038224866250074 : input[136] > 1e-35 ? var75 = -.03199938604211209 : var75 = .0014268928516615767 : input[99] > 1e-35 ? var75 = .018668567929263327 : input[5] > 7.334002872979111 ? input[156] > 1e-35 ? var75 = -.05380541629812827 : input[210] > 1e-35 ? input[30] > 1e-35 ? var75 = -.047112416583853595 : var75 = .00900546030963941 : input[208] > 1e-35 ? var75 = .02334424121914086 : input[158] > 1e-35 ? var75 = .04595592178250823 : var75 = -.006709820970668842 : input[204] > 1e-35 ? input[5] > 3.772694874805912 ? var75 = .009489783712825852 : input[3] > 2.249904835165133 ? var75 = .09999429949553015 : var75 = -.03961464289941561 : var75 = -.001190853283470586;
  let var76;
  input[39] > 1e-35 ? var76 = -.011391872842603505 : input[190] > 1e-35 ? var76 = -.021093147889461955 : input[51] > 1e-35 ? input[18] > 1e-35 ? var76 = .08723256651643213 : var76 = -.04233732133209843 : input[19] > 1e-35 ? var76 = .008078856044745801 : input[4] > .8958797346140276 ? input[60] > 1e-35 ? var76 = -.022165860715145688 : input[129] > 1e-35 ? input[3] > 3.314020688089767 ? var76 = .019990677612126993 : var76 = -.035520772730423776 : input[153] > 1e-35 ? input[2] > .8958797346140276 ? var76 = -.006946377120973384 : input[0] > 1e-35 ? input[8] > 1e-35 ? input[5] > 5.692045796563381 ? var76 = .04230611914121616 : var76 = -.1152833284663223 : var76 = .03987788751961305 : var76 = -.02748865099804465 : input[46] > 1e-35 ? input[18] > 1e-35 ? var76 = .047655531405650486 : var76 = -.022707509947190632 : input[18] > 1e-35 ? input[3] > .8958797346140276 ? input[31] > 1e-35 ? var76 = .1425984397283696 : input[143] > 1e-35 ? var76 = .05597721538261218 : var76 = -.02117927246804007 : var76 = .011077153043550766 : input[143] > 1e-35 ? var76 = -.0158979963012007 : input[187] > 1e-35 ? input[30] > 1e-35 ? var76 = .02515771028113912 : var76 = -.019084229614362958 : input[49] > 1e-35 ? input[1] > 1e-35 ? var76 = .014623537050735559 : var76 = -.05320125987679328 : input[58] > 1e-35 ? input[3] > 3.1132683346437333 ? var76 = .021421346835282216 : var76 = -.03287702034784505 : input[16] > 1e-35 ? var76 = .008645735809593434 : input[3] > 4.993822430271426 ? var76 = -.01889537207927676 : var76 = .00131546333396141 : input[153] > 1e-35 ? var76 = -.09822789507794744 : var76 = -.010292962989428067;
  let var77;
  input[11] > 1e-35 ? input[156] > 1e-35 ? input[4] > 3.1132683346437333 ? var77 = -.009153166060719259 : var77 = -.035386636811765286 : input[58] > 1e-35 ? var77 = -.03881024236774208 : input[153] > 1e-35 ? input[7] > .12645023619128054 ? var77 = -.01286680669029116 : var77 = -.0573874491021103 : input[3] > 3.276966702012906 ? input[38] > 1e-35 ? var77 = -.03084033316462023 : var77 = -.00517175216868761 : input[195] > 1e-35 ? var77 = .01773824295809578 : input[131] > 1e-35 ? var77 = -.17828043850421407 : var77 = .0005554487984838318 : input[7] > .14547530463198097 ? input[105] > 1e-35 ? var77 = -.018589129226123456 : input[116] > 1e-35 ? var77 = -.0227108777687536 : input[24] > 1e-35 ? var77 = .009520152980411787 : input[135] > 1e-35 ? var77 = -.004364970908897872 : input[0] > 1e-35 ? input[18] > 1e-35 ? var77 = -.015737703364129243 : var77 = .003711277180349787 : input[12] > 1e-35 ? input[4] > 3.540854293052788 ? input[155] > 1e-35 ? var77 = .04655165952772795 : var77 = .009321761971665682 : input[210] > 1e-35 ? var77 = .018839890489201528 : input[129] > 1e-35 ? var77 = -.03111680952187252 : var77 = .0002649813454447912 : input[23] > 1e-35 ? var77 = .014110539528977999 : input[109] > 1e-35 ? var77 = .014168740682742625 : var77 = -.0008607565404007093 : input[3] > 2.3502401828962087 ? input[9] > 1e-35 ? input[4] > 3.3842466058243152 ? var77 = -.004252607769147212 : var77 = .02017003996344357 : input[16] > 1e-35 ? var77 = .01594899805169211 : var77 = -.006372071796745688 : input[12] > 1e-35 ? var77 = -.0251011457777017 : input[121] > 1e-35 ? var77 = -.07822588279288774 : var77 = -.005026529762858;
  let var78;
  input[7] > .8375851232899904 ? input[155] > 1e-35 ? input[3] > 1.2424533248940002 ? var78 = .014982109981371684 : var78 = -.08302064203662592 : input[3] > 2.602003343538398 ? input[125] > 1e-35 ? var78 = -.02862612402789537 : var78 = -.0004831913476108919 : input[42] > 1e-35 ? var78 = -.08030278175390543 : input[90] > 1e-35 ? var78 = -.11931838045625616 : var78 = .003328726909052652 : input[125] > 1e-35 ? input[3] > 1e-35 ? var78 = -.03347653784336098 : var78 = .0381767649776156 : input[3] > 2.4414009612931857 ? input[3] > 3.1132683346437333 ? input[137] > 1e-35 ? var78 = .04078434374172937 : input[130] > 1e-35 ? var78 = .04811471469938318 : input[152] > 1e-35 ? var78 = .012079515899716571 : input[23] > 1e-35 ? var78 = .017817807971301534 : input[122] > 1e-35 ? var78 = .049338146544587284 : input[115] > 1e-35 ? var78 = .026905923036994708 : input[10] > 1e-35 ? var78 = -.008135082370740723 : input[89] > 1e-35 ? var78 = .023584069012120446 : input[95] > 1e-35 ? var78 = .013988944683250695 : var78 = -.002584756192745314 : input[139] > 1e-35 ? var78 = -.04454469703180858 : input[99] > 1e-35 ? input[3] > 2.524928003624769 ? var78 = .010620580427538877 : var78 = .047779724434429495 : input[131] > 1e-35 ? var78 = -.08155143867377633 : var78 = .0031488702256745843 : input[7] > .06275229375044648 ? input[99] > 1e-35 ? var78 = .016956254821045937 : input[90] > 1e-35 ? var78 = -.11685880917620971 : input[210] > 1e-35 ? input[11] > 1e-35 ? var78 = -.040607887814632475 : var78 = -.006287900824728332 : var78 = -.0018997472673294537 : input[14] > 1e-35 ? var78 = .02358706984105576 : var78 = -.01737075534918072;
  let var79;
  input[6] > 1e-35 ? input[2] > 5.4049245766661995 ? input[5] > 6.441743353550561 ? input[29] > 1e-35 ? input[4] > 2.673553765358735 ? var79 = -.007517267159018327 : var79 = -.02379463821120899 : var79 = -.0026543290628044274 : input[8] > 1e-35 ? var79 = -.022865480180725452 : var79 = .009005117181880752 : input[6] > 5.161920636569023 ? input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[2] > 2.012675845367575 ? input[3] > 2.3502401828962087 ? var79 = .0021573820428423146 : var79 = -.0046125093600082965 : input[3] > 3.314020688089767 ? var79 = -.005566488595229649 : input[6] > 6.288787065535392 ? var79 = .012796965207082116 : var79 = -.0023971957228440767 : input[3] > 2.249904835165133 ? input[2] > 1e-35 ? var79 = -.0003832411399288501 : input[1] > 1e-35 ? var79 = -.03148874544425103 : var79 = -.3158553329522586 : input[2] > 1e-35 ? var79 = .025981575700247922 : var79 = .052944809618023905 : input[6] > 8.681774988134558 ? input[3] > 2.970085626360216 ? var79 = -.0005280655103032829 : var79 = -.009402467452152188 : input[2] > .8958797346140276 ? var79 = .0018798828715775142 : input[3] > 1.7005986908310777 ? var79 = -.0002583719758369029 : var79 = -.014467497542301198 : input[128] > 1e-35 ? var79 = -.03075061856353219 : input[3] > 3.0201273556387074 ? input[8] > 1e-35 ? var79 = -.03107874404542307 : var79 = -.0063178690978266385 : input[113] > 1e-35 ? input[24] > 1e-35 ? var79 = .10168122236339333 : var79 = .0027676566086997536 : input[100] > 1e-35 ? input[3] > 1.4978661367769956 ? var79 = -.019182725682091863 : input[3] > 1.2424533248940002 ? var79 = .10007959215270637 : var79 = -.049901874168813753 : input[12] > 1e-35 ? var79 = -.008354674563617942 : var79 = .000556773623388255 : var79 = -.06338083699889271;
  let var80;
  input[14] > 1e-35 ? input[5] > 7.841296344941067 ? input[217] > 1e-35 ? var80 = -.03452197748259044 : input[141] > 1e-35 ? var80 = -.05526745933972476 : var80 = .003096257901065188 : var80 = .013468654879205778 : input[90] > 1e-35 ? var80 = -.04633994478668718 : input[7] > .04507521918085865 ? input[39] > 1e-35 ? var80 = -.011427282692256308 : input[188] > 1e-35 ? var80 = -.11824461537515621 : input[17] > 1e-35 ? input[5] > 3.276966702012906 ? var80 = .009014346731620665 : var80 = -.10784986305366669 : input[102] > 1e-35 ? var80 = .014356846380168074 : input[109] > 1e-35 ? var80 = .0100955463134877 : input[31] > 1e-35 ? var80 = .025672511171270042 : input[127] > 1e-35 ? var80 = -.10904631172619624 : input[19] > 1e-35 ? var80 = .007015456473363717 : input[60] > 1e-35 ? var80 = -.02409044800892067 : input[217] > 1e-35 ? input[7] > .9914949911911836 ? var80 = .02334115299069277 : input[1] > 1e-35 ? var80 = -29013080593250377e-21 : var80 = .014307421165143329 : input[1] > 1e-35 ? input[42] > 1e-35 ? var80 = -.06673983904970003 : input[37] > 1e-35 ? var80 = -.05636396687178933 : input[32] > 1e-35 ? var80 = -.042854874962508754 : input[140] > 1e-35 ? var80 = -.014546243613252019 : input[119] > 1e-35 ? var80 = .02592806792359847 : var80 = .0008331579108247542 : input[12] > 1e-35 ? var80 = .004348565717870661 : input[195] > 1e-35 ? var80 = -.016064193157584304 : input[210] > 1e-35 ? var80 = -.01896835246692864 : input[122] > 1e-35 ? var80 = .06415669138405272 : input[219] > 1e-35 ? var80 = -.03191239858069586 : var80 = -.0022170295258555585 : var80 = -.00965022020696389;
  let var81;
  input[55] > 1e-35 ? var81 = -.04649484416236924 : input[6] > 1e-35 ? input[35] > 1e-35 ? var81 = -.04814595674860986 : input[173] > 1e-35 ? var81 = -.030965289355370126 : input[190] > 1e-35 ? var81 = -.01892908615035444 : input[50] > 1e-35 ? var81 = -.03023310323845746 : input[14] > 1e-35 ? input[134] > 1e-35 ? var81 = .029102388421738776 : input[217] > 1e-35 ? var81 = -.021829759931582565 : var81 = .005209049556942947 : input[90] > 1e-35 ? input[3] > 3.276966702012906 ? var81 = .007482519637019732 : input[28] > 1e-35 ? var81 = .08823476156200263 : var81 = -.1134870648564767 : input[17] > 1e-35 ? input[5] > 3.156774023138548 ? input[3] > 2.861792550976191 ? input[134] > 1e-35 ? var81 = .037573808092493166 : var81 = -.008120569804875069 : var81 = .015185866424900767 : var81 = -.10150107137017012 : input[39] > 1e-35 ? var81 = -.011108691883331833 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var81 = -.019406534412652932 : input[22] > 1e-35 ? var81 = -.011646225036274034 : input[118] > 1e-35 ? input[1] > 1e-35 ? var81 = .007977856608752276 : var81 = -.038946271309380914 : var81 = .0009257226566265858 : input[101] > 1e-35 ? input[6] > 5.769881059461895 ? var81 = -.06484570063989317 : var81 = .016294764421436982 : input[29] > 1e-35 ? input[204] > 1e-35 ? input[5] > 5.859359688974663 ? var81 = .036329398743295674 : var81 = -.20474934656494398 : input[4] > 1.7005986908310777 ? var81 = -.0005630875641286038 : input[5] > 3.5694334999727624 ? input[19] > 1e-35 ? var81 = .03322386202318951 : var81 = -.01687696637036405 : var81 = -.10533305728771972 : var81 = -.0004901077590279651 : var81 = -.05758869249681345;
  let var82;
  input[57] > 1e-35 ? var82 = -.043478488738181505 : input[53] > 1e-35 ? var82 = -.05188532777589009 : input[11] > 1e-35 ? input[156] > 1e-35 ? var82 = -.01733439245316815 : input[58] > 1e-35 ? var82 = -.03508850349398082 : input[134] > 1e-35 ? input[38] > 1e-35 ? input[3] > 3.156774023138548 ? var82 = -.02641618586067251 : var82 = .0053883499998111746 : var82 = -.04111067521339709 : input[46] > 1e-35 ? var82 = -.03960880739147387 : input[56] > 1e-35 ? var82 = .02833430038101972 : input[3] > 4.548585836935273 ? var82 = -.028156779064728323 : var82 = -.0006287807275955149 : input[105] > 1e-35 ? var82 = -.018589321466431944 : input[187] > 1e-35 ? input[30] > 1e-35 ? var82 = .021938681282791916 : var82 = -.016917430307970042 : input[7] > .015258684697466883 ? input[132] > 1e-35 ? var82 = .026815659384164206 : input[204] > 1e-35 ? input[7] > .992067132663463 ? var82 = -.010565408217521758 : input[7] > .9738681190948303 ? input[9] > 1e-35 ? input[30] > 1e-35 ? var82 = .09345774314045512 : var82 = -.003460687191126055 : var82 = .009778848673591349 : var82 = .006207652194161698 : input[134] > 1e-35 ? input[14] > 1e-35 ? var82 = .026940863472122597 : var82 = .004032635910042969 : input[16] > 1e-35 ? input[156] > 1e-35 ? var82 = -.014571620220052964 : input[219] > 1e-35 ? var82 = .03394257525872151 : input[189] > 1e-35 ? var82 = -.16441255476933125 : var82 = .006890416623408193 : input[7] > .5866799179067689 ? input[156] > 1e-35 ? input[9] > 1e-35 ? var82 = -.002374233797129139 : var82 = .015343494638416642 : var82 = .0007085956801478842 : var82 = -.0014226167854637043 : var82 = -.014931890774210171;
  let var83;
  input[52] > 1e-35 ? var83 = -.040552145534119004 : input[88] > 1e-35 ? var83 = -.11616238297789526 : input[147] > 1e-35 ? input[21] > 1e-35 ? var83 = .08405882357263977 : var83 = -.028120036866471673 : input[89] > 1e-35 ? var83 = .013417411709807947 : input[138] > 1e-35 ? input[25] > 1e-35 ? var83 = -.03104795267483152 : input[8] > 1e-35 ? var83 = -.013793892541819341 : var83 = .007067793368543704 : input[3] > 4.212100162283537 ? input[37] > 1e-35 ? var83 = -.04169781427571004 : input[59] > 1e-35 ? var83 = .039366779099462186 : input[190] > 1e-35 ? var83 = -.0746572875957972 : var83 = -.0046665287028623895 : input[31] > 1e-35 ? input[3] > 3.3497501700808394 ? var83 = -.015043885860062665 : var83 = .04427790295514171 : input[127] > 1e-35 ? var83 = -.09222397003880911 : input[188] > 1e-35 ? var83 = -.11791399942046604 : input[116] > 1e-35 ? var83 = -.022670774074606673 : input[21] > 1e-35 ? input[118] > 1e-35 ? var83 = -.08590814127371893 : var83 = -.009079159755287763 : input[10] > 1e-35 ? input[153] > 1e-35 ? input[7] > .12025037553499339 ? var83 = -.010834658570263708 : var83 = -.06942979142484561 : input[59] > 1e-35 ? var83 = -.0368654965105411 : input[186] > 1e-35 ? var83 = -.13585047638050318 : var83 = -.001475385731000911 : input[11] > 1e-35 ? input[47] > 1e-35 ? var83 = -.07021793045868131 : input[58] > 1e-35 ? var83 = -.03264322466138671 : input[153] > 1e-35 ? input[7] > .4982752029697964 ? var83 = -.000719771928860618 : var83 = -.02550581685370434 : var83 = -.001300530189452872 : input[216] > 1e-35 ? var83 = -.04553949138490546 : var83 = .0013445292966782988;
  let var84;
  input[152] > 1e-35 ? var84 = .005642349825665321 : input[108] > 1e-35 ? input[1] > 1e-35 ? var84 = .012759171568581189 : var84 = -.0015650437871311187 : input[102] > 1e-35 ? var84 = .012533880283367552 : input[10] > 1e-35 ? input[4] > 1.4978661367769956 ? input[7] > .9888588760569341 ? var84 = .007453521083396632 : var84 = -.0036225862281260785 : input[3] > .8958797346140276 ? var84 = -.0027177080775155366 : input[5] > 5.782284349061034 ? var84 = -.04454373321655838 : var84 = .021964247026786614 : input[11] > 1e-35 ? input[47] > 1e-35 ? var84 = -.06196070580382676 : input[121] > 1e-35 ? input[1] > 1e-35 ? var84 = -.06122312462911518 : input[7] > .3847172300624272 ? var84 = .03518239795956787 : input[3] > 2.4414009612931857 ? var84 = .006811972713764457 : var84 = -.0933556055347465 : input[5] > 4.938058177869999 ? var84 = -.004012086267764631 : var84 = .01930669434547199 : input[5] > 6.0051201133541365 ? input[27] > 1e-35 ? var84 = -.012304580143719986 : var84 = .0013650712455989071 : input[3] > 2.802901033147999 ? var84 = -.0083470520183599 : input[7] > .5811983411966435 ? input[7] > .990877425524446 ? input[219] > 1e-35 ? input[3] > 1e-35 ? var84 = .06211865200552023 : input[17] > 1e-35 ? var84 = .06775644666502018 : var84 = -.06866304616688222 : input[217] > 1e-35 ? var84 = .059656960273077646 : var84 = -.004328630560280456 : input[204] > 1e-35 ? input[4] > 2.249904835165133 ? var84 = .006371564018556469 : input[3] > 2.138333059508028 ? var84 = .09486061534469152 : var84 = -.09409330595635478 : input[4] > 2.602003343538398 ? var84 = .011308844028341723 : input[100] > 1e-35 ? var84 = .0439316487073224 : var84 = -.003403233436702135 : var84 = -.00960652384005499;
  let var85;
  input[144] > 1e-35 ? input[18] > 1e-35 ? var85 = .07197995497453837 : input[1] > 1e-35 ? var85 = -.001274320993832369 : var85 = -.040032546534329444 : input[52] > 1e-35 ? input[18] > 1e-35 ? var85 = .09098124993319018 : var85 = -.04537404774072243 : input[40] > 1e-35 ? var85 = -.02515534903180516 : input[53] > 1e-35 ? var85 = -.04736675675905027 : input[178] > 1e-35 ? var85 = -.021374380471858013 : input[55] > 1e-35 ? var85 = -.04240162360893064 : input[51] > 1e-35 ? input[18] > 1e-35 ? var85 = .07999652271774131 : var85 = -.036649228565504045 : input[109] > 1e-35 ? var85 = .009067075019741765 : input[54] > 1e-35 ? input[1] > 1e-35 ? var85 = .019160818735605257 : var85 = -.05967997790089002 : input[35] > 1e-35 ? var85 = -.043420689526233285 : input[173] > 1e-35 ? var85 = -.027561163630755333 : input[190] > 1e-35 ? var85 = -.016370101115869642 : input[14] > 1e-35 ? input[217] > 1e-35 ? var85 = -.019735056448517897 : input[141] > 1e-35 ? var85 = -.028090004807030017 : var85 = .006865378253320941 : input[139] > 1e-35 ? input[1] > 1e-35 ? var85 = -.032389864623829076 : var85 = .005458607214221278 : input[60] > 1e-35 ? var85 = -.019089857559617188 : input[153] > 1e-35 ? input[18] > 1e-35 ? var85 = .015189336996079859 : input[19] > 1e-35 ? var85 = .013745154147527805 : input[1] > 1e-35 ? var85 = -.005284271350108698 : var85 = -.0374184512092477 : input[18] > 1e-35 ? input[99] > 1e-35 ? var85 = -.0595395395199616 : input[100] > 1e-35 ? var85 = -.09991342902311327 : var85 = -.0042488091801234805 : var85 = .0006682804828197052;
  let var86;
  input[46] > 1e-35 ? var86 = -.012191380765172536 : input[88] > 1e-35 ? var86 = -.10266216005056819 : input[91] > 1e-35 ? var86 = -.018445844031974568 : input[50] > 1e-35 ? var86 = -.027431707051961525 : input[144] > 1e-35 ? input[7] > .9945060383544003 ? var86 = .03614842925379388 : var86 = -.02095650990295711 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? input[3] > 3.0201273556387074 ? var86 = -.01053451990903616 : var86 = -.05114195197878968 : input[16] > 1e-35 ? var86 = .007316468830803533 : input[9] > 1e-35 ? var86 = .003316750172048933 : var86 = 860911526134492e-20 : input[141] > 1e-35 ? input[3] > 1e-35 ? var86 = -.02547358042212171 : var86 = .019472890771357998 : input[186] > 1e-35 ? var86 = -.09288424685816356 : input[41] > 1e-35 ? var86 = -.1310231930206974 : input[42] > 1e-35 ? var86 = -.056216247465863484 : input[29] > 1e-35 ? input[5] > 3.5694334999727624 ? input[134] > 1e-35 ? var86 = -.054747915129536466 : input[1] > 1e-35 ? input[131] > 1e-35 ? var86 = -.16815706432319097 : var86 = -.002818043413853223 : var86 = -.041951940639575136 : input[7] > .960816451500545 ? input[219] > 1e-35 ? var86 = .10052885656939581 : var86 = -.11599835225683999 : var86 = .029922858316313545 : input[101] > 1e-35 ? input[5] > 7.429817490674132 ? var86 = -.06576516230122952 : var86 = -.0008540865426696243 : input[210] > 1e-35 ? input[114] > 1e-35 ? var86 = .013062456952379193 : input[7] > .7267616382562012 ? var86 = .0022613700798703854 : var86 = -.03938763940013096 : input[59] > 1e-35 ? input[12] > 1e-35 ? var86 = .008501036224046256 : var86 = -.06542467236134167 : var86 = .002585754319607976;
  let var87;
  input[28] > 1e-35 ? var87 = .008779900390406317 : input[7] > .9880960409521241 ? input[8] > 1e-35 ? var87 = -.008991654120695218 : input[3] > 1e-35 ? input[140] > 1e-35 ? var87 = -.02731072195122447 : var87 = .002008744895602654 : input[217] > 1e-35 ? var87 = .02359361264236281 : var87 = .007024522001417586 : input[2] > 2.138333059508028 ? input[3] > 2.4414009612931857 ? input[125] > 1e-35 ? var87 = -.04199133736767654 : input[47] > 1e-35 ? var87 = -.027561033349225085 : input[3] > 4.085941003063911 ? input[12] > 1e-35 ? var87 = .007807873722550442 : input[152] > 1e-35 ? var87 = .030689318204494505 : input[137] > 1e-35 ? var87 = .06699720359975746 : var87 = -.010441301216813357 : input[118] > 1e-35 ? var87 = -.03153852460438172 : input[48] > 1e-35 ? var87 = -.03440026517387997 : var87 = .0015296602873888215 : input[0] > 1e-35 ? input[2] > 6.607325405747152 ? var87 = -.027110120892630915 : input[153] > 1e-35 ? var87 = -.017016088064422574 : var87 = -.005723165911539293 : input[187] > 1e-35 ? var87 = -.031718114891806884 : var87 = -.0005272212291525389 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[46] > 1e-35 ? var87 = -.09171631422683799 : var87 = .003327268948098216 : input[3] > 2.3502401828962087 ? input[125] > 1e-35 ? var87 = -.5887915327321841 : input[2] > 1e-35 ? var87 = -.006637502258168407 : var87 = -.08424468641004934 : input[125] > 1e-35 ? var87 = -.06617256968162606 : var87 = .028846174454930092 : input[2] > 1.2424533248940002 ? input[15] > 1e-35 ? var87 = -.016616715415331784 : var87 = .002680237807803091 : input[3] > 1e-35 ? var87 = -.0012589163812412535 : var87 = -.015154395987664649;
  let var88;
  input[6] > 9.286096980078398 ? input[4] > 2.970085626360216 ? var88 = -.001155963563974424 : var88 = -.011949331884445141 : input[6] > 6.3071868642287745 ? input[2] > 5.150393035655617 ? var88 = -.0033183579364470086 : input[11] > 1e-35 ? var88 = -.0018887492076874403 : input[169] > 1e-35 ? var88 = -.09486398911649394 : var88 = .0025252552927441433 : input[4] > 3.0677824455408698 ? input[7] > .09963982551990838 ? input[141] > 1e-35 ? input[6] > 3.314020688089767 ? var88 = .012137569190879735 : var88 = .09584425242224671 : input[8] > 1e-35 ? input[7] > .987306237235768 ? input[2] > .8958797346140276 ? var88 = -.020817404206469048 : var88 = -.06464699261956137 : var88 = -.008121005894366425 : var88 = -.002273798477153842 : input[4] > 3.5114340430413216 ? var88 = -.024199637055494112 : var88 = -.0044500308011184275 : input[12] > 1e-35 ? var88 = -.00483411782477681 : input[5] > 3.156774023138548 ? input[8] > 1e-35 ? input[5] > 3.772694874805912 ? input[6] > 3.795426061844291 ? var88 = .0013628724281773107 : var88 = -.04205266437322089 : input[141] > 1e-35 ? input[4] > 2.861792550976191 ? input[5] > 3.417592293073651 ? var88 = -.15445392240959782 : input[2] > 2.970085626360216 ? var88 = -.5683130345409004 : var88 = -1.2639522532467855 : var88 = -.12861577169349267 : var88 = -.08527127841498366 : input[4] > 2.4414009612931857 ? input[7] > .29163353806150266 ? var88 = .003881870206848933 : var88 = .01474849027472377 : input[18] > 1e-35 ? input[219] > 1e-35 ? var88 = -.07387984252991263 : var88 = -.013089382916580447 : var88 = -.0008129634296833813 : input[3] > 2.3502401828962087 ? input[2] > 3.1132683346437333 ? var88 = .019943967048858428 : var88 = -.04278248600927625 : input[17] > 1e-35 ? var88 = -.11809979934412335 : var88 = .03777084692378827;
  let var89;
  input[57] > 1e-35 ? var89 = -.03805766278012468 : input[6] > 9.286096980078398 ? input[2] > 3.725620842493839 ? var89 = -.010152097691926694 : var89 = -.000726856757223527 : input[25] > 1e-35 ? input[4] > 2.917405368531303 ? input[6] > 4.226807104886684 ? input[5] > 8.866229029069968 ? var89 = .016965184252348844 : var89 = -.027524673351863413 : var89 = -.09999982742666325 : input[219] > 1e-35 ? var89 = -.11642840619184194 : input[6] > 3.1984648276080736 ? var89 = .02202934385365115 : var89 = -.0758508504188626 : input[17] > 1e-35 ? input[5] > 3.276966702012906 ? input[3] > 2.861792550976191 ? input[38] > 1e-35 ? var89 = .03529859841404316 : var89 = -.005442656204983076 : var89 = .013832633319757828 : var89 = -.07099090377505678 : input[40] > 1e-35 ? input[12] > 1e-35 ? var89 = .020780509349314687 : var89 = -.0412229778697227 : input[178] > 1e-35 ? input[6] > 4.832297822126891 ? var89 = -.012751356404573045 : var89 = -.07365946414911166 : input[6] > 1e-35 ? input[91] > 1e-35 ? var89 = -.018973855754862178 : input[31] > 1e-35 ? input[3] > 3.3497501700808394 ? var89 = -.019342018507399077 : var89 = .04336755184633714 : input[52] > 1e-35 ? var89 = -.034601279556920723 : input[53] > 1e-35 ? var89 = -.04570921257037347 : input[4] > 2.4414009612931857 ? input[22] > 1e-35 ? var89 = -.009909029766665835 : input[88] > 1e-35 ? var89 = -.13759996623650647 : var89 = .0010774168904012999 : input[90] > 1e-35 ? var89 = -.09942790916464699 : input[5] > 8.17933999189099 ? var89 = -.006237804261380787 : input[154] > 1e-35 ? var89 = -.02869365685254793 : input[41] > 1e-35 ? var89 = -.11951308633255478 : var89 = .0005720279396045617 : var89 = -.05091927304878396;
  let var90;
  input[2] > 8.18910569469239 ? var90 = -.011281718118735835 : input[2] > 8.136957041085973 ? var90 = .007639929297282146 : input[2] > 6.178980383851587 ? var90 = -.006867711027875817 : input[6] > 4.5379471377116305 ? input[125] > 1e-35 ? input[3] > 1e-35 ? var90 = -.026657037414316055 : var90 = .03822052894720058 : input[89] > 1e-35 ? var90 = .01442240494610187 : var90 = .0005482931472826037 : input[3] > 2.970085626360216 ? input[8] > 1e-35 ? var90 = -.04157937378268839 : input[25] > 1e-35 ? var90 = -.07438346384769444 : var90 = -.007688780027797844 : input[113] > 1e-35 ? input[24] > 1e-35 ? var90 = .10208422768618285 : var90 = -.0025376848550412623 : input[24] > 1e-35 ? input[209] > 1e-35 ? input[7] > .9738681190948303 ? var90 = -.18081467351794253 : var90 = .06403272706376394 : var90 = -.006045919721112658 : input[100] > 1e-35 ? input[3] > 1.4978661367769956 ? var90 = -.034372452343283254 : input[3] > 1.2424533248940002 ? var90 = .10087241747333926 : var90 = -.06270133551905664 : input[12] > 1e-35 ? input[209] > 1e-35 ? var90 = .02872327658284419 : var90 = -.012940407270969699 : input[5] > 3.276966702012906 ? input[8] > 1e-35 ? var90 = -.02165149142042258 : input[3] > 2.249904835165133 ? var90 = .011522668417532612 : var90 = -.005129494488342788 : input[3] > 2.3502401828962087 ? input[2] > 3.1132683346437333 ? var90 = .018894357520732635 : var90 = -.03443967069634786 : input[19] > 1e-35 ? input[0] > 1e-35 ? var90 = .0868126244943877 : input[2] > 1.4978661367769956 ? input[194] > 1e-35 ? var90 = -.16834554324370338 : var90 = .08799302490518951 : var90 = .007907573815540844 : input[17] > 1e-35 ? var90 = -.07843101628051594 : var90 = .04322926522720053;
  let var91;
  input[7] > .987306237235768 ? input[8] > 1e-35 ? input[5] > 6.285066127789834 ? var91 = 6536595256810364e-20 : input[153] > 1e-35 ? var91 = -.07687008855803332 : var91 = -.015088524832702519 : input[18] > 1e-35 ? var91 = -.012556097563484098 : input[217] > 1e-35 ? input[5] > 8.28387302567733 ? var91 = -.004574660978375117 : var91 = .02566519458840368 : var91 = .003837771337656032 : input[28] > 1e-35 ? input[194] > 1e-35 ? input[29] > 1e-35 ? input[5] > 3.979637980058199 ? var91 = .04675774128546983 : var91 = -.16922871147253024 : input[5] > 5.821564412917691 ? var91 = .017788548280824237 : var91 = .101599048954043 : input[5] > 4.424828703319957 ? var91 = .009470487487627452 : var91 = -.046977132290520585 : input[95] > 1e-35 ? var91 = .008579165333164537 : input[204] > 1e-35 ? input[7] > .9782662069407232 ? input[9] > 1e-35 ? var91 = .0717824359443052 : var91 = .01776258010455891 : var91 = .003970948558978321 : input[208] > 1e-35 ? input[1] > 1e-35 ? var91 = .012428835257375037 : input[18] > 1e-35 ? var91 = -.08152843296689005 : var91 = -.0059907248803252305 : input[109] > 1e-35 ? var91 = .008117980905290326 : input[89] > 1e-35 ? input[1] > 1e-35 ? var91 = -.08097766993639294 : var91 = .014258345453663996 : input[62] > 1e-35 ? var91 = .025185598552042956 : input[213] > 1e-35 ? var91 = .01261362855232781 : input[138] > 1e-35 ? input[1] > 1e-35 ? input[29] > 1e-35 ? var91 = .004355449069502461 : var91 = -.03327693117307522 : input[29] > 1e-35 ? var91 = -.024228224306581475 : input[5] > 5.244385543610066 ? var91 = .01690188327986934 : var91 = -.02426164440751183 : var91 = -.0016932467092565535;
  let var92;
  input[116] > 1e-35 ? var92 = -.018106356667092538 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[5] > 4.658699722134796 ? var92 = -.0289267666661116 : var92 = .10225466717059267 : input[5] > 3.979637980058199 ? var92 = .007715497036238576 : input[209] > 1e-35 ? var92 = -.1596622066794057 : var92 = -.02153459011172981 : input[46] > 1e-35 ? input[18] > 1e-35 ? var92 = .044010040060630896 : var92 = -.018791912393741998 : input[39] > 1e-35 ? var92 = -.008648992983623099 : input[3] > 4.993822430271426 ? var92 = -.01442291433054286 : input[158] > 1e-35 ? var92 = .023944934429097977 : input[21] > 1e-35 ? var92 = -.008731676115726167 : input[51] > 1e-35 ? input[18] > 1e-35 ? var92 = .07015276907667169 : var92 = -.03981801316250594 : input[152] > 1e-35 ? input[12] > 1e-35 ? input[7] > .9811887196001154 ? var92 = .025342984951627335 : input[56] > 1e-35 ? var92 = -.039652717595259894 : var92 = -.003499774006708361 : input[4] > 3.676220550121792 ? var92 = .026612369959601385 : input[0] > 1e-35 ? input[2] > 2.012675845367575 ? var92 = .012259156005894655 : var92 = .04466570041636591 : var92 = .002369030228609974 : input[50] > 1e-35 ? var92 = -.02625338435100237 : input[198] > 1e-35 ? input[5] > 3.156774023138548 ? input[4] > 2.602003343538398 ? var92 = .004706524615587467 : var92 = .03172381727140614 : var92 = -.08877100979833137 : input[19] > 1e-35 ? input[156] > 1e-35 ? var92 = .047690620764284854 : var92 = .004980692597287184 : input[188] > 1e-35 ? var92 = -.10330323519600788 : input[108] > 1e-35 ? var92 = .006389080836282864 : input[217] > 1e-35 ? var92 = .0034861135133741716 : var92 = -.0005184951270632008;
  let var93;
  input[150] > 1e-35 ? var93 = -.03083355660591381 : input[6] > 8.681774988134558 ? input[0] > 1e-35 ? var93 = .0032708551521722813 : input[3] > 2.970085626360216 ? var93 = -.0008773771112515323 : var93 = -.008194765714031488 : input[1] > 1e-35 ? input[42] > 1e-35 ? var93 = -.0544661644610188 : input[114] > 1e-35 ? var93 = .014743200719322279 : input[25] > 1e-35 ? var93 = -.03415156332118204 : input[121] > 1e-35 ? input[0] > 1e-35 ? var93 = -.012241568524042012 : var93 = -.08332027167107449 : input[119] > 1e-35 ? var93 = .02487058944439717 : input[210] > 1e-35 ? input[4] > 2.602003343538398 ? var93 = .003409540133128587 : input[7] > .985694415330804 ? var93 = .014360134818665793 : var93 = -.029939754177999198 : input[140] > 1e-35 ? input[30] > 1e-35 ? var93 = -.07017324311241228 : var93 = -.00954038893956995 : input[32] > 1e-35 ? var93 = -.0321895511220355 : var93 = .0018389054792352236 : input[3] > .8958797346140276 ? input[138] > 1e-35 ? var93 = .014210083256713822 : input[3] > 2.970085626360216 ? input[56] > 1e-35 ? var93 = .03179391063657913 : input[132] > 1e-35 ? var93 = .044860161753142676 : input[122] > 1e-35 ? var93 = .056053352587009365 : input[44] > 1e-35 ? var93 = .011126140459263092 : input[217] > 1e-35 ? var93 = .015177735064648389 : input[30] > 1e-35 ? var93 = .00292550151642784 : input[0] > 1e-35 ? var93 = -.01370614277688821 : var93 = -.00467240699644943 : input[30] > 1e-35 ? input[17] > 1e-35 ? var93 = .06455607454604466 : var93 = -.018525791968354337 : input[127] > 1e-35 ? var93 = .058525937257934674 : var93 = .004550050432870272 : var93 = -.024273015893662056;
  let var94;
  input[57] > 1e-35 ? var94 = -.03433295479723807 : input[35] > 1e-35 ? var94 = -.039185287251387806 : input[2] > 8.18910569469239 ? var94 = -.01005594457537474 : input[2] > 8.136957041085973 ? var94 = .006899889609485921 : input[2] > 5.6542404955442525 ? input[156] > 1e-35 ? var94 = -.021428903659715646 : var94 = -.003794036359277691 : input[6] > 4.3882378946731615 ? input[125] > 1e-35 ? var94 = -.012625422706971806 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[32] > 1e-35 ? var94 = .024078606665492636 : input[6] > 6.9309832857755405 ? input[2] > 2.012675845367575 ? var94 = .00015676395930232578 : var94 = .008324926956588046 : var94 = -.0031526636810443134 : input[156] > 1e-35 ? var94 = .053603289446623514 : input[6] > 5.912149824839399 ? var94 = .022861200347258755 : input[128] > 1e-35 ? input[9] > 1e-35 ? var94 = -.44322676747225076 : var94 = -.07989645752877887 : var94 = .005736631305989689 : input[6] > 9.286096980078398 ? var94 = -.005302861539231229 : input[133] > 1e-35 ? var94 = -.011410750972764748 : input[2] > 1e-35 ? input[139] > 1e-35 ? var94 = -.01695599188677891 : input[12] > 1e-35 ? input[129] > 1e-35 ? var94 = -.029257180272820173 : input[106] > 1e-35 ? var94 = .03593102425808264 : input[59] > 1e-35 ? var94 = .03336711951593411 : input[114] > 1e-35 ? var94 = .021293721644930708 : var94 = .0031644417228525465 : input[140] > 1e-35 ? input[2] > 2.802901033147999 ? var94 = .005338088459754211 : var94 = -.018863893195455395 : input[59] > 1e-35 ? input[20] > 1e-35 ? var94 = -.2145461556048109 : var94 = -.013833058686928565 : var94 = .0010745795613665528 : var94 = -.003974960846380726 : var94 = -.004018386137909663;
  let var95;
  input[55] > 1e-35 ? var95 = -.038436881673730244 : input[49] > 1e-35 ? input[1] > 1e-35 ? var95 = .013340924551504776 : var95 = -.04038081752369706 : input[135] > 1e-35 ? input[17] > 1e-35 ? var95 = .02160784630817418 : input[6] > 4.722943345003718 ? input[2] > 3.9981586158983733 ? var95 = -.012347824466576033 : var95 = -.000545766507983511 : input[4] > 3.0201273556387074 ? input[2] > 1e-35 ? var95 = -.0252070573488502 : var95 = -.13173630032620282 : var95 = .009893647988200364 : input[6] > 1e-35 ? input[73] > 1e-35 ? var95 = -.05384174968342247 : input[52] > 1e-35 ? input[1] > 1e-35 ? var95 = .02326718288961822 : var95 = -.04799167043714381 : input[7] > .8453853180651066 ? input[4] > 3.481121732133104 ? input[12] > 1e-35 ? input[59] > 1e-35 ? var95 = .061286381265316374 : input[3] > 3.481121732133104 ? var95 = .005424469650470853 : input[6] > 4.310776603370241 ? var95 = .014609485744972962 : var95 = .06126754321077295 : input[156] > 1e-35 ? input[2] > 8.898092196194755 ? var95 = -.2427431056579565 : var95 = .018014774163852717 : var95 = .0018695162213364096 : input[61] > 1e-35 ? var95 = -.07802947082997094 : input[45] > 1e-35 ? var95 = -.024426413301391545 : input[140] > 1e-35 ? input[4] > .8958797346140276 ? var95 = -.021126260874271455 : input[6] > 4.03420147928485 ? var95 = -.08415757514826445 : input[3] > 1e-35 ? var95 = .10708927158160722 : var95 = -.24178647896179492 : var95 = .0008522369825914582 : input[218] > 1e-35 ? var95 = .02373187641553724 : input[57] > 1e-35 ? var95 = -.04729470896114382 : input[6] > 4.135134555718313 ? var95 = -.00014270136560779048 : var95 = -.007024429214918294 : var95 = -.08338039048086893;
  let var96;
  input[72] > 1e-35 ? var96 = .056415744834310104 : input[102] > 1e-35 ? var96 = .010312560108512227 : input[109] > 1e-35 ? var96 = .007457767681676636 : input[208] > 1e-35 ? input[4] > 3.0677824455408698 ? input[18] > 1e-35 ? var96 = -.06595581480202953 : var96 = .0010087955639505731 : var96 = .010976237400105874 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? input[2] > 4.5900436644025815 ? var96 = -.05474288807524913 : var96 = -.010369052951168002 : input[47] > 1e-35 ? input[18] > 1e-35 ? var96 = .06670108938458437 : input[20] > 1e-35 ? var96 = .08555144132474565 : var96 = -.021968528557862133 : input[48] > 1e-35 ? input[18] > 1e-35 ? var96 = .06392608504748652 : var96 = -.02321056177872842 : input[54] > 1e-35 ? var96 = -.03592967725793262 : input[6] > 5.519456907163478 ? var96 = .0008682946366782881 : input[133] > 1e-35 ? var96 = -.029370515479889298 : input[4] > 3.0201273556387074 ? var96 = -.004567764283497172 : input[12] > 1e-35 ? var96 = -.008355751724201374 : input[113] > 1e-35 ? var96 = .04158028065835193 : var96 = .005544170962219649 : input[141] > 1e-35 ? var96 = -.01706283616408152 : input[186] > 1e-35 ? var96 = -.08075713781164345 : input[196] > 1e-35 ? input[4] > 2.012675845367575 ? var96 = -.004591551989937031 : input[4] > .8958797346140276 ? input[18] > 1e-35 ? var96 = -.1239344826496822 : var96 = .026355647530608275 : var96 = -.07955511774996737 : input[41] > 1e-35 ? var96 = -.10181506412232362 : input[42] > 1e-35 ? var96 = -.0453542732395041 : input[116] > 1e-35 ? var96 = -.040407946567398226 : input[158] > 1e-35 ? var96 = .027239009428531448 : var96 = -.002118967070037752;
  let var97;
  input[174] > 1e-35 ? var97 = -.02339144841300339 : input[173] > 1e-35 ? var97 = -.02466576607302462 : input[60] > 1e-35 ? var97 = -.014400177078045 : input[187] > 1e-35 ? var97 = -.009580909976967153 : input[6] > 8.681774988134558 ? var97 = -.0018832004566674773 : input[1] > 1e-35 ? input[42] > 1e-35 ? input[10] > 1e-35 ? var97 = -.13287881120130746 : var97 = -.03759084751116859 : input[25] > 1e-35 ? var97 = -.029737667621816583 : input[119] > 1e-35 ? var97 = .022639692376110337 : input[98] > 1e-35 ? var97 = .014991063146855506 : input[195] > 1e-35 ? input[6] > 3.417592293073651 ? var97 = .008961268500787772 : var97 = -.023240187732927162 : input[61] > 1e-35 ? input[7] > .428769371249852 ? var97 = -.08413653233956772 : var97 = .0010489731231787087 : input[140] > 1e-35 ? input[3] > .8958797346140276 ? input[5] > 4.855921334140645 ? input[44] > 1e-35 ? var97 = -.009299863216357543 : var97 = -.0613782065666655 : var97 = -.06705655672927394 : input[5] > 3.772694874805912 ? var97 = .0008635593500817348 : var97 = .08361268069705163 : var97 = .001087642897550713 : input[98] > 1e-35 ? var97 = -.021712258264119783 : input[3] > .8958797346140276 ? input[105] > 1e-35 ? var97 = -.039681509263849626 : input[195] > 1e-35 ? input[18] > 1e-35 ? var97 = -.07079074829049314 : var97 = -.008109353986158243 : input[210] > 1e-35 ? input[18] > 1e-35 ? var97 = -.10610285355896108 : var97 = -.009292320249100847 : input[157] > 1e-35 ? var97 = .03507595269407085 : input[97] > 1e-35 ? var97 = .0249669535461336 : input[48] > 1e-35 ? var97 = -.027595291123779366 : var97 = .0011643902717306173 : var97 = -.0211420439263067;
  let var98;
  input[138] > 1e-35 ? input[1] > 1e-35 ? input[42] > 1e-35 ? input[3] > 3.5114340430413216 ? var98 = -.022448598781455772 : var98 = -.07031164685918086 : input[2] > 1e-35 ? input[2] > 2.740319461670996 ? var98 = .00894455632762117 : var98 = -.003454709734759444 : input[0] > 1e-35 ? var98 = .060858110677215166 : var98 = -.03435493609374257 : input[3] > 2.602003343538398 ? input[2] > .8958797346140276 ? var98 = .0168978378983998 : var98 = -.009237748165804088 : var98 = -.016931758267026403 : input[3] > 4.424828703319957 ? var98 = -.005659352703826067 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[6] > 4.460127707454046 ? var98 = -.023722482692479133 : var98 = .10064484300766507 : input[6] > 4.03420147928485 ? var98 = .007526717802235146 : input[209] > 1e-35 ? input[4] > 2.970085626360216 ? var98 = .11711852031495243 : var98 = -.15067622815741855 : var98 = -.011085192149895408 : input[108] > 1e-35 ? var98 = .0059255171206349135 : input[19] > 1e-35 ? input[156] > 1e-35 ? var98 = .04454460743043898 : input[37] > 1e-35 ? var98 = -.14161163738926447 : input[4] > 1.4978661367769956 ? input[4] > 1.7005986908310777 ? input[217] > 1e-35 ? var98 = -.020705364221039385 : var98 = .006460529078997639 : input[0] > 1e-35 ? input[98] > 1e-35 ? var98 = .10347448218504114 : var98 = -.04090123141769794 : input[6] > 5.636572136251498 ? var98 = -.001212671493834005 : input[2] > 1.8688348091416842 ? var98 = -.15821279618670178 : var98 = -.03563734739460456 : var98 = .027924859655082585 : input[57] > 1e-35 ? var98 = -.03743904649648422 : input[35] > 1e-35 ? var98 = -.0414066369468363 : input[46] > 1e-35 ? var98 = -.011240341460759123 : var98 = -.0003091959047563666;
  let var99;
  input[14] > 1e-35 ? input[5] > 7.841296344941067 ? input[141] > 1e-35 ? var99 = -.04382809259971909 : input[217] > 1e-35 ? input[4] > 3.417592293073651 ? var99 = -.05008164665262682 : var99 = .0007032387608254502 : input[190] > 1e-35 ? var99 = -.19371592847895003 : var99 = .0017489801221668277 : input[129] > 1e-35 ? var99 = -.24591656603456258 : var99 = .011026730387591234 : input[72] > 1e-35 ? var99 = .05658163433406649 : input[90] > 1e-35 ? input[4] > 3.5114340430413216 ? var99 = .017141361021852975 : input[28] > 1e-35 ? var99 = .07243997319099477 : var99 = -.08677988948169385 : input[138] > 1e-35 ? var99 = .0038201430289573884 : input[23] > 1e-35 ? input[4] > 2.917405368531303 ? var99 = .014990462643385919 : var99 = -.013592080985068531 : input[217] > 1e-35 ? input[4] > 1.8688348091416842 ? var99 = .0022421195021632245 : input[4] > 1.2424533248940002 ? var99 = .03891295508085918 : input[4] > .8958797346140276 ? var99 = -.08902318396862074 : var99 = .02476911275463073 : input[2] > 3.1132683346437333 ? input[29] > 1e-35 ? input[19] > 1e-35 ? var99 = .023731839695418987 : input[5] > 7.366761104104307 ? input[4] > 3.417592293073651 ? input[6] > 6.633975895571033 ? input[8] > 1e-35 ? var99 = .016171629088047517 : input[134] > 1e-35 ? var99 = .03196373735768742 : var99 = -.006820341969572339 : var99 = -.02712238491085242 : var99 = -.016309188486296804 : var99 = -.0019386576944297078 : input[156] > 1e-35 ? var99 = -.03079416196682616 : input[123] > 1e-35 ? var99 = -.020888866054988395 : input[4] > 3.238486181444842 ? var99 = -.0027078359220281674 : input[141] > 1e-35 ? var99 = -.029581214969996845 : var99 = .002299670778244013 : var99 = .0001804027795430786;
  let var100 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10 + var11 + var12 + var13 + var14 + var15 + var16 + var17 + var18 + var19 + var20 + var21 + var22 + var23 + var24 + var25 + var26 + var27 + var28 + var29 + var30 + var31 + var32 + var33 + var34 + var35 + var36 + var37 + var38 + var39 + var40 + var41 + var42 + var43 + var44 + var45 + var46 + var47 + var48 + var49 + var50 + var51 + var52 + var53 + var54 + var55 + var56 + var57 + var58 + var59 + var60 + var61 + var62 + var63 + var64 + var65 + var66 + var67 + var68 + var69 + var70 + var71 + var72 + var73 + var74 + var75 + var76 + var77 + var78 + var79 + var80 + var81 + var82 + var83 + var84 + var85 + var86 + var87 + var88 + var89 + var90 + var91 + var92 + var93 + var94 + var95 + var96 + var97 + var98 + var99);
  return [1 - var100, var100];
}
__name(treeScore, "treeScore");
function sigmoid(x) {
  if (x < 0) {
    let z = Math.exp(x);
    return z / (1 + z);
  }
  return 1 / (1 + Math.exp(-x));
}
__name(sigmoid, "sigmoid");
var ContextualFilterManager = class {
  static {
    __name(this, "ContextualFilterManager");
  }
  constructor() {
    this.previousLabel = 0, this.previousLabelTimestamp = Date.now() - 3600, this.probabilityAccept = 0;
  }
};
function getLastLineLength(source) {
  let lines = source.split(`
`);
  return lines[lines.length - 1].length;
}
__name(getLastLineLength, "getLastLineLength");
function contextualFilterScore(ctx, telemetryData, prompt, contextualFilterEnableTree) {
  let cfManager = ctx.get(ContextualFilterManager),
    yt_1 = cfManager.previousLabel,
    acw = 0;
  "afterCursorWhitespace" in telemetryData.properties && telemetryData.properties.afterCursorWhitespace === "true" && (acw = 1);
  let dt_1 = (Date.now() - cfManager.previousLabelTimestamp) / 1e3,
    ln_dt_1 = Math.log(1 + dt_1),
    ln_promptLastLineLength = 0,
    promptLastCharIndex = 0,
    promptPrefix = prompt.prefix;
  if (promptPrefix) {
    ln_promptLastLineLength = Math.log(1 + getLastLineLength(promptPrefix));
    let promptLastChar = promptPrefix.slice(-1);
    contextualFilterCharacterMap[promptLastChar] !== void 0 && (promptLastCharIndex = contextualFilterCharacterMap[promptLastChar]);
  }
  let ln_promptLastLineRstripLength = 0,
    promptLastRstripCharIndex = 0,
    promptPrefixRstrip = promptPrefix.trimEnd();
  if (promptPrefixRstrip) {
    ln_promptLastLineRstripLength = Math.log(1 + getLastLineLength(promptPrefixRstrip));
    let promptLastRstripChar = promptPrefixRstrip.slice(-1);
    contextualFilterCharacterMap[promptLastRstripChar] !== void 0 && (promptLastRstripCharIndex = contextualFilterCharacterMap[promptLastRstripChar]);
  }
  let ln_documentLength = 0;
  if ("documentLength" in telemetryData.measurements) {
    let documentLength = telemetryData.measurements.documentLength;
    ln_documentLength = Math.log(1 + documentLength);
  }
  let ln_promptEndPos = 0;
  if ("promptEndPos" in telemetryData.measurements) {
    let promptEndPos = telemetryData.measurements.promptEndPos;
    ln_promptEndPos = Math.log(1 + promptEndPos);
  }
  let relativeEndPos = 0;
  if ("promptEndPos" in telemetryData.measurements && "documentLength" in telemetryData.measurements) {
    let documentLength = telemetryData.measurements.documentLength;
    relativeEndPos = (telemetryData.measurements.promptEndPos + .5) / (1 + documentLength);
  }
  let languageIndex = 0;
  contextualFilterLanguageMap[telemetryData.properties.languageId] !== void 0 && (languageIndex = contextualFilterLanguageMap[telemetryData.properties.languageId]);
  let probabilityAccept = 0;
  if (contextualFilterEnableTree) {
    let features = new Array(221).fill(0);
    features[0] = yt_1, features[1] = acw, features[2] = ln_dt_1, features[3] = ln_promptLastLineLength, features[4] = ln_promptLastLineRstripLength, features[5] = ln_documentLength, features[6] = ln_promptEndPos, features[7] = relativeEndPos, features[8 + languageIndex] = 1, features[29 + promptLastCharIndex] = 1, features[125 + promptLastRstripCharIndex] = 1, probabilityAccept = treeScore(features)[1];
  } else {
    let sum = contextualFilterIntercept;
    sum += contextualFilterWeights[0] * yt_1, sum += contextualFilterWeights[1] * acw, sum += contextualFilterWeights[2] * ln_dt_1, sum += contextualFilterWeights[3] * ln_promptLastLineLength, sum += contextualFilterWeights[4] * ln_promptLastLineRstripLength, sum += contextualFilterWeights[5] * ln_documentLength, sum += contextualFilterWeights[6] * ln_promptEndPos, sum += contextualFilterWeights[7] * relativeEndPos, sum += contextualFilterWeights[8 + languageIndex], sum += contextualFilterWeights[29 + promptLastCharIndex], sum += contextualFilterWeights[125 + promptLastRstripCharIndex], probabilityAccept = 1 / (1 + Math.exp(-sum));
  }
  return ctx.get(ContextualFilterManager).probabilityAccept = probabilityAccept, probabilityAccept;
}
__name(contextualFilterScore, "contextualFilterScore");
var import_copilot_promptlib = Ns(Dc()),
  import_crypto_js = Ns(o8());
async function* asyncIterableMap(source, selector) {
  for await (let item of source) yield selector(item);
}
__name(asyncIterableMap, "asyncIterableMap");
async function* asyncIterableFilter(source, predicate) {
  for await (let item of source) (await predicate(item)) && (yield item);
}
__name(asyncIterableFilter, "asyncIterableFilter");
async function* asyncIterableMapFilter(source, selector) {
  for await (let item of source) {
    let result = await selector(item);
    result !== void 0 && (yield result);
  }
}
__name(asyncIterableMapFilter, "asyncIterableMapFilter");
async function* asyncIterableFromArray(source) {
  for (let item of source) yield item;
}
__name(asyncIterableFromArray, "asyncIterableFromArray");
var knownTemplateLanguageExtensions = [".ejs", ".erb", ".haml", ".hbs", ".j2", ".jinja", ".jinja2", ".liquid", ".mustache", ".njk", ".php", ".pug", ".slim", ".webc"],
  templateLanguageLimitations = {
    ".php": [".blade"]
  },
  knownFileExtensions = Object.keys(knownLanguages).flatMap(language => knownLanguages[language].extensions);
var path = require("path"),
  Language = class {
    constructor(languageId, isGuess, fileExtension) {
      this.languageId = languageId;
      this.isGuess = isGuess;
      this.fileExtension = fileExtension;
    }
    static {
      __name(this, "Language");
    }
  },
  LanguageDetection = class {
    static {
      __name(this, "LanguageDetection");
    }
  };
function primeLanguageDetectionCache(ctx, doc) {
  ctx.get(LanguageDetection).detectLanguage(doc);
}
__name(primeLanguageDetectionCache, "primeLanguageDetectionCache");
function getLanguageDetection(ctx) {
  return new CachingLanguageDetection(new FilenameAndExensionLanguageDetection(), new NotebookLanguageDetection(ctx));
}
__name(getLanguageDetection, "getLanguageDetection");
var CachingLanguageDetection = class extends LanguageDetection {
  constructor(delegate, notebookDelegate) {
    super();
    this.delegate = delegate;
    this.notebookDelegate = notebookDelegate;
    this.cache = new LRUCacheMap(100);
  }
  static {
    __name(this, "CachingLanguageDetection");
  }
  async detectLanguage(doc) {
    let filename = path.basename(doc.uri.path);
    return isNotebook(filename) ? this.notebookDelegate.detectLanguage(doc) : this.detectLanguageForRegularFile(filename, doc);
  }
  async detectLanguageForRegularFile(filename, doc) {
    let language = this.cache.get(filename);
    return language || (language = await this.delegate.detectLanguage(doc), language.isGuess || this.cache.set(filename, language)), language;
  }
};
function isNotebook(filename) {
  return filename.endsWith(".ipynb");
}
__name(isNotebook, "isNotebook");
var NotebookLanguageDetection = class extends LanguageDetection {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "NotebookLanguageDetection");
    }
    async detectLanguage(doc) {
      let notebook = this.ctx.get(TextDocumentManager).findNotebook(doc);
      return notebook ? this.detectCellLanguage(doc, notebook) : new Language("python", !1, ".ipynb");
    }
    detectCellLanguage(doc, notebook) {
      let activeCell = notebook.getCells().find(cell => cell.document.uri.toString() === doc.uri.toString());
      if (activeCell) {
        let metadata = activeCell.metadata;
        return metadata?.custom?.metadata?.vscode?.languageId ? new Language(metadata.custom.metadata.vscode.languageId, !1, ".ipynb") : activeCell.kind === 2 ? new Language("python", !1, ".ipynb") : new Language("markdown", !1, ".ipynb");
      }
      return new Language("unknown", !1, ".ipynb");
    }
  },
  FilenameAndExensionLanguageDetection = class extends LanguageDetection {
    constructor() {
      super(...arguments);
      this.languageIdByExtensionTracker = new LanguageIdTracker();
    }
    static {
      __name(this, "FilenameAndExensionLanguageDetection");
    }
    async detectLanguage(doc) {
      let filename = path.basename(doc.uri.path),
        extension = path.extname(filename).toLowerCase(),
        extensionWithoutTemplate = this.extensionWithoutTemplateLanguage(filename, extension),
        languageIdWithGuessing = this.detectLanguageId(filename, extensionWithoutTemplate);
      return new Language(languageIdWithGuessing.languageId, languageIdWithGuessing.isGuess, this.computeFullyQualifiedExtension(extension, extensionWithoutTemplate));
    }
    extensionWithoutTemplateLanguage(filename, extension) {
      if (knownTemplateLanguageExtensions.includes(extension)) {
        let filenameWithoutExtension = filename.substring(0, filename.lastIndexOf(".")),
          extensionWithoutTemplate = path.extname(filenameWithoutExtension).toLowerCase();
        if (extensionWithoutTemplate.length > 0 && knownFileExtensions.includes(extensionWithoutTemplate) && this.isExtensionValidForTemplateLanguage(extension, extensionWithoutTemplate)) return extensionWithoutTemplate;
      }
      return extension;
    }
    isExtensionValidForTemplateLanguage(extension, extensionWithoutTemplate) {
      let limitations = templateLanguageLimitations[extension];
      return !limitations || limitations.includes(extensionWithoutTemplate);
    }
    detectLanguageId(filename, extension) {
      let candidatesByExtension = [];
      for (let language in knownLanguages) {
        let info = knownLanguages[language];
        if (info.filenames && info.filenames.includes(filename)) return {
          languageId: language,
          isGuess: !1
        };
        info.extensions.includes(extension) && candidatesByExtension.push(language);
      }
      return this.determineLanguageIdByCandidates(candidatesByExtension);
    }
    determineLanguageIdByCandidates(candidates) {
      return candidates.length === 1 ? (this.languageIdByExtensionTracker.track(candidates[0]), {
        languageId: candidates[0],
        isGuess: !1
      }) : candidates.length > 1 ? this.determineMostSeenLanguages(candidates) : {
        languageId: "unknown",
        isGuess: !0
      };
    }
    determineMostSeenLanguages(candidates) {
      let mostSeenLanguageId = this.languageIdByExtensionTracker.mostRecentLanguageId(candidates);
      return mostSeenLanguageId ? {
        languageId: mostSeenLanguageId,
        isGuess: !0
      } : {
        languageId: candidates[0],
        isGuess: !0
      };
    }
    computeFullyQualifiedExtension(extension, extensionWithoutTemplate) {
      return extension !== extensionWithoutTemplate ? extensionWithoutTemplate + extension : extension;
    }
  },
  LanguageIdTracker = class {
    constructor() {
      this.seenLanguages = new LRUCacheMap(25);
    }
    static {
      __name(this, "LanguageIdTracker");
    }
    track(languageId) {
      this.seenLanguages.set(languageId, this.preciseTimestamp());
    }
    preciseTimestamp() {
      return process.hrtime.bigint();
    }
    mostRecentLanguageId(candidates) {
      let mostRecentIds = candidates.map(languageId => ({
        id: languageId,
        seen: this.seenLanguages.get(languageId)
      })).filter(candidate => candidate.seen).sort((a, b) => Number(b.seen) - Number(a.seen)).map(candidate => candidate.id);
      if (mostRecentIds.length > 0) return mostRecentIds[0];
    }
  };
var OPENAI_PROXY_HOST = "https://copilot-proxy.githubusercontent.com";
var V1_ENGINES_COPILOT_CODEX = "/v1/engines/copilot-codex";
function _getOverrideProxyURL(ctx) {
  return isRunningInTest(ctx) ? getConfig(ctx, ConfigKey.DebugTestOverrideProxyUrl) : getConfig(ctx, ConfigKey.DebugOverrideProxyUrl);
}
__name(_getOverrideProxyURL, "_getOverrideProxyURL");
function getProxyURLWithPath(ctx, path) {
  let proxyUrl = _getOverrideProxyURL(ctx);
  return proxyUrl.length == 0 && (proxyUrl = OPENAI_PROXY_HOST), `${proxyUrl}${path}`;
}
__name(getProxyURLWithPath, "getProxyURLWithPath");
async function _getEnginePath(ctx, repoNwo, fileType, dogFood, userKind, customModel, retrievalOrg, telemetryData) {
  let engineOverride = getConfig(ctx, ConfigKey.DebugOverrideEngine);
  if (engineOverride) return `/v1/engines/${engineOverride}`;
  let customEngine = await ctx.get(Features).customEngine({
    repoNwo: repoNwo,
    fileType: fileType,
    userKind: userKind,
    dogFood: dogFood,
    customModel: customModel,
    retrievalOrg: retrievalOrg
  }, telemetryData);
  return customEngine !== "" ? `/v1/engines/${customEngine}` : V1_ENGINES_COPILOT_CODEX;
}
__name(_getEnginePath, "_getEnginePath");
async function getEngineURL(ctx, nwo, fileType, dogfood, userKind, customModel, retrievalOrg, telemetryData) {
  return getProxyURLWithPath(ctx, await _getEnginePath(ctx, nwo, fileType, dogfood, userKind, customModel, retrievalOrg, telemetryData));
}
__name(getEngineURL, "getEngineURL");
var util = Ns(require("util"));
var StatusReporter = class {
  static {
    __name(this, "StatusReporter");
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_git_url_parse = Ns(Kee()),
  import_path = require("path"),
  import_vscode_uri = Ns(B1());
async function getUserKind(ctx) {
  let orgs = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).organization_list ?? [];
  return ["a5db0bcaae94032fe715fb34a5e4bce2", "7184f66dfcee98cb5f08a1cb936d5225", "4535c7beffc844b46bb1ed4aa04d759a"].find(org => orgs.includes(org)) ?? "";
}
__name(getUserKind, "getUserKind");
async function getFtFlag(ctx) {
  return (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).getTokenValue("ft") ?? "";
}
__name(getFtFlag, "getFtFlag");
async function getRagFlag(ctx) {
  return (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).getTokenValue("rag") ?? "";
}
__name(getRagFlag, "getRagFlag");
function getDogFood(repoInfo) {
  if (repoInfo === void 0 || repoInfo === 0) return "";
  let ghnwo = tryGetGitHubNWO(repoInfo);
  if (ghnwo === "github/github") return ghnwo;
  let adoNwo = tryGetADONWO(repoInfo)?.toLowerCase();
  return adoNwo !== void 0 ? adoNwo : "";
}
__name(getDogFood, "getDogFood");
function tryGetGitHubNWO(repoInfo) {
  if (repoInfo !== void 0 && repoInfo !== 0 && repoInfo.hostname === "github.com") return repoInfo.owner + "/" + repoInfo.repo;
}
__name(tryGetGitHubNWO, "tryGetGitHubNWO");
function tryGetADONWO(repoInfo) {
  if (repoInfo !== void 0 && repoInfo !== 0 && (repoInfo.hostname.endsWith("azure.com") || repoInfo.hostname.endsWith("visualstudio.com"))) return repoInfo.owner + "/" + repoInfo.repo;
}
__name(tryGetADONWO, "tryGetADONWO");
function extractRepoInfoInBackground(ctx, uri) {
  let baseFolder = Yee.Utils.dirname(uri);
  return backgroundRepoInfo(ctx, baseFolder);
}
__name(extractRepoInfoInBackground, "extractRepoInfoInBackground");
var backgroundRepoInfo = computeInBackgroundAndMemoize(extractRepoInfo, 1e4);
async function extractRepoInfo(ctx, uri) {
  if (uri.scheme !== "file") return;
  let baseFolder = await getRepoBaseFolder(ctx, uri.fsPath);
  if (!baseFolder) return;
  let fs = ctx.get(xO.FileSystem),
    configPath = (0, Z4.join)(baseFolder, ".git", "config"),
    gitConfig;
  try {
    gitConfig = await fs.readFile(configPath);
  } catch {
    return;
  }
  let url = getRepoUrlFromConfigText(gitConfig.toString()) ?? "",
    parsedResult = parseRepoUrl(url);
  return parsedResult === void 0 ? {
    baseFolder: baseFolder,
    url: url,
    hostname: "",
    owner: "",
    repo: "",
    pathname: ""
  } : {
    baseFolder: baseFolder,
    url: url,
    ...parsedResult
  };
}
__name(extractRepoInfo, "extractRepoInfo");
function parseRepoUrl(url) {
  let parsedUrl = {};
  try {
    if (parsedUrl = (0, Xee.GitUrlParse)(url), parsedUrl.host == "" || parsedUrl.owner == "" || parsedUrl.name == "" || parsedUrl.pathname == "") return;
  } catch {
    return;
  }
  return {
    hostname: parsedUrl.host,
    owner: parsedUrl.owner,
    repo: parsedUrl.name,
    pathname: parsedUrl.pathname
  };
}
__name(parseRepoUrl, "parseRepoUrl");
async function getRepoBaseFolder(ctx, uri) {
  let previousUri = uri + "_add_to_make_longer",
    fs = ctx.get(xO.FileSystem);
  for (; uri.length > 1 && uri.length < previousUri.length;) {
    let configPath = (0, Z4.join)(uri, ".git", "config"),
      result = !1;
    try {
      await fs.stat(configPath), result = !0;
    } catch {
      result = !1;
    }
    if (result) return uri;
    previousUri = uri, uri = (0, Z4.dirname)(uri);
  }
}
__name(getRepoBaseFolder, "getRepoBaseFolder");
function getRepoUrlFromConfigText(gitConfig) {
  let remoteSectionRegex = /^\s*\[\s*remote\s+"((\\\\|\\"|[^\\"])+)"/,
    deprecatedRemoteSectionRegex = /^\s*\[remote.([^"\s]+)/,
    setUrlRegex = /^\s*url\s*=\s*([^\s#;]+)/,
    newSectionRegex = /^\s*\[/,
    remoteUrl,
    remoteSection,
    isWithinMultilineUrl = !1;
  for (let line of gitConfig.split(`
`)) if (isWithinMultilineUrl && remoteUrl !== void 0) {
    if (remoteUrl += line, line.endsWith("\\")) remoteUrl = remoteUrl.substring(0, remoteUrl.length - 1);else if (isWithinMultilineUrl = !1, remoteSection === "origin") return remoteUrl;
  } else {
    let remoteSectionMatch = line.match(remoteSectionRegex) ?? line.match(deprecatedRemoteSectionRegex);
    if (remoteSectionMatch) remoteSection = remoteSectionMatch[1];else if (line.match(newSectionRegex)) remoteSection = void 0;else {
      if (remoteUrl && remoteSection !== "origin") continue;
      {
        let urlMatch = line.match(setUrlRegex);
        if (urlMatch) {
          if (remoteUrl = urlMatch[1], remoteUrl.endsWith("\\")) remoteUrl = remoteUrl.substring(0, remoteUrl.length - 1), isWithinMultilineUrl = !0;else if (remoteSection === "origin") return remoteUrl;
        }
      }
    }
  }
  return remoteUrl;
}
__name(getRepoUrlFromConfigText, "getRepoUrlFromConfigText");
var CompletedComputation = class {
  static {
    __name(this, "CompletedComputation");
  }
  constructor(result) {
    this.result = result;
  }
};
function computeInBackgroundAndMemoize(fct, cacheSize) {
  let resultsCache = new LRUCacheMap(cacheSize),
    inComputation = new Set();
  return (ctx, ...args) => {
    let key = JSON.stringify(args),
      memorizedComputation = resultsCache.get(key);
    if (memorizedComputation) return memorizedComputation.result;
    if (inComputation.has(key)) return 0;
    let computation = fct(ctx, ...args);
    return inComputation.add(key), computation.then(computedResult => {
      resultsCache.set(key, new CompletedComputation(computedResult)), inComputation.delete(key);
    }), 0;
  };
}
__name(computeInBackgroundAndMemoize, "computeInBackgroundAndMemoize");
function convertToAPIChoice(ctx, completionText, jsonData, choiceIndex, requestId, blockFinished, telemetryData, modelInfo) {
  return logEngineCompletion(ctx, completionText, jsonData, requestId, choiceIndex), {
    completionText: completionText,
    meanLogProb: calculateMeanLogProb(ctx, jsonData),
    meanAlternativeLogProb: calculateMeanAlternativeLogProb(ctx, jsonData),
    choiceIndex: choiceIndex,
    requestId: requestId,
    modelInfo: modelInfo,
    blockFinished: blockFinished,
    tokens: jsonData.tokens,
    numTokens: jsonData.tokens.length,
    telemetryData: telemetryData
  };
}
__name(convertToAPIChoice, "convertToAPIChoice");
async function* cleanupIndentChoices(choices, indentation) {
  for await (let choice of choices) {
    let choiceCopy = {
        ...choice
      },
      completionLines = choiceCopy.completionText.split(`
`);
    for (let i = 0; i < completionLines.length; ++i) {
      let newLine = completionLines[i].trimLeft();
      newLine === "" ? completionLines[i] = newLine : completionLines[i] = indentation + newLine;
    }
    choiceCopy.completionText = completionLines.join(`
`), yield choiceCopy;
  }
}
__name(cleanupIndentChoices, "cleanupIndentChoices");
function calculateMeanLogProb(ctx, jsonData) {
  if (jsonData?.logprobs?.token_logprobs) try {
    let logProbSum = 0,
      numTokens = 0,
      iterLimit = 50;
    for (let i = 0; i < jsonData.logprobs.token_logprobs.length - 1 && iterLimit > 0; i++, iterLimit--) logProbSum += jsonData.logprobs.token_logprobs[i], numTokens += 1;
    return numTokens > 0 ? logProbSum / numTokens : void 0;
  } catch (e) {
    logger.exception(ctx, e, "Error calculating mean prob");
  }
}
__name(calculateMeanLogProb, "calculateMeanLogProb");
function calculateMeanAlternativeLogProb(ctx, jsonData) {
  if (jsonData?.logprobs?.top_logprobs) try {
    let logProbSum = 0,
      numTokens = 0,
      iterLimit = 50;
    for (let i = 0; i < jsonData.logprobs.token_logprobs.length - 1 && iterLimit > 0; i++, iterLimit--) {
      let options = {
        ...jsonData.logprobs.top_logprobs[i]
      };
      delete options[jsonData.logprobs.tokens[i]], logProbSum += Math.max(...Object.values(options)), numTokens += 1;
    }
    return numTokens > 0 ? logProbSum / numTokens : void 0;
  } catch (e) {
    logger.exception(ctx, e, "Error calculating mean prob");
  }
}
__name(calculateMeanAlternativeLogProb, "calculateMeanAlternativeLogProb");
function getTemperatureForSamples(ctx, numShots) {
  if (isRunningInTest(ctx)) return 0;
  let configTemp = parseFloat(getConfig(ctx, ConfigKey.Temperature));
  return configTemp >= 0 && configTemp <= 1 ? configTemp : numShots <= 1 ? 0 : numShots < 10 ? .2 : numShots < 20 ? .4 : .8;
}
__name(getTemperatureForSamples, "getTemperatureForSamples");
var streamChoicesLogger = new Logger(1, "streamChoices"),
  APIJsonDataStreaming = class {
    constructor() {
      this.logprobs = [];
      this.top_logprobs = [];
      this.text = [];
      this.tokens = [];
      this.text_offset = [];
    }
    static {
      __name(this, "APIJsonDataStreaming");
    }
    append(choice) {
      choice.text && this.text.push(choice.text), choice.delta?.content && this.text.push(choice.delta.content), choice.logprobs && (this.tokens.push(choice.logprobs.tokens ?? []), this.text_offset.push(choice.logprobs.text_offset ?? []), this.logprobs.push(choice.logprobs.token_logprobs ?? []), this.top_logprobs.push(choice.logprobs.top_logprobs ?? []));
    }
  };
function splitChunk(chunk) {
  let dataLines = chunk.split(`
`),
    newExtra = dataLines.pop();
  return [dataLines.filter(line => line != ""), newExtra];
}
__name(splitChunk, "splitChunk");
var SSEProcessor = class _SSEProcessor {
  constructor(ctx, expectedNumChoices, response, body, telemetryData, dropCompletionReasons, fastCancellation, cancellationToken) {
    this.ctx = ctx;
    this.expectedNumChoices = expectedNumChoices;
    this.response = response;
    this.body = body;
    this.telemetryData = telemetryData;
    this.dropCompletionReasons = dropCompletionReasons;
    this.fastCancellation = fastCancellation;
    this.cancellationToken = cancellationToken;
    this.requestId = getRequestId(this.response);
    this.stats = new ChunkStats(this.expectedNumChoices);
    this.solutions = {};
  }
  static {
    __name(this, "SSEProcessor");
  }
  static async create(ctx, expectedNumChoices, response, telemetryData, dropCompletionReasons, cancellationToken) {
    let body = await response.body();
    body.setEncoding("utf8");
    let fastCancellation = await ctx.get(Features).fastCancellation();
    return new _SSEProcessor(ctx, expectedNumChoices, response, body, telemetryData, dropCompletionReasons ?? ["content_filter"], fastCancellation, cancellationToken);
  }
  async *processSSE(finishedCb = async () => {}) {
    try {
      yield* this.processSSEInner(finishedCb);
    } finally {
      this.fastCancellation && this.cancel(), streamChoicesLogger.info(this.ctx, `request done: headerRequestId: [${this.requestId.headerRequestId}] model deployment ID: [${this.requestId.deploymentId}]`), streamChoicesLogger.debug(this.ctx, `request stats: ${this.stats}`);
    }
  }
  async *processSSEInner(finishedCb) {
    let extraData = "";
    networkRead: for await (let chunk of this.body) {
      if (this.maybeCancel("after awaiting body chunk")) return;
      streamChoicesLogger.debug(this.ctx, "chunk", chunk.toString());
      let [dataLines, remainder] = splitChunk(extraData + chunk.toString());
      extraData = remainder;
      for (let dataLine of dataLines) {
        let lineWithoutData = dataLine.slice(5).trim();
        if (lineWithoutData == "[DONE]") {
          yield* this.finishSolutions();
          return;
        }
        let json;
        try {
          json = JSON.parse(lineWithoutData);
        } catch {
          streamChoicesLogger.error(this.ctx, "Error parsing JSON stream data", dataLine);
          continue;
        }
        if (json.choices === void 0) {
          json.error !== void 0 ? streamChoicesLogger.error(this.ctx, "Error in response:", json.error.message) : streamChoicesLogger.error(this.ctx, "Unexpected response with no choices or error: " + lineWithoutData);
          continue;
        }
        if (this.requestId.created == 0 && (this.requestId = getRequestId(this.response, json), this.requestId.created == 0 && streamChoicesLogger.error(this.ctx, `Request id invalid, should have "completionId" and "created": ${this.requestId}`, this.requestId)), this.allSolutionsDone() && this.fastCancellation) break networkRead;
        for (let i = 0; i < json.choices.length; i++) {
          let choice = json.choices[i];
          streamChoicesLogger.debug(this.ctx, "choice", choice), this.stats.add(choice.index), choice.index in this.solutions || (this.solutions[choice.index] = new APIJsonDataStreaming());
          let solution = this.solutions[choice.index];
          if (solution == null) continue;
          solution.append(choice);
          let finishOffset,
            hasNewLine = choice.text?.indexOf(`
`) > -1 || choice.delta?.content?.indexOf(`
`) > -1;
          if ((choice.finish_reason || hasNewLine) && (finishOffset = await finishedCb(solution.text.join("")), this.maybeCancel("after awaiting finishedCb"))) return;
          if (!(choice.finish_reason || finishOffset !== void 0)) continue;
          let loggedReason = choice.finish_reason ?? "client-trimmed";
          if (telemetry(this.ctx, "completion.finishReason", this.telemetryData.extendedBy({
            completionChoiceFinishReason: loggedReason
          })), this.dropCompletionReasons.includes(choice.finish_reason) ? this.solutions[choice.index] = null : (this.stats.markYielded(choice.index), yield {
            solution: solution,
            finishOffset: finishOffset,
            reason: choice.finish_reason,
            requestId: this.requestId,
            index: choice.index
          }), this.maybeCancel("after yielding finished choice")) return;
          this.solutions[choice.index] = null;
        }
      }
    }
    for (let [index, solution] of Object.entries(this.solutions)) {
      let solutionIndex = Number(index);
      if (solution != null && (this.stats.markYielded(solutionIndex), yield {
        solution: solution,
        finishOffset: void 0,
        reason: "Iteration Done",
        requestId: this.requestId,
        index: solutionIndex
      }, this.maybeCancel("after yielding after iteration done"))) return;
    }
    if (extraData.length > 0) try {
      let extraDataJson = JSON.parse(extraData);
      extraDataJson.error !== void 0 && streamChoicesLogger.error(this.ctx, `Error in response: ${extraDataJson.error.message}`, extraDataJson.error);
    } catch {
      streamChoicesLogger.error(this.ctx, `Error parsing extraData: ${extraData}`);
    }
  }
  async *finishSolutions() {
    for (let [index, solution] of Object.entries(this.solutions)) {
      let solutionIndex = Number(index);
      if (solution != null && (this.stats.markYielded(solutionIndex), yield {
        solution: solution,
        finishOffset: void 0,
        reason: "DONE",
        requestId: this.requestId,
        index: solutionIndex
      }, this.maybeCancel("after yielding on DONE"))) return;
    }
  }
  maybeCancel(description) {
    return this.cancellationToken?.isCancellationRequested ? (streamChoicesLogger.debug(this.ctx, "Cancelled: " + description), this.cancel(), !0) : !1;
  }
  cancel() {
    this.body.destroy();
  }
  allSolutionsDone() {
    let solutions = Object.values(this.solutions);
    return solutions.length == this.expectedNumChoices && solutions.every(s => s == null);
  }
};
function prepareSolutionForReturn(ctx, c, telemetryData) {
  let completionText = c.solution.text.join(""),
    blockFinished = !1;
  c.finishOffset !== void 0 && (streamChoicesLogger.debug(ctx, `solution ${c.index}: early finish at offset ${c.finishOffset}`), completionText = completionText.substring(0, c.finishOffset), blockFinished = !0), streamChoicesLogger.info(ctx, `solution ${c.index} returned. finish reason: [${c.reason}]`), streamChoicesLogger.debug(ctx, `solution ${c.index} details: finishOffset: [${c.finishOffset}] completionId: [{${c.requestId.completionId}}] created: [{${c.requestId.created}}]`);
  let jsonData = convertToAPIJsonData(ctx, c.solution);
  return convertToAPIChoice(ctx, completionText, jsonData, c.index, c.requestId, blockFinished, telemetryData);
}
__name(prepareSolutionForReturn, "prepareSolutionForReturn");
function convertToAPIJsonData(ctx, streamingData) {
  let out = {
    text: streamingData.text.join(""),
    tokens: streamingData.text
  };
  if (streamingData.logprobs.length === 0) return out;
  let flattenedLogprobs = streamingData.logprobs.reduce((acc, cur) => acc.concat(cur), []),
    flattenedTopLogprobs = streamingData.top_logprobs.reduce((acc, cur) => acc.concat(cur), []),
    flattenedOffsets = streamingData.text_offset.reduce((acc, cur) => acc.concat(cur), []),
    flattenedTokens = streamingData.tokens.reduce((acc, cur) => acc.concat(cur), []);
  return {
    ...out,
    logprobs: {
      token_logprobs: flattenedLogprobs,
      top_logprobs: flattenedTopLogprobs,
      text_offset: flattenedOffsets,
      tokens: flattenedTokens
    }
  };
}
__name(convertToAPIJsonData, "convertToAPIJsonData");
var ChunkStats = class {
    constructor(expectedNumChoices) {
      this.choices = new Map();
      for (let i = 0; i < expectedNumChoices; i++) this.choices.set(i, new ChoiceStats());
    }
    static {
      __name(this, "ChunkStats");
    }
    add(choiceIndex) {
      this.choices.get(choiceIndex).increment();
    }
    markYielded(choiceIndex) {
      this.choices.get(choiceIndex).markYielded();
    }
    toString() {
      return Array.from(this.choices.entries()).map(([index, stats]) => `${index}: ${stats.yieldedTokens} -> ${stats.seenTokens}`).join(", ");
    }
  },
  ChoiceStats = class {
    constructor() {
      this.yieldedTokens = -1;
      this.seenTokens = 0;
    }
    static {
      __name(this, "ChoiceStats");
    }
    increment() {
      this.seenTokens++;
    }
    markYielded() {
      this.yieldedTokens = this.seenTokens;
    }
  };
var fetchLogger = new Logger(1, "fetch");
function getRequestId(response, json) {
  return {
    headerRequestId: response.headers.get("x-request-id") || "",
    completionId: json && json.id ? json.id : "",
    created: json && json.created ? json.created : 0,
    serverExperiments: response.headers.get("X-Copilot-Experiment") || "",
    deploymentId: response.headers.get("azureml-model-deployment") || ""
  };
}
__name(getRequestId, "getRequestId");
function getProcessingTime(response) {
  let reqIdStr = response.headers.get("openai-processing-ms");
  return reqIdStr ? parseInt(reqIdStr, 10) : 0;
}
__name(getProcessingTime, "getProcessingTime");
function extractEngineName(ctx, engineUrl) {
  let engineName = engineUrl.split("/").pop();
  return engineName || (fetchLogger.error(ctx, "Malformed engine URL: " + engineUrl), engineUrl);
}
__name(extractEngineName, "extractEngineName");
function uiKindToIntent(uiKind) {
  switch (uiKind) {
    case "ghostText":
      return "copilot-ghost";
    case "synthesize":
      return "copilot-panel";
  }
}
__name(uiKindToIntent, "uiKindToIntent");
var OpenAIFetcher = class {
  static {
    __name(this, "OpenAIFetcher");
  }
};
function fetchWithInstrumentation(ctx, prompt, engineUrl, endpoint, ourRequestId, request, secretKey, uiKind, cancel, telemetryProperties) {
  let statusReporter = ctx.get(StatusReporter),
    uri = tte.format("%s/%s", engineUrl, endpoint);
  if (!secretKey) {
    logger.error(ctx, `Failed to send request to ${uri} due to missing key`);
    return;
  }
  let telemetryData = TelemetryData.createAndMarkAsIssued({
    endpoint: endpoint,
    engineName: extractEngineName(ctx, engineUrl),
    uiKind: uiKind
  }, telemetrizePromptLength(prompt));
  telemetryProperties && (telemetryData = telemetryData.extendedBy(telemetryProperties));
  for (let [key, value] of Object.entries(request)) key == "prompt" || key == "suffix" || (telemetryData.properties[`request.option.${key}`] = JSON.stringify(value) ?? "undefined");
  telemetryData.properties.headerRequestId = ourRequestId, telemetry(ctx, "request.sent", telemetryData);
  let requestStart = now(),
    intent = uiKindToIntent(uiKind);
  return postRequest(ctx, uri, secretKey, intent, ourRequestId, request, cancel).then(response => {
    let modelRequestId = getRequestId(response, void 0);
    telemetryData.extendWithRequestId(modelRequestId);
    let totalTimeMs = now() - requestStart;
    return telemetryData.measurements.totalTimeMs = totalTimeMs, logger.info(ctx, `request.response: [${uri}] took ${totalTimeMs} ms`), logger.debug(ctx, "request.response properties", telemetryData.properties), logger.debug(ctx, "request.response measurements", telemetryData.measurements), logger.debug(ctx, `prompt: ${JSON.stringify(prompt)}`), telemetry(ctx, "request.response", telemetryData), response;
  }).catch(error => {
    if (isAbortError(error)) throw error;
    statusReporter.setWarning(error.message);
    let warningTelemetry = telemetryData.extendedBy({
      error: "Network exception"
    });
    telemetry(ctx, "request.shownWarning", warningTelemetry), telemetryData.properties.message = String(error.name ?? ""), telemetryData.properties.code = String(error.code ?? ""), telemetryData.properties.errno = String(error.errno ?? ""), telemetryData.properties.type = String(error.type ?? "");
    let totalTimeMs = now() - requestStart;
    throw telemetryData.measurements.totalTimeMs = totalTimeMs, logger.debug(ctx, `request.response: [${uri}] took ${totalTimeMs} ms`), logger.debug(ctx, "request.error properties", telemetryData.properties), logger.debug(ctx, "request.error measurements", telemetryData.measurements), telemetry(ctx, "request.error", telemetryData), error;
  }).finally(() => {
    logEnginePrompt(ctx, prompt, telemetryData);
  });
}
__name(fetchWithInstrumentation, "fetchWithInstrumentation");
function postProcessChoices(choices, allowEmptyChoices) {
  return allowEmptyChoices ?? !1 ? choices : asyncIterableFilter(choices, async choice => choice.completionText.trim().length > 0);
}
__name(postProcessChoices, "postProcessChoices");
var LiveOpenAIFetcher = class extends OpenAIFetcher {
  static {
    __name(this, "LiveOpenAIFetcher");
  }
  async fetchAndStreamCompletions(ctx, params, baseTelemetryData, finishedCb, cancel, telemetryProperties) {
    let statusReporter = ctx.get(StatusReporter),
      endpoint = "completions",
      response = await this.fetchWithParameters(ctx, endpoint, params, cancel, telemetryProperties);
    if (response === "not-sent") return {
      type: "canceled",
      reason: "before fetch request"
    };
    if (cancel?.isCancellationRequested) {
      let body = await response.body();
      try {
        body.destroy();
      } catch (e) {
        logger.exception(ctx, e, "Error destroying stream");
      }
      return {
        type: "canceled",
        reason: "after fetch request"
      };
    }
    if (response === void 0) {
      let telemetryData = this.createTelemetryData(endpoint, ctx, params);
      return statusReporter.setWarning(), telemetryData.properties.error = "Response was undefined", telemetry(ctx, "request.shownWarning", telemetryData), {
        type: "failed",
        reason: "fetch response was undefined"
      };
    }
    if (response.status !== 200) {
      let telemetryData = this.createTelemetryData(endpoint, ctx, params);
      return this.handleError(ctx, statusReporter, telemetryData, response);
    }
    let dropCompletionReasons = await ctx.get(Features).dropCompletionReasons(),
      finishedCompletions = (await SSEProcessor.create(ctx, params.count, response, baseTelemetryData, dropCompletionReasons, cancel)).processSSE(finishedCb),
      choices = asyncIterableMap(finishedCompletions, async solution => prepareSolutionForReturn(ctx, solution, baseTelemetryData));
    return {
      type: "success",
      choices: postProcessChoices(choices, params.allowEmptyChoices),
      getProcessingTime: () => getProcessingTime(response)
    };
  }
  createTelemetryData(endpoint, ctx, params) {
    return TelemetryData.createAndMarkAsIssued({
      endpoint: endpoint,
      engineName: extractEngineName(ctx, params.engineUrl),
      uiKind: params.uiKind,
      headerRequestId: params.ourRequestId
    });
  }
  async fetchWithParameters(ctx, endpoint, params, cancel, telemetryProperties) {
    let stops = getLanguageConfig(ctx, ConfigKey.Stops),
      disableLogProb = await ctx.get(Features).disableLogProb(),
      request = {
        prompt: params.prompt.prefix,
        suffix: params.prompt.suffix,
        max_tokens: getConfig(ctx, ConfigKey.SolutionLength),
        temperature: getTemperatureForSamples(ctx, params.count),
        top_p: getConfig(ctx, ConfigKey.TopP),
        n: params.count,
        stop: stops
      };
    (params.requestLogProbs || !disableLogProb) && (request.logprobs = 2);
    let githubNWO = tryGetGitHubNWO(params.repoInfo);
    return githubNWO !== void 0 && (request.nwo = githubNWO), params.postOptions && Object.assign(request, params.postOptions), cancel?.isCancellationRequested ? "not-sent" : (logger.info(ctx, `[fetchCompletions] engine ${params.engineUrl}`), await fetchWithInstrumentation(ctx, params.prompt, params.engineUrl, endpoint, params.ourRequestId, request, (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token, params.uiKind, cancel, telemetryProperties));
  }
  async handleError(ctx, statusReporter, telemetryData, response) {
    if (statusReporter.setWarning(), telemetryData.properties.error = `Response status was ${response.status}`, telemetryData.properties.status = String(response.status), telemetry(ctx, "request.shownWarning", telemetryData), response.status === 401 || response.status === 403) return ctx.get(CopilotTokenManager).resetCopilotToken(ctx, response.status), {
      type: "failed",
      reason: `token expired or invalid: ${response.status}`
    };
    if (response.status === 499) return fetchLogger.info(ctx, "Cancelled by server"), {
      type: "failed",
      reason: "canceled by server"
    };
    let text = await response.text();
    return response.status === 466 ? (statusReporter.setError(text), fetchLogger.info(ctx, text), {
      type: "failed",
      reason: `client not supported: ${text}`
    }) : (fetchLogger.error(ctx, "Unhandled status from server:", response.status, text), {
      type: "failed",
      reason: `unhandled status from server: ${response.status} ${text}`
    });
  }
};
var LocationFactory = class {
  static {
    __name(this, "LocationFactory");
  }
};
var promptlib = Ns(Dc());
var worker = null,
  handlers = new Map(),
  nextHandlerId = 0;
function init(ctx, use_worker_threads, logger) {
  if (!use_worker_threads) {
    let localPromptlib = (uL(), nT(Pre));
    for (let fn of allFuns) updatePromptLibProxyFunction(fn, localPromptlib[fn]);
    return;
  }
  for (let fn of workerFuns) updatePromptLibProxyFunction(fn, proxy(ctx, logger, fn));
  promptLibProxy.getPrompt = getPromptProxy(ctx, logger), worker = X0.createWorker(), handlers.clear(), nextHandlerId = 0, worker.on("message", ({
    id: id,
    err: err,
    code: code,
    res: res
  }) => {
    let handler = handlers.get(id);
    logger.debug(ctx, `Response ${id} - ${res}, ${err}`), handler && (handlers.delete(id), err ? (err.code = code, handler.reject(err)) : handler.resolve(res));
  });
  function handleError(maybeError) {
    let err;
    if (maybeError instanceof Error) {
      err = maybeError, err.code === "MODULE_NOT_FOUND" && err.message?.endsWith("worker.js'") && (err = new Error("Failed to load worker.js"), err.code = "CopilotPromptLoadFailure");
      let ourStack = new Error().stack;
      err.stack && ourStack?.match(/^Error\n/) && (err.stack += ourStack.replace(/^Error/, ""));
    } else maybeError?.name === "ExitStatus" && typeof maybeError.status == "number" ? (err = new Error(`worker.js exited with status ${maybeError.status}`), err.code = `CopilotPromptWorkerExit${maybeError.status}`) : err = new Error(`Non-error thrown: ${maybeError}`);
    for (let handler of handlers.values()) handler.reject(err);
    handlers.clear();
  }
  __name(handleError, "handleError"), worker.on("error", handleError);
}
__name(init, "init");
function terminate() {
  worker && (worker.removeAllListeners(), worker.terminate(), worker = null, handlers.clear());
}
__name(terminate, "terminate");
var workerFuns = ["getFunctionPositions", "isEmptyBlockStart", "isBlockBodyFinished", "getNodeStart", "getCallSites", "parsesWithoutError"],
  directFuns = ["isSupportedLanguageId", "getBlockCloseToken", "getPrompt"],
  allFuns = [...workerFuns, ...directFuns];
function proxy(ctx, logger, fn) {
  return function (...args) {
    let id = nextHandlerId++;
    return new Promise((resolve, reject) => {
      handlers.set(id, {
        resolve: resolve,
        reject: reject
      }), logger.debug(ctx, `Proxy ${fn}`), worker?.postMessage({
        id: id,
        fn: fn,
        args: args
      });
    });
  };
}
__name(proxy, "proxy");
function getPromptProxy(ctx, logger) {
  return function (_fileSystem, ...args) {
    let id = nextHandlerId++;
    return new Promise((resolve, reject) => {
      handlers.set(id, {
        resolve: resolve,
        reject: reject
      }), logger.debug(ctx, `Proxy getPrompt - ${id}`), worker?.postMessage({
        id: id,
        fn: "getPrompt",
        args: args
      });
    });
  };
}
__name(getPromptProxy, "getPromptProxy");
function updatePromptLibProxyFunction(fn, impl) {
  promptLibProxy[fn] = impl;
}
__name(updatePromptLibProxyFunction, "updatePromptLibProxyFunction");
var promptLibProxy = {
  isEmptyBlockStart: X0.isEmptyBlockStart,
  isBlockBodyFinished: X0.isBlockBodyFinished,
  isSupportedLanguageId: X0.isSupportedLanguageId,
  getBlockCloseToken: X0.getBlockCloseToken,
  getFunctionPositions: X0.getFunctionPositions,
  getNodeStart: X0.getNodeStart,
  getPrompt: X0.getPrompt,
  getCallSites: X0.getCallSites,
  parsesWithoutError: X0.parsesWithoutError
};
function isEmptyBlockStart(doc, position) {
  return promptLibProxy.isEmptyBlockStart(doc.languageId, doc.getText(), doc.offsetAt(position));
}
__name(isEmptyBlockStart, "isEmptyBlockStart");
function parsingBlockFinished(ctx, doc, position) {
  let locationFactory = ctx.get(LocationFactory),
    prefix = doc.getText(locationFactory.range(locationFactory.position(0, 0), position)),
    offset = doc.offsetAt(position),
    languageId = doc.languageId;
  return completion => promptLibProxy.isBlockBodyFinished(languageId, prefix, completion, offset);
}
__name(parsingBlockFinished, "parsingBlockFinished");
async function getNodeStart(ctx, doc, position, completion) {
  let locationFactory = ctx.get(LocationFactory),
    text = doc.getText(locationFactory.range(locationFactory.position(0, 0), position)) + completion,
    offset = await promptLibProxy.getNodeStart(doc.languageId, text, doc.offsetAt(position));
  if (offset) return doc.positionAt(offset);
}
__name(getNodeStart, "getNodeStart");
var continuations = ["\\{", "\\}", "\\[", "\\]", "\\(", "\\)"].concat(["then", "else", "elseif", "elif", "catch", "finally", "fi", "done", "end", "loop", "until", "where", "when"].map(s => s + "\\b")),
  continuationRegex = new RegExp(`^(${continuations.join("|")})`);
function isContinuationLine(line) {
  return continuationRegex.test(line.trimLeft().toLowerCase());
}
__name(isContinuationLine, "isContinuationLine");
function indentationOfLine(line) {
  let match = /^(\s*)([^]*)$/.exec(line);
  if (match && match[2] && match[2].length > 0) return match[1].length;
}
__name(indentationOfLine, "indentationOfLine");
function contextIndentation(doc, position) {
  let source = doc.getText(),
    offset = doc.offsetAt(position);
  return contextIndentationFromText(source, offset, doc.languageId);
}
__name(contextIndentation, "contextIndentation");
function contextIndentationFromText(source, offset, languageId) {
  let prevLines = source.slice(0, offset).split(`
`),
    nextLines = source.slice(offset).split(`
`);
  function seekNonBlank(lines, start, direction) {
    let i = start,
      ind,
      indIdx;
    for (; ind === void 0 && i >= 0 && i < lines.length;) ind = indentationOfLine(lines[i]), indIdx = i, i += direction;
    if (languageId === "python" && direction === -1) {
      i++;
      let trimmedLine = lines[i].trim();
      if (trimmedLine.endsWith('"""')) {
        if (!(trimmedLine.startsWith('"""') && trimmedLine !== '"""')) for (i--; i >= 0 && !lines[i].trim().startsWith('"""');) i--;
        if (i >= 0) for (ind = void 0, i--; ind === void 0 && i >= 0;) ind = indentationOfLine(lines[i]), indIdx = i, i--;
      }
    }
    return [ind, indIdx];
  }
  __name(seekNonBlank, "seekNonBlank");
  let [current, currentIdx] = seekNonBlank(prevLines, prevLines.length - 1, -1),
    prev = (() => {
      if (!(current === void 0 || currentIdx === void 0)) for (let i = currentIdx - 1; i >= 0; i--) {
        let ind = indentationOfLine(prevLines[i]);
        if (ind !== void 0 && ind < current) return ind;
      }
    })(),
    [next] = seekNonBlank(nextLines, 1, 1);
  return {
    prev: prev,
    current: current ?? 0,
    next: next
  };
}
__name(contextIndentationFromText, "contextIndentationFromText");
var OfferNextLineCompletion = !1;
function completionCutOrContinue(completion, contextIndentation, previewText) {
  let completionLines = completion.split(`
`),
    isContinuation = previewText !== void 0,
    lastLineOfPreview = previewText?.split(`
`).pop(),
    startLine = 0;
  if (isContinuation && lastLineOfPreview?.trim() != "" && completionLines[0].trim() !== "" && startLine++, !isContinuation && OfferNextLineCompletion && completionLines[0].trim() === "" && startLine++, isContinuation || startLine++, completionLines.length === startLine) return "continue";
  let breakIndentation = Math.max(contextIndentation.current, contextIndentation.next ?? 0);
  for (let i = startLine; i < completionLines.length; i++) {
    let line = completionLines[i];
    i == 0 && lastLineOfPreview !== void 0 && (line = lastLineOfPreview + line);
    let ind = indentationOfLine(line);
    if (ind !== void 0 && (ind < breakIndentation || ind === breakIndentation && !isContinuationLine(line))) return completionLines.slice(0, i).join(`
`).length;
  }
  return "continue";
}
__name(completionCutOrContinue, "completionCutOrContinue");
function indentationBlockFinished(contextIndentation, previewText) {
  return async completion => {
    let res = completionCutOrContinue(completion, contextIndentation, previewText);
    return res === "continue" ? void 0 : res;
  };
}
__name(indentationBlockFinished, "indentationBlockFinished");
var import_copilot_promptlib = Ns(Dc());
function telemetryShown(ctx, insertionCategory, telemetryData, fromCache) {
  telemetryData.markAsDisplayed();
  let eventName = fromCache ? `${insertionCategory}.shownFromCache` : `${insertionCategory}.shown`;
  telemetry(ctx, eventName, telemetryData);
}
__name(telemetryShown, "telemetryShown");
function telemetryAccepted(ctx, insertionCategory, telemetryData) {
  let telemetryName = insertionCategory + ".accepted",
    cfManager = ctx.get(ContextualFilterManager);
  cfManager.previousLabel = 1, cfManager.previousLabelTimestamp = Date.now(), telemetry(ctx, telemetryName, telemetryData);
}
__name(telemetryAccepted, "telemetryAccepted");
function telemetryRejected(ctx, insertionCategory, telemetryData) {
  let telemetryName = insertionCategory + ".rejected",
    cfManager = ctx.get(ContextualFilterManager);
  cfManager.previousLabel = 0, cfManager.previousLabelTimestamp = Date.now(), telemetry(ctx, telemetryName, telemetryData);
}
__name(telemetryRejected, "telemetryRejected");
function mkCanceledResultTelemetry(telemetryBlob, extraFlags = {}) {
  return {
    ...extraFlags,
    telemetryBlob: telemetryBlob
  };
}
__name(mkCanceledResultTelemetry, "mkCanceledResultTelemetry");
function mkBasicResultTelemetry(telemetryBlob) {
  let result = {
    headerRequestId: telemetryBlob.properties.headerRequestId,
    copilot_trackingId: telemetryBlob.properties.copilot_trackingId
  };
  return telemetryBlob.properties.sku !== void 0 && (result.sku = telemetryBlob.properties.sku), telemetryBlob.properties.organizations_list !== void 0 && (result.organizations_list = telemetryBlob.properties.organizations_list), telemetryBlob.properties.enterprise_list !== void 0 && (result.enterprise_list = telemetryBlob.properties.enterprise_list), result;
}
__name(mkBasicResultTelemetry, "mkBasicResultTelemetry");
async function handleGhostTextResultTelemetry(ctx, result) {
  if (result.type === "success") return telemetryRaw(ctx, "ghostText.produced", result.telemetryData, {}), result.value;
  if (result.type !== "abortedBeforeIssued") {
    if (result.type === "canceled") {
      telemetry(ctx, "ghostText.canceled", result.telemetryData.telemetryBlob.extendedBy({
        reason: result.reason,
        cancelledNetworkRequest: result.telemetryData.cancelledNetworkRequest ? "true" : "false"
      }));
      return;
    }
    telemetryRaw(ctx, `ghostText.${result.type}`, {
      ...result.telemetryData,
      reason: result.reason
    }, {});
  }
}
__name(handleGhostTextResultTelemetry, "handleGhostTextResultTelemetry");
var POLICY_ENDPOINT = "https://repositorypolicy.azurewebsites.net/GetPolicy/v1";
var NOT_BLOCKED_RESPONSE = {
    isBlocked: !1,
    reason: "VALID_FILE"
  },
  NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE = {
    isBlocked: !1,
    reason: "NO_MATCHING_POLICY"
  },
  BLOCKED_REPO_RESPONSE = {
    isBlocked: !0,
    reason: "REPO_BLOCKED",
    message: "Your organization has disabled Copilot for this repository"
  },
  BLOCKED_FILE_RESPONSE = {
    isBlocked: !0,
    reason: "FILE_BLOCKED",
    message: "Your organization has disabled Copilot for this file"
  },
  BLOCKED_POLICY_ERROR_RESPONSE = {
    isBlocked: !0,
    reason: "POLICY_ERROR",
    message: "Copilot is disabled because we could not fetch the repository policy"
  };
var PolicyEvaluator = class {
  static {
    __name(this, "PolicyEvaluator");
  }
};
var import_typebox = Ns(ou());
var e = new WeakMap();
function t(r, o) {
  if (r == null || typeof r != "object") return String(r);
  let a,
    c = "",
    n = 0,
    s = Object.prototype.toString.call(r);
  if (s !== "[object RegExp]" && s !== "[object Date]" && e.has(r)) return e.get(r);
  switch (e.set(r, "~" + ++o), s) {
    case "[object Set]":
      a = Array.from(r);
    case "[object Array]":
      for (a || (a = r), c += "a"; n < a.length; c += t(a[n++], o));
      break;
    case "[object Object]":
      for (c += "o", a = Object.keys(r).sort(); n < a.length; c += a[n] + t(r[a[n++]], o));
      break;
    case "[object Map]":
      for (c += "o", a = Array.from(r.keys()).sort(); n < a.length; c += a[n] + t(r.get(a[n++]), o));
      break;
    case "[object Date]":
      return "d" + +r;
    case "[object RegExp]":
      return "r" + r.source + r.flags;
    default:
      throw new Error(`Unsupported value ${r}`);
  }
  return e.set(r, c), c;
}
__name(t, "t");
function r(e) {
  return t(e, 0);
}
__name(r, "r");
var t = new WeakMap();
function n(n, r, o = r(r)) {
  let i,
    u,
    f = t.get(n);
  f || (t.set(n, f = [[], u = [], i = []]), queueMicrotask(function () {
    let e,
      r = 0;
    function o(t) {
      for (; e = i[r++]; e.r(t));
    }
    __name(o, "o"), t.delete(n), n(u).then(function (t) {
      if (t.length !== i.length) return o(new Error("loader value length mismatch"));
      for (; e = t[r++], r <= t.length; e instanceof Error ? i[r - 1].r(e) : i[r - 1].s(e));
    }, o);
  }));
  let c = f[0].indexOf(o);
  if (~c) return f[2][c].p;
  let l = f[0].push(o) - 1,
    a = f[2][l] = {};
  return f[1][l] = r, a.p = new Promise(function (e, t) {
    a.s = e, a.r = t;
  });
}
__name(n, "n");
var r = new WeakMap();
function n(n, o, i, a = r(i)) {
  if (o || (o = r.get(n)), o || r.set(n, o = new Map()), o.has(a)) return Promise.resolve(o.get(a));
  let c = n(n, i, a);
  return o.set(a, c), c.catch(() => o.delete(a)), c;
}
__name(n, "n");
function o(e, t) {
  return function (r, o) {
    return n(e, t, r, o);
  };
}
__name(o, "o");
var import_brace_expansion = Ns(nne(), 1);
var assertValidPattern = __name(pattern => {
  if (typeof pattern != "string") throw new TypeError("invalid pattern");
  if (pattern.length > 65536) throw new TypeError("pattern is too long");
}, "assertValidPattern");
var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
    "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
    "[:ascii:]": ["\\x00-\\x7f", !1],
    "[:blank:]": ["\\p{Zs}\\t", !0],
    "[:cntrl:]": ["\\p{Cc}", !0],
    "[:digit:]": ["\\p{Nd}", !0],
    "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
    "[:lower:]": ["\\p{Ll}", !0],
    "[:print:]": ["\\p{C}", !0],
    "[:punct:]": ["\\p{P}", !0],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
    "[:upper:]": ["\\p{Lu}", !0],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
    "[:xdigit:]": ["A-Fa-f0-9", !1]
  },
  braceEscape = __name(s => s.replace(/[[\]\\-]/g, "\\$&"), "braceEscape"),
  regexpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regexpEscape"),
  rangesToString = __name(ranges => ranges.join(""), "rangesToString"),
  parseClass = __name((glob, position) => {
    let pos = position;
    if (glob.charAt(pos) !== "[") throw new Error("not in a brace expression");
    let ranges = [],
      negs = [],
      i = pos + 1,
      sawStart = !1,
      uflag = !1,
      escaping = !1,
      negate = !1,
      endPos = pos,
      rangeStart = "";
    WHILE: for (; i < glob.length;) {
      let c = glob.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = !0, i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      if (sawStart = !0, c === "\\" && !escaping) {
        escaping = !0, i++;
        continue;
      }
      if (c === "[" && !escaping) {
        for (let [cls, [unip, u, neg]] of Object.entries(posixClasses)) if (glob.startsWith(cls, i)) {
          if (rangeStart) return ["$.", !1, glob.length - pos, !0];
          i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
          continue WHILE;
        }
      }
      if (escaping = !1, rangeStart) {
        c > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c)) : c === rangeStart && ranges.push(braceEscape(c)), rangeStart = "", i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-")), i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c, i += 2;
        continue;
      }
      ranges.push(braceEscape(c)), i++;
    }
    if (endPos < i) return ["", !1, 0, !1];
    if (!ranges.length && !negs.length) return ["$.", !1, glob.length - pos, !0];
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      let r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), !1, endPos - pos, !1];
    }
    let sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]",
      snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos, !0];
  }, "parseClass");
var unescape = __name((s, {
  windowsPathsNoEscape = !1
} = {}) => windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), "unescape");
var types = new Set(["!", "?", "+", "*", "@"]),
  isExtglobType = __name(c => types.has(c), "isExtglobType"),
  startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))",
  startNoDot = "(?!\\.)",
  addPatternStart = new Set(["[", "."]),
  justDots = new Set(["..", "."]),
  reSpecials = new Set("().*{}+?[]^$\\!"),
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  qmark = "[^/]",
  star = qmark + "*?",
  starNoEmpty = qmark + "+?",
  AST = class _AST {
    static {
      __name(this, "AST");
    }
    type;
    ##root;
    ##hasMagic;
    ##uflag = !1;
    ##parts = [];
    ##parent;
    ##parentIndex;
    ##negs;
    ##filledNegs = !1;
    ##options;
    ##toString;
    ##emptyExt = !1;
    constructor(type, parent, options = {}) {
      this.type = type, type && (this.##hasMagic = !0), this.##parent = parent, this.##root = this.##parent ? this.##parent.##root : this, this.##options = this.##root === this ? options : this.##root.##options, this.##negs = this.##root === this ? [] : this.##root.##negs, type === "!" && !this.##root.##filledNegs && this.##negs.push(this), this.##parentIndex = this.##parent ? this.##parent.##parts.length : 0;
    }
    get hasMagic() {
      if (this.##hasMagic !== void 0) return this.##hasMagic;
      for (let p of this.##parts) if (typeof p != "string" && (p.type || p.hasMagic)) return this.##hasMagic = !0;
      return this.##hasMagic;
    }
    toString() {
      return this.##toString !== void 0 ? this.##toString : this.type ? this.##toString = this.type + "(" + this.##parts.map(p => String(p)).join("|") + ")" : this.##toString = this.##parts.map(p => String(p)).join("");
    }
    ##fillNegs() {
      if (this !== this.##root) throw new Error("should only call on root");
      if (this.##filledNegs) return this;
      this.toString(), this.##filledNegs = !0;
      let n;
      for (; n = this.##negs.pop();) {
        if (n.type !== "!") continue;
        let p = n,
          pp = p.##parent;
        for (; pp;) {
          for (let i = p.##parentIndex + 1; !pp.type && i < pp.##parts.length; i++) for (let part of n.##parts) {
            if (typeof part == "string") throw new Error("string part in extglob AST??");
            part.copyIn(pp.##parts[i]);
          }
          p = pp, pp = p.##parent;
        }
      }
      return this;
    }
    push(...parts) {
      for (let p of parts) if (p !== "") {
        if (typeof p != "string" && !(p instanceof _AST && p.##parent === this)) throw new Error("invalid part: " + p);
        this.##parts.push(p);
      }
    }
    toJSON() {
      let ret = this.type === null ? this.##parts.slice().map(p => typeof p == "string" ? p : p.toJSON()) : [this.type, ...this.##parts.map(p => p.toJSON())];
      return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === this.##root || this.##root.##filledNegs && this.##parent?.type === "!") && ret.push({}), ret;
    }
    isStart() {
      if (this.##root === this) return !0;
      if (!this.##parent?.isStart()) return !1;
      if (this.##parentIndex === 0) return !0;
      let p = this.##parent;
      for (let i = 0; i < this.##parentIndex; i++) {
        let pp = p.##parts[i];
        if (!(pp instanceof _AST && pp.type === "!")) return !1;
      }
      return !0;
    }
    isEnd() {
      if (this.##root === this || this.##parent?.type === "!") return !0;
      if (!this.##parent?.isEnd()) return !1;
      if (!this.type) return this.##parent?.isEnd();
      let pl = this.##parent ? this.##parent.##parts.length : 0;
      return this.##parentIndex === pl - 1;
    }
    copyIn(part) {
      typeof part == "string" ? this.push(part) : this.push(part.clone(this));
    }
    clone(parent) {
      let c = new _AST(this.type, parent);
      for (let p of this.##parts) c.copyIn(p);
      return c;
    }
    static ##parseAST(str, ast, pos, opt) {
      let escaping = !1,
        inBrace = !1,
        braceStart = -1,
        braceNeg = !1;
      if (ast.type === null) {
        let i = pos,
          acc = "";
        for (; i < str.length;) {
          let c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping, acc += c;
            continue;
          }
          if (inBrace) {
            i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
            continue;
          } else if (c === "[") {
            inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
            ast.push(acc), acc = "";
            let ext = new _AST(c, ast);
            i = _AST.##parseAST(str, ext, i, opt), ast.push(ext);
            continue;
          }
          acc += c;
        }
        return ast.push(acc), i;
      }
      let i = pos + 1,
        part = new _AST(null, ast),
        parts = [],
        acc = "";
      for (; i < str.length;) {
        let c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping, acc += c;
          continue;
        }
        if (inBrace) {
          i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
          continue;
        } else if (c === "[") {
          inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc), acc = "";
          let ext = new _AST(c, part);
          part.push(ext), i = _AST.##parseAST(str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc), acc = "", parts.push(part), part = new _AST(null, ast);
          continue;
        }
        if (c === ")") return acc === "" && ast.##parts.length === 0 && (ast.##emptyExt = !0), part.push(acc), acc = "", ast.push(...parts, part), i;
        acc += c;
      }
      return ast.type = null, ast.##hasMagic = void 0, ast.##parts = [str.substring(pos - 1)], i;
    }
    static fromGlob(pattern, options = {}) {
      let ast = new _AST(null, void 0, options);
      return _AST.##parseAST(pattern, ast, 0, options), ast;
    }
    toMMPattern() {
      if (this !== this.##root) return this.##root.toMMPattern();
      let glob = this.toString(),
        [re, body, hasMagic, uflag] = this.toRegExpSource();
      if (!(hasMagic || this.##hasMagic || this.##options.nocase && !this.##options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase())) return body;
      let flags = (this.##options.nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    toRegExpSource(allowDot) {
      let dot = allowDot ?? !!this.##options.dot;
      if (this.##root === this && this.##fillNegs(), !this.type) {
        let noEmpty = this.isStart() && this.isEnd(),
          src = this.##parts.map(p => {
            let [re, _, hasMagic, uflag] = typeof p == "string" ? _AST.##parseGlob(p, this.##hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            return this.##hasMagic = this.##hasMagic || hasMagic, this.##uflag = this.##uflag || uflag, re;
          }).join(""),
          start = "";
        if (this.isStart() && typeof this.##parts[0] == "string" && !(this.##parts.length === 1 && justDots.has(this.##parts[0]))) {
          let aps = addPatternStart,
            needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4)),
            needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
          start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
        }
        let end = "";
        return this.isEnd() && this.##root.##filledNegs && this.##parent?.type === "!" && (end = "(?:$|\\/)"), [start + src + end, unescape(src), this.##hasMagic = !!this.##hasMagic, this.##uflag];
      }
      let repeated = this.type === "*" || this.type === "+",
        start = this.type === "!" ? "(?:(?!(?:" : "(?:",
        body = this.##partsToRegExp(dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        let s = this.toString();
        return this.##parts = [s], this.type = null, this.##hasMagic = void 0, [s, unescape(this.toString()), !1, !1];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.##partsToRegExp(!0);
      bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
      let final = "";
      if (this.type === "!" && this.##emptyExt) final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;else {
        let close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
        final = start + body + close;
      }
      return [final, unescape(body), this.##hasMagic = !!this.##hasMagic, this.##uflag];
    }
    ##partsToRegExp(dot) {
      return this.##parts.map(p => {
        if (typeof p == "string") throw new Error("string type in extglob ast??");
        let [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
        return this.##uflag = this.##uflag || uflag, re;
      }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join("|");
    }
    static ##parseGlob(glob, hasMagic, noEmpty = !1) {
      let escaping = !1,
        re = "",
        uflag = !1;
      for (let i = 0; i < glob.length; i++) {
        let c = glob.charAt(i);
        if (escaping) {
          escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          i === glob.length - 1 ? re += "\\\\" : escaping = !0;
          continue;
        }
        if (c === "[") {
          let [src, needUflag, consumed, magic] = parseClass(glob, i);
          if (consumed) {
            re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          noEmpty && glob === "*" ? re += starNoEmpty : re += star, hasMagic = !0;
          continue;
        }
        if (c === "?") {
          re += qmark, hasMagic = !0;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, unescape(glob), !!hasMagic, uflag];
    }
  };
var escape = __name((s, {
  windowsPathsNoEscape = !1
} = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), "escape");
var minimatch = __name((p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p)), "minimatch"),
  starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/,
  starDotExtTest = __name(ext => f => !f.startsWith(".") && f.endsWith(ext), "starDotExtTest"),
  starDotExtTestDot = __name(ext => f => f.endsWith(ext), "starDotExtTestDot"),
  starDotExtTestNocase = __name(ext => (ext = ext.toLowerCase(), f => !f.startsWith(".") && f.toLowerCase().endsWith(ext)), "starDotExtTestNocase"),
  starDotExtTestNocaseDot = __name(ext => (ext = ext.toLowerCase(), f => f.toLowerCase().endsWith(ext)), "starDotExtTestNocaseDot"),
  starDotStarRE = /^\*+\.\*+$/,
  starDotStarTest = __name(f => !f.startsWith(".") && f.includes("."), "starDotStarTest"),
  starDotStarTestDot = __name(f => f !== "." && f !== ".." && f.includes("."), "starDotStarTestDot"),
  dotStarRE = /^\.\*+$/,
  dotStarTest = __name(f => f !== "." && f !== ".." && f.startsWith("."), "dotStarTest"),
  starRE = /^\*+$/,
  starTest = __name(f => f.length !== 0 && !f.startsWith("."), "starTest"),
  starTestDot = __name(f => f.length !== 0 && f !== "." && f !== "..", "starTestDot"),
  qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/,
  qmarksTestNocase = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocase"),
  qmarksTestNocaseDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocaseDot"),
  qmarksTestDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTestDot"),
  qmarksTest = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTest"),
  qmarksTestNoExt = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && !f.startsWith(".");
  }, "qmarksTestNoExt"),
  qmarksTestNoExtDot = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && f !== "." && f !== "..";
  }, "qmarksTestNoExtDot"),
  defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix",
  path = {
    win32: {
      sep: "\\"
    },
    posix: {
      sep: "/"
    }
  },
  sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark = "[^/]",
  star = qmark + "*?",
  twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
  twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?",
  filter = __name((pattern, options = {}) => p => minimatch(p, pattern, options), "filter");
minimatch.filter = filter;
var ext = __name((a, b = {}) => Object.assign({}, a, b), "ext"),
  defaults = __name(def => {
    if (!def || typeof def != "object" || !Object.keys(def).length) return minimatch;
    let orig = minimatch;
    return Object.assign(__name((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), "m"), {
      Minimatch: class extends orig.Minimatch {
        static {
          __name(this, "Minimatch");
        }
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class extends orig.AST {
        static {
          __name(this, "AST");
        }
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: options => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR: GLOBSTAR
    });
  }, "defaults");
minimatch.defaults = defaults;
var braceExpand = __name((pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : (0, fne.expand)(pattern)), "braceExpand");
minimatch.braceExpand = braceExpand;
var makeRe = __name((pattern, options = {}) => new Minimatch(pattern, options).makeRe(), "makeRe");
minimatch.makeRe = makeRe;
var match = __name((list, pattern, options = {}) => {
  let mm = new Minimatch(pattern, options);
  return list = list.filter(f => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
}, "match");
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/,
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  Minimatch = class {
    static {
      __name(this, "Minimatch");
    }
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) return !0;
      for (let pattern of this.set) for (let part of pattern) if (typeof part != "string") return !0;
      return !1;
    }
    debug(..._) {}
    make() {
      let pattern = this.pattern,
        options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
      let rawGlobParts = this.globSet.map(s => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]),
            isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
          if (isDrive) return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
        }
        return s.map(ss => this.parse(ss));
      });
      if (this.debug(this.pattern, set), this.set = set.filter(s => s.indexOf(!1) === -1), this.isWindows) for (let i = 0; i < this.set.length; i++) {
        let p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) for (let i = 0; i < globParts.length; i++) for (let j = 0; j < globParts[i].length; j++) globParts[i][j] === "**" && (globParts[i][j] = "*");
      let {
        optimizationLevel = 1
      } = this.options;
      return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map(parts => {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
          let i = gs;
          for (; parts[i + 1] === "**";) i++;
          i !== gs && parts.splice(gs, i - gs);
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map(parts => (parts = parts.reduce((set, part) => {
        let prev = set[set.length - 1];
        return part === "**" && prev === "**" ? set : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set.pop(), set) : (set.push(part), set);
      }, []), parts.length === 0 ? [""] : parts));
    }
    levelTwoFileOptimize(parts) {
      Array.isArray(parts) || (parts = this.slashSplit(parts));
      let didSomething = !1;
      do {
        if (didSomething = !1, !this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            let p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
          let p = parts[dd - 1];
          p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = !1;
      do {
        didSomething = !1;
        for (let parts of globParts) {
          let gs = -1;
          for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
            let gss = gs;
            for (; parts[gss + 1] === "**";) gss++;
            gss > gs && parts.splice(gs + 1, gss - gs);
            let next = parts[gs + 1],
              p = parts[gs + 2],
              p2 = parts[gs + 3];
            if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") continue;
            didSomething = !0, parts.splice(gs, 1);
            let other = parts.slice(0);
            other[gs] = "**", globParts.push(other), gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              let p = parts[i];
              i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
            }
            parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
          }
          let dd = 0;
          for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
            let p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = !0;
              let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) for (let j = i + 1; j < globParts.length; j++) {
        let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        matched && (globParts[i] = matched, globParts[j] = []);
      }
      return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = !1) {
      let ai = 0,
        bi = 0,
        result = [],
        which = "";
      for (; ai < a.length && bi < b.length;) if (a[ai] === b[bi]) result.push(which === "b" ? b[bi] : a[ai]), ai++, bi++;else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) result.push(a[ai]), ai++;else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) result.push(b[bi]), bi++;else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b") return !1;
        which = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a") return !1;
        which = "b", result.push(b[bi]), ai++, bi++;
      } else return !1;
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate) return;
      let pattern = this.pattern,
        negate = !1,
        negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
    }
    matchOne(file, pattern, partial = !1) {
      let options = this.options;
      if (this.isWindows) {
        let fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]),
          fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]),
          patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]),
          patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]),
          fdi = fileUNC ? 3 : fileDrive ? 0 : void 0,
          pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi == "number" && typeof pdi == "number") {
          let [fd, pd] = [file[fdi], pattern[pdi]];
          fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
        }
      }
      let {
        optimizationLevel = 1
      } = this.options;
      optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, {
        file: file,
        pattern: pattern
      }), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi],
          f = file[fi];
        if (this.debug(pattern, p, f), p === !1) return !1;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi,
            pr = pi + 1;
          if (pr === pl) {
            for (this.debug("** at the end"); fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return !1;
            return !0;
          }
          for (; fr < fl;) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial)) return this.debug("globstar found match!", fr, fl, swallowee), !0;
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), fr++;
          }
          return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
        }
        let hit;
        if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit) return !1;
      }
      if (fi === fl && pi === pl) return !0;
      if (fi === fl) return partial;
      if (pi === pl) return fi === fl - 1 && file[fi] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      let options = this.options;
      if (pattern === "**") return GLOBSTAR;
      if (pattern === "") return "";
      let m,
        fastTest = null;
      (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
      let re = AST.fromGlob(pattern, this.options).toMMPattern();
      return fastTest ? Object.assign(re, {
        test: fastTest
      }) : re;
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      let set = this.set;
      if (!set.length) return this.regexp = !1, this.regexp;
      let options = this.options,
        twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,
        flags = new Set(options.nocase ? ["i"] : []),
        re = set.map(pattern => {
          let pp = pattern.map(p => {
            if (p instanceof RegExp) for (let f of p.flags.split("")) flags.add(f);
            return typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
          });
          return pp.forEach((p, i) => {
            let next = pp[i + 1],
              prev = pp[i - 1];
            p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
          }), pp.filter(p => p !== GLOBSTAR).join("/");
        }).join("|"),
        [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    slashSplit(p) {
      return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment) return !1;
      if (this.empty) return f === "";
      if (f === "/" && partial) return !0;
      let options = this.options;
      this.isWindows && (f = f.split("\\").join("/"));
      let ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      let set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) for (let i = ff.length - 2; !filename && i >= 0; i--) filename = ff[i];
      for (let i = 0; i < set.length; i++) {
        let pattern = set[i],
          file = ff;
        if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial)) return options.flipNegate ? !0 : !this.negate;
      }
      return options.flipNegate ? !1 : this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
var import_value = Ns(OL());
var assertShape = __name((schema, payload) => {
  if (LL.Value.Check(schema, payload)) return payload;
  let error = `Typebox schema validation failed:
${[...LL.Value.Errors(schema, payload)].map(i => `${i.path} ${i.message}`).join(`
`)}`;
  throw new Error(error);
}, "assertShape");
var TELEMETRY_NAME = "contentExclusion",
  CopilotContentRestrictions = class extends PolicyEvaluator {
    static {
      __name(this, "CopilotContentRestrictions");
    }
    ##context;
    ##evaluateResultCache = new LRUCacheMap(1e4);
    ##ruleLoaderCache = new LRUCacheMap(200);
    constructor(context) {
      super(), this.##context = context;
    }
    async evaluate(uri) {
      let cacheKey = uri.fsPath;
      if (this.##evaluateResultCache.has(cacheKey)) return this.##evaluateResultCache.get(cacheKey);
      try {
        let repo = await extractRepoInfo(this.##context, uri);
        if (!repo || !repo.url) return NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE;
        let fileNameToCompare = uri.fsPath.replace(repo.baseFolder, "");
        var result = await this.evaluateFileFromRepo(fileNameToCompare, repo.url);
      } catch (err) {
        return telemetryException(this.##context, err, `${TELEMETRY_NAME}.evaluate`), BLOCKED_POLICY_ERROR_RESPONSE;
      }
      return this.##evaluateResultCache.set(cacheKey, result), result;
    }
    async evaluateFileFromRepo(fileName, repoUrl) {
      let rules = await this.##rulesForRepo(repoUrl);
      if (!rules) return NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE;
      for (let rule of rules) for (let pattern of rule.paths) if (minimatch(fileName, pattern, {
        nocase: !0,
        matchBase: !0,
        nonegate: !0
      })) return fileBlockedEvaluationResult(rule);
      return NOT_BLOCKED_RESPONSE;
    }
    async refresh() {
      try {
        let existingUrls = [...this.##ruleLoaderCache.keys()];
        this.reset(), await Promise.all(existingUrls.map(url => this.##ruleLoader(url)));
      } catch (err) {
        telemetryException(this.##context, err, `${TELEMETRY_NAME}.refresh`);
      }
    }
    reset() {
      this.##ruleLoaderCache.clear(), this.##evaluateResultCache.clear();
    }
    async ##rulesForRepo(repoUrl) {
      let rules = await this.##ruleLoader(repoUrl.toLowerCase());
      if (rules.length !== 0) return rules;
    }
    ##ruleLoader = o(async urls => {
      let session = await this.##context.get(CopilotTokenManager).getGitHubSession(this.##context);
      if (!session) throw new CopilotAuthError("No token found");
      let endpoint = this.##context.get(NetworkConfiguration).getContentRestrictionsUrl(session),
        url = new URL(endpoint);
      url.searchParams.set("repos", urls.join(","));
      let result = await this.##context.get(Fetcher).fetch(url.href, {
          method: "GET",
          headers: {
            Authorization: `token ${session.token}`
          }
        }),
        data = await result.json();
      if (!result.ok) {
        if (result.status === 404) return Array.from(urls, () => []);
        this.##telemetry("fetch.error", {
          message: data.message
        });
        let error = new Error(`HTTP ${result.status}`);
        throw error.code = `HTTP${result.status}`, error;
      }
      return this.##telemetry("fetch.success"), assertShape(ContentRestrictionsResponseSchema, data).map(r => r.rules);
    }, this.##ruleLoaderCache);
    ##telemetry(event, properties, measurements) {
      telemetry(this.##context, `${TELEMETRY_NAME}.${event}`, TelemetryData.createAndMarkAsIssued(properties, measurements));
    }
  };
function fileBlockedEvaluationResult(rule) {
  return {
    isBlocked: !0,
    reason: "FILE_BLOCKED",
    message: `Your ${rule.source.type.toLowerCase()} '${rule.source.name}' has disabled Copilot for this file`
  };
}
__name(fileBlockedEvaluationResult, "fileBlockedEvaluationResult");
var SourceSchema = eu.Type.Object({
    name: eu.Type.String(),
    type: eu.Type.Union([eu.Type.Literal("Organization"), eu.Type.Literal("Repository")])
  }),
  RuleSchema = eu.Type.Object({
    paths: eu.Type.Array(eu.Type.String()),
    source: SourceSchema
  }),
  RulesSchema = eu.Type.Array(RuleSchema),
  RepoRuleSchema = eu.Type.Object({
    rules: RulesSchema,
    last_updated_at: eu.Type.String()
  }),
  ContentRestrictionsResponseSchema = eu.Type.Array(RepoRuleSchema);
var nodePath = Ns(require("path"));
var CopilotRepositoryControl = class extends PolicyEvaluator {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.repoUriToPolicyMap = new Map();
    this.requestStatus = {
      status: "initial"
    };
    this.initialWaitMs = 30 * 1e3;
    this.maxRetryCount = 3;
  }
  static {
    __name(this, "CopilotRepositoryControl");
  }
  async refresh() {
    try {
      this.reset(), this.requestStatus.status !== "retrying" && (this.requestStatus = {
        status: "initial"
      }, await this.fetchControlData());
    } catch (err) {
      telemetryException(this.ctx, err, "repositoryControl.refresh");
    }
  }
  reset() {
    this.repoUriToPolicyMap.clear();
  }
  async fetchControlData() {
    if (this.requestStatus.status === "retrying" || this.requestStatus.status === "maxRetries") return "POLICY_NOT_AVAILABLE";
    if (this.requestStatus.status === "cached") return this.requestStatus.data;
    this.requestStatus.status !== "fetching" && (this.requestStatus = {
      status: "fetching",
      data: this._fetchControlData()
    });
    let data = await this.requestStatus.data;
    return data || "POLICY_NOT_AVAILABLE";
  }
  async _fetchControlData() {
    if (this.requestStatus.status === "retrying") {
      let _waitMs = this.requestStatus.waitMs;
      await new Promise(resolve => setTimeout(resolve, _waitMs));
    }
    try {
      let githubToken = await this.ctx.get(CopilotTokenManager).getGitHubToken(this.ctx),
        editorSession = this.ctx.get(EditorSession),
        editorInfo = this.ctx.get(EditorAndPluginInfo),
        telemetryConfig = this.ctx.get(TelemetryUserConfig);
      if (!githubToken) throw new CopilotAuthError("No github token found");
      let fetcher = this.ctx.get(Fetcher),
        headers = {
          trackingid: `${telemetryConfig.trackingId}`,
          githubtoken: `${githubToken}`,
          machineid: `${editorSession.machineId}`,
          sessionid: `${editorSession.sessionId}`,
          extname: `${editorInfo.getEditorPluginInfo().name}`,
          extversion: `${editorInfo.getEditorPluginInfo().version}`
        },
        response = await fetcher.fetch(POLICY_ENDPOINT, {
          headers: headers,
          method: "GET"
        });
      if (response.ok) {
        let content = await response.json(),
          lowercaseConfig = {};
        for (let key in content.config) lowercaseConfig[key.toLowerCase()] = content.config[key];
        return content.config = lowercaseConfig, logger.info(this.ctx, "repositoryControl.fetch", "success", Object.keys(content.config).length + " repos"), telemetry(this.ctx, "repositoryControl.fetch.success"), this.requestStatus = {
          status: "cached",
          data: content
        }, content;
      }
      throw new Error(`API returned ${response.status}`);
    } catch (err) {
      telemetry(this.ctx, "repositoryControl.fetch.error"), telemetryException(this.ctx, err, "repositoryControl.fetch");
      let _retryCount = this.requestStatus.status === "retrying" ? this.requestStatus.retryCount + 1 : 0,
        _waitMs = this.requestStatus.status === "retrying" ? this.requestStatus.waitMs * 2 : this.initialWaitMs;
      if (_retryCount >= this.maxRetryCount) {
        telemetry(this.ctx, "repositoryControl.fetch.maxRetries"), this.requestStatus = {
          status: "maxRetries"
        };
        return;
      }
      this.requestStatus = {
        status: "retrying",
        retryCount: _retryCount,
        waitMs: _waitMs
      }, this._fetchControlData();
    }
  }
  async evaluate(uri, fileContent) {
    try {
      let policy = await this.getRepositoryPolicy(uri);
      return policy === "POLICY_NOT_AVAILABLE" ? BLOCKED_POLICY_ERROR_RESPONSE : policy === "NO_MATCHING_POLICY" ? NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE : {
        ...(await this._evaluate(uri, fileContent, policy)),
        providerRepoKey: policy.providerRepoKey
      };
    } catch (err) {
      return telemetryException(this.ctx, err, "repositoryControl.evaluate"), BLOCKED_POLICY_ERROR_RESPONSE;
    }
  }
  async _evaluate(uri, fileContent, policy) {
    if (policy?.blocked) return BLOCKED_REPO_RESPONSE;
    if (policy?.rule && policy.rule.fileContent && fileContent) {
      let mustInclude = policy.rule.fileContent.includes;
      if (fileContent && mustInclude && mustInclude.length > 0 && !new RegExp(mustInclude.join("|"), "i").test(fileContent)) return BLOCKED_FILE_RESPONSE;
      let mustExclude = policy.rule.fileContent.excludes;
      if (fileContent && mustExclude && mustExclude.length > 0 && new RegExp(mustExclude.join("|"), "i").test(fileContent)) return BLOCKED_FILE_RESPONSE;
    }
    return NOT_BLOCKED_RESPONSE;
  }
  async fetchRepositoryPolicy(providerRepoKey) {
    let data = await this.fetchControlData();
    if (data === "POLICY_NOT_AVAILABLE") return "POLICY_NOT_AVAILABLE";
    let config = data.config[providerRepoKey];
    if (!config) return "NO_MATCHING_POLICY";
    let result = {
      providerRepoKey: providerRepoKey,
      blocked: config.blocked
    };
    return config.ruleId && (result.rule = data.rule[config.ruleId]), result;
  }
  async getRepositoryPolicy(uri) {
    let cachedPolicy = this.repoUriToPolicyMap.get(uri.fsPath);
    if (cachedPolicy) return cachedPolicy;
    let matchingKey = getFilePathChunks(uri.fsPath).find(chunk => this.repoUriToPolicyMap.has(chunk));
    if (matchingKey) return this.repoUriToPolicyMap.get(matchingKey) ?? "NO_MATCHING_POLICY";
    let repositoryInfo = await extractRepoInfo(this.ctx, uri);
    if (!repositoryInfo || !repositoryInfo.url) {
      let parentFolder = R_.dirname(uri.fsPath);
      return this.repoUriToPolicyMap.set(parentFolder, "NO_MATCHING_POLICY"), this.repoUriToPolicyMap.set(uri.fsPath, "NO_MATCHING_POLICY"), "NO_MATCHING_POLICY";
    }
    let providerRepoKey = this.getProviderRepoKey(repositoryInfo);
    if (!providerRepoKey) return "NO_MATCHING_POLICY";
    let policy = await this.fetchRepositoryPolicy(providerRepoKey);
    return policy === "POLICY_NOT_AVAILABLE" || (this.repoUriToPolicyMap.set(repositoryInfo.baseFolder, policy), this.repoUriToPolicyMap.set(uri.fsPath, policy)), policy;
  }
  getProviderRepoKey(repoInfo) {
    if (repoInfo !== void 0) {
      if (repoInfo.hostname === "github.com") return `github.com:${repoInfo.owner}/${repoInfo.repo}`.toLowerCase();
      if (repoInfo.hostname.endsWith("azure.com") || repoInfo.hostname.endsWith("visualstudio.com")) return `dev.azure.com:${repoInfo.owner}/${repoInfo.repo}`.toLowerCase();
    }
  }
};
function getFilePathChunks(filepath) {
  let chunks = [],
    currentPath = "";
  for (let part of filepath.split(R_.sep)) currentPath += part + R_.sep, chunks.push(currentPath.slice(0, -1));
  return chunks;
}
__name(getFilePathChunks, "getFilePathChunks");
var logger = new Logger(1, "CopilotContentExclusion");
var CopilotRepositoryControlManager = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.##featureEnabled = !1;
    this.##repositoryControl = null;
    this.##contentRestrictions = new CopilotContentRestrictions(this.ctx);
    this.evaluateResultCache = new Map();
    this.onDidChangeActiveTextEditor = async e => {
      if (!this.##featureEnabled || !e) return;
      let result = await this.ctx.get(TextDocumentManager).getTextDocumentWithValidation(e.document.uri),
        isBlocked = result.status === "invalid",
        reason = result.status === "invalid" ? result.reason : void 0;
      this.updateStatusIcon(isBlocked, reason);
    };
    this.ctx.get(TextDocumentManager).onDidFocusTextDocument(this.onDidChangeActiveTextEditor), this.ctx.get(CopilotTokenNotifier).on("onCopilotToken", (token, tokenEnvelope) => {
      this.##featureEnabled = tokenEnvelope?.copilotignore_enabled ?? !1, tokenEnvelope?.copilotignore_enabled && logger.info(this.ctx, "feature flag is enabled for user"), this.evaluateResultCache.clear(), this.##contentRestrictions.refresh();
      let orgs = token.organization_list ?? [];
      this.##refreshMSFTRepoControl(orgs);
    });
  }
  static {
    __name(this, "CopilotRepositoryControlManager");
  }
  ##featureEnabled;
  ##repositoryControl;
  ##contentRestrictions;
  get enabled() {
    return this.##featureEnabled;
  }
  async evaluate(uri, fileContent, shouldUpdateStatusBar) {
    if (!this.##featureEnabled || uri.scheme !== "file") return {
      isBlocked: !1
    };
    let events = [],
      track = __name(async (key, ev) => {
        let startTimeMs = Date.now(),
          result = await ev.evaluate(uri, fileContent),
          endTimeMs = Date.now();
        return events.push({
          key: key,
          result: result,
          elapsedMs: endTimeMs - startTimeMs
        }), result;
      }, "track"),
      result = (await Promise.all([this.##repositoryControl && track("repositoryControl.evaluate", this.##repositoryControl), track("contentExclusion.evaluate", this.##contentRestrictions)])).find(r => r?.isBlocked) ?? {
        isBlocked: !1
      };
    try {
      for (let event of events) this.##trackEvaluationResult(event.key, uri, event.result, event.elapsedMs);
    } catch (e) {
      console.log("Error tracking telemetry", e);
    }
    return shouldUpdateStatusBar === "UPDATE" && this.updateStatusIcon(result.isBlocked, result.message), result;
  }
  updateStatusIcon(isBlocked, reason) {
    this.##featureEnabled && (isBlocked ? this.ctx.get(StatusReporter).setInactive(reason ?? "Copilot is disabled") : this.ctx.get(StatusReporter).forceNormal());
  }
  ##trackEvaluationResult(key, uri, result, elapsedMs) {
    let cacheKey = uri.path + key;
    if (this.evaluateResultCache.get(cacheKey) === result.reason) return !1;
    if (this.evaluateResultCache.set(cacheKey, result.reason ?? "UNKNOWN"), result.reason === NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE.reason) return logger.info(this.ctx, key, ` No matching policy for this repository. uri: ${uri.path}`), !1;
    let properties = {
        isBlocked: result.isBlocked ? "true" : "false",
        reason: result.reason ?? "UNKNOWN"
      },
      measurements = {
        elapsedMs: elapsedMs
      };
    return telemetry(this.ctx, key, TelemetryData.createAndMarkAsIssued(properties, measurements)), telemetry(this.ctx, key, TelemetryData.createAndMarkAsIssued({
      ...properties,
      path: uri.path
    }, measurements), 1), logger.info(this.ctx, key, uri.path, JSON.stringify(result)), !0;
  }
  ##refreshMSFTRepoControl(user_orgs) {
    let knownOrg = ["a5db0bcaae94032fe715fb34a5e4bce2", "7184f66dfcee98cb5f08a1cb936d5225"].find(org => user_orgs.includes(org));
    this.##featureEnabled && knownOrg ? (this.##repositoryControl ||= new CopilotRepositoryControl(this.ctx), this.##repositoryControl.refresh()) : this.##repositoryControl = null;
  }
  set __repositoryControl(repoControl) {
    this.##repositoryControl = repoControl;
  }
  get __repositoryControl() {
    return this.##repositoryControl;
  }
  set __contentRestrictions(contentRestrictions) {
    this.##contentRestrictions = contentRestrictions;
  }
  get __contentRestrictions() {
    return this.##contentRestrictions;
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_crypto = require("crypto");
function editDistance(haystack, needle, compare = (h, n) => h === n ? 0 : 1) {
  if (needle.length === 0 || haystack.length === 0) return {
    distance: needle.length,
    startOffset: 0,
    endOffset: 0
  };
  let curRow = new Array(needle.length + 1).fill(0),
    curStart = new Array(needle.length + 1).fill(0),
    prevRow = new Array(haystack.length + 1).fill(0),
    prevStart = new Array(haystack.length + 1).fill(0),
    c = needle[0];
  for (let i = 0; i < haystack.length + 1; i++) i === 0 ? curRow[i] = 1 : curRow[i] = compare(haystack[i - 1], c, i - 1, 0), curStart[i] = i > 0 ? i - 1 : 0;
  for (let j = 1; j < needle.length; j++) {
    let swap = prevRow;
    prevRow = curRow, curRow = swap, swap = prevStart, prevStart = curStart, curStart = swap, c = needle[j], curRow[0] = j + 1;
    for (let i = 1; i < haystack.length + 1; i++) {
      let inserted = 1 + prevRow[i],
        deleted = 1 + curRow[i - 1],
        substituted = compare(haystack[i - 1], c, i - 1, j) + prevRow[i - 1];
      curRow[i] = Math.min(deleted, inserted, substituted), curRow[i] === substituted ? curStart[i] = prevStart[i - 1] : curRow[i] === inserted ? curStart[i] = prevStart[i] : curStart[i] = curStart[i - 1];
    }
  }
  let best = 0;
  for (let i = 0; i < haystack.length + 1; i++) curRow[i] < curRow[best] && (best = i);
  return {
    distance: curRow[best],
    startOffset: curStart[best],
    endOffset: best
  };
}
__name(editDistance, "editDistance");
function emptyLexDictionary() {
  return new Map();
}
__name(emptyLexDictionary, "emptyLexDictionary");
function reverseLexDictionary(d) {
  let lookup = new Array(d.size);
  for (let [lexeme, idx] of d) lookup[idx] = lexeme;
  return lookup;
}
__name(reverseLexDictionary, "reverseLexDictionary");
function* lexGeneratorWords(s) {
  let buffer = "",
    State;
  (c => (State[c.Word = 0] = "Word", State[c.Space = 1] = "Space", State[c.Other = 2] = "Other"))(State ||= {});
  let state = 0;
  for (let c of s) {
    let newState;
    /(\p{L}|\p{Nd}|_)/u.test(c) ? newState = 0 : c === " " ? newState = 1 : newState = 2, newState === state && newState !== 2 ? buffer += c : (buffer.length > 0 && (yield buffer), buffer = c, state = newState);
  }
  buffer.length > 0 && (yield buffer);
}
__name(lexGeneratorWords, "lexGeneratorWords");
function lexicalAnalyzer(s, d, lexGenerator, lexFilter) {
  let lexed = [],
    offset = 0;
  for (let lexeme of lexGenerator(s)) lexFilter(lexeme) && (d.has(lexeme) || d.set(lexeme, d.size), lexed.push([d.get(lexeme), offset])), offset += lexeme.length;
  return [lexed, d];
}
__name(lexicalAnalyzer, "lexicalAnalyzer");
function notSingleSpace(s) {
  return s !== " ";
}
__name(notSingleSpace, "notSingleSpace");
function lexEditDistance(haystack, needle, lexGenerator = lexGeneratorWords) {
  let [haystackLexed, d] = lexicalAnalyzer(haystack, emptyLexDictionary(), lexGenerator, notSingleSpace),
    [needleLexed, dBoth] = lexicalAnalyzer(needle, d, lexGenerator, notSingleSpace);
  if (needleLexed.length === 0 || haystackLexed.length === 0) return {
    lexDistance: needleLexed.length,
    startOffset: 0,
    endOffset: 0,
    haystackLexLength: haystackLexed.length,
    needleLexLength: needleLexed.length
  };
  let lookupId = reverseLexDictionary(dBoth),
    needleLexedLength = needleLexed.length,
    needleFirst = lookupId[needleLexed[0][0]],
    needleLast = lookupId[needleLexed[needleLexedLength - 1][0]];
  function compare(hLexId, nLexId, hIndex, nIndex) {
    if (nIndex === 0 || nIndex === needleLexedLength - 1) {
      let haystackLexeme = lookupId[haystackLexed[hIndex][0]];
      return nIndex == 0 && haystackLexeme.endsWith(needleFirst) || nIndex == needleLexedLength - 1 && haystackLexeme.startsWith(needleLast) ? 0 : 1;
    } else return hLexId === nLexId ? 0 : 1;
  }
  __name(compare, "compare");
  let alignment = editDistance(haystackLexed.map(x => x[0]), needleLexed.map(x => x[0]), compare),
    startOffset = haystackLexed[alignment.startOffset][1],
    endOffset = alignment.endOffset < haystackLexed.length ? haystackLexed[alignment.endOffset][1] : haystack.length;
  return endOffset > 0 && haystack[endOffset - 1] === " " && --endOffset, {
    lexDistance: alignment.distance,
    startOffset: startOffset,
    endOffset: endOffset,
    haystackLexLength: haystackLexed.length,
    needleLexLength: needleLexed.length
  };
}
__name(lexEditDistance, "lexEditDistance");
var equal = Vne(),
  logger = new Logger(0, "retrieval");
function snippetFromRetrievalResult(result) {
  return {
    snippet: result.text.before + result.text.snippet + result.text.after,
    score: result.distance,
    startLine: result.line_info.before_start_line,
    endLine: result.line_info.after_end_line,
    relativePath: result.file,
    restrictedTelemetry: {
      corpusId: result.corpus_config.corpus_id,
      repoNwo: result.corpus_config.repo_nwo,
      repoSha: result.corpus_config.repo_sha,
      indexTimestamp: result.corpus_config.index_timestamp
    }
  };
}
__name(snippetFromRetrievalResult, "snippetFromRetrievalResult");
function buildSnippetMatcher(matcherName, matcherThreshold) {
  switch (matcherName) {
    case "exact":
      return exactSnippetMatcher;
    case "editDistanceRelative":
      if (matcherThreshold === void 0 || matcherThreshold < 0 || matcherThreshold > 100) throw new Error("Invalid threshold for editDistanceRelative matcher");
      return editDistanceSnippetMatcher(matcherThreshold / 100, "relative");
    case "editDistanceAbsolute":
      if (matcherThreshold === void 0 || matcherThreshold < 0) throw new Error("Invalid threshold for editDistanceAbsolute matcher");
      return editDistanceSnippetMatcher(matcherThreshold, "absolute");
    case "lineBasedRelative":
      if (matcherThreshold === void 0 || matcherThreshold < 0 || matcherThreshold > 100) throw new Error("Invalid threshold for lineBasedRelative matcher");
      return lineBasedSnippetMatcher(matcherThreshold / 100, "relative", 100);
    case "lineBasedAbsolute":
      if (matcherThreshold === void 0 || matcherThreshold < 0) throw new Error("Invalid threshold for lineBasedAbsolute matcher");
      return lineBasedSnippetMatcher(matcherThreshold, "absolute", 100);
    default:
      return exactSnippetMatcher;
  }
}
__name(buildSnippetMatcher, "buildSnippetMatcher");
function exactSnippetMatcher(queryKey, cacheKey) {
  return queryKey.querySnippet === cacheKey.querySnippet;
}
__name(exactSnippetMatcher, "exactSnippetMatcher");
function breakUpLongLines(text, maxLineCharLength) {
  let lines = new Set();
  for (let line of text.split(`
`)) {
    if (line.length <= maxLineCharLength) {
      lines.add(line);
      continue;
    }
    let i = 0;
    for (; i < line.length;) lines.add(line.substring(i, i + maxLineCharLength)), i += maxLineCharLength;
  }
  return lines;
}
__name(breakUpLongLines, "breakUpLongLines");
function lineBasedSnippetMatcher(threshold, thresholdType, maxLineCharLength) {
  return (queryKey, cacheKey) => {
    let queryLines = breakUpLongLines(queryKey.querySnippet, maxLineCharLength),
      cacheLines = breakUpLongLines(cacheKey.querySnippet, maxLineCharLength),
      intersection = new Set([...queryLines].filter(line => cacheLines.has(line)));
    return thresholdType === "relative" ? 1 - intersection.size / (queryLines.size + cacheLines.size - intersection.size) <= threshold : Math.max(queryLines.size, cacheLines.size) - intersection.size <= threshold;
  };
}
__name(lineBasedSnippetMatcher, "lineBasedSnippetMatcher");
function editDistanceSnippetMatcher(threshold, thresholdType) {
  return (queryKey, cacheKey) => {
    let res = editDistance(queryKey.querySnippet, cacheKey.querySnippet);
    return thresholdType === "relative" ? res.distance <= threshold * Math.max(queryKey.querySnippet.length, cacheKey.querySnippet.length) : res.distance <= threshold;
  };
}
__name(editDistanceSnippetMatcher, "editDistanceSnippetMatcher");
function getRetrievalContext(docInfo, options) {
  let contextInfo = (0, z5.getCursorContext)(docInfo, options);
  return {
    querySnippet: contextInfo.context,
    offset: docInfo.offset,
    tokenLength: contextInfo.tokenLength,
    lineCount: contextInfo.lineCount
  };
}
__name(getRetrievalContext, "getRetrievalContext");
var RetrievalCache = class {
  constructor(matcher, maxUriCacheSize) {
    this.uriToCache = new Map();
    this.matcher = matcher, this.maxUriCacheSize = maxUriCacheSize;
  }
  static {
    __name(this, "RetrievalCache");
  }
  hashContext(context) {
    return (0, Yne.createHash)("sha1").update(context.querySnippet).digest("hex");
  }
  get(uri, queryContext) {
    let uriCache = this.uriToCache.get(uri);
    if (uriCache !== void 0) for (let hash of uriCache.keys()) {
      let {
        context: context,
        retrievalId: retrievalId,
        snippets: snippets
      } = uriCache.get(hash);
      if (this.matcher(queryContext, context)) return {
        retrievalId: retrievalId,
        snippets: snippets
      };
    }
  }
  put(uri, retrievalId, retrievalContext, snippets) {
    let uriCache = this.uriToCache.get(uri);
    uriCache === void 0 && (uriCache = new LRUCacheMap(this.maxUriCacheSize), this.uriToCache.set(uri, uriCache)), uriCache.set(this.hashContext(retrievalContext), {
      context: retrievalContext,
      retrievalId: retrievalId,
      snippets: snippets
    });
  }
};
function lookupCache(ctx, retrievalCache, docInfo, retrievalContext, telemetryData) {
  let cacheLookupStart = Date.now(),
    cacheHit = retrievalCache.get(docInfo.uri, retrievalContext),
    cacheLookupElapsed = Date.now() - cacheLookupStart;
  return telemetrizeCacheLookup(ctx, cacheHit !== void 0, cacheLookupElapsed, telemetryData), cacheHit;
}
__name(lookupCache, "lookupCache");
function telemetrizeCacheLookup(ctx, cacheHit, cacheLookupElapsed, telemetryData) {
  telemetry(ctx, "retrieval.cacheLookup", telemetryData.extendedBy({
    cacheHit: cacheHit ? "true" : "false"
  }, {
    cacheLookupElapsed: cacheLookupElapsed
  }), 0);
}
__name(telemetrizeCacheLookup, "telemetrizeCacheLookup");
function telemetrizeTooShortContext(ctx, docInfo, retrievalContext, telemetryData) {
  let commonMeasurements = {
    retrievalContextTokens: retrievalContext.tokenLength,
    retrievalLineCount: retrievalContext.lineCount,
    cursorPos: docInfo.offset
  };
  telemetry(ctx, "retrieval.tooShortContext", telemetryData.extendedBy({}, commonMeasurements), 0), telemetry(ctx, "retrieval.tooShortContext", telemetryData.extendedBy({
    file: docInfo.uri,
    retrievalContext: retrievalContext.querySnippet
  }, commonMeasurements), 1);
}
__name(telemetrizeTooShortContext, "telemetrizeTooShortContext");
function telemetrizePostRetrievalRequest(ctx, docInfo, retrievalId, retrievalContext, retrievalOptions, telemetryData) {
  let commonMeasurements = {
    retrievalContextTokens: retrievalContext.tokenLength,
    retrievalLineCount: retrievalContext.lineCount,
    cursorPos: docInfo.offset
  };
  telemetry(ctx, "retrieval.issued", telemetryData.extendedBy({
    retrievalId: retrievalId
  }, commonMeasurements), 0), telemetry(ctx, "retrieval.issued", telemetryData.extendedBy({
    retrievalId: retrievalId,
    file: docInfo.uri,
    retrievalContext: retrievalContext.querySnippet
  }, commonMeasurements), 1);
}
__name(telemetrizePostRetrievalRequest, "telemetrizePostRetrievalRequest");
function telemetrizePostRetrievalResponse(ctx, retrievalId, response, telemetryData) {
  telemetry(ctx, "retrieval.response", telemetryData.extendedBy({
    retrievalId: retrievalId
  }), 0);
}
__name(telemetrizePostRetrievalResponse, "telemetrizePostRetrievalResponse");
function telemetrizePostRetrievalRequestError(ctx, retrievalId, error, telemetryData) {
  telemetry(ctx, "retrieval.error", telemetryData.extendedBy({
    retrievalId: retrievalId,
    error: JSON.stringify(error) ?? "unknown"
  }), 0);
}
__name(telemetrizePostRetrievalRequestError, "telemetrizePostRetrievalRequestError");
function telemetrizeProcessRetrievalResponse(ctx, retrievalId, body, snippets, telemetryData) {
  let commonMeasurements = {
    numSnippetsFromServer: body?.results?.length || -1,
    numFilteredSnippets: snippets.length
  };
  telemetry(ctx, "retrieval.retrieved", telemetryData.extendedBy({
    retrievalId: retrievalId
  }, {
    ...commonMeasurements,
    elapsedEmbeddingNs: body?.metadata?.elapsed_embedding_ns || -1,
    elapsedKnnNs: body?.metadata?.elapsed_knn_ns || -1,
    elapsedFindSourceNs: body?.metadata?.elapsed_find_source_ns || -1
  }), 0), telemetry(ctx, "retrieval.retrieved", telemetryData.extendedBy({
    retrievalId: retrievalId,
    snippets: JSON.stringify(snippets.map(snippet => {
      let {
        restrictedTelemetry: restrictedTelemetry,
        ...rest
      } = snippet;
      return {
        ...rest,
        ...restrictedTelemetry
      };
    }))
  }, {
    ...commonMeasurements
  }), 1);
}
__name(telemetrizeProcessRetrievalResponse, "telemetrizeProcessRetrievalResponse");
function telemetrizeProcessRetrievalError(ctx, retrievalId, body, error, telemetryData) {
  telemetry(ctx, "retrieval.errorProcess", telemetryData.extendedBy({
    retrievalId: retrievalId
  }), 0), telemetry(ctx, "retrieval.errorProcess", telemetryData.extendedBy({
    retrievalId: retrievalId,
    body: JSON.stringify(body) ?? "unknown",
    error: JSON.stringify(error) ?? "unknown"
  }), 1);
}
__name(telemetrizeProcessRetrievalError, "telemetrizeProcessRetrievalError");
function telemetrizeQueryRetrievalDebounce(ctx, pendingRetrievalId, telemetryData) {
  telemetry(ctx, "retrieval.debounced", telemetryData.extendedBy({
    pendingRetrievalId: pendingRetrievalId
  }), 0);
}
__name(telemetrizeQueryRetrievalDebounce, "telemetrizeQueryRetrievalDebounce");
function telemetrizeQueryRetrievalFromCache(ctx, cachedRetrievalId, cachedSnippets, telemetryData) {
  telemetry(ctx, "retrieval.cacheHit", telemetryData.extendedBy({
    cachedRetrievalId: cachedRetrievalId
  }, {
    numSnippetsReturned: cachedSnippets.length
  }), 0);
}
__name(telemetrizeQueryRetrievalFromCache, "telemetrizeQueryRetrievalFromCache");
var documentRequestStates = new Map();
function retrievalRequestUrl(repoNwo, serverRouteImpl) {
  return OPENAI_PROXY_HOST + `/v0/retrieval?repo=${repoNwo}&impl=${serverRouteImpl}`;
}
__name(retrievalRequestUrl, "retrievalRequestUrl");
function filterQuerySnippets(docInfo) {
  return snippet => snippet.relativePath === void 0 ? !0 : !(docInfo.uri.endsWith(snippet.relativePath) || snippet.relativePath.endsWith(docInfo.uri));
}
__name(filterQuerySnippets, "filterQuerySnippets");
async function postRetrievalRequest(ctx, docInfo, retrievalContext, retrievalOptions, telemetryData) {
  let retrievalId = v4_default();
  documentRequestStates.set(docInfo.uri, {
    state: "pending",
    retrievalId: retrievalId
  });
  let secretKey = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token;
  telemetrizePostRetrievalRequest(ctx, docInfo, retrievalId, retrievalContext, retrievalOptions, telemetryData), postRequest(ctx, retrievalRequestUrl(retrievalOptions.repoNwo, retrievalOptions.serverRouteImpl), secretKey, void 0, v4_default(), {
    query: retrievalContext.querySnippet,
    options: {
      ...retrievalOptions.server
    }
  }).then(async response => {
    if (logger.info(ctx, `Retrieval request for ${docInfo.uri} finished`), response.status === 200) documentRequestStates.set(docInfo.uri, {
      state: "response",
      retrievalId: retrievalId,
      retrievalContext: retrievalContext,
      response: response,
      retrievalOptions: retrievalOptions
    }), telemetrizePostRetrievalResponse(ctx, retrievalId, response, telemetryData);else throw new Error(`Retrieval request failed with status ${response.status}`);
  }).catch(error => {
    logger.info(ctx, `Retrieval request for ${docInfo.uri} failed. Error: ${error}`), telemetrizePostRetrievalRequestError(ctx, retrievalId, error, telemetryData), documentRequestStates.set(docInfo.uri, {
      state: "idle"
    });
  });
}
__name(postRetrievalRequest, "postRetrievalRequest");
async function processRetrievalResponse(ctx, docInfo, retrievalId, retrievalContext, response, retrievalOptions, telemetryData) {
  if (documentRequestStates.set(docInfo.uri, {
    state: "idle"
  }), !equal(retrievalOptions, currentRetrievalOptions)) return;
  let {
      data: unparsedData,
      impl: impl
    } = await response.json(),
    data = JSON.parse(unparsedData);
  try {
    if (impl !== retrievalOptions.serverRouteImpl) throw new Error(`Wrong retrieval implementation returned from the proxy: expected ${retrievalOptions.serverRouteImpl}, got ${impl}`);
    if (data === null) throw new Error("Retrieval response body is null");
    logger.info(ctx, `Retrieval request for ${docInfo.uri} processed. Got ${data?.results?.length} snippets back`);
    let snippets = data.results.map(snippetFromRetrievalResult).filter(filterQuerySnippets(docInfo));
    logger.info(ctx, `There were ${snippets.length} after filtering`), retrievalCache?.put(docInfo.uri, retrievalId, retrievalContext, snippets.map(snippet => {
      let {
        restrictedTelemetry: restrictedTelemetry,
        ...rest
      } = snippet;
      return rest;
    })), telemetrizeProcessRetrievalResponse(ctx, retrievalId, data, snippets, telemetryData);
  } catch (error) {
    logger.exception(ctx, error, "Error while processing retrieval response"), telemetrizeProcessRetrievalError(ctx, retrievalId, data, error, telemetryData);
  }
}
__name(processRetrievalResponse, "processRetrievalResponse");
var retrievalCache, currentRetrievalOptions;
async function queryRetrievalSnippets(ctx, docInfo, retrievalOptions, telemetryData) {
  if (retrievalCache === void 0 || !equal(currentRetrievalOptions, retrievalOptions)) {
    let matcher = buildSnippetMatcher(retrievalOptions.cache.snippetMatcherName, retrievalOptions.cache.snippetMatcherThreshold);
    currentRetrievalOptions = retrievalOptions, retrievalCache = new RetrievalCache(matcher, retrievalOptions.cache.maxUriCacheSize);
  }
  let requestState = documentRequestStates.get(docInfo.uri) ?? {
    state: "idle"
  };
  if (requestState.state === "pending") return telemetrizeQueryRetrievalDebounce(ctx, requestState.retrievalId, telemetryData), [];
  requestState.state === "response" && (await processRetrievalResponse(ctx, docInfo, requestState.retrievalId, requestState.retrievalContext, requestState.response, requestState.retrievalOptions, telemetryData));
  let retrievalContext = getRetrievalContext(docInfo, retrievalOptions.context);
  if (retrievalContext.lineCount < (retrievalOptions.context.minLineCount ?? 0) || retrievalContext.tokenLength < (retrievalOptions.context.minTokenLength ?? 0)) return telemetrizeTooShortContext(ctx, docInfo, retrievalContext, telemetryData), [];
  let cacheHit = lookupCache(ctx, retrievalCache, docInfo, retrievalContext, telemetryData);
  return cacheHit === void 0 ? (await postRetrievalRequest(ctx, docInfo, retrievalContext, retrievalOptions, telemetryData), []) : (telemetrizeQueryRetrievalFromCache(ctx, cacheHit.retrievalId, cacheHit.snippets, telemetryData), logger.debug(ctx, `Retrieval cache hit for ${docInfo.uri}`), cacheHit.snippets.map(snippet => ({
    provider: z5.SnippetProviderType.Retrieval,
    semantics: z5.SnippetSemantics.Snippet,
    ...snippet
  })));
}
__name(queryRetrievalSnippets, "queryRetrievalSnippets");
async function getRetrievalOptions(ctx, featuresFilterArgs, telemetryData) {
  if (!(await ctx.get(Features).retrievalStrategy(featuresFilterArgs, telemetryData))) return;
  let serverRouteImpl = await ctx.get(Features).retrievalServerRoute(featuresFilterArgs, telemetryData),
    repoNwo;
  return featuresFilterArgs.repoNwo && featuresFilterArgs.repoNwo.length > 0 ? repoNwo = featuresFilterArgs.repoNwo : featuresFilterArgs.dogFood && featuresFilterArgs.dogFood.length > 0 ? repoNwo = featuresFilterArgs.dogFood : repoNwo = "", {
    repoNwo: repoNwo,
    serverRouteImpl: serverRouteImpl,
    context: {
      maxLineCount: 30,
      maxTokenLength: 1e3,
      minLineCount: 8,
      minTokenLength: 30
    },
    server: {
      results: 10,
      language: featuresFilterArgs.fileType,
      range_from: -10,
      range_to: 10,
      max_length: 192
    },
    cache: {
      snippetMatcherName: "lineBasedRelative",
      snippetMatcherThreshold: 40,
      maxUriCacheSize: 5
    }
  };
}
__name(getRetrievalOptions, "getRetrievalOptions");
function defaultHash(...args) {
  return JSON.stringify(args, (_, v) => typeof v == "object" ? v : String(v));
}
__name(defaultHash, "defaultHash");
function memoize(fn, opts = {}) {
  let {
    hash = defaultHash,
    cache = new Map()
  } = opts;
  return function (...args) {
    let id = hash.apply(this, args);
    if (cache.has(id)) return cache.get(id);
    let result = fn.apply(this, args);
    return result instanceof Promise && (result = result.catch(error => {
      throw cache.delete(id), error;
    })), cache.set(id, result), result;
  };
}
__name(memoize, "memoize");
function shortCircuit(fn, shortCircuitMs, shortCircuitReturn) {
  return async function (...args) {
    return await Promise.race([fn.apply(this, args), new Promise(resolve => {
      setTimeout(resolve, shortCircuitMs, shortCircuitReturn);
    })]);
  };
}
__name(shortCircuit, "shortCircuit");
var logger = new Logger(1, "symbol_def"),
  lruCacheSize = 1e3,
  SymbolDefinitionProvider = class {
    static {
      __name(this, "SymbolDefinitionProvider");
    }
  },
  getSymbolDefinition = __name(async function (ctx, symbolName, docInfo, symbolDefinitionProvider) {
    try {
      return await symbolDefinitionProvider.getSymbolDefinition(docInfo);
    } catch (error) {
      return logger.exception(ctx, error, "Error retrieving definitions"), [];
    }
  }, "getSymbolDefinition");
getSymbolDefinition = memoize(getSymbolDefinition, {
  cache: new LRUCacheMap(lruCacheSize),
  hash: (ctx, symbolName, docInfo, symbolDefinitionProvider) => `${docInfo.uri}#${symbolName}`
});
getSymbolDefinition = shortCircuit(getSymbolDefinition, 100, []);
async function getSymbolDefSnippets(ctx, docInfo) {
  let symbolDefinitionProvider = ctx.get(SymbolDefinitionProvider),
    callerFunctions = await promptLibProxy.getCallSites(docInfo);
  if (callerFunctions.length == 0) return [];
  let symbolDefinitionPromises = [];
  for (let callerFunc of callerFunctions) {
    let docInfoSnippet = {
        ...docInfo,
        position: callerFunc.position
      },
      symbolDefPromises = getSymbolDefinition(ctx, callerFunc.name, docInfoSnippet, symbolDefinitionProvider);
    symbolDefinitionPromises.push(symbolDefPromises);
  }
  return (await Promise.all(symbolDefinitionPromises)).flat();
}
__name(getSymbolDefSnippets, "getSymbolDefSnippets");
var MIN_PROMPT_CHARS = 10,
  _contextTooShort = {
    type: "contextTooShort"
  },
  _copilotNotAvailable = {
    type: "copilotNotAvailable"
  };
async function getPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData) {
  let docInfo = {
      uri: uri.toString(),
      source: source,
      offset: offset,
      relativePath: relativePath,
      languageId: languageId
    },
    repoInfo = extractRepoInfoInBackground(ctx, uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    userKind = await getUserKind(ctx),
    dogFood = getDogFood(repoInfo),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: languageId,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    },
    tokenizerName = M0.TokenizerName.cl100k,
    defaultPromptCompletionTokens = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).getTokenValue("8kp") === "1" ? 8192 : 2048,
    maxPromptLength = (await ctx.get(Features).maxPromptCompletionTokens(featuresFilterArgs, defaultPromptCompletionTokens)) - getConfig(ctx, ConfigKey.SolutionLength),
    neighboringTabs = await ctx.get(Features).neighboringTabsOption(featuresFilterArgs),
    neighboringSnippetTypes = await ctx.get(Features).neighboringSnippetTypes(featuresFilterArgs),
    numberOfSnippets = await ctx.get(Features).numberOfSnippets(featuresFilterArgs),
    snippetPercent = await ctx.get(Features).snippetPercent(featuresFilterArgs),
    suffixStartMode = await ctx.get(Features).suffixStartMode(featuresFilterArgs),
    cursorSnippetsPickingStrategy = await ctx.get(Features).cursorSnippetsPickingStrategy(featuresFilterArgs),
    promptOptions = {
      maxPromptLength: maxPromptLength,
      neighboringTabs: neighboringTabs,
      suffixStartMode: suffixStartMode,
      tokenizerName: tokenizerName,
      neighboringSnippetTypes: neighboringSnippetTypes,
      cursorSnippetsPickingStrategy: cursorSnippetsPickingStrategy,
      numberOfSnippets: numberOfSnippets,
      snippetPercent: snippetPercent
    },
    suffixPercent = await ctx.get(Features).suffixPercent(featuresFilterArgs),
    suffixMatchThreshold = await ctx.get(Features).suffixMatchThreshold(featuresFilterArgs),
    fimSuffixLengthThreshold = await ctx.get(Features).fimSuffixLengthThreshold(featuresFilterArgs),
    localImportContextEnabled = await ctx.get(Features).localImportContext(featuresFilterArgs);
  suffixPercent > 0 && (promptOptions = {
    ...promptOptions,
    suffixPercent: suffixPercent,
    suffixMatchThreshold: suffixMatchThreshold,
    fimSuffixLengthThreshold: fimSuffixLengthThreshold,
    localImportContext: localImportContextEnabled
  });
  let fileSystem = ctx.get(M0.FileSystem),
    promptInfo,
    history = new Map();
  for (let key of cursorHistoryManager.lineCursorHistory.keys()) history.set(key, cursorHistoryManager.lineCursorHistory.get(key) ?? new Map());
  let snippets = [];
  telemetryData || (telemetryData = TelemetryData.createAndMarkAsIssued());
  let retrievalOptions = await getRetrievalOptions(ctx, featuresFilterArgs, telemetryData);
  if (retrievalOptions && (snippets = await queryRetrievalSnippets(ctx, docInfo, retrievalOptions, telemetryData)), await ctx.get(Features).symbolDefinitionStrategy(featuresFilterArgs)) {
    let symbolDefSnippets = await getSymbolDefSnippets(ctx, docInfo);
    snippets.push(...symbolDefSnippets);
  }
  let docs = [],
    neighborSource = new Map();
  try {
    let files = await NeighborSource.getNeighborFiles(ctx, uri, featuresFilterArgs);
    docs = files.docs, neighborSource = files.neighborSource;
  } catch (e) {
    telemetryException(ctx, e, "prompt.getPromptForSource.exception");
  }
  try {
    let spContext = {
        currentFile: docInfo,
        neighborFiles: docs,
        options: new M0.PromptOptions(fileSystem, promptOptions),
        lineCursorHistory: history
      },
      snippetProviderResults = await ctx.get(M0.SnippetOrchestrator).getSnippets(spContext),
      orchestratorSnippets = (0, M0.providersSnippets)(snippetProviderResults),
      errors = (0, M0.providersErrors)(snippetProviderResults),
      {
        runtimes: runtimes,
        timeouts: timeouts
      } = (0, M0.providersPerformance)(snippetProviderResults);
    telemetryData.extendWithConfigProperties(ctx), telemetryData.sanitizeKeys(), await telemetryRaw(ctx, "prompt.stat", {
      ...mkBasicResultTelemetry(telemetryData),
      ...(timeouts[M0.SnippetProviderType.NeighboringTabs] && {
        neighborFilesTimeout: "true"
      })
    }, {
      ...(typeof runtimes[M0.SnippetProviderType.NeighboringTabs] == "number" && {
        neighborFilesRuntimeMs: runtimes[M0.SnippetProviderType.NeighboringTabs]
      })
    });
    for (let e of errors) e.error instanceof M0.ProviderTimeoutError || (await telemetryException(ctx, e.error, "getSnippets"));
    snippets.push(...orchestratorSnippets);
  } catch (e) {
    throw await telemetryException(ctx, e, "prompt.orchestrator.getSnippets.exception"), e;
  }
  try {
    promptInfo = await promptLibProxy.getPrompt(fileSystem, docInfo, promptOptions, snippets);
  } catch (e) {
    throw await telemetryException(ctx, e, "prompt.getPromptForSource.exception"), e;
  }
  return {
    neighborSource: neighborSource,
    ...promptInfo
  };
}
__name(getPromptForSource, "getPromptForSource");
function trimLastLine(source) {
  let lines = source.split(`
`),
    lastLine = lines[lines.length - 1],
    extraSpace = lastLine.length - lastLine.trimRight().length,
    promptTrim = source.slice(0, source.length - extraSpace),
    trailingWs = source.slice(promptTrim.length);
  return [lastLine.length == extraSpace ? promptTrim : source, trailingWs];
}
__name(trimLastLine, "trimLastLine");
async function extractPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData) {
  if ((await ctx.get(CopilotRepositoryControlManager).evaluate(uri, source, "UPDATE")).isBlocked) return _copilotNotAvailable;
  let repoInfo = extractRepoInfoInBackground(ctx, uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    userKind = await getUserKind(ctx),
    dogFood = getDogFood(repoInfo),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: languageId,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    },
    suffixPercent = await ctx.get(Features).suffixPercent(featuresFilterArgs),
    fimSuffixLengthThreshold = await ctx.get(Features).fimSuffixLengthThreshold(featuresFilterArgs);
  if ((suffixPercent > 0 ? source.length : offset) < MIN_PROMPT_CHARS) return _contextTooShort;
  let startTime = Date.now(),
    {
      prefix: prefix,
      suffix: suffix,
      prefixLength: prefixLength,
      suffixLength: suffixLength,
      promptChoices: promptChoices,
      promptBackground: promptBackground,
      promptElementRanges: promptElementRanges,
      neighborSource: neighborSource
    } = await getPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData),
    [resPrompt, trailingWs] = trimLastLine(prefix),
    endTime = Date.now();
  return {
    type: "prompt",
    prompt: {
      prefix: resPrompt,
      suffix: suffix,
      prefixTokens: prefixLength,
      suffixTokens: suffixLength,
      isFimEnabled: suffixPercent > 0 && suffix.length > fimSuffixLengthThreshold,
      promptElementRanges: promptElementRanges.ranges
    },
    trailingWs: trailingWs,
    promptChoices: promptChoices,
    computeTimeMs: endTime - startTime,
    promptBackground: promptBackground,
    neighborSource: neighborSource
  };
}
__name(extractPromptForSource, "extractPromptForSource");
async function extractPromptForDocument(ctx, doc, position, telemetryData) {
  let relativePath = await ctx.get(TextDocumentManager).getRelativePath(doc);
  return extractPromptForSource(ctx, doc.getText(), doc.offsetAt(position), relativePath, doc.uri, doc.languageId, telemetryData);
}
__name(extractPromptForDocument, "extractPromptForDocument");
function addNeighboringCellsToPrompt(neighboringCell, activeCellLanguageId) {
  let languageId = neighboringCell.document.languageId,
    text = neighboringCell.document.getText();
  return languageId === activeCellLanguageId ? text : (0, M0.commentBlockAsSingles)(text, activeCellLanguageId);
}
__name(addNeighboringCellsToPrompt, "addNeighboringCellsToPrompt");
async function extractPromptForNotebook(ctx, doc, notebook, position, telemetryData) {
  let activeCell = notebook.getCells().find(cell => cell.document.uri.toString() === doc.uri.toString());
  if (activeCell) {
    let beforeCells = notebook.getCells().filter(cell => cell.index < activeCell.index && considerNeighborFile(activeCell.document.languageId, cell.document.languageId)),
      beforeSource = beforeCells.length > 0 ? beforeCells.map(cell => addNeighboringCellsToPrompt(cell, activeCell.document.languageId)).join(`

`) + `

` : "",
      source = beforeSource + doc.getText(),
      offset = beforeSource.length + doc.offsetAt(position),
      relativePath = await ctx.get(TextDocumentManager).getRelativePath(doc);
    return extractPromptForSource(ctx, source, offset, relativePath, doc.uri, activeCell.document.languageId, telemetryData);
  } else return extractPromptForDocument(ctx, doc, position, telemetryData);
}
__name(extractPromptForNotebook, "extractPromptForNotebook");
function extractPrompt(ctx, doc, position, telemetryData) {
  let notebook = ctx.get(TextDocumentManager).findNotebook(doc);
  return notebook === void 0 ? extractPromptForDocument(ctx, doc, position, telemetryData) : extractPromptForNotebook(ctx, doc, notebook, position, telemetryData);
}
__name(extractPrompt, "extractPrompt");
var ghostTextDisplayInterceptParameter = 2.98410452738298,
  ghostTextDisplayLog1pcompCharLenParameter = -.838732736843507,
  ghostTextDisplayMeanLogProbParameter = 1.50314646255716,
  ghostTextDisplayMeanAlternativeLogProbParameter = -.237798634012662,
  ghostTextDisplayLanguageParameters = {
    python: .314368072478742
  },
  ghostTextDisplayQuantiles = {
    "0.01": .225800751784931,
    "0.02": .290204307767402,
    "0.03": .333153496466045,
    "0.05": .404516749849559,
    "0.1": .513216040545626,
    "0.2": .626904979128674,
    "0.3": .694880719658273,
    "0.4": .743100684947291,
    "0.5": .782524520571946,
    "0.6": .816856186092243,
    "0.7": .84922977716585,
    "0.8": .883694877241999,
    "0.9": .921859050950077,
    "0.95": .944571268106974,
    "0.99": .969535563141733
  };
var restraintLogger = new Logger(1, "restraint"),
  Logit = {
    link: x => Math.exp(x) / (1 + Math.exp(x)),
    unlink: p => Math.log(p / (1 - p))
  };
function linearInterpolation(x0, points) {
  let x_after = Math.min(...Array.from(points.keys()).filter(x => x >= x0)),
    x_before = Math.max(...Array.from(points.keys()).filter(x => x < x0)),
    y_after = points.get(x_after),
    y_before = points.get(x_before);
  return y_before + (y_after - y_before) * (x0 - x_before) / (x_after - x_before);
}
__name(linearInterpolation, "linearInterpolation");
var Regressor = class {
    static {
      __name(this, "Regressor");
    }
    constructor(name, coefficient, transformation) {
      this.name = name, this.coefficient = coefficient, this.transformation = transformation || (x => x);
    }
    contribution(value) {
      return this.coefficient * this.transformation(value);
    }
  },
  LogisticRegression = class {
    constructor(intercept, coefficients, quantiles) {
      this.link = Logit;
      if (this.intercept = intercept, this.coefficients = coefficients, this.logitsToQuantiles = new Map(), this.logitsToQuantiles.set(0, 0), this.logitsToQuantiles.set(1, 1), quantiles) for (let key in quantiles) this.logitsToQuantiles.set(quantiles[key], Number(key));
    }
    static {
      __name(this, "LogisticRegression");
    }
    predict(ctx, values) {
      let sum = this.intercept;
      for (let regressor of this.coefficients) {
        let value = values[regressor.name];
        if (value === void 0) return NaN;
        sum += regressor.contribution(value);
      }
      return this.link.link(sum);
    }
    quantile(ctx, values) {
      let logit = this.predict(ctx, values);
      return linearInterpolation(logit, this.logitsToQuantiles);
    }
  },
  ghostTextRetentionModel = new LogisticRegression(ghostTextDisplayInterceptParameter, [new Regressor("compCharLen", ghostTextDisplayLog1pcompCharLenParameter, x => Math.log(1 + x)), new Regressor("meanLogProb", ghostTextDisplayMeanLogProbParameter), new Regressor("meanAlternativeLogProb", ghostTextDisplayMeanAlternativeLogProbParameter)].concat(Object.entries(ghostTextDisplayLanguageParameters).map(value => new Regressor(value[0], value[1]))), ghostTextDisplayQuantiles);
function ghostTextScoreConfidence(ctx, telemetryData) {
  let values = {
    ...telemetryData.measurements
  };
  return Object.keys(ghostTextDisplayLanguageParameters).forEach(lang => {
    values[lang] = telemetryData.properties["customDimensions.languageId"] == lang ? 1 : 0;
  }), ghostTextRetentionModel.predict(ctx, values);
}
__name(ghostTextScoreConfidence, "ghostTextScoreConfidence");
function ghostTextScoreQuantile(ctx, telemetryData) {
  let values = {
    ...telemetryData.measurements
  };
  return Object.keys(ghostTextDisplayLanguageParameters).forEach(lang => {
    values[lang] = telemetryData.properties["customDimensions.languageId"] == lang ? 1 : 0;
  }), ghostTextRetentionModel.quantile(ctx, values);
}
__name(ghostTextScoreQuantile, "ghostTextScoreQuantile");
var configs = [{
  max_token_sequence_length: 1,
  last_tokens_to_consider: 10
}, {
  max_token_sequence_length: 10,
  last_tokens_to_consider: 30
}, {
  max_token_sequence_length: 20,
  last_tokens_to_consider: 45
}, {
  max_token_sequence_length: 30,
  last_tokens_to_consider: 60
}];
function isRepetitive(tokens) {
  let tokensBackwards = tokens.slice();
  return tokensBackwards.reverse(), isRepeatedPattern(tokensBackwards) || isRepeatedPattern(tokensBackwards.filter(token => token.trim().length > 0));
}
__name(isRepetitive, "isRepetitive");
function isRepeatedPattern(s) {
  let prefix = kmp_prefix_function(s);
  for (let config of configs) {
    if (s.length < config.last_tokens_to_consider) continue;
    if (config.last_tokens_to_consider - 1 - prefix[config.last_tokens_to_consider - 1] <= config.max_token_sequence_length) return !0;
  }
  return !1;
}
__name(isRepeatedPattern, "isRepeatedPattern");
function kmp_prefix_function(s) {
  let pi = Array(s.length).fill(0);
  pi[0] = -1;
  let k = -1;
  for (let q = 1; q < s.length; q++) {
    for (; k >= 0 && s[k + 1] !== s[q];) k = pi[k];
    s[k + 1] === s[q] && k++, pi[q] = k;
  }
  return pi;
}
__name(kmp_prefix_function, "kmp_prefix_function");
function maybeSnipCompletion(ctx, doc, position, completion, isMiddleOfTheLineSuggestion) {
  let blockCloseToken = "}";
  try {
    blockCloseToken = promptLibProxy.getBlockCloseToken(doc.languageId) ?? "}";
  } catch {}
  if (getHiddenConfig(ctx, ConfigKey.DebugTruncationKiwi, {
    default: !0
  })) return maybeSnipCompletionImpl({
    getLineText: lineIdx => doc.lineAt(lineIdx).text,
    getLineCount: () => doc.lineCount
  }, position, completion, blockCloseToken);
  {
    if (completion == "") return completion;
    let nextLineStart = completion.length;
    do {
      let thisLineStart = completion.lastIndexOf(`
`, nextLineStart - 2) + 1,
        line = completion.substring(thisLineStart, nextLineStart);
      if (line.trim() === blockCloseToken) {
        for (let i = position.line; i < doc.lineCount; i++) {
          let lineText = doc.lineAt(i).text;
          if (i === position.line && (lineText = lineText.substr(position.character)), lineText.startsWith(line.trimRight())) return completion.substring(0, Math.max(0, isMiddleOfTheLineSuggestion ? thisLineStart : thisLineStart - 1));
          if (lineText.trim() !== "") break;
        }
        break;
      }
      if (nextLineStart === thisLineStart) {
        if (shouldFailForDebugPurposes(ctx)) throw Error(`Aborting: maybeSnipCompletion would have looped on completion: ${completion}`);
        break;
      }
      nextLineStart = thisLineStart;
    } while (nextLineStart > 1);
    return completion;
  }
}
__name(maybeSnipCompletion, "maybeSnipCompletion");
function maybeSnipCompletionImpl(doc, position, completion, blockCloseToken) {
  let completionLinesInfo = splitByNewLine(completion),
    completionLines = completionLinesInfo.lines;
  if (completionLines.length === 1) return completion;
  for (let completionLineStartIdx = 1; completionLineStartIdx < completionLines.length; completionLineStartIdx++) {
    let matched = !0,
      docSkippedEmptyLineCount = 0,
      completionSkippedEmptyLineCount = 0;
    for (let offset = 0; offset + completionLineStartIdx + completionSkippedEmptyLineCount < completionLines.length; offset++) {
      let docLine;
      do {
        let docLineIdx = position.line + 1 + offset + docSkippedEmptyLineCount;
        if (docLine = docLineIdx >= doc.getLineCount() ? void 0 : doc.getLineText(docLineIdx), docLine !== void 0 && docLine.trim() === "") docSkippedEmptyLineCount++;else break;
      } while (!0);
      let completionLineIdx, completionLine;
      do if (completionLineIdx = completionLineStartIdx + offset + completionSkippedEmptyLineCount, completionLine = completionLineIdx >= completionLines.length ? void 0 : completionLines[completionLineIdx], completionLine !== void 0 && completionLine.trim() === "") completionSkippedEmptyLineCount++;else break; while (!0);
      let isLastCompletionLine = completionLineIdx === completionLines.length - 1;
      if (!completionLine || !(docLine && completionLine.trim() === blockCloseToken && (isLastCompletionLine ? docLine.startsWith(completionLine) : docLine === completionLine))) {
        matched = !1;
        break;
      }
    }
    if (matched) return completionLines.slice(0, completionLineStartIdx).join(completionLinesInfo.newLineCharacter);
  }
  return completion;
}
__name(maybeSnipCompletionImpl, "maybeSnipCompletionImpl");
function splitByNewLine(text) {
  let newLineCharacter = text.includes(`\r
`) ? `\r
` : `
`;
  return {
    lines: text.split(newLineCharacter),
    newLineCharacter: newLineCharacter
  };
}
__name(splitByNewLine, "splitByNewLine");
function matchesNextLine(document, position, text) {
  let nextLine = "",
    lineNo = position.line + 1;
  for (; nextLine === "" && lineNo < document.lineCount;) {
    if (nextLine = document.lineAt(lineNo).text.trim(), nextLine === text.trim()) return !0;
    lineNo++;
  }
  return !1;
}
__name(matchesNextLine, "matchesNextLine");
async function postProcessChoice(ctx, insertionCategory, document, position, choice, isMiddleOfTheLineSuggestion, logger, prompt, actualSuffix) {
  if (isRepetitive(choice.tokens)) {
    let telemetryData = TelemetryData.createAndMarkAsIssued();
    telemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, "repetition.detected", telemetryData, 1), logger.info(ctx, "Filtered out repetitive solution");
    return;
  }
  let postProcessedChoice = {
    ...choice
  };
  if (matchesNextLine(document, position, postProcessedChoice.completionText)) {
    let baseTelemetryData = TelemetryData.createAndMarkAsIssued();
    baseTelemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, "completion.alreadyInDocument", baseTelemetryData), telemetry(ctx, "completion.alreadyInDocument", baseTelemetryData.extendedBy({
      completionTextJson: JSON.stringify(postProcessedChoice.completionText)
    }), 1), logger.info(ctx, "Filtered out solution matching next line");
    return;
  }
  return getHiddenConfig(ctx, ConfigKey.DebugTruncationKiwi, {
    default: !0
  }) && (postProcessedChoice.completionText = removeDifferenceOfCachedVsActualPromptSuffix(postProcessedChoice.completionText, actualSuffix, prompt)), postProcessedChoice.completionText = maybeSnipCompletion(ctx, document, position, postProcessedChoice.completionText, isMiddleOfTheLineSuggestion), postProcessedChoice.completionText ? postProcessedChoice : void 0;
}
__name(postProcessChoice, "postProcessChoice");
function removeDifferenceOfCachedVsActualPromptSuffix(completionText, actualSuffix, prompt) {
  actualSuffix = actualSuffix.trim();
  let idxOfCachedSuffixInActualSuffix = actualSuffix.indexOf(prompt.suffix);
  if (idxOfCachedSuffixInActualSuffix <= 0) return completionText;
  let missing = actualSuffix.substring(0, idxOfCachedSuffixInActualSuffix).trim();
  return removeSuffix(completionText, missing);
}
__name(removeDifferenceOfCachedVsActualPromptSuffix, "removeDifferenceOfCachedVsActualPromptSuffix");
function removeSuffix(str, suffix) {
  return str.endsWith(suffix) ? str.substring(0, str.length - suffix.length) : str;
}
__name(removeSuffix, "removeSuffix");
function checkSuffix(document, position, choice) {
  let restOfLine = document.lineAt(position.line).text.substring(position.character);
  if (restOfLine.length > 0) {
    if (choice.completionText.indexOf(restOfLine) !== -1) return !0;
    {
      let lastIndex = 0;
      for (let c of restOfLine) {
        let idx = choice.completionText.indexOf(c, lastIndex + 1);
        if (idx > lastIndex) lastIndex = idx;else {
          lastIndex = -1;
          break;
        }
      }
      return lastIndex !== -1;
    }
  }
  return !1;
}
__name(checkSuffix, "checkSuffix");
async function getDebounceLimit(ctx, telemetryData) {
  let expDebounce;
  if ((await ctx.get(Features).debouncePredict()) && telemetryData.measurements.contextualFilterScore) {
    let acceptProbability = telemetryData.measurements.contextualFilterScore,
      sigmoidMin = 25,
      sigmoidRange = 250,
      sigmoidShift = .3475,
      sigmoidSlope = 7;
    expDebounce = sigmoidMin + sigmoidRange / (1 + Math.pow(acceptProbability / sigmoidShift, sigmoidSlope));
  } else expDebounce = await ctx.get(Features).debounceMs();
  return expDebounce > 0 ? expDebounce : 75;
}
__name(getDebounceLimit, "getDebounceLimit");
function multilineModelPredict(input) {
  let var0;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 427.50000000000006 ? input[9] > 13.500000000000002 ? input[121] > 1e-35 ? var0 = -.3793786744885956 : input[149] > 1e-35 ? var0 = -.34717430705356905 : var0 = -.26126834451035963 : var0 = -.2431318366096852 : input[5] > 888.5000000000001 ? var0 = -.20600463586387135 : var0 = -.2568037008471491 : input[308] > 1e-35 ? var0 = -.2363064824497454 : input[8] > 370.50000000000006 ? var0 = -.37470755210284723 : var0 = -.321978453730494 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var0 = -.26259136509758885 : var0 = -.3096719634039438 : input[4] > 30.500000000000004 ? input[9] > 18.500000000000004 ? var0 = -.34254903852890883 : input[2] > 98.50000000000001 ? var0 = -.41585250791146294 : var0 = -.3673574858887241 : input[9] > 6.500000000000001 ? var0 = -.31688079287876225 : input[31] > 1e-35 ? var0 = -.29110977864003823 : input[308] > 1e-35 ? var0 = -.3201411739040839 : var0 = -.36874023066055506 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var0 = -.41318393149040566 : input[133] > 1e-35 ? var0 = -.3741272613525161 : input[32] > 1e-35 ? var0 = -.4112378041027121 : input[227] > 1e-35 ? var0 = -.37726615155719356 : input[10] > 3.5000000000000004 ? var0 = -.3164502293560397 : var0 = -.2930071546509045 : input[9] > 13.500000000000002 ? var0 = -.277366858539218 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var0 = -.30975610686807187 : input[4] > 1.5000000000000002 ? var0 = -.2549142136728043 : var0 = -.3271325650785176 : input[127] > 1e-35 ? input[0] > 1937.5000000000002 ? var0 = -.2533046188098832 : var0 = -.325520883579 : var0 = -.331628896481776;
  let var1;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? input[9] > 13.500000000000002 ? var1 = .031231253521808708 : var1 = .05380836288014532 : input[5] > 423.00000000000006 ? input[8] > 114.50000000000001 ? var1 = .06751619128429062 : var1 = .09625089153176467 : var1 = .027268163053989804 : input[308] > 1e-35 ? var1 = .060174483556283756 : var1 = -.049062854038919135 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var1 = -.03969241799174589 : var1 = .01086816842550381 : input[31] > 1e-35 ? var1 = -.003284694817583201 : input[9] > 6.500000000000001 ? input[4] > 30.500000000000004 ? var1 = -.04224490699947552 : var1 = -.011834162944360616 : input[308] > 1e-35 ? input[32] > 1e-35 ? var1 = -.13448447971850278 : var1 = -.019569456707046823 : input[19] > 1e-35 ? input[9] > 1.5000000000000002 ? var1 = -.07256260662659254 : input[4] > 60.50000000000001 ? var1 = -.08227503453609311 : var1 = -.020596416747563847 : var1 = -.07396549241564149 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var1 = -.10046536995362734 : input[133] > 1e-35 ? var1 = -.06407649822752297 : input[225] > 1e-35 ? var1 = .08035785003303324 : input[92] > 1e-35 ? var1 = .018901360933204676 : input[20] > 1e-35 ? var1 = .05252546973665552 : input[8] > 2592.5000000000005 ? var1 = -.040543705016462955 : var1 = -.011236043818320725 : input[9] > 17.500000000000004 ? var1 = .025560632674895334 : input[308] > 1e-35 ? input[0] > 1847.5000000000002 ? var1 = .03527165701669741 : var1 = -.0071847350825815035 : input[127] > 1e-35 ? var1 = .024373016379595405 : input[9] > 2.5000000000000004 ? var1 = -.0035090719709448288 : var1 = -.03514829488063766;
  let var2;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? var2 = .03848674861536988 : input[5] > 423.00000000000006 ? input[8] > 114.50000000000001 ? input[9] > 56.50000000000001 ? var2 = -.003764520033319488 : var2 = .06570817919969299 : input[4] > 61.50000000000001 ? var2 = .028346156293069538 : var2 = .0908154644362606 : var2 = .02445594243234816 : input[308] > 1e-35 ? input[8] > 65.50000000000001 ? var2 = .0019305229020073053 : var2 = .09279357295883772 : var2 = -.04458984161917124 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? var2 = .0027405390271277013 : input[4] > 29.500000000000004 ? input[52] > 1e-35 ? var2 = .044727478132905285 : input[115] > 1e-35 ? var2 = .10245804828855934 : input[9] > 17.500000000000004 ? var2 = -.03353173647469207 : input[2] > 98.50000000000001 ? var2 = -.10048106638102179 : var2 = -.05484231104348874 : input[31] > 1e-35 ? var2 = .016807537467116516 : input[9] > 6.500000000000001 ? var2 = -.012113620535295137 : input[4] > 8.500000000000002 ? input[308] > 1e-35 ? var2 = -.01882594250504289 : var2 = -.05585658862796076 : var2 = .04279591277938338 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var2 = -.09262278043707878 : input[133] > 1e-35 ? var2 = -.058454257768893625 : input[32] > 1e-35 ? var2 = -.09769348447126434 : input[25] > 1e-35 ? var2 = -.0725430043727677 : input[122] > 1e-35 ? var2 = -.10047841601578077 : var2 = -.00580671054458958 : input[9] > 13.500000000000002 ? var2 = .021399199032818294 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var2 = -.0076376731757173515 : var2 = .03394923033036848 : input[127] > 1e-35 ? var2 = .02070489091204209 : var2 = -.02290162726126496;
  let var3;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[9] > 21.500000000000004 ? var3 = .010230295672324606 : var3 = .038540509248742805 : input[8] > 125.50000000000001 ? input[1] > 49.50000000000001 ? var3 = .03086356292895467 : var3 = .057128750867458604 : input[5] > 888.5000000000001 ? var3 = .07861602941396924 : var3 = .030523262699070908 : input[308] > 1e-35 ? var3 = .048236117667577356 : input[8] > 370.50000000000006 ? var3 = -.05642125069212264 : var3 = -.007232836777168195 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var3 = .03640661467213915 : var3 = -.005889820723907028 : input[31] > 1e-35 ? var3 = -.0009007166998276938 : input[9] > 6.500000000000001 ? var3 = -.022590340093882378 : input[308] > 1e-35 ? input[32] > 1e-35 ? var3 = -.1215445089091064 : var3 = -.01435612266219722 : input[19] > 1e-35 ? input[9] > 1.5000000000000002 ? var3 = -.061555513040777825 : input[4] > 60.50000000000001 ? var3 = -.07053475504569347 : var3 = -.013733369453963092 : var3 = -.06302097189114152 : input[227] > 1e-35 ? var3 = -.05820440333190048 : input[8] > 683.5000000000001 ? input[82] > 1e-35 ? var3 = -.08466979526809346 : input[10] > 24.500000000000004 ? var3 = -.017092159721119944 : input[92] > 1e-35 ? var3 = .03592901452463749 : var3 = -.00359310519524756 : input[5] > 1809.5000000000002 ? input[243] > 1e-35 ? var3 = -.03963116207386097 : input[118] > 1e-35 ? var3 = -.09483996283536394 : input[217] > 1e-35 ? var3 = -.03394542089519989 : input[242] > 1e-35 ? var3 = -.07985899422287938 : var3 = .019706602160656964 : input[9] > 12.500000000000002 ? var3 = .014072998937735146 : var3 = -.021156294523894684;
  let var4;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[9] > 21.500000000000004 ? var4 = .009197756540516563 : var4 = .03458896869535166 : input[5] > 5082.500000000001 ? var4 = .08265545468131008 : input[131] > 1e-35 ? var4 = .0740738432473315 : var4 = .045159136632942756 : input[8] > 319.50000000000006 ? var4 = -.04653401534465376 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var4 = -.011400839766681709 : var4 = .11149800187510031 : var4 = -.08683250977599462 : var4 = .08355310136724753 : input[4] > 23.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var4 = .040389083779932555 : var4 = -.009887614274108602 : input[52] > 1e-35 ? var4 = .03705353499757327 : input[9] > 6.500000000000001 ? var4 = -.025401260429257562 : input[2] > 98.50000000000001 ? var4 = -.09237673187534504 : var4 = -.04298556869281803 : input[222] > 1e-35 ? var4 = -.045221965895986184 : input[8] > 691.5000000000001 ? input[133] > 1e-35 ? var4 = -.05435318330148897 : input[128] > 1e-35 ? var4 = -.08672907303184191 : input[227] > 1e-35 ? var4 = -.05568304584186561 : input[122] > 1e-35 ? var4 = -.09623059693538563 : input[225] > 1e-35 ? var4 = .07558331642202279 : input[82] > 1e-35 ? var4 = -.07360566227233566 : var4 = -.005646164647395919 : input[242] > 1e-35 ? var4 = -.08203758341228108 : input[9] > 13.500000000000002 ? var4 = .018726123829696042 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var4 = -.011153942154062704 : var4 = .03132858912391067 : input[127] > 1e-35 ? var4 = .021455228822345174 : input[23] > 1e-35 ? var4 = .01959966745346997 : var4 = -.021764790177579325;
  let var5;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 284.50000000000006 ? input[121] > 1e-35 ? input[18] > 1e-35 ? var5 = .07547602514276922 : var5 = -.08529678832140396 : var5 = .030314822344598043 : input[5] > 888.5000000000001 ? input[4] > 61.50000000000001 ? var5 = .011143589009415464 : var5 = .0654700456802118 : var5 = .021794712646632755 : input[308] > 1e-35 ? var5 = .04231872551095028 : var5 = -.034381999950549455 : input[4] > 23.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var5 = -.03678981254332261 : var5 = .010518160384496255 : input[8] > 825.5000000000001 ? var5 = -.04506534842082387 : input[9] > 38.50000000000001 ? var5 = .01004983052203438 : var5 = -.030580958620701027 : input[39] > 1e-35 ? var5 = -.12802435021505382 : input[8] > 691.5000000000001 ? input[23] > 1e-35 ? input[203] > 1e-35 ? input[4] > 6.500000000000001 ? var5 = .030426957004611704 : var5 = -.0726407693060581 : var5 = .017395521646964375 : input[4] > 7.500000000000001 ? input[0] > 93.50000000000001 ? input[9] > 7.500000000000001 ? var5 = -.008024349629981291 : input[31] > 1e-35 ? var5 = .01296539930850471 : input[308] > 1e-35 ? var5 = -.012855016509024084 : var5 = -.04564527976851505 : var5 = -.15681420504058596 : input[10] > 4.500000000000001 ? input[243] > 1e-35 ? var5 = -.1012064426380198 : var5 = -.0062808850924854194 : var5 = .030706323726162416 : input[9] > 13.500000000000002 ? var5 = .017081636133736405 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var5 = -.009306613091760644 : input[4] > 1.5000000000000002 ? var5 = .03655523200850989 : var5 = -.02671654212893341 : input[127] > 1e-35 ? var5 = .019261510468604387 : var5 = -.017627818570628936;
  let var6;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[308] > 1e-35 ? var6 = .036100405995889276 : var6 = .011709313297015793 : input[0] > 119.50000000000001 ? input[8] > 125.50000000000001 ? var6 = .03622542297472574 : var6 = .05595579157301536 : var6 = -.02234751038146796 : input[8] > 319.50000000000006 ? var6 = -.040132029478400735 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var6 = -.009306153573847916 : var6 = .10058509567064988 : var6 = -.0785668890966017 : input[9] > 28.500000000000004 ? var6 = -.04781977604130416 : var6 = .09753292614937459 : input[4] > 23.500000000000004 ? input[131] > 1e-35 ? var6 = .02372493254975127 : input[148] > 1e-35 ? var6 = .028103095989516644 : input[4] > 58.50000000000001 ? input[10] > 1e-35 ? var6 = -.05000852203469597 : var6 = .02922366846119705 : input[23] > 1e-35 ? var6 = -.0026335076988151292 : var6 = -.03073993752935585 : input[222] > 1e-35 ? var6 = -.03867374428185713 : input[32] > 1e-35 ? var6 = -.07220729365053084 : input[39] > 1e-35 ? var6 = -.11624524614351733 : input[8] > 691.5000000000001 ? input[133] > 1e-35 ? var6 = -.04836360271198036 : input[8] > 4968.500000000001 ? var6 = -.10873681915578029 : input[149] > 1e-35 ? var6 = -.11847484033769298 : input[122] > 1e-35 ? var6 = -.08916172460307559 : input[82] > 1e-35 ? var6 = -.06774726602152634 : var6 = -.0033469147714351327 : input[126] > 1e-35 ? var6 = -.09474445392080015 : input[8] > 131.50000000000003 ? input[118] > 1e-35 ? var6 = -.09002547031023511 : var6 = .015475385187009489 : input[25] > 1e-35 ? var6 = -.08175501232759151 : var6 = -.000429679055394914;
  let var7;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? var7 = .021942996005324917 : var7 = .042349138084484074 : input[308] > 1e-35 ? var7 = .036507270845732874 : var7 = -.028981850556764995 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? var7 = .00210930790963475 : input[31] > 1e-35 ? var7 = .006825358293027163 : input[9] > 6.500000000000001 ? var7 = -.013772084269062394 : input[308] > 1e-35 ? var7 = -.008307929099892574 : input[19] > 1e-35 ? var7 = -.027706313312904487 : var7 = -.04891108984170914 : input[134] > 1e-35 ? var7 = -.0605730733844732 : input[25] > 1e-35 ? var7 = -.05347926493253117 : input[227] > 1e-35 ? var7 = -.049415829249003666 : input[32] > 1e-35 ? var7 = -.06807799662179595 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? input[2] > 13.500000000000002 ? var7 = -.00016302718260794637 : var7 = -.10247095758122947 : input[210] > 1e-35 ? var7 = -.022149002072787024 : input[95] > 1e-35 ? var7 = .15222631630626304 : var7 = .027393884520465712 : input[9] > 7.500000000000001 ? input[225] > 1e-35 ? var7 = .13483346577752245 : input[3] > 9.500000000000002 ? input[243] > 1e-35 ? var7 = -.045352728133789516 : input[8] > 683.5000000000001 ? var7 = .00474372227519902 : var7 = .02635476098707525 : input[92] > 1e-35 ? var7 = .05659380819933452 : input[105] > 1e-35 ? var7 = .07431443210341222 : input[186] > 1e-35 ? var7 = .0915821133384904 : var7 = -.016414750130401053 : input[127] > 1e-35 ? var7 = .011824693641866162 : input[23] > 1e-35 ? var7 = .0228468674288774 : input[284] > 1e-35 ? var7 = .06606936863302432 : var7 = -.02872463273902358;
  let var8;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 125.50000000000001 ? input[288] > 1e-35 ? var8 = -.019844363904157558 : input[1] > 50.50000000000001 ? input[131] > 1e-35 ? var8 = .044961338592245194 : var8 = .003659599513761676 : input[121] > 1e-35 ? var8 = -.04057103630479994 : var8 = .03158560697078578 : input[0] > 421.50000000000006 ? input[4] > 61.50000000000001 ? var8 = -.0003708603406529278 : var8 = .05331312264472391 : var8 = .0006575958601218936 : input[8] > 319.50000000000006 ? var8 = -.034654694051901545 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var8 = -.0076053515916517005 : var8 = .09116695486305336 : var8 = -.07137458699162028 : var8 = .06633130654035282 : input[4] > 29.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var8 = -.0308520802187302 : var8 = .013156423968295541 : input[115] > 1e-35 ? var8 = .11581171687488252 : input[52] > 1e-35 ? input[10] > 22.500000000000004 ? var8 = .12264179915175587 : var8 = -.021905727233873535 : input[8] > 799.5000000000001 ? var8 = -.04181869575935412 : var8 = -.023695901673350575 : input[222] > 1e-35 ? var8 = -.034612899265371776 : input[8] > 691.5000000000001 ? input[9] > 98.50000000000001 ? var8 = -.06892116536821917 : input[149] > 1e-35 ? var8 = -.11194586444154514 : input[133] > 1e-35 ? var8 = -.04269583234000504 : input[128] > 1e-35 ? var8 = -.0644631966969502 : input[8] > 4968.500000000001 ? var8 = -.09650726096330133 : var8 = -.004219129180139438 : input[126] > 1e-35 ? var8 = -.08038306745347751 : input[5] > 1809.5000000000002 ? var8 = .009265335288169993 : input[9] > 2.5000000000000004 ? var8 = .006447645462117438 : var8 = -.021047132609551503;
  let var9;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[9] > 21.500000000000004 ? input[121] > 1e-35 ? var9 = -.08436540015142402 : input[8] > 1861.5000000000002 ? var9 = -.01621425699342421 : var9 = .01878613821895428 : var9 = .031052879158242532 : input[8] > 319.50000000000006 ? var9 = -.031536619360997865 : input[7] > 3.5000000000000004 ? var9 = -.004510586962343298 : var9 = .0596524941011746 : input[4] > 18.500000000000004 ? input[23] > 1e-35 ? var9 = .004757490541310808 : input[9] > 6.500000000000001 ? var9 = -.008842393772207996 : input[31] > 1e-35 ? var9 = .0010536183837006993 : input[308] > 1e-35 ? var9 = -.008145882815435419 : input[2] > 98.50000000000001 ? var9 = -.08404937622173021 : input[276] > 1e-35 ? var9 = .0020072791321856663 : input[19] > 1e-35 ? var9 = -.023031820639490178 : var9 = -.04553314326377875 : input[8] > 2134.5000000000005 ? var9 = -.02244583113572251 : input[134] > 1e-35 ? var9 = -.05592137394753121 : input[308] > 1e-35 ? input[49] > 1e-35 ? var9 = .09989109704064947 : input[4] > 10.500000000000002 ? input[2] > 13.500000000000002 ? var9 = -.00447733056482096 : var9 = -.10191061664873849 : var9 = .021765308380331864 : input[9] > 7.500000000000001 ? input[118] > 1e-35 ? var9 = -.07570059131536411 : input[243] > 1e-35 ? var9 = -.040983393346598646 : input[3] > 9.500000000000002 ? var9 = .014763759061483812 : input[92] > 1e-35 ? var9 = .05136368898963024 : var9 = -.008162398981149495 : input[127] > 1e-35 ? var9 = .013999119696708346 : input[23] > 1e-35 ? input[20] > 1e-35 ? var9 = .14138985500120907 : var9 = .008668274102844162 : input[284] > 1e-35 ? var9 = .06356484011042893 : var9 = -.024781304572706303;
  let var10;
  input[13] > 1e-35 ? input[3] > 8.500000000000002 ? input[8] > 892.5000000000001 ? input[0] > 384.50000000000006 ? var10 = .014387526569215037 : input[8] > 2266.5000000000005 ? var10 = -.1397298649743087 : var10 = .007953931014097788 : input[0] > 119.50000000000001 ? input[4] > 61.50000000000001 ? var10 = .0029819092211896296 : input[218] > 1e-35 ? var10 = .08450459375645737 : var10 = .031646488019280654 : var10 = -.03544960151460596 : input[9] > 9.500000000000002 ? var10 = -.026002317735915183 : input[7] > 1.5000000000000002 ? var10 = .005074258810794793 : var10 = .0745247650477651 : input[4] > 29.500000000000004 ? input[131] > 1e-35 ? var10 = .023269218675640847 : input[148] > 1e-35 ? var10 = .03812942399144545 : input[115] > 1e-35 ? var10 = .10512283476967227 : var10 = -.02607307479736138 : input[227] > 1e-35 ? var10 = -.036576708299046294 : input[101] > 1e-35 ? var10 = .027948683650881864 : input[149] > 1e-35 ? var10 = -.08195628451594297 : input[50] > 1e-35 ? var10 = -.16997544922278504 : input[8] > 691.5000000000001 ? input[9] > 101.50000000000001 ? var10 = -.06860333850762075 : input[225] > 1e-35 ? var10 = .06066641950951723 : input[10] > 22.500000000000004 ? input[1] > 29.500000000000004 ? input[127] > 1e-35 ? var10 = .028599705845427533 : var10 = -.010746719511640914 : input[0] > 4877.500000000001 ? var10 = -.07251187886096228 : var10 = -.021299712241446785 : input[118] > 1e-35 ? var10 = -.11902023760964736 : var10 = 15874469526809387e-21 : input[8] > 267.50000000000006 ? var10 = .01317292185402293 : input[148] > 1e-35 ? input[9] > 20.500000000000004 ? var10 = .09614842415142123 : var10 = .006049073167176467 : input[189] > 1e-35 ? var10 = .05562696451900713 : var10 = -.006257541923837303;
  let var11;
  input[13] > 1e-35 ? input[9] > 14.500000000000002 ? input[2] > 11.500000000000002 ? input[1] > 71.50000000000001 ? input[8] > 1252.5000000000002 ? var11 = -.10069846585436666 : var11 = -.010577995535809317 : input[146] > 1e-35 ? var11 = -.008877238274428668 : input[280] > 1e-35 ? var11 = .10076055897012692 : input[6] > 70.50000000000001 ? var11 = -.020603523042565547 : input[7] > 1.5000000000000002 ? var11 = .02819095420813202 : var11 = -.1223354167911277 : var11 = -.025073583348334844 : input[8] > 416.50000000000006 ? var11 = .01718560189149466 : input[230] > 1e-35 ? var11 = .12281803224342265 : var11 = .03281276971308565 : input[4] > 14.500000000000002 ? input[23] > 1e-35 ? input[21] > 1e-35 ? var11 = -.13070568109867683 : input[4] > 63.50000000000001 ? var11 = -.027221825262496814 : var11 = .01530862490082352 : input[9] > 6.500000000000001 ? input[5] > 4320.500000000001 ? input[2] > 31.500000000000004 ? var11 = -.00605574271293711 : var11 = .04739407327741249 : var11 = -.012537528620315956 : input[31] > 1e-35 ? input[20] > 1e-35 ? var11 = .1252215087035768 : var11 = .003905888677601057 : input[52] > 1e-35 ? var11 = .045466299731038815 : input[2] > 100.50000000000001 ? var11 = -.07815624550168065 : input[308] > 1e-35 ? var11 = -.007715815250508057 : input[276] > 1e-35 ? input[9] > 1.5000000000000002 ? var11 = -.03538265083203445 : input[18] > 1e-35 ? var11 = .1591211669800727 : var11 = .015151475408241136 : input[8] > 557.5000000000001 ? var11 = -.04225569725456342 : var11 = -.022455546324243267 : input[308] > 1e-35 ? var11 = .01325441736085826 : input[197] > 1e-35 ? var11 = .03752194600682512 : input[225] > 1e-35 ? var11 = .06583712394533976 : var11 = -.005205289866839043;
  let var12;
  input[13] > 1e-35 ? input[9] > 21.500000000000004 ? input[2] > 12.500000000000002 ? var12 = .010264022580774884 : var12 = -.02335958814489217 : input[8] > 416.50000000000006 ? input[3] > 4.500000000000001 ? input[295] > 1e-35 ? var12 = -.0936747137352166 : input[0] > 384.50000000000006 ? var12 = .019846244507320695 : var12 = -.0751102554077272 : var12 = -.026885329334203723 : input[0] > 966.5000000000001 ? input[10] > 48.50000000000001 ? var12 = .11654906890054273 : var12 = .0346250587613322 : input[4] > 39.50000000000001 ? var12 = -.08568002378645614 : input[9] > 16.500000000000004 ? var12 = -.12010535752923689 : var12 = .021321923389033808 : input[4] > 14.500000000000002 ? input[23] > 1e-35 ? input[21] > 1e-35 ? var12 = -.12056431231412057 : input[131] > 1e-35 ? var12 = .03652965550568472 : var12 = .002563006128791669 : input[9] > 6.500000000000001 ? input[30] > 1e-35 ? var12 = -.10141481732178981 : var12 = -.003936457893178248 : input[31] > 1e-35 ? var12 = .008215898756249477 : input[52] > 1e-35 ? input[0] > 4188.500000000001 ? var12 = .12972828769588213 : var12 = -.003137412232297087 : input[2] > 100.50000000000001 ? var12 = -.0730872929087944 : input[308] > 1e-35 ? var12 = -.006958622747243333 : input[35] > 1e-35 ? input[0] > 3707.5000000000005 ? var12 = .07934620723812878 : var12 = -.018598568353702116 : var12 = -.030635505446410763 : input[128] > 1e-35 ? var12 = -.06962290453843294 : input[84] > 1e-35 ? var12 = -.15290337844960322 : input[308] > 1e-35 ? input[8] > 2543.5000000000005 ? var12 = -.034938657503885584 : var12 = .016339322898966915 : input[197] > 1e-35 ? var12 = .03358907965870046 : input[18] > 1e-35 ? var12 = -.01754013791515288 : var12 = -.0004944586067698557;
  let var13;
  input[13] > 1e-35 ? input[308] > 1e-35 ? input[210] > 1e-35 ? var13 = .005888790687820524 : var13 = .0429676533834978 : input[2] > 7.500000000000001 ? input[0] > 119.50000000000001 ? input[6] > 79.50000000000001 ? var13 = -.0224319889201976 : input[212] > 1e-35 ? var13 = .06249587051783863 : input[8] > 963.5000000000001 ? input[8] > 1156.5000000000002 ? var13 = .010357273289123324 : var13 = -.029749145161304082 : input[218] > 1e-35 ? var13 = .06449336340743606 : var13 = .018047654539345502 : var13 = -.07350502390293116 : var13 = -.019594829995832414 : input[4] > 39.50000000000001 ? var13 = -.019338083179859314 : input[39] > 1e-35 ? var13 = -.10427066919173111 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? var13 = -.019197415255018464 : var13 = -.0836562507048181 : input[149] > 1e-35 ? var13 = -.07679624472577429 : input[32] > 1e-35 ? var13 = -.05097506748590604 : input[191] > 1e-35 ? var13 = .04670476485250936 : input[30] > 1e-35 ? var13 = -.05313073892148652 : input[8] > 691.5000000000001 ? input[23] > 1e-35 ? input[203] > 1e-35 ? input[4] > 8.500000000000002 ? var13 = .03930363008271334 : var13 = -.06029171685615689 : var13 = .016203086182431294 : input[4] > 7.500000000000001 ? var13 = -.013824248237085224 : input[10] > 4.500000000000001 ? input[94] > 1e-35 ? var13 = -.09817668643367765 : input[10] > 40.50000000000001 ? var13 = -.023558078753593125 : var13 = .0065113494780482326 : input[8] > 809.5000000000001 ? input[297] > 1e-35 ? var13 = -.1352063548573715 : var13 = .058203900441270634 : var13 = -.035243959159285736 : input[10] > 59.50000000000001 ? input[1] > 43.50000000000001 ? var13 = -.012552876807800442 : var13 = .05991247777734298 : var13 = .0035893102109330177;
  let var14;
  input[13] > 1e-35 ? input[9] > 21.500000000000004 ? input[145] > 1e-35 ? var14 = .03507251990078782 : input[2] > 14.500000000000002 ? var14 = .004905698363309292 : input[8] > 2421.5000000000005 ? var14 = -.10306119951984316 : var14 = -.018951037816654928 : input[8] > 416.50000000000006 ? input[3] > 4.500000000000001 ? input[295] > 1e-35 ? var14 = -.08503171085833393 : var14 = .015130974593044409 : var14 = -.024425267075198206 : var14 = .02624054905103126 : input[4] > 19.500000000000004 ? input[131] > 1e-35 ? var14 = .02100191580704534 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var14 = .09908783187786288 : var14 = -.06920877329925636 : input[8] > 241.50000000000003 ? var14 = -.016756131804203496 : input[9] > 33.50000000000001 ? var14 = .04903179955263626 : input[217] > 1e-35 ? var14 = -.047416847619291644 : var14 = -.0017200891991431119 : input[39] > 1e-35 ? var14 = -.10389927604977028 : input[134] > 1e-35 ? var14 = -.050480365434872866 : input[178] > 1e-35 ? var14 = -.05167855791556937 : input[8] > 2134.5000000000005 ? var14 = -.01663197335585307 : input[242] > 1e-35 ? var14 = -.05361323756615453 : input[118] > 1e-35 ? var14 = -.05299780866211368 : input[10] > 24.500000000000004 ? input[10] > 55.50000000000001 ? input[8] > 764.5000000000001 ? var14 = -.0016544848369620534 : var14 = .04494144460483587 : var14 = -.009283616456736156 : input[121] > 1e-35 ? input[0] > 4463.500000000001 ? var14 = .051166688553608355 : var14 = -.06623908820705383 : input[84] > 1e-35 ? var14 = -.12990936092409747 : input[306] > 1e-35 ? var14 = -.07020596855118943 : input[49] > 1e-35 ? var14 = .06272964802556856 : input[192] > 1e-35 ? var14 = .06540204627162581 : var14 = .008277910531592885;
  let var15;
  input[13] > 1e-35 ? input[308] > 1e-35 ? input[210] > 1e-35 ? var15 = .003325460510319164 : var15 = .037153108286272905 : input[2] > 12.500000000000002 ? input[1] > 124.50000000000001 ? var15 = -.09880713344892134 : input[7] > 60.50000000000001 ? input[10] > 71.50000000000001 ? var15 = .0697359767152808 : input[230] > 1e-35 ? var15 = .06513506845651572 : var15 = -.02826625276613455 : input[5] > 246.50000000000003 ? input[8] > 95.50000000000001 ? var15 = .013616385013146277 : var15 = .04171540100223404 : var15 = -.04360396575094823 : input[212] > 1e-35 ? var15 = .025945477945627522 : var15 = -.019793208261535442 : input[4] > 39.50000000000001 ? input[25] > 1e-35 ? var15 = -.07856453318384411 : var15 = -.014803893522351739 : input[39] > 1e-35 ? var15 = -.09185452630751932 : input[149] > 1e-35 ? var15 = -.07122426086157027 : input[134] > 1e-35 ? var15 = -.04231052091434186 : input[227] > 1e-35 ? var15 = -.029815824273994197 : input[50] > 1e-35 ? var15 = -.15736496271211153 : input[222] > 1e-35 ? var15 = -.02360285356956629 : input[128] > 1e-35 ? var15 = -.03922080193836443 : input[136] > 1e-35 ? var15 = -.07219685327698587 : input[10] > 24.500000000000004 ? input[1] > 8.500000000000002 ? var15 = -.0029736170756835783 : var15 = -.06482902102259112 : input[84] > 1e-35 ? var15 = -.11340924635708383 : input[94] > 1e-35 ? var15 = -.03635703457792193 : input[118] > 1e-35 ? var15 = -.058181913914186034 : input[126] > 1e-35 ? var15 = -.062030576241517366 : input[116] > 1e-35 ? var15 = -.045086301850604006 : input[25] > 1e-35 ? var15 = -.031665223656767286 : input[203] > 1e-35 ? var15 = -.009444685731407691 : var15 = .0112265153772187;
  let var16;
  input[13] > 1e-35 ? input[1] > 64.50000000000001 ? input[9] > 14.500000000000002 ? input[9] > 54.50000000000001 ? var16 = .022717227245241684 : var16 = -.049700413274686266 : var16 = .007175776918589741 : input[5] > 50.50000000000001 ? input[8] > 61.50000000000001 ? input[21] > 1e-35 ? var16 = -.07927556792063156 : input[3] > 8.500000000000002 ? input[4] > 23.500000000000004 ? input[281] > 1e-35 ? var16 = -.12263724050601095 : var16 = .0070743478891288035 : input[288] > 1e-35 ? var16 = -.050439138582109 : var16 = .0255701593657891 : var16 = -.005812703740580558 : input[6] > 49.50000000000001 ? var16 = -.008542694147899113 : var16 = .035147383686665 : var16 = -.0960461939274094 : input[32] > 1e-35 ? var16 = -.04555453745517765 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? var16 = -.01800870272656664 : var16 = -.07817304234604389 : input[30] > 1e-35 ? var16 = -.05227061750368981 : input[25] > 1e-35 ? input[0] > 4449.500000000001 ? input[217] > 1e-35 ? var16 = .08778416018479411 : var16 = -.026563982720830256 : var16 = -.05296139548112329 : input[50] > 1e-35 ? var16 = -.14926464875852247 : input[8] > 779.5000000000001 ? input[133] > 1e-35 ? var16 = -.036572140520852024 : input[183] > 1e-35 ? var16 = -.10766853736801459 : var16 = -.003966794968701808 : input[217] > 1e-35 ? input[5] > 5237.500000000001 ? var16 = .09513215942486053 : var16 = -.03641865277445567 : input[10] > 59.50000000000001 ? var16 = .03177172388687933 : input[39] > 1e-35 ? var16 = -.10234241303898953 : input[243] > 1e-35 ? var16 = -.02966738115984321 : input[190] > 1e-35 ? var16 = -.04312785336449181 : input[118] > 1e-35 ? var16 = -.05808521194081524 : var16 = .006720381600740378;
  let var17;
  input[308] > 1e-35 ? input[5] > 423.00000000000006 ? input[133] > 1e-35 ? var17 = -.046284053681928526 : input[210] > 1e-35 ? var17 = 49778070699847876e-21 : input[13] > 1e-35 ? var17 = .03328070054739309 : input[128] > 1e-35 ? var17 = -.054790214922938896 : input[126] > 1e-35 ? var17 = -.08524792218532945 : var17 = .014414055975542446 : input[1] > 38.50000000000001 ? var17 = -.07287851335872973 : var17 = .005263371501687163 : input[9] > 7.500000000000001 ? input[21] > 1e-35 ? input[10] > 4.500000000000001 ? var17 = -.12459748864088374 : var17 = -.004626323021331593 : input[298] > 1e-35 ? input[4] > 64.50000000000001 ? var17 = .13044981041138526 : input[9] > 71.50000000000001 ? var17 = -.056068402282406865 : input[9] > 12.500000000000002 ? var17 = .038957722962512764 : var17 = -.04598815982492169 : input[8] > 691.5000000000001 ? input[126] > 1e-35 ? var17 = -.0852126122372075 : input[225] > 1e-35 ? var17 = .10082066771689505 : input[1] > 161.50000000000003 ? var17 = -.11609832500613824 : input[3] > 8.500000000000002 ? input[8] > 1685.5000000000002 ? var17 = -.010835400874777133 : var17 = .004607419973807752 : var17 = -.016989075258564062 : var17 = .009205417251698097 : input[23] > 1e-35 ? input[20] > 1e-35 ? var17 = .10184317139657878 : input[0] > 5724.500000000001 ? var17 = -.1163666496650542 : input[1] > 106.50000000000001 ? var17 = .1303850608190687 : input[129] > 1e-35 ? var17 = .10745031509534769 : var17 = .006166901738036226 : input[31] > 1e-35 ? var17 = .010177092833155127 : input[13] > 1e-35 ? input[0] > 213.50000000000003 ? var17 = .005004582564506611 : var17 = -.10481581731668346 : input[19] > 1e-35 ? var17 = -.009850706427306281 : var17 = -.02608226348051303;
  let var18;
  input[13] > 1e-35 ? input[1] > 64.50000000000001 ? input[2] > 4.500000000000001 ? var18 = -.0024117174588695603 : var18 = -.058339700513831916 : input[212] > 1e-35 ? input[0] > 2215.5000000000005 ? input[8] > 847.5000000000001 ? input[10] > 21.500000000000004 ? input[1] > 39.50000000000001 ? var18 = .04575380761203418 : var18 = -.10025595041353463 : input[15] > 1e-35 ? var18 = .17705790384964004 : var18 = .0073813837628615014 : var18 = .07676373681392407 : var18 = -.027167992693885996 : input[3] > 11.500000000000002 ? input[280] > 1e-35 ? var18 = .07078572910026419 : input[4] > 23.500000000000004 ? var18 = .005513918674164821 : var18 = .0206586476926392 : input[0] > 5269.500000000001 ? var18 = .07706773525822633 : var18 = -.010233826953776122 : input[148] > 1e-35 ? input[8] > 1622.5000000000002 ? var18 = -.03204783603215824 : var18 = .027405418223981973 : input[4] > 14.500000000000002 ? input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? input[0] > 5026.500000000001 ? var18 = -.0930246911392012 : var18 = .011173087289703683 : input[3] > 24.500000000000004 ? var18 = .03281421918878597 : var18 = .12449335091369843 : input[204] > 1e-35 ? var18 = .06634531187326123 : var18 = -.011522999669353388 : input[92] > 1e-35 ? input[10] > 42.50000000000001 ? var18 = -.041196758517013515 : input[4] > 7.500000000000001 ? var18 = -2942718111029724e-20 : input[4] > 6.500000000000001 ? var18 = .11953909558532852 : var18 = .03188615019450534 : input[122] > 1e-35 ? var18 = -.0616037324662157 : input[101] > 1e-35 ? var18 = .027230889593349412 : input[8] > 4968.500000000001 ? var18 = -.1113986516540856 : input[3] > 2.5000000000000004 ? var18 = -.002045140426885727 : input[129] > 1e-35 ? var18 = .12641163374304432 : var18 = .014909826232873194;
  let var19;
  input[308] > 1e-35 ? input[0] > 7277.500000000001 ? var19 = -.09337446795435 : input[5] > 423.00000000000006 ? input[133] > 1e-35 ? var19 = -.040884836258675006 : input[210] > 1e-35 ? var19 = -.0003719413278428804 : input[13] > 1e-35 ? var19 = .030287610160818174 : var19 = .011174130013595384 : input[1] > 38.50000000000001 ? var19 = -.0662442170185784 : var19 = .004332185707008564 : input[9] > 7.500000000000001 ? input[145] > 1e-35 ? input[285] > 1e-35 ? var19 = -.08092286307197555 : var19 = .029866363328584986 : input[21] > 1e-35 ? input[10] > 4.500000000000001 ? var19 = -.1155211149523894 : var19 = -.0032903546638958538 : input[149] > 1e-35 ? var19 = -.03632198993199768 : input[3] > 9.500000000000002 ? input[8] > 999.5000000000001 ? var19 = -.003507023626534306 : input[128] > 1e-35 ? input[4] > 13.500000000000002 ? input[0] > 3459.5000000000005 ? var19 = -.025416927789760076 : var19 = .02777568919793122 : var19 = -.10310351509769732 : var19 = .013549608903688785 : input[186] > 1e-35 ? var19 = .08513865847420551 : var19 = -.009306721292510369 : input[31] > 1e-35 ? var19 = .009780833952582307 : input[23] > 1e-35 ? var19 = .011143773934157629 : input[210] > 1e-35 ? var19 = .025354797285173356 : input[17] > 1e-35 ? input[10] > 3.5000000000000004 ? var19 = -.04846287537743046 : var19 = -.014647271080376757 : input[2] > 5.500000000000001 ? input[7] > 57.50000000000001 ? var19 = -.034224938681445764 : input[8] > 1641.5000000000002 ? var19 = -.027298372075800673 : input[191] > 1e-35 ? input[10] > 18.500000000000004 ? var19 = -.027950103994861836 : var19 = .14575930827829034 : var19 = -.007124740389354946 : input[10] > 22.500000000000004 ? var19 = .013173304107866726 : var19 = -.11119620042551365;
  let var20;
  input[131] > 1e-35 ? var20 = .01892225243240137 : input[308] > 1e-35 ? input[5] > 691.5000000000001 ? input[133] > 1e-35 ? var20 = -.037118314390013646 : input[1] > 51.50000000000001 ? input[5] > 3749.5000000000005 ? input[8] > 58.50000000000001 ? var20 = -.022305242912035072 : var20 = .024792895826340516 : var20 = .013666137278072166 : input[88] > 1e-35 ? input[10] > 27.500000000000004 ? var20 = .2080083584805785 : var20 = .04247197078083379 : input[10] > 40.50000000000001 ? input[18] > 1e-35 ? input[1] > 27.500000000000004 ? var20 = .060783227455868206 : var20 = -.056904865557409035 : var20 = -.03278952553107572 : input[192] > 1e-35 ? var20 = .13117402617043625 : var20 = .01647119888257836 : var20 = -.01825870445636398 : input[9] > 6.500000000000001 ? input[298] > 1e-35 ? var20 = .026536210945939682 : input[8] > 691.5000000000001 ? input[126] > 1e-35 ? var20 = -.07927319604548912 : input[10] > 3.5000000000000004 ? input[21] > 1e-35 ? var20 = -.11083976837572328 : input[146] > 1e-35 ? var20 = -.03359294484446772 : var20 = -.0042815953591236475 : input[190] > 1e-35 ? var20 = -.09264239592903775 : input[10] > 1e-35 ? var20 = .022282638485105657 : var20 = -.0205994057928458 : input[5] > 4918.500000000001 ? var20 = .03430715695199153 : input[243] > 1e-35 ? input[2] > 57.50000000000001 ? var20 = .08935072241972036 : var20 = -.03781647876237494 : var20 = .0062655753179671515 : input[31] > 1e-35 ? var20 = .008603500300349887 : input[230] > 1e-35 ? var20 = .03350056932774173 : input[23] > 1e-35 ? input[241] > 1e-35 ? var20 = .10277555508503314 : var20 = .0017901817172993888 : input[2] > 98.50000000000001 ? var20 = -.05920081229672715 : var20 = -.015722173275739208;
  let var21;
  input[13] > 1e-35 ? input[118] > 1e-35 ? var21 = .07957905150112207 : input[1] > 125.50000000000001 ? var21 = -.0662620579858685 : input[145] > 1e-35 ? var21 = .029682040828779843 : input[19] > 1e-35 ? input[6] > 15.500000000000002 ? var21 = -.0009597832580977798 : var21 = -.081474760755753 : input[212] > 1e-35 ? var21 = .03637001492325179 : var21 = .006912305498963309 : input[32] > 1e-35 ? var21 = -.03919900630910754 : input[134] > 1e-35 ? var21 = -.036225295529777886 : input[4] > 4.500000000000001 ? input[5] > 384.50000000000006 ? input[204] > 1e-35 ? var21 = .06671440854602108 : input[136] > 1e-35 ? var21 = -.07577364230133474 : input[148] > 1e-35 ? input[4] > 7.500000000000001 ? var21 = .026430947016830915 : var21 = -.04075501264495112 : input[9] > 93.50000000000001 ? var21 = -.04353169430417609 : input[50] > 1e-35 ? var21 = -.1411224537622882 : input[17] > 1e-35 ? input[49] > 1e-35 ? var21 = .068392679163672 : input[10] > 1.5000000000000002 ? var21 = -.0209659792007492 : var21 = -.0004393235559249831 : input[133] > 1e-35 ? input[9] > 64.50000000000001 ? var21 = .07254524592323175 : var21 = -.0319087835282534 : var21 = .00037444813327793425 : var21 = -.025138768151370408 : input[243] > 1e-35 ? var21 = -.050010891710502096 : input[94] > 1e-35 ? var21 = -.0817513550778599 : input[122] > 1e-35 ? var21 = -.061038875809822285 : input[19] > 1e-35 ? input[8] > 1085.5000000000002 ? var21 = -.008408408775061623 : input[2] > 5.500000000000001 ? input[218] > 1e-35 ? var21 = .1454877641381946 : var21 = .053787998331240316 : input[9] > 33.50000000000001 ? var21 = .08602629796680285 : var21 = -.03895127455803038 : var21 = .008830878042315722;
  let var22;
  input[131] > 1e-35 ? var22 = .01687979707990516 : input[8] > 2915.5000000000005 ? input[297] > 1e-35 ? var22 = .07473600489975568 : input[0] > 93.50000000000001 ? var22 = -.021596848506011502 : var22 = -.13840802327735696 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[0] > 4977.500000000001 ? var22 = .10264284346448256 : var22 = .031042487183181262 : var22 = -.016653982936827776 : input[4] > 60.50000000000001 ? input[10] > 75.50000000000001 ? var22 = .04226403420647408 : input[10] > 1e-35 ? input[0] > 4733.500000000001 ? var22 = .006271403149804702 : var22 = -.030013637555715046 : input[0] > 4449.500000000001 ? var22 = -.06556876058654929 : var22 = .06437994816903034 : input[32] > 1e-35 ? var22 = -.043814577251655815 : input[308] > 1e-35 ? input[0] > 7277.500000000001 ? var22 = -.09349726304052086 : input[210] > 1e-35 ? var22 = -.0035960132209098003 : input[5] > 691.5000000000001 ? input[133] > 1e-35 ? var22 = -.029188394315052574 : var22 = .017219308333820193 : var22 = -.017378928852189585 : input[9] > 6.500000000000001 ? input[0] > 2653.5000000000005 ? input[149] > 1e-35 ? var22 = -.04428555753857688 : var22 = .0001456106867817353 : input[5] > 213.50000000000003 ? var22 = .01740292726636365 : var22 = -.011361718115556464 : input[7] > 4.500000000000001 ? input[0] > 316.50000000000006 ? input[19] > 1e-35 ? input[10] > 54.50000000000001 ? var22 = .03410288911259329 : input[121] > 1e-35 ? var22 = -.06056527462120627 : input[8] > 2592.5000000000005 ? var22 = .12166808844363577 : input[191] > 1e-35 ? var22 = .11669879218998758 : var22 = -.001664858391716235 : var22 = -.01262927450503166 : var22 = -.04506589951879664 : input[227] > 1e-35 ? var22 = -.08548904959752329 : var22 = .02156080776537726;
  let var23;
  input[306] > 1e-35 ? input[149] > 1e-35 ? var23 = -.1389218965136736 : var23 = -.032218642644416894 : input[13] > 1e-35 ? var23 = .006465035217331847 : input[50] > 1e-35 ? var23 = -.1381687930130022 : input[179] > 1e-35 ? var23 = -.13112784985951215 : input[148] > 1e-35 ? input[8] > 1726.5000000000002 ? var23 = -.03262719498763048 : var23 = .023342916702125613 : input[191] > 1e-35 ? var23 = .030005484947580197 : input[4] > 4.500000000000001 ? input[204] > 1e-35 ? var23 = .047767773119269434 : input[136] > 1e-35 ? input[0] > 1937.5000000000002 ? var23 = -.09989343595668776 : var23 = .06533942033334243 : input[15] > 1e-35 ? input[9] > 86.50000000000001 ? var23 = -.10577989354150097 : input[8] > 668.5000000000001 ? input[126] > 1e-35 ? var23 = -.09165257825246746 : input[9] > 32.50000000000001 ? var23 = .02484870392366004 : var23 = -.008499493096971395 : input[8] > 24.500000000000004 ? var23 = .02459679192828244 : var23 = -.010527978013140512 : input[25] > 1e-35 ? input[217] > 1e-35 ? var23 = .0015644546318714849 : var23 = -.06579524865022705 : var23 = -.0060233890975120614 : input[122] > 1e-35 ? input[1] > 36.50000000000001 ? var23 = .03331853632960164 : var23 = -.09482264761126993 : input[19] > 1e-35 ? input[8] > 1430.5000000000002 ? var23 = -.019091477207111116 : var23 = .037878468575478504 : input[94] > 1e-35 ? var23 = -.08013082284576584 : input[4] > 2.5000000000000004 ? input[186] > 1e-35 ? var23 = .16919658785098224 : input[243] > 1e-35 ? var23 = -.06580584936754524 : var23 = .01567555159935563 : input[129] > 1e-35 ? var23 = .06721746994993226 : input[10] > 32.50000000000001 ? var23 = -.046394462507797975 : var23 = -.006436180519584767;
  let var24;
  input[131] > 1e-35 ? var24 = .015039096856208693 : input[8] > 779.5000000000001 ? input[145] > 1e-35 ? var24 = .019122095523977856 : input[298] > 1e-35 ? var24 = .023828936462317443 : input[1] > 23.500000000000004 ? input[5] > 384.50000000000006 ? input[7] > 59.50000000000001 ? var24 = -.026094309429557913 : input[204] > 1e-35 ? var24 = .09163404305658318 : input[1] > 27.500000000000004 ? input[149] > 1e-35 ? input[6] > 34.50000000000001 ? var24 = .012643810980689466 : var24 = -.07884161741497837 : var24 = -.0025267379810891104 : input[2] > 43.50000000000001 ? input[0] > 2860.5000000000005 ? var24 = .04493082949897325 : var24 = .18046359750455776 : input[7] > 18.500000000000004 ? var24 = -.018667348656891496 : var24 = .02584325784698236 : var24 = -.045696524897545915 : input[0] > 3321.5000000000005 ? input[201] > 1e-35 ? var24 = .04749240016989375 : var24 = -.0333334578246718 : input[5] > 3276.5000000000005 ? var24 = .11330554740098908 : input[7] > 94.50000000000001 ? var24 = .1296600395033268 : var24 = -.003576436308940934 : input[15] > 1e-35 ? input[183] > 1e-35 ? var24 = -.13787130789142835 : input[0] > 1847.5000000000002 ? var24 = .017915229729920556 : input[10] > 23.500000000000004 ? input[10] > 31.500000000000004 ? input[6] > 7.500000000000001 ? var24 = .028856848462727104 : var24 = -.11197632885851168 : var24 = .08169801342016791 : input[1] > 22.500000000000004 ? var24 = -.021052888644970163 : var24 = .019048604298876753 : input[7] > 4.500000000000001 ? var24 = -.002603328695276418 : input[7] > 1.5000000000000002 ? input[2] > 5.500000000000001 ? var24 = .03432638833359197 : var24 = -.0036767863082454973 : input[1] > 48.50000000000001 ? var24 = .03087375270128195 : input[2] > 3.5000000000000004 ? var24 = -.04219917149740248 : var24 = .018818493993207935;
  let var25;
  input[306] > 1e-35 ? var25 = -.04076858123502297 : input[13] > 1e-35 ? input[1] > 67.50000000000001 ? input[9] > 14.500000000000002 ? input[9] > 53.50000000000001 ? input[8] > 1971.5000000000002 ? var25 = -.09091897542577475 : var25 = .04042943082645558 : input[218] > 1e-35 ? var25 = .056254985867151 : var25 = -.053848117950183044 : var25 = .003881630017086845 : input[5] > 5152.500000000001 ? input[8] > 857.5000000000001 ? input[6] > 28.500000000000004 ? var25 = .021581808008986944 : var25 = -.05639286496176611 : var25 = .052838875036198954 : input[5] > 50.50000000000001 ? input[5] > 4082.5000000000005 ? input[17] > 1e-35 ? var25 = .023061479860228728 : input[145] > 1e-35 ? input[9] > 10.500000000000002 ? var25 = .023885302967553288 : var25 = .1617794086125622 : input[212] > 1e-35 ? var25 = .04504545345658806 : input[3] > 17.500000000000004 ? input[4] > 45.50000000000001 ? var25 = -.03948072448245435 : input[1] > 47.50000000000001 ? input[9] > 18.500000000000004 ? var25 = .01894935813286188 : var25 = -.06449356357429188 : var25 = .012297239104320094 : input[1] > 26.500000000000004 ? input[8] > 33.50000000000001 ? var25 = -.034718828212885515 : var25 = .0898976288814321 : input[1] > 17.500000000000004 ? var25 = -.15440137451988326 : var25 = -.03864183216821465 : var25 = .009988507307006308 : var25 = -.08540311947043305 : input[50] > 1e-35 ? var25 = -.13323659732101975 : input[134] > 1e-35 ? var25 = -.031820386486894385 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var25 = .08082476177379844 : var25 = -.041665761903645876 : input[179] > 1e-35 ? var25 = -.12405023987936657 : input[39] > 1e-35 ? var25 = -.06247416524997478 : input[138] > 1e-35 ? var25 = -.10724031753676487 : var25 = -.0005423122305122404;
  let var26;
  input[308] > 1e-35 ? var26 = .006160742906729798 : input[190] > 1e-35 ? input[0] > 2461.5000000000005 ? input[10] > 22.500000000000004 ? var26 = .023223358334607133 : var26 = -.04383410185346742 : var26 = -.08542395045055405 : input[297] > 1e-35 ? input[8] > 51.50000000000001 ? input[1] > 13.500000000000002 ? var26 = .023406489302867494 : var26 = -.085521220804058 : var26 = -.02921899554854833 : input[298] > 1e-35 ? input[9] > 12.500000000000002 ? var26 = .028120059780969632 : var26 = -.04211009474298743 : input[294] > 1e-35 ? var26 = -.05040415676618239 : input[86] > 1e-35 ? input[1] > 36.50000000000001 ? var26 = -.0993035220737934 : var26 = -.0005384930611060366 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? var26 = .029770210551187937 : var26 = -.016272917551655715 : input[4] > 60.50000000000001 ? input[280] > 1e-35 ? var26 = .06421359317599738 : var26 = -.01963732469244167 : input[218] > 1e-35 ? input[3] > 3.5000000000000004 ? var26 = .024368404612215164 : var26 = -.04045232374803373 : input[131] > 1e-35 ? var26 = .017372701982485795 : input[120] > 1e-35 ? var26 = .08812710275150198 : input[18] > 1e-35 ? input[90] > 1e-35 ? var26 = .18451364351180236 : input[7] > 33.50000000000001 ? var26 = -.03850813130183531 : input[195] > 1e-35 ? var26 = .06966114053446336 : input[3] > 16.500000000000004 ? var26 = -.0012869181693341211 : input[0] > 4242.500000000001 ? var26 = -.054625548611291035 : var26 = -.014431095117473881 : input[5] > 4558.500000000001 ? input[8] > 1.5000000000000002 ? var26 = .006302103427145562 : var26 = .13967622319898698 : input[121] > 1e-35 ? var26 = -.038798585213145644 : input[5] > 4544.500000000001 ? var26 = -.08050498033009466 : var26 = -.002986974112681435;
  let var27;
  input[0] > 384.50000000000006 ? input[2] > 101.50000000000001 ? input[1] > 16.500000000000004 ? var27 = -.03461119351456781 : var27 = .05659026566680352 : input[306] > 1e-35 ? input[2] > 14.500000000000002 ? input[149] > 1e-35 ? var27 = -.12404435523286539 : var27 = -.0034376913880382956 : var27 = -.09821622245095822 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var27 = .0037507103585310234 : var27 = .03610387965829944 : input[8] > 999.5000000000001 ? input[9] > 137.50000000000003 ? var27 = -.11985021663179699 : input[0] > 1847.5000000000002 ? input[126] > 1e-35 ? var27 = -.04832024079663151 : input[37] > 1e-35 ? var27 = -.037103393468366934 : var27 = -.004248086592531705 : input[8] > 3084.0000000000005 ? input[9] > 43.50000000000001 ? var27 = .032539071163832034 : input[5] > 1643.5000000000002 ? var27 = .036408625378035665 : input[0] > 1500.5000000000002 ? var27 = -.1346358322854993 : var27 = -.027586559522081014 : input[3] > 1e-35 ? input[190] > 1e-35 ? var27 = -.1133991164577881 : input[9] > 52.50000000000001 ? var27 = -.024478640359723122 : var27 = .03673777861098756 : var27 = -.1037451237591819 : input[230] > 1e-35 ? input[9] > 48.50000000000001 ? input[10] > 20.500000000000004 ? var27 = .002583438691776944 : var27 = .10773520810108106 : input[9] > 12.500000000000002 ? input[1] > 16.500000000000004 ? var27 = -.02141222346712401 : var27 = .06392462314316179 : input[4] > 12.500000000000002 ? var27 = .08700122294434816 : input[8] > 267.50000000000006 ? var27 = .056923170082743224 : var27 = -.07716309825583327 : input[32] > 1e-35 ? var27 = -.03961343943752142 : var27 = .002674914122888783 : input[1] > 42.50000000000001 ? var27 = -.05217539654421676 : input[145] > 1e-35 ? var27 = .09553630282946368 : var27 = -.009424791262477729;
  let var28;
  input[183] > 1e-35 ? var28 = -.05753337139158443 : input[308] > 1e-35 ? var28 = .00562436671450989 : input[9] > 7.500000000000001 ? input[21] > 1e-35 ? input[10] > 8.500000000000002 ? var28 = -.10477869875380448 : var28 = -.0070301869937306055 : input[3] > 9.500000000000002 ? input[8] > 1765.5000000000002 ? input[0] > 4571.500000000001 ? var28 = -.12526505173232894 : input[10] > 1e-35 ? input[9] > 71.50000000000001 ? var28 = -.04442302951713574 : var28 = .00012409888451734224 : var28 = -.092199119633697 : input[225] > 1e-35 ? var28 = .13773072450201831 : input[0] > 2882.5000000000005 ? var28 = .0028540012229920533 : input[298] > 1e-35 ? var28 = .07134486044361629 : var28 = .014297412329837425 : input[145] > 1e-35 ? var28 = .05608385321902638 : input[92] > 1e-35 ? var28 = .038298413603926135 : input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var28 = -.0039957800609801315 : var28 = .0776927564241081 : input[203] > 1e-35 ? var28 = -.05502900859432093 : input[105] > 1e-35 ? var28 = .06062892720841595 : var28 = -.009574839629252128 : input[31] > 1e-35 ? var28 = .009488858841144216 : input[23] > 1e-35 ? input[20] > 1e-35 ? var28 = .08818126313644752 : input[8] > 161.50000000000003 ? var28 = .014353968957885408 : var28 = -.022240738532827903 : input[210] > 1e-35 ? var28 = .024648862719806694 : input[2] > 5.500000000000001 ? input[4] > 4.500000000000001 ? input[17] > 1e-35 ? input[10] > 16.500000000000004 ? var28 = -.043902062079383485 : var28 = -.014741559220396223 : var28 = -.00934935734853194 : input[6] > 32.50000000000001 ? var28 = .1514593126307404 : var28 = .010771222510801532 : input[10] > 22.500000000000004 ? var28 = .01412495209334078 : var28 = -.08576940379502533;
  let var29;
  input[0] > 384.50000000000006 ? input[84] > 1e-35 ? var29 = -.06647690967306838 : input[2] > 101.50000000000001 ? var29 = -.024451334501552457 : input[306] > 1e-35 ? var29 = -.034517188927733505 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var29 = .0031858381443673127 : var29 = .032574927024450646 : input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var29 = -.08601340441214533 : input[1] > 29.500000000000004 ? var29 = .10487598629539963 : input[8] > 597.5000000000001 ? var29 = -.0786529133673238 : var29 = .08689436600511559 : input[8] > 779.5000000000001 ? input[10] > 2.5000000000000004 ? input[9] > 100.50000000000001 ? var29 = -.04883600353740688 : input[126] > 1e-35 ? var29 = -.03794042763348827 : var29 = -.003358871967539988 : input[210] > 1e-35 ? var29 = .054991356498447566 : input[6] > 19.500000000000004 ? var29 = -.007418396981635549 : var29 = .018032606049498613 : input[18] > 1e-35 ? input[7] > 35.50000000000001 ? input[2] > 44.50000000000001 ? var29 = -.02143003429501711 : var29 = -.09016000554055564 : input[1] > 19.500000000000004 ? input[1] > 42.50000000000001 ? input[8] > 17.500000000000004 ? var29 = -.006636355416244082 : var29 = -.06483095743431454 : input[4] > 21.500000000000004 ? var29 = -.028975965946833545 : var29 = .022012264796522657 : var29 = -.06653648243193663 : input[5] > 4593.500000000001 ? var29 = .01753551428088607 : input[217] > 1e-35 ? var29 = -.028864824937700297 : input[94] > 1e-35 ? var29 = -.04885192273020658 : input[279] > 1e-35 ? var29 = .08105715462329498 : input[121] > 1e-35 ? var29 = -.04576676034750651 : var29 = .004795141324949362 : input[1] > 42.50000000000001 ? var29 = -.047446619702809195 : input[145] > 1e-35 ? var29 = .08400495571952321 : var29 = -.00854528836489364;
  let var30;
  input[294] > 1e-35 ? var30 = -.042529778074638265 : input[266] > 1e-35 ? var30 = -.1180276669679798 : input[134] > 1e-35 ? var30 = -.026818144353279623 : input[183] > 1e-35 ? var30 = -.05120747503479363 : input[227] > 1e-35 ? input[8] > 1641.5000000000002 ? var30 = -.07265906898294434 : input[4] > 12.500000000000002 ? input[17] > 1e-35 ? var30 = -.027516137530797014 : input[0] > 4331.500000000001 ? input[1] > 64.50000000000001 ? var30 = -.03049646619610203 : input[1] > 50.50000000000001 ? var30 = .20634590755061122 : var30 = .06956378103625731 : input[0] > 3770.5000000000005 ? var30 = -.07946414366134913 : input[19] > 1e-35 ? var30 = .17083312065604694 : input[2] > 21.500000000000004 ? var30 = -.02327981978127724 : var30 = .129717297518715 : input[145] > 1e-35 ? var30 = .006891245076133524 : var30 = -.0789123467863741 : input[3] > 99.50000000000001 ? var30 = -.02022281202803071 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var30 = .06447639919732716 : var30 = -.05457561977645972 : input[306] > 1e-35 ? var30 = -.029995903305383882 : input[191] > 1e-35 ? var30 = .030596508110850414 : input[242] > 1e-35 ? var30 = -.024085578702020216 : input[8] > 3198.5000000000005 ? input[297] > 1e-35 ? var30 = .09518584795377832 : var30 = -.018197744600833596 : input[13] > 1e-35 ? var30 = .006751790086127549 : input[148] > 1e-35 ? var30 = .01904174573618417 : input[99] > 1e-35 ? var30 = .025287735102561926 : input[4] > 14.500000000000002 ? var30 = -.004364337681643273 : input[1] > 15.500000000000002 ? input[35] > 1e-35 ? var30 = -.09467943982430241 : input[243] > 1e-35 ? var30 = -.02521824751996268 : var30 = .005437570718352172 : var30 = -.022476214821960674;
  let var31;
  input[0] > 384.50000000000006 ? input[84] > 1e-35 ? var31 = -.06088131453064195 : input[147] > 1e-35 ? var31 = -.05332792965930566 : input[135] > 1e-35 ? input[9] > 32.50000000000001 ? var31 = .04219361472548491 : var31 = -.07227529211725771 : input[10] > 4.500000000000001 ? input[21] > 1e-35 ? var31 = -.0787279848043689 : input[17] > 1e-35 ? input[3] > 18.500000000000004 ? input[188] > 1e-35 ? var31 = -.054347604504400286 : input[0] > 3544.5000000000005 ? input[0] > 5850.500000000001 ? var31 = -.11431764534511478 : var31 = .013549717238356157 : var31 = -.020987333767091276 : input[6] > 2.5000000000000004 ? var31 = -.02914877855133127 : var31 = .08483464900160231 : input[8] > 58.50000000000001 ? input[183] > 1e-35 ? var31 = -.10087072787978416 : input[37] > 1e-35 ? var31 = -.030467397753331196 : input[229] > 1e-35 ? var31 = -.1017559811057469 : input[4] > 20.500000000000004 ? var31 = -.00413177742240167 : input[20] > 1e-35 ? var31 = .05213315982685969 : var31 = .0037921635866823133 : input[8] > 51.50000000000001 ? var31 = .07327913092421544 : input[6] > 49.50000000000001 ? var31 = -.03457694284156811 : input[6] > 18.500000000000004 ? input[7] > 17.500000000000004 ? var31 = .02744420891894289 : var31 = .11288946357194463 : var31 = .003482908820966248 : input[18] > 1e-35 ? input[1] > 20.500000000000004 ? input[7] > 4.500000000000001 ? var31 = -.012329314369909049 : var31 = .026816658655600168 : var31 = -.0872405354618811 : var31 = .007872673500247845 : input[1] > 42.50000000000001 ? var31 = -.04309044198258254 : input[145] > 1e-35 ? var31 = .07572529147860785 : input[7] > 5.500000000000001 ? var31 = -.013837187093264945 : input[1] > 17.500000000000004 ? var31 = .04208698439539668 : var31 = -.06284346769019863;
  let var32;
  input[294] > 1e-35 ? var32 = -.0384794324818203 : input[266] > 1e-35 ? var32 = -.1087205883821061 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var32 = .07432960094940501 : var32 = -.035248735855751855 : input[134] > 1e-35 ? var32 = -.02456191365284949 : input[121] > 1e-35 ? input[0] > 4720.500000000001 ? input[1] > 39.50000000000001 ? var32 = -.01706896375068821 : var32 = .08212247914968074 : input[2] > 59.50000000000001 ? var32 = -.09546478958824225 : input[6] > 53.50000000000001 ? var32 = .12317082897575611 : input[1] > 56.50000000000001 ? input[4] > 7.500000000000001 ? input[0] > 3560.5000000000005 ? var32 = .02816463285971267 : var32 = .15449139016588445 : var32 = -.10199787406123524 : var32 = -.038068684323297096 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var32 = -.13924786681478077 : var32 = -.0072772442570213335 : input[39] > 1e-35 ? var32 = -.05392786531177836 : input[0] > 93.50000000000001 ? input[40] > 1e-35 ? var32 = -.054059371343144036 : input[306] > 1e-35 ? input[2] > 14.500000000000002 ? input[149] > 1e-35 ? var32 = -.11174465335620831 : var32 = .00013144040097180107 : var32 = -.08493919336681105 : input[42] > 1e-35 ? var32 = -.11078582572836196 : input[84] > 1e-35 ? input[4] > 17.500000000000004 ? var32 = -.015540659878839153 : var32 = -.14442609417300142 : input[21] > 1e-35 ? var32 = -.025251979447574083 : var32 = .0023698372645272847 : input[18] > 1e-35 ? var32 = .07269739695712212 : input[8] > 2592.5000000000005 ? var32 = -.1460388776448558 : input[9] > 30.500000000000004 ? input[1] > 23.500000000000004 ? var32 = -.01835130329646532 : input[9] > 45.50000000000001 ? var32 = .02023047454629885 : var32 = .16469378262221102 : var32 = -.042975030085836426;
  let var33;
  input[8] > 2915.5000000000005 ? input[297] > 1e-35 ? var33 = .06257393915394144 : input[0] > 93.50000000000001 ? input[4] > 1.5000000000000002 ? var33 = -.01034964686484714 : var33 = -.07357437440667927 : var33 = -.11987794734779106 : input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[0] > 3370.5000000000005 ? input[8] > 155.50000000000003 ? input[8] > 660.5000000000001 ? input[8] > 2134.5000000000005 ? var33 = -.09476398869062203 : input[9] > 72.50000000000001 ? var33 = -.0757383854264379 : var33 = .02806542779508718 : var33 = -.05147742568418084 : var33 = .10212721564444344 : var33 = .0518263760642861 : var33 = -.08743405377022222 : input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var33 = -.10669213185972036 : var33 = .027050434286384796 : input[302] > 1e-35 ? var33 = -.0407832394672723 : input[116] > 1e-35 ? input[10] > 38.50000000000001 ? var33 = .06354599160071946 : input[1] > 67.50000000000001 ? var33 = .05317447949011187 : var33 = -.059138165935307165 : input[212] > 1e-35 ? input[19] > 1e-35 ? var33 = -.09369289448773599 : input[0] > 2215.5000000000005 ? var33 = .04077965380363924 : input[0] > 807.5000000000001 ? var33 = -.0591771776458298 : var33 = .057315736906679376 : input[308] > 1e-35 ? input[1] > 52.50000000000001 ? input[5] > 3749.5000000000005 ? var33 = -.016323380219241672 : var33 = .007291062979527741 : input[210] > 1e-35 ? input[8] > 1641.5000000000002 ? var33 = .03720704290087811 : var33 = -.008730548158766654 : input[4] > 80.50000000000001 ? var33 = -.05346644687473197 : var33 = .014596824736762107 : input[218] > 1e-35 ? input[3] > 3.5000000000000004 ? var33 = .019984510398089086 : var33 = -.03917825025861855 : input[9] > 170.50000000000003 ? var33 = -.09759719821334525 : var33 = -.0023586682752856298;
  let var34;
  input[183] > 1e-35 ? input[17] > 1e-35 ? var34 = .030100940443356424 : input[10] > 1.5000000000000002 ? var34 = -.10861112216742408 : var34 = .017680668976453255 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[2] > 16.500000000000004 ? var34 = -.032062878390325456 : var34 = -.10808232631806887 : input[8] > 1641.5000000000002 ? var34 = -.06147013392655731 : input[4] > 12.500000000000002 ? var34 = .03324767551088266 : input[145] > 1e-35 ? var34 = .028851633810612017 : var34 = -.054871239091792784 : input[134] > 1e-35 ? var34 = -.023813968121342108 : input[266] > 1e-35 ? var34 = -.10037039667146351 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? input[10] > 1e-35 ? input[8] > 1939.5000000000002 ? var34 = -.055566877553100726 : input[2] > 24.500000000000004 ? input[8] > 182.50000000000003 ? input[10] > 43.50000000000001 ? input[10] > 55.50000000000001 ? var34 = -.025350325484720576 : var34 = .1579024598549572 : input[9] > 2.5000000000000004 ? input[0] > 3746.5000000000005 ? var34 = .056817276537534815 : var34 = -.07674158463557636 : var34 = -.06335553143454145 : input[1] > 56.50000000000001 ? var34 = .16390494217299284 : var34 = -.0027330160430847177 : input[10] > 36.50000000000001 ? input[8] > 1067.5000000000002 ? var34 = .041717597065890205 : var34 = -.10357913492269129 : input[10] > 29.500000000000004 ? var34 = .1365512866715726 : var34 = .020600048310575665 : var34 = .09708785634773187 : var34 = -.060427658852305666 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[6] > 24.500000000000004 ? input[8] > 1146.5000000000002 ? var34 = -.03146213719547347 : var34 = .11784024316238083 : var34 = -.050940520532045355 : var34 = -.047988344143075616 : input[191] > 1e-35 ? var34 = .028764654731460032 : var34 = .0011911575567860023;
  let var35;
  input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var35 = -.11630092297244568 : input[0] > 2432.5000000000005 ? input[0] > 4199.500000000001 ? var35 = -.05103908560370243 : var35 = .05002066201169583 : var35 = -.09976646725732496 : input[32] > 1e-35 ? input[0] > 4242.500000000001 ? var35 = -.0648838712201258 : input[5] > 3721.5000000000005 ? input[9] > 4.500000000000001 ? var35 = .127983140816313 : var35 = -.05436534163636867 : var35 = -.024514536544596455 : input[121] > 1e-35 ? input[0] > 4449.500000000001 ? input[4] > 9.500000000000002 ? var35 = -.009504203657088933 : input[8] > 819.5000000000001 ? var35 = .18689664822602375 : var35 = .03635576744011826 : var35 = -.029862411809998525 : input[223] > 1e-35 ? var35 = -.06474496692999487 : input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 46.50000000000001 ? var35 = -.09405026597863717 : input[0] > 4153.500000000001 ? var35 = .053577663326799765 : var35 = -.05062127873995668 : var35 = .06512222894425874 : input[39] > 1e-35 ? var35 = -.04985311717827547 : input[51] > 1e-35 ? var35 = -.04541229517934797 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[2] > 30.500000000000004 ? input[0] > 2151.5000000000005 ? var35 = -.02860634573675884 : var35 = .08863753005590103 : var35 = .11158892111063744 : input[0] > 655.5000000000001 ? var35 = -.031005736641654926 : var35 = -.1439827004505974 : input[222] > 1e-35 ? input[1] > 11.500000000000002 ? input[0] > 612.5000000000001 ? var35 = -.00843386136334982 : var35 = -.05273594615999777 : var35 = .1060183822015004 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[8] > 719.5000000000001 ? var35 = -.015774115523598486 : var35 = .10147367091236065 : var35 = -.048307000563071016 : var35 = .002118376117677254;
  let var36;
  input[8] > 1014.5000000000001 ? input[9] > 137.50000000000003 ? var36 = -.10279096288817871 : input[0] > 93.50000000000001 ? input[8] > 1067.5000000000002 ? input[227] > 1e-35 ? var36 = -.03544332389470493 : input[285] > 1e-35 ? input[9] > 64.50000000000001 ? var36 = .07211107542565391 : var36 = -.041556776020476104 : input[145] > 1e-35 ? input[1] > 66.50000000000001 ? var36 = -.0751486415451188 : input[1] > 59.50000000000001 ? var36 = .13459005084554104 : var36 = .024184371850147466 : input[0] > 3072.5000000000005 ? input[95] > 1e-35 ? var36 = .06715575425741895 : var36 = -.005895690393702183 : input[8] > 2915.5000000000005 ? var36 = -.010205039411753762 : input[9] > 33.50000000000001 ? input[9] > 47.50000000000001 ? var36 = -.00029068886245881074 : var36 = .0613467393188786 : input[148] > 1e-35 ? var36 = -.06074463294936236 : input[3] > 1.5000000000000002 ? input[5] > 1849.5000000000002 ? input[1] > 15.500000000000002 ? var36 = .003887223773199377 : var36 = -.08553893131979015 : var36 = .025654192706396767 : var36 = -.05651733979610658 : var36 = -.02039913645229667 : input[2] > 7.500000000000001 ? var36 = -.1058450646728524 : var36 = .02267192191610376 : input[1] > 120.50000000000001 ? input[2] > 60.50000000000001 ? var36 = -.12304707569000428 : input[1] > 132.50000000000003 ? input[6] > 41.50000000000001 ? var36 = .1283258201586378 : var36 = -.01718135372229775 : var36 = -.07702452408491414 : input[125] > 1e-35 ? var36 = -.0804612900572707 : input[178] > 1e-35 ? input[0] > 4533.500000000001 ? var36 = .04273051857848212 : var36 = -.04533122948101463 : input[2] > 196.50000000000003 ? var36 = -.10543331044088727 : input[94] > 1e-35 ? input[5] > 4532.500000000001 ? var36 = .0231032972703664 : var36 = -.04807386814498683 : var36 = .002729435991332102;
  let var37;
  input[179] > 1e-35 ? var37 = -.08065315471211375 : input[183] > 1e-35 ? input[17] > 1e-35 ? var37 = .026484626664041125 : input[10] > 1.5000000000000002 ? var37 = -.10187000872941615 : var37 = .015274190652133752 : input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var37 = .09574540795390041 : var37 = -.06454986703691233 : var37 = -.11411849349353141 : input[266] > 1e-35 ? var37 = -.09281838517322076 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var37 = .06685250330182936 : input[4] > 67.50000000000001 ? input[2] > 97.50000000000001 ? var37 = -.04403391373512386 : var37 = .1132928075412222 : input[2] > 47.50000000000001 ? var37 = -.09700191391838056 : var37 = -.02147184357182825 : input[10] > 4.500000000000001 ? input[21] > 1e-35 ? var37 = -.0735617817957859 : input[17] > 1e-35 ? input[3] > 18.500000000000004 ? var37 = -.001668912999010927 : var37 = -.02363511102970245 : input[8] > 58.50000000000001 ? var37 = -.00035213368294640616 : input[3] > 17.500000000000004 ? input[2] > 28.500000000000004 ? input[10] > 23.500000000000004 ? input[1] > 38.50000000000001 ? var37 = .0911011436534449 : input[1] > 28.500000000000004 ? var37 = -.07192390493729035 : var37 = .06913818091291246 : var37 = -.012312625373699222 : var37 = .06784496312307986 : var37 = -167756936027735e-19 : input[18] > 1e-35 ? input[8] > 302.50000000000006 ? var37 = .0026564453057705273 : var37 = -.025425772389361445 : input[122] > 1e-35 ? var37 = -.12046786388602149 : input[0] > 3183.5000000000005 ? var37 = .01162092842804907 : input[91] > 1e-35 ? var37 = .07000265526928563 : input[1] > 22.500000000000004 ? input[0] > 576.5000000000001 ? var37 = -.0001647792543020228 : var37 = -.023664538532907665 : var37 = .01609078206180752;
  let var38;
  input[294] > 1e-35 ? input[1] > 26.500000000000004 ? input[0] > 4141.500000000001 ? var38 = -.051473645433684705 : input[0] > 3030.5000000000005 ? input[1] > 51.50000000000001 ? var38 = -.017696526862422682 : var38 = .1450050954613223 : var38 = -.05406930069823832 : var38 = -.08308700260259043 : input[120] > 1e-35 ? var38 = .058316269489189415 : input[297] > 1e-35 ? input[94] > 1e-35 ? var38 = -.07425512495167255 : input[8] > 51.50000000000001 ? input[1] > 13.500000000000002 ? input[1] > 33.50000000000001 ? input[19] > 1e-35 ? input[0] > 4498.500000000001 ? var38 = .038431826961746934 : var38 = -.05937462906539856 : input[9] > 65.50000000000001 ? var38 = .10814845712507865 : input[4] > 9.500000000000002 ? input[2] > 22.500000000000004 ? input[1] > 39.50000000000001 ? input[1] > 44.50000000000001 ? input[10] > 44.50000000000001 ? var38 = .12297945639231944 : input[0] > 3796.5000000000005 ? input[4] > 26.500000000000004 ? var38 = -.09579030954062734 : var38 = .025064711572811746 : var38 = .02579440518821548 : var38 = .1044440128091862 : var38 = -.058348633139536844 : var38 = .07766788227934436 : var38 = -.01021229539092708 : input[2] > 2.5000000000000004 ? input[10] > 29.500000000000004 ? input[0] > 3770.5000000000005 ? input[0] > 4438.500000000001 ? var38 = .07463684068207214 : var38 = .18244269035484484 : input[6] > 39.50000000000001 ? var38 = -.06050050067471004 : var38 = .05787759066913493 : var38 = .010783225857972171 : var38 = .1674891243602606 : input[4] > 9.500000000000002 ? var38 = -.004814132027475892 : var38 = -.14543299413454813 : var38 = -.02935093398687923 : input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[8] > 1218.5000000000002 ? var38 = -.07634466313617769 : var38 = .0287825335169114 : var38 = -.06894721943300268 : var38 = -.00023988459059521937;
  let var39;
  input[131] > 1e-35 ? input[1] > 93.50000000000001 ? var39 = -.05706887458825395 : input[2] > 1.5000000000000002 ? var39 = .011446637886629108 : var39 = -.10616119878749211 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[0] > 4977.500000000001 ? var39 = .08424281276381033 : input[3] > 17.500000000000004 ? input[20] > 1e-35 ? var39 = .11146885439601915 : input[8] > 61.50000000000001 ? input[0] > 3530.5000000000005 ? input[9] > 48.50000000000001 ? input[9] > 61.50000000000001 ? var39 = .026278724448495064 : var39 = .17053138400480508 : input[0] > 4463.500000000001 ? var39 = -.06482289890096041 : var39 = .03026516489536295 : var39 = -.031785170717683144 : var39 = .1312690622980455 : input[13] > 1e-35 ? var39 = .14336922540461444 : var39 = .03523850945454039 : var39 = -.015407465968975714 : input[39] > 1e-35 ? var39 = -.054809635385158186 : input[32] > 1e-35 ? input[0] > 4242.500000000001 ? var39 = -.0659975068798723 : var39 = -.008386582621403979 : input[4] > 60.50000000000001 ? input[10] > 75.50000000000001 ? input[3] > 107.50000000000001 ? var39 = -.04225314193574262 : input[3] > 70.50000000000001 ? input[1] > 29.500000000000004 ? var39 = .057409156184759516 : var39 = .2024322059866388 : var39 = -.030670938454461245 : input[10] > 1e-35 ? input[0] > 4733.500000000001 ? var39 = .010648654146284154 : input[308] > 1e-35 ? var39 = .008728141696325391 : input[4] > 64.50000000000001 ? input[298] > 1e-35 ? var39 = .12364025998551711 : var39 = -.02247495081065243 : input[1] > 22.500000000000004 ? var39 = -.0726295464624251 : var39 = .03481895086048152 : input[0] > 4331.500000000001 ? var39 = -.04775443357020673 : var39 = .07172377425057568 : input[2] > 89.50000000000001 ? var39 = -.11782645274716962 : var39 = .00010092665257989378;
  let var40;
  input[147] > 1e-35 ? var40 = -.041560228567115574 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var40 = .062292114082780084 : input[10] > 5.500000000000001 ? input[7] > 22.500000000000004 ? var40 = -.016101990375700172 : input[0] > 2579.5000000000005 ? var40 = -.13045089661551845 : var40 = -.02874367814784938 : var40 = .025835149631944995 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var40 = .17084176915326055 : var40 = -.019195947948312853 : input[222] > 1e-35 ? input[30] > 1e-35 ? input[1] > 36.50000000000001 ? input[8] > 45.50000000000001 ? input[8] > 578.5000000000001 ? input[1] > 67.50000000000001 ? var40 = .10591712319944074 : var40 = -.024082167264285 : var40 = .16497698867036126 : var40 = -.04985066326861431 : input[0] > 1937.5000000000002 ? input[2] > 16.500000000000004 ? var40 = -.021012910475524206 : var40 = -.13058422554298485 : input[0] > 1102.5000000000002 ? var40 = .10955864175201457 : var40 = -.03566689354348996 : input[1] > 11.500000000000002 ? var40 = -.02093884208606101 : var40 = .09107244766183857 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[8] > 719.5000000000001 ? var40 = -.013861861436128482 : var40 = .09756849802202777 : input[224] > 1e-35 ? input[1] > 51.50000000000001 ? var40 = .10163873449625677 : var40 = -.02779270277623805 : input[1] > 26.500000000000004 ? var40 = -.08035058228527389 : var40 = .0005719695099064484 : input[191] > 1e-35 ? input[9] > 9.500000000000002 ? var40 = -.007028075523033826 : var40 = .0489470913925288 : input[1] > 61.50000000000001 ? input[132] > 1e-35 ? var40 = .11230846723576784 : input[0] > 350.50000000000006 ? input[2] > 1.5000000000000002 ? var40 = -.0032075580718124892 : var40 = -.04442829143298883 : var40 = -.06597073245775804 : var40 = .0015594090939337751;
  let var41;
  input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var41 = -.12803889879260094 : var41 = .002171373740016862 : input[121] > 1e-35 ? input[0] > 4720.500000000001 ? input[217] > 1e-35 ? var41 = .08967966612917375 : input[1] > 39.50000000000001 ? var41 = -.059791671514498074 : var41 = .05648934961902822 : input[2] > 59.50000000000001 ? var41 = -.08633234097449628 : input[6] > 53.50000000000001 ? var41 = .11140345067444689 : input[1] > 56.50000000000001 ? input[4] > 7.500000000000001 ? input[0] > 3560.5000000000005 ? var41 = .025606129643140924 : var41 = .13835395886271978 : var41 = -.09361630641448024 : input[4] > 7.500000000000001 ? input[1] > 26.500000000000004 ? input[1] > 49.50000000000001 ? var41 = -.09975506556937946 : input[10] > 36.50000000000001 ? var41 = -.09427724661655643 : input[10] > 24.500000000000004 ? var41 = .07329330653410447 : var41 = -.02271182965807972 : var41 = -.09767874967639482 : input[6] > 13.500000000000002 ? input[10] > 23.500000000000004 ? var41 = -.05082091374050816 : var41 = .1687114435254966 : input[0] > 2314.5000000000005 ? var41 = -.06422664016383926 : var41 = .0636688376664789 : input[298] > 1e-35 ? input[9] > 12.500000000000002 ? input[133] > 1e-35 ? var41 = -.06857762517406195 : input[9] > 71.50000000000001 ? input[0] > 4188.500000000001 ? var41 = -.1274167728754332 : var41 = .01308079126447365 : input[4] > 73.50000000000001 ? var41 = .13854015371106546 : input[4] > 48.50000000000001 ? var41 = -.03684255740123261 : input[6] > 45.50000000000001 ? var41 = .10329912215813097 : input[10] > 77.50000000000001 ? var41 = -.08630788656925215 : var41 = .031022006843800853 : input[1] > 25.500000000000004 ? var41 = -.08278381528048026 : var41 = .06664374548141594 : input[84] > 1e-35 ? var41 = -.05624227409079396 : var41 = .00012184182357340415;
  let var42;
  input[179] > 1e-35 ? var42 = -.07443348719246982 : input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var42 = -.07595415373151816 : var42 = .054065040429292326 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[2] > 13.500000000000002 ? input[0] > 1187.5000000000002 ? var42 = .022822510448266862 : var42 = .17491569312933697 : var42 = -.058362287133533565 : input[2] > 2.5000000000000004 ? var42 = -.03633895806364428 : var42 = .06397808186120692 : input[8] > 4968.500000000001 ? input[1] > 31.500000000000004 ? var42 = -.07294848747514579 : var42 = .025053613105805606 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[107] > 1e-35 ? var42 = -.07009535282685533 : input[8] > 2640.0000000000005 ? var42 = -.051761240111316276 : input[131] > 1e-35 ? var42 = -.06245774419231631 : var42 = .03495606662854905 : var42 = -.013863522184803188 : input[131] > 1e-35 ? input[1] > 93.50000000000001 ? input[1] > 105.50000000000001 ? var42 = .0015036626973581122 : var42 = -.12505706794835883 : input[1] > 48.50000000000001 ? input[276] > 1e-35 ? var42 = .10435171369790015 : input[0] > 5026.500000000001 ? input[0] > 5308.500000000001 ? var42 = .022343994371919224 : var42 = -.14087991797693533 : input[8] > 1323.5000000000002 ? input[10] > 49.50000000000001 ? var42 = .07724450228328664 : input[0] > 3853.5000000000005 ? var42 = -.15671707454435677 : input[10] > 28.500000000000004 ? var42 = -.10179090671841723 : var42 = .014878216919760927 : var42 = .03967665658164865 : input[8] > 2696.5000000000005 ? input[15] > 1e-35 ? var42 = .14054154485273487 : var42 = .01821247272493051 : input[2] > 5.500000000000001 ? input[2] > 100.50000000000001 ? var42 = -.08632985141410315 : var42 = .005524157938954954 : var42 = -.08802502622523681 : var42 = -.0004649168897260341;
  let var43;
  input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 32.50000000000001 ? input[4] > 16.500000000000004 ? var43 = -.007458687464321174 : var43 = -.09444966249102484 : input[1] > 23.500000000000004 ? var43 = .08564129697360716 : var43 = -.07105002902845851 : var43 = .05688756955238231 : input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var43 = -.10326216566705966 : input[1] > 26.500000000000004 ? var43 = .0050539832484585365 : var43 = -.07080395606126953 : input[306] > 1e-35 ? input[149] > 1e-35 ? var43 = -.10399433201474328 : input[2] > 14.500000000000002 ? input[9] > 6.500000000000001 ? var43 = .05783632021087773 : input[10] > 17.500000000000004 ? var43 = -.06720598671764105 : input[1] > 47.50000000000001 ? var43 = .097495825172558 : var43 = -.013372242800584872 : var43 = -.06463226787713715 : input[42] > 1e-35 ? var43 = -.0885725817597767 : input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var43 = -.07496598696848249 : input[1] > 29.500000000000004 ? input[8] > 446.50000000000006 ? var43 = .11051270080118503 : var43 = .027719462817590454 : input[8] > 597.5000000000001 ? var43 = -.08441503592016869 : var43 = .05534229430302502 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var43 = -.12190088985091102 : var43 = -.0067442838156576345 : input[148] > 1e-35 ? input[9] > 79.50000000000001 ? var43 = .09225972475904022 : input[2] > 10.500000000000002 ? input[1] > 102.50000000000001 ? var43 = .11805676536334647 : input[8] > 1726.5000000000002 ? input[9] > 10.500000000000002 ? var43 = .016585157185448045 : var43 = -.11032043771149425 : var43 = .01586986028570486 : input[8] > 388.50000000000006 ? var43 = -.10592413013261853 : var43 = .04930703248769364 : input[13] > 1e-35 ? var43 = .003621937787920821 : var43 = -.0013786331198611841;
  let var44;
  input[145] > 1e-35 ? input[1] > 32.50000000000001 ? input[1] > 38.50000000000001 ? input[10] > 55.50000000000001 ? input[1] > 54.50000000000001 ? var44 = .009769895322846493 : var44 = -.10620052926943656 : input[9] > 19.500000000000004 ? var44 = .03781202525403449 : input[9] > 14.500000000000002 ? var44 = -.11485785321365344 : input[9] > 6.500000000000001 ? var44 = .07677177833073881 : input[0] > 4342.500000000001 ? var44 = -.07079285609687631 : input[49] > 1e-35 ? var44 = .06156814809246001 : var44 = -.014788509042554625 : var44 = -.032659201618470655 : input[5] > 5207.500000000001 ? var44 = -.09013500825185713 : input[3] > 10.500000000000002 ? input[8] > 1787.5000000000002 ? var44 = -.03094160322187924 : input[1] > 29.500000000000004 ? var44 = .09474646043921069 : var44 = .023445783928231618 : var44 = .09342846694174194 : input[0] > 533.5000000000001 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var44 = -.07164443768784848 : input[1] > 29.500000000000004 ? var44 = .089473622509272 : input[8] > 597.5000000000001 ? var44 = -.08155349903101317 : var44 = .07098423265024251 : input[8] > 691.5000000000001 ? input[5] > 2252.5000000000005 ? var44 = -.004003900679358653 : input[190] > 1e-35 ? var44 = -.09236113461485262 : input[8] > 3198.5000000000005 ? var44 = -.0124130160451179 : var44 = .018453070064009328 : input[15] > 1e-35 ? var44 = .012013209112857824 : input[7] > 4.500000000000001 ? input[7] > 5.500000000000001 ? var44 = -.0009580759587680961 : var44 = -.03227283036698222 : var44 = .01369287669536875 : input[1] > 50.50000000000001 ? var44 = -.04213060332500437 : input[35] > 1e-35 ? var44 = -.11508095777767471 : input[190] > 1e-35 ? var44 = -.08611884672400155 : input[297] > 1e-35 ? var44 = .05723551879433584 : var44 = -.004829340082311461;
  let var45;
  input[183] > 1e-35 ? var45 = -.037994150023203555 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[3] > 20.500000000000004 ? input[10] > 36.50000000000001 ? var45 = -.11753465135886734 : var45 = -.007515490299047085 : var45 = -.08576941990777916 : input[8] > 1641.5000000000002 ? input[10] > 37.50000000000001 ? var45 = -.12371142493530439 : input[1] > 36.50000000000001 ? var45 = .032189417575190435 : var45 = -.10339125953022954 : input[3] > 32.50000000000001 ? input[4] > 27.500000000000004 ? input[1] > 59.50000000000001 ? var45 = -.0784518658439288 : input[2] > 54.50000000000001 ? var45 = .12477882322370665 : var45 = .000313468482399738 : var45 = .12261955132611434 : input[8] > 81.50000000000001 ? input[23] > 1e-35 ? var45 = .04969252946760318 : input[8] > 511.50000000000006 ? input[8] > 1146.5000000000002 ? var45 = .0353146070135579 : var45 = -.06327619611098285 : var45 = .02813577701641991 : var45 = -.12354390728506215 : input[34] > 1e-35 ? var45 = -.07664408516055397 : input[3] > 99.50000000000001 ? input[1] > 16.500000000000004 ? input[1] > 26.500000000000004 ? var45 = -.01245803535276381 : var45 = -.07169472553475001 : input[1] > 11.500000000000002 ? var45 = .12989984824561698 : var45 = -.01201544398886606 : input[6] > 91.50000000000001 ? input[1] > 22.500000000000004 ? var45 = .010390226893521422 : input[10] > 14.500000000000002 ? var45 = .16790888126487719 : var45 = .010614982228955577 : input[4] > 79.50000000000001 ? input[9] > 44.50000000000001 ? input[0] > 3853.5000000000005 ? var45 = -.043398307129729134 : var45 = .09963544907820426 : input[9] > 30.500000000000004 ? var45 = -.13540713124984502 : input[9] > 17.500000000000004 ? var45 = .0509435850590757 : var45 = -.04761897852404613 : input[4] > 78.50000000000001 ? var45 = .09197086656470652 : var45 = .0006771050176682337;
  let var46;
  input[122] > 1e-35 ? input[6] > 36.50000000000001 ? var46 = .05686884451670743 : var46 = -.05334759543084309 : input[266] > 1e-35 ? var46 = -.08603579519816038 : input[157] > 1e-35 ? var46 = -.06736746113382097 : input[302] > 1e-35 ? input[0] > 2579.5000000000005 ? var46 = -.0499592651503952 : input[0] > 725.5000000000001 ? var46 = .11780353905132664 : var46 = -.05232097173108943 : input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var46 = -.11398297342629615 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var46 = -.03190157229022304 : var46 = .07985197845805492 : var46 = -.0763078988943886 : input[4] > 41.50000000000001 ? input[280] > 1e-35 ? var46 = .05162933940904835 : input[11] > 1e-35 ? input[0] > 460.50000000000006 ? var46 = -.027174047777029083 : var46 = .057117284879796476 : input[3] > 43.50000000000001 ? var46 = -.0016147040913107311 : var46 = -.05856597304613519 : input[2] > 45.50000000000001 ? input[0] > 4663.500000000001 ? input[18] > 1e-35 ? var46 = -.04779247091640426 : input[10] > 25.500000000000004 ? input[9] > 22.500000000000004 ? input[22] > 1e-35 ? var46 = -.01466076988151239 : var46 = .13375695925484857 : var46 = -.04885873081899647 : input[0] > 5566.500000000001 ? var46 = .11086813028591343 : input[8] > 992.5000000000001 ? var46 = -.07622304217072383 : var46 = .04316019272026325 : input[10] > 12.500000000000002 ? input[9] > 36.50000000000001 ? input[9] > 45.50000000000001 ? var46 = .03285858361708423 : var46 = -.12354858211764992 : var46 = .0672788301823281 : input[15] > 1e-35 ? var46 = .08658836986585006 : var46 = -.02741484278509758 : input[290] > 1e-35 ? var46 = -.08161310335133287 : input[135] > 1e-35 ? var46 = -.04824156054814152 : var46 = .0009156904299554183;
  let var47;
  input[3] > 7.500000000000001 ? var47 = .0006791852818377787 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var47 = .03642374718166293 : var47 = .16379973756366603 : var47 = -.03946685266127979 : input[186] > 1e-35 ? var47 = .07618896623420895 : input[96] > 1e-35 ? var47 = .0680272261319657 : input[107] > 1e-35 ? input[1] > 48.50000000000001 ? var47 = -.022822371600847505 : var47 = .0501405836324949 : input[203] > 1e-35 ? input[1] > 77.50000000000001 ? var47 = .044416424920571296 : var47 = -.0648450593196238 : input[5] > 3921.5000000000005 ? input[1] > 110.50000000000001 ? var47 = -.11110466767595227 : input[9] > 5.500000000000001 ? input[9] > 52.50000000000001 ? input[1] > 50.50000000000001 ? var47 = .1061937286809567 : input[7] > 54.50000000000001 ? var47 = .11487507743121311 : input[8] > 819.5000000000001 ? var47 = -.07181278009001418 : input[10] > 25.500000000000004 ? var47 = .13499019430369633 : input[1] > 31.500000000000004 ? var47 = .09032979489780704 : var47 = -.12754166393372374 : input[9] > 37.50000000000001 ? var47 = -.05093963635361407 : var47 = -.005026651151683848 : input[9] > 2.5000000000000004 ? var47 = .07619735785573735 : var47 = .012363301341532136 : input[26] > 1e-35 ? var47 = -.10685800454968203 : input[8] > 125.50000000000001 ? input[8] > 446.50000000000006 ? input[0] > 3842.5000000000005 ? var47 = -.08783796894105043 : input[282] > 1e-35 ? input[1] > 47.50000000000001 ? input[9] > 40.50000000000001 ? var47 = -.10764172927882483 : var47 = .01890760098464703 : var47 = .06573095405846417 : input[8] > 634.5000000000001 ? var47 = -.00783575973273707 : var47 = -.050612689680229306 : input[1] > 22.500000000000004 ? var47 = -.0016842490401359626 : var47 = .0738227088444087 : var47 = -.02663970950432175;
  let var48;
  input[31] > 1e-35 ? input[8] > 17.500000000000004 ? var48 = .013678038624884814 : input[1] > 35.50000000000001 ? input[1] > 51.50000000000001 ? var48 = .007191286124908192 : var48 = -.09347881647636902 : input[10] > 1.5000000000000002 ? var48 = .07938758708008091 : var48 = -.008702935600305113 : input[224] > 1e-35 ? input[149] > 1e-35 ? input[13] > 1e-35 ? var48 = .12321804057595996 : var48 = -.018281109320672437 : input[23] > 1e-35 ? input[4] > 62.50000000000001 ? var48 = -.04644244754790671 : var48 = .024546310702263208 : input[8] > 862.5000000000001 ? input[0] > 3429.5000000000005 ? input[4] > 9.500000000000002 ? input[52] > 1e-35 ? var48 = .0706108609273337 : input[2] > 40.50000000000001 ? var48 = -.028046629962303716 : var48 = -.06497613993109329 : var48 = .01076489668586676 : input[1] > 33.50000000000001 ? input[0] > 966.5000000000001 ? input[2] > 14.500000000000002 ? input[1] > 38.50000000000001 ? var48 = -.03056331974267756 : var48 = -.11886389712497057 : var48 = .053364962175658184 : input[8] > 2233.5000000000005 ? var48 = -.0448152521157682 : var48 = .1508651602190868 : input[2] > 33.50000000000001 ? input[0] > 2882.5000000000005 ? input[0] > 3183.5000000000005 ? var48 = .03818796510453344 : var48 = .23673992112982362 : var48 = .02858814226507374 : input[10] > 44.50000000000001 ? var48 = -.1125863771551199 : var48 = .009129996952394916 : input[1] > 7.500000000000001 ? var48 = -.004374525302461639 : var48 = -.07858519434925451 : input[149] > 1e-35 ? input[6] > 23.500000000000004 ? var48 = .0005231594491642136 : input[0] > 4053.5000000000005 ? input[8] > 660.5000000000001 ? var48 = -.13677189943034931 : input[10] > 2.5000000000000004 ? var48 = .039591891437078086 : var48 = -.09312596849507347 : var48 = -.02423172142089822 : var48 = .0009836986075266283;
  let var49;
  input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var49 = -.103183298350443 : input[2] > 51.50000000000001 ? var49 = .09784373530929913 : input[10] > 26.500000000000004 ? input[8] > 764.5000000000001 ? var49 = -.05186168947388339 : var49 = .0496996365539082 : input[10] > 23.500000000000004 ? var49 = .1404445738719 : input[93] > 1e-35 ? var49 = .0027146310074558505 : input[5] > 3821.5000000000005 ? var49 = .002153033152069652 : input[4] > 2.5000000000000004 ? var49 = .007663539551317215 : var49 = .13902616832015402 : input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[4] > 64.50000000000001 ? var49 = .11498405722487515 : input[2] > 23.500000000000004 ? input[0] > 2815.5000000000005 ? input[2] > 44.50000000000001 ? input[4] > 42.50000000000001 ? var49 = -.021479467709980358 : var49 = .09336868994327292 : input[1] > 22.500000000000004 ? input[15] > 1e-35 ? var49 = .021660293256233334 : var49 = -.0927396152303864 : var49 = .0665074081601698 : input[0] > 1550.5000000000002 ? var49 = .08972407105958534 : var49 = -.0380796411182682 : input[6] > 13.500000000000002 ? input[10] > 2.5000000000000004 ? var49 = .06761927942466854 : var49 = -.015762168112653286 : input[17] > 1e-35 ? var49 = .10311304131145381 : var49 = -.017672785252336027 : var49 = -.08629805732772755 : input[1] > 24.500000000000004 ? input[138] > 1e-35 ? var49 = -.10638321435298535 : var49 = .0007073011744385905 : input[18] > 1e-35 ? var49 = -.027056185501334325 : input[145] > 1e-35 ? var49 = .023191199677450886 : input[9] > 33.50000000000001 ? input[201] > 1e-35 ? var49 = .09762140519655171 : input[9] > 110.50000000000001 ? var49 = -.06581942957595835 : input[6] > 54.50000000000001 ? var49 = .04959634035251596 : var49 = .0022616298654554207 : var49 = -.007437620924990854;
  let var50;
  input[179] > 1e-35 ? var50 = -.06961998209988884 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var50 = .1470294450403005 : var50 = -.01671476793947083 : input[187] > 1e-35 ? input[6] > 13.500000000000002 ? input[4] > 30.500000000000004 ? input[13] > 1e-35 ? var50 = .07448480853603114 : input[0] > 1012.5000000000001 ? input[5] > 2883.5000000000005 ? input[0] > 3682.5000000000005 ? input[5] > 4031.5000000000005 ? input[23] > 1e-35 ? var50 = .07965955447707423 : input[10] > 10.500000000000002 ? var50 = -.09236156404262426 : var50 = .03396273196231458 : var50 = -.13246465021467432 : var50 = .07092822261735353 : var50 = -.08753829085942 : var50 = .09409024840640956 : input[1] > 40.50000000000001 ? input[8] > 984.5000000000001 ? input[8] > 1514.5000000000002 ? input[8] > 2134.5000000000005 ? var50 = .004705878789890202 : var50 = .13775378964952867 : var50 = -.04770928980587811 : input[10] > 29.500000000000004 ? var50 = .011221519891071544 : input[0] > 3853.5000000000005 ? var50 = .06365381191628273 : var50 = .15506252245336827 : input[1] > 37.50000000000001 ? var50 = -.07254777021042061 : var50 = .026514587757252385 : input[308] > 1e-35 ? var50 = .04115804816617256 : input[10] > 26.500000000000004 ? var50 = .02077721353011946 : input[5] > 3548.5000000000005 ? var50 = -.1280907116663952 : var50 = -.021974774274438 : input[306] > 1e-35 ? var50 = -.02700446558079895 : input[297] > 1e-35 ? input[212] > 1e-35 ? var50 = .07794139136748461 : input[7] > 5.500000000000001 ? input[19] > 1e-35 ? var50 = -.005710865560475598 : input[94] > 1e-35 ? var50 = -.06751507982853555 : var50 = .027250040757588703 : input[9] > 52.50000000000001 ? var50 = .07060357924595577 : var50 = -.030297760713011795 : var50 = -.0006005400085266517;
  let var51;
  input[113] > 1e-35 ? var51 = -.07311041707507712 : input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var51 = -.06996356565314456 : var51 = .04780211300352931 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var51 = -.08317707559926495 : input[21] > 1e-35 ? var51 = -.0817284654645976 : input[15] > 1e-35 ? input[2] > 3.5000000000000004 ? var51 = -.010538203005984922 : var51 = .08454819465349446 : input[9] > 124.50000000000001 ? var51 = .09015659250299132 : input[7] > 15.500000000000002 ? input[5] > 5732.500000000001 ? var51 = -.08542251249346582 : input[9] > 50.50000000000001 ? var51 = -.023428882537657472 : var51 = .010042500833979073 : var51 = .020697210754240154 : input[10] > 28.500000000000004 ? input[5] > 423.00000000000006 ? input[148] > 1e-35 ? var51 = .03006025206979096 : input[9] > 108.50000000000001 ? var51 = -.09153851322499747 : input[145] > 1e-35 ? input[5] > 4814.500000000001 ? input[2] > 38.50000000000001 ? var51 = .04222035773042132 : var51 = -.09078149053947535 : input[8] > 568.5000000000001 ? input[1] > 64.50000000000001 ? var51 = -.07209095448054853 : var51 = .028065954981903313 : var51 = .08714651929917122 : var51 = -.006678820669279169 : input[10] > 40.50000000000001 ? var51 = .006982396294941626 : var51 = -.07889649792011418 : input[94] > 1e-35 ? input[4] > 30.500000000000004 ? var51 = -.09351114982645548 : input[4] > 3.5000000000000004 ? var51 = -.004837550129223451 : var51 = -.08324141237464677 : input[303] > 1e-35 ? var51 = .10703037493990825 : input[9] > 156.50000000000003 ? var51 = -.10803018621648303 : input[116] > 1e-35 ? var51 = -.03208302566598311 : input[212] > 1e-35 ? input[243] > 1e-35 ? var51 = .10261721665006701 : var51 = .018994509090668264 : var51 = .0011244262442038839;
  let var52;
  input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 46.50000000000001 ? var52 = -.08404263465005328 : input[0] > 3682.5000000000005 ? var52 = .041259223920298876 : input[1] > 29.500000000000004 ? var52 = -.09541257493441671 : var52 = .001482192721625409 : var52 = .051541427372951004 : input[3] > 7.500000000000001 ? input[157] > 1e-35 ? var52 = -.08268996098437432 : input[230] > 1e-35 ? var52 = .015749498159959817 : input[4] > 7.500000000000001 ? input[3] > 11.500000000000002 ? var52 = -913218977737457e-19 : input[4] > 10.500000000000002 ? var52 = -.056334165674005156 : input[127] > 1e-35 ? var52 = -.0784634021824036 : input[2] > 9.500000000000002 ? input[1] > 62.50000000000001 ? var52 = -.04231200150318989 : input[10] > 42.50000000000001 ? var52 = .10182973257894812 : var52 = .015934763950068445 : var52 = -.03130938805859397 : input[92] > 1e-35 ? input[4] > 6.500000000000001 ? input[1] > 51.50000000000001 ? input[9] > 19.500000000000004 ? var52 = -.041117068322885315 : var52 = .1167767830037126 : var52 = .13611206992387337 : input[10] > 41.50000000000001 ? var52 = -.07120286010564107 : var52 = .022032788063345417 : input[8] > 1.5000000000000002 ? input[1] > 51.50000000000001 ? input[9] > 72.50000000000001 ? var52 = -.07702290997669524 : input[198] > 1e-35 ? var52 = .08776558554437136 : var52 = -.008290740324975692 : input[2] > 32.50000000000001 ? var52 = .07198457624219955 : var52 = .005463113714361629 : var52 = .09414099512900526 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var52 = .03295785445437507 : var52 = .15140250150674536 : var52 = -.035613213948910254 : input[186] > 1e-35 ? var52 = .06849425535860769 : input[96] > 1e-35 ? var52 = .06028225812727254 : var52 = -.007582543288662308;
  let var53;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var53 = .08396556264106572 : var53 = -.0562516995099192 : var53 = -.10593011018789432 : input[183] > 1e-35 ? input[15] > 1e-35 ? var53 = -.09705176473553752 : input[7] > 18.500000000000004 ? input[2] > 37.50000000000001 ? var53 = .0052017514017035915 : var53 = -.11194119432743639 : var53 = .03724337696163019 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[2] > 16.500000000000004 ? var53 = -.025692451287403446 : var53 = -.09511862672123193 : input[8] > 1661.5000000000002 ? input[10] > 37.50000000000001 ? var53 = -.11892250746801664 : input[10] > 22.500000000000004 ? var53 = .07548493166973796 : var53 = -.05973048107712209 : input[4] > 12.500000000000002 ? input[0] > 4319.500000000001 ? input[10] > 4.500000000000001 ? input[10] > 37.50000000000001 ? var53 = .13750699058082427 : input[18] > 1e-35 ? var53 = .06535408879552801 : var53 = -.054118179035040674 : var53 = .1344282838979622 : input[0] > 3982.5000000000005 ? var53 = -.10409582202467015 : input[19] > 1e-35 ? var53 = .12672850705810795 : input[8] > 587.5000000000001 ? input[1] > 35.50000000000001 ? var53 = .012705935670766466 : var53 = .14149359442527545 : var53 = -.047977876173706004 : input[20] > 1e-35 ? var53 = .057945228080337946 : input[0] > 3642.5000000000005 ? var53 = -.008726535792122467 : var53 = -.08424769891378858 : input[34] > 1e-35 ? var53 = -.0699329538228602 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[4] > 15.500000000000002 ? input[0] > 1187.5000000000002 ? var53 = .01196849566739346 : var53 = .1614642278429876 : var53 = -.043022338150701625 : input[3] > 5.500000000000001 ? var53 = -.03907848255033881 : var53 = .018280601026175593 : var53 = .0006654540402589085;
  let var54;
  input[31] > 1e-35 ? input[2] > 58.50000000000001 ? input[9] > 1.5000000000000002 ? var54 = -.01386103677247845 : var54 = .11386694333005128 : input[4] > 27.500000000000004 ? var54 = -.021862617610091336 : input[2] > 31.500000000000004 ? var54 = .0828858469030438 : var54 = .006483353475830127 : input[224] > 1e-35 ? input[149] > 1e-35 ? input[13] > 1e-35 ? var54 = .11303635767048735 : var54 = -.01645525128352694 : input[23] > 1e-35 ? input[4] > 62.50000000000001 ? var54 = -.04238798044549342 : var54 = .022091190130494303 : input[5] > 5082.500000000001 ? var54 = -.04287166152163786 : input[8] > 862.5000000000001 ? input[19] > 1e-35 ? var54 = .000660344696244351 : input[4] > 9.500000000000002 ? input[0] > 1277.5000000000002 ? var54 = -.04291104140431434 : input[17] > 1e-35 ? var54 = .11256797532342613 : var54 = -.017206916368289193 : var54 = .026482035265709743 : input[1] > 8.500000000000002 ? input[11] > 1e-35 ? var54 = .04060606971664621 : input[0] > 4733.500000000001 ? input[8] > 214.50000000000003 ? input[5] > 4814.500000000001 ? var54 = .03581712466863222 : var54 = .14770264307668884 : input[8] > 73.50000000000001 ? var54 = -.13093289429740068 : var54 = .042461737442702936 : input[52] > 1e-35 ? var54 = .0501831919044939 : var54 = -.010450249720465756 : var54 = -.0753365425372656 : input[149] > 1e-35 ? input[6] > 23.500000000000004 ? var54 = .0005381332165438493 : var54 = -.04549431717503909 : input[133] > 1e-35 ? input[2] > 5.500000000000001 ? input[8] > 698.5000000000001 ? input[282] > 1e-35 ? var54 = .04849637311285226 : var54 = -.036671377119808564 : input[0] > 421.50000000000006 ? var54 = .00020968499911058945 : var54 = .11636422423182405 : var54 = -.12687837788222575 : var54 = .0012774367867215346;
  let var55;
  input[120] > 1e-35 ? var55 = .04776057572434719 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[0] > 3904.5000000000005 ? var55 = -.042799574885345304 : var55 = .07412430171193245 : var55 = -.11248270469336048 : input[193] > 1e-35 ? var55 = -.060694220820603384 : input[121] > 1e-35 ? input[217] > 1e-35 ? input[0] > 4449.500000000001 ? input[4] > 8.500000000000002 ? var55 = .028911612178122104 : var55 = .12326369727728437 : input[0] > 4091.5000000000005 ? var55 = -.09370267064141052 : input[0] > 3519.5000000000005 ? input[8] > 668.5000000000001 ? var55 = .1159839898100149 : var55 = -.01924880886585737 : input[8] > 501.50000000000006 ? input[10] > 16.500000000000004 ? var55 = -.0216343737351583 : var55 = -.1220272260878369 : input[2] > 18.500000000000004 ? var55 = .09152924475072398 : input[8] > 55.50000000000001 ? var55 = .039508716651005665 : var55 = -.11714436880423203 : input[18] > 1e-35 ? input[9] > 2.5000000000000004 ? var55 = .06793009902674053 : var55 = -.024060578029812988 : input[4] > 2.5000000000000004 ? input[2] > 16.500000000000004 ? input[4] > 11.500000000000002 ? var55 = -.04391068849624096 : var55 = .04009967593394672 : input[8] > 1085.5000000000002 ? var55 = -.024773826356034825 : var55 = -.13919707884246582 : var55 = .06659278075192335 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var55 = -.11567917501901476 : var55 = -.006813640337684114 : input[3] > 7.500000000000001 ? var55 = .0010671269682548076 : input[7] > 3.5000000000000004 ? input[1] > 33.50000000000001 ? input[0] > 1597.5000000000002 ? input[10] > 1.5000000000000002 ? var55 = -.001754586408351048 : var55 = -.055422422450722056 : var55 = -.06090032532532226 : input[0] > 5269.500000000001 ? var55 = .11787981735983527 : var55 = -.00198119768540783 : var55 = .00210412924303036;
  let var56;
  input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var56 = -.09738558653332406 : input[0] > 2432.5000000000005 ? input[0] > 4533.500000000001 ? var56 = -.06063239096209816 : var56 = .03317022411417386 : var56 = -.08607562321324262 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var56 = -.013608609329298802 : var56 = .09078000157330264 : input[99] > 1e-35 ? var56 = .014828708581964632 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var56 = -.07536137260189814 : var56 = .006253266595455118 : input[10] > 28.500000000000004 ? var56 = -.006106041147592768 : input[9] > 156.50000000000003 ? var56 = -.11828932797811101 : input[94] > 1e-35 ? var56 = -.02566078479505714 : input[303] > 1e-35 ? var56 = .09544850289775349 : input[15] > 1e-35 ? input[224] > 1e-35 ? input[4] > 56.50000000000001 ? var56 = -.08401252789168523 : input[5] > 4244.500000000001 ? var56 = .026372887658499107 : input[1] > 16.500000000000004 ? var56 = -.027836756345634026 : var56 = .09205362097909099 : var56 = .00934612788718244 : input[203] > 1e-35 ? var56 = -.016371658366767253 : input[7] > 26.500000000000004 ? input[0] > 966.5000000000001 ? input[1] > 38.50000000000001 ? input[146] > 1e-35 ? input[9] > 21.500000000000004 ? var56 = -.09580979052540028 : input[1] > 50.50000000000001 ? var56 = -.06402211827281554 : var56 = .08342858760095972 : input[2] > 36.50000000000001 ? var56 = .008114897658204584 : input[92] > 1e-35 ? var56 = .09541587072672864 : var56 = -.022342147210555434 : var56 = -.01660492519175128 : var56 = .014721622240945446 : input[4] > 25.500000000000004 ? input[11] > 1e-35 ? var56 = .15846731118501817 : var56 = .039498507912023195 : input[245] > 1e-35 ? var56 = .07008718676813333 : var56 = .0019806389728814727;
  let var57;
  input[32] > 1e-35 ? input[8] > 90.50000000000001 ? input[4] > 67.50000000000001 ? input[0] > 4188.500000000001 ? var57 = -.01192072916082109 : var57 = .13888590840802637 : input[1] > 16.500000000000004 ? input[8] > 2302.5000000000005 ? var57 = .06874032717466054 : input[4] > 40.50000000000001 ? var57 = -.07752510020707537 : input[1] > 76.50000000000001 ? var57 = -.09944032260703917 : input[8] > 1381.5000000000002 ? var57 = -.054466635810800745 : input[1] > 32.50000000000001 ? var57 = .05974084520839573 : var57 = -.0384718740755954 : var57 = -.11374190719134032 : input[0] > 2151.5000000000005 ? var57 = -.13703645155803298 : var57 = .004833344758654556 : input[297] > 1e-35 ? input[212] > 1e-35 ? var57 = .06954747264544993 : input[7] > 9.500000000000002 ? input[19] > 1e-35 ? input[1] > 30.500000000000004 ? input[0] > 4242.500000000001 ? var57 = .013539805885738608 : var57 = -.0692740641801559 : input[0] > 2653.5000000000005 ? input[10] > 57.50000000000001 ? var57 = .09941880179344399 : var57 = -.01608127391210995 : var57 = .08025226531247417 : input[9] > 67.50000000000001 ? var57 = .13525448212444113 : input[6] > 61.50000000000001 ? var57 = -.05511099182158894 : input[94] > 1e-35 ? var57 = -.06821509831783572 : input[128] > 1e-35 ? var57 = .11361314817714643 : var57 = .030160785008575566 : input[1] > 13.500000000000002 ? input[8] > 17.500000000000004 ? input[16] > 1e-35 ? var57 = -.09954181329804547 : input[197] > 1e-35 ? var57 = .10102833149755386 : input[188] > 1e-35 ? var57 = .05584490988313965 : input[9] > 49.50000000000001 ? input[4] > 5.500000000000001 ? var57 = -.03781554214742005 : var57 = .09927933385592314 : var57 = -.020006000056720083 : var57 = -.10520473615957895 : var57 = -.12006990846253787 : var57 = -.00026111570975317574;
  let var58;
  input[8] > 2830.5000000000005 ? input[1] > 31.500000000000004 ? input[9] > 32.50000000000001 ? input[5] > 1234.5000000000002 ? input[0] > 1725.5000000000002 ? input[7] > 14.500000000000002 ? input[2] > 38.50000000000001 ? var58 = -.019188245509744628 : var58 = -.13354864350075848 : input[0] > 2461.5000000000005 ? var58 = .051885477468354396 : var58 = -.0833581968852119 : var58 = .08233441701532287 : var58 = -.10865584951212362 : input[8] > 2992.5000000000005 ? input[10] > 49.50000000000001 ? input[10] > 56.50000000000001 ? input[1] > 45.50000000000001 ? input[0] > 2041.5000000000002 ? var58 = .09926337893072812 : var58 = -.027753610497327715 : input[0] > 1972.5000000000002 ? var58 = -.09780045823152517 : var58 = .032380915168504935 : var58 = .11502632261226381 : input[17] > 1e-35 ? var58 = -.06094965899579662 : input[10] > 40.50000000000001 ? var58 = -.07500475582440802 : var58 = .006499832113084677 : input[10] > 4.500000000000001 ? input[4] > 10.500000000000002 ? var58 = -.09584538995220808 : var58 = -.00908705814304442 : var58 = .03203281520813893 : input[10] > 49.50000000000001 ? var58 = -.03146271513986384 : input[2] > 63.50000000000001 ? var58 = .13172001315536286 : input[224] > 1e-35 ? var58 = .08945777550527927 : input[0] > 2282.5000000000005 ? input[4] > 4.500000000000001 ? var58 = .09521549382082259 : var58 = -.04414925613522197 : input[0] > 1847.5000000000002 ? var58 = -.09118580379557353 : var58 = .009206744918282364 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[1] > 31.500000000000004 ? var58 = .03525144509943896 : var58 = -.053340750721609057 : input[0] > 1057.5000000000002 ? input[10] > 2.5000000000000004 ? var58 = -.04766112322938157 : input[2] > 10.500000000000002 ? var58 = .0728516504357201 : var58 = -.05049625965272536 : var58 = -.10868663055825774 : var58 = .0005382613419948969;
  let var59;
  input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var59 = -.10615739288764095 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var59 = -.030504020655417463 : var59 = .07102458639110094 : var59 = -.07058131985243714 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var59 = .055304563442710876 : input[1] > 53.50000000000001 ? var59 = .033723409577443623 : input[8] > 175.50000000000003 ? input[0] > 2628.5000000000005 ? input[9] > 40.50000000000001 ? var59 = -.1568835288372895 : var59 = -.0279829124400056 : var59 = .04493843959601833 : var59 = -.11637042729644327 : input[191] > 1e-35 ? input[282] > 1e-35 ? var59 = -.054133834303687026 : input[9] > 48.50000000000001 ? var59 = .11263810289007213 : input[9] > 9.500000000000002 ? var59 = -.02202034562838259 : input[4] > 45.50000000000001 ? var59 = -.03410927569045158 : var59 = .04381615166534081 : input[242] > 1e-35 ? input[0] > 3615.5000000000005 ? input[3] > 19.500000000000004 ? input[1] > 56.50000000000001 ? input[4] > 28.500000000000004 ? var59 = -.029687297407295893 : var59 = .10673602850001934 : input[4] > 42.50000000000001 ? var59 = .0036275562945108117 : var59 = -.0760789221330622 : var59 = -.10385623431741903 : input[2] > 34.50000000000001 ? input[2] > 44.50000000000001 ? input[4] > 51.50000000000001 ? var59 = .08274426793676076 : var59 = -.07076234425516396 : var59 = .13890177606150175 : var59 = -.019863286503635686 : input[53] > 1e-35 ? input[18] > 1e-35 ? var59 = -.09250637750836187 : var59 = -.0031531727902009026 : input[2] > 107.50000000000001 ? input[4] > 91.50000000000001 ? input[1] > 16.500000000000004 ? var59 = -.01897867921812603 : var59 = .04890781705365262 : var59 = -.11569892307597907 : input[2] > 106.50000000000001 ? var59 = .09032697440623969 : var59 = .00047935919155035045;
  let var60;
  input[115] > 1e-35 ? var60 = .05338335681275557 : input[242] > 1e-35 ? input[0] > 3615.5000000000005 ? input[4] > 42.50000000000001 ? input[4] > 75.50000000000001 ? var60 = -.10131179514695865 : input[8] > 938.5000000000001 ? var60 = .10203729808015481 : var60 = -.015357944186835289 : input[1] > 56.50000000000001 ? input[2] > 22.500000000000004 ? var60 = .03574015165562999 : var60 = -.07763042506449493 : var60 = -.0813323116215548 : input[2] > 34.50000000000001 ? input[2] > 44.50000000000001 ? input[4] > 51.50000000000001 ? var60 = .0665706259130275 : var60 = -.06586817559309924 : var60 = .11925564412287476 : var60 = -.014170019267143326 : input[1] > 124.50000000000001 ? input[2] > 30.500000000000004 ? input[8] > 533.5000000000001 ? input[4] > 41.50000000000001 ? input[8] > 977.5000000000001 ? var60 = .046017146627455346 : var60 = -.08623321630086885 : input[8] > 1765.5000000000002 ? var60 = -.017990564319859934 : input[10] > 25.500000000000004 ? input[10] > 48.50000000000001 ? var60 = .11143827902215087 : var60 = -.01817808730473413 : var60 = .16980985030210127 : var60 = -.09357806298740017 : input[10] > 7.500000000000001 ? input[10] > 54.50000000000001 ? var60 = .010168994879727824 : var60 = -.09099594488792513 : input[9] > 1.5000000000000002 ? var60 = .0533459678147928 : var60 = -.06886854808370108 : input[99] > 1e-35 ? input[17] > 1e-35 ? input[9] > 22.500000000000004 ? var60 = -.062346959148773695 : input[1] > 47.50000000000001 ? var60 = -.0021578343835599316 : input[2] > 27.500000000000004 ? var60 = .19567373210166172 : var60 = .07851555379116423 : input[18] > 1e-35 ? var60 = .03711549097804649 : input[8] > 359.50000000000006 ? var60 = .012492346746905587 : input[4] > 20.500000000000004 ? var60 = .047511695735697544 : var60 = -.07999269063948773 : var60 = 6802045404471004e-20;
  let var61;
  input[222] > 1e-35 ? input[0] > 612.5000000000001 ? input[10] > 1e-35 ? input[8] > 2167.5000000000005 ? input[4] > 25.500000000000004 ? var61 = .0011484728213539738 : var61 = -.0936582904650763 : input[2] > 25.500000000000004 ? input[8] > 182.50000000000003 ? input[10] > 22.500000000000004 ? input[0] > 5026.500000000001 ? var61 = -.09828874964938798 : input[8] > 1586.5000000000002 ? var61 = .13726397438080162 : input[4] > 48.50000000000001 ? input[2] > 63.50000000000001 ? var61 = .011938269926919522 : var61 = .17541983715953954 : input[19] > 1e-35 ? var61 = .023002786011088672 : var61 = -.06221461272461431 : input[9] > 2.5000000000000004 ? input[0] > 3818.5000000000005 ? var61 = .06508934844183291 : var61 = -.10168553534835639 : var61 = -.07755626499024171 : input[2] > 51.50000000000001 ? input[4] > 65.50000000000001 ? var61 = .021140806225203937 : var61 = -.1167833342453639 : input[2] > 33.50000000000001 ? var61 = .13163585734056618 : var61 = -.00203273890889717 : input[10] > 36.50000000000001 ? input[8] > 1067.5000000000002 ? var61 = .06314479201263888 : var61 = -.09639088327091713 : input[10] > 29.500000000000004 ? var61 = .09225469303582386 : input[0] > 3129.5000000000005 ? input[0] > 4091.5000000000005 ? input[0] > 4354.500000000001 ? var61 = 40577156464836036e-21 : var61 = .12322387121810757 : var61 = -.03697224045046014 : input[1] > 22.500000000000004 ? var61 = .016474835887320276 : var61 = .16919298733903063 : var61 = .07633203630214054 : var61 = -.047438037934250644 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var61 = .14150493354700563 : var61 = -.01831155354975749 : input[1] > 28.500000000000004 ? var61 = -.07952557178685365 : input[10] > 28.500000000000004 ? var61 = .0665695554984927 : var61 = -.053640139319277094 : var61 = .0004754840665898665;
  let var62;
  input[76] > 1e-35 ? var62 = -.06814884255939921 : input[179] > 1e-35 ? var62 = -.06325743795510681 : input[122] > 1e-35 ? input[6] > 36.50000000000001 ? var62 = .05052338063261613 : input[8] > 626.5000000000001 ? input[1] > 38.50000000000001 ? var62 = .004193658608848433 : var62 = -.1066968975983452 : input[8] > 302.50000000000006 ? var62 = .05476730110440451 : var62 = -.06382970920394895 : input[218] > 1e-35 ? input[2] > 3.5000000000000004 ? input[6] > 13.500000000000002 ? input[2] > 19.500000000000004 ? input[0] > 3200.5000000000005 ? input[4] > 91.50000000000001 ? var62 = -.12156071809840739 : input[9] > 21.500000000000004 ? input[5] > 3883.5000000000005 ? input[8] > 919.5000000000001 ? input[8] > 1085.5000000000002 ? var62 = .013555772109446666 : var62 = -.09856116699770784 : var62 = .0284329611813383 : input[2] > 52.50000000000001 ? var62 = .04008708444763762 : input[9] > 29.500000000000004 ? var62 = -.1289599546008197 : var62 = -.018566534248335896 : input[8] > 747.5000000000001 ? var62 = .02236484980076122 : var62 = .1148871655157582 : input[8] > 3084.0000000000005 ? var62 = -.05573875952902531 : input[10] > 17.500000000000004 ? input[2] > 51.50000000000001 ? var62 = .03164751204281298 : var62 = .11752140436184891 : input[9] > 42.50000000000001 ? var62 = -.07180559595410106 : input[22] > 1e-35 ? var62 = .09325040416256854 : var62 = -.016041122807939914 : var62 = -.02765708954618808 : input[1] > 30.500000000000004 ? input[1] > 66.50000000000001 ? var62 = -.010718250133458515 : var62 = .09818827994853763 : var62 = .010180038981174032 : var62 = -.039472162599295535 : input[9] > 170.50000000000003 ? var62 = -.08536729235976731 : input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var62 = -.08674788057474031 : var62 = .02077653508548371 : var62 = -.0003536561382007414;
  let var63;
  input[86] > 1e-35 ? input[10] > 6.500000000000001 ? input[0] > 4376.500000000001 ? var63 = .018337297491457794 : var63 = -.05926206443180149 : var63 = .024026520855881126 : input[288] > 1e-35 ? input[184] > 1e-35 ? var63 = .10747078482128616 : input[126] > 1e-35 ? var63 = -.10550625192391357 : input[7] > 71.50000000000001 ? var63 = -.07698346027863572 : input[8] > 302.50000000000006 ? input[6] > 49.50000000000001 ? input[4] > 47.50000000000001 ? input[1] > 38.50000000000001 ? input[15] > 1e-35 ? var63 = .1317396472229434 : var63 = -.025035791351328947 : var63 = -.0728334305864372 : input[8] > 963.5000000000001 ? var63 = .023642201723096064 : var63 = .183010326734258 : input[128] > 1e-35 ? var63 = .04228920135648387 : input[2] > 34.50000000000001 ? input[15] > 1e-35 ? var63 = .002801782941492993 : input[3] > 40.50000000000001 ? input[4] > 39.50000000000001 ? var63 = -.1088876900335281 : var63 = .02758317023002635 : var63 = -.11886771300807207 : input[9] > 59.50000000000001 ? input[1] > 33.50000000000001 ? var63 = -.01928020117446408 : var63 = .10193718474139135 : input[1] > 48.50000000000001 ? input[4] > 9.500000000000002 ? input[8] > 932.5000000000001 ? var63 = .07893723375925096 : var63 = -.009878929627026153 : input[10] > 2.5000000000000004 ? input[9] > 20.500000000000004 ? var63 = -.10301657587280551 : var63 = .005787463140224318 : var63 = .07421364314695046 : input[0] > 2840.5000000000005 ? input[10] > 29.500000000000004 ? var63 = -.019296977889522397 : var63 = -.07274529751752634 : input[1] > 30.500000000000004 ? var63 = -.050368901143148286 : var63 = .029630869489466655 : input[2] > 6.500000000000001 ? input[4] > 9.500000000000002 ? var63 = .0015332402792773946 : var63 = .09930153676749967 : var63 = -.06370844564357069 : var63 = .00042272155209927616;
  let var64;
  input[71] > 1e-35 ? input[4] > 17.500000000000004 ? var64 = .12586844370423247 : var64 = -.006791999603126354 : input[222] > 1e-35 ? input[1] > 10.500000000000002 ? input[30] > 1e-35 ? input[1] > 36.50000000000001 ? input[9] > 1.5000000000000002 ? input[10] > 25.500000000000004 ? var64 = -.08474891624263797 : input[8] > 125.50000000000001 ? var64 = .08125086980439704 : var64 = -.04082085238068532 : input[0] > 3863.5000000000005 ? var64 = .020481535807469208 : var64 = .14810819386202126 : input[0] > 1937.5000000000002 ? input[2] > 16.500000000000004 ? var64 = -.019110200161573936 : var64 = -.12387719685855114 : input[0] > 1102.5000000000002 ? var64 = .08376595701957407 : var64 = -.031821919580524834 : input[9] > 4.500000000000001 ? var64 = -.08116383486497568 : input[7] > 8.500000000000002 ? input[2] > 24.500000000000004 ? var64 = -.02154820850475448 : input[0] > 3863.5000000000005 ? input[8] > 902.5000000000001 ? var64 = .1349841206807871 : var64 = .011864053595560297 : input[1] > 41.50000000000001 ? var64 = -.08203662486612544 : input[2] > 18.500000000000004 ? var64 = -.009541865642346947 : var64 = .08345043168501759 : input[2] > 10.500000000000002 ? var64 = -.09585031818030947 : var64 = .019432330487099865 : var64 = .08399259524715129 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var64 = .11951517733981365 : var64 = -.016651014735738538 : input[1] > 28.500000000000004 ? var64 = -.07410922545030711 : input[10] > 28.500000000000004 ? var64 = .05886430683844788 : var64 = -.04929626605117184 : input[191] > 1e-35 ? input[9] > 9.500000000000002 ? input[9] > 48.50000000000001 ? var64 = .04802269879144705 : var64 = -.026208212831796737 : input[4] > 45.50000000000001 ? var64 = -.03227476944664786 : var64 = .05124575625622705 : var64 = .00020506696916003137;
  let var65;
  input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[9] > 17.500000000000004 ? var65 = -.03042091758483443 : input[10] > 14.500000000000002 ? var65 = .09816619204768777 : var65 = .01332124067720947 : input[8] > 8.500000000000002 ? input[4] > 15.500000000000002 ? var65 = -.02381165060401718 : var65 = -.10950361804974783 : var65 = .03538211665111128 : input[212] > 1e-35 ? input[19] > 1e-35 ? var65 = -.09940014650006174 : input[0] > 2215.5000000000005 ? input[5] > 5056.500000000001 ? input[3] > 5.500000000000001 ? input[10] > 25.500000000000004 ? var65 = -.06371052144380579 : var65 = .0835500621252692 : var65 = -.10408255929333915 : input[1] > 74.50000000000001 ? var65 = .13208968122712403 : input[1] > 64.50000000000001 ? var65 = -.04778844603644965 : input[8] > 51.50000000000001 ? input[8] > 201.50000000000003 ? input[8] > 660.5000000000001 ? input[6] > 4.500000000000001 ? input[9] > 5.500000000000001 ? input[1] > 29.500000000000004 ? input[0] > 3830.5000000000005 ? var65 = .09922816902423433 : var65 = .016366955328796718 : var65 = .1592412560903584 : input[1] > 39.50000000000001 ? var65 = .05409467990258923 : var65 = -.08260633210459611 : var65 = -.06307205775247567 : input[9] > 36.50000000000001 ? var65 = .040253940015648144 : var65 = .14202568969471283 : var65 = -.028761848341594044 : var65 = .08994073058773508 : input[0] > 807.5000000000001 ? var65 = -.043427848826323195 : var65 = .04573516446846493 : input[20] > 1e-35 ? input[188] > 1e-35 ? var65 = -.0758877731600639 : input[23] > 1e-35 ? var65 = .05913923322043199 : input[8] > 155.50000000000003 ? input[128] > 1e-35 ? var65 = .08124700978741987 : var65 = .013296063087086852 : input[7] > 5.500000000000001 ? var65 = -.01640196088612987 : var65 = -.12685498840146067 : var65 = -.0004940792382459551;
  let var66;
  input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 61.50000000000001 ? input[17] > 1e-35 ? var66 = -.05584993681929434 : input[9] > 27.500000000000004 ? input[0] > 3916.5000000000005 ? var66 = .08513773825688947 : var66 = -.1184664832315282 : var66 = .05676963535893477 : var66 = .14263843210340613 : var66 = .0005795003292924202 : input[18] > 1e-35 ? input[0] > 5453.500000000001 ? input[1] > 11.500000000000002 ? var66 = -.10669720555606924 : var66 = .029016613003137307 : input[2] > 46.50000000000001 ? input[10] > 9.500000000000002 ? var66 = .0664744575868955 : var66 = -.08469256188890871 : var66 = -.026746678040592144 : input[281] > 1e-35 ? var66 = -.07408427239006925 : input[145] > 1e-35 ? input[4] > 6.500000000000001 ? input[9] > 16.500000000000004 ? input[4] > 18.500000000000004 ? var66 = .012131807587207655 : var66 = -.12776015795398743 : var66 = .04320472481083551 : var66 = .08390980661550446 : input[10] > 227.50000000000003 ? var66 = -.09771783809101153 : input[10] > 130.50000000000003 ? var66 = .11175201938704937 : input[8] > 779.5000000000001 ? input[5] > 3325.5000000000005 ? input[128] > 1e-35 ? var66 = -.07610698254064358 : input[8] > 902.5000000000001 ? var66 = -.03136381213599649 : input[131] > 1e-35 ? var66 = .0704821739127936 : input[224] > 1e-35 ? var66 = -.056961477774953785 : input[10] > 30.500000000000004 ? input[9] > 43.50000000000001 ? var66 = .10431473040024908 : input[8] > 841.5000000000001 ? var66 = .07304745320500514 : var66 = -.038011541882439825 : var66 = -.01679746695007364 : input[0] > 3129.5000000000005 ? var66 = .05589952587431965 : input[210] > 1e-35 ? var66 = .06227198085800842 : var66 = -.0011341890997947812 : input[8] > 740.5000000000001 ? var66 = .04817300084412584 : var66 = -.000577001010789238;
  let var67;
  input[187] > 1e-35 ? input[6] > 12.500000000000002 ? input[10] > 8.500000000000002 ? input[10] > 16.500000000000004 ? input[8] > 234.50000000000003 ? input[4] > 43.50000000000001 ? input[0] > 4476.500000000001 ? var67 = -.10504730480402079 : input[5] > 3341.5000000000005 ? var67 = .11087894671081754 : var67 = -.0406668834674614 : var67 = .03308382165616109 : input[8] > 104.50000000000001 ? var67 = -.10431436764549162 : var67 = .0073928337244891455 : input[4] > 34.50000000000001 ? var67 = -.10571751512748416 : var67 = -.006081128814142983 : input[13] > 1e-35 ? var67 = .1299673566095023 : input[4] > 60.50000000000001 ? var67 = -.06587492443829139 : input[0] > 2604.5000000000005 ? input[3] > 19.500000000000004 ? var67 = .04857126072645073 : var67 = -.03431365358104773 : input[4] > 16.500000000000004 ? var67 = .04101865986596709 : var67 = .16480274980378218 : input[10] > 26.500000000000004 ? var67 = .03673978504199255 : input[10] > 9.500000000000002 ? var67 = -.10996402743800027 : input[308] > 1e-35 ? var67 = .0553693735082498 : var67 = -.041600136235644125 : input[306] > 1e-35 ? input[8] > 1156.5000000000002 ? input[4] > 14.500000000000002 ? input[10] > 21.500000000000004 ? var67 = .010902983761213922 : var67 = .1325118659895645 : var67 = -.064362945508595 : input[1] > 66.50000000000001 ? var67 = .033416767779331176 : var67 = -.054080316225040496 : input[42] > 1e-35 ? var67 = -.07762364337810815 : input[10] > 1089.5000000000002 ? var67 = -.08465599849125216 : input[31] > 1e-35 ? input[8] > 30.500000000000004 ? var67 = .012788520036013586 : input[1] > 32.50000000000001 ? input[1] > 51.50000000000001 ? var67 = .0220102041325908 : var67 = -.06516708740003069 : var67 = .012833498905748267 : input[224] > 1e-35 ? var67 = -.007038418272997865 : var67 = .00037666304316290967;
  let var68;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var68 = .07554189644995735 : var68 = -.052089349455904946 : var68 = -.10148206848169845 : input[113] > 1e-35 ? var68 = -.06666678653225779 : input[39] > 1e-35 ? input[9] > 3.5000000000000004 ? input[0] > 3670.5000000000005 ? var68 = .07172653627995676 : var68 = -.07602959317610998 : var68 = -.08790686271287523 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[0] > 3904.5000000000005 ? var68 = -.0399322883690891 : var68 = .06523495517476098 : var68 = -.10358715295743802 : input[193] > 1e-35 ? var68 = -.05551414334329124 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[2] > 13.500000000000002 ? input[10] > 1.5000000000000002 ? var68 = .015928764772252406 : var68 = .1341513061552287 : var68 = -.04975001987586173 : input[10] > 2.5000000000000004 ? input[3] > 5.500000000000001 ? input[9] > 2.5000000000000004 ? input[8] > 310.50000000000006 ? var68 = -.033592997607280156 : var68 = -.12432458028446665 : input[1] > 32.50000000000001 ? input[217] > 1e-35 ? var68 = -.08402551858097379 : var68 = .017401984506038796 : input[1] > 25.500000000000004 ? var68 = .13337205393591278 : var68 = -.01160208350090984 : var68 = .06708317942315471 : input[8] > 227.50000000000003 ? var68 = -.08486943882418681 : var68 = -.013970104864235007 : input[8] > 4968.500000000001 ? input[1] > 31.500000000000004 ? input[9] > 4.500000000000001 ? var68 = -.10496268177586783 : var68 = -.020921489532370493 : var68 = .02629915927247642 : input[7] > 20.500000000000004 ? input[8] > 251.50000000000003 ? input[115] > 1e-35 ? var68 = .11639296062157028 : var68 = -.004275784356569115 : input[32] > 1e-35 ? var68 = -.07297384970166025 : var68 = .006026841626381599 : var68 = .002034611134960428;
  let var69;
  input[248] > 1e-35 ? var69 = .06091438745093315 : input[0] > 384.50000000000006 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var69 = -.06455513326540585 : input[1] > 29.500000000000004 ? var69 = .07718474591552532 : input[4] > 7.500000000000001 ? var69 = .040139336931404826 : var69 = -.09685734690563386 : var69 = .00015327283570347363 : input[9] > 88.50000000000001 ? var69 = .10079017954199324 : input[1] > 47.50000000000001 ? input[2] > 20.500000000000004 ? input[2] > 27.500000000000004 ? var69 = -.04077257804338707 : var69 = .0739963982640615 : input[9] > 1.5000000000000002 ? input[17] > 1e-35 ? var69 = .03778141591008941 : var69 = -.06459919920634845 : var69 = -.11193190957880604 : input[7] > 6.500000000000001 ? input[11] > 1e-35 ? input[18] > 1e-35 ? var69 = .14063930759326346 : input[0] > 179.50000000000003 ? var69 = .07287482250668585 : input[8] > 1180.5000000000002 ? var69 = -.14419393112726253 : input[10] > 28.500000000000004 ? var69 = -.07993142770099469 : input[17] > 1e-35 ? var69 = -.04702595410391655 : input[7] > 21.500000000000004 ? input[2] > 26.500000000000004 ? var69 = .05527969663610186 : var69 = -.10824385941441346 : input[3] > 11.500000000000002 ? var69 = .12358502961047915 : var69 = -.017509147119622873 : input[0] > 74.50000000000001 ? var69 = -.014907705458730486 : input[8] > 95.50000000000001 ? var69 = -.02225118168342062 : var69 = -.1222374623708485 : input[8] > 1.5000000000000002 ? input[8] > 950.5000000000001 ? var69 = .06946188930925638 : input[3] > 6.500000000000001 ? input[10] > 2.5000000000000004 ? input[19] > 1e-35 ? var69 = .04962819555610421 : var69 = -.07213577821855309 : var69 = .09139529824708481 : input[19] > 1e-35 ? var69 = .013439401088345224 : var69 = -.049274647207292056 : var69 = .10531673719686951;
  let var70;
  input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var70 = -.06421671152073961 : var70 = .04235421241226177 : input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var70 = -.09100102290316286 : input[0] > 3030.5000000000005 ? input[0] > 4177.500000000001 ? var70 = -.03520420769287065 : input[8] > 1085.5000000000002 ? var70 = -.019817352506127633 : var70 = .11444439424520964 : var70 = -.06854631664538167 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var70 = -.010490117519863269 : var70 = .08104430117757461 : input[121] > 1e-35 ? input[243] > 1e-35 ? var70 = .16408304891242204 : input[217] > 1e-35 ? input[0] > 4449.500000000001 ? var70 = .06619344145920268 : input[0] > 4091.5000000000005 ? var70 = -.08813353450871053 : input[0] > 3519.5000000000005 ? input[8] > 668.5000000000001 ? var70 = .10016091391222309 : var70 = -.017407607199427293 : input[8] > 501.50000000000006 ? input[10] > 16.500000000000004 ? var70 = -.019511460451434884 : var70 = -.11643672465055221 : input[2] > 18.500000000000004 ? var70 = .07848228087333317 : input[8] > 55.50000000000001 ? var70 = .032583027899956235 : var70 = -.11209832692153521 : input[11] > 1e-35 ? var70 = .027482174104412567 : input[10] > 1.5000000000000002 ? input[6] > 26.500000000000004 ? input[4] > 19.500000000000004 ? input[9] > 31.500000000000004 ? var70 = -.09996887746328006 : input[9] > 2.5000000000000004 ? var70 = .02157682011863397 : var70 = -.05247727848991843 : var70 = .07409150201483244 : input[1] > 38.50000000000001 ? var70 = -.11378466075449625 : input[224] > 1e-35 ? var70 = -.10741749127732923 : input[1] > 26.500000000000004 ? var70 = .07343136534146562 : var70 = -.07013573628594773 : input[25] > 1e-35 ? var70 = -.04626669734164317 : var70 = .05518333197956482 : var70 = .00032434010867555516;
  let var71;
  input[183] > 1e-35 ? input[10] > 1.5000000000000002 ? input[17] > 1e-35 ? var71 = .026313251010808853 : var71 = -.08997339150292381 : var71 = .025062509535227952 : input[227] > 1e-35 ? input[1] > 6.500000000000001 ? input[2] > 9.500000000000002 ? input[210] > 1e-35 ? var71 = .08071107515789745 : input[23] > 1e-35 ? input[1] > 75.50000000000001 ? var71 = .0905155504503746 : input[8] > 1049.5000000000002 ? var71 = -.062312558183394054 : input[8] > 719.5000000000001 ? var71 = .09583836191410239 : input[0] > 3719.5000000000005 ? var71 = -.0778097309430818 : var71 = .04012012419054895 : input[4] > 12.500000000000002 ? input[8] > 1496.5000000000002 ? input[10] > 42.50000000000001 ? var71 = -.12920865648544927 : input[0] > 2699.5000000000005 ? var71 = -.07086587879041864 : var71 = .022614182502461846 : input[4] > 15.500000000000002 ? input[8] > 55.50000000000001 ? input[1] > 60.50000000000001 ? input[8] > 652.5000000000001 ? var71 = -.11377786322600797 : var71 = -.009486325820117998 : input[1] > 55.50000000000001 ? var71 = .12430248795958142 : input[0] > 2952.5000000000005 ? input[0] > 4331.500000000001 ? input[1] > 38.50000000000001 ? var71 = -.07938291201004219 : input[2] > 36.50000000000001 ? var71 = .01520046732530246 : var71 = .13649854049662832 : var71 = -.07145015938528873 : input[8] > 407.50000000000006 ? var71 = -.00350257360822279 : var71 = .11332047082193297 : var71 = -.10060624458629897 : var71 = .05429496612497562 : input[8] > 1446.5000000000002 ? var71 = .006073419197482838 : var71 = -.08718676350883998 : var71 = -.11532497988252638 : var71 = .10766270463068293 : input[34] > 1e-35 ? var71 = -.06345912440611544 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var71 = -.0004109812623829506 : var71 = .021601073497455662 : var71 = -7343540098965853e-20;
  let var72;
  input[298] > 1e-35 ? input[9] > 12.500000000000002 ? input[133] > 1e-35 ? var72 = -.06107663265515864 : input[9] > 70.50000000000001 ? input[10] > 37.50000000000001 ? var72 = .05995640200798119 : input[0] > 3443.5000000000005 ? var72 = -.14698883458733583 : var72 = -.030039164579240187 : input[189] > 1e-35 ? var72 = -.06086763220538141 : input[1] > 86.50000000000001 ? var72 = -.05096727866142538 : input[4] > 64.50000000000001 ? var72 = .11240554253834577 : input[4] > 45.50000000000001 ? var72 = -.030279760168394117 : input[6] > 45.50000000000001 ? var72 = .10161088917815142 : input[10] > 77.50000000000001 ? var72 = -.0792333078055653 : input[7] > 23.500000000000004 ? input[0] > 2882.5000000000005 ? var72 = -.06672020005240323 : var72 = .08831457502630258 : input[8] > 2592.5000000000005 ? var72 = -.052617701047376654 : input[10] > 29.500000000000004 ? var72 = .08499327690298047 : input[2] > 12.500000000000002 ? input[9] > 41.50000000000001 ? var72 = .12880460816709416 : input[9] > 25.500000000000004 ? input[4] > 11.500000000000002 ? var72 = -.064099222705728 : var72 = .044332487521538365 : input[0] > 2882.5000000000005 ? var72 = .031099546885005065 : var72 = .12938467051623853 : input[0] > 4221.500000000001 ? var72 = -.0928676413498701 : input[9] > 30.500000000000004 ? var72 = -.05781824812803708 : var72 = .07561268901778094 : input[8] > 711.5000000000001 ? input[2] > 22.500000000000004 ? var72 = -.06648105454098469 : var72 = .05985487552383097 : var72 = -.13070190291919334 : input[116] > 1e-35 ? input[10] > 38.50000000000001 ? var72 = .05282385499619401 : input[1] > 66.50000000000001 ? var72 = .048802929108006314 : input[2] > 4.500000000000001 ? input[0] > 4593.500000000001 ? var72 = .027885690791379255 : var72 = -.08407126408362446 : var72 = .014432924125571093 : var72 = -9903435845205118e-20;
  let var73;
  input[76] > 1e-35 ? var73 = -.06307875292162934 : input[21] > 1e-35 ? input[7] > 10.500000000000002 ? input[10] > 4.500000000000001 ? input[8] > 944.5000000000001 ? input[0] > 3655.5000000000005 ? var73 = .013633653464240465 : var73 = -.10164319411983509 : var73 = -.1228424374328996 : input[1] > 26.500000000000004 ? input[2] > 28.500000000000004 ? var73 = .00632864847804078 : var73 = -.08393000368134668 : var73 = .07870508617440916 : input[284] > 1e-35 ? var73 = .1092302727710421 : var73 = -.0025505047582483234 : input[248] > 1e-35 ? var73 = .07101822393621864 : input[274] > 1e-35 ? var73 = -.06621099406425579 : input[1] > 26.500000000000004 ? input[1] > 28.500000000000004 ? var73 = .0003077044909372931 : input[10] > 2.5000000000000004 ? input[0] > 3770.5000000000005 ? var73 = .025081789181021243 : var73 = -.014813325803582618 : input[9] > 33.50000000000001 ? var73 = -.033466921233840194 : input[3] > 12.500000000000002 ? input[23] > 1e-35 ? var73 = .11926990418060353 : var73 = .01852125513565268 : var73 = .0975367595927343 : input[5] > 3325.5000000000005 ? input[8] > 892.5000000000001 ? input[133] > 1e-35 ? var73 = -.1178464984373743 : input[283] > 1e-35 ? var73 = .043370859226927405 : input[5] > 4320.500000000001 ? var73 = -.01103141226366587 : input[8] > 1104.5000000000002 ? var73 = -.023053423988095886 : var73 = -.0734238953804657 : input[6] > 18.500000000000004 ? input[8] > 85.50000000000001 ? var73 = .000579145585864887 : var73 = .03389152834202143 : input[128] > 1e-35 ? var73 = -.14527722052568462 : input[210] > 1e-35 ? var73 = -.08915971541902741 : input[7] > 9.500000000000002 ? var73 = -.03307314577076116 : input[18] > 1e-35 ? var73 = -.05521712302023565 : var73 = .009315605032770029 : var73 = .0036332551852289933;
  let var74;
  input[0] > 689.5000000000001 ? input[5] > 768.5000000000001 ? input[20] > 1e-35 ? input[5] > 4368.500000000001 ? var74 = -.07583539600416284 : input[188] > 1e-35 ? var74 = -.07042659515500142 : input[23] > 1e-35 ? input[0] > 3807.5000000000005 ? var74 = -.011038193049597113 : var74 = .08154028164397753 : input[1] > 85.50000000000001 ? var74 = .10259361975201933 : var74 = .011640408330521594 : var74 = -.00023319159023748508 : input[92] > 1e-35 ? var74 = .13771692859530546 : var74 = .022860029819654806 : input[1] > 22.500000000000004 ? input[1] > 24.500000000000004 ? input[2] > 96.50000000000001 ? var74 = .09967230141007705 : input[30] > 1e-35 ? var74 = -.08888529037551285 : var74 = -.008615931385397808 : input[10] > 5.500000000000001 ? input[4] > 36.50000000000001 ? var74 = .08284665960761373 : var74 = -.029292565021289504 : input[7] > 7.500000000000001 ? var74 = -.09945093355204493 : var74 = -.008381393701708593 : input[20] > 1e-35 ? var74 = -.04218678460370465 : input[10] > 6.500000000000001 ? input[9] > 2.5000000000000004 ? input[1] > 13.500000000000002 ? input[8] > 143.50000000000003 ? input[4] > 7.500000000000001 ? input[2] > 36.50000000000001 ? var74 = .07585582641438211 : input[8] > 284.50000000000006 ? var74 = -.029387993239886723 : var74 = .07716738177321587 : input[1] > 18.500000000000004 ? var74 = .026745348497993746 : var74 = .1427429617069753 : input[9] > 16.500000000000004 ? input[9] > 33.50000000000001 ? var74 = .02337306890530338 : var74 = -.10390355904767366 : var74 = .07390521199638532 : var74 = -.06788247515155237 : var74 = -.04201446383470994 : input[2] > 25.500000000000004 ? input[2] > 29.500000000000004 ? input[8] > 227.50000000000003 ? var74 = -.06360325615644084 : var74 = .04342192339836601 : var74 = -.10598779152030145 : var74 = .05253384605768211;
  let var75;
  input[3] > 7.500000000000001 ? input[157] > 1e-35 ? var75 = -.07514182877923786 : var75 = .000636205502279271 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var75 = .028692053800951845 : var75 = .14081686716133598 : var75 = -.03316566526940354 : input[186] > 1e-35 ? input[0] > 2653.5000000000005 ? var75 = .0037139292567243084 : var75 = .12662311031652707 : input[107] > 1e-35 ? input[0] > 612.5000000000001 ? var75 = .01202688580305612 : var75 = .0993509141454483 : input[203] > 1e-35 ? input[1] > 77.50000000000001 ? var75 = .043935495082738626 : var75 = -.05639305759669704 : input[247] > 1e-35 ? var75 = -.06770766046891649 : input[105] > 1e-35 ? input[19] > 1e-35 ? var75 = .10331836202616368 : var75 = .0006926658459781341 : input[96] > 1e-35 ? var75 = .05361846065599475 : input[127] > 1e-35 ? input[0] > 2723.5000000000005 ? input[1] > 54.50000000000001 ? var75 = -.0741403257305367 : var75 = .022900127535540854 : input[7] > 3.5000000000000004 ? var75 = .038110741403836294 : var75 = .14618649985842758 : input[5] > 3921.5000000000005 ? input[1] > 110.50000000000001 ? var75 = -.09552842289807008 : input[1] > 27.500000000000004 ? var75 = .012505935885798007 : var75 = -.020509603428689526 : input[282] > 1e-35 ? input[9] > 45.50000000000001 ? input[6] > 5.500000000000001 ? var75 = -.1046104767723845 : var75 = .031388606992301074 : input[8] > 114.50000000000001 ? input[9] > 17.500000000000004 ? input[9] > 22.500000000000004 ? input[1] > 32.50000000000001 ? var75 = .023466328488582572 : var75 = .11730925774586994 : var75 = -.04771965631104874 : var75 = .17059689880751394 : var75 = -.08181850955999449 : input[26] > 1e-35 ? var75 = -.12727482696678769 : var75 = -.014343123272734182;
  let var76;
  input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var76 = -.0993064321015924 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var76 = -.02763546051134888 : var76 = .06423344777499343 : var76 = -.064606430904295 : input[302] > 1e-35 ? input[10] > 2.5000000000000004 ? input[10] > 47.50000000000001 ? var76 = .049825139823021586 : input[7] > 22.500000000000004 ? var76 = -.01131680751379858 : input[0] > 2579.5000000000005 ? var76 = -.10673674485369694 : var76 = -.015387212937189957 : var76 = .04347325151148724 : input[179] > 1e-35 ? var76 = -.05788885608624092 : input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var76 = .0650355590939066 : var76 = -.0473332870892226 : var76 = -.09699315983340703 : input[288] > 1e-35 ? input[88] > 1e-35 ? var76 = .11139543329789044 : input[126] > 1e-35 ? var76 = -.09726928633696198 : input[8] > 149.50000000000003 ? input[9] > 46.50000000000001 ? input[4] > 1.5000000000000002 ? input[8] > 1861.5000000000002 ? var76 = .06370903833231022 : input[10] > 29.500000000000004 ? var76 = .03415223859607161 : input[10] > 3.5000000000000004 ? var76 = -.07415518117873297 : var76 = -.0014119203473324082 : var76 = .12617652343819508 : input[9] > 41.50000000000001 ? var76 = -.10311145857176976 : input[8] > 2757.5000000000005 ? var76 = -.08106484219011428 : input[7] > 71.50000000000001 ? var76 = -.09783384432091176 : input[1] > 88.50000000000001 ? var76 = .06249739709782831 : input[3] > 9.500000000000002 ? input[5] > 1601.5000000000002 ? var76 = -.008884084501608536 : var76 = .061339437777743616 : var76 = -.042490992675121846 : input[2] > 6.500000000000001 ? input[3] > 10.500000000000002 ? var76 = .01526664064166223 : var76 = .13534828515415498 : var76 = -.06985484465894776 : var76 = .0005758961943178744;
  let var77;
  input[86] > 1e-35 ? input[1] > 23.500000000000004 ? input[1] > 29.500000000000004 ? input[4] > 16.500000000000004 ? input[2] > 31.500000000000004 ? var77 = -.029152732370514342 : var77 = .07173628916139178 : input[1] > 36.50000000000001 ? var77 = -.08859111297255318 : var77 = .0018030071815630785 : var77 = .13652461563759322 : var77 = -.07550137680349367 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var77 = -.07145140450454163 : input[21] > 1e-35 ? var77 = -.07422841663493233 : var77 = .006289319702780104 : input[10] > 40.50000000000001 ? input[9] > 59.50000000000001 ? input[19] > 1e-35 ? input[13] > 1e-35 ? var77 = .11864240653986852 : input[3] > 33.50000000000001 ? var77 = -.08821209591953476 : var77 = .05706392280054726 : var77 = -.03600088051578915 : input[18] > 1e-35 ? input[1] > 24.500000000000004 ? var77 = .01953613016837112 : var77 = -.059781039130025006 : input[148] > 1e-35 ? var77 = .052668447861325476 : input[3] > 30.500000000000004 ? input[9] > 49.50000000000001 ? var77 = .07207826841738371 : input[202] > 1e-35 ? var77 = .08163917539410503 : var77 = -.01319846363832958 : input[9] > 35.50000000000001 ? input[5] > 4134.500000000001 ? input[10] > 44.50000000000001 ? var77 = -.06858280496900336 : var77 = -.1781828899516648 : var77 = -.04024620133969553 : input[9] > 10.500000000000002 ? input[1] > 22.500000000000004 ? input[1] > 37.50000000000001 ? var77 = .018232649414147116 : var77 = -.04419781124222661 : var77 = .05145485182416554 : input[1] > 23.500000000000004 ? input[0] > 655.5000000000001 ? input[5] > 4901.500000000001 ? input[10] > 45.50000000000001 ? var77 = .11452368095776105 : var77 = -.036496437259924026 : var77 = -.040445338739465486 : var77 = .0816572651001145 : var77 = -.08968914517368663 : var77 = .0002826343082585516;
  let var78;
  input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var78 = -.08839493050459957 : input[10] > 85.50000000000001 ? var78 = .10046908365702462 : input[8] > 2592.5000000000005 ? var78 = -.09632233975926387 : input[8] > 2000.5000000000002 ? var78 = .10282992953871627 : input[8] > 1266.5000000000002 ? input[9] > 34.50000000000001 ? var78 = .035504970430426296 : input[1] > 31.500000000000004 ? var78 = -.1133764813142531 : var78 = -.01138280942244812 : input[8] > 1125.5000000000002 ? var78 = .09800530246229806 : var78 = .016170419267589393 : input[218] > 1e-35 ? input[9] > 99.50000000000001 ? input[9] > 101.50000000000001 ? input[9] > 124.50000000000001 ? var78 = .07316772160107896 : var78 = -.059095014819051765 : var78 = .17859437315769733 : input[2] > 1.5000000000000002 ? input[9] > 86.50000000000001 ? var78 = -.09150209066166894 : input[8] > 3084.0000000000005 ? var78 = -.05443972593168094 : input[1] > 65.50000000000001 ? input[10] > 11.500000000000002 ? input[9] > 33.50000000000001 ? var78 = -.04449234460408263 : var78 = .05568837973347338 : var78 = -.12362324875024472 : input[1] > 41.50000000000001 ? input[10] > 12.500000000000002 ? input[8] > 1336.5000000000002 ? var78 = .12741077850267066 : var78 = .007372371864985329 : input[2] > 39.50000000000001 ? var78 = .02295917234617787 : var78 = .14966532083907075 : input[1] > 39.50000000000001 ? var78 = -.06685557815340279 : input[10] > 22.500000000000004 ? input[2] > 52.50000000000001 ? var78 = -.02511861881285652 : input[1] > 27.500000000000004 ? var78 = .08683660011672288 : var78 = .02956214835267301 : input[9] > 15.500000000000002 ? var78 = -.016538805462996232 : var78 = .04352738094981517 : var78 = -.05561856645643868 : input[9] > 170.50000000000003 ? var78 = -.07996752635874248 : input[179] > 1e-35 ? var78 = -.09065975936933919 : var78 = -.00042817975060427177;
  let var79;
  input[39] > 1e-35 ? input[4] > 25.500000000000004 ? var79 = .03443173196222934 : var79 = -.06554248341270724 : input[32] > 1e-35 ? input[8] > 90.50000000000001 ? input[4] > 67.50000000000001 ? input[4] > 86.50000000000001 ? var79 = -.0013415395759330318 : var79 = .12950978489563347 : input[1] > 22.500000000000004 ? input[10] > 19.500000000000004 ? input[4] > 30.500000000000004 ? input[9] > 41.50000000000001 ? var79 = .002297618040307216 : var79 = -.12522800128774994 : input[4] > 8.500000000000002 ? input[8] > 1075.5000000000002 ? var79 = -.015297257305397608 : var79 = .09651828834062742 : var79 = -.06636003334371929 : input[10] > 11.500000000000002 ? var79 = .17631616138309397 : input[0] > 1639.5000000000002 ? var79 = 3804386478092585e-20 : var79 = -.09099296398683193 : var79 = -.06874415876172972 : input[0] > 2151.5000000000005 ? var79 = -.1311264883406766 : var79 = .00809052010141122 : input[253] > 1e-35 ? var79 = -.06338558211939296 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[2] > 30.500000000000004 ? input[0] > 2151.5000000000005 ? input[10] > 10.500000000000002 ? input[0] > 3615.5000000000005 ? var79 = .045038497754638605 : var79 = -.07770167665661752 : var79 = -.08596294280650517 : var79 = .08538655727027213 : var79 = .09829076418590559 : input[1] > 39.50000000000001 ? input[9] > 1.5000000000000002 ? var79 = .054627956617973275 : input[1] > 61.50000000000001 ? var79 = -.11994465088415499 : input[4] > 8.500000000000002 ? var79 = .06676200239406452 : var79 = -.027503148069376867 : input[8] > 676.5000000000001 ? var79 = -.10363964928357075 : input[4] > 8.500000000000002 ? var79 = -.07589816227175682 : var79 = .034664436544646814 : input[1] > 159.50000000000003 ? input[6] > 25.500000000000004 ? var79 = .009093153189012338 : var79 = -.06119765876605404 : var79 = .0004668642103528348;
  let var80;
  input[223] > 1e-35 ? input[1] > 31.500000000000004 ? input[8] > 711.5000000000001 ? var80 = -.10100794502567233 : var80 = .08000205636470442 : var80 = -.11945419826856896 : input[113] > 1e-35 ? var80 = -.06105445938688056 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var80 = .1224302423880318 : var80 = -.01875566982911468 : input[222] > 1e-35 ? input[1] > 8.500000000000002 ? input[1] > 24.500000000000004 ? input[4] > 3.5000000000000004 ? input[0] > 725.5000000000001 ? input[0] > 1682.5000000000002 ? input[0] > 2860.5000000000005 ? var80 = .0019277012166729114 : input[1] > 28.500000000000004 ? var80 = -.054445821715687494 : var80 = .045645722976713245 : input[30] > 1e-35 ? var80 = .13402660155331655 : var80 = .008921176001777645 : var80 = -.058547426505451076 : var80 = .08841202222426625 : input[1] > 22.500000000000004 ? input[10] > 9.500000000000002 ? var80 = -.13526418192218206 : var80 = -.03266013432583145 : input[1] > 20.500000000000004 ? input[4] > 27.500000000000004 ? var80 = .0007263224246135398 : var80 = .12450043268647056 : input[1] > 17.500000000000004 ? input[9] > 1.5000000000000002 ? var80 = -.11575657261278308 : var80 = -.01530376565862095 : input[4] > 13.500000000000002 ? input[4] > 22.500000000000004 ? var80 = -.01995960178292952 : var80 = .11216586049153021 : var80 = -.10050961087149474 : var80 = .08848063368485726 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var80 = .10303451081526649 : var80 = -.01375730267020699 : input[1] > 28.500000000000004 ? input[2] > 20.500000000000004 ? var80 = -.043799548968209395 : var80 = -.12451444314954115 : input[4] > 12.500000000000002 ? var80 = -.03838117361958468 : var80 = .06504990789767144 : input[57] > 1e-35 ? var80 = .06890006938293915 : var80 = .0003914274695562949;
  let var81;
  input[53] > 1e-35 ? input[4] > 11.500000000000002 ? input[8] > 617.5000000000001 ? input[2] > 41.50000000000001 ? var81 = .004271749009686975 : var81 = -.10523878297127605 : var81 = .04633982158107851 : var81 = -.10349713975483057 : input[183] > 1e-35 ? input[15] > 1e-35 ? var81 = -.08655730561951676 : input[8] > 919.5000000000001 ? var81 = -.0676453705610183 : input[7] > 18.500000000000004 ? var81 = -.027787974193650575 : var81 = .08012784576991301 : input[227] > 1e-35 ? input[1] > 6.500000000000001 ? input[3] > 8.500000000000002 ? input[210] > 1e-35 ? var81 = .07185850683316512 : input[8] > 201.50000000000003 ? input[8] > 348.50000000000006 ? input[23] > 1e-35 ? input[8] > 1049.5000000000002 ? var81 = -.03473877164537313 : input[8] > 719.5000000000001 ? var81 = .10471053866934404 : var81 = .008236107678382981 : input[4] > 57.50000000000001 ? var81 = .09412219478825269 : input[10] > 66.50000000000001 ? var81 = -.13884338641811986 : input[10] > 19.500000000000004 ? input[10] > 22.500000000000004 ? input[0] > 2490.5000000000005 ? var81 = -.040681323751002293 : var81 = .06374650297561021 : var81 = .12884615227401788 : input[10] > 5.500000000000001 ? var81 = -.0887517295786972 : input[8] > 597.5000000000001 ? input[18] > 1e-35 ? var81 = -.05474068967150784 : var81 = .03744700650806603 : var81 = -.07846396348680855 : input[1] > 42.50000000000001 ? var81 = .018972315810821302 : var81 = .10953621007604744 : input[5] > 4439.500000000001 ? var81 = .010999776705494586 : input[1] > 40.50000000000001 ? var81 = -.12394200059775967 : input[10] > 2.5000000000000004 ? var81 = .013528093962849453 : var81 = -.09222088417048682 : var81 = -.12662967149701485 : var81 = .09327296405849603 : input[3] > 99.50000000000001 ? var81 = -.013581954439986752 : var81 = .0005526498251862075;
  let var82;
  input[187] > 1e-35 ? input[243] > 1e-35 ? var82 = -.08392792551692502 : input[10] > 68.50000000000001 ? var82 = .07871769409454053 : input[10] > 8.500000000000002 ? input[10] > 16.500000000000004 ? input[2] > 17.500000000000004 ? input[3] > 31.500000000000004 ? input[91] > 1e-35 ? input[10] > 21.500000000000004 ? input[10] > 33.50000000000001 ? input[10] > 48.50000000000001 ? var82 = -.0825306209711224 : var82 = .049559996084532945 : var82 = -.1064938580886302 : var82 = .03353240732240275 : var82 = .045985370399163464 : input[1] > 42.50000000000001 ? input[4] > 20.500000000000004 ? var82 = .16966001471529374 : input[1] > 57.50000000000001 ? var82 = -.005772777673676247 : var82 = .09383677041525058 : input[8] > 747.5000000000001 ? var82 = .054068175469351235 : var82 = -.049968216310277036 : input[8] > 753.5000000000001 ? var82 = -.0679383555784074 : input[4] > 8.500000000000002 ? var82 = -.059757341189735386 : var82 = .05701083682780414 : var82 = -.052497281448921164 : input[6] > 12.500000000000002 ? input[8] > 969.5000000000001 ? input[4] > 23.500000000000004 ? var82 = .05820296128730006 : var82 = -.1063042385102475 : input[1] > 49.50000000000001 ? input[8] > 302.50000000000006 ? var82 = .15340611616954566 : var82 = .04385036188666874 : input[0] > 4449.500000000001 ? var82 = -.02110897605541555 : input[1] > 24.500000000000004 ? input[2] > 17.500000000000004 ? var82 = .004840354641006495 : var82 = .09967827580276283 : var82 = .11605363537391578 : input[9] > 19.500000000000004 ? var82 = -.0735831692725717 : var82 = .019973331823355176 : input[306] > 1e-35 ? input[149] > 1e-35 ? var82 = -.08968948874343531 : input[8] > 1094.5000000000002 ? input[10] > 15.500000000000002 ? var82 = -.02442182361342386 : var82 = .10334853004243093 : var82 = -.030431948680167104 : var82 = -956078595250818e-19;
  let var83;
  input[294] > 1e-35 ? input[1] > 26.500000000000004 ? input[0] > 4078.5000000000005 ? var83 = -.040232505718244854 : input[0] > 3030.5000000000005 ? var83 = .0634109586813073 : var83 = -.04043617034245621 : var83 = -.06385323610738443 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var83 = -.007859096946435131 : var83 = .07282728486115758 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[17] > 1e-35 ? var83 = .05515771679628051 : var83 = -.04214471312668263 : var83 = -.09589322222261765 : input[193] > 1e-35 ? var83 = -.05056345906812831 : input[121] > 1e-35 ? input[243] > 1e-35 ? var83 = .14857706653119385 : input[4] > 9.500000000000002 ? input[1] > 26.500000000000004 ? input[2] > 59.50000000000001 ? var83 = -.08152604001147906 : input[11] > 1e-35 ? var83 = .09132936522356462 : input[15] > 1e-35 ? input[4] > 23.500000000000004 ? var83 = .13100930780107503 : input[10] > 25.500000000000004 ? var83 = .05921074710011526 : var83 = -.07226005736695183 : input[0] > 3304.5000000000005 ? input[0] > 3707.5000000000005 ? input[0] > 4053.5000000000005 ? var83 = .0009447118243153454 : var83 = -.09820565036865991 : var83 = .057146909749745546 : input[0] > 2115.5000000000005 ? var83 = -.12331216726611678 : var83 = .007281983677694285 : input[2] > 56.50000000000001 ? var83 = .012310154675612615 : var83 = -.08873665774670461 : input[6] > 25.500000000000004 ? var83 = .134708740821879 : input[9] > 5.500000000000001 ? var83 = -.0805901581148979 : input[224] > 1e-35 ? var83 = -.063684477784257 : input[7] > 2.5000000000000004 ? input[19] > 1e-35 ? var83 = .10842593386554122 : input[2] > 13.500000000000002 ? var83 = .06466798320378395 : var83 = -.08578130788886655 : var83 = -.03590892078300114 : var83 = .0003499894043880708;
  let var84;
  input[134] > 1e-35 ? input[6] > 50.50000000000001 ? input[0] > 3601.5000000000005 ? var84 = .10839808814624702 : var84 = -.028043875308180352 : input[7] > 30.500000000000004 ? input[8] > 932.5000000000001 ? var84 = -.007478368069393829 : var84 = -.09066751344326617 : input[0] > 3588.5000000000005 ? input[5] > 4748.500000000001 ? var84 = .04035247751736232 : input[0] > 4255.500000000001 ? var84 = -.1310865624507367 : input[0] > 4004.5000000000005 ? var84 = .06647367311982634 : var84 = -.08339693352955757 : input[4] > 10.500000000000002 ? input[1] > 34.50000000000001 ? var84 = -.011618902907510411 : var84 = .1114646660406691 : input[10] > 2.5000000000000004 ? input[0] > 3072.5000000000005 ? var84 = .09356028223727986 : var84 = -.03811765057032162 : var84 = -.09456215497345526 : input[280] > 1e-35 ? input[7] > 70.50000000000001 ? var84 = .10322956436499003 : input[2] > 22.500000000000004 ? input[1] > 83.50000000000001 ? var84 = .1146142460964847 : input[1] > 62.50000000000001 ? var84 = -.09679869865322362 : input[9] > 71.50000000000001 ? var84 = -.07377580769927583 : input[4] > 19.500000000000004 ? input[0] > 4571.500000000001 ? var84 = -.039046426387852974 : var84 = .04558778688367152 : var84 = .11220830937352602 : input[7] > 5.500000000000001 ? input[9] > 17.500000000000004 ? input[8] > 1067.5000000000002 ? var84 = .03261697816211156 : input[15] > 1e-35 ? var84 = .02586252542264368 : input[2] > 14.500000000000002 ? var84 = -.016420452667484604 : var84 = -.1011799626006976 : var84 = -.13787471318963773 : input[6] > 4.500000000000001 ? input[8] > 427.50000000000006 ? input[10] > 36.50000000000001 ? var84 = .010193588102560583 : var84 = .11748729525930773 : var84 = -.04468162226743652 : var84 = -.028365274393617957 : input[71] > 1e-35 ? var84 = .05115139346588793 : var84 = -.0001510425316936658;
  let var85;
  input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[8] > 119.50000000000001 ? input[4] > 64.50000000000001 ? var85 = .09072192054181037 : input[9] > 72.50000000000001 ? input[8] > 1094.5000000000002 ? var85 = .020637047900190317 : var85 = -.1017300802134141 : input[1] > 23.500000000000004 ? input[9] > 12.500000000000002 ? input[0] > 2815.5000000000005 ? input[0] > 3183.5000000000005 ? input[3] > 23.500000000000004 ? input[3] > 45.50000000000001 ? input[4] > 48.50000000000001 ? var85 = -.04632587527094407 : var85 = .08603684785510396 : var85 = -.05101401015448496 : var85 = .025466432054358498 : var85 = -.07897811963329214 : input[6] > 13.500000000000002 ? input[10] > 26.500000000000004 ? var85 = .020385355430046367 : var85 = .12032592051335252 : var85 = -.012387370292173013 : input[2] > 23.500000000000004 ? var85 = -.12568545484492677 : var85 = -.022261190943521976 : input[8] > 634.5000000000001 ? input[8] > 857.5000000000001 ? var85 = .043528764484784536 : var85 = .14352071657196003 : var85 = -.009332833816977268 : var85 = .11186782227735846 : var85 = -.0737365712425554 : input[136] > 1e-35 ? input[0] > 1937.5000000000002 ? var85 = -.05649104643152564 : var85 = .03884200719305747 : input[42] > 1e-35 ? var85 = -.07191700385792335 : input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[9] > 17.500000000000004 ? var85 = -.04103416502526736 : var85 = .04881823954656287 : input[4] > 15.500000000000002 ? var85 = .009342724662897898 : input[0] > 3969.5000000000005 ? var85 = -.025637309961309498 : var85 = -.12574492012987865 : input[212] > 1e-35 ? input[19] > 1e-35 ? var85 = -.08185697075265091 : input[0] > 2215.5000000000005 ? var85 = .030063975892297354 : input[0] > 807.5000000000001 ? var85 = -.03924325550733229 : var85 = .0415330999189793 : var85 = -.00024374664461674863;
  let var86;
  input[3] > 7.500000000000001 ? var86 = .0005117490419655908 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var86 = .025798416259686565 : var86 = .13251610353146012 : var86 = -.029900559552677654 : input[1] > 81.50000000000001 ? input[1] > 110.50000000000001 ? input[0] > 4242.500000000001 ? var86 = -.11098564237775424 : var86 = 25960925309712775e-21 : input[0] > 4177.500000000001 ? input[9] > 35.50000000000001 ? var86 = .15347826616466054 : input[3] > 4.500000000000001 ? var86 = .10379320730958941 : var86 = -.008896303020010654 : input[0] > 3415.5000000000005 ? input[0] > 3830.5000000000005 ? var86 = .03159791088468647 : var86 = -.10612873364104258 : var86 = .05059856107348746 : input[133] > 1e-35 ? input[2] > 5.500000000000001 ? var86 = -.02335760775001469 : var86 = -.1379386577903324 : input[1] > 62.50000000000001 ? input[3] > 2.5000000000000004 ? var86 = -.011164334474672973 : var86 = -.06594044410501655 : input[207] > 1e-35 ? var86 = -.1014214372326535 : input[8] > 3.5000000000000004 ? input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var86 = -.01725821503981916 : var86 = .05594086838700241 : input[203] > 1e-35 ? input[1] > 44.50000000000001 ? input[1] > 51.50000000000001 ? var86 = -.04226531631656534 : var86 = -.14409800530171432 : var86 = -.03245576341206398 : input[8] > 4214.500000000001 ? var86 = .0895409165534886 : input[247] > 1e-35 ? var86 = -.06506383629143335 : input[118] > 1e-35 ? var86 = -.07214270121257443 : input[8] > 546.5000000000001 ? var86 = -.004385020865473831 : var86 = .009321812545248529 : input[0] > 1639.5000000000002 ? input[13] > 1e-35 ? var86 = .046278501133958524 : var86 = -.030835570926968044 : input[0] > 493.50000000000006 ? var86 = -.12794504651610425 : var86 = .009415039807550776;
  let var87;
  input[304] > 1e-35 ? var87 = -.04717777269217453 : input[76] > 1e-35 ? var87 = -.05813439142128324 : input[1] > 59.50000000000001 ? input[0] > 350.50000000000006 ? input[53] > 1e-35 ? var87 = -.09648224457374217 : input[132] > 1e-35 ? var87 = .07089308107910267 : input[0] > 2248.5000000000005 ? input[5] > 2525.5000000000005 ? input[9] > 1.5000000000000002 ? input[114] > 1e-35 ? var87 = -.08595213071749083 : input[9] > 14.500000000000002 ? input[9] > 33.50000000000001 ? input[285] > 1e-35 ? var87 = .10838431695638147 : input[230] > 1e-35 ? var87 = .06458713915750626 : input[0] > 3219.5000000000005 ? input[3] > 23.500000000000004 ? input[9] > 69.50000000000001 ? var87 = .050071316251979 : var87 = -.006356941111525215 : input[6] > 8.500000000000002 ? var87 = -.0384814076434817 : input[1] > 73.50000000000001 ? input[0] > 3746.5000000000005 ? var87 = .10217402850540398 : var87 = -.048840949025349197 : var87 = -.03668313197909846 : input[7] > 39.50000000000001 ? var87 = -.0562642841496003 : input[10] > 2.5000000000000004 ? var87 = .09749777369987417 : var87 = -.04848223121417616 : input[0] > 5453.500000000001 ? var87 = .08316648226133942 : var87 = -.0261979698267618 : input[212] > 1e-35 ? var87 = .09565573198318654 : input[5] > 4814.500000000001 ? input[8] > 963.5000000000001 ? input[8] > 1514.5000000000002 ? var87 = .04837009746506856 : var87 = -.09184360565631328 : var87 = .0032411047845613606 : input[0] > 4733.500000000001 ? var87 = .0977378556864798 : var87 = .010776545559325588 : var87 = -.012483310473120218 : var87 = -.049284121449103935 : var87 = .011962641341789565 : input[1] > 67.50000000000001 ? input[1] > 77.50000000000001 ? var87 = -.08380361910948711 : var87 = .07375088778585813 : var87 = -.1084864186071348 : var87 = .0007819503469605476;
  let var88;
  input[7] > 17.500000000000004 ? input[115] > 1e-35 ? var88 = .08741852531696623 : input[167] > 1e-35 ? var88 = .10078975495600809 : var88 = -.0018324767784017562 : input[290] > 1e-35 ? var88 = -.0850089851255888 : input[74] > 1e-35 ? input[10] > 16.500000000000004 ? var88 = .1379733311640402 : var88 = -.0038500648529631075 : input[6] > 29.500000000000004 ? input[8] > 876.5000000000001 ? input[0] > 3129.5000000000005 ? input[9] > 5.500000000000001 ? input[8] > 1765.5000000000002 ? var88 = -.09360083033774169 : var88 = .061471353193188374 : input[10] > 11.500000000000002 ? input[10] > 31.500000000000004 ? var88 = -.015599362579530679 : input[0] > 4593.500000000001 ? var88 = -.12029549262691491 : var88 = -.018917032256501397 : var88 = .04632831686576592 : var88 = .06892347785444271 : input[4] > 8.500000000000002 ? input[10] > 33.50000000000001 ? var88 = -.05894883236412263 : var88 = .05213944998315824 : var88 = .12621779223564986 : input[243] > 1e-35 ? input[6] > 16.500000000000004 ? input[0] > 4141.500000000001 ? input[0] > 5850.500000000001 ? var88 = .07577412405680808 : var88 = -.053144737214742235 : input[1] > 29.500000000000004 ? input[9] > 16.500000000000004 ? var88 = -.0277076900736147 : input[1] > 65.50000000000001 ? var88 = -.023587471585763506 : var88 = .10184896592433082 : var88 = -.057699270527916825 : var88 = -.041191811945739454 : input[114] > 1e-35 ? input[2] > 23.500000000000004 ? var88 = .06566902102799584 : input[10] > 25.500000000000004 ? var88 = -.07033633753181047 : var88 = -.01599120398351932 : input[242] > 1e-35 ? input[0] > 2402.5000000000005 ? var88 = -.08108035861059537 : var88 = .04184690010531078 : input[35] > 1e-35 ? input[0] > 2904.5000000000005 ? var88 = -.12431182772561139 : var88 = .01886235886984271 : var88 = .0025579594894418116;
  let var89;
  input[8] > 2915.5000000000005 ? input[101] > 1e-35 ? var89 = .08648323956719083 : input[0] > 93.50000000000001 ? input[196] > 1e-35 ? var89 = -.09509320772734361 : input[4] > 1.5000000000000002 ? input[5] > 1106.5000000000002 ? input[5] > 1191.5000000000002 ? input[283] > 1e-35 ? var89 = -.11268313808648661 : input[10] > 12.500000000000002 ? input[131] > 1e-35 ? var89 = .0687641681341721 : input[10] > 102.50000000000001 ? var89 = -.09667920080214842 : input[4] > 15.500000000000002 ? input[8] > 2992.5000000000005 ? input[1] > 24.500000000000004 ? input[1] > 71.50000000000001 ? var89 = -.06762578396473291 : input[10] > 65.50000000000001 ? var89 = -.05226727783610509 : input[282] > 1e-35 ? var89 = .09911438410640917 : input[19] > 1e-35 ? var89 = .06915156336429933 : var89 = -.006565637886508241 : var89 = -.08344300251849307 : var89 = -.0928863907927501 : input[1] > 60.50000000000001 ? input[2] > 17.500000000000004 ? var89 = .19428463865406298 : var89 = .016073883020956765 : input[13] > 1e-35 ? var89 = .06864077097923665 : var89 = -.01388867527034731 : input[0] > 1847.5000000000002 ? var89 = .004655280608161356 : input[1] > 40.50000000000001 ? var89 = .031406054057765996 : var89 = .12798062439212832 : var89 = .09859670536264255 : input[10] > 2.5000000000000004 ? input[9] > 68.50000000000001 ? var89 = .08821759640665892 : input[9] > 32.50000000000001 ? input[8] > 3960.0000000000005 ? input[1] > 31.500000000000004 ? var89 = -.0706095614785733 : var89 = .04227164041372561 : var89 = -.1056906923176064 : input[2] > 8.500000000000002 ? input[19] > 1e-35 ? var89 = -.07139533369873902 : var89 = .008952586782921625 : var89 = .06086212582180936 : var89 = -.0816938490403437 : var89 = -.051224901945956025 : var89 = -.10525399124186095 : var89 = .000270924147208224;
  let var90;
  input[122] > 1e-35 ? input[0] > 2461.5000000000005 ? input[2] > 36.50000000000001 ? var90 = .029186512383291244 : input[7] > 1.5000000000000002 ? var90 = -.14984127276725573 : input[1] > 40.50000000000001 ? var90 = .032757060730648144 : var90 = -.07675575422749602 : input[6] > 8.500000000000002 ? var90 = .10599766037117893 : var90 = -.0541423394552156 : input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 61.50000000000001 ? input[17] > 1e-35 ? var90 = -.051394622947855385 : var90 = .03237141302699347 : var90 = .12526173027943244 : var90 = .000579473126472788 : input[18] > 1e-35 ? input[3] > 4.500000000000001 ? input[3] > 6.500000000000001 ? input[0] > 5453.500000000001 ? var90 = -.07383912482657777 : input[0] > 5147.500000000001 ? var90 = .07008813937042091 : input[10] > 38.50000000000001 ? var90 = -.06779203808365307 : var90 = -.013782769999524498 : var90 = .0880038869117715 : var90 = -.12846294176070952 : input[281] > 1e-35 ? var90 = -.06810806903850834 : input[10] > 227.50000000000003 ? var90 = -.08937977001661111 : input[10] > 130.50000000000003 ? var90 = .10538920632708033 : input[145] > 1e-35 ? input[4] > 6.500000000000001 ? input[9] > 16.500000000000004 ? input[4] > 18.500000000000004 ? var90 = .011036530162093841 : var90 = -.11500797478569702 : var90 = .03702229366129399 : var90 = .07242026683784307 : input[189] > 1e-35 ? var90 = .03331407112090286 : input[9] > 33.50000000000001 ? input[201] > 1e-35 ? var90 = .08979610115743614 : input[7] > 57.50000000000001 ? input[1] > 20.500000000000004 ? var90 = -.02608892716555304 : var90 = .09609599320761308 : input[9] > 105.50000000000001 ? var90 = -.06848127135991534 : var90 = .0023675721254089715 : input[86] > 1e-35 ? var90 = -.11049635625500497 : var90 = -.004847764219432233;
  let var91;
  input[125] > 1e-35 ? input[0] > 3969.5000000000005 ? var91 = -.09462233499115416 : var91 = .05235324508465096 : input[17] > 1e-35 ? input[49] > 1e-35 ? input[10] > 19.500000000000004 ? var91 = -.030700661288166148 : var91 = .0870883677166864 : input[10] > 3.5000000000000004 ? input[3] > 18.500000000000004 ? input[0] > 3544.5000000000005 ? input[188] > 1e-35 ? input[9] > 7.500000000000001 ? var91 = .03149547314036763 : var91 = -.08166208257451366 : input[0] > 5850.500000000001 ? var91 = -.10228136324773157 : input[102] > 1e-35 ? var91 = -.10572585290676295 : input[8] > 726.5000000000001 ? input[5] > 3657.5000000000005 ? var91 = .01782894842128785 : input[13] > 1e-35 ? var91 = .002680190260979968 : var91 = .1773965720476949 : input[2] > 72.50000000000001 ? var91 = .09090831938627947 : input[1] > 59.50000000000001 ? var91 = -.12297206702816128 : input[0] > 4977.500000000001 ? var91 = .09899015653118268 : var91 = -.022207141540838887 : input[4] > 32.50000000000001 ? input[1] > 34.50000000000001 ? var91 = -.0675900954187773 : var91 = .012336403425364092 : var91 = -.0017002325391924573 : input[6] > 7.500000000000001 ? input[1] > 17.500000000000004 ? var91 = -.02671721777458802 : var91 = -.09242452991958029 : input[284] > 1e-35 ? var91 = -.08585691288582491 : var91 = .013332890564324447 : input[4] > 14.500000000000002 ? var91 = -.005245022074799553 : input[23] > 1e-35 ? var91 = -.020036720167235768 : input[1] > 29.500000000000004 ? input[114] > 1e-35 ? var91 = -.09289852307936758 : input[116] > 1e-35 ? var91 = -.09686573010015055 : input[8] > 804.5000000000001 ? var91 = .03812547148215318 : var91 = .005162744968176633 : input[9] > 43.50000000000001 ? var91 = -.059246106396159376 : var91 = .050370113808135275 : var91 = .000794041852811028;
  let var92;
  input[3] > 7.500000000000001 ? var92 = .0004981426543104341 : input[9] > 114.50000000000001 ? var92 = .05666010099424601 : input[129] > 1e-35 ? input[6] > 3.5000000000000004 ? var92 = -.019061766497948867 : var92 = .07193491146561211 : input[186] > 1e-35 ? input[0] > 2653.5000000000005 ? var92 = -.006044199577160493 : var92 = .1147136801028133 : input[6] > 85.50000000000001 ? input[8] > 847.5000000000001 ? var92 = .11486607015912494 : input[9] > 16.500000000000004 ? var92 = -.08686820858087294 : var92 = .06119632492911875 : input[127] > 1e-35 ? input[0] > 2723.5000000000005 ? input[0] > 3682.5000000000005 ? input[1] > 38.50000000000001 ? var92 = -.022230207980026437 : var92 = .1056683690528792 : var92 = -.05859530800943035 : var92 = .06970608927597141 : input[7] > 3.5000000000000004 ? input[105] > 1e-35 ? var92 = .08073568184886762 : input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var92 = -.05177544573528314 : var92 = .05370469772149028 : input[1] > 35.50000000000001 ? input[0] > 4106.500000000001 ? input[9] > 46.50000000000001 ? input[0] > 4633.500000000001 ? var92 = .15159657923771555 : var92 = -.0060542654587671055 : input[9] > 5.500000000000001 ? var92 = -.042808028205051786 : input[1] > 48.50000000000001 ? var92 = -.010449538258110742 : var92 = .10026907521968294 : var92 = -.04249349329714756 : input[9] > 42.50000000000001 ? input[1] > 19.500000000000004 ? input[8] > 852.5000000000001 ? var92 = -.02272452389409874 : var92 = -.11202691218244319 : input[5] > 1809.5000000000002 ? var92 = -.04460413584255906 : var92 = .08196329474205256 : input[10] > 69.50000000000001 ? var92 = .10221481166238167 : var92 = .0004063052701699382 : input[243] > 1e-35 ? var92 = -.07563941678849846 : input[18] > 1e-35 ? var92 = .02563513231103432 : var92 = -.004740081147303786;
  let var93;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var93 = .057446442918106 : var93 = -.04404018270156349 : var93 = -.09282976714550464 : input[0] > 384.50000000000006 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var93 = -.05930486238817954 : input[1] > 29.500000000000004 ? var93 = .06955866121256543 : input[8] > 597.5000000000001 ? var93 = -.06538593556505168 : var93 = .06212512595497445 : var93 = .00021102929959182257 : input[9] > 90.50000000000001 ? var93 = .0958061289119631 : input[102] > 1e-35 ? var93 = .07172059675638813 : input[1] > 47.50000000000001 ? var93 = -.03879798603977766 : input[297] > 1e-35 ? var93 = .054948234271956144 : input[282] > 1e-35 ? input[2] > 6.500000000000001 ? var93 = .003805910996312012 : var93 = .09304295674749524 : input[11] > 1e-35 ? input[18] > 1e-35 ? var93 = .11252376801858695 : input[288] > 1e-35 ? var93 = -.10293901912180432 : var93 = .014669268837893872 : input[1] > 42.50000000000001 ? var93 = -.05988274123836837 : input[145] > 1e-35 ? var93 = .06142784665288495 : input[3] > 1.5000000000000002 ? input[4] > 4.500000000000001 ? input[1] > 21.500000000000004 ? input[1] > 27.500000000000004 ? input[9] > 24.500000000000004 ? var93 = .038791154988529926 : input[10] > 22.500000000000004 ? input[2] > 19.500000000000004 ? var93 = -.03366718308159971 : var93 = .11936550608549797 : input[1] > 31.500000000000004 ? var93 = -.07454716789539667 : var93 = .027859650621164217 : input[10] > 10.500000000000002 ? var93 = -.11806374092321247 : var93 = -.03506042229223101 : var93 = -.0007080765837654515 : input[10] > 6.500000000000001 ? var93 = -.028077713664996503 : input[2] > 7.500000000000001 ? var93 = .15803724124216814 : var93 = .0351381284833169 : var93 = -.07877953381054767;
  let var94;
  input[131] > 1e-35 ? input[282] > 1e-35 ? input[4] > 23.500000000000004 ? var94 = .14144941521975005 : var94 = .0007727806714190652 : input[9] > 1.5000000000000002 ? input[8] > 2134.5000000000005 ? input[2] > 34.50000000000001 ? var94 = .10514088112381886 : input[7] > 18.500000000000004 ? var94 = -.10370643555956745 : var94 = .04093594315421388 : input[6] > 15.500000000000002 ? input[4] > 9.500000000000002 ? input[10] > 27.500000000000004 ? input[10] > 71.50000000000001 ? var94 = -.0508129468802936 : input[224] > 1e-35 ? var94 = -.037816066368733595 : input[10] > 43.50000000000001 ? var94 = .07793408602607932 : var94 = .017646166646099453 : input[9] > 3.5000000000000004 ? input[9] > 29.500000000000004 ? input[17] > 1e-35 ? var94 = .036972453794202324 : var94 = -.08727431092411866 : input[8] > 427.50000000000006 ? input[8] > 1278.5000000000002 ? var94 = .09475302525132188 : var94 = -.03580104945898193 : var94 = .08349488283861875 : input[10] > 3.5000000000000004 ? input[0] > 1847.5000000000002 ? input[0] > 4280.500000000001 ? input[2] > 27.500000000000004 ? var94 = -.1282448778804823 : var94 = -.014395808269207212 : var94 = -.008940927190750592 : var94 = -.1459118815453748 : input[0] > 4897.500000000001 ? var94 = -.09733068457286576 : input[1] > 57.50000000000001 ? var94 = .06575271409540207 : var94 = -.019556422817450115 : var94 = -.10623959222984136 : input[18] > 1e-35 ? var94 = .11280940901275241 : input[8] > 319.50000000000006 ? input[2] > 6.500000000000001 ? var94 = .008125645893104896 : var94 = -.11084368630465868 : var94 = .0584398731508786 : input[0] > 350.50000000000006 ? input[3] > 83.50000000000001 ? var94 = -.05854904579626861 : input[4] > 5.500000000000001 ? var94 = .02985784951394175 : var94 = -.03247600140149334 : var94 = -.11152899295304973 : var94 = -.00035424577714215764;
  let var95;
  input[32] > 1e-35 ? input[17] > 1e-35 ? input[8] > 359.50000000000006 ? input[8] > 804.5000000000001 ? var95 = -.06563670567578264 : var95 = .067656954313663 : var95 = -.10388217548685377 : input[8] > 2302.5000000000005 ? var95 = .07190621943790435 : input[4] > 67.50000000000001 ? var95 = .060020507643618604 : input[4] > 38.50000000000001 ? var95 = -.08707253184321638 : input[2] > 11.500000000000002 ? input[2] > 16.500000000000004 ? input[1] > 31.500000000000004 ? input[1] > 59.50000000000001 ? var95 = -.06568134366461277 : input[8] > 1075.5000000000002 ? var95 = -.004768057709758692 : var95 = .11785959165999467 : var95 = -.05080221682879267 : var95 = .14814206127494542 : var95 = -.07241946332311736 : input[253] > 1e-35 ? var95 = -.058893562861261274 : input[4] > 61.50000000000001 ? input[283] > 1e-35 ? input[10] > 23.500000000000004 ? var95 = -.02471195342450034 : var95 = .11866056464409412 : input[10] > 44.50000000000001 ? input[1] > 16.500000000000004 ? input[8] > 2640.0000000000005 ? var95 = -.10741850739482771 : var95 = .010051635824944 : var95 = .12502069436017124 : input[8] > 1971.5000000000002 ? input[1] > 23.500000000000004 ? input[308] > 1e-35 ? var95 = .10511236013756364 : input[10] > 10.500000000000002 ? input[1] > 53.50000000000001 ? var95 = -.08992396138178163 : var95 = .010944365997007212 : var95 = .06221307021813793 : var95 = .1286024087559141 : input[127] > 1e-35 ? var95 = .06568148624531012 : input[10] > 40.50000000000001 ? var95 = -.07567979134643352 : input[5] > 5647.500000000001 ? var95 = .07594672895572069 : var95 = -.018158016446439187 : input[6] > 55.50000000000001 ? var95 = .009293422430111872 : input[4] > 45.50000000000001 ? var95 = -.017749818406964022 : input[2] > 46.50000000000001 ? var95 = .01714136511113982 : var95 = -724762291423549e-19;
  let var96;
  input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 48.50000000000001 ? input[17] > 1e-35 ? var96 = -.048689215588703864 : input[9] > 27.500000000000004 ? input[0] > 3916.5000000000005 ? var96 = .07084726276890757 : var96 = -.11232323677722932 : var96 = .04812773089510436 : var96 = .11757502216780046 : input[5] > 1464.5000000000002 ? input[5] > 1505.5000000000002 ? input[167] > 1e-35 ? var96 = .07470606002425358 : input[1] > 53.50000000000001 ? input[132] > 1e-35 ? var96 = .0879462816013881 : var96 = -.002966662093626573 : input[306] > 1e-35 ? var96 = -.04588085188342676 : var96 = .0031910005157084823 : input[3] > 10.500000000000002 ? input[10] > 20.500000000000004 ? var96 = -.006600332774461143 : var96 = .1272481351557754 : var96 = -.09030973597154808 : input[284] > 1e-35 ? input[1] > 38.50000000000001 ? input[10] > 2.5000000000000004 ? var96 = .011884312066620044 : var96 = .11678751052403374 : input[4] > 8.500000000000002 ? var96 = .03627129613273813 : var96 = -.12132783497902287 : var96 = -.006784372643244717 : input[18] > 1e-35 ? input[3] > 4.500000000000001 ? input[3] > 6.500000000000001 ? input[0] > 5453.500000000001 ? var96 = -.06830131718398992 : input[0] > 5147.500000000001 ? var96 = .062360406249609306 : input[4] > 4.500000000000001 ? var96 = -.013162203864592055 : var96 = -.07153029184927609 : var96 = .07628618062271557 : var96 = -.12085065687320373 : input[190] > 1e-35 ? var96 = -.045816889524231186 : input[137] > 1e-35 ? var96 = -.07956001795911584 : input[199] > 1e-35 ? input[0] > 3853.5000000000005 ? var96 = .025895337822752502 : var96 = -.06503949350616421 : input[10] > 227.50000000000003 ? var96 = -.09989456525790491 : input[10] > 130.50000000000003 ? var96 = .08616651057030683 : var96 = .0001234981796706021;
  let var97;
  input[8] > 1014.5000000000001 ? input[9] > 137.50000000000003 ? var97 = -.08778879924617534 : input[8] > 1022.5000000000001 ? input[285] > 1e-35 ? input[9] > 64.50000000000001 ? var97 = .04955806187281689 : input[0] > 3670.5000000000005 ? input[10] > 32.50000000000001 ? var97 = -.141732381961068 : var97 = -.0317152307496497 : var97 = -.02074638849097191 : input[0] > 93.50000000000001 ? input[0] > 3072.5000000000005 ? input[10] > 100.50000000000001 ? input[4] > 24.500000000000004 ? input[8] > 1336.5000000000002 ? var97 = .12191801556691254 : var97 = -.0003444689085397977 : var97 = .005739668504631604 : input[146] > 1e-35 ? input[308] > 1e-35 ? var97 = .015237524791728777 : input[6] > 61.50000000000001 ? input[4] > 63.50000000000001 ? var97 = -.05676033995381961 : var97 = .10933961076803381 : input[4] > 26.500000000000004 ? var97 = -.11667582544549814 : input[8] > 1765.5000000000002 ? var97 = .032174455312047705 : var97 = -.0755016390126608 : input[293] > 1e-35 ? var97 = -.08234885407658332 : input[9] > 41.50000000000001 ? input[0] > 3830.5000000000005 ? var97 = .026571311956824436 : input[15] > 1e-35 ? var97 = .06175459479851121 : var97 = -.018778084411148754 : input[9] > 40.50000000000001 ? var97 = -.09420232889965811 : var97 = -.004578248021263184 : input[2] > 1.5000000000000002 ? var97 = .005453714644971445 : var97 = -.03907138175699279 : var97 = -.055296364182154736 : input[23] > 1e-35 ? var97 = .036555134842143476 : input[0] > 4188.500000000001 ? input[6] > 29.500000000000004 ? var97 = -.09358146510580179 : var97 = .060524657996178094 : var97 = -.11245101144669545 : input[125] > 1e-35 ? input[9] > 1.5000000000000002 ? var97 = -.12698331085931538 : var97 = .006059605604079918 : input[2] > 196.50000000000003 ? var97 = -.09451315810804783 : var97 = .0011390147031687425;
  let var98;
  input[8] > 2830.5000000000005 ? input[1] > 31.500000000000004 ? input[9] > 32.50000000000001 ? input[5] > 1234.5000000000002 ? input[8] > 3794.5000000000005 ? var98 = .05517359070460923 : var98 = -.04758751221404857 : var98 = -.09482078194138792 : input[8] > 2992.5000000000005 ? input[1] > 101.50000000000001 ? var98 = .1040436595565776 : input[9] > 21.500000000000004 ? var98 = .04032250517675179 : input[107] > 1e-35 ? var98 = .05978752253058374 : input[210] > 1e-35 ? input[4] > 37.50000000000001 ? var98 = .1192453009230486 : input[1] > 51.50000000000001 ? var98 = .0443376336292195 : var98 = -.07967674833321865 : input[5] > 2117.5000000000005 ? input[9] > 10.500000000000002 ? var98 = -.10025078607591283 : input[0] > 2882.5000000000005 ? input[18] > 1e-35 ? var98 = -.08999822408398037 : var98 = .017533219253893447 : input[9] > 1.5000000000000002 ? input[4] > 12.500000000000002 ? var98 = -.061850439226075 : var98 = .08849196353361093 : var98 = .10536348167793089 : input[92] > 1e-35 ? var98 = .04894947712119185 : input[9] > 16.500000000000004 ? var98 = .05900227903883853 : input[9] > 5.500000000000001 ? var98 = -.11946594348916476 : var98 = -.03652096348071964 : input[1] > 41.50000000000001 ? var98 = -.07411603110840567 : var98 = -.00021033247574340914 : input[10] > 22.500000000000004 ? input[9] > 68.50000000000001 ? var98 = .08493634342741495 : input[11] > 1e-35 ? var98 = -.10899097825564363 : var98 = -.006156708838964173 : input[8] > 3198.5000000000005 ? input[2] > 41.50000000000001 ? var98 = .08356655906359918 : input[7] > 25.500000000000004 ? var98 = -.09475076526194888 : input[10] > 5.500000000000001 ? var98 = -.01999406228763778 : var98 = .06696212545889428 : input[6] > 20.500000000000004 ? var98 = .14713592661393468 : var98 = .0459917279002218 : var98 = .00027445928493734093;
  let var99;
  input[223] > 1e-35 ? input[1] > 31.500000000000004 ? input[8] > 634.5000000000001 ? var99 = -.06904501553217077 : var99 = .05696231672035904 : var99 = -.1124703178077813 : input[99] > 1e-35 ? input[1] > 89.50000000000001 ? var99 = -.05074261170009721 : input[1] > 57.50000000000001 ? input[8] > 969.5000000000001 ? var99 = -.011419256378538392 : input[0] > 3830.5000000000005 ? var99 = .140315841503076 : var99 = .02403434913963024 : input[1] > 31.500000000000004 ? input[8] > 65.50000000000001 ? input[2] > 10.500000000000002 ? var99 = -.04027822909411164 : var99 = .03176085103667189 : var99 = .06779515865838849 : input[4] > 15.500000000000002 ? var99 = .0762878389015175 : input[8] > 175.50000000000003 ? input[0] > 3030.5000000000005 ? input[8] > 1041.5000000000002 ? var99 = .06124039747298539 : var99 = -.04312732764434027 : var99 = .09161522761808062 : var99 = -.09663512235460074 : input[280] > 1e-35 ? input[6] > 45.50000000000001 ? input[1] > 46.50000000000001 ? var99 = .11211681010488772 : input[13] > 1e-35 ? var99 = .06725735814960367 : var99 = -.046744031455827846 : input[10] > 44.50000000000001 ? input[0] > 3400.5000000000005 ? input[0] > 4004.5000000000005 ? input[2] > 22.500000000000004 ? var99 = .11743605068905603 : var99 = -.011309033539148687 : var99 = -.07896094707523052 : var99 = .12862714793172117 : input[10] > 1.5000000000000002 ? input[8] > 455.50000000000006 ? input[0] > 4706.500000000001 ? var99 = -.09218756798869711 : input[10] > 19.500000000000004 ? input[0] > 1894.5000000000002 ? input[0] > 3719.5000000000005 ? var99 = .02836295848998302 : var99 = .12210680366745175 : var99 = -.058302317470509096 : input[5] > 4144.500000000001 ? var99 = .06123341960495106 : var99 = -.03840046906926525 : var99 = -.05221474543453495 : var99 = .03988215485860711 : var99 = -.00033074684693083496;
  let var100 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10 + var11 + var12 + var13 + var14 + var15 + var16 + var17 + var18 + var19 + var20 + var21 + var22 + var23 + var24 + var25 + var26 + var27 + var28 + var29 + var30 + var31 + var32 + var33 + var34 + var35 + var36 + var37 + var38 + var39 + var40 + var41 + var42 + var43 + var44 + var45 + var46 + var47 + var48 + var49 + var50 + var51 + var52 + var53 + var54 + var55 + var56 + var57 + var58 + var59 + var60 + var61 + var62 + var63 + var64 + var65 + var66 + var67 + var68 + var69 + var70 + var71 + var72 + var73 + var74 + var75 + var76 + var77 + var78 + var79 + var80 + var81 + var82 + var83 + var84 + var85 + var86 + var87 + var88 + var89 + var90 + var91 + var92 + var93 + var94 + var95 + var96 + var97 + var98 + var99);
  return [1 - var100, var100];
}
__name(multilineModelPredict, "multilineModelPredict");
function sigmoid(x) {
  if (x < 0) {
    let z = Math.exp(x);
    return z / (1 + z);
  }
  return 1 / (1 + Math.exp(-x));
}
__name(sigmoid, "sigmoid");
var commentMap = {
    javascript: ["//"],
    typescript: ["//"],
    typescriptreact: ["//"],
    javascriptreact: ["//"],
    vue: ["//", "-->"],
    php: ["//", "#"],
    dart: ["//"],
    go: ["//"],
    cpp: ["//"],
    scss: ["//"],
    csharp: ["//"],
    java: ["//"],
    c: ["//"],
    rust: ["//"],
    python: ["#"],
    markdown: ["#", "-->"],
    css: ["*/"]
  },
  languageMap = {
    javascript: 1,
    javascriptreact: 2,
    typescript: 3,
    typescriptreact: 4,
    python: 5,
    go: 6,
    ruby: 7
  };
function hasComment(text, lineNumber, language, ignoreEmptyLines = !0) {
  let lines = text.split(`
`);
  if (ignoreEmptyLines && (lines = lines.filter(line => line.trim().length > 0)), Math.abs(lineNumber) > lines.length || lineNumber >= lines.length) return !1;
  lineNumber < 0 && (lineNumber = lines.length + lineNumber);
  let line = lines[lineNumber];
  return (commentMap[language] ?? []).some(commentChar => line.includes(commentChar));
}
__name(hasComment, "hasComment");
var PromptFeatures = class {
    static {
      __name(this, "PromptFeatures");
    }
    constructor(promptComponentText, language) {
      let [firstLine, lastLine] = this.firstAndLast(promptComponentText),
        firstAndLastTrimEnd = this.firstAndLast(promptComponentText.trimEnd());
      this.language = language, this.length = promptComponentText.length, this.firstLineLength = firstLine.length, this.lastLineLength = lastLine.length, this.lastLineRstripLength = lastLine.trimEnd().length, this.lastLineStripLength = lastLine.trim().length, this.rstripLength = promptComponentText.trimEnd().length, this.stripLength = promptComponentText.trim().length, this.rstripLastLineLength = firstAndLastTrimEnd[1].length, this.rstripLastLineStripLength = firstAndLastTrimEnd[1].trim().length, this.secondToLastLineHasComment = hasComment(promptComponentText, -2, language), this.rstripSecondToLastLineHasComment = hasComment(promptComponentText.trimEnd(), -2, language), this.prefixEndsWithNewline = promptComponentText.endsWith(`
`), this.lastChar = promptComponentText.slice(-1), this.rstripLastChar = promptComponentText.trimEnd().slice(-1), this.firstChar = promptComponentText[0], this.lstripFirstChar = promptComponentText.trimStart().slice(0, 1);
    }
    firstAndLast(text) {
      let lines = text.split(`
`),
        numLines = lines.length,
        firstLine = lines[0],
        lastLine = lines[numLines - 1];
      return lastLine == "" && numLines > 1 && (lastLine = lines[numLines - 2]), [firstLine, lastLine];
    }
  },
  MultilineModelFeatures = class {
    static {
      __name(this, "MultilineModelFeatures");
    }
    constructor(prefix, suffix, language) {
      this.language = language, this.prefixFeatures = new PromptFeatures(prefix, language), this.suffixFeatures = new PromptFeatures(suffix, language);
    }
    constructFeatures() {
      let numFeatures = new Array(14).fill(0);
      numFeatures[0] = this.prefixFeatures.length, numFeatures[1] = this.prefixFeatures.firstLineLength, numFeatures[2] = this.prefixFeatures.lastLineLength, numFeatures[3] = this.prefixFeatures.lastLineRstripLength, numFeatures[4] = this.prefixFeatures.lastLineStripLength, numFeatures[5] = this.prefixFeatures.rstripLength, numFeatures[6] = this.prefixFeatures.rstripLastLineLength, numFeatures[7] = this.prefixFeatures.rstripLastLineStripLength, numFeatures[8] = this.suffixFeatures.length, numFeatures[9] = this.suffixFeatures.firstLineLength, numFeatures[10] = this.suffixFeatures.lastLineLength, numFeatures[11] = this.prefixFeatures.secondToLastLineHasComment ? 1 : 0, numFeatures[12] = this.prefixFeatures.rstripSecondToLastLineHasComment ? 1 : 0, numFeatures[13] = this.prefixFeatures.prefixEndsWithNewline ? 1 : 0;
      let langFeatures = new Array(Object.keys(languageMap).length + 1).fill(0);
      langFeatures[languageMap[this.language] ?? 0] = 1;
      let prefixLastCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      prefixLastCharFeatures[contextualFilterCharacterMap[this.prefixFeatures.lastChar] ?? 0] = 1;
      let prefixRstripLastCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      prefixRstripLastCharFeatures[contextualFilterCharacterMap[this.prefixFeatures.rstripLastChar] ?? 0] = 1;
      let suffixFirstCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      suffixFirstCharFeatures[contextualFilterCharacterMap[this.suffixFeatures.firstChar] ?? 0] = 1;
      let suffixLstripFirstCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      return suffixLstripFirstCharFeatures[contextualFilterCharacterMap[this.suffixFeatures.lstripFirstChar] ?? 0] = 1, numFeatures.concat(langFeatures, prefixLastCharFeatures, prefixRstripLastCharFeatures, suffixFirstCharFeatures, suffixLstripFirstCharFeatures);
    }
  };
function constructMultilineFeatures(prompt, language) {
  return new MultilineModelFeatures(prompt.prefix, prompt.suffix, language);
}
__name(constructMultilineFeatures, "constructMultilineFeatures");
function requestMultilineScore(prompt, language) {
  let features = constructMultilineFeatures(prompt, language).constructFeatures();
  return multilineModelPredict(features)[1];
}
__name(requestMultilineScore, "requestMultilineScore");
var ghostTextLogger = new Logger(1, "ghostText");
var lastPrefix, lastSuffix, lastPromptHash;
async function genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, what, processChoices) {
  ghostTextLogger.debug(ctx, `Getting ${what} from network`), baseTelemetryData = baseTelemetryData.extendedBy();
  let numGhostCompletions = await getNumGhostCompletions(ctx, requestContext),
    temperature = getTemperatureForSamples(ctx, numGhostCompletions),
    postOptions = {
      stream: !0,
      n: numGhostCompletions,
      temperature: temperature,
      extra: {
        language: requestContext.languageId,
        next_indent: requestContext.indentation.next ?? 0,
        trim_by_indentation: shouldDoServerTrimming(requestContext.blockMode),
        prompt_tokens: requestContext.prompt.prefixTokens ?? 0,
        suffix_tokens: requestContext.prompt.suffixTokens ?? 0
      }
    };
  requestContext.multiline || (postOptions.stop = [`
`]), requestContext.multiline && requestContext.multiLogitBias && (postOptions.logit_bias = {
    50256: -100
  });
  let requestStart = Date.now(),
    newProperties = {
      endpoint: "completions",
      uiKind: "ghostText",
      isCycling: JSON.stringify(requestContext.isCycling),
      temperature: JSON.stringify(temperature),
      n: JSON.stringify(numGhostCompletions),
      stop: JSON.stringify(postOptions.stop) ?? "unset",
      logit_bias: JSON.stringify(postOptions.logit_bias ?? null)
    },
    newMeasurements = telemetrizePromptLength(requestContext.prompt);
  Object.assign(baseTelemetryData.properties, newProperties), Object.assign(baseTelemetryData.measurements, newMeasurements);
  try {
    let completionParams = {
      prompt: requestContext.prompt,
      languageId: requestContext.languageId,
      repoInfo: requestContext.repoInfo,
      ourRequestId: requestContext.ourRequestId,
      engineUrl: requestContext.engineURL,
      count: numGhostCompletions,
      uiKind: "ghostText",
      postOptions: postOptions
    };
    requestContext.delayMs > 0 && (await new Promise(resolve => setTimeout(resolve, requestContext.delayMs)));
    let res = await ctx.get(OpenAIFetcher).fetchAndStreamCompletions(ctx, completionParams, baseTelemetryData, finishedCb, cancellationToken);
    return res.type === "failed" ? {
      type: "failed",
      reason: res.reason,
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    } : res.type === "canceled" ? (ghostTextLogger.debug(ctx, "Cancelled after awaiting fetchCompletions"), {
      type: "canceled",
      reason: res.reason,
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
    }) : processChoices(numGhostCompletions, requestStart, res.getProcessingTime(), res.choices);
  } catch (err) {
    if (isAbortError(err)) return {
      type: "canceled",
      reason: "network request aborted",
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData, {
        cancelledNetworkRequest: !0
      })
    };
    if (ghostTextLogger.exception(ctx, err, "Error on ghost text request"), ctx.get(UserErrorNotifier).notifyUser(ctx, err), shouldFailForDebugPurposes(ctx)) throw err;
    return {
      type: "failed",
      reason: "non-abort error on ghost text request",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
  }
}
__name(genericGetCompletionsFromNetwork, "genericGetCompletionsFromNetwork");
async function getCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb) {
  return genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, "completions", async (numGhostCompletions, requestStart, processingTime, choicesStream) => {
    let choicesIterator = choicesStream[Symbol.asyncIterator](),
      firstRes = await choicesIterator.next();
    if (firstRes.done) return ghostTextLogger.debug(ctx, "All choices redacted"), {
      type: "empty",
      reason: "all choices redacted",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
    if (cancellationToken?.isCancellationRequested) return ghostTextLogger.debug(ctx, "Cancelled after awaiting redactedChoices iterator"), {
      type: "canceled",
      reason: "after awaiting redactedChoices iterator",
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
    };
    let firstChoice = firstRes.value;
    if (firstChoice === void 0) return ghostTextLogger.debug(ctx, "Got undefined choice from redactedChoices iterator"), {
      type: "empty",
      reason: "got undefined choice from redactedChoices iterator",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
    telemetryPerformance(ctx, "performance", firstChoice, requestStart, processingTime);
    let remainingChoices = numGhostCompletions - 1;
    ghostTextLogger.debug(ctx, `Awaited first result, id:  ${firstChoice.choiceIndex}`), addToCache(ctx, requestContext, {
      multiline: requestContext.multiline,
      choices: [firstChoice]
    });
    let remainingPromise = [];
    for (let index = 0; index < remainingChoices; index++) remainingPromise.push(choicesIterator.next());
    let cacheDone = Promise.all(remainingPromise).then(async results => {
      (await ctx.get(Features).fastCancellation()) && choicesIterator.next(), ghostTextLogger.debug(ctx, `Awaited remaining results, number of results: ${results.length}`);
      let apiChoices = [];
      for (let innerChoice of results) {
        let redactedChoice = innerChoice.value;
        if (redactedChoice !== void 0 && (ghostTextLogger.info(ctx, `GhostText later completion: [${redactedChoice.completionText}]`), redactedChoice.completionText.trimEnd())) {
          if (apiChoices.findIndex(v => v.completionText.trim() === redactedChoice.completionText.trim()) !== -1 || redactedChoice.completionText.trim() === firstChoice.completionText.trim()) continue;
          apiChoices.push(redactedChoice);
        }
      }
      apiChoices.length > 0 && appendToCache(ctx, requestContext, {
        multiline: requestContext.multiline,
        choices: apiChoices
      });
    });
    return isRunningInTest(ctx) && (await cacheDone), {
      type: "success",
      value: makeGhostAPIChoice(firstRes.value, {
        forceSingleLine: !1
      }),
      telemetryData: mkBasicResultTelemetry(baseTelemetryData),
      telemetryBlob: baseTelemetryData
    };
  });
}
__name(getCompletionsFromNetwork, "getCompletionsFromNetwork");
async function getAllCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb) {
  return genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, "all completions", async (numGhostCompletions, requestStart, processingTime, choicesStream) => {
    let apiChoices = [];
    for await (let choice of choicesStream) {
      if (cancellationToken?.isCancellationRequested) return ghostTextLogger.debug(ctx, "Cancelled after awaiting choices iterator"), {
        type: "canceled",
        reason: "after awaiting choices iterator",
        telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
      };
      if (choice.completionText.trimEnd()) {
        if (apiChoices.findIndex(v => v.completionText.trim() === choice.completionText.trim()) !== -1) continue;
        apiChoices.push(choice);
      }
    }
    return apiChoices.length > 0 && (appendToCache(ctx, requestContext, {
      multiline: requestContext.multiline,
      choices: apiChoices
    }), telemetryPerformance(ctx, "cyclingPerformance", apiChoices[0], requestStart, processingTime)), {
      type: "success",
      value: apiChoices,
      telemetryData: mkBasicResultTelemetry(baseTelemetryData),
      telemetryBlob: baseTelemetryData
    };
  });
}
__name(getAllCompletionsFromNetwork, "getAllCompletionsFromNetwork");
function makeGhostAPIChoice(choice, options) {
  let ghostChoice = {
    ...choice
  };
  return ghostChoice.completionText = choice.completionText.trimEnd(), options.forceSingleLine && (ghostChoice.completionText = ghostChoice.completionText.split(`
`)[0]), ghostChoice;
}
__name(makeGhostAPIChoice, "makeGhostAPIChoice");
async function getNumGhostCompletions(ctx, requestContext) {
  let override = await ctx.get(Features).overrideNumGhostCompletions();
  return override ? requestContext.isCycling ? Math.max(0, 3 - override) : override : shouldDoParsingTrimming(requestContext.blockMode) && requestContext.multiline ? getConfig(ctx, ConfigKey.InlineSuggestCount) : requestContext.isCycling ? 2 : 1;
}
__name(getNumGhostCompletions, "getNumGhostCompletions");
async function getGhostTextStrategy(ctx, document, position, prompt, isCycling, inlineSuggestion, preIssuedTelemetryData, requestMultilineExploration = !1, requestMultilineOnNewLine = !0, requestMultiModel = !0, requestMultiModelThreshold = .5) {
  let blockMode = await ctx.get(BlockModeConfig).forLanguage(ctx, document.languageId);
  switch (blockMode) {
    case "server":
      return {
        blockMode: "server",
        requestMultiline: !0,
        isCyclingRequest: isCycling,
        finishedCb: async text => {}
      };
    case "parsing":
    case "parsingandserver":
    default:
      {
        if (await shouldRequestMultiline(ctx, document, position, inlineSuggestion, preIssuedTelemetryData, prompt, requestMultilineExploration, requestMultilineOnNewLine, requestMultiModel, requestMultiModelThreshold)) {
          let adjustedPosition;
          return prompt.trailingWs.length > 0 && !prompt.prompt.prefix.endsWith(prompt.trailingWs) ? adjustedPosition = ctx.get(LocationFactory).position(position.line, Math.max(position.character - prompt.trailingWs.length, 0)) : adjustedPosition = position, {
            blockMode: blockMode,
            requestMultiline: !0,
            isCyclingRequest: !1,
            finishedCb: parsingBlockFinished(ctx, document, adjustedPosition)
          };
        }
        return {
          blockMode: blockMode,
          requestMultiline: !1,
          isCyclingRequest: isCycling,
          finishedCb: async text => {}
        };
      }
  }
}
__name(getGhostTextStrategy, "getGhostTextStrategy");
var ghostTextDebouncer = new Debouncer();
async function getGhostText(ctx, document, position, isCycling, preIssuedTelemetryData, cancellationToken) {
  let ourRequestId = v4_default();
  preIssuedTelemetryData = preIssuedTelemetryData.extendedBy({
    headerRequestId: ourRequestId
  });
  let documentSource = document.getText(),
    positionOffset = document.offsetAt(position),
    actualSuffix = documentSource.substring(positionOffset),
    prompt = await extractPrompt(ctx, document, position, preIssuedTelemetryData);
  if (prompt.type === "copilotNotAvailable") return ghostTextLogger.debug(ctx, "Copilot not available, due to content exclusion"), {
    type: "abortedBeforeIssued",
    reason: "Copilot not available due to content exclusion"
  };
  if (prompt.type === "contextTooShort") return ghostTextLogger.debug(ctx, "Breaking, not enough context"), {
    type: "abortedBeforeIssued",
    reason: "Not enough context"
  };
  if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after extractPrompt"), {
    type: "abortedBeforeIssued",
    reason: "Cancelled after extractPrompt"
  };
  let inlineSuggestion = isInlineSuggestion(document, position);
  if (inlineSuggestion === void 0) return ghostTextLogger.debug(ctx, "Breaking, invalid middle of the line"), {
    type: "abortedBeforeIssued",
    reason: "Invalid middle of the line"
  };
  let statusBarItem = ctx.get(StatusReporter),
    locationFactory = ctx.get(LocationFactory),
    repoInfo = extractRepoInfoInBackground(ctx, document.uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    dogFood = getDogFood(repoInfo),
    userKind = await getUserKind(ctx),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: document.languageId,
      customModel: customModel,
      retrievalOrg: retrievalOrg
    },
    ghostTextStrategy = await getGhostTextStrategy(ctx, document, position, prompt, isCycling, inlineSuggestion, preIssuedTelemetryData);
  if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after requestMultiline"), {
    type: "abortedBeforeIssued",
    reason: "Cancelled after requestMultiline"
  };
  let [prefix] = trimLastLine(document.getText(locationFactory.range(locationFactory.position(0, 0), position))),
    choices = getLocalInlineSuggestion(ctx, prefix, prompt.prompt, ghostTextStrategy.requestMultiline),
    engineURL = await getEngineURL(ctx, repoNwo, document.languageId, dogFood, userKind, customModel, retrievalOrg, preIssuedTelemetryData),
    delayMs = await ctx.get(Features).beforeRequestWaitMs(featuresFilterArgs, preIssuedTelemetryData),
    multiLogitBias = await ctx.get(Features).multiLogitBias(featuresFilterArgs, preIssuedTelemetryData),
    requestContext = {
      blockMode: ghostTextStrategy.blockMode,
      languageId: document.languageId,
      repoInfo: repoInfo,
      engineURL: engineURL,
      ourRequestId: ourRequestId,
      prefix: prefix,
      prompt: prompt.prompt,
      multiline: ghostTextStrategy.requestMultiline,
      indentation: contextIndentation(document, position),
      isCycling: isCycling,
      delayMs: delayMs,
      multiLogitBias: multiLogitBias
    },
    debouncePredict = await ctx.get(Features).debouncePredict(),
    contextualFilterEnable = await ctx.get(Features).contextualFilterEnable(),
    contextualFilterAcceptThreshold = await ctx.get(Features).contextualFilterAcceptThreshold(),
    contextualFilterEnableTree = await ctx.get(Features).contextualFilterEnableTree(),
    contextualFilterExplorationTraffic = await ctx.get(Features).contextualFilterExplorationTraffic(),
    computeContextualFilterScore = !1;
  (debouncePredict || contextualFilterEnable) && (computeContextualFilterScore = !0);
  let detectedLanguage = await ctx.get(LanguageDetection).detectLanguage(document),
    telemetryData = telemetryIssued(ctx, document, detectedLanguage, requestContext, position, prompt, preIssuedTelemetryData, computeContextualFilterScore, contextualFilterEnableTree);
  if (ghostTextStrategy.isCyclingRequest && (choices?.[0].length ?? 0) > 1 || !ghostTextStrategy.isCyclingRequest && choices !== void 0) ghostTextLogger.info(ctx, "Found inline suggestions locally");else {
    if (statusBarItem?.setProgress(), ghostTextStrategy.isCyclingRequest) {
      let networkChoices = await getAllCompletionsFromNetwork(ctx, requestContext, telemetryData, cancellationToken, ghostTextStrategy.finishedCb);
      if (networkChoices.type === "success") {
        let resultChoices = choices?.[0] ?? [];
        networkChoices.value.forEach(c => {
          resultChoices.findIndex(v => v.completionText.trim() === c.completionText.trim()) === -1 && resultChoices.push(c);
        }), choices = [resultChoices, 3];
      } else if (choices === void 0) return statusBarItem?.removeProgress(), networkChoices;
    } else {
      let debounceLimit = await getDebounceLimit(ctx, telemetryData);
      try {
        await ghostTextDebouncer.debounce(debounceLimit);
      } catch {
        return {
          type: "canceled",
          reason: "by debouncer",
          telemetryData: mkCanceledResultTelemetry(telemetryData)
        };
      }
      if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled during debounce"), {
        type: "canceled",
        reason: "during debounce",
        telemetryData: mkCanceledResultTelemetry(telemetryData)
      };
      if (contextualFilterEnable && telemetryData.measurements.contextualFilterScore && telemetryData.measurements.contextualFilterScore < contextualFilterAcceptThreshold / 100 && Math.random() < 1 - contextualFilterExplorationTraffic / 100) return ghostTextLogger.info(ctx, "Cancelled by contextual filter"), {
        type: "canceled",
        reason: "contextualFilterScore below threshold",
        telemetryData: mkCanceledResultTelemetry(telemetryData)
      };
      let c = await getCompletionsFromNetwork(ctx, requestContext, telemetryData, cancellationToken, ghostTextStrategy.finishedCb);
      if (c.type !== "success") return statusBarItem?.removeProgress(), c;
      choices = [[c.value], 0];
    }
    statusBarItem?.removeProgress();
  }
  if (choices === void 0) return {
    type: "failed",
    reason: "internal error: choices should be defined after network call",
    telemetryData: mkBasicResultTelemetry(telemetryData)
  };
  let [choicesArray, resultType] = choices,
    postProcessedChoices = asyncIterableMapFilter(asyncIterableFromArray(choicesArray), async choice => postProcessChoice(ctx, "ghostText", document, position, choice, inlineSuggestion, ghostTextLogger, prompt.prompt, actualSuffix)),
    results = [];
  for await (let choice of postProcessedChoices) {
    let hasSuffix = inlineSuggestion && checkSuffix(document, position, choice);
    if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after post processing completions"), {
      type: "canceled",
      reason: "after post processing completions",
      telemetryData: mkCanceledResultTelemetry(telemetryData)
    };
    let choiceTelemetryData = telemetryWithAddData(ctx, choice),
      res = {
        completion: adjustLeadingWhitespace(choice.choiceIndex, choice.completionText, prompt.trailingWs),
        telemetry: choiceTelemetryData,
        isMiddleOfTheLine: inlineSuggestion,
        coversSuffix: hasSuffix
      };
    results.push(res);
  }
  return {
    type: "success",
    value: [results, resultType],
    telemetryData: mkBasicResultTelemetry(telemetryData),
    telemetryBlob: telemetryData
  };
}
__name(getGhostText, "getGhostText");
function getLocalInlineSuggestion(ctx, prefix, prompt, requestMultiline) {
  let choicesTyping = getCompletionsForUserTyping(ctx, prefix, prompt, requestMultiline);
  if (choicesTyping && choicesTyping.length > 0) return [choicesTyping, 2];
  let choicesCache = getCompletionsFromCache(ctx, prefix, prompt, requestMultiline);
  if (choicesCache && choicesCache.length > 0) return [choicesCache, 1];
}
__name(getLocalInlineSuggestion, "getLocalInlineSuggestion");
function isInlineSuggestion(document, position) {
  let isMiddleOfLine = isMiddleOfTheLine(position, document),
    isValidMiddleOfLine = isValidMiddleOfTheLinePosition(position, document);
  return isMiddleOfLine && !isValidMiddleOfLine ? void 0 : isMiddleOfLine && isValidMiddleOfLine;
}
__name(isInlineSuggestion, "isInlineSuggestion");
function isMiddleOfTheLine(selectionPosition, doc) {
  return doc.lineAt(selectionPosition).text.substr(selectionPosition.character).trim().length != 0;
}
__name(isMiddleOfTheLine, "isMiddleOfTheLine");
function isValidMiddleOfTheLinePosition(selectionPosition, doc) {
  let endOfLine = doc.lineAt(selectionPosition).text.substr(selectionPosition.character).trim();
  return /^\s*[)}\]"'`]*\s*[:{;,]?\s*$/.test(endOfLine);
}
__name(isValidMiddleOfTheLinePosition, "isValidMiddleOfTheLinePosition");
function isNewLine(selectionPosition, doc) {
  return doc.lineAt(selectionPosition).text.trim().length === 0;
}
__name(isNewLine, "isNewLine");
function exploreMultilineRandom() {
  return Math.random() > .5;
}
__name(exploreMultilineRandom, "exploreMultilineRandom");
var ForceMultiLine = class _ForceMultiLine {
  constructor(requestMultilineOverride = !1) {
    this.requestMultilineOverride = requestMultilineOverride;
  }
  static {
    __name(this, "ForceMultiLine");
  }
  static {
    this.default = new _ForceMultiLine();
  }
};
async function requestMultilineExperiment(requestMultilineExploration, requestMultiModel, requestMultiModelThreshold, document, prompt, preIssuedTelemetryData) {
  let requestMultiline = !1;
  return requestMultilineExploration ? requestMultiline = exploreMultilineRandom() : requestMultiModel && ["javascript", "javascriptreact", "python"].includes(document.languageId) && (requestMultiline = requestMultilineScore(prompt.prompt, document.languageId) > requestMultiModelThreshold), requestMultiline;
}
__name(requestMultilineExperiment, "requestMultilineExperiment");
async function shouldRequestMultiline(ctx, document, position, inlineSuggestion, preIssuedTelemetryData, prompt, requestMultilineExploration, requestMultilineOnNewLine, requestMultiModel, requestMultiModelThreshold) {
  if (ctx.get(ForceMultiLine).requestMultilineOverride) return !0;
  if (requestMultilineExploration) {
    let isEmptyBlockStartDocumentPosition = await isEmptyBlockStart(document, position),
      isEmptyBlockStartDocumentPositionRangeEnd = await isEmptyBlockStart(document, document.lineAt(position).range.end);
    preIssuedTelemetryData.properties.isEmptyBlockStartDocumentPosition = isEmptyBlockStartDocumentPosition.toString(), preIssuedTelemetryData.properties.isEmptyBlockStartDocumentPositionRangeEnd = isEmptyBlockStartDocumentPositionRangeEnd.toString(), preIssuedTelemetryData.properties.inlineSuggestion = inlineSuggestion.toString(), preIssuedTelemetryData.measurements.documentLineCount = document.lineCount, preIssuedTelemetryData.measurements.positionLine = position.line;
  }
  if (document.lineCount >= 8e3) telemetry(ctx, "ghostText.longFileMultilineSkip", TelemetryData.createAndMarkAsIssued({
    languageId: document.languageId,
    lineCount: String(document.lineCount),
    currentLine: String(position.line)
  }));else {
    if (requestMultilineOnNewLine && ["typescript", "typescriptreact"].includes(document.languageId) && isNewLine(position, document)) return !0;
    let requestMultiline = !1;
    return !inlineSuggestion && (0, qL.isSupportedLanguageId)(document.languageId) ? requestMultiline = await isEmptyBlockStart(document, position) : inlineSuggestion && (0, qL.isSupportedLanguageId)(document.languageId) && (requestMultiline = (await isEmptyBlockStart(document, position)) || (await isEmptyBlockStart(document, document.lineAt(position).range.end))), requestMultiline || (requestMultiline = await requestMultilineExperiment(requestMultilineExploration, requestMultiModel, requestMultiModelThreshold, document, prompt, preIssuedTelemetryData)), requestMultiline;
  }
  return !1;
}
__name(shouldRequestMultiline, "shouldRequestMultiline");
function recordLastSuccessfulCompletionContext(prefix, suffix, promptHash) {
  lastPrefix = prefix, lastSuffix = suffix, lastPromptHash = promptHash;
}
__name(recordLastSuccessfulCompletionContext, "recordLastSuccessfulCompletionContext");
function addToCache(ctx, requestContext, contents) {
  let promptHash = keyForPrompt(requestContext.prompt);
  recordLastSuccessfulCompletionContext(requestContext.prefix, requestContext.prompt.suffix, promptHash), ctx.get(CompletionsCache).set(promptHash, contents), ghostTextLogger.debug(ctx, `Cached ghost text for key: ${promptHash}, multiline: ${contents.multiline}, number of suggestions: ${contents.choices.length}`);
}
__name(addToCache, "addToCache");
function appendToCache(ctx, requestContext, newContents) {
  let promptHash = keyForPrompt(requestContext.prompt),
    existing = ctx.get(CompletionsCache).get(promptHash);
  existing && existing.multiline === newContents.multiline ? ctx.get(CompletionsCache).set(promptHash, {
    multiline: existing.multiline,
    choices: existing.choices.concat(newContents.choices)
  }) : ctx.get(CompletionsCache).set(promptHash, newContents), ghostTextLogger.debug(ctx, `Appended cached ghost text for key: ${promptHash}, multiline: ${newContents.multiline}, number of suggestions: ${newContents.choices.length}`);
}
__name(appendToCache, "appendToCache");
function getCachedChoices(ctx, promptHash, multiline) {
  let contents = ctx.get(CompletionsCache).get(promptHash);
  if (contents && !(multiline && !contents.multiline)) return contents.choices;
}
__name(getCachedChoices, "getCachedChoices");
function adjustLeadingWhitespace(index, text, ws) {
  if (ws.length > 0) {
    if (text.startsWith(ws)) return {
      completionIndex: index,
      completionText: text,
      displayText: text.substr(ws.length),
      displayNeedsWsOffset: !1
    };
    {
      let textLeftWs = text.substr(0, text.length - text.trimLeft().length);
      return ws.startsWith(textLeftWs) ? {
        completionIndex: index,
        completionText: text,
        displayText: text.trimLeft(),
        displayNeedsWsOffset: !0
      } : {
        completionIndex: index,
        completionText: text,
        displayText: text,
        displayNeedsWsOffset: !1
      };
    }
  } else return {
    completionIndex: index,
    completionText: text,
    displayText: text,
    displayNeedsWsOffset: !1
  };
}
__name(adjustLeadingWhitespace, "adjustLeadingWhitespace");
function getCompletionsForUserTyping(ctx, prefix, prompt, multiline) {
  let prefixMatches = lastPrefix ? prefix.startsWith(lastPrefix) : !1,
    suffixMatches = lastSuffix != null ? prompt.suffix == lastSuffix : !1;
  if (!lastPrefix || !lastPromptHash || !prefixMatches || !suffixMatches) return;
  let lastCachedCompletion = getCachedChoices(ctx, lastPromptHash, multiline);
  if (!lastCachedCompletion) return;
  let remainingPrefix = prefix.substring(lastPrefix.length);
  ghostTextLogger.debug(ctx, `Getting completions for user-typing flow - remaining prefix: ${remainingPrefix}`);
  let completionsToReturn = [];
  return lastCachedCompletion.forEach(element => {
    let completionToReturn = makeGhostAPIChoice(element, {
      forceSingleLine: !1
    });
    completionToReturn.completionText.startsWith(remainingPrefix) && (completionToReturn.completionText = completionToReturn.completionText.substring(remainingPrefix.length), completionsToReturn.push(completionToReturn));
  }), completionsToReturn;
}
__name(getCompletionsForUserTyping, "getCompletionsForUserTyping");
function clearUserTypingState() {
  lastPrefix = void 0, lastSuffix = void 0, lastPromptHash = void 0;
}
__name(clearUserTypingState, "clearUserTypingState");
function getCompletionsFromCache(ctx, prefix, prompt, multiline) {
  let promptHash = keyForPrompt(prompt);
  ghostTextLogger.debug(ctx, `Trying to get completions from cache for key: ${promptHash}`);
  let cachedChoice = getCachedChoices(ctx, promptHash, multiline);
  if (cachedChoice) {
    ghostTextLogger.debug(ctx, `Got completions from cache for key: ${promptHash}`);
    let completionsToReturn = [];
    cachedChoice.forEach(element => {
      let completionToReturn = makeGhostAPIChoice(element, {
        forceSingleLine: !multiline
      });
      completionsToReturn.push(completionToReturn);
    });
    let result = completionsToReturn.filter(e => e.completionText);
    return result.length > 0 && recordLastSuccessfulCompletionContext(prefix, prompt.suffix, promptHash), result;
  }
}
__name(getCompletionsFromCache, "getCompletionsFromCache");
function telemetryWithAddData(ctx, choice) {
  let requestId = choice.requestId,
    properties = {
      choiceIndex: choice.choiceIndex.toString()
    },
    measurements = {
      numTokens: choice.numTokens,
      compCharLen: choice.completionText.length,
      numLines: choice.completionText.split(`
`).length
    };
  choice.meanLogProb && (measurements.meanLogProb = choice.meanLogProb), choice.meanAlternativeLogProb && (measurements.meanAlternativeLogProb = choice.meanAlternativeLogProb);
  let extendedTelemetry = choice.telemetryData.extendedBy(properties, measurements);
  return extendedTelemetry.extendWithRequestId(requestId), extendedTelemetry.measurements.confidence = ghostTextScoreConfidence(ctx, extendedTelemetry), extendedTelemetry.measurements.quantile = ghostTextScoreQuantile(ctx, extendedTelemetry), ghostTextLogger.debug(ctx, `Extended telemetry for ${choice.telemetryData.properties.headerRequestId} with retention confidence ${extendedTelemetry.measurements.confidence} (expected as good or better than about ${extendedTelemetry.measurements.quantile} of all suggestions)`), extendedTelemetry;
}
__name(telemetryWithAddData, "telemetryWithAddData");
function telemetryIssued(ctx, document, detectedLanguage, requestContext, position, prompt, baseTelemetryData, computeContextualFilterScore, contextualFilterEnableTree) {
  let locationFactory = ctx.get(LocationFactory),
    currentLine = document.lineAt(position.line),
    lineBeforeCursor = document.getText(locationFactory.range(currentLine.range.start, position)),
    restOfLine = document.getText(locationFactory.range(position, currentLine.range.end)),
    properties = {
      languageId: document.languageId,
      beforeCursorWhitespace: JSON.stringify(lineBeforeCursor.trim() === ""),
      afterCursorWhitespace: JSON.stringify(restOfLine.trim() === "")
    };
  document.languageId !== detectedLanguage.languageId && (properties.detectedLanguageId = detectedLanguage.languageId, properties.fileExtension = detectedLanguage.fileExtension);
  let measurements = {
      ...telemetrizePromptLength(prompt.prompt),
      promptEndPos: document.offsetAt(position),
      documentLength: document.getText().length,
      delayMs: requestContext.delayMs
    },
    telemetryData = baseTelemetryData.extendedBy(properties, measurements);
  telemetryData.properties.promptChoices = JSON.stringify(prompt.promptChoices, (key, value) => value instanceof Map ? Array.from(value.entries()).reduce((acc, [k, v]) => ({
    ...acc,
    [k]: v
  }), {}) : value), telemetryData.properties.promptBackground = JSON.stringify(prompt.promptBackground, (key, value) => value instanceof Map ? Array.from(value.values()) : value);
  let typeFileHashCode = Array.from(prompt.neighborSource.entries()).map(typeFiles => [typeFiles[0], typeFiles[1].map(f => (0, vie.SHA256)(f).toString())]);
  telemetryData.properties.neighborSource = JSON.stringify(typeFileHashCode), telemetryData.measurements.promptComputeTimeMs = prompt.computeTimeMs, computeContextualFilterScore && (telemetryData.measurements.contextualFilterScore = contextualFilterScore(ctx, telemetryData, prompt.prompt, contextualFilterEnableTree));
  let repoInfo = requestContext.repoInfo;
  return telemetryData.properties.gitRepoInformation = repoInfo === void 0 ? "unavailable" : repoInfo === 0 ? "pending" : "available", repoInfo !== void 0 && repoInfo !== 0 && (telemetryData.properties.gitRepoUrl = repoInfo.url, telemetryData.properties.gitRepoHost = repoInfo.hostname, telemetryData.properties.gitRepoOwner = repoInfo.owner, telemetryData.properties.gitRepoName = repoInfo.repo, telemetryData.properties.gitRepoPath = repoInfo.pathname), telemetryData.properties.engineName = extractEngineName(ctx, requestContext.engineURL), telemetryData.properties.isMultiline = JSON.stringify(requestContext.multiline), telemetryData.properties.blockMode = requestContext.blockMode, telemetryData.properties.isCycling = JSON.stringify(requestContext.isCycling), telemetry(ctx, "ghostText.issued", telemetryData), telemetryData;
}
__name(telemetryIssued, "telemetryIssued");
function telemetryPerformance(ctx, performanceKind, choice, requestStart, processingTimeMs) {
  let requestTimeMs = Date.now() - requestStart,
    deltaMs = requestTimeMs - processingTimeMs,
    telemetryData = choice.telemetryData.extendedBy({}, {
      completionCharLen: choice.completionText.length,
      requestTimeMs: requestTimeMs,
      processingTimeMs: processingTimeMs,
      deltaMs: deltaMs,
      meanLogProb: choice.meanLogProb || NaN,
      meanAlternativeLogProb: choice.meanAlternativeLogProb || NaN,
      numTokens: choice.numTokens
    });
  telemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, `ghostText.${performanceKind}`, telemetryData);
}
__name(telemetryPerformance, "telemetryPerformance");
var CertificateReaderCache = class {
  constructor() {
    this.cache = new Map();
  }
  static {
    __name(this, "CertificateReaderCache");
  }
  get(platform) {
    return this.cache.get(platform);
  }
  set(platform, reader) {
    this.cache.set(platform, reader);
  }
};
var fs = Ns(require("fs")),
  import_tls = require("tls");
var certLogger = new Logger(1, "certificates"),
  RootCertificateReader = class {
    static {
      __name(this, "RootCertificateReader");
    }
  },
  getRootCertificateReader = __name((ctx, platform = process.platform) => new FeatureAwareCertificateReader(ctx.get(CopilotTokenNotifier), createRealReader(ctx, platform), new EmptyRootCertificateReader()), "getRootCertificateReader"),
  FeatureAwareCertificateReader = class extends RootCertificateReader {
    constructor(notifier, realReader, noopReader) {
      super();
      this.realReader = realReader;
      this.noopReader = noopReader;
      this.delegate = realReader, notifier.on("onCopilotToken", token => {
        this.delegate = token.getTokenValue("ssc") === "1" ? this.realReader : this.noopReader;
      });
    }
    static {
      __name(this, "FeatureAwareCertificateReader");
    }
    getAllRootCAs() {
      return this.delegate.getAllRootCAs();
    }
  };
function createRealReader(ctx, platform) {
  let cachedReader = ctx.get(CertificateReaderCache).get(platform);
  if (cachedReader) return cachedReader;
  let realReader = new ErrorHandlingCertificateReader(ctx, createPlatformReader(ctx, platform), Yoe.rootCertificates),
    envReader = new ErrorHandlingCertificateReader(ctx, new EnvironmentVariableRootCertificateReader()),
    cachingReader = new CachingRootCertificateReader([envReader, realReader]);
  return ctx.get(CertificateReaderCache).set(platform, cachingReader), cachingReader;
}
__name(createRealReader, "createRealReader");
function createPlatformReader(ctx, platform) {
  switch (platform) {
    case "linux":
      return new LinuxRootCertificateReader(ctx);
    case "darwin":
      return new MacRootCertificateReader(ctx);
    case "win32":
      return new WindowsRootCertificateReader(ctx);
    default:
      return new UnsupportedPlatformRootCertificateReader();
  }
}
__name(createPlatformReader, "createPlatformReader");
var ErrorHandlingCertificateReader = class extends RootCertificateReader {
    constructor(ctx, delegate, fallbackCerts = []) {
      super();
      this.ctx = ctx;
      this.delegate = delegate;
      this.fallbackCerts = fallbackCerts;
    }
    static {
      __name(this, "ErrorHandlingCertificateReader");
    }
    async getAllRootCAs() {
      try {
        return await this.delegate.getAllRootCAs();
      } catch (ex) {
        return certLogger.warn(this.ctx, `Failed to read root certificates: ${ex}`), this.fallbackCerts;
      }
    }
  },
  CachingRootCertificateReader = class extends RootCertificateReader {
    constructor(delegates) {
      super();
      this.delegates = delegates;
    }
    static {
      __name(this, "CachingRootCertificateReader");
    }
    async getAllRootCAs() {
      return this.certificates || (this.certificates = (await Promise.all(this.delegates.map(d => d.getAllRootCAs()))).flat()), this.certificates;
    }
  },
  EnvironmentVariableRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "EnvironmentVariableRootCertificateReader");
    }
    async getAllRootCAs() {
      let extraCertsFile = process.env.NODE_EXTRA_CA_CERTS;
      return extraCertsFile ? await readCertsFromFile(extraCertsFile) : [];
    }
  },
  LinuxRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "LinuxRootCertificateReader");
    }
    async getAllRootCAs() {
      let rootCAs = [];
      for (let certPath of ["/etc/ssl/certs/ca-certificates.crt", "/etc/ssl/certs/ca-bundle.crt"]) {
        let certs = await readCertsFromFile(certPath);
        certLogger.debug(this.ctx, `Read ${certs.length} certificates from ${certPath}`), rootCAs = rootCAs.concat(certs);
      }
      return rootCAs;
    }
  },
  MacRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "MacRootCertificateReader");
    }
    async getAllRootCAs() {
      let macCa = Woe(),
        certs = macCa.all(macCa.der2.pem).filter(c => c !== void 0);
      return certLogger.debug(this.ctx, `Read ${certs.length} certificates from Mac keychain`), certs;
    }
  },
  WindowsRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "WindowsRootCertificateReader");
    }
    async getAllRootCAs() {
      let certs = Koe().all();
      return certLogger.debug(this.ctx, `Read ${certs.length} certificates from Windows store`), certs;
    }
  },
  UnsupportedPlatformRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "UnsupportedPlatformRootCertificateReader");
    }
    async getAllRootCAs() {
      throw new Error("No certificate reader available for unsupported platform");
    }
  },
  EmptyRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "EmptyRootCertificateReader");
    }
    async getAllRootCAs() {
      return [];
    }
  };
async function readCertsFromFile(certFilePath) {
  try {
    let nonEmptyCerts = (await Xoe.promises.readFile(certFilePath, {
        encoding: "utf8"
      })).split(/(?=-----BEGIN CERTIFICATE-----)/g).filter(pem => pem.length > 0),
      uniqueCerts = new Set(nonEmptyCerts);
    return Array.from(uniqueCerts);
  } catch (err) {
    if (err?.code !== "ENOENT") throw err;
  }
  return [];
}
__name(readCertsFromFile, "readCertsFromFile");
var tls = Ns(require("tls"));
var RootCertificateConfigurator = class {
  static {
    __name(this, "RootCertificateConfigurator");
  }
  constructor(ctx) {
    this._certificateReader = ctx.get(RootCertificateReader);
  }
  async enhanceProxySettings(proxySettings) {
    let certs = await this.getCertificates();
    return {
      ...proxySettings,
      ca: certs
    };
  }
  async getCertificates() {
    let certificates = await this._certificateReader.getAllRootCAs();
    if (certificates.length !== 0) return certificates;
  }
  async applyToRequestOptions(requestOptions) {
    let certs = await this._certificateReader.getAllRootCAs(),
      options = {
        _vscodeAdditionalCaCerts: certs
      };
    requestOptions.secureContext = Joe.createSecureContext(options), requestOptions.ca = certs, requestOptions.cert = certs, certs.map(cert => {
      requestOptions.secureContext.context.addCACert(cert);
    });
  }
};
var http = Ns(require("http"));
var PROXY_AUTHORIZATION_REQUIRED = 407,
  logger = new Logger(0, "proxy-socket-factory"),
  ProxySocketFactory = class {
    static {
      __name(this, "ProxySocketFactory");
    }
  },
  ProxySocketError = class extends Error {
    constructor(message, cause, code) {
      super(message);
      this.code = cause?.code, this.syscall = cause?.syscall, this.errno = cause?.errno, /^Failed to establish a socket connection to proxies:/.test(cause?.message ?? "") ? this.code = "ProxyFailedToEstablishSocketConnection" : /^InitializeSecurityContext:/.test(cause?.message ?? "") ? this.code = "ProxyInitializeSecurityContext" : cause?.message === "Miscellaneous failure (see text): Server not found in Kerberos database" ? this.code = "ProxyKerberosServerNotFound" : /^Unspecified GSS failure. {2}Minor code may provide more information: No Kerberos credentials available/.test(cause?.message ?? "") && (this.code = "ProxyGSSFailureNoKerberosCredentialsAvailable"), code !== void 0 && (this.code = code);
    }
    static {
      __name(this, "ProxySocketError");
    }
  };
function getProxySocketFactory(ctx) {
  return new KerberosProxySocketFactory(ctx, new TunnelingProxySocketFactory(ctx));
}
__name(getProxySocketFactory, "getProxySocketFactory");
var KerberosProxySocketFactory = class extends ProxySocketFactory {
    constructor(ctx, delegate, kerberosLoader = new KerberosLoader(), platform = process.platform) {
      super();
      this.ctx = ctx;
      this.delegate = delegate;
      this.kerberosLoader = kerberosLoader;
      this.platform = platform;
      this.successfullyAuthorized = new LRUCacheMap(20);
    }
    static {
      __name(this, "KerberosProxySocketFactory");
    }
    async createSocket(requestOptions, proxySettings) {
      this.successfullyAuthorized.get(this.getProxyCacheKey(proxySettings)) && (logger.debug(this.ctx, "Proxy authorization already successful once, skipping 407 rountrip"), await this.reauthorize(requestOptions, proxySettings));
      try {
        return await this.delegate.createSocket(requestOptions, proxySettings);
      } catch (error) {
        if (error instanceof ProxySocketError && error.code === `ProxyStatusCode${PROXY_AUTHORIZATION_REQUIRED}`) {
          logger.debug(this.ctx, "Proxy authorization required, trying to authorize first time");
          let socket = await this.authorizeAndCreateSocket(requestOptions, proxySettings);
          if (socket) return logger.debug(this.ctx, "Proxy authorization successful, caching result"), this.successfullyAuthorized.set(this.getProxyCacheKey(proxySettings), !0), socket;
        }
        throw error;
      }
    }
    async reauthorize(requestOptions, proxySettings) {
      let proxyAuthorization = await this.authorize(proxySettings);
      proxyAuthorization && (logger.debug(this.ctx, "Proxy re-authorization successful, received token"), requestOptions.headers["Proxy-Authorization"] = "Negotiate " + proxyAuthorization);
    }
    async authorizeAndCreateSocket(requestOptions, proxySettings) {
      let proxyAuthorization = await this.authorize(proxySettings);
      if (logger.debug(this.ctx, "Proxy authorization successful, received token"), proxyAuthorization) return logger.debug(this.ctx, "Trying to create socket with proxy authorization"), requestOptions.headers["Proxy-Authorization"] = "Negotiate " + proxyAuthorization, await this.delegate.createSocket(requestOptions, proxySettings);
    }
    async authorize(proxySettings) {
      logger.debug(this.ctx, "Loading kerberos module");
      let kerberos = this.kerberosLoader.load(),
        spn = this.computeSpn(proxySettings);
      logger.debug(this.ctx, "Initializing kerberos client using spn", spn);
      let client = await kerberos.initializeClient(spn);
      logger.debug(this.ctx, "Perform client side kerberos step");
      let response = await client.step("");
      return logger.debug(this.ctx, "Received kerberos server response"), response;
    }
    computeSpn(proxySettings) {
      let configuredSpn = getHiddenConfig(this.ctx, ConfigKey.KerberosServicePrincipal, {
        default: proxySettings.kerberosServicePrincipal
      });
      if (configuredSpn) return logger.debug(this.ctx, "Using configured kerberos spn", configuredSpn), configuredSpn;
      let defaultSpn = this.platform === "win32" ? `HTTP/${proxySettings.host}` : `HTTP@${proxySettings.host}`;
      return logger.debug(this.ctx, "Using default kerberos spn", defaultSpn), defaultSpn;
    }
    getProxyCacheKey(proxySettings) {
      return proxySettings.host + ":" + proxySettings.port;
    }
  },
  TunnelingProxySocketFactory = class extends ProxySocketFactory {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "TunnelingProxySocketFactory");
    }
    async createSocket(requestOptions, proxySettings) {
      let connectOptions = this.createConnectRequestOptions(requestOptions, proxySettings);
      return new Promise((resolve, reject) => {
        logger.debug(this.ctx, "Attempting to establish connection to proxy");
        let connectRequest = yae.request(connectOptions);
        connectRequest.useChunkedEncodingByDefault = !1, connectRequest.once("connect", (res, socket, head) => {
          logger.debug(this.ctx, "Socket Connect returned status code", res.statusCode), connectRequest.removeAllListeners(), socket.removeAllListeners(), res.statusCode !== 200 ? (socket.destroy(), reject(new ProxySocketError(`tunneling socket could not be established, statusCode=${res.statusCode}`, void 0, `ProxyStatusCode${res.statusCode}`))) : head.length > 0 ? (socket.destroy(), reject(new ProxySocketError(`got non-empty response body from proxy, length=${head.length}`, void 0, "ProxyNonEmptyResponseBody"))) : (logger.debug(this.ctx, "Successfully established tunneling connection to proxy"), resolve(socket));
        }), connectRequest.once("error", cause => {
          logger.debug(this.ctx, "Proxy socket connection error", cause.message), connectRequest.removeAllListeners(), reject(new ProxySocketError(`tunneling socket could not be established, cause=${cause.message}`, cause));
        }), connectRequest.on("timeout", () => {
          logger.debug(this.ctx, "Proxy socket connection timeout"), reject(new ProxySocketError(`tunneling socket could not be established, proxy socket connection timeout while connecting to ${connectOptions.host}:${connectOptions.port}`, void 0, "ProxyTimeout"));
        }), connectRequest.end();
      });
    }
    createConnectRequestOptions(requestOptions, proxySettings) {
      let path = `${requestOptions.hostname}:${requestOptions.port}`,
        connectOptions = {
          ...proxySettings,
          method: "CONNECT",
          path: path,
          agent: !1,
          headers: {
            host: path,
            "Proxy-Connection": "keep-alive"
          },
          timeout: requestOptions.timeout
        };
      return requestOptions.localAddress && (connectOptions.localAddress = requestOptions.localAddress), this.configureProxyAuthorization(connectOptions, requestOptions), connectOptions;
    }
    configureProxyAuthorization(connectOptions, requestOptions) {
      connectOptions.headers["Proxy-Authorization"] = [], connectOptions.proxyAuth && connectOptions.headers["Proxy-Authorization"].push("Basic " + Buffer.from(connectOptions.proxyAuth).toString("base64")), requestOptions.headers && requestOptions.headers["Proxy-Authorization"] && connectOptions.headers["Proxy-Authorization"].push(requestOptions.headers["Proxy-Authorization"]);
    }
  },
  KerberosLoader = class {
    static {
      __name(this, "KerberosLoader");
    }
    load() {
      return _ae();
    }
  };
var HelixFetcher = class extends Fetcher {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.createSocketFactory = (userSettings, rejectUnauthorized) => async requestOptions => {
      requestOptions.rejectUnauthorized = rejectUnauthorized, requestOptions.timeout = userSettings.connectionTimeoutInMs, await this.certificateConfigurator.applyToRequestOptions(requestOptions);
      let proxySettings = await this.certificateConfigurator.enhanceProxySettings(userSettings);
      return await this.proxySocketFactory.createSocket(requestOptions, proxySettings);
    };
    this.fetchApi = this.createFetchApi(ctx), this.certificateConfigurator = new RootCertificateConfigurator(ctx), this.proxySocketFactory = ctx.get(ProxySocketFactory);
  }
  static {
    __name(this, "HelixFetcher");
  }
  set proxySettings(value) {
    this._proxySettings = value, this.fetchApi = this.createFetchApi(this.ctx);
  }
  get proxySettings() {
    return this._proxySettings;
  }
  set rejectUnauthorized(value) {
    super.rejectUnauthorized = value, this.fetchApi = this.createFetchApi(this.ctx);
  }
  get rejectUnauthorized() {
    return super.rejectUnauthorized;
  }
  createFetchApi(ctx) {
    let buildInfo = ctx.get(BuildInfo);
    return super.rejectUnauthorized === !1 && (process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"), context({
      userAgent: `GithubCopilot/${buildInfo.getVersion()}`,
      socketFactory: this._proxySettings ? this.createSocketFactory(this._proxySettings, super.rejectUnauthorized) : void 0,
      rejectUnauthorized: super.rejectUnauthorized
    });
  }
  async fetch(url, options) {
    let helixOptions = {
      ...options,
      body: options.body ? options.body : options.json,
      signal: options.signal
    };
    await this.certificateConfigurator.applyToRequestOptions(helixOptions);
    let certs = await this.certificateConfigurator.getCertificates();
    this.fetchApi.setCA(certs);
    let resp = await this.fetchApi.fetch(url, helixOptions);
    return new Response(resp.status, resp.statusText, resp.headers, () => resp.text(), async () => resp.body);
  }
  disconnectAll() {
    return this.fetchApi.reset();
  }
  makeAbortController() {
    return new AbortController();
  }
};
var import_events = require("events");
var PostInsertionNotifier = class extends xae.EventEmitter {
  static {
    __name(this, "PostInsertionNotifier");
  }
};
function createProductionContext(configProvider) {
  let ctx = new Context();
  return ctx.set(ConfigProvider, configProvider), ctx.set(Clock, new Clock()), ctx.set(BuildInfo, new BuildInfo()), setupRudimentaryLogging(ctx), logger.debug(ctx, "Initializing main context"), ctx.set(CompletionsCache, new CompletionsCache()), ctx.set(CopilotTokenNotifier, new CopilotTokenNotifier()), ctx.set(CertificateReaderCache, new CertificateReaderCache()), ctx.set(RootCertificateReader, getRootCertificateReader(ctx)), ctx.set(ProxySocketFactory, getProxySocketFactory(ctx)), ctx.set(Fetcher, new HelixFetcher(ctx)), ctx.set(LanguageDetection, getLanguageDetection(ctx)), ctx.set(Features, new Features(ctx)), ctx.set(PostInsertionNotifier, new PostInsertionNotifier()), ctx.set(TelemetryUserConfig, new TelemetryUserConfig(ctx)), ctx.set(TelemetryEndpointUrl, new TelemetryEndpointUrl()), ctx.set(TelemetryReporters, new TelemetryReporters()), ctx.set(HeaderContributors, new HeaderContributors()), ctx.set(UserErrorNotifier, new UserErrorNotifier(ctx)), ctx.set(ContextualFilterManager, new ContextualFilterManager()), ctx.set(OpenAIFetcher, new LiveOpenAIFetcher()), ctx.set(BlockModeConfig, new ConfigBlockModeConfig()), ctx.set(UrlOpener, new RealUrlOpener()), ctx.set(ExpConfigMaker, new ExpConfigNone()), ctx.set(PromiseQueue, new PromiseQueue()), ctx.set(uD.SnippetOrchestrator, new uD.SnippetOrchestrator()), ctx.set(ForceMultiLine, ForceMultiLine.default), ctx;
}
__name(createProductionContext, "createProductionContext");
function setupRudimentaryLogging(ctx) {
  ctx.set(RuntimeMode, RuntimeMode.fromEnvironment(!1)), ctx.set(LogVerbose, new LogVerbose(isVerboseLoggingEnabled(ctx))), ctx.set(LogTarget, new ConsoleLog(console));
}
__name(setupRudimentaryLogging, "setupRudimentaryLogging");
var logger = new Logger(0, "context");
var logger = new Logger(1, "Exp"),
  EditorExperimentFilters = class {
    static {
      __name(this, "EditorExperimentFilters");
    }
  };
function setupExperimentationService(ctx) {
  let features = ctx.get(Features);
  features.registerStaticFilters(createAllFilters(ctx)), features.registerDynamicFilter("X-Copilot-OverrideEngine", () => getConfig(ctx, ConfigKey.DebugOverrideEngine));
}
__name(setupExperimentationService, "setupExperimentationService");
function createAllFilters(ctx) {
  let defaultFilters = createDefaultFilters(ctx),
    specificFilters = ctx.get(EditorExperimentFilters).addEditorSpecificFilters();
  return {
    ...defaultFilters,
    ...specificFilters
  };
}
__name(createAllFilters, "createAllFilters");
function createDefaultFilters(ctx) {
  let buildInfo = ctx.get(BuildInfo),
    editorInfo = ctx.get(EditorAndPluginInfo).getEditorInfo(),
    editorSession = ctx.get(EditorSession);
  return {
    "X-VSCode-AppVersion": trimVersionSuffix(editorInfo.version),
    "X-MSEdge-ClientId": editorSession.machineId,
    "X-VSCode-ExtensionName": buildInfo.getName(),
    "X-VSCode-ExtensionVersion": trimVersionSuffix(buildInfo.getVersion()),
    "X-VSCode-TargetPopulation": "public"
  };
}
__name(createDefaultFilters, "createDefaultFilters");
function trimVersionSuffix(version) {
  return version.split("-")[0];
}
__name(trimVersionSuffix, "trimVersionSuffix");
var fs = Ns(require("fs"));
var FakeCopilotTokenManagerFromGitHubToken = class extends CopilotTokenManagerFromGitHubTokenBase {
    constructor(githubToken) {
      super();
      this.githubToken = githubToken;
    }
    static {
      __name(this, "FakeCopilotTokenManagerFromGitHubToken");
    }
    getGitHubSession(ctx) {
      return Promise.resolve(this.githubToken);
    }
  },
  FixedCopilotTokenManager = class extends CopilotTokenManager {
    constructor(token) {
      super();
      this.token = token;
      this.wasReset = !1;
    }
    static {
      __name(this, "FixedCopilotTokenManager");
    }
    async getGitHubSession(ctx) {
      return Promise.resolve({
        token: "token"
      });
    }
    async getCopilotToken(ctx, force) {
      return new CopilotToken(this.token);
    }
    resetCopilotToken(ctx, httpError) {
      this.wasReset = !0;
    }
    async checkCopilotToken(ctx) {
      return {
        status: "OK"
      };
    }
  };
var tokenFileName = `${process.env.HOME}/.copilot-testing-gh-token`,
  tokenManager;
function getTestingCopilotTokenManager() {
  return tokenManager || (tokenManager = createTokenManager()), tokenManager;
}
__name(getTestingCopilotTokenManager, "getTestingCopilotTokenManager");
var createTokenManager = __name(() => {
  let tokenStr = readTestingGitHubToken();
  if (tokenStr) return new FakeCopilotTokenManagerFromGitHubToken({
    token: tokenStr
  });
  if (process.env.GH_COPILOT_TOKEN) return new FixedCopilotTokenManager(process.env.GH_COPILOT_TOKEN);
  if (process.env.GITHUB_TOKEN) return new FakeCopilotTokenManagerFromGitHubToken({
    token: process.env.GITHUB_TOKEN
  });
  throw new Error(`Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${tokenFileName}. Run "npm run get_token" to get one.`);
}, "createTokenManager");
function readTestingGitHubToken() {
  if (mC.existsSync(tokenFileName)) return mC.readFileSync(tokenFileName).toString();
}
__name(readTestingGitHubToken, "readTestingGitHubToken");
var TestUrlOpener = class extends UrlOpener {
  constructor() {
    super(...arguments);
    this.openedUrls = [];
  }
  static {
    __name(this, "TestUrlOpener");
  }
  open(target) {
    this.openedUrls.push(target);
  }
};
function errorMessageForUnsupportedNodeVersion(version = process.versions.node) {
  let [major, minor, _] = version.split(".").map(v => parseInt(v, 10));
  if (major < 16 || major === 16 && minor < 14 || major == 17 && minor < 3) return `Node.js 18.x is required to run GitHub Copilot but found ${version}`;
}
__name(errorMessageForUnsupportedNodeVersion, "errorMessageForUnsupportedNodeVersion");
var import_vscode = require("vscode");
function normalizeIndentCharacter(options, completion, isEmptyLine) {
  function replace(text, toReplace, replacer) {
    let regex = new RegExp(`^(${toReplace})+`, "g");
    return text.split(`
`).map(line => {
      let trimmed = line.replace(regex, ""),
        removedCharacters = line.length - trimmed.length;
      return replacer(removedCharacters) + trimmed;
    }).join(`
`);
  }
  __name(replace, "replace");
  let indentSize;
  if (options.tabSize === void 0 || typeof options.tabSize == "string" ? indentSize = 4 : indentSize = options.tabSize, options.insertSpaces === !1) {
    let r = __name(txt => replace(txt, " ", n => "	".repeat(Math.floor(n / indentSize)) + " ".repeat(n % indentSize)), "r");
    completion.displayText = r(completion.displayText), completion.completionText = r(completion.completionText);
  } else if (options.insertSpaces === !0) {
    let r = __name(txt => replace(txt, "	", n => " ".repeat(n * indentSize)), "r");
    if (completion.displayText = r(completion.displayText), completion.completionText = r(completion.completionText), isEmptyLine) {
      let re = __name(txt => {
        let spacesAtStart = txt.length - txt.trimLeft().length,
          remainder = spacesAtStart % indentSize;
        if (remainder !== 0 && spacesAtStart > 0) {
          let toReplace = " ".repeat(remainder);
          return replace(txt, toReplace, n => " ".repeat((Math.floor(n / indentSize) + 1) * indentSize));
        } else return txt;
      }, "re");
      completion.displayText = re(completion.displayText), completion.completionText = re(completion.completionText);
    }
  }
  return completion;
}
__name(normalizeIndentCharacter, "normalizeIndentCharacter");
function completionsFromGhostTextResults(ctx, completionResults, resultType, document, position, textEditorOptions, lastShownCompletionIndex) {
  let locationFactory = ctx.get(LocationFactory),
    currentLine = document.lineAt(position),
    completions = completionResults.map(result => {
      let range,
        text = "";
      if (textEditorOptions && (result.completion = normalizeIndentCharacter(textEditorOptions, result.completion, currentLine.isEmptyOrWhitespace)), result.completion.displayNeedsWsOffset && currentLine.isEmptyOrWhitespace) range = locationFactory.range(locationFactory.position(position.line, 0), position), text = result.completion.completionText;else if (currentLine.isEmptyOrWhitespace && result.completion.completionText.startsWith(currentLine.text)) range = locationFactory.range(locationFactory.position(position.line, 0), position), text = result.completion.completionText;else {
        let wordRange = document.getWordRangeAtPosition(position);
        if (result.isMiddleOfTheLine) {
          let line = document.lineAt(position),
            rangeFromStart = locationFactory.range(locationFactory.position(position.line, 0), position),
            textBefore = document.getText(rangeFromStart);
          range = result.coversSuffix ? line.range : rangeFromStart, text = textBefore + result.completion.displayText;
        } else if (wordRange) {
          let word = document.getText(wordRange);
          range = locationFactory.range(wordRange.start, position), text = word + result.completion.completionText;
        } else {
          let rangeFromStart = locationFactory.range(locationFactory.position(position.line, 0), position),
            textBefore = document.getText(rangeFromStart);
          range = rangeFromStart, text = textBefore + result.completion.displayText;
        }
      }
      return {
        uuid: v4_default(),
        text: text,
        range: range,
        file: document.uri,
        index: result.completion.completionIndex,
        telemetry: result.telemetry,
        displayText: result.completion.displayText,
        position: position,
        offset: document.offsetAt(position),
        resultType: resultType
      };
    });
  if (resultType === 2 && lastShownCompletionIndex !== void 0) {
    let lastShownCompletion = completions.find(predicate => predicate.index === lastShownCompletionIndex);
    if (lastShownCompletion) {
      let restCompletions = completions.filter(predicate => predicate.index !== lastShownCompletionIndex);
      completions = [lastShownCompletion, ...restCompletions];
    }
  }
  return completions;
}
__name(completionsFromGhostTextResults, "completionsFromGhostTextResults");
var ChangeTracker = class {
  constructor(ctx, fileURI, insertionOffset) {
    this._referenceCount = 0;
    this._isDisposed = !1;
    this._offset = insertionOffset;
    let documentManager = ctx.get(TextDocumentManager);
    this._tracker = documentManager.onDidChangeTextDocument(async e => {
      if (e.document.uri.toString() === fileURI.toString()) {
        for (let cc of e.contentChanges) if (cc.rangeOffset + cc.rangeLength <= this.offset) {
          let delta = cc.text.length - cc.rangeLength;
          this._offset = this._offset + delta;
        }
      }
    });
  }
  static {
    __name(this, "ChangeTracker");
  }
  get offset() {
    return this._offset;
  }
  push(action, timeout) {
    if (this._isDisposed) throw new Error("Unable to push new actions to a disposed ChangeTracker");
    this._referenceCount++, setTimeout(() => {
      action(), this._referenceCount--, this._referenceCount === 0 && (this._tracker.dispose(), this._isDisposed = !0);
    }, timeout);
  }
};
var postInsertionLogger = new Logger(1, "post-insertion"),
  captureTimeouts = [{
    seconds: 15,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 30,
    captureCode: !0,
    captureRejection: !0
  }, {
    seconds: 120,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 300,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 600,
    captureCode: !1,
    captureRejection: !1
  }],
  stillInCodeNearMargin = 50,
  stillInCodeFarMargin = 1500,
  stillInCodeFraction = .5,
  captureCodeMargin = 500,
  postInsertConfiguration = {
    triggerPostInsertionSynchroneously: !1,
    captureCode: !1,
    captureRejection: !1
  };
async function captureCode(ctx, fileURI, offset, suffixOffset) {
  let document = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
  if (!document) return postInsertionLogger.info(ctx, `Could not get document for ${fileURI.fsPath}. Maybe it was closed by the editor.`), {
    prompt: {
      prefix: "",
      suffix: "",
      isFimEnabled: !1,
      promptElementRanges: []
    },
    capturedCode: "",
    terminationOffset: 0
  };
  let documentText = document.getText(),
    documentTextBefore = documentText.substring(0, offset),
    position = document.positionAt(offset),
    hypotheticalPromptResponse = await extractPrompt(ctx, document, position),
    hypotheticalPrompt = hypotheticalPromptResponse.type === "prompt" ? hypotheticalPromptResponse.prompt : {
      prefix: documentTextBefore,
      suffix: "",
      isFimEnabled: !1,
      promptElementRanges: []
    };
  if (hypotheticalPrompt.isFimEnabled && suffixOffset !== void 0) {
    let capturedCode = documentText.substring(offset, suffixOffset);
    return hypotheticalPrompt.suffix = documentText.substring(suffixOffset), {
      prompt: hypotheticalPrompt,
      capturedCode: capturedCode,
      terminationOffset: 0
    };
  } else {
    let hypotheticalResponse = documentText.substring(offset),
      contextIndent = contextIndentationFromText(documentTextBefore, offset, document.languageId),
      terminationResult = await indentationBlockFinished(contextIndent, void 0)(hypotheticalResponse),
      maxOffset = Math.min(documentText.length, offset + (terminationResult ? terminationResult * 2 : captureCodeMargin)),
      capturedCode = documentText.substring(offset, maxOffset);
    return {
      prompt: hypotheticalPrompt,
      capturedCode: capturedCode,
      terminationOffset: terminationResult ?? -1
    };
  }
}
__name(captureCode, "captureCode");
function postRejectionTasks(ctx, insertionCategory, insertionOffset, fileURI, completions) {
  completions.forEach(({
    completionText: completionText,
    completionTelemetryData: completionTelemetryData
  }) => {
    postInsertionLogger.debug(ctx, `${insertionCategory}.rejected choiceIndex: ${completionTelemetryData.properties.choiceIndex}`), telemetryRejected(ctx, insertionCategory, completionTelemetryData);
  });
  let positionTracker = new ChangeTracker(ctx, fileURI, insertionOffset - 1),
    suffixTracker = new ChangeTracker(ctx, fileURI, insertionOffset);
  captureTimeouts.filter(t => t.captureRejection).map(t => {
    positionTracker.push(async () => {
      postInsertionLogger.debug(ctx, `Original offset: ${insertionOffset}, Tracked offset: ${positionTracker.offset}`);
      let {
          completionTelemetryData: completionTelemetryData
        } = completions[0],
        {
          prompt: prompt,
          capturedCode: capturedCode,
          terminationOffset: terminationOffset
        } = await captureCode(ctx, fileURI, positionTracker.offset + 1, suffixTracker.offset),
        promptTelemetry;
      prompt.isFimEnabled ? promptTelemetry = {
        hypotheticalPromptPrefixJson: JSON.stringify(prompt.prefix),
        hypotheticalPromptSuffixJson: JSON.stringify(prompt.suffix)
      } : promptTelemetry = {
        hypotheticalPromptJson: JSON.stringify(prompt.prefix)
      };
      let customTelemetryData = completionTelemetryData.extendedBy({
        ...promptTelemetry,
        capturedCodeJson: JSON.stringify(capturedCode)
      }, {
        timeout: t.seconds,
        insertionOffset: insertionOffset,
        trackedOffset: positionTracker.offset,
        terminationOffsetInCapturedCode: terminationOffset
      });
      postInsertionLogger.debug(ctx, `${insertionCategory}.capturedAfterRejected choiceIndex: ${completionTelemetryData.properties.choiceIndex}`, customTelemetryData), telemetry(ctx, insertionCategory + ".capturedAfterRejected", customTelemetryData, 1);
    }, t.seconds * 1e3);
  });
}
__name(postRejectionTasks, "postRejectionTasks");
async function postInsertionTasks(ctx, insertionCategory, completionText, insertionOffset, fileURI, telemetryData, completionId, start) {
  postInsertionLogger.debug(ctx, `${insertionCategory}.accepted choiceIndex: ${telemetryData.properties.choiceIndex}`), telemetryAccepted(ctx, insertionCategory, telemetryData);
  let trimmedCompletion = completionText.trim(),
    tracker = new ChangeTracker(ctx, fileURI, insertionOffset),
    suffixTracker = new ChangeTracker(ctx, fileURI, insertionOffset + completionText.length),
    stillInCodeCheck = __name(async timeout => {
      await checkStillInCode(ctx, insertionCategory, trimmedCompletion, insertionOffset, fileURI, timeout, telemetryData, tracker, suffixTracker);
    }, "stillInCodeCheck");
  postInsertConfiguration.triggerPostInsertionSynchroneously && isRunningInTest(ctx) ? await stillInCodeCheck({
    seconds: 0,
    captureCode: postInsertConfiguration.captureCode,
    captureRejection: postInsertConfiguration.captureRejection
  }) : captureTimeouts.map(timeout => tracker.push(() => stillInCodeCheck(timeout), timeout.seconds * 1e3)), ctx.get(PostInsertionNotifier).emit("onPostInsertion", {
    ctx: ctx,
    insertionCategory: insertionCategory,
    insertionOffset: insertionOffset,
    fileURI: fileURI,
    completionText: completionText,
    telemetryData: telemetryData,
    completionId: completionId,
    start: start
  });
}
__name(postInsertionTasks, "postInsertionTasks");
function find(documentText, completion, margin, offset) {
  let window = documentText.substring(Math.max(0, offset - margin), Math.min(documentText.length, offset + completion.length + margin)),
    lexAlignment = lexEditDistance(window, completion),
    fraction = lexAlignment.lexDistance / lexAlignment.needleLexLength,
    {
      distance: charEditDistance
    } = editDistance(window.substring(lexAlignment.startOffset, lexAlignment.endOffset), completion);
  return {
    relativeLexEditDistance: fraction,
    charEditDistance: charEditDistance,
    completionLexLength: lexAlignment.needleLexLength,
    foundOffset: lexAlignment.startOffset + Math.max(0, offset - margin),
    lexEditDistance: lexAlignment.lexDistance,
    stillInCodeHeuristic: fraction <= stillInCodeFraction ? 1 : 0
  };
}
__name(find, "find");
async function checkStillInCode(ctx, insertionCategory, completion, insertionOffset, fileURI, timeout, telemetryData, tracker, suffixTracker) {
  let document = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
  if (document) {
    let documentText = document.getText(),
      finding = find(documentText, completion, stillInCodeNearMargin, tracker.offset);
    finding.stillInCodeHeuristic || (finding = find(documentText, completion, stillInCodeFarMargin, tracker.offset)), postInsertionLogger.debug(ctx, `stillInCode: ${finding.stillInCodeHeuristic ? "Found" : "Not found"}! Completion '${completion}' in file ${fileURI.fsPath}. lexEditDistance fraction was ${finding.relativeLexEditDistance}. Char edit distance was ${finding.charEditDistance}. Inserted at ${insertionOffset}, tracked at ${tracker.offset}, found at ${finding.foundOffset}. choiceIndex: ${telemetryData.properties.choiceIndex}`);
    let customTelemetryData = telemetryData.extendedBy({}, {
      timeout: timeout.seconds,
      insertionOffset: insertionOffset,
      trackedOffset: tracker.offset
    }).extendedBy({}, finding);
    if (telemetry(ctx, insertionCategory + ".stillInCode", customTelemetryData), timeout.captureCode) {
      let {
          prompt: prompt,
          capturedCode: capturedCode,
          terminationOffset: terminationOffset
        } = await captureCode(ctx, fileURI, tracker.offset, suffixTracker.offset),
        promptTelemetry;
      prompt.isFimEnabled ? promptTelemetry = {
        hypotheticalPromptPrefixJson: JSON.stringify(prompt.prefix),
        hypotheticalPromptSuffixJson: JSON.stringify(prompt.suffix)
      } : promptTelemetry = {
        hypotheticalPromptJson: JSON.stringify(prompt.prefix)
      };
      let afterAcceptedTelemetry = telemetryData.extendedBy({
        ...promptTelemetry,
        capturedCodeJson: JSON.stringify(capturedCode)
      }, {
        timeout: timeout.seconds,
        insertionOffset: insertionOffset,
        trackedOffset: tracker.offset,
        terminationOffsetInCapturedCode: terminationOffset
      });
      postInsertionLogger.debug(ctx, `${insertionCategory}.capturedAfterAccepted choiceIndex: ${telemetryData.properties.choiceIndex}`, customTelemetryData), telemetry(ctx, insertionCategory + ".capturedAfterAccepted", afterAcceptedTelemetry, 1);
    }
  }
}
__name(checkStillInCode, "checkStillInCode");
function isDocumentTooLarge(document) {
  try {
    return document.getText(), !1;
  } catch (e) {
    if (e instanceof RangeError) return !0;
    throw e;
  }
}
__name(isDocumentTooLarge, "isDocumentTooLarge");
async function isDocumentValid(ctx, document) {
  if (isDocumentTooLarge(document)) return {
    status: "invalid",
    reason: "Document is too large"
  };
  let rcmResult = await ctx.get(CopilotRepositoryControlManager).evaluate(document.uri, document.getText());
  return rcmResult.isBlocked ? {
    status: "invalid",
    reason: rcmResult.message ?? "Document is blocked by repository policy"
  } : {
    status: "valid",
    document: document
  };
}
__name(isDocumentValid, "isDocumentValid");
var import_vscode_uri = Ns(B1());
var CopilotPanelScheme = "copilot";
function completionTypeToString(type) {
  switch (type) {
    case 2:
      return "open copilot";
    default:
      return "unknown";
  }
}
__name(completionTypeToString, "completionTypeToString");
var CompletionContext = class _CompletionContext {
  constructor(ctx, insertPosition, completionType) {
    this.prependToCompletion = "";
    this.appendToCompletion = "";
    this.indentation = null;
    this.completionType = 2;
    this.insertPosition = ctx.get(LocationFactory).position(insertPosition.line, insertPosition.character), this.completionType = completionType;
  }
  static {
    __name(this, "CompletionContext");
  }
  static fromJSONParse(ctx, contextObj) {
    let insertPosition = ctx.get(LocationFactory).position(contextObj.insertPosition.line, contextObj.insertPosition.character),
      context = new _CompletionContext(ctx, insertPosition, contextObj.completionType);
    return context.prependToCompletion = contextObj.prependToCompletion, context.appendToCompletion = contextObj.appendToCompletion, context.indentation = contextObj.indentation, context;
  }
};
function completionContextForDocument(ctx, document, insertPosition) {
  let returnPosition = insertPosition,
    line = document.lineAt(insertPosition.line);
  return line.isEmptyOrWhitespace || (returnPosition = line.range.end), new CompletionContext(ctx, returnPosition, 2);
}
__name(completionContextForDocument, "completionContextForDocument");
var seq = 0;
function encodeLocation(targetUri, completionContext) {
  let panelFileName = "GitHub Copilot Suggestions",
    target = targetUri.toString().split("#"),
    remain = target.length > 1 ? target[1] : "",
    query = JSON.stringify([target[0], completionContext, remain]),
    targetFileName = ey.Utils.basename(targetUri);
  return targetFileName.length > 0 && (panelFileName += ` for ${targetFileName}`), ey.URI.from({
    scheme: CopilotPanelScheme,
    path: panelFileName,
    query: query,
    fragment: `${seq++}`
  });
}
__name(encodeLocation, "encodeLocation");
function decodeLocation(ctx, uri) {
  let [target, completionContextPrimer, remain] = JSON.parse(uri.query),
    targetUri = ey.URI.parse(remain.length > 0 ? target + "#" + remain : target),
    completionContext = CompletionContext.fromJSONParse(ctx, completionContextPrimer);
  return [targetUri, completionContext];
}
__name(decodeLocation, "decodeLocation");
function ignoreDocument(ctx, document) {
  let language = document.languageId;
  return !!(!getEnabledConfig(ctx, language) || [CopilotPanelScheme, "output", "search-editor"].includes(document.uri.scheme));
}
__name(ignoreDocument, "ignoreDocument");
var import_vscode = require("vscode");
var oomCodes = new Set(["ERR_WORKER_OUT_OF_MEMORY", "ENOMEM"]);
function isOomError(error) {
  return oomCodes.has(error.code ?? "") || error.name === "RangeError" && error.message === "WebAssembly.Memory(): could not allocate memory";
}
__name(isOomError, "isOomError");
function handleException(ctx, err, origin) {
  if (!isAbortError(err)) {
    if (err instanceof Error) {
      let error = err;
      isOomError(error) ? ctx.get(StatusReporter).setError("Out of memory") : error.code === "EMFILE" || error.code === "ENFILE" ? ctx.get(StatusReporter).setError("Too many open files") : error.code === "CopilotPromptLoadFailure" ? ctx.get(StatusReporter).setError("Corrupted Copilot installation") : `${error.code}`.startsWith("CopilotPromptWorkerExit") ? ctx.get(StatusReporter).setError("Worker unexpectedly exited") : error.syscall === "uv_cwd" && error.code === "ENOENT" && ctx.get(StatusReporter).setError("Current working directory does not exist");
    }
    console.error(origin, err), telemetryException(ctx, err, origin);
  }
}
__name(handleException, "handleException");
function exception(ctx, error, origin) {
  error instanceof Error && error.name === "Canceled" || error instanceof Error && error.name === "CodeExpectedError" || handleException(ctx, error, origin);
}
__name(exception, "exception");
function registerCommandWithTelemetry(ctx, command, fn) {
  let disposable = Uae.commands.registerCommand(command, async (...args) => {
    try {
      return await fn(...args);
    } catch (error) {
      exception(ctx, error, command);
    }
  });
  ctx.get(Extension).register(disposable);
}
__name(registerCommandWithTelemetry, "registerCommandWithTelemetry");
function cleanupTelemetryReporters(ctx) {
  let container = ctx.get(TelemetryReporters);
  disposeIfNeccessary(ctx, container.getReporter(ctx)), disposeIfNeccessary(ctx, container.getRestrictedReporter(ctx));
}
__name(cleanupTelemetryReporters, "cleanupTelemetryReporters");
function disposeIfNeccessary(ctx, reporter) {
  reporter && ctx.get(Extension).register(reporter);
}
__name(disposeIfNeccessary, "disposeIfNeccessary");
var postInsertCmdName = "_ghostTextPostInsert",
  VersionMismatchError = class extends Error {
    constructor(oldVersion, newVersion) {
      super(`Document version changed from ${oldVersion} to ${newVersion}`);
      this.oldVersion = oldVersion;
      this.newVersion = newVersion;
      this.name = "VersionMismatchError";
    }
    static {
      __name(this, "VersionMismatchError");
    }
  },
  ExtensionTextDocument = class {
    static {
      __name(this, "ExtensionTextDocument");
    }
    constructor(textDocument) {
      this._textDocument = textDocument, this._originalVersion = textDocument.version;
    }
    get textDocument() {
      if (this._originalVersion !== this._textDocument.version) throw new VersionMismatchError(this._originalVersion, this._textDocument.version);
      return this._textDocument;
    }
    get uri() {
      return this.textDocument.uri;
    }
    get languageId() {
      return this.textDocument.languageId;
    }
    get version() {
      return this.textDocument.version;
    }
    get lineCount() {
      return this.textDocument.lineCount;
    }
    get relativePath() {
      return this.textDocument.uri.path;
    }
    getText(range) {
      return this.textDocument.getText(range);
    }
    positionAt(offset) {
      return this.textDocument.positionAt(offset);
    }
    offsetAt(position) {
      return this.textDocument.offsetAt(position);
    }
    lineAt(position) {
      let lineNumber = typeof position == "number" ? position : position.line;
      return this.textDocument.lineAt(lineNumber);
    }
    getWordRangeAtPosition(position) {
      return this.textDocument.getWordRangeAtPosition(position);
    }
  };
function getInsertionTextFromCompletion(completion) {
  return completion.insertText;
}
__name(getInsertionTextFromCompletion, "getInsertionTextFromCompletion");
var ghostTextLogger = new Logger(1, "ghostText");
function ghostTextEnabled(ctx) {
  return getConfig(ctx, ConfigKey.InlineSuggestEnable);
}
__name(ghostTextEnabled, "ghostTextEnabled");
function getTextEditorOptions(document) {
  return Ol.window.visibleTextEditors.find(editor => editor.document === document)?.options;
}
__name(getTextEditorOptions, "getTextEditorOptions");
var lastPosition,
  lastUri,
  lastShownCompletions = [],
  lastShownCompletionIndex,
  lastPartiallyAcceptedLength;
async function calculateInlineCompletions(ctx, vscodeDocument, position, context, token) {
  let document = new ExtensionTextDocument(vscodeDocument),
    textEditorOptions = getTextEditorOptions(vscodeDocument),
    telemetryData = TelemetryData.createAndMarkAsIssued();
  if (!ghostTextEnabled(ctx)) return {
    type: "abortedBeforeIssued",
    reason: "ghost text is disabled"
  };
  if (ignoreDocument(ctx, document)) return {
    type: "abortedBeforeIssued",
    reason: "document is ignored"
  };
  if (isDocumentTooLarge(document)) return {
    type: "abortedBeforeIssued",
    reason: "document is too large"
  };
  if (ghostTextLogger.debug(ctx, `Ghost text called at [${position.line}, ${position.character}], with triggerKind ${context.triggerKind}`), token.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled before extractPrompt"), {
    type: "abortedBeforeIssued",
    reason: "cancelled before extractPrompt"
  };
  let result = await getGhostText(ctx, document, position, context.triggerKind === Ol.InlineCompletionTriggerKind.Invoke, telemetryData, token);
  if (result.type !== "success") return ghostTextLogger.debug(ctx, "Breaking, no results from getGhostText -- " + result.type + ": " + result.reason), result;
  let [resultArray, resultType] = result.value;
  if (lastPosition && lastUri && !(lastPosition.isEqual(position) && lastUri.toString() === document.uri.toString()) && resultType !== 2) {
    let rejectedCompletions = computeRejectedCompletions();
    rejectedCompletions.length > 0 && postRejectionTasks(ctx, "ghostText", document.offsetAt(lastPosition), lastUri, rejectedCompletions), lastPartiallyAcceptedLength = void 0;
  }
  if (lastPosition = position, lastUri = document.uri, lastShownCompletions = [], token.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after getGhostText"), {
    type: "canceled",
    reason: "after getGhostText",
    telemetryData: {
      telemetryBlob: result.telemetryBlob
    }
  };
  let inlineCompletions = completionsFromGhostTextResults(ctx, resultArray, resultType, document, position, textEditorOptions, lastShownCompletionIndex).map(completion => {
    let {
        text: text,
        range: range
      } = completion,
      newRange = new Ol.Range(new Ol.Position(range.start.line, range.start.character), new Ol.Position(range.end.line, range.end.character)),
      completionItem = new Ol.InlineCompletionItem(text, newRange);
    return completionItem.index = completion.index, completionItem.telemetry = completion.telemetry, completionItem.displayText = completion.displayText, completionItem.resultType = completion.resultType, completionItem.id = completion.uuid, completionItem.uri = document.uri, completionItem.insertPosition = new Ol.Position(completion.position.line, completion.position.character), completionItem.insertOffset = document.offsetAt(completionItem.insertPosition), completionItem.command = {
      title: "PostInsertTask",
      command: postInsertCmdName,
      arguments: [completionItem]
    }, completionItem;
  });
  return inlineCompletions.length === 0 ? {
    type: "empty",
    reason: "no completions in final result",
    telemetryData: result.telemetryData
  } : {
    ...result,
    value: inlineCompletions
  };
}
__name(calculateInlineCompletions, "calculateInlineCompletions");
function computeRejectedCompletions() {
  let rejectedCompletions = [];
  return lastShownCompletions.forEach(c => {
    if (c.displayText && c.telemetry) {
      let completionText, completionTelemetryData;
      lastPartiallyAcceptedLength ? (completionText = c.displayText.substring(lastPartiallyAcceptedLength - 1), completionTelemetryData = c.telemetry.extendedBy({
        compType: "partial"
      }, {
        compCharLen: completionText.length
      })) : (completionText = c.displayText, completionTelemetryData = c.telemetry);
      let rejection = {
        completionText: completionText,
        completionTelemetryData: completionTelemetryData
      };
      rejectedCompletions.push(rejection);
    }
  }), rejectedCompletions;
}
__name(computeRejectedCompletions, "computeRejectedCompletions");
async function provideInlineCompletions(ctx, document, position, context, token) {
  let result;
  try {
    result = await calculateInlineCompletions(ctx, document, position, context, token);
  } catch (e) {
    if (!(e instanceof VersionMismatchError)) throw e;
    let data = TelemetryData.createAndMarkAsIssued({
      languageId: String(document.languageId),
      requestedDocumentVersion: String(e.oldVersion),
      actualDocumentVersion: String(e.newVersion)
    });
    telemetry(ctx, "ghostText.docVersionMismatch", data);
    return;
  }
  return await handleGhostTextResultTelemetry(ctx, result);
}
__name(provideInlineCompletions, "provideInlineCompletions");
var Provider = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "Provider");
  }
  async provideInlineCompletionItems(doc, cursorPos, context, token) {
    if (!(context.triggerKind === Ol.InlineCompletionTriggerKind.Automatic && !isAutoCompletionsEnabled(this.ctx))) try {
      let items = await provideInlineCompletions(this.ctx, doc, cursorPos, context, token);
      return items ? {
        items: items
      } : void 0;
    } catch (e) {
      exception(this.ctx, e, "ghostText.provideInlineCompletionItems");
    }
  }
  handleDidShowCompletionItem(completionItem) {
    try {
      handleGhostTextShown(this.ctx, completionItem);
    } catch (e) {
      exception(this.ctx, e, "ghostText.handleGhostTextShown");
    }
  }
  handleDidPartiallyAcceptCompletionItem(completionItem, acceptedLength) {
    try {
      handlePartialGhostTextPostInsert(this.ctx, completionItem, acceptedLength);
    } catch (e) {
      exception(this.ctx, e, "ghostText.handleDidPartiallyAcceptCompletionItem");
    }
  }
};
function isAutoCompletionsEnabled(ctx) {
  return getConfig(ctx, ConfigKey.EnableAutoCompletions);
}
__name(isAutoCompletionsEnabled, "isAutoCompletionsEnabled");
async function handlePartialGhostTextPostInsert(ctx, ci, acceptedLength) {
  if (acceptedLength === getInsertionTextFromCompletion(ci).length && resetStateForLastCompletion(), ghostTextLogger.debug(ctx, "Ghost text partial post insert"), ci.telemetry && ci.uri && ci.displayText && ci.insertOffset && ci.range && ci.id) {
    let partialAcceptanceLength = computePartialLength(ci, acceptedLength);
    if (partialAcceptanceLength) {
      let partialTelemetryData = ci.telemetry.extendedBy({
        compType: "partial"
      }, {
        compCharLen: partialAcceptanceLength
      });
      lastPartiallyAcceptedLength = acceptedLength;
      let completionText = ci.displayText.substring(0, partialAcceptanceLength);
      await postInsertionTasks(ctx, "ghostText", completionText, ci.insertOffset, ci.uri, partialTelemetryData, ci.id, ci.range.start);
    }
  }
}
__name(handlePartialGhostTextPostInsert, "handlePartialGhostTextPostInsert");
function resetStateForLastCompletion() {
  lastShownCompletions = [], lastUri = void 0, lastPosition = void 0;
}
__name(resetStateForLastCompletion, "resetStateForLastCompletion");
function resetPartialAcceptanceState() {
  lastPartiallyAcceptedLength = void 0;
}
__name(resetPartialAcceptanceState, "resetPartialAcceptanceState");
function computePartialLength(ci, acceptedLength) {
  if (!ci.range || !ci.range.start || !ci.range.end) return;
  let insertText = getInsertionTextFromCompletion(ci);
  return ci.displayText !== insertText && insertText.trim() === ci.displayText ? acceptedLength : acceptedLength - ci.range.end.character + ci.range.start.character;
}
__name(computePartialLength, "computePartialLength");
function handleGhostTextShown(ctx, ci) {
  if (lastShownCompletionIndex = ci.index, !lastShownCompletions.find(c => c.index === ci.index) && (`${ci.uri}` == `${lastUri}` && lastPosition?.isEqual(ci.insertPosition) && lastShownCompletions.push(ci), ci.telemetry && ci.displayText)) {
    let fromCache = ci.resultType !== 0;
    ghostTextLogger.debug(ctx, `[${ci.telemetry.properties.headerRequestId}] shown choiceIndex: ${ci.telemetry.properties.choiceIndex}, fromCache ${fromCache}`), ci.telemetry.measurements.compCharLen = ci.displayText.length, telemetryShown(ctx, "ghostText", ci.telemetry, fromCache);
  }
}
__name(handleGhostTextShown, "handleGhostTextShown");
async function handleGhostTextPostInsert(ctx, e) {
  if (resetStateForLastCompletion(), ghostTextLogger.debug(ctx, "Ghost text post insert"), e.telemetry && e.uri && e.displayText && e.insertOffset !== void 0 && e.range && e.id) {
    let completionTelemetryData = e.telemetry.extendedBy({
      compType: lastPartiallyAcceptedLength ? "partial" : "full"
    }, {
      compCharLen: e.displayText.length
    });
    resetPartialAcceptanceState(), await postInsertionTasks(ctx, "ghostText", e.displayText, e.insertOffset, e.uri, completionTelemetryData, e.id, e.range.start);
  }
}
__name(handleGhostTextPostInsert, "handleGhostTextPostInsert");
function registerGhostText(ctx) {
  let provider = new Provider(ctx),
    providerHandler = Ol.languages.registerInlineCompletionItemProvider({
      pattern: "**"
    }, provider),
    postCmdHandler = Ol.commands.registerCommand(postInsertCmdName, async e => handleGhostTextPostInsert(ctx, e));
  ctx.get(Extension).register(providerHandler, postCmdHandler);
}
__name(registerGhostText, "registerGhostText");
var import_vscode = require("vscode");
async function telemetryAuthNotifyShown(ctx, authSource) {
  let data = TelemetryData.createAndMarkAsIssued({
    authSource: authSource
  });
  await telemetry(ctx, "auth.auth_notify_shown", data);
}
__name(telemetryAuthNotifyShown, "telemetryAuthNotifyShown");
async function telemetryAuthNotifyDismissed(ctx) {
  await telemetry(ctx, "auth.auth_notify_dismissed");
}
__name(telemetryAuthNotifyDismissed, "telemetryAuthNotifyDismissed");
async function telemetryNewGitHubLogin(ctx, authSource, authType) {
  let data = TelemetryData.createAndMarkAsIssued({
    authSource: authSource,
    authType: authType
  });
  await telemetry(ctx, "auth.new_github_login", data);
}
__name(telemetryNewGitHubLogin, "telemetryNewGitHubLogin");
async function telemetryGitHubLoginFailed(ctx) {
  await telemetryError(ctx, "auth.github_login_failed");
}
__name(telemetryGitHubLoginFailed, "telemetryGitHubLoginFailed");
var import_vscode = require("vscode");
var GITHUB_SCOPE_READ_USER = ["read:user"],
  GITHUB_SCOPE_USER_EMAIL = ["user:email"],
  SESSION_LOGIN_MESSAGE = "You are not signed in to GitHub. Please sign in to use Copilot.",
  shownSignInMessage = !1;
function permitOneSignIn() {
  shownSignInMessage = !1;
}
__name(permitOneSignIn, "permitOneSignIn");
function authProviderId() {
  return N1.workspace.getConfiguration(CopilotConfigPrefix).get("advanced")?.authProvider === "github-enterprise" ? "github-enterprise" : "github";
}
__name(authProviderId, "authProviderId");
async function onDidChangeSessionsHandler(event, ctx) {
  let provider = event.provider,
    providerId = authProviderId();
  if (provider.id === providerId) {
    let statusReporter = ctx.get(StatusReporter);
    (await N1.authentication.getSession(providerId, GITHUB_SCOPE_USER_EMAIL)) ? (statusReporter.forceNormal(), await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !0)) : (ctx.get(CopilotTokenManager).resetCopilotToken(ctx), statusReporter.setWarning(SESSION_LOGIN_MESSAGE));
  }
}
__name(onDidChangeSessionsHandler, "onDidChangeSessionsHandler");
function getSessionHelper(createIfNone) {
  let providerId = authProviderId();
  return N1.authentication.getSession(providerId, GITHUB_SCOPE_READ_USER, {
    silent: !0
  }).then(session => session || N1.authentication.getSession(providerId, GITHUB_SCOPE_USER_EMAIL, {
    createIfNone: createIfNone
  }));
}
__name(getSessionHelper, "getSessionHelper");
async function getSession(ctx, fromCommand = !1) {
  let session = await getSessionHelper(!1);
  if (!session) if (shownSignInMessage) fromCommand && (telemetryAuthNotifyShown(ctx, "command"), telemetryNewGitHubLogin(ctx, "command", "editorAuth"), session = await getSessionHelper(!0));else {
    shownSignInMessage = !0, telemetryAuthNotifyShown(ctx, "toast");
    let choice = await N1.window.showInformationMessage("Sign in to use GitHub Copilot.", "Sign in to GitHub");
    if (session = await getSessionHelper(!1), !session) if (choice === "Sign in to GitHub") telemetryNewGitHubLogin(ctx, "toast", "editorAuth"), session = await getSessionHelper(!0);else throw telemetryAuthNotifyDismissed(ctx), new CopilotAuthError("GitHubLoginFailed");
  }
  return session;
}
__name(getSession, "getSession");
async function hasExistingSession() {
  return (await getSessionHelper(!1)) !== void 0;
}
__name(hasExistingSession, "hasExistingSession");
var authLogger = new Logger(1, "auth"),
  shown401Message = !1,
  everActivated = !1;
async function auth(ctx) {
  let session = await getSession(ctx);
  if (!session) {
    let message = "GitHub login failed";
    return authLogger.info(ctx, message), telemetryGitHubLoginFailed(ctx), {
      kind: "failure",
      reason: "GitHubLoginFailed",
      message: message
    };
  }
  authLogger.debug(ctx, `Logged in as ${session.account.label}, oauth token ${session.accessToken}`);
  let tokenResult = await authFromGitHubToken(ctx, {
    token: session.accessToken
  });
  if (tokenResult.kind == "success") {
    let token = tokenResult.token;
    authLogger.debug(ctx, `Copilot HMAC for ${session.account.label}: ${token}`);
  }
  return tokenResult;
}
__name(auth, "auth");
var ExtensionNotificationSender = class extends NotificationSender {
  static {
    __name(this, "ExtensionNotificationSender");
  }
  async showWarningMessage(message, ...actions) {
    return {
      title: await ED.window.showWarningMessage(message, ...actions.map(action => action.title))
    };
  }
};
async function authShowWarnings(ctx) {
  let tokenResult = await auth(ctx);
  if (tokenResult.kind === "failure" && tokenResult.reason === "HTTP401") {
    let message = "Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.";
    everActivated && !shown401Message && (shown401Message = !0, ED.window.showWarningMessage(message));
  }
  if (tokenResult.kind === "failure" && tokenResult.message) throw new CopilotAuthError(tokenResult.message);
  if (tokenResult.kind === "failure") {
    let error = new Error(`Unexpected error getting Copilot token: ${tokenResult.reason ?? "no reason given"}`);
    throw error.code = `CopilotToken.${tokenResult.reason}`, error;
  }
  return everActivated = !0, tokenResult;
}
__name(authShowWarnings, "authShowWarnings");
var VSCodeCopilotTokenManager = class extends CopilotTokenManager {
  constructor() {
    super();
    this.copilotToken = void 0;
  }
  static {
    __name(this, "VSCodeCopilotTokenManager");
  }
  async getGitHubSession(ctx) {
    let session = await getSession(ctx);
    return session ? {
      token: session.accessToken
    } : void 0;
  }
  async getCopilotToken(ctx, force) {
    return (!this.copilotToken || this.copilotToken.expires_at < nowSeconds() || force) && (this.copilotToken = await authShowWarnings(ctx), refreshToken(ctx, this, this.copilotToken.refresh_in)), new CopilotToken(this.copilotToken.token, this.copilotToken.organization_list);
  }
  resetCopilotToken(ctx, httpError) {
    httpError !== void 0 && telemetry(ctx, "auth.reset_token_" + httpError), authLogger.debug(ctx, `Resetting copilot token on HTTP error ${httpError || "unknown"}`), this.copilotToken = void 0;
  }
};
var import_vscode = require("vscode");
var import_vscode = require("vscode");
var OutputPaneShowCommand = "codereferencing.showOutputPane",
  FeatureName = "code-referencing",
  ProdSnippyDomain = "https://origin-tracker.githubusercontent.com";
var codeReferenceLogger = new Logger(1, FeatureName);
var statusCodeRe = /^[1-6][0-9][0-9]$/,
  capitalsRe = /([A-Z][a-z]+)/,
  NAMESPACE = "code_referencing",
  CodeQuoteTelemetry = class {
    constructor(baseKey) {
      this.baseKey = baseKey;
    }
    static {
      __name(this, "CodeQuoteTelemetry");
    }
    buildKey(...keys) {
      return [NAMESPACE, this.baseKey, ...keys].join(".");
    }
  },
  CopilotOutputLogTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "CopilotOutputLogTelemetry");
    }
    constructor() {
      super("github_copilot_log");
    }
    handleOpen({
      context: context
    }) {
      let key = this.buildKey("open", "count"),
        data = TelemetryData.createAndMarkAsIssued();
      telemetry(context, key, data);
    }
    handleFocus({
      context: context
    }) {
      let data = TelemetryData.createAndMarkAsIssued(),
        key = this.buildKey("focus", "count");
      telemetry(context, key, data);
    }
    handleWrite({
      context: context
    }) {
      let data = TelemetryData.createAndMarkAsIssued(),
        key = this.buildKey("write", "count");
      telemetry(context, key, data);
    }
  },
  copilotOutputLogTelemetry = new CopilotOutputLogTelemetry(),
  MatchNotificationTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "MatchNotificationTelemetry");
    }
    constructor() {
      super("match_notification");
    }
    handleDoAction({
      context: context,
      actor: actor
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
          actor: actor
        }),
        key = this.buildKey("acknowledge", "count");
      telemetry(context, key, data);
    }
    handleDismiss({
      context: context,
      actor: actor
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
          actor: actor
        }),
        key = this.buildKey("ignore", "count");
      telemetry(context, key, data);
    }
  },
  matchNotificationTelemetry = new MatchNotificationTelemetry(),
  SnippyTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "SnippyTelemetry");
    }
    constructor() {
      super("snippy");
    }
    handleUnexpectedError({
      context: context,
      origin: origin,
      reason: reason
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        reason: reason
      });
      telemetryError(context, this.buildKey("unexpectedError"), data);
    }
    handleCompletionMissing({
      context: context,
      origin: origin,
      reason: reason
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        reason: reason
      });
      telemetryError(context, this.buildKey("completionMissing"), data);
    }
    handleSnippyNetworkError({
      context: context,
      origin: origin,
      reason: reason,
      message: message
    }) {
      if (!origin.match(statusCodeRe)) {
        codeReferenceLogger.debug(context, "Invalid status code, not sending telemetry", {
          origin: origin
        });
        return;
      }
      let errorType = reason.split(capitalsRe).filter(part => !!part).join("_").toLowerCase(),
        data = TelemetryData.createAndMarkAsIssued({
          message: message
        });
      telemetryError(context, this.buildKey(errorType, origin), data);
    }
  },
  snippyTelemetry = new SnippyTelemetry();
var CopilotOutputLogFilename = "GitHub Copilot Log",
  CodeRefEngagementTracker = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.activeLog = !1;
      this.subscriptions = [];
      this.onActiveEditorChange = editor => {
        this.isOutputLog(editor) && copilotOutputLogTelemetry.handleFocus({
          context: this.ctx
        });
      };
      this.onVisibleEditorsChange = currEditors => {
        let copilotLog = currEditors.find(this.isOutputLog);
        this.activeLog ? copilotLog || (this.activeLog = !1) : copilotLog && (this.activeLog = !0, copilotOutputLogTelemetry.handleOpen({
          context: this.ctx
        }));
      };
      this.isOutputLog = editor => editor && editor.document.uri.scheme === "output" && editor.document.uri.path.includes(CopilotOutputLogFilename);
    }
    static {
      __name(this, "CodeRefEngagementTracker");
    }
    register() {
      let activeEditorChangeSub = ay.window.onDidChangeActiveTextEditor(this.onActiveEditorChange),
        visibleEditorsSub = ay.window.onDidChangeVisibleTextEditors(this.onVisibleEditorsChange);
      this.subscriptions.push(visibleEditorsSub), this.subscriptions.push(activeEditorChangeSub);
    }
    dispose() {
      return ay.Disposable.from(...this.subscriptions);
    }
    get logVisible() {
      return this.activeLog;
    }
  };
function registerCodeRefEngagementTracker(ctx) {
  let engagementTracker = new CodeRefEngagementTracker(ctx);
  return engagementTracker.register(), engagementTracker;
}
__name(registerCodeRefEngagementTracker, "registerCodeRefEngagementTracker");
var InitialTimeout = 3e3,
  BaseRetryTime = 2,
  MaxRetryTime = 256,
  MaxAttempts = Math.log(MaxRetryTime) / Math.log(BaseRetryTime) / BaseRetryTime,
  state = {
    connection: "disabled",
    maxAttempts: MaxAttempts,
    retryAttempts: 0,
    initialWait: !1
  },
  stateAPI,
  handlers = [];
function registerConnectionState() {
  if (stateAPI) return stateAPI;
  function subscribe(cb) {
    return handlers.push(cb), () => {
      let index = handlers.indexOf(cb);
      index !== -1 && handlers.splice(index, 1);
    };
  }
  __name(subscribe, "subscribe");
  function afterUpdateConnection() {
    for (let handler of handlers) handler();
  }
  __name(afterUpdateConnection, "afterUpdateConnection");
  function updateConnection(status) {
    state.connection !== status && (state.connection = status, afterUpdateConnection());
  }
  __name(updateConnection, "updateConnection");
  function isConnected() {
    return state.connection === "connected";
  }
  __name(isConnected, "isConnected");
  function isDisconnected() {
    return state.connection === "disconnected";
  }
  __name(isDisconnected, "isDisconnected");
  function isRetrying() {
    return state.connection === "retry";
  }
  __name(isRetrying, "isRetrying");
  function isDisabled() {
    return state.connection === "disabled";
  }
  __name(isDisabled, "isDisabled");
  function setConnected() {
    updateConnection("connected"), setInitialWait(!1);
  }
  __name(setConnected, "setConnected");
  function setDisconnected() {
    updateConnection("disconnected");
  }
  __name(setDisconnected, "setDisconnected");
  function setRetrying() {
    updateConnection("retry");
  }
  __name(setRetrying, "setRetrying");
  function setDisabled() {
    updateConnection("disabled");
  }
  __name(setDisabled, "setDisabled");
  function setInitialWait(enabled) {
    state.initialWait !== enabled && (state.initialWait = enabled);
  }
  __name(setInitialWait, "setInitialWait");
  async function enableRetry(ctx, initialTimeout = InitialTimeout) {
    isRetrying() || (setRetrying(), setInitialWait(!0), attemptToPing(ctx, initialTimeout));
  }
  __name(enableRetry, "enableRetry");
  function isInitialWait() {
    return state.initialWait;
  }
  __name(isInitialWait, "isInitialWait");
  async function attemptToPing(ctx, initialTimeout) {
    codeReferenceLogger.info(ctx, `Attempting to reconnect in ${initialTimeout}ms.`), await timeout(initialTimeout), setInitialWait(!1);
    let fetcher = ctx.get(Fetcher);
    async function succeedOrRetry(time, ctx) {
      if (time > MaxRetryTime) {
        codeReferenceLogger.info(ctx, "Max retry time reached, disabling."), setDisabled();
        return;
      }
      setTimeout(async () => {
        state.retryAttempts = Math.min(state.retryAttempts + 1, MaxAttempts);
        try {
          codeReferenceLogger.info(ctx, `Pinging service after ${time} second(s)`);
          let response = await fetcher.fetch(ProdSnippyDomain + "/_ping", {
            method: "GET",
            headers: {
              "content-type": "application/json"
            }
          });
          if (response.status !== 200 || !response.ok) await succeedOrRetry(time ** 2, ctx);else {
            codeReferenceLogger.info(ctx, "Successfully reconnected."), setConnected();
            return;
          }
        } catch {
          await succeedOrRetry(time ** 2, ctx);
        }
      }, time * 1e3);
    }
    __name(succeedOrRetry, "succeedOrRetry"), codeReferenceLogger.info(ctx, "Attempting to reconnect."), await succeedOrRetry(BaseRetryTime, ctx);
  }
  __name(attemptToPing, "attemptToPing");
  let timeout = __name(ms => new Promise(resolve => setTimeout(resolve, ms)), "timeout");
  function listen(cb) {
    return {
      dispose: subscribe(cb)
    };
  }
  return __name(listen, "listen"), stateAPI = {
    setConnected: setConnected,
    setDisconnected: setDisconnected,
    setRetrying: setRetrying,
    setDisabled: setDisabled,
    enableRetry: enableRetry,
    listen: listen,
    isConnected: isConnected,
    isDisconnected: isDisconnected,
    isRetrying: isRetrying,
    isDisabled: isDisabled,
    isInitialWait: isInitialWait
  }, stateAPI;
}
__name(registerConnectionState, "registerConnectionState");
var ConnectionState = registerConnectionState();
var import_vscode = require("vscode");
var CodeQuoteHeaderContributor = class {
    static {
      __name(this, "CodeQuoteHeaderContributor");
    }
    constructor(codequoteEnabled) {
      this.codequoteEnabled = codequoteEnabled ?? !1;
    }
    updateCodeQuoteEnabled(codequoteEnabled) {
      this.codequoteEnabled = codequoteEnabled ?? !1;
    }
    contributeHeaderValues(headers) {
      headers["Code-Quote-Enabled"] = String(this.codequoteEnabled);
    }
  },
  AnnotationsHeaderContributor = class {
    static {
      __name(this, "AnnotationsHeaderContributor");
    }
    constructor(annotationsEnabled) {
      this.annotationsEnabled = annotationsEnabled ?? !1;
    }
    updateAnnotationsEnabled(annotationsEnabled) {
      this.annotationsEnabled = annotationsEnabled ?? !1;
    }
    contributeHeaderValues(headers) {
      headers["Annotations-Enabled"] = String(this.annotationsEnabled);
    }
  };
function registerCopilotEnvelopeListener(ctx) {
  function updateFromEnvelopeState() {
    let codeQuoteEnabled = !ConnectionState.isDisabled();
    codequoteHeaderContributor.updateCodeQuoteEnabled(codeQuoteEnabled);
  }
  __name(updateFromEnvelopeState, "updateFromEnvelopeState");
  let disposer = ConnectionState.listen(updateFromEnvelopeState),
    codequoteHeaderContributor = new CodeQuoteHeaderContributor(),
    headerContributors = ctx.get(HeaderContributors);
  return headerContributors.add(codequoteHeaderContributor), updateFromEnvelopeState(), new s0e.Disposable(() => {
    headerContributors.remove(codequoteHeaderContributor), disposer.dispose();
  });
}
__name(registerCopilotEnvelopeListener, "registerCopilotEnvelopeListener");
var import_value = Ns(OL()),
  import_vscode = require("vscode");
var SnippyLexemeRegex = new RegExp("[_\\p{L}\\p{Nd}]+|====+|----+|####+|////+|\\*\\*\\*\\*+|[\\p{P}\\p{S}]", "gu"),
  MinTokenLength = 65;
function lexemeLength(text) {
  let i = 0,
    m;
  SnippyLexemeRegex.lastIndex = 0;
  do if (m = SnippyLexemeRegex.exec(text), m && (i += 1), i >= MinTokenLength) break; while (m);
  return i;
}
__name(lexemeLength, "lexemeLength");
function offsetFirstLexemes(text, n) {
  let i = 0,
    m;
  SnippyLexemeRegex.lastIndex = 0;
  do if (m = SnippyLexemeRegex.exec(text), m && (i += 1, i >= n)) return SnippyLexemeRegex.lastIndex; while (m);
  return text.length;
}
__name(offsetFirstLexemes, "offsetFirstLexemes");
function offsetLastLexemes(text, n) {
  let textRev = text.split("").reverse().join(""),
    offsetRev = offsetFirstLexemes(textRev, n);
  return textRev.length - offsetRev;
}
__name(offsetLastLexemes, "offsetLastLexemes");
function hasMinLexemeLength(text) {
  return lexemeLength(text) >= MinTokenLength;
}
__name(hasMinLexemeLength, "hasMinLexemeLength");
var import_vscode = require("vscode");
var matchCodeMessage = "We found a reference to public code in a recent suggestion.",
  MatchAction = "View log",
  CodeReferenceKey = "codeReference.notified";
function notify(ctx) {
  let extension = ctx.get(Extension);
  if (extension.context.globalState.get(CodeReferenceKey)) return;
  ctx.get(NotificationSender).showWarningMessage(matchCodeMessage, {
    title: MatchAction
  }).then(action => {
    let event = {
      context: ctx,
      actor: "user"
    };
    switch (action?.title) {
      case MatchAction:
        {
          matchNotificationTelemetry.handleDoAction(event), u0e.commands.executeCommand(OutputPaneShowCommand);
          break;
        }
      case void 0:
        {
          matchNotificationTelemetry.handleDismiss(event);
          break;
        }
    }
  }), extension.context.globalState.update(CodeReferenceKey, !0);
}
__name(notify, "notify");
var import_vscode = require("vscode");
var GitHubCopilotChannelName = "GitHub Copilot Log";
function getCurrentTimestamp() {
  let toTwoDigits = __name(v => v < 10 ? `0${v}` : v, "toTwoDigits"),
    toThreeDigits = __name(v => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v, "toThreeDigits"),
    currentTime = new Date();
  return `${currentTime.getFullYear()}-${toTwoDigits(currentTime.getMonth() + 1)}-${toTwoDigits(currentTime.getDate())} ${toTwoDigits(currentTime.getHours())}:${toTwoDigits(currentTime.getMinutes())}:${toTwoDigits(currentTime.getSeconds())}.${toThreeDigits(currentTime.getMilliseconds())}`;
}
__name(getCurrentTimestamp, "getCurrentTimestamp");
var CodeReferenceOutputChannel = class {
    constructor(output) {
      this.output = output;
    }
    static {
      __name(this, "CodeReferenceOutputChannel");
    }
    info(...messages) {
      this.output.appendLine(`${getCurrentTimestamp()} [info] ${messages.join(" ")}`);
    }
    show(preserveFocus) {
      this.output.show(preserveFocus);
    }
    dispose() {
      this.output.dispose();
    }
  },
  GitHubCopilotLogger = class _GitHubCopilotLogger {
    constructor(ctx) {
      this.ctx = ctx;
      this.tokenManager = void 0;
      this.checkCopilotToken = (_, env) => {
        env.code_quote_enabled ? this.output = this.createChannel() : this.output?.dispose();
      };
      this.tokenManager = this.ctx.get(CopilotTokenNotifier), this.tokenManager.on("onCopilotToken", this.checkCopilotToken), this.output = this.createChannel();
    }
    static {
      __name(this, "GitHubCopilotLogger");
    }
    static create(ctx) {
      return new _GitHubCopilotLogger(ctx);
    }
    createChannel() {
      return this.output ? this.output : new CodeReferenceOutputChannel(d0e.window.createOutputChannel(GitHubCopilotChannelName, "code-referencing"));
    }
    async log(type, ...messages) {
      this.output || (this.output = this.createChannel());
      let [base, ...rest] = messages;
      this.output[type](base, ...rest);
    }
    info(...messages) {
      this.log("info", ...messages);
    }
    forceShow() {
      this.output?.show(!0);
    }
    dispose() {
      this.output?.dispose();
    }
  };
var ErrorReasons = {
    BadArguments: "BadArgumentsError",
    Unauthorized: "NotAuthorized",
    NotFound: "NotFoundError",
    RateLimit: "RateLimitError",
    InternalError: "InternalError",
    ConnectionError: "ConnectionError",
    Unknown: "UnknownError"
  },
  ErrorMessages = {
    [ErrorReasons.Unauthorized]: "Invalid GitHub token. Please sign out from your GitHub account using VSCode UI and try again",
    [ErrorReasons.InternalError]: "Internal error: matches to public code will not be detected. It is advised to disable Copilot completions until the service is reconnected.",
    [ErrorReasons.RateLimit]: "You've reached your quota and limit, code matching will be unavailable until the limit resets"
  };
function getErrorType(code) {
  return code === 401 ? ErrorReasons.Unauthorized : code === 400 ? ErrorReasons.BadArguments : code === 404 ? ErrorReasons.NotFound : code === 429 ? ErrorReasons.RateLimit : code >= 500 && code < 600 ? ErrorReasons.InternalError : code >= 600 ? ErrorReasons.ConnectionError : ErrorReasons.Unknown;
}
__name(getErrorType, "getErrorType");
function createErrorResponse(code, msg, meta = {}) {
  return {
    kind: "failure",
    reason: getErrorType(Number(code)),
    code: Number(code),
    msg: msg,
    meta: meta
  };
}
__name(createErrorResponse, "createErrorResponse");
var TWIRP_URL = "twirp/github.snippy.v1.SnippyAPI";
function getSnippyDomain(ctx) {
  if (isProduction(ctx)) return ProdSnippyDomain;
  let overrideUrl;
  try {
    overrideUrl = getConfig(ctx, ConfigKey.DebugSnippyOverrideUrl);
  } catch {
    return ProdSnippyDomain;
  }
  return overrideUrl || ProdSnippyDomain;
}
__name(getSnippyDomain, "getSnippyDomain");
async function call(ctx, endpoint, config, signal) {
  let SNIPPY_BASE_URL = `${getSnippyDomain(ctx)}/${TWIRP_URL}`,
    token;
  try {
    token = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token;
  } catch {
    return ConnectionState.setDisconnected(), createErrorResponse(401, ErrorMessages[ErrorReasons.Unauthorized]);
  }
  if (codeReferenceLogger.info(ctx, `Calling ${endpoint}`), ConnectionState.isRetrying()) return createErrorResponse(600, "Attempting to reconnect to the public code matching service.");
  if (ConnectionState.isDisconnected()) return createErrorResponse(601, "The public code matching service is offline.");
  let res;
  try {
    res = await ctx.get(Fetcher).fetch(`${SNIPPY_BASE_URL}/${endpoint}`, {
      method: config.method,
      body: config.method === "POST" ? JSON.stringify(config.body) : void 0,
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${token}`,
        ...editorVersionHeaders(ctx)
      },
      signal: signal
    });
  } catch {
    return ConnectionState.enableRetry(ctx), createErrorResponse(602, "Network error detected. Check your internet connection.");
  }
  let payload;
  try {
    payload = await res.json();
  } catch (e) {
    let message = e.message;
    throw snippyTelemetry.handleUnexpectedError({
      context: ctx,
      origin: "snippyNetwork",
      reason: message
    }), e;
  }
  if (res.ok) return {
    kind: "success",
    ...payload
  };
  let errorPayload = {
      ...payload,
      code: Number(res.status)
    },
    {
      code: code,
      msg: msg,
      meta: meta
    } = errorPayload,
    formattedCode = Number(code),
    errorTypeFromCode = getErrorType(formattedCode),
    fallbackMsg = msg || "unknown error";
  switch (errorTypeFromCode) {
    case ErrorReasons.Unauthorized:
      return createErrorResponse(code, ErrorMessages[ErrorReasons.Unauthorized], meta);
    case ErrorReasons.BadArguments:
      return createErrorResponse(code, fallbackMsg, meta);
    case ErrorReasons.RateLimit:
      return ConnectionState.enableRetry(ctx, 60 * 1e3), createErrorResponse(code, ErrorMessages.RateLimitError, meta);
    case ErrorReasons.InternalError:
      return ConnectionState.enableRetry(ctx), createErrorResponse(code, ErrorMessages[ErrorReasons.InternalError], meta);
    default:
      return createErrorResponse(code, fallbackMsg, meta);
  }
}
__name(call, "call");
var import_typebox = Ns(ou()),
  MatchError = ba.Type.Object({
    kind: ba.Type.Literal("failure"),
    reason: ba.Type.String(),
    code: ba.Type.Number(),
    msg: ba.Type.String(),
    meta: ba.Type.Optional(ba.Type.Any())
  }),
  Snippet = ba.Type.Object({
    matched_source: ba.Type.String(),
    occurrences: ba.Type.String(),
    capped: ba.Type.Boolean(),
    cursor: ba.Type.String(),
    github_url: ba.Type.String()
  }),
  MatchRequest = ba.Type.Object({
    source: ba.Type.String()
  }),
  MatchSuccess = ba.Type.Object({
    snippets: ba.Type.Array(Snippet)
  }),
  MatchResponse = ba.Type.Union([MatchSuccess, MatchError]),
  FileMatchRequest = ba.Type.Object({
    cursor: ba.Type.String()
  }),
  FileMatch = ba.Type.Object({
    commit_id: ba.Type.String(),
    license: ba.Type.String(),
    nwo: ba.Type.String(),
    path: ba.Type.String(),
    url: ba.Type.String()
  }),
  PageInfo = ba.Type.Object({
    has_next_page: ba.Type.Boolean(),
    cursor: ba.Type.String()
  }),
  LicenseStats = ba.Type.Object({
    count: ba.Type.Record(ba.Type.String(), ba.Type.String())
  }),
  FileMatchSuccess = ba.Type.Object({
    file_matches: ba.Type.Array(FileMatch),
    page_info: PageInfo,
    license_stats: LicenseStats
  }),
  FileMatchResponse = ba.Type.Union([FileMatchSuccess, MatchError]);
async function Match(ctx, source, signal) {
  let result = await call(ctx, "Match", {
    method: "POST",
    body: assertShape(MatchRequest, {
      source: source
    })
  }, signal);
  return assertShape(MatchResponse, result);
}
__name(Match, "Match");
async function FilesForMatch(ctx, {
  cursor: cursor
}, signal) {
  let result = await call(ctx, "FilesForMatch", {
    method: "POST",
    body: assertShape(FileMatchRequest, {
      cursor: cursor
    })
  }, signal);
  return assertShape(FileMatchResponse, result);
}
__name(FilesForMatch, "FilesForMatch");
var pluralize = __name((count, noun, suffix = "s") => `${count} ${noun}${count !== 1 ? suffix : ""}`, "pluralize");
function isError(payload) {
  return x0e.Value.Check(MatchError, payload);
}
__name(isError, "isError");
async function snippyRequest(ctx, requestFn) {
  let res = await requestFn();
  if (isError(res)) {
    snippyTelemetry.handleSnippyNetworkError({
      context: ctx,
      origin: String(res.code),
      reason: res.reason,
      message: res.msg
    });
    return;
  }
  return res;
}
__name(snippyRequest, "snippyRequest");
function handlePostInsertion(githubLogger) {
  return async event => {
    let {
        ctx: ctx,
        completionText: completionText,
        completionId: completionId,
        start: start,
        fileURI: fileURI,
        insertionOffset: insertionOffset
      } = event,
      insertionDoc = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
    if (!insertionDoc) {
      codeReferenceLogger.debug(ctx, `Expected document matching ${fileURI}, got nothing.`);
      return;
    }
    if (!completionId || !start) {
      snippyTelemetry.handleCompletionMissing({
        context: ctx,
        origin: "onPostInsertion",
        reason: "No completion metadata found."
      });
      return;
    }
    let docText = insertionDoc.getText();
    if (!hasMinLexemeLength(docText)) return;
    let potentialMatchContext = completionText;
    if (!hasMinLexemeLength(completionText)) {
      let textWithoutCompletion = docText.slice(0, insertionOffset),
        minLexemeStartOffset = offsetLastLexemes(textWithoutCompletion, MinTokenLength);
      potentialMatchContext = docText.slice(minLexemeStartOffset, insertionOffset + completionText.length);
    }
    if (!hasMinLexemeLength(potentialMatchContext)) return;
    let matchResponse = await snippyRequest(ctx, () => Match(ctx, potentialMatchContext));
    if (!matchResponse || !matchResponse.snippets.length) {
      codeReferenceLogger.info(ctx, "No match found");
      return;
    }
    codeReferenceLogger.info(ctx, "Match found");
    let {
        snippets: snippets
      } = matchResponse,
      citationPromises = snippets.map(async snippet => {
        let response = await snippyRequest(ctx, () => FilesForMatch(ctx, {
          cursor: snippet.cursor
        }));
        if (!response) return;
        let files = response.file_matches,
          licenseStats = response.license_stats;
        return {
          match: snippet,
          files: files,
          licenseStats: licenseStats
        };
      });
    notify(ctx), Promise.all(citationPromises).then(citations => citations.filter(Boolean)).then(filtered => {
      if (filtered.length) for (let citation of filtered) {
        let licensesSet = new Set(Object.keys(citation.licenseStats?.count ?? {}));
        licensesSet.has("NOASSERTION") && (licensesSet.delete("NOASSERTION"), licensesSet.add("unknown"));
        let allLicenses = Array.from(licensesSet).sort(),
          matchLocation = `[Ln ${start.line}, Col ${start.character}]`,
          shortenedMatchText = `${citation.match.matched_source.slice(0, 100).replace(/[\r\n\t]+|^[ \t]+/gm, " ").trim()}...`,
          workspaceFolders = y3.workspace.workspaceFolders ?? [],
          fileName = fileURI.fsPath;
        for (let folder of workspaceFolders) if (fileURI.fsPath.startsWith(folder.uri.fsPath)) {
          fileName = fileURI.fsPath.replace(folder.uri.fsPath, "");
          break;
        }
        githubLogger.info(`'${fileName}'`, `Similar code with ${pluralize(allLicenses.length, "license type")}`, `[${allLicenses.join(", ")}]`, `${citation.match.github_url.replace(/,\s*$/, "")}&editor=vscode`, matchLocation, shortenedMatchText), copilotOutputLogTelemetry.handleWrite({
          context: ctx
        });
      }
    });
  };
}
__name(handlePostInsertion, "handlePostInsertion");
function registerPostInsertionListener(ctx) {
  let logger = GitHubCopilotLogger.create(ctx),
    initialNotificationCommand = y3.commands.registerCommand(OutputPaneShowCommand, () => logger.forceShow()),
    insertionNotificationHandler = handlePostInsertion(logger),
    notifier = ctx.get(PostInsertionNotifier);
  return notifier.on("onPostInsertion", insertionNotificationHandler), new y3.Disposable(() => {
    notifier.off("onPostInsertion", insertionNotificationHandler), initialNotificationCommand.dispose();
  });
}
__name(registerPostInsertionListener, "registerPostInsertionListener");
var CodeReference = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.onCopilotToken = (_, tokenEnvelope) => {
      if (!tokenEnvelope.code_quote_enabled) {
        ConnectionState.setDisabled(), this.subscriptions?.dispose(), this.subscriptions = void 0, codeReferenceLogger.debug(this.ctx, "Public code references are disabled.");
        return;
      }
      this.annotationsHeaderContributor.updateAnnotationsEnabled(tokenEnvelope.annotations_enabled), ConnectionState.setConnected(), codeReferenceLogger.info(this.ctx, "Public code references are enabled."), this.subscriptions || (this.subscriptions = E0e.Disposable.from(registerCopilotEnvelopeListener(this.ctx), registerPostInsertionListener(this.ctx), registerCodeRefEngagementTracker(this.ctx)));
    };
    this.tokenNotifier = ctx.get(CopilotTokenNotifier), this.annotationsHeaderContributor = new AnnotationsHeaderContributor();
  }
  static {
    __name(this, "CodeReference");
  }
  dispose() {
    this.subscriptions?.dispose(), this.ctx.get(HeaderContributors).remove(this.annotationsHeaderContributor), this.tokenNotifier.off("onCopilotToken", this.onCopilotToken);
  }
  register() {
    return isRunningInTest(this.ctx) || this.tokenNotifier.on("onCopilotToken", this.onCopilotToken), this.ctx.get(HeaderContributors).add(this.annotationsHeaderContributor), this;
  }
};
var vscode = Ns(require("vscode"));
var packageJson = rO();
function stringOrStringify(value) {
  return typeof value == "string" ? value : JSON.stringify(value);
}
__name(stringOrStringify, "stringOrStringify");
var VSCodeConfigProvider = class extends ConfigProvider {
    constructor() {
      super();
      this.config = Lc.workspace.getConfiguration(CopilotConfigPrefix), Lc.workspace.onDidChangeConfiguration(changeEvent => {
        changeEvent.affectsConfiguration(CopilotConfigPrefix) && (this.config = Lc.workspace.getConfiguration(CopilotConfigPrefix));
      });
    }
    static {
      __name(this, "VSCodeConfigProvider");
    }
    getConfigKeyFromObject(key, objectKey) {
      let value = this.config[key][objectKey];
      return value === void 0 ? getConfigDefaultForObjectKey(key, objectKey) : value;
    }
    getConfig(key) {
      if (Array.isArray(key)) return this.getConfigKeyFromObject(key[0], key[1]);
      let value = this.config.get(key);
      if (value === void 0) throw new Error(`Missing config default value: ${CopilotConfigPrefix}.${key}`);
      return value;
    }
    isDefaultSettingOverwritten(key) {
      if (Array.isArray(key)) return this.config[key[0]][key[1]] !== void 0;
      let inspection = this.config.inspect(key);
      return inspection ? !!inspection.globalValue || !!inspection.workspaceValue || !!inspection.workspaceFolderValue || !!inspection.defaultLanguageValue || !!inspection.globalLanguageValue || !!inspection.workspaceLanguageValue || !!inspection.workspaceFolderLanguageValue : !1;
    }
    dumpConfig() {
      let configProperties = {};
      try {
        let extensionConfigProps = packageJson.contributes.configuration[0].properties;
        for (let key in extensionConfigProps) {
          let value = key.replace(`${CopilotConfigPrefix}.`, "").split(".").reduce((o, i) => o[i], this.config);
          typeof value == "object" && value !== null ? Object.keys(value).filter(k => k !== "secret_key").forEach(k => configProperties[`${key}.${k}`] = stringOrStringify(value[k])) : configProperties[key] = stringOrStringify(value);
        }
      } catch (ex) {
        console.error(`Failed to retrieve configuration properties ${ex}`);
      }
      return configProperties;
    }
    getLanguageConfig(key, language) {
      let obj = this.getConfig(key);
      if (language === void 0) {
        let editor = Lc.window.activeTextEditor;
        language = editor && editor.document.languageId;
      }
      return obj?.[language ?? "*"] ?? obj?.["*"];
    }
    updateEnabledConfig(ctx, language, enabled) {
      let updatedConfig = ctx.get(ConfigProvider).getConfig(ConfigKey.Enable);
      return updatedConfig[language] = enabled, this.config.update(ConfigKey.Enable, updatedConfig, !0);
    }
  },
  telemetryAllowedAuthorities = new Set(["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"]),
  VSCodeEditorInfo = class extends EditorAndPluginInfo {
    static {
      __name(this, "VSCodeEditorInfo");
    }
    getEditorInfo() {
      let remoteName = Lc.env.remoteName;
      return {
        name: "vscode",
        version: Lc.version,
        root: Lc.env.appRoot,
        remoteName: remoteName && (telemetryAllowedAuthorities.has(remoteName) ? remoteName : "other")
      };
    }
    getEditorPluginInfo() {
      return {
        name: "copilot",
        version: packageJson.version
      };
    }
  };
async function toggleCopilotEnablement(ctx, scope) {
  let configProvider = ctx.get(ConfigProvider),
    isEnabled = getEnabledConfig(ctx) || !1,
    currentLanguage = Lc.window.activeTextEditor?.document.languageId;
  isEnabled && Lc.commands.executeCommand("editor.action.inlineSuggest.hide"), scope === "global" ? await configProvider.updateEnabledConfig(ctx, "*", !getEnabledConfig(ctx, "*")) : await configProvider.updateEnabledConfig(ctx, currentLanguage || "*", !isEnabled);
}
__name(toggleCopilotEnablement, "toggleCopilotEnablement");
var CMDOpenPanel = "github.copilot.generate",
  CMDOpenPanelForRange = "github.copilot.openPanelForRange",
  CMDAcceptPanelSolution = "github.copilot.acceptPanelSolution",
  CMDToggleCopilot = "github.copilot.toggleCopilot",
  CMDToggleStatusMenu = "github.copilot.toggleStatusMenu",
  CMDSendFeedback = "github.copilot.sendFeedback",
  CMDOpenDocumentation = "github.copilot.openDocs",
  CMDCollectDiagnostics = "github.copilot.collectDiagnostics",
  CMDSignIn = "github.copilot.signIn",
  CMDOpenLogs = "github.copilot.openLogs",
  CMDAcceptCursorPanelSolution = "github.copilot.acceptCursorPanelSolution",
  CMDNavigatePreviousPanelSolution = "github.copilot.previousPanelSolution",
  CMDNavigateNextPanelSolution = "github.copilot.nextPanelSolution",
  CopilotPanelVisible = "github.copilot.panelVisible";
var import_vscode = require("vscode");
var import_vscode = require("vscode");
var solutionsLogger = new Logger(1, "solutions");
async function* prependChoices(choices, prefix) {
  for await (let choice of choices) {
    let choiceCopy = {
      ...choice
    };
    choiceCopy.completionText = prefix + choiceCopy.completionText.trimRight(), yield choiceCopy;
  }
}
__name(prependChoices, "prependChoices");
function normalizeCompletionText(text) {
  return text.replace(/\s+/g, "");
}
__name(normalizeCompletionText, "normalizeCompletionText");
async function launchSolutions(ctx, solutionManager) {
  let insertPosition = solutionManager.completionContext.insertPosition,
    prependToCompletion = solutionManager.completionContext.prependToCompletion,
    indentation = solutionManager.completionContext.indentation,
    locationFactory = ctx.get(LocationFactory),
    document = await solutionManager.getDocument(),
    documentSource = document.getText(),
    positionOffset = document.offsetAt(insertPosition),
    actualSuffix = documentSource.substring(positionOffset),
    promptResponse = await extractPrompt(ctx, document, insertPosition);
  if (promptResponse.type === "copilotNotAvailable") return solutionManager.reportCancelled(), {
    status: "FinishedNormally"
  };
  if (promptResponse.type === "contextTooShort") return solutionManager.reportCancelled(), {
    status: "FinishedWithError",
    error: "Context too short"
  };
  let prompt = promptResponse.prompt,
    trailingWs = promptResponse.trailingWs;
  trailingWs.length > 0 && (solutionManager.startPosition = locationFactory.position(solutionManager.startPosition.line, solutionManager.startPosition.character - trailingWs.length));
  let cancellationToken = solutionManager.getCancellationToken(),
    ourRequestId = v4_default();
  solutionManager.savedTelemetryData = TelemetryData.createAndMarkAsIssued({
    headerRequestId: ourRequestId,
    languageId: document.languageId,
    source: completionTypeToString(solutionManager.completionContext.completionType)
  }, {
    ...telemetrizePromptLength(prompt),
    solutionCount: solutionManager.solutionCountTarget,
    promptEndPos: document.offsetAt(insertPosition)
  }), solutionsLogger.info(ctx, `prompt: ${JSON.stringify(prompt)}`), solutionsLogger.debug(ctx, `prependToCompletion: ${prependToCompletion}`), telemetry(ctx, "solution.requested", solutionManager.savedTelemetryData);
  let blockMode = await ctx.get(BlockModeConfig).forLanguage(ctx, document.languageId),
    isSupportedLanguage = promptLibProxy.isSupportedLanguageId(document.languageId),
    contextIndent = contextIndentation(document, insertPosition),
    postOptions = {
      stream: !0,
      extra: {
        language: document.languageId,
        next_indent: contextIndent.next ?? 0,
        prompt_tokens: prompt.prefixTokens ?? 0,
        suffix_tokens: prompt.suffixTokens ?? 0
      }
    };
  blockMode === "parsing" && !isSupportedLanguage && (postOptions.stop = [`

`, `\r
\r
`]);
  let repoInfo = extractRepoInfoInBackground(ctx, document.uri),
    completionParams = {
      prompt: prompt,
      languageId: document.languageId,
      repoInfo: repoInfo,
      ourRequestId: ourRequestId,
      engineUrl: await getEngineURL(ctx, tryGetGitHubNWO(repoInfo) ?? "", document.languageId, getDogFood(repoInfo), await getUserKind(ctx), await getFtFlag(ctx), await getRagFlag(ctx), solutionManager.savedTelemetryData),
      count: solutionManager.solutionCountTarget,
      uiKind: "synthesize",
      postOptions: postOptions,
      requestLogProbs: !0
    },
    finishedCb;
  switch (blockMode) {
    case "server":
      finishedCb = __name(async text => {}, "finishedCb"), postOptions.extra.force_indent = contextIndent.prev ?? -1, postOptions.extra.trim_by_indentation = !0;
      break;
    case "parsingandserver":
      finishedCb = isSupportedLanguage ? parsingBlockFinished(ctx, document, solutionManager.startPosition) : async text => {}, postOptions.extra.force_indent = contextIndent.prev ?? -1, postOptions.extra.trim_by_indentation = !0;
      break;
    case "parsing":
    default:
      finishedCb = isSupportedLanguage ? parsingBlockFinished(ctx, document, solutionManager.startPosition) : async text => {};
      break;
  }
  ctx.get(StatusReporter).setProgress();
  let res = await ctx.get(OpenAIFetcher).fetchAndStreamCompletions(ctx, completionParams, TelemetryData.createAndMarkAsIssued(), finishedCb, cancellationToken);
  if (res.type === "failed" || res.type === "canceled") return solutionManager.reportCancelled(), ctx.get(StatusReporter).removeProgress(), {
    status: "FinishedWithError",
    error: `${res.type}: ${res.reason}`
  };
  let choices = res.choices;
  choices = prependChoices(choices, prependToCompletion), indentation !== null && (choices = cleanupIndentChoices(choices, indentation)), choices = asyncIterableMapFilter(choices, async choice => postProcessChoice(ctx, "solution", document, insertPosition, choice, !1, solutionsLogger, promptResponse.prompt, actualSuffix));
  let solutions = asyncIterableMapFilter(choices, async apiChoice => {
    let display = apiChoice.completionText;
    if (solutionsLogger.info(ctx, `Open Copilot completion: [${apiChoice.completionText}]`), solutionManager.completionContext.completionType === 2) {
      let displayBefore = "",
        displayStartPos = await getNodeStart(ctx, document, insertPosition, apiChoice.completionText);
      if (displayStartPos) [displayBefore] = trimLastLine(document.getText(locationFactory.range(locationFactory.position(displayStartPos.line, displayStartPos.character), insertPosition)));else {
        let displayStartPos = locationFactory.position(insertPosition.line, 0);
        displayBefore = document.getText(locationFactory.range(displayStartPos, insertPosition));
      }
      display = displayBefore + display;
    }
    let completionText = apiChoice.completionText;
    trailingWs.length > 0 && completionText.startsWith(trailingWs) && (completionText = completionText.substring(trailingWs.length));
    let meanLogProb = apiChoice.meanLogProb,
      meanProb = meanLogProb !== void 0 ? Math.exp(meanLogProb) : 0,
      docVersion = (await solutionManager.getDocument()).version;
    return {
      displayText: display,
      meanProb: meanProb,
      meanLogProb: meanLogProb || 0,
      completionText: completionText,
      requestId: apiChoice.requestId,
      choiceIndex: apiChoice.choiceIndex,
      prependToCompletion: prependToCompletion,
      docVersion: docVersion
    };
  });
  return generateSolutionsStream(ctx.get(StatusReporter), cancellationToken, solutions[Symbol.asyncIterator]());
}
__name(launchSolutions, "launchSolutions");
async function generateSolutionsStream(statusReporter, cancellationToken, solutions) {
  if (cancellationToken.isCancellationRequested) return statusReporter.removeProgress(), {
    status: "FinishedWithError",
    error: "Cancelled"
  };
  let nextResult = await solutions.next();
  return nextResult.done === !0 ? (statusReporter.removeProgress(), {
    status: "FinishedNormally"
  }) : {
    status: "Solution",
    solution: nextResult.value,
    next: generateSolutionsStream(statusReporter, cancellationToken, solutions)
  };
}
__name(generateSolutionsStream, "generateSolutionsStream");
var CopilotListDocument = class _CopilotListDocument {
  constructor(ctx, uri, targetDocument, completionContext, solutionCount, token) {
    this.targetDocument = targetDocument;
    this.completionContext = completionContext;
    this.token = token;
    this._solutionCount = 0;
    this.solutionCountTarget = 0;
    this._solutions = [];
    this._wasCancelled = !1;
    this._updateHandlers = new Set();
    this.savedTelemetryData = TelemetryData.createAndMarkAsIssued();
    this.debouncedEventFire = debounce(10, () => this._updateHandlers.forEach(handler => handler(this._uri)));
    this.onDidResultUpdated = listener => (this._updateHandlers.add(listener), {
      dispose: () => {
        this._updateHandlers.delete(listener);
      }
    });
    this.solutionCountTarget = solutionCount, this._ctx = ctx, this._uri = uri, this._showLogprobs = getConfig(ctx, ConfigKey.DebugShowScores), this.startPosition = this.completionContext.insertPosition;
  }
  static {
    __name(this, "CopilotListDocument");
  }
  static {
    this.separator = `
=======`;
  }
  static {
    this.suggestionHeaderPrefix = "Suggestion ";
  }
  async getDocument() {
    return this.targetDocument;
  }
  get targetUri() {
    return this.targetDocument.uri;
  }
  get numberHeaderLines() {
    return this.header().split(`
`).length + 1;
  }
  header() {
    if (this._wasCancelled) return "No synthesized solutions found.";
    {
      let suffix = this._solutionCount - this._solutions.length > 0 ? " (Duplicates hidden)" : "";
      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${suffix}`;
    }
  }
  areSolutionsDuplicates(solutionA, solutionB) {
    let stripA = normalizeCompletionText(solutionA.completionText),
      stripB = normalizeCompletionText(solutionB.completionText);
    return stripA === stripB;
  }
  insertSorted(list, newItem, keyFn) {
    if (!/^\s*$/.test(newItem.completionText)) {
      for (let i = 0; i < list.length; i++) {
        let item = list[i];
        if (this.areSolutionsDuplicates(item, newItem)) if (keyFn(item) < keyFn(newItem)) {
          list.splice(i, 1);
          break;
        } else return;
      }
      for (let i = 0; i < list.length; i++) {
        let item = list[i];
        if (keyFn(item) < keyFn(newItem)) {
          list.splice(i, 0, newItem);
          return;
        }
      }
      list.push(newItem);
    }
  }
  reportCancelled() {
    this._wasCancelled = !0, this.debouncedEventFire();
  }
  getCancellationToken() {
    return this.token;
  }
  insertSolution(unformatted) {
    let newItem = {
        displayLines: this.formatDisplayLines(unformatted.displayText, unformatted.meanProb, unformatted.meanLogProb),
        completionText: unformatted.completionText,
        meanLogProb: unformatted.meanLogProb,
        meanProb: unformatted.meanProb,
        prependToCompletion: unformatted.prependToCompletion,
        requestId: unformatted.requestId,
        choiceIndex: unformatted.choiceIndex
      },
      keyFn = __name(item => item.meanProb, "keyFn");
    this.insertSorted(this._solutions, newItem, keyFn), this._solutionCount++, this.debouncedEventFire();
  }
  formatDisplayLines(displayText, meanProb, meanLogProb) {
    let optionalPrefix = "";
    return this._showLogprobs && (meanLogProb = meanLogProb || 0, optionalPrefix += `
	# mean prob: ${meanProb}`), `${_CopilotListDocument.separator}${optionalPrefix}
${_CopilotListDocument.suggestionHeaderPrefix}

${displayText}`.split(`
`);
  }
  async runQuery() {
    let firstSolution = await this.launchSolutions();
    this.processNextSolution(firstSolution);
  }
  launchSolutions() {
    return launchSolutions(this._ctx, this);
  }
  async processNextSolution(nextSolution) {
    switch (nextSolution.status) {
      case "FinishedNormally":
      case "FinishedWithError":
        return;
      case "Solution":
        this.insertSolution(nextSolution.solution), this.processNextSolution(await nextSolution.next);
        break;
    }
  }
  solutionsReceived() {
    return this._solutionCount;
  }
  solutions() {
    return this._solutions;
  }
  get value() {
    let solutionsWithItemHeaders = this._solutions.flatMap((solution, index) => {
      let displayLines = solution.displayLines,
        sepIndex = displayLines.findIndex(line => line === _CopilotListDocument.separator.trim());
      if (sepIndex === -1) return displayLines;
      let itemHeader = `Suggestion ${index + 1}`,
        hasHeader = displayLines[sepIndex + 1].startsWith(_CopilotListDocument.suggestionHeaderPrefix);
      return displayLines.splice(sepIndex + 1, hasHeader ? 1 : 0, itemHeader), displayLines;
    });
    return [this.header()].concat(solutionsWithItemHeaders).concat("").join(`
`);
  }
};
var CopilotPanel = class {
  constructor(ctx) {
    this._onDidChange = new T0.EventEmitter();
    this._documents = new Map();
    this.panelSolutions = new Map();
    this._previousPositions = [];
    this._ctx = ctx, this._closeSubscription = T0.workspace.onDidCloseTextDocument(doc => {
      doc.isClosed && doc.uri.scheme == CopilotPanelScheme && (this._documents.delete(doc.uri.toString()), this.panelSolutions.delete(doc.uri.toString()));
    }), this._changeSubscription = T0.window.onDidChangeVisibleTextEditors(editors => {
      editors.some(editor => editor.document.uri.scheme == CopilotPanelScheme) || T0.commands.executeCommand("setContext", CopilotPanelVisible, !1);
    }), this._didChangeEditorSelection = T0.window.onDidChangeTextEditorSelection(event => {
      if (event.textEditor.document.uri.scheme == CopilotPanelScheme) {
        let currentPosition = event.textEditor.selection.active;
        this._previousPositions.push(currentPosition), this._previousPositions.length > 2 && this._previousPositions.shift();
      }
    }), this._didChangeVisibleRanges = T0.window.onDidChangeTextEditorVisibleRanges(event => {
      if (event.textEditor.document.uri.scheme == CopilotPanelScheme) {
        let positionBeforeChange = this._previousPositions[0];
        if (!positionBeforeChange) return;
        this.resetCursorPositionToEndOfFirstLine(positionBeforeChange);
      }
    });
  }
  static {
    __name(this, "CopilotPanel");
  }
  dispose() {
    this._closeSubscription.dispose(), this._changeSubscription.dispose(), this._documents.clear(), this.panelSolutions.clear(), this._onDidChange.dispose(), this._didChangeVisibleRanges.dispose(), this._didChangeEditorSelection.dispose();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  async provideTextDocumentContent(uri) {
    let document = this._documents.get(uri.toString()),
      model = document?.model;
    if (document && model) return this.getTextDocumentContent(document, uri);
    let cts = new T0.CancellationTokenSource(),
      [targetUri, completionContext] = decodeLocation(this._ctx, uri),
      targetDocument = await T0.workspace.openTextDocument(targetUri);
    return model = new CopilotListDocument(this._ctx, uri, targetDocument, completionContext, getConfig(this._ctx, ConfigKey.ListCount), cts.token), model.onDidResultUpdated(uri => {
      this._onDidChange.fire(uri);
    }), document = {
      model: model,
      cts: cts
    }, this._documents.set(uri.toString(), document), model.runQuery(), this.getTextDocumentContent(document, uri);
  }
  getTextDocumentContent(document, uri) {
    return this.generatePanelSolutionInfo(document, uri), document.model.value;
  }
  generatePanelSolutionInfo(info, uri) {
    let model = info.model,
      lineCount = model.numberHeaderLines,
      insertPosition = model.completionContext.insertPosition,
      separatorLineCount = CopilotListDocument.separator.split(`
`).length - 1,
      panelSolutions = model.solutions().map((solution, index) => {
        let startPos = new T0.Position(lineCount + separatorLineCount - 1, 0),
          endPos = new T0.Position(startPos.line + solution.displayLines.length, 0),
          telemetryData = model.savedTelemetryData.extendedBy({
            choiceIndex: solution.choiceIndex.toString()
          }, {
            compCharLen: solution.completionText.length,
            meanProb: solution.meanProb,
            rank: index
          });
        telemetryData.extendWithRequestId(solution.requestId), telemetryData.markAsDisplayed();
        let postInsertionCallback = __name(async () => {
            let offset = (await T0.workspace.openTextDocument(model.targetUri)).offsetAt(insertPosition);
            info.cts.cancel(), await postInsertionTasks(this._ctx, "solution", solution.completionText, offset, model.targetUri, telemetryData, `${solution.requestId.headerRequestId}-${index}`, insertPosition);
          }, "postInsertionCallback"),
          range = new T0.Range(startPos, endPos);
        return lineCount = endPos.line, {
          targetUri: model.targetUri,
          range: range,
          insertPosition: insertPosition,
          completionText: solution.completionText,
          postInsertionCallback: postInsertionCallback
        };
      });
    return this.panelSolutions.set(uri.toString(), panelSolutions), panelSolutions;
  }
  getCodeLens(info, uri) {
    return (this.panelSolutions.get(uri.toString()) ?? this.generatePanelSolutionInfo(info, uri)).map(solution => new T0.CodeLens(solution.range, {
      title: "Accept Solution",
      tooltip: "Replace code with this solution",
      command: CMDAcceptPanelSolution,
      arguments: [solution.targetUri, solution.insertPosition, solution.completionText, solution.postInsertionCallback]
    }));
  }
  provideCodeLenses(document, token) {
    let doc = this._documents.get(document.uri.toString());
    if (doc) return this.getCodeLens(doc, document.uri);
  }
  resetCursorPositionToEndOfFirstLine(previousPosition) {
    let activeEditor = T0.window.activeTextEditor;
    if (activeEditor === void 0) return;
    let document = activeEditor.document,
      endFirstLinePosition = document.lineAt(0).range.end,
      onSecondLine = !1;
    if (document.lineCount > 1) {
      let endSecondLinePosition = document.lineAt(1).range.end;
      onSecondLine = previousPosition.line == endSecondLinePosition?.line && previousPosition.character == endSecondLinePosition?.character;
    }
    (previousPosition.line == endFirstLinePosition.line && previousPosition.character == endFirstLinePosition.character || onSecondLine) && (activeEditor.selection = new T0.Selection(previousPosition, previousPosition));
  }
};
function completionContextForEditor(ctx, editor, completionContext) {
  return completionContext || completionContextForDocument(ctx, editor.document, editor.selection.active);
}
__name(completionContextForEditor, "completionContextForEditor");
function registerPanelSupport(ctx) {
  registerCommandWithTelemetry(ctx, CMDOpenPanel, () => {
    za.commands.executeCommand("editor.action.inlineSuggest.hide"), commandOpenPanel(ctx);
  }), registerCommandWithTelemetry(ctx, CMDAcceptCursorPanelSolution, () => {
    commandAcceptPanelSolution(ctx);
  }), registerCommandWithTelemetry(ctx, CMDNavigatePreviousPanelSolution, () => {
    commandNavigateToPanelSolution(ctx, "previous");
  }), registerCommandWithTelemetry(ctx, CMDNavigateNextPanelSolution, () => {
    commandNavigateToPanelSolution(ctx, "next");
  }), registerCommandWithTelemetry(ctx, CMDOpenPanelForRange, completionContext => {
    commandOpenPanel(ctx, completionContext);
  }), registerCommandWithTelemetry(ctx, CMDAcceptPanelSolution, async (targetUri, insertPosition, solution, postInsertionCallback) => {
    let edit = new za.WorkspaceEdit();
    edit.insert(targetUri, insertPosition, solution), await za.workspace.applyEdit(edit), postInsertionCallback(), await za.commands.executeCommand("workbench.action.closeActiveEditor");
  });
  let contentProvider = new CopilotPanel(ctx);
  ctx.get(Extension).register(za.workspace.registerTextDocumentContentProvider(CopilotPanelScheme, contentProvider), za.languages.registerCodeLensProvider({
    scheme: CopilotPanelScheme
  }, contentProvider)), ctx.set(CopilotPanel, contentProvider);
}
__name(registerPanelSupport, "registerPanelSupport");
function commandOpenPanel(ctx, completionContext) {
  let editor = za.window.activeTextEditor;
  if (!editor) return;
  if (!za.workspace.getConfiguration("editor", editor.document.uri).get("codeLens")) {
    za.window.showInformationMessage("GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.", "Open Settings").then(selection => {
      selection === "Open Settings" && za.commands.executeCommand("workbench.action.openSettings", "editor.codeLens");
    });
    return;
  }
  completionContext = completionContextForEditor(ctx, editor, completionContext);
  let uri = encodeLocation(editor.document.uri, completionContext),
    languageId = editor.document.languageId;
  za.workspace.openTextDocument(uri).then(doc => {
    za.languages.setTextDocumentLanguage(doc, languageId), za.window.showTextDocument(doc, za.ViewColumn.Beside), za.commands.executeCommand("setContext", CopilotPanelVisible, !0);
  });
}
__name(commandOpenPanel, "commandOpenPanel");
function shouldExecutePanelCommand(ctx) {
  let editor = za.window.activeTextEditor;
  if (!editor) return !1;
  let document = editor.document;
  if (!document.uri.scheme.startsWith(CopilotPanelScheme)) return !1;
  let solutions = ctx.get(CopilotPanel).panelSolutions.get(document.uri.toString());
  return !(!solutions || solutions?.length === 0);
}
__name(shouldExecutePanelCommand, "shouldExecutePanelCommand");
function commandAcceptPanelSolution(ctx) {
  if (!shouldExecutePanelCommand(ctx)) return;
  let editor = za.window.activeTextEditor,
    solutions = ctx.get(CopilotPanel).panelSolutions.get(editor.document.uri.toString()) ?? [],
    cursorPosition = editor.selection.active,
    chosenSolution = solutions.find(solution => solution.range.contains(cursorPosition));
  chosenSolution && za.commands.executeCommand(CMDAcceptPanelSolution, chosenSolution.targetUri, chosenSolution.insertPosition, chosenSolution.completionText, chosenSolution.postInsertionCallback);
}
__name(commandAcceptPanelSolution, "commandAcceptPanelSolution");
function commandNavigateToPanelSolution(ctx, navigationType) {
  if (!shouldExecutePanelCommand(ctx)) return;
  let editor = za.window.activeTextEditor,
    solutions = ctx.get(CopilotPanel).panelSolutions.get(editor.document.uri.toString()) ?? [],
    cursorPosition = editor.selection.active,
    chosenSolution = findPrevNextSolution(solutions, cursorPosition, navigationType),
    headerLine = chosenSolution.range.start.line + 1,
    {
      text: text
    } = editor.document.lineAt(headerLine);
  editor.selection = new za.Selection(new za.Position(headerLine, 0), new za.Position(headerLine, text.length)), editor.revealRange(chosenSolution.range);
}
__name(commandNavigateToPanelSolution, "commandNavigateToPanelSolution");
function findPrevNextSolution(solutions, cursorPosition, navigationType) {
  let navPrevious = navigationType === "previous",
    currentSolutionIndex = solutions.findIndex(solution => solution.range.contains(cursorPosition)),
    prevNextSolutionIndex = navPrevious ? currentSolutionIndex - 1 : currentSolutionIndex + 1;
  return currentSolutionIndex === -1 && (prevNextSolutionIndex = navPrevious ? -1 : 0), solutions.at(prevNextSolutionIndex) ?? solutions[0];
}
__name(findPrevNextSolution, "findPrevNextSolution");
var import_vscode = require("vscode");
var os = Ns(require("os")),
  tls = Ns(require("tls"));
async function collectDiagnostics(ctx) {
  return {
    sections: [collectCopilotSection(ctx), collectEnvironmentSection(), await collectFeatureFlagsSection(ctx), collectNodeSection(), collectNetworkConfigSection(ctx), await collectReachabilitySection(ctx)]
  };
}
__name(collectDiagnostics, "collectDiagnostics");
function formatDiagnosticsAsMarkdown(data) {
  return data.sections.map(formatSectionAsMarkdown).join(Hu.EOL + Hu.EOL);
}
__name(formatDiagnosticsAsMarkdown, "formatDiagnosticsAsMarkdown");
function collectCopilotSection(ctx) {
  return {
    name: "Copilot",
    items: {
      Version: getVersion(ctx),
      Build: getBuildType(ctx),
      Editor: editorVersionHeaders(ctx)["Editor-Version"]
    }
  };
}
__name(collectCopilotSection, "collectCopilotSection");
function collectEnvironmentSection() {
  return {
    name: "Environment",
    items: {
      http_proxy: findEnvironmentVariable("http_proxy"),
      https_proxy: findEnvironmentVariable("https_proxy"),
      no_proxy: findEnvironmentVariable("no_proxy"),
      SSL_CERT_FILE: findEnvironmentVariable("SSL_CERT_FILE"),
      SSL_CERT_DIR: findEnvironmentVariable("SSL_CERT_DIR"),
      OPENSSL_CONF: findEnvironmentVariable("OPENSSL_CONF")
    }
  };
}
__name(collectEnvironmentSection, "collectEnvironmentSection");
function collectNodeSection() {
  return {
    name: "Node setup",
    items: {
      "Number of root certificates": b3.rootCertificates.length,
      "Operating system": Hu.type(),
      "Operating system version": Hu.release(),
      "Operating system architecture": Hu.arch(),
      NODE_OPTIONS: findEnvironmentVariable("NODE_OPTIONS"),
      NODE_EXTRA_CA_CERTS: findEnvironmentVariable("NODE_EXTRA_CA_CERTS"),
      NODE_TLS_REJECT_UNAUTHORIZED: findEnvironmentVariable("NODE_TLS_REJECT_UNAUTHORIZED"),
      "tls default min version": b3.DEFAULT_MIN_VERSION,
      "tls default max version": b3.DEFAULT_MAX_VERSION
    }
  };
}
__name(collectNodeSection, "collectNodeSection");
async function collectFeatureFlagsSection(ctx) {
  let ssc = "",
    rt = "";
  try {
    let token = await ctx.get(CopilotTokenManager).getCopilotToken(ctx);
    ssc = token.getTokenValue("ssc") === "1" ? "enabled" : "disabled", rt = token.getTokenValue("rt") === "1" ? "enabled" : "disabled";
  } catch {
    ssc = rt = "unable to determine";
  }
  return {
    name: "Feature Flags",
    items: {
      "Custom Certificates": ssc,
      "Send Restricted Telemetry": rt
    }
  };
}
__name(collectFeatureFlagsSection, "collectFeatureFlagsSection");
function collectNetworkConfigSection(ctx) {
  let fetcher = ctx.get(Fetcher);
  return {
    name: "Network Configuration",
    items: {
      "Proxy host": fetcher.proxySettings?.host,
      "Proxy port": fetcher.proxySettings?.port,
      "Proxy auth": fetcher.proxySettings?.proxyAuth,
      "Kerberos SPN": fetcher.proxySettings?.kerberosServicePrincipal,
      "Reject unauthorized": fetcher.rejectUnauthorized ? "enabled" : "disabled"
    }
  };
}
__name(collectNetworkConfigSection, "collectNetworkConfigSection");
async function collectReachabilitySection(ctx) {
  return {
    name: "Reachability",
    items: {
      "github.com": await determineReachability(ctx, "https://github.com"),
      "copilot-proxy.githubusercontent.com": await determineReachability(ctx, "https://copilot-proxy.githubusercontent.com/_ping"),
      "default.exp-tas.com": await determineReachability(ctx, "https://default.exp-tas.com/vscode/ab")
    }
  };
}
__name(collectReachabilitySection, "collectReachabilitySection");
async function determineReachability(ctx, url) {
  try {
    let response = await ctx.get(Fetcher).fetch(url, {});
    return `HTTP ${response.status} - ${response.statusText}`;
  } catch (err) {
    return err.message;
  }
}
__name(determineReachability, "determineReachability");
function findEnvironmentVariable(name) {
  let key = Object.keys(process.env).find(k => k.toLowerCase() === name.toLowerCase());
  return key ? process.env[key] : void 0;
}
__name(findEnvironmentVariable, "findEnvironmentVariable");
function formatSectionAsMarkdown(s) {
  return `## ${s.name}` + Hu.EOL + Hu.EOL + Object.keys(s.items).filter(k => k !== "name").map(k => `- ${k}: ${s.items[k] ?? "n/a"}`).join(Hu.EOL);
}
__name(formatSectionAsMarkdown, "formatSectionAsMarkdown");
async function openDiagnosticReport(ctx) {
  let installationCheck = __name(name => wh.extensions.getExtension(name) !== void 0, "installationCheck"),
    reportData = await new DiagnosticReport(installationCheck).collectData(ctx),
    report = formatDiagnosticsAsMarkdown(reportData),
    doc = await wh.workspace.openTextDocument({
      language: "markdown",
      content: report
    });
  await wh.window.showTextDocument(doc);
}
__name(openDiagnosticReport, "openDiagnosticReport");
var DiagnosticReport = class {
  static {
    __name(this, "DiagnosticReport");
  }
  constructor(installationCheck) {
    this.isExtensionInstalled = installationCheck;
  }
  async collectData(ctx) {
    return {
      sections: [...(await collectDiagnostics(ctx)).sections, this.collectConfigurationSection(), this.collectExtensionSection(ctx)]
    };
  }
  collectConfigurationSection() {
    return {
      name: "VS Code Configuration",
      items: {
        "HTTP proxy": this.findVsCodeConfiguration("http", "proxy"),
        "HTTP proxy autentication": this.findVsCodeConfiguration("http", "proxyAuthorization"),
        "Proxy Strict SSL": this.findVsCodeConfiguration("http", "proxyStrictSSL"),
        "Extension HTTP proxy support": this.findVsCodeConfiguration("http", "proxySupport")
      }
    };
  }
  collectExtensionSection(ctx) {
    return {
      name: "Extensions",
      items: {
        "Is `win-ca` installed?": this.isExtensionInstalled("ukoloff.win-ca"),
        "Is `mac-ca` installed?": this.isExtensionInstalled("linhmtran168.mac-ca-vscode")
      }
    };
  }
  findVsCodeConfiguration(section, name) {
    return wh.workspace.getConfiguration(section).get(name);
  }
};
var vscode = Ns(require("vscode"));
var VSCodeEditorExperimentFilters = class extends EditorExperimentFilters {
  static {
    __name(this, "VSCodeEditorExperimentFilters");
  }
  addEditorSpecificFilters() {
    return {
      "X-VSCode-Build": DD.env.appName,
      "X-VSCode-Language": DD.env.language
    };
  }
};
var CopilotExtensionStatus = class {
  constructor(status = "Normal", errorMessage) {
    this.status = status;
    this.errorMessage = errorMessage;
  }
  static {
    __name(this, "CopilotExtensionStatus");
  }
};
var import_vscode = require("vscode");
var import_copilot_promptlib = Ns(Dc());
function fakeAPIChoice(headerRequestId, choiceIndex, completionText, telemetryData = TelemetryData.createAndMarkAsIssued()) {
  let tokenizer = (0, j0e.getTokenizer)();
  return {
    completionText: completionText,
    meanLogProb: .5,
    meanAlternativeLogProb: .5,
    modelInfo: void 0,
    numTokens: -1,
    choiceIndex: choiceIndex,
    requestId: {
      headerRequestId: headerRequestId,
      completionId: v4_default(),
      created: 0,
      serverExperiments: "dummy",
      deploymentId: "dummy"
    },
    telemetryData: telemetryData,
    tokens: tokenizer.tokenize(completionText).map(token => tokenizer.detokenize([token])).concat()
  };
}
__name(fakeAPIChoice, "fakeAPIChoice");
async function* fakeAPIChoices(postOptions, finishedCb, completions, telemetryData) {
  let fakeHeaderRequestId = v4_default(),
    choiceIndex = 0;
  for (let completion of completions) {
    let stopOffset = -1;
    if (postOptions?.stop !== void 0) for (let stopToken of postOptions.stop) {
      let thisStopOffset = completion.indexOf(stopToken);
      thisStopOffset !== -1 && (stopOffset === -1 || thisStopOffset < stopOffset) && (stopOffset = thisStopOffset);
    }
    stopOffset !== -1 && (completion = completion.substring(0, stopOffset));
    let finishOffset = await finishedCb(completion);
    finishOffset !== void 0 && (completion = completion.substring(0, finishOffset));
    let choice = fakeAPIChoice(fakeHeaderRequestId, choiceIndex++, completion, telemetryData);
    choice.blockFinished = finishOffset !== void 0, yield choice;
  }
}
__name(fakeAPIChoices, "fakeAPIChoices");
function fakeResponse(completions, finishedCb, postOptions, allowEmptyChoices, telemetryData) {
  return {
    type: "success",
    choices: postProcessChoices(fakeAPIChoices(postOptions, finishedCb, completions, telemetryData), allowEmptyChoices),
    getProcessingTime: () => 0
  };
}
__name(fakeResponse, "fakeResponse");
var SyntheticCompletions = class extends OpenAIFetcher {
  constructor(_completions) {
    super();
    this._completions = _completions;
    this._wasCalled = !1;
  }
  static {
    __name(this, "SyntheticCompletions");
  }
  async fetchAndStreamCompletions(ctx, params, baseTelemetryData, finishedCb, cancel, teletryProperties, allowEmptyChoices) {
    if (ctx.get(CopilotTokenManager).getCopilotToken(ctx), cancel?.isCancellationRequested) return {
      type: "canceled",
      reason: "canceled during test"
    };
    if (this._wasCalled) {
      let emptyCompletions = this._completions.map(completion => "");
      return fakeResponse(emptyCompletions, finishedCb, params.postOptions, allowEmptyChoices, baseTelemetryData);
    } else return this._wasCalled = !0, fakeResponse(this._completions, finishedCb, params.postOptions, allowEmptyChoices, baseTelemetryData);
  }
};
var FixedBlockModeConfig = class extends BlockModeConfig {
  constructor(blockMode) {
    super();
    this.blockMode = blockMode;
  }
  static {
    __name(this, "FixedBlockModeConfig");
  }
  async forLanguage(ctx, languageId) {
    return this.blockMode;
  }
};
var CopilotExtensionApi = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "CopilotExtensionApi");
  }
  captureExtensionTelemetry(work) {
    return withInlineTelemetryCapture(this.ctx, work);
  }
  setupNextCompletion(completions) {
    this.clearCompletionsCache(), this.ctx.forceSet(OpenAIFetcher, new SyntheticCompletions(completions)), this.ctx.forceSet(BlockModeConfig, new FixedBlockModeConfig("parsing"));
  }
  clearCompletionsCache() {
    this.ctx.get(CompletionsCache).clear(), clearUserTypingState();
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_vscode = require("vscode");
var ExtensionFileSystem = class extends H0e.FileSystem {
    static {
      __name(this, "ExtensionFileSystem");
    }
    async readFile(uri) {
      return await E3.workspace.fs.readFile(E3.Uri.file(uri));
    }
    async stat(uri) {
      return await E3.workspace.fs.stat(E3.Uri.file(uri));
    }
  },
  extensionFileSystem = new ExtensionFileSystem();
var import_semver = Ns(XS());
var InstallationManager = class {
  static {
    __name(this, "InstallationManager");
  }
  async startup(ctx) {
    (await this.isNewInstall(ctx)) ? (await this.handleInstall(ctx, await this.wasPreviouslyInstalled(ctx)), await this.markInstalled(ctx)) : (await this.isNewUpgrade(ctx)) && (await this.handleUpgrade(ctx), await this.markUpgraded(ctx));
  }
  async uninstall(ctx) {
    return await this.handleUninstall(ctx);
  }
  async handleInstall(ctx, previouslyInstalled) {
    previouslyInstalled ? telemetry(ctx, "installed.reinstall") : telemetry(ctx, "installed.new");
  }
  async handleUpgrade(ctx) {
    telemetry(ctx, "installed.upgrade");
  }
  async handleUninstall(ctx) {
    telemetry(ctx, "uninstalled");
  }
};
var VsCodeInstallationManager = class extends InstallationManager {
  static {
    __name(this, "VsCodeInstallationManager");
  }
  async isNewInstall(ctx) {
    return !ctx.get(Extension).context.globalState.get("installedVersion") && !(await hasExistingSession());
  }
  async markInstalled(ctx) {
    let info = ctx.get(EditorAndPluginInfo).getEditorPluginInfo();
    ctx.get(Extension).context.globalState.update("installedVersion", info.version);
  }
  async wasPreviouslyInstalled(ctx) {
    return !1;
  }
  async isNewUpgrade(ctx) {
    let current = ctx.get(EditorAndPluginInfo).getEditorPluginInfo(),
      last = ctx.get(Extension).context.globalState.get("installedVersion");
    if (last === void 0) return !0;
    try {
      return (0, py.gt)((0, py.coerce)(current.version), (0, py.coerce)(last));
    } catch {
      return !1;
    }
  }
  async markUpgraded(ctx) {
    await this.markInstalled(ctx);
  }
};
var import_vscode = require("vscode");
var EnterpriseConfigPrefix = "github-enterprise",
  DotComUrl = "https://github.com";
function configuredBaseUrl() {
  return BD.workspace.getConfiguration(CopilotConfigPrefix).get("advanced")?.authProvider === "github-enterprise" ? BD.workspace.getConfiguration(EnterpriseConfigPrefix).get("uri") ?? DotComUrl : DotComUrl;
}
__name(configuredBaseUrl, "configuredBaseUrl");
var VSCodeNetworkConfiguration = class extends DefaultNetworkConfiguration {
  static {
    __name(this, "VSCodeNetworkConfiguration");
  }
  constructor() {
    super(configuredBaseUrl(), {});
  }
  updateBaseUrl(ctx, newUrl) {
    super.updateBaseUrl(ctx, configuredBaseUrl());
  }
};
function onDidChangeConfigurationHandler(event, ctx) {
  (event.affectsConfiguration(`${CopilotConfigPrefix}.advanced`) || event.affectsConfiguration(`${EnterpriseConfigPrefix}.uri`)) && ctx.get(NetworkConfiguration).updateBaseUrl(ctx);
}
__name(onDidChangeConfigurationHandler, "onDidChangeConfigurationHandler");
var import_vscode = require("vscode");
var import_net = require("net");
function getProxyFromEnvironment(env) {
  return env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy;
}
__name(getProxyFromEnvironment, "getProxyFromEnvironment");
function proxySettingFromUrl(proxyUrl) {
  (0, K0e.isIPv6)(proxyUrl) ? proxyUrl = "https://[" + proxyUrl + "]" : /:\/\//.test(proxyUrl) || (proxyUrl = `https://${proxyUrl}`);
  let {
    hostname: hostname,
    port: port,
    username: username,
    password: password
  } = new URL(proxyUrl);
  return {
    host: hostname,
    port: parsePort(port),
    proxyAuth: getAuth(username, password),
    headers: {}
  };
}
__name(proxySettingFromUrl, "proxySettingFromUrl");
function parsePort(port) {
  if (!port) return 80;
  let portNumber = Number(port);
  if (isNaN(portNumber)) throw new TypeError("Invalid proxy port");
  return portNumber;
}
__name(parsePort, "parsePort");
function getAuth(username, password) {
  return !username || !password ? "" : `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
}
__name(getAuth, "getAuth");
function initProxyEnvironment(fetcher, env) {
  C3.workspace.onDidChangeConfiguration(event => {
    let hasProxyUrlChanged = event.affectsConfiguration("http.proxy");
    (event.affectsConfiguration("http.proxyStrictSSL") || event.affectsConfiguration("http.proxyAuthorization") || event.affectsConfiguration("http.proxyKerberosServicePrincipal") || hasProxyUrlChanged) && updateProxyEnvironment(fetcher, env, hasProxyUrlChanged);
  }), updateProxyEnvironment(fetcher, env);
}
__name(initProxyEnvironment, "initProxyEnvironment");
var updateProxyEnvironment = __name((fetcher, env, hasProxyUrlChanged) => {
  let proxyUrl = C3.workspace.getConfiguration("http").get("proxy") || getProxyFromEnvironment(env);
  if (proxyUrl) {
    let proxyAuthorization = C3.workspace.getConfiguration("http").get("proxyAuthorization"),
      proxyStrictSSL = C3.workspace.getConfiguration("http").get("proxyStrictSSL", !0),
      proxySettings = proxySettingFromUrl(proxyUrl);
    proxyAuthorization && (proxySettings.headers["Proxy-Authorization"] = proxyAuthorization);
    let spn = C3.workspace.getConfiguration("http").get("proxyKerberosServicePrincipal");
    spn && (proxySettings.kerberosServicePrincipal = spn), fetcher.proxySettings = proxySettings, fetcher.rejectUnauthorized = proxyStrictSSL;
  } else hasProxyUrlChanged && !proxyUrl && (fetcher.proxySettings = void 0);
}, "updateProxyEnvironment");
var import_vscode = require("vscode");
var CopilotStatusBar = class extends StatusReporter {
  constructor(ctx, outputChannel) {
    super();
    this.ctx = ctx;
    this.outputChannel = outputChannel;
    this.showingMessage = !1;
    this.delayedUpdateDisplay = debounce(100, () => {
      this.updateStatusBarIndicator();
    });
    this.item = ld.window.createStatusBarItem("status", ld.StatusBarAlignment.Right, 1), this.item.name = "Copilot Status", this.state = ctx.get(CopilotExtensionStatus), this.updateStatusBarIndicator(), this.item.show(), ld.window.onDidChangeActiveTextEditor(() => {
      this.updateStatusBarIndicator();
    }), ld.workspace.onDidCloseTextDocument(() => {
      !ld.window.activeTextEditor && this.state.status === "Inactive" && (this.state.status = "Normal"), this.updateStatusBarIndicator();
    }), ld.workspace.onDidOpenTextDocument(() => {
      this.updateStatusBarIndicator();
    });
  }
  static {
    __name(this, "CopilotStatusBar");
  }
  checkEnabledForLanguage() {
    return getEnabledConfig(this.ctx) || !1;
  }
  updateStatusBarIndicator() {
    switch (this.state.status) {
      case "Error":
        this.item.text = "$(copilot-notconnected)", this.item.command = CMDToggleStatusMenu, this.item.tooltip = "Copilot error (click for details)";
        break;
      case "Warning":
        this.item.text = "$(copilot-warning)", this.item.command = this.state.errorMessage ? CMDToggleStatusMenu : void 0, this.item.tooltip = "Copilot is encountering temporary issues (click for details)";
        break;
      case "InProgress":
        this.item.text = "$(loading~spin)";
        break;
      case "Inactive":
        this.item.text = "$(copilot-notconnected)", this.item.tooltip = this.state.errorMessage || "Copilot is currently inactive";
        break;
      case "Normal":
        this.item.text = this.checkEnabledForLanguage() ? "$(copilot-logo)" : "$(copilot-notconnected)", this.item.command = CMDToggleStatusMenu, this.item.tooltip = "Show Copilot status menu";
    }
  }
  getStatusBarItem() {
    return this.item;
  }
  setProgress() {
    this.state.status !== "Error" && (this.state.status = "InProgress", this.delayedUpdateDisplay());
  }
  removeProgress() {
    this.state.status !== "Error" && this.state.status !== "Warning" && (this.state.status = "Normal", this.delayedUpdateDisplay());
  }
  setWarning(warningMessage) {
    this.state.status !== "Error" && (this.state.status = "Warning", warningMessage && (this.state.errorMessage = warningMessage), this.updateStatusBarIndicator());
  }
  setError(errorMessage, errorRetry) {
    this.state.status = "Error", this.state.errorMessage = errorMessage, this.errorRetry = errorRetry, this.updateStatusBarIndicator(), this.showErrorMessage();
  }
  setInactive(message) {
    this.state.status = "Inactive", this.state.errorMessage = message || "", this.errorRetry = void 0, this.updateStatusBarIndicator();
  }
  forceNormal() {
    this.state.status = "Normal", this.state.errorMessage = "", this.errorRetry = void 0, this.updateStatusBarIndicator();
  }
  showErrorMessage() {
    if (this.showingMessage) return;
    this.showingMessage = !0;
    let showOutputOption = "Show Output Log",
      options = [showOutputOption];
    this.errorRetry && options.push("Retry"), ld.window.showWarningMessage(this.state.errorMessage, ...options).then(res => {
      this.showingMessage = !1, res === showOutputOption && this.outputChannel.show(), res === "Retry" && this.errorRetry && this.errorRetry();
    });
  }
};
var import_vscode = require("vscode");
var CopilotStatusBarPickMenu = class {
    constructor(ctx, afterCommandCallback) {
      this.ctx = ctx;
      this.afterCommandCallback = afterCommandCallback;
      this.state = ctx.get(CopilotExtensionStatus);
    }
    static {
      __name(this, "CopilotStatusBarPickMenu");
    }
    showStatusMenu() {
      let quickpickList = Ih.window.createQuickPick();
      return quickpickList.items = this.collectQuickPickItems(), quickpickList.onDidAccept(() => {
        this.handleItemSelection(quickpickList);
      }), quickpickList.show(), quickpickList;
    }
    async handleItemSelection(quickpickList) {
      return new Promise((resolve, reject) => {
        let selection = quickpickList.selectedItems[0];
        if (selection !== void 0) if ("command" in selection) {
          let commandSelection = selection;
          Ih.commands.executeCommand(commandSelection.command, ...commandSelection.commandArgs).then(() => {
            this.afterCommandCallback(), quickpickList.hide(), resolve();
          });
        } else reject("Unexpected selection");
      });
    }
    collectQuickPickItems() {
      return this.state.status == "Normal" || this.state.status == "InProgress" ? [this.newStatusItem(), this.newSeparator(), this.newChatItem(), this.newSeparator(), ...this.collectLanguageSpecificItems(), this.newSeparator(), this.newKeyboardItem(), this.newSettingsItem(), this.newDiagnosticsItem(), this.newOpenLogsItem(), this.newSeparator(), this.newDocsItem(), this.newForumItem()] : [this.newStatusItem(), this.newSeparator(), this.newSettingsItem(), this.newDiagnosticsItem(), this.newOpenLogsItem(), this.newSeparator(), this.newDocsItem(), this.newForumItem(), this.newSeparator(), this.newSignInItem()];
    }
    collectLanguageSpecificItems() {
      let currentLanguage = Ih.window.activeTextEditor?.document.languageId;
      return currentLanguage ? [this.newPanelItem(), this.newGlobalEnablementItem(), ...this.newEnableLanguageItem(currentLanguage)] : [this.newGlobalEnablementItem()];
    }
    newEnableLanguageItem(currentLanguage) {
      let isEnabled = getEnabledConfig(this.ctx);
      if (isEnabled === void 0) return [];
      let enablementLabelPrefix = isEnabled ? "Disable" : "Enable";
      return [this.newCommandItem(enablementLabelPrefix + " Completions for '" + currentLanguage + "'", CMDToggleCopilot, [currentLanguage])];
    }
    newGlobalEnablementItem() {
      let prefix = getEnabledConfig(this.ctx, "*") ? "Disable" : "Enable";
      return this.newCommandItem(prefix + " Completions", CMDToggleCopilot);
    }
    newStatusItem() {
      let statusText;
      return this.state.status == "Normal" || this.state.status == "InProgress" ? (statusText = "Ready", getEnabledConfig(this.ctx) || (statusText += " (Disabled)")) : statusText = this.state.errorMessage || "Copilot is currently inactive", this.newCommandItem("$(copilot-logo) Status: " + statusText, CMDOpenLogs);
    }
    newSignInItem() {
      return this.newCommandItem("Sign in to GitHub", CMDSignIn);
    }
    newOpenLogsItem() {
      return this.newCommandItem("Open Logs...", CMDOpenLogs);
    }
    newDiagnosticsItem() {
      return this.newCommandItem("Show Diagnostics...", CMDCollectDiagnostics);
    }
    newKeyboardItem() {
      return this.newCommandItem("$(keyboard) Edit Keyboard Shortcuts...", "workbench.action.openGlobalKeybindings", ["copilot"]);
    }
    newChatItem() {
      return this.newCommandItem("$(copilot-chat) GitHub Copilot Chat", "workbench.panel.chat.view.copilot.focus");
    }
    newSettingsItem() {
      return this.newCommandItem("$(settings-gear) Edit Settings...", "workbench.action.openSettings", ["GitHub Copilot"]);
    }
    newPanelItem() {
      return this.newCommandItem("Open Completions Panel...", CMDOpenPanel);
    }
    newForumItem() {
      return this.newCommandItem("$(comments-view-icon) View Copilot Forum...", CMDSendFeedback);
    }
    newDocsItem() {
      return this.newCommandItem("$(remote-explorer-documentation) View Copilot Documentation...", CMDOpenDocumentation);
    }
    newCommandItem(label, command, commandArgs) {
      return new CommandQuickItem(label, command, commandArgs || []);
    }
    newSeparator() {
      return {
        label: "",
        kind: Ih.QuickPickItemKind.Separator
      };
    }
  },
  CommandQuickItem = class {
    constructor(label, command, commandArgs) {
      this.label = label;
      this.command = command;
      this.commandArgs = commandArgs;
    }
    static {
      __name(this, "CommandQuickItem");
    }
  };
var import_copilot_promptlib = Ns(Dc()),
  vscode = Ns(require("vscode")),
  import_vscode = require("vscode");
var ExtensionSymbolDefinitionProvider = class extends SymbolDefinitionProvider {
  static {
    __name(this, "ExtensionSymbolDefinitionProvider");
  }
  async getSymbolDefinition(docInfo) {
    let location = {
        line: docInfo.position.line,
        character: docInfo.position.character,
        uri: T3.Uri.parse(docInfo.uri)
      },
      [signature, semantics] = await this.getHoverTextAndDecompose(location);
    return signature === "" ? [] : [{
      snippet: signature,
      score: 1,
      startLine: location.line,
      endLine: location.line,
      semantics: semantics,
      provider: pc.SnippetProviderType.SymbolDef
    }];
  }
  async getHoverTextAndDecompose(uriLineCol) {
    let hoverText = await T3.commands.executeCommand("vscode.executeHoverProvider", uriLineCol.uri, new J0e.Position(uriLineCol.line, uriLineCol.character));
    return hoverText[0] && hoverText[0].contents[0] instanceof T3.MarkdownString ? decomposeHoverText(hoverText[0].contents[0].value) : ["", pc.SnippetSemantics.Snippet];
  }
};
function decomposeHoverText(hoverText) {
  let regex = /```\w+\n(class|\(\w+\))\s([^`]*)```.*/m,
    match = hoverText.match(regex);
  if (match != null) {
    let codeTypeString = match[1],
      semantics = getSemantics(codeTypeString);
    return [match[2].trim(), semantics];
  } else return ["", pc.SnippetSemantics.Snippet];
}
__name(decomposeHoverText, "decomposeHoverText");
function getSemantics(codeTypeString) {
  switch (codeTypeString = codeTypeString.replace("(", "").replace(")", ""), codeTypeString) {
    case "function":
      return pc.SnippetSemantics.Function;
    case "variable":
      return pc.SnippetSemantics.Variable;
    case "parameter":
      return pc.SnippetSemantics.Parameter;
    case "method":
      return pc.SnippetSemantics.Method;
    case "class":
      return pc.SnippetSemantics.Class;
    case "module":
      return pc.SnippetSemantics.Module;
    case "alias":
      return pc.SnippetSemantics.Alias;
    case "enum":
      return pc.SnippetSemantics.Enum;
    case "interface":
      return pc.SnippetSemantics.Interface;
    default:
      return pc.SnippetSemantics.Snippet;
  }
}
__name(getSemantics, "getSemantics");
function escapeForRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeForRegExp, "escapeForRegExp");
var rootDirRegExp = new RegExp(escapeForRegExp(__dirname.replace(/[\\/]extension[\\/]src$|[\\/]dist$/, "")) + `[\\\\/]?([^:)'"\\s]*)`, "gi"),
  irrelevantStackPaths = new Set(["node_modules/diagnostic-channel/dist/src/patchRequire.js"]),
  TelemetryDelegator = class {
    constructor(handler) {
      this.handler = handler;
    }
    static {
      __name(this, "TelemetryDelegator");
    }
    sendEventData() {}
    sendErrorData(error) {
      let relevant = !1;
      for (let match of (error.stack ?? "").matchAll(rootDirRegExp)) if (!irrelevantStackPaths.has(match[1].replace(/\\/g, "/"))) {
        relevant = !0;
        break;
      }
      relevant && this.handler(error);
    }
  };
var import_vscode = require("vscode");
var ExtensionLocationFactory = class extends LocationFactory {
  static {
    __name(this, "ExtensionLocationFactory");
  }
  range(x1, y1, x2, y2) {
    return x2 !== void 0 && y2 !== void 0 ? new my.Range(x1, y1, x2, y2) : new my.Range(x1, y1);
  }
  position(line, character) {
    return new my.Position(line, character);
  }
};
var import_vscode = require("vscode");
var ExtensionTextDocumentManager = class extends TextDocumentManager {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.onDidFocusTextDocument = ap.window.onDidChangeActiveTextEditor;
    this.onDidChangeTextDocument = ap.workspace.onDidChangeTextDocument;
    this.onDidChangeCursor = ap.window.onDidChangeTextEditorSelection;
  }
  static {
    __name(this, "ExtensionTextDocumentManager");
  }
  async textDocuments() {
    let documents = ap.workspace.textDocuments,
      filteredDocuments = [];
    for (let doc of documents) (await isDocumentValid(this.ctx, doc)).status === "valid" && filteredDocuments.push(doc);
    return filteredDocuments;
  }
  async getTextDocumentWithValidation(uri) {
    try {
      let doc = await ap.workspace.openTextDocument(uri);
      return isDocumentValid(this.ctx, doc);
    } catch {
      return {
        status: "notfound",
        message: `Document for URI could not be found: ${uri}`
      };
    }
  }
  async getTextDocument(uri) {
    let result = await this.getTextDocumentWithValidation(uri);
    if (result.status === "valid") return result.document;
  }
  findNotebook(doc) {
    return ap.workspace.notebookDocuments.find(notebook => notebook.getCells().some(cell => cell.document.uri.toString() === doc.uri.toString()));
  }
  getWorkspaceFolders() {
    return ap.workspace.workspaceFolders?.map(f => f.uri) ?? [];
  }
};
var path = Ns(require("path")),
  vscode = Ns(require("vscode"));
var import_vscode = require("vscode");
var ExtensionCommitFileResolver = class extends CommitFileResolver {
  static {
    __name(this, "ExtensionCommitFileResolver");
  }
  async getCoCommitResult(targetURI, maxFiles) {
    if (targetURI.scheme !== "file") return [];
    let targetPath = targetURI.fsPath,
      gitExtension = ele.extensions.getExtension("vscode.git");
    if (gitExtension === void 0) return [];
    let api = gitExtension.exports.getAPI(1);
    if (api === void 0) return [];
    if (api.repositories.length === 0) return [];
    let repos = api.repositories,
      touchedFiles = [],
      visited = new Set(),
      deleteStatus = new Set([6, 12, 13, 2, 15]);
    visited.add(targetPath);
    let logOption = {
      path: targetPath
    };
    for (let repo of repos) {
      let relative = eT.relative(repo.rootUri.fsPath, targetPath);
      if (!(relative && !relative.startsWith("..") && !eT.isAbsolute(relative))) continue;
      let logResults = await repo.log(logOption);
      for (let logResult of logResults) {
        let parents = logResult.parents;
        for (let parent of parents) {
          let changes = await repo.diffBetween(parent, logResult.hash);
          for (let change of changes) if (!(deleteStatus.has(change.status) || visited.has(change.uri.fsPath)) && (visited.add(change.uri.fsPath), touchedFiles.push(change.uri), touchedFiles.length >= maxFiles)) return touchedFiles;
        }
      }
    }
    return touchedFiles;
  }
};
var import_vscode = require("vscode");
var ExtensionWorkspaceFileSystem = class extends WorkspaceFileSystem {
  static {
    __name(this, "ExtensionWorkspaceFileSystem");
  }
  async findFiles(include, exclude, maxResults) {
    return await UD.workspace.findFiles(include, exclude, maxResults);
  }
  async getWorkspaceFolder(uri) {
    let folder = UD.workspace.getWorkspaceFolder(uri);
    if (folder !== void 0) return folder.uri;
  }
};
var outputChannel = ja.window.createOutputChannel("GitHub Copilot");
function registerStatusBar(ctx, outputChannel) {
  let copilotStatusBarItem = new CopilotStatusBar(ctx, outputChannel);
  registerCommandWithTelemetry(ctx, CMDToggleCopilot, async language => {
    await toggleCopilotEnablement(ctx, language === void 0 ? "global" : "language"), copilotStatusBarItem.updateStatusBarIndicator();
  }), registerCommandWithTelemetry(ctx, CMDToggleStatusMenu, () => {
    new CopilotStatusBarPickMenu(ctx, () => {
      debounce(100, () => {
        copilotStatusBarItem.updateStatusBarIndicator();
      });
    }).showStatusMenu();
  }), ctx.get(Extension).register(copilotStatusBarItem.getStatusBarItem()), ctx.set(StatusReporter, copilotStatusBarItem);
}
__name(registerStatusBar, "registerStatusBar");
async function activate(context) {
  let activationTelemetry = TelemetryData.createAndMarkAsIssued(),
    ctx = await createExtensionContext(context);
  registerStatusBar(ctx, outputChannel), ctx.set(CopilotRepositoryControlManager, new CopilotRepositoryControlManager(ctx)), registerDiagnosticCommands(ctx), registerCommandWithTelemetry(ctx, CMDSignIn, () => getSession(ctx, !0)), context.subscriptions.push(new CodeReference(ctx).register()), context.subscriptions.push(onDeactivate(ctx));
  let tryActivation = __name(async () => {
    let statusBar = ctx.get(StatusReporter);
    statusBar.setProgress(), permitOneSignIn();
    let rejectionHandler = __name((error, allowRetry = !0) => {
        let reason = error.message || error;
        telemetryError(ctx, "activationFailed", TelemetryData.createAndMarkAsIssued({
          reason: reason
        })), ctx.get(TelemetryReporters).deactivate();
        let message = reason === "GitHubLoginFailed" ? SESSION_LOGIN_MESSAGE : `Extension activation failed: "${reason}"`;
        statusBar.setError(message, allowRetry ? tryActivation : void 0), logger.error(ctx, message), ja.commands.executeCommand("setContext", "github.copilot.activated", !1);
      }, "rejectionHandler"),
      nodeVersionError = errorMessageForUnsupportedNodeVersion();
    if (nodeVersionError) {
      rejectionHandler(nodeVersionError, !1);
      return;
    }
    ctx.get(CopilotTokenManager).getCopilotToken(ctx).then(() => {
      statusBar.forceNormal(), ja.commands.executeCommand("setContext", "github.copilot.activated", !0), registerPanelSupport(ctx), registerGhostTextSupport(ctx), context.subscriptions.push(registerDocumentTracker(ctx)), context.subscriptions.push(registerCursorTracker(ctx)), context.subscriptions.push(ja.window.onDidChangeActiveTextEditor(e => e && extractRepoInfoInBackground(ctx, e.document.uri))), context.subscriptions.push(ja.workspace.onDidOpenTextDocument(doc => primeLanguageDetectionCache(ctx, doc))), context.subscriptions.push(ja.workspace.onDidChangeConfiguration(e => onDidChangeConfigurationHandler(e, ctx)));
      let isDevMode = context.extensionMode === ja.ExtensionMode.Development;
      init(ctx, !isDevMode, new Logger(1, "promptlib proxy")), isDevMode || ctx.get(hy.SnippetOrchestrator).startThreading(), telemetry(ctx, "extension.activate", activationTelemetry), ja.window?.activeTextEditor && ctx.get(CopilotRepositoryControlManager).evaluate(ja.window.activeTextEditor.document?.uri, ja.window.activeTextEditor.document.getText(), "UPDATE");
    }).catch(ex => {
      rejectionHandler(ex);
    });
  }, "tryActivation");
  return ja.authentication.onDidChangeSessions(async event => {
    await onDidChangeSessionsHandler(event, ctx);
  }), new VsCodeInstallationManager().startup(ctx), await tryActivation(), new CopilotExtensionApi(ctx);
}
__name(activate, "activate");
function registerGhostTextSupport(ctx) {
  try {
    registerGhostText(ctx);
    let inspect = ja.workspace.getConfiguration().inspect("editor.inlineSuggest.enabled");
    (inspect?.globalValue === !1 || inspect?.workspaceValue === !1) && logger.warn(ctx, "editor.inlineSuggest.enabled is disabled. Enabling recommended to use Copilot.");
  } catch (e) {
    telemetryException(ctx, e, "registerGhostTextSupport");
  }
}
__name(registerGhostTextSupport, "registerGhostTextSupport");
function registerDiagnosticCommands(ctx) {
  registerCommandWithTelemetry(ctx, CMDCollectDiagnostics, () => openDiagnosticReport(ctx)), registerCommandWithTelemetry(ctx, CMDSendFeedback, () => {
    ja.env.openExternal(ja.Uri.parse("https://github.com/orgs/community/discussions/categories/copilot"));
  }), registerCommandWithTelemetry(ctx, CMDOpenDocumentation, () => {
    ja.env.openExternal(ja.Uri.parse("https://docs.github.com/en/copilot/getting-started-with-github-copilot?tool=vscode"));
  }), registerCommandWithTelemetry(ctx, CMDOpenLogs, () => {
    outputChannel.show();
  });
}
__name(registerDiagnosticCommands, "registerDiagnosticCommands");
async function createExtensionContext(extensionContext) {
  let ctx = createProductionContext(new VSCodeConfigProvider()),
    logTarget = new MultiLog([new ConsoleLog(console), new OutputChannelLog(outputChannel)]);
  return ctx.forceSet(LogTarget, logTarget), ctx.set(EditorAndPluginInfo, new VSCodeEditorInfo()), initProxyEnvironment(ctx.get(Fetcher), process.env), ctx.set(NotificationSender, new ExtensionNotificationSender()), ctx.set(EditorSession, new EditorSession(ja.env.sessionId, ja.env.machineId)), ctx.set(Extension, new Extension(extensionContext)), ctx.set(EditorExperimentFilters, new VSCodeEditorExperimentFilters()), setupExperimentationService(ctx), ctx.set(SymbolDefinitionProvider, new ExtensionSymbolDefinitionProvider()), ctx.set(CopilotExtensionStatus, new CopilotExtensionStatus()), extensionContext.extensionMode === ja.ExtensionMode.Test ? (ctx.forceSet(RuntimeMode, RuntimeMode.fromEnvironment(!0)), ctx.set(CopilotTokenManager, getTestingCopilotTokenManager()), ctx.forceSet(UrlOpener, new TestUrlOpener()), await setupTelemetry(ctx, extensionContext, "copilot-test", !0)) : (ctx.set(CopilotTokenManager, new VSCodeCopilotTokenManager()), ctx.forceSet(ExpConfigMaker, new ExpConfigFromTAS()), await setupTelemetry(ctx, extensionContext, extensionContext.extension.packageJSON.name, ja.env.isTelemetryEnabled)), ctx.set(LocationFactory, new ExtensionLocationFactory()), ctx.set(TextDocumentManager, new ExtensionTextDocumentManager(ctx)), ctx.set(WorkspaceFileSystem, new ExtensionWorkspaceFileSystem()), ctx.set(CommitFileResolver, new ExtensionCommitFileResolver()), ctx.set(hy.FileSystem, extensionFileSystem), ctx.set(NetworkConfiguration, new VSCodeNetworkConfiguration()), ctx;
}
__name(createExtensionContext, "createExtensionContext");
async function setupTelemetry(ctx, extensionContext, extensionName, enabled) {
  extensionContext.subscriptions.push(ja.env.onDidChangeTelemetryEnabled(async newEnabled => {
    await setupTelemetryReporters(ctx, extensionContext.extension.packageJSON.name, newEnabled && ja.env.isTelemetryEnabled);
  })), await setupTelemetryReporters(ctx, extensionName, enabled), extensionContext.subscriptions.push(ja.env.createTelemetryLogger(new TelemetryDelegator(err => exception(ctx, err, "unhandlederror")))), cleanupTelemetryReporters(ctx);
}
__name(setupTelemetry, "setupTelemetry");
var Extension = class {
  constructor(context) {
    this.context = context;
  }
  static {
    __name(this, "Extension");
  }
  get isProdMode() {
    return this.context.extensionMode === ja.ExtensionMode.Production;
  }
  get isNightlyBuild() {
    return this.context.extension.packageJSON.buildType === "nightly";
  }
  register(...disposables) {
    this.context.subscriptions.push(...disposables);
  }
};
function onDeactivate(ctx) {
  return {
    dispose: async () => {
      await telemetry(ctx, "extension.deactivate"), ctx.get(TelemetryReporters).deactivate(), ctx.get(hy.SnippetOrchestrator).stopThreading(), terminate();
    }
  };
}
__name(onDeactivate, "onDeactivate");
0 && (module.exports = {
  Extension,
  activate,
  createExtensionContext,
  onDeactivate
});
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@microsoft/applicationinsights-web-snippet/dist/node/applicationinsights-web-snippet.js:
  (*!
   * Application Insights JavaScript SDK - Web Snippet, 1.0.1
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

git-url-parse/lib/index.js:
  (*!
   * buildToken
   * Builds OAuth token prefix (helper function)
   *
   * @name buildToken
   * @function
   * @param {GitUrl} obj The parsed Git url object.
   * @return {String} token prefix
   *)
*/
//# sourceMappingURL=extension.js.map