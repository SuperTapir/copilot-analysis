"use strict";

var ile = Object.create;
var w3 = Object.defineProperty;
var sle = Object.getOwnPropertyDescriptor;
var ole = Object.getOwnPropertyNames;
var ale = Object.getPrototypeOf,
  lle = Object.prototype.hasOwnProperty;
var l = (e, t) => w3(e, "name", {
  value: t,
  configurable: !0
});
var Bs = (e, t) => () => (e && (t = e(e = 0)), t);
var T = (e, t) => () => (t || e((t = {
    exports: {}
  }).exports, t), t.exports),
  rT = (e, t) => {
    for (var r in t) w3(e, r, {
      get: t[r],
      enumerable: !0
    });
  },
  jD = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function") for (let i of ole(t)) !lle.call(e, i) && i !== r && w3(e, i, {
      get: () => t[i],
      enumerable: !(n = sle(t, i)) || n.enumerable
    });
    return e;
  };
var Ns = (e, t, r) => (r = e != null ? ile(ale(e)) : {}, jD(t || !e || !e.__esModule ? w3(r, "default", {
    value: e,
    enumerable: !0
  }) : r, e)),
  nT = e => jD(w3({}, "__esModule", {
    value: !0
  }), e);
var require_base64 = __commonJSMin(exports => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  exports.decode = function (charCode) {
    var bigA = 65,
      bigZ = 90,
      littleA = 97,
      littleZ = 122,
      zero = 48,
      nine = 57,
      plus = 43,
      slash = 47,
      littleOffset = 26,
      numberOffset = 52;
    return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
  };
});
var require_base64_vlq = __commonJSMin(exports => {
  var base64 = $D(),
    VLQ_BASE_SHIFT = 5,
    VLQ_BASE = 1 << VLQ_BASE_SHIFT,
    VLQ_BASE_MASK = VLQ_BASE - 1,
    VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  __name(toVLQSigned, "toVLQSigned");
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1,
      shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  __name(fromVLQSigned, "fromVLQSigned");
  exports.encode = __name(function (aValue) {
    var encoded = "",
      digit,
      vlq = toVLQSigned(aValue);
    do digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit); while (vlq > 0);
    return encoded;
  }, "base64VLQ_encode");
  exports.decode = __name(function (aStr, aIndex, aOutParam) {
    var strLen = aStr.length,
      result = 0,
      shift = 0,
      continuation,
      digit;
    do {
      if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
      if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
  }, "base64VLQ_decode");
});
var require_util = __commonJSMin(exports => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) return aArgs[aName];
    if (arguments.length === 3) return aDefaultValue;
    throw new Error('"' + aName + '" is a required argument.');
  }
  __name(getArg, "getArg");
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
    dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    return match ? {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    } : null;
  }
  __name(urlParse, "urlParse");
  exports.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url = "";
    return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
  }
  __name(urlGenerate, "urlGenerate");
  exports.urlGenerate = urlGenerate;
  function normalize(aPath) {
    var path = aPath,
      url = urlParse(aPath);
    if (url) {
      if (!url.path) return aPath;
      path = url.path;
    }
    for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i = parts.length - 1; i >= 0; i--) part = parts[i], part === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
    return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
  }
  __name(normalize, "normalize");
  exports.normalize = normalize;
  function join(aRoot, aPath) {
    aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
    var aPathUrl = urlParse(aPath),
      aRootUrl = urlParse(aRoot);
    if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme) return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
    if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) return aRootUrl.host = aPath, urlGenerate(aRootUrl);
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
  }
  __name(join, "join");
  exports.join = join;
  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
    for (var level = 0; aPath.indexOf(aRoot + "/") !== 0;) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/))) return aPath;
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  __name(relative, "relative");
  exports.relative = relative;
  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  __name(identity, "identity");
  function toSetString(aStr) {
    return isProtoString(aStr) ? "$" + aStr : aStr;
  }
  __name(toSetString, "toSetString");
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    return isProtoString(aStr) ? aStr.slice(1) : aStr;
  }
  __name(fromSetString, "fromSetString");
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) return !1;
    var length = s.length;
    if (length < 9 || s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) return !1;
    for (var i = length - 10; i >= 0; i--) if (s.charCodeAt(i) !== 36) return !1;
    return !0;
  }
  __name(isProtoString, "isProtoString");
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
  }
  __name(compareByOriginalPositions, "compareByOriginalPositions");
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
  }
  __name(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated");
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
  }
  __name(strcmp, "strcmp");
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
  }
  __name(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated");
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  __name(parseSourceMapInput, "parseSourceMapInput");
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) throw new Error("sourceMapURL could not be parsed");
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  __name(computeSourceURL, "computeSourceURL");
  exports.computeSourceURL = computeSourceURL;
});
var require_array_set = __commonJSMin(exports => {
  var util = Rh(),
    has = Object.prototype.hasOwnProperty,
    hasNativeMap = typeof Map < "u";
  function ArraySet() {
    this._array = [], this._set = hasNativeMap ? new Map() : Object.create(null);
  }
  __name(ArraySet, "ArraySet");
  ArraySet.fromArray = __name(function (aArray, aAllowDuplicates) {
    for (var set = new ArraySet(), i = 0, len = aArray.length; i < len; i++) set.add(aArray[i], aAllowDuplicates);
    return set;
  }, "ArraySet_fromArray");
  ArraySet.prototype.size = __name(function () {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, "ArraySet_size");
  ArraySet.prototype.add = __name(function (aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr),
      isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr),
      idx = this._array.length;
    (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
  }, "ArraySet_add");
  ArraySet.prototype.has = __name(function (aStr) {
    if (hasNativeMap) return this._set.has(aStr);
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }, "ArraySet_has");
  ArraySet.prototype.indexOf = __name(function (aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) return idx;
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }, "ArraySet_indexOf");
  ArraySet.prototype.at = __name(function (aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
    throw new Error("No element indexed by " + aIdx);
  }, "ArraySet_at");
  ArraySet.prototype.toArray = __name(function () {
    return this._array.slice();
  }, "ArraySet_toArray");
  exports.ArraySet = ArraySet;
});
var require_mapping_list = __commonJSMin(exports => {
  var util = Rh();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine,
      lineB = mappingB.generatedLine,
      columnA = mappingA.generatedColumn,
      columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  __name(generatedPositionAfter, "generatedPositionAfter");
  function MappingList() {
    this._array = [], this._sorted = !0, this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  __name(MappingList, "MappingList");
  MappingList.prototype.unsortedForEach = __name(function (aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }, "MappingList_forEach");
  MappingList.prototype.add = __name(function (aMapping) {
    generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
  }, "MappingList_add");
  MappingList.prototype.toArray = __name(function () {
    return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
  }, "MappingList_toArray");
  exports.MappingList = MappingList;
});
var require_source_map_generator = __commonJSMin(exports => {
  var base64VLQ = aT(),
    util = Rh(),
    ArraySet = fT().ArraySet,
    MappingList = rM().MappingList;
  function SourceMapGenerator(aArgs) {
    aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
  }
  __name(SourceMapGenerator, "SourceMapGenerator");
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = __name(function (aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot,
      generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
    return aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
    }), aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && generator.setSourceContent(sourceFile, content);
    }), generator;
  }, "SourceMapGenerator_fromSourceMap");
  SourceMapGenerator.prototype.addMapping = __name(function (aArgs) {
    var generated = util.getArg(aArgs, "generated"),
      original = util.getArg(aArgs, "original", null),
      source = util.getArg(aArgs, "source", null),
      name = util.getArg(aArgs, "name", null);
    this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  }, "SourceMapGenerator_addMapping");
  SourceMapGenerator.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
    var source = aSourceFile;
    this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
  }, "SourceMapGenerator_setSourceContent");
  SourceMapGenerator.prototype.applySourceMap = __name(function (aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
    var newSources = new ArraySet(),
      newNames = new ArraySet();
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
      }
      var source = mapping.source;
      source != null && !newSources.has(source) && newSources.add(source);
      var name = mapping.name;
      name != null && !newNames.has(name) && newNames.add(name);
    }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aSourceMapPath != null && (sourceFile = util.join(aSourceMapPath, sourceFile)), sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile)), this.setSourceContent(sourceFile, content));
    }, this);
  }, "SourceMapGenerator_applySourceMap");
  SourceMapGenerator.prototype._validateMapping = __name(function (aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  }, "SourceMapGenerator_validateMapping");
  SourceMapGenerator.prototype._serializeMappings = __name(function () {
    for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
      if (mapping = mappings[i], next = "", mapping.generatedLine !== previousGeneratedLine) for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine;) next += ";", previousGeneratedLine++;else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
        next += ",";
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
    }
    return result;
  }, "SourceMapGenerator_serializeMappings");
  SourceMapGenerator.prototype._generateSourcesContent = __name(function (aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) return null;
      aSourceRoot != null && (source = util.relative(aSourceRoot, source));
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  }, "SourceMapGenerator_generateSourcesContent");
  SourceMapGenerator.prototype.toJSON = __name(function () {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
  }, "SourceMapGenerator_toJSON");
  SourceMapGenerator.prototype.toString = __name(function () {
    return JSON.stringify(this.toJSON());
  }, "SourceMapGenerator_toString");
  exports.SourceMapGenerator = SourceMapGenerator;
});
var require_binary_search = __commonJSMin(exports => {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow,
      cmp = aCompare(aNeedle, aHaystack[mid], !0);
    return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
  }
  __name(recursiveSearch, "recursiveSearch");
  exports.search = __name(function (aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) return -1;
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) return -1;
    for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0;) --index;
    return index;
  }, "search");
});
var require_quick_sort = __commonJSMin(exports => {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y], ary[y] = temp;
  }
  __name(swap, "swap");
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  __name(randomIntInRange, "randomIntInRange");
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r),
        i = p - 1;
      swap(ary, pivotIndex, r);
      for (var pivot = ary[r], j = p; j < r; j++) comparator(ary[j], pivot) <= 0 && (i += 1, swap(ary, i, j));
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
    }
  }
  __name(doQuickSort, "doQuickSort");
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});
var require_source_map_consumer = __commonJSMin(exports => {
  var util = Rh(),
    binarySearch = iM(),
    ArraySet = fT().ArraySet,
    base64VLQ = aT(),
    quickSort = oM().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    return typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  __name(SourceMapConsumer, "SourceMapConsumer");
  SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = __name(function (aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  }, "SourceMapConsumer_charIsMappingSeparator");
  SourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }, "SourceMapConsumer_parseMappings");
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = __name(function (aCallback, aContext, aOrder) {
    var context = aContext || null,
      order = aOrder || SourceMapConsumer.GENERATED_ORDER,
      mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      return source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  }, "SourceMapConsumer_eachMapping");
  SourceMapConsumer.prototype.allGeneratedPositionsFor = __name(function (aArgs) {
    var line = util.getArg(aArgs, "line"),
      needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
    if (needle.source = this._findSourceIndex(needle.source), needle.source < 0) return [];
    var mappings = [],
      index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === void 0) for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine;) mappings.push({
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      }), mapping = this._originalMappings[++index];else for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn;) mappings.push({
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      }), mapping = this._originalMappings[++index];
    }
    return mappings;
  }, "SourceMapConsumer_allGeneratedPositionsFor");
  exports.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
    var version = util.getArg(sourceMap, "version"),
      sources = util.getArg(sourceMap, "sources"),
      names = util.getArg(sourceMap, "names", []),
      sourceRoot = util.getArg(sourceMap, "sourceRoot", null),
      sourcesContent = util.getArg(sourceMap, "sourcesContent", null),
      mappings = util.getArg(sourceMap, "mappings"),
      file = util.getArg(sourceMap, "file", null);
    if (version != this._version) throw new Error("Unsupported version: " + version);
    sourceRoot && (sourceRoot = util.normalize(sourceRoot)), sources = sources.map(String).map(util.normalize).map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
  }
  __name(BasicSourceMapConsumer, "BasicSourceMapConsumer");
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) if (this._absoluteSources[i] == aSource) return i;
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = __name(function (aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype),
      names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0),
      sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
    smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i],
        destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
    }
    return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
  }, "SourceMapConsumer_fromSourceMap");
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function () {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
  }
  __name(Mapping, "Mapping");
  BasicSourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
    for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str, segment, end, value; index < length;) if (aStr.charAt(index) === ";") generatedLine++, index++, previousGeneratedColumn = 0;else if (aStr.charAt(index) === ",") index++;else {
      for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++);
      if (str = aStr.slice(index, end), segment = cachedSegments[str], segment) index += str.length;else {
        for (segment = []; index < end;) base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
        if (segment.length === 2) throw new Error("Found a source, but no line and column");
        if (segment.length === 3) throw new Error("Found a source and line, but no column");
        cachedSegments[str] = segment;
      }
      mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
  }, "SourceMapConsumer_parseMappings");
  BasicSourceMapConsumer.prototype._findMapping = __name(function (aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  }, "SourceMapConsumer_findMapping");
  BasicSourceMapConsumer.prototype.computeColumnSpans = __name(function () {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = 1 / 0;
    }
  }, "SourceMapConsumer_computeColumnSpans");
  BasicSourceMapConsumer.prototype.originalPositionFor = __name(function (aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      },
      index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        source !== null && (source = this._sources.at(source), source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
        var name = util.getArg(mapping, "name", null);
        return name !== null && (name = this._names.at(name)), {
          source: source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name: name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, "SourceMapConsumer_originalPositionFor");
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = __name(function () {
    return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    }) : !1;
  }, "BasicSourceMapConsumer_hasContentsOfAllSources");
  BasicSourceMapConsumer.prototype.sourceContentFor = __name(function (aSource, nullOnMissing) {
    if (!this.sourcesContent) return null;
    var index = this._findSourceIndex(aSource);
    if (index >= 0) return this.sourcesContent[index];
    var relativeSource = aSource;
    this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource));
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
    if (nullOnMissing) return null;
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }, "SourceMapConsumer_sourceContentFor");
  BasicSourceMapConsumer.prototype.generatedPositionFor = __name(function (aArgs) {
    var source = util.getArg(aArgs, "source");
    if (source = this._findSourceIndex(source), source < 0) return {
      line: null,
      column: null,
      lastColumn: null
    };
    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      },
      index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) return {
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, "SourceMapConsumer_generatedPositionFor");
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
    var version = util.getArg(sourceMap, "version"),
      sections = util.getArg(sourceMap, "sections");
    if (version != this._version) throw new Error("Unsupported version: " + version);
    this._sources = new ArraySet(), this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) throw new Error("Support for url field in sections not implemented.");
      var offset = util.getArg(s, "offset"),
        offsetLine = util.getArg(offset, "line"),
        offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return lastOffset = offset, {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  __name(IndexedSourceMapConsumer, "IndexedSourceMapConsumer");
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function () {
      for (var sources = [], i = 0; i < this._sections.length; i++) for (var j = 0; j < this._sections[i].consumer.sources.length; j++) sources.push(this._sections[i].consumer.sources[j]);
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = __name(function (aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      },
      sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        return cmp || needle.generatedColumn - section.generatedOffset.generatedColumn;
      }),
      section = this._sections[sectionIndex];
    return section ? section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, "IndexedSourceMapConsumer_originalPositionFor");
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = __name(function () {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  }, "IndexedSourceMapConsumer_hasContentsOfAllSources");
  IndexedSourceMapConsumer.prototype.sourceContentFor = __name(function (aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i],
        content = section.consumer.sourceContentFor(aSource, !0);
      if (content) return content;
    }
    if (nullOnMissing) return null;
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }, "IndexedSourceMapConsumer_sourceContentFor");
  IndexedSourceMapConsumer.prototype.generatedPositionFor = __name(function (aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) !== -1) {
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
    }
    return {
      line: null,
      column: null
    };
  }, "IndexedSourceMapConsumer_generatedPositionFor");
  IndexedSourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j],
        source = section.consumer._sources.at(mapping.source);
      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
      var name = null;
      mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };
      this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
  }, "IndexedSourceMapConsumer_parseMappings");
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});
var require_source_node = __commonJSMin(exports => {
  var SourceMapGenerator = dT().SourceMapGenerator,
    util = Rh(),
    REGEX_NEWLINE = /(\r?\n)/,
    NEWLINE_CODE = 10,
    isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
  }
  __name(SourceNode, "SourceNode");
  SourceNode.fromStringWithSourceMap = __name(function (aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode(),
      remainingLines = aGeneratedCode.split(REGEX_NEWLINE),
      remainingLinesIndex = 0,
      shiftNextLine = __name(function () {
        var lineContents = getNextLine(),
          newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, "shiftNextLine"),
      lastGeneratedLine = 1,
      lastGeneratedColumn = 0,
      lastMapping = null;
    return aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;else {
        var nextLine = remainingLines[remainingLinesIndex] || "",
          code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
        return;
      }
      for (; lastGeneratedLine < mapping.generatedLine;) node.add(shiftNextLine()), lastGeneratedLine++;
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
    }), node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === void 0) node.add(code);else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
    __name(addMappingWithCode, "addMappingWithCode");
  }, "SourceNode_fromStringWithSourceMap");
  SourceNode.prototype.add = __name(function (aChunk) {
    if (Array.isArray(aChunk)) aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);else if (aChunk[isSourceNode] || typeof aChunk == "string") aChunk && this.children.push(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    return this;
  }, "SourceNode_add");
  SourceNode.prototype.prepend = __name(function (aChunk) {
    if (Array.isArray(aChunk)) for (var i = aChunk.length - 1; i >= 0; i--) this.prepend(aChunk[i]);else if (aChunk[isSourceNode] || typeof aChunk == "string") this.children.unshift(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    return this;
  }, "SourceNode_prepend");
  SourceNode.prototype.walk = __name(function (aFn) {
    for (var chunk, i = 0, len = this.children.length; i < len; i++) chunk = this.children[i], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
  }, "SourceNode_walk");
  SourceNode.prototype.join = __name(function (aSep) {
    var newChildren,
      i,
      len = this.children.length;
    if (len > 0) {
      for (newChildren = [], i = 0; i < len - 1; i++) newChildren.push(this.children[i]), newChildren.push(aSep);
      newChildren.push(this.children[i]), this.children = newChildren;
    }
    return this;
  }, "SourceNode_join");
  SourceNode.prototype.replaceRight = __name(function (aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
  }, "SourceNode_replaceRight");
  SourceNode.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }, "SourceNode_setSourceContent");
  SourceNode.prototype.walkSourceContents = __name(function (aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
    for (var sources = Object.keys(this.sourceContents), i = 0, len = sources.length; i < len; i++) aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }, "SourceNode_walkSourceContents");
  SourceNode.prototype.toString = __name(function () {
    var str = "";
    return this.walk(function (chunk) {
      str += chunk;
    }), str;
  }, "SourceNode_toString");
  SourceNode.prototype.toStringWithSourceMap = __name(function (aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
      },
      map = new SourceMapGenerator(aArgs),
      sourceMappingActive = !1,
      lastOriginalSource = null,
      lastOriginalLine = null,
      lastOriginalColumn = null,
      lastOriginalName = null;
    return this.walk(function (chunk, original) {
      generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      }), lastOriginalSource = null, sourceMappingActive = !1);
      for (var idx = 0, length = chunk.length; idx < length; idx++) chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      })) : generated.column++;
    }), this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    }), {
      code: generated.code,
      map: map
    };
  }, "SourceNode_toStringWithSourceMap");
  exports.SourceNode = SourceNode;
});
var require_source_map = __commonJSMin(exports => {
  exports.SourceMapGenerator = dT().SourceMapGenerator;
  exports.SourceMapConsumer = lM().SourceMapConsumer;
  exports.SourceNode = uM().SourceNode;
});
var require_buffer_from = __commonJSMin((exports, module) => {
  var toString = Object.prototype.toString,
    isModern = typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
  function isArrayBuffer(input) {
    return toString.call(input).slice(8, -1) === "ArrayBuffer";
  }
  __name(isArrayBuffer, "isArrayBuffer");
  function fromArrayBuffer(obj, byteOffset, length) {
    byteOffset >>>= 0;
    var maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) throw new RangeError("'offset' is out of bounds");
    if (length === void 0) length = maxLength;else if (length >>>= 0, length > maxLength) throw new RangeError("'length' is out of bounds");
    return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
  }
  __name(fromArrayBuffer, "fromArrayBuffer");
  function fromString(string, encoding) {
    if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
    return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
  }
  __name(fromString, "fromString");
  function bufferFrom(value, encodingOrOffset, length) {
    if (typeof value == "number") throw new TypeError('"value" argument must not be a number');
    return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
  }
  __name(bufferFrom, "bufferFrom");
  module.exports = bufferFrom;
});
var require_source_map_support = __commonJSMin((exports, module) => {
  var SourceMapConsumer = fM().SourceMapConsumer,
    path = require("path"),
    fs;
  try {
    fs = require("fs"), (!fs.existsSync || !fs.readFileSync) && (fs = null);
  } catch {}
  var bufferFrom = pM();
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  __name(dynamicRequire, "dynamicRequire");
  var errorFormatterInstalled = !1,
    uncaughtShimInstalled = !1,
    emptyCacheBetweenOperations = !1,
    environment = "auto",
    fileContentsCache = {},
    sourceMapCache = {},
    reSourceMap = /^data:application\/json[^,]+base64,/,
    retrieveFileHandlers = [],
    retrieveMapHandlers = [];
  function isInBrowser() {
    return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
  }
  __name(isInBrowser, "isInBrowser");
  function hasGlobalProcessEventEmitter() {
    return typeof process == "object" && process !== null && typeof process.on == "function";
  }
  __name(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter");
  function globalProcessVersion() {
    return typeof process == "object" && process !== null ? process.version : "";
  }
  __name(globalProcessVersion, "globalProcessVersion");
  function globalProcessStderr() {
    if (typeof process == "object" && process !== null) return process.stderr;
  }
  __name(globalProcessStderr, "globalProcessStderr");
  function globalProcessExit(code) {
    if (typeof process == "object" && process !== null && typeof process.exit == "function") return process.exit(code);
  }
  __name(globalProcessExit, "globalProcessExit");
  function handlerExec(list) {
    return function (arg) {
      for (var i = 0; i < list.length; i++) {
        var ret = list[i](arg);
        if (ret) return ret;
      }
      return null;
    };
  }
  __name(handlerExec, "handlerExec");
  var retrieveFile = handlerExec(retrieveFileHandlers);
  retrieveFileHandlers.push(function (path) {
    if (path = path.trim(), /^file:/.test(path) && (path = path.replace(/file:\/\/\/(\w:)?/, function (protocol, drive) {
      return drive ? "" : "/";
    })), path in fileContentsCache) return fileContentsCache[path];
    var contents = "";
    try {
      if (fs) fs.existsSync(path) && (contents = fs.readFileSync(path, "utf8"));else {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", path, !1), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
      }
    } catch {}
    return fileContentsCache[path] = contents;
  });
  function supportRelativeURL(file, url) {
    if (!file) return url;
    var dir = path.dirname(file),
      match = /^\w+:\/\/[^\/]*/.exec(dir),
      protocol = match ? match[0] : "",
      startPath = dir.slice(protocol.length);
    return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url);
  }
  __name(supportRelativeURL, "supportRelativeURL");
  function retrieveSourceMapURL(source) {
    var fileData;
    if (isInBrowser()) try {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
      var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
      if (sourceMapHeader) return sourceMapHeader;
    } catch {}
    fileData = retrieveFile(source);
    for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData);) lastMatch = match;
    return lastMatch ? lastMatch[1] : null;
  }
  __name(retrieveSourceMapURL, "retrieveSourceMapURL");
  var retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveMapHandlers.push(function (source) {
    var sourceMappingURL = retrieveSourceMapURL(source);
    if (!sourceMappingURL) return null;
    var sourceMapData;
    if (reSourceMap.test(sourceMappingURL)) {
      var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
      sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
    } else sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
    return sourceMapData ? {
      url: sourceMappingURL,
      map: sourceMapData
    } : null;
  });
  function mapSourcePosition(position) {
    var sourceMap = sourceMapCache[position.source];
    if (!sourceMap) {
      var urlAndMap = retrieveSourceMap(position.source);
      urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function (source, i) {
        var contents = sourceMap.map.sourcesContent[i];
        if (contents) {
          var url = supportRelativeURL(sourceMap.url, source);
          fileContentsCache[url] = contents;
        }
      })) : sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
    if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
      var originalPosition = sourceMap.map.originalPositionFor(position);
      if (originalPosition.source !== null) return originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source), originalPosition;
    }
    return position;
  }
  __name(mapSourcePosition, "mapSourcePosition");
  function mapEvalOrigin(origin) {
    var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
    if (match) {
      var position = mapSourcePosition({
        source: match[2],
        line: +match[3],
        column: match[4] - 1
      });
      return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
    }
    return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
  }
  __name(mapEvalOrigin, "mapEvalOrigin");
  function CallSiteToString() {
    var fileName,
      fileLocation = "";
    if (this.isNative()) fileLocation = "native";else {
      fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
      var lineNumber = this.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ":" + lineNumber;
        var columnNumber = this.getColumnNumber();
        columnNumber && (fileLocation += ":" + columnNumber);
      }
    }
    var line = "",
      functionName = this.getFunctionName(),
      addSuffix = !0,
      isConstructor = this.isConstructor(),
      isMethodCall = !(this.isToplevel() || isConstructor);
    if (isMethodCall) {
      var typeName = this.getTypeName();
      typeName === "[object Object]" && (typeName = "null");
      var methodName = this.getMethodName();
      functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
    } else isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
    return addSuffix && (line += " (" + fileLocation + ")"), line;
  }
  __name(CallSiteToString, "CallSiteToString");
  function cloneCallSite(frame) {
    var object = {};
    return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
      object[name] = /^(?:is|get)/.test(name) ? function () {
        return frame[name].call(frame);
      } : frame[name];
    }), object.toString = CallSiteToString, object;
  }
  __name(cloneCallSite, "cloneCallSite");
  function wrapCallSite(frame, state) {
    if (state === void 0 && (state = {
      nextPosition: null,
      curPosition: null
    }), frame.isNative()) return state.curPosition = null, frame;
    var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
    if (source) {
      var line = frame.getLineNumber(),
        column = frame.getColumnNumber() - 1,
        noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/,
        headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
      line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
      var position = mapSourcePosition({
        source: source,
        line: line,
        column: column
      });
      state.curPosition = position, frame = cloneCallSite(frame);
      var originalFunctionName = frame.getFunctionName;
      return frame.getFunctionName = function () {
        return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
      }, frame.getFileName = function () {
        return position.source;
      }, frame.getLineNumber = function () {
        return position.line;
      }, frame.getColumnNumber = function () {
        return position.column + 1;
      }, frame.getScriptNameOrSourceURL = function () {
        return position.source;
      }, frame;
    }
    var origin = frame.isEval() && frame.getEvalOrigin();
    return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function () {
      return origin;
    }), frame;
  }
  __name(wrapCallSite, "wrapCallSite");
  function prepareStackTrace(error, stack) {
    emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
    for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = {
        nextPosition: null,
        curPosition: null
      }, processedStack = [], i = stack.length - 1; i >= 0; i--) processedStack.push(`
    at ` + wrapCallSite(stack[i], state)), state.nextPosition = state.curPosition;
    return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
  }
  __name(prepareStackTrace, "prepareStackTrace");
  function getErrorSource(error) {
    var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
    if (match) {
      var source = match[1],
        line = +match[2],
        column = +match[3],
        contents = fileContentsCache[source];
      if (!contents && fs && fs.existsSync(source)) try {
        contents = fs.readFileSync(source, "utf8");
      } catch {
        contents = "";
      }
      if (contents) {
        var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
        if (code) return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
      }
    }
    return null;
  }
  __name(getErrorSource, "getErrorSource");
  function printErrorAndExit(error) {
    var source = getErrorSource(error),
      stderr = globalProcessStderr();
    stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
  }
  __name(printErrorAndExit, "printErrorAndExit");
  function shimEmitUncaughtException() {
    var origEmit = process.emit;
    process.emit = function (type) {
      if (type === "uncaughtException") {
        var hasStack = arguments[1] && arguments[1].stack,
          hasListeners = this.listeners(type).length > 0;
        if (hasStack && !hasListeners) return printErrorAndExit(arguments[1]);
      }
      return origEmit.apply(this, arguments);
    };
  }
  __name(shimEmitUncaughtException, "shimEmitUncaughtException");
  var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0),
    originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
  exports.wrapCallSite = wrapCallSite;
  exports.getErrorSource = getErrorSource;
  exports.mapSourcePosition = mapSourcePosition;
  exports.retrieveSourceMap = retrieveSourceMap;
  exports.install = function (options) {
    if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1)) throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
    if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
      var Module = dynamicRequire(module, "module"),
        $compile = Module.prototype._compile;
      $compile.__sourceMapSupport || (Module.prototype._compile = function (content, filename) {
        return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
      }, Module.prototype._compile.__sourceMapSupport = !0);
    }
    if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
      var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
      try {
        var worker_threads = dynamicRequire(module, "worker_threads");
        worker_threads.isMainThread === !1 && (installHandler = !1);
      } catch {}
      installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
    }
  };
  exports.resetRetrieveHandlers = function () {
    retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
  };
});
var require_register = __commonJSMin(() => {
  bM().install();
});
var Dc = T((exports, module) => {
  "use strict";

  var Gi = Object.create,
    je = Object.defineProperty,
    Ki = Object.getOwnPropertyDescriptor,
    Ji = Object.getOwnPropertyNames,
    Qi = Object.getPrototypeOf,
    Xi = Object.prototype.hasOwnProperty,
    a = l((e, t) => je(e, "name", {
      value: t,
      configurable: !0
    }), "a"),
    z = l((e, t) => () => (t || e((t = {
      exports: {}
    }).exports, t), t.exports), "z"),
    Yi = l((e, t) => {
      for (var r in t) je(e, r, {
        get: t[r],
        enumerable: !0
      });
    }, "Yi"),
    tr = l((e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function") for (let i of Ji(t)) !Xi.call(e, i) && i !== r && je(e, i, {
        get: () => t[i],
        enumerable: !(n = Ki(t, i)) || n.enumerable
      });
      return e;
    }, "tr"),
    ct = l((e, t, r) => (r = e != null ? Gi(Qi(e)) : {}, tr(t || !e || !e.__esModule ? je(r, "default", {
      value: e,
      enumerable: !0
    }) : r, e)), "ct"),
    eo = l(e => tr(je({}, "__esModule", {
      value: !0
    }), e), "eo"),
    require_tree_sitter = __commonJSMin((exports, module) => {
      var Module = Module !== void 0 ? Module : {},
        TreeSitter = function () {
          var initPromise,
            document = typeof window == "object" ? {
              currentScript: window.document.currentScript
            } : null;
          class Parser {
            static {
              __name(this, "Parser");
            }
            static {
              __name(this, "Parser");
            }
            constructor() {
              this.initialize();
            }
            initialize() {
              throw new Error("cannot construct a Parser before calling `init()`");
            }
            static init(moduleOptions) {
              return initPromise || (Module = Object.assign({}, Module, moduleOptions), initPromise = new Promise(resolveInitPromise => {
                var moduleOverrides = Object.assign({}, Module),
                  arguments_ = [],
                  thisProgram = "./this.program",
                  quit_ = __name((e, t) => {
                    throw t;
                  }, "quit_"),
                  ENVIRONMENT_IS_WEB = typeof window == "object",
                  ENVIRONMENT_IS_WORKER = typeof importScripts == "function",
                  ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string",
                  scriptDirectory = "",
                  read_,
                  readAsync,
                  readBinary,
                  setWindowTitle;
                function locateFile(e) {
                  return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
                }
                __name(locateFile, "locateFile"), __name(locateFile, "locateFile");
                function logExceptionOnExit(e) {
                  e instanceof ExitStatus || err("exiting due to exception: " + e);
                }
                if (__name(logExceptionOnExit, "logExceptionOnExit"), __name(logExceptionOnExit, "logExceptionOnExit"), ENVIRONMENT_IS_NODE) {
                  var fs = require("fs"),
                    nodePath = require("path");
                  scriptDirectory = ENVIRONMENT_IS_WORKER ? nodePath.dirname(scriptDirectory) + "/" : __dirname + "/", read_ = __name((e, t) => (e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFileSync(e, t ? void 0 : "utf8")), "read_"), readBinary = __name(e => {
                    var t = read_(e, !0);
                    return t.buffer || (t = new Uint8Array(t)), t;
                  }, "readBinary"), readAsync = __name((e, t, r) => {
                    e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFile(e, function (e, _) {
                      e ? r(e) : t(_.buffer);
                    });
                  }, "readAsync"), process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), typeof module < "u" && (module.exports = Module), quit_ = __name((e, t) => {
                    if (keepRuntimeAlive()) throw process.exitCode = e, t;
                    logExceptionOnExit(t), process.exit(e);
                  }, "quit_"), Module.inspect = function () {
                    return "[Emscripten Module object]";
                  };
                } else (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : document !== void 0 && document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = scriptDirectory.indexOf("blob:") !== 0 ? scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", read_ = __name(e => {
                  var t = new XMLHttpRequest();
                  return t.open("GET", e, !1), t.send(null), t.responseText;
                }, "read_"), ENVIRONMENT_IS_WORKER && (readBinary = __name(e => {
                  var t = new XMLHttpRequest();
                  return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
                }, "readBinary")), readAsync = __name((e, t, r) => {
                  var _ = new XMLHttpRequest();
                  _.open("GET", e, !0), _.responseType = "arraybuffer", _.onload = () => {
                    _.status == 200 || _.status == 0 && _.response ? t(_.response) : r();
                  }, _.onerror = r, _.send(null);
                }, "readAsync"), setWindowTitle = __name(e => document.title = e, "setWindowTitle"));
                var out = Module.print || console.log.bind(console),
                  err = Module.printErr || console.warn.bind(console);
                Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram), Module.quit && (quit_ = Module.quit);
                var STACK_ALIGN = 16,
                  dynamicLibraries = Module.dynamicLibraries || [],
                  wasmBinary;
                Module.wasmBinary && (wasmBinary = Module.wasmBinary);
                var noExitRuntime = Module.noExitRuntime || !0,
                  wasmMemory;
                typeof WebAssembly != "object" && abort("no native wasm support detected");
                var ABORT = !1,
                  EXITSTATUS,
                  UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
                  buffer,
                  HEAP8,
                  HEAPU8,
                  HEAP16,
                  HEAPU16,
                  HEAP32,
                  HEAPU32,
                  HEAPF32,
                  HEAPF64;
                function UTF8ArrayToString(e, t, r) {
                  for (var _ = t + r, n = t; e[n] && !(n >= _);) ++n;
                  if (n - t > 16 && e.buffer && UTF8Decoder) return UTF8Decoder.decode(e.subarray(t, n));
                  for (var s = ""; t < n;) {
                    var a = e[t++];
                    if (128 & a) {
                      var o = 63 & e[t++];
                      if ((224 & a) != 192) {
                        var i = 63 & e[t++];
                        if ((a = (240 & a) == 224 ? (15 & a) << 12 | o << 6 | i : (7 & a) << 18 | o << 12 | i << 6 | 63 & e[t++]) < 65536) s += String.fromCharCode(a);else {
                          var l = a - 65536;
                          s += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);
                        }
                      } else s += String.fromCharCode((31 & a) << 6 | o);
                    } else s += String.fromCharCode(a);
                  }
                  return s;
                }
                __name(UTF8ArrayToString, "UTF8ArrayToString"), __name(UTF8ArrayToString, "UTF8ArrayToString");
                function UTF8ToString(e, t) {
                  return e ? UTF8ArrayToString(HEAPU8, e, t) : "";
                }
                __name(UTF8ToString, "UTF8ToString"), __name(UTF8ToString, "UTF8ToString");
                function stringToUTF8Array(e, t, r, _) {
                  if (!(_ > 0)) return 0;
                  for (var n = r, s = r + _ - 1, a = 0; a < e.length; ++a) {
                    var o = e.charCodeAt(a);
                    if (o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e.charCodeAt(++a)), o <= 127) {
                      if (r >= s) break;
                      t[r++] = o;
                    } else if (o <= 2047) {
                      if (r + 1 >= s) break;
                      t[r++] = 192 | o >> 6, t[r++] = 128 | 63 & o;
                    } else if (o <= 65535) {
                      if (r + 2 >= s) break;
                      t[r++] = 224 | o >> 12, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                    } else {
                      if (r + 3 >= s) break;
                      t[r++] = 240 | o >> 18, t[r++] = 128 | o >> 12 & 63, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                    }
                  }
                  return t[r] = 0, r - n;
                }
                __name(stringToUTF8Array, "stringToUTF8Array"), __name(stringToUTF8Array, "stringToUTF8Array");
                function stringToUTF8(e, t, r) {
                  return stringToUTF8Array(e, HEAPU8, t, r);
                }
                __name(stringToUTF8, "stringToUTF8"), __name(stringToUTF8, "stringToUTF8");
                function lengthBytesUTF8(e) {
                  for (var t = 0, r = 0; r < e.length; ++r) {
                    var _ = e.charCodeAt(r);
                    _ <= 127 ? t++ : _ <= 2047 ? t += 2 : _ >= 55296 && _ <= 57343 ? (t += 4, ++r) : t += 3;
                  }
                  return t;
                }
                __name(lengthBytesUTF8, "lengthBytesUTF8"), __name(lengthBytesUTF8, "lengthBytesUTF8");
                function updateGlobalBufferAndViews(e) {
                  buffer = e, Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e);
                }
                __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews"), __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
                var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432;
                wasmMemory = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({
                  initial: INITIAL_MEMORY / 65536,
                  maximum: 32768
                }), wasmMemory && (buffer = wasmMemory.buffer), INITIAL_MEMORY = buffer.byteLength, updateGlobalBufferAndViews(buffer);
                var wasmTable = new WebAssembly.Table({
                    initial: 20,
                    element: "anyfunc"
                  }),
                  __ATPRERUN__ = [],
                  __ATINIT__ = [],
                  __ATMAIN__ = [],
                  __ATPOSTRUN__ = [],
                  __RELOC_FUNCS__ = [],
                  runtimeInitialized = !1;
                function keepRuntimeAlive() {
                  return noExitRuntime;
                }
                __name(keepRuntimeAlive, "keepRuntimeAlive"), __name(keepRuntimeAlive, "keepRuntimeAlive");
                function preRun() {
                  if (Module.preRun) for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length;) addOnPreRun(Module.preRun.shift());
                  callRuntimeCallbacks(__ATPRERUN__);
                }
                __name(preRun, "preRun"), __name(preRun, "preRun");
                function initRuntime() {
                  runtimeInitialized = !0, callRuntimeCallbacks(__RELOC_FUNCS__), callRuntimeCallbacks(__ATINIT__);
                }
                __name(initRuntime, "initRuntime"), __name(initRuntime, "initRuntime");
                function preMain() {
                  callRuntimeCallbacks(__ATMAIN__);
                }
                __name(preMain, "preMain"), __name(preMain, "preMain");
                function postRun() {
                  if (Module.postRun) for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length;) addOnPostRun(Module.postRun.shift());
                  callRuntimeCallbacks(__ATPOSTRUN__);
                }
                __name(postRun, "postRun"), __name(postRun, "postRun");
                function addOnPreRun(e) {
                  __ATPRERUN__.unshift(e);
                }
                __name(addOnPreRun, "addOnPreRun"), __name(addOnPreRun, "addOnPreRun");
                function addOnInit(e) {
                  __ATINIT__.unshift(e);
                }
                __name(addOnInit, "addOnInit"), __name(addOnInit, "addOnInit");
                function addOnPostRun(e) {
                  __ATPOSTRUN__.unshift(e);
                }
                __name(addOnPostRun, "addOnPostRun"), __name(addOnPostRun, "addOnPostRun");
                var runDependencies = 0,
                  runDependencyWatcher = null,
                  dependenciesFulfilled = null;
                function addRunDependency(e) {
                  runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies);
                }
                __name(addRunDependency, "addRunDependency"), __name(addRunDependency, "addRunDependency");
                function removeRunDependency(e) {
                  if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), runDependencies == 0 && (runDependencyWatcher !== null && (clearInterval(runDependencyWatcher), runDependencyWatcher = null), dependenciesFulfilled)) {
                    var t = dependenciesFulfilled;
                    dependenciesFulfilled = null, t();
                  }
                }
                __name(removeRunDependency, "removeRunDependency"), __name(removeRunDependency, "removeRunDependency");
                function abort(e) {
                  throw Module.onAbort && Module.onAbort(e), err(e = "Aborted(" + e + ")"), ABORT = !0, EXITSTATUS = 1, e += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(e);
                }
                __name(abort, "abort"), __name(abort, "abort");
                var dataURIPrefix = "data:application/octet-stream;base64,",
                  wasmBinaryFile,
                  tempDouble,
                  tempI64;
                function isDataURI(e) {
                  return e.startsWith(dataURIPrefix);
                }
                __name(isDataURI, "isDataURI"), __name(isDataURI, "isDataURI");
                function isFileURI(e) {
                  return e.startsWith("file://");
                }
                __name(isFileURI, "isFileURI"), __name(isFileURI, "isFileURI");
                function getBinary(e) {
                  try {
                    if (e == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                    if (readBinary) return readBinary(e);
                    throw "both async and sync fetching of the wasm failed";
                  } catch (e) {
                    abort(e);
                  }
                }
                __name(getBinary, "getBinary"), __name(getBinary, "getBinary");
                function getBinaryPromise() {
                  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                    if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                      credentials: "same-origin"
                    }).then(function (e) {
                      if (!e.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                      return e.arrayBuffer();
                    }).catch(function () {
                      return getBinary(wasmBinaryFile);
                    });
                    if (readAsync) return new Promise(function (e, t) {
                      readAsync(wasmBinaryFile, function (t) {
                        e(new Uint8Array(t));
                      }, t);
                    });
                  }
                  return Promise.resolve().then(function () {
                    return getBinary(wasmBinaryFile);
                  });
                }
                __name(getBinaryPromise, "getBinaryPromise"), __name(getBinaryPromise, "getBinaryPromise");
                function createWasm() {
                  var e = {
                    env: asmLibraryArg,
                    wasi_snapshot_preview1: asmLibraryArg,
                    "GOT.mem": new Proxy(asmLibraryArg, GOTHandler),
                    "GOT.func": new Proxy(asmLibraryArg, GOTHandler)
                  };
                  function t(e, t) {
                    var r = e.exports;
                    r = relocateExports(r, 1024);
                    var _ = getDylinkMetadata(t);
                    _.neededDynlibs && (dynamicLibraries = _.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(r, "main"), Module.asm = r, addOnInit(Module.asm.__wasm_call_ctors), __RELOC_FUNCS__.push(Module.asm.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate");
                  }
                  t(t, "t"), __name(t, "t");
                  function r(e) {
                    t(e.instance, e.module);
                  }
                  r(r, "r"), __name(r, "r");
                  function _(t) {
                    return getBinaryPromise().then(function (t) {
                      return WebAssembly.instantiate(t, e);
                    }).then(function (e) {
                      return e;
                    }).then(t, function (e) {
                      err("failed to asynchronously prepare wasm: " + e), abort(e);
                    });
                  }
                  if (_(_, "_"), __name(_, "_"), addRunDependency("wasm-instantiate"), Module.instantiateWasm) try {
                    return Module.instantiateWasm(e, t);
                  } catch (e) {
                    return err("Module.instantiateWasm callback failed with error: " + e), !1;
                  }
                  return wasmBinary || typeof WebAssembly.instantiateStreaming != "function" || isDataURI(wasmBinaryFile) || isFileURI(wasmBinaryFile) || ENVIRONMENT_IS_NODE || typeof fetch != "function" ? _(r) : fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                  }).then(function (t) {
                    return WebAssembly.instantiateStreaming(t, e).then(r, function (e) {
                      return err("wasm streaming compile failed: " + e), err("falling back to ArrayBuffer instantiation"), _(r);
                    });
                  }), {};
                }
                __name(createWasm, "createWasm"), __name(createWasm, "createWasm"), wasmBinaryFile = "tree-sitter.wasm", isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile));
                var ASM_CONSTS = {};
                function ExitStatus(e) {
                  this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e;
                }
                __name(ExitStatus, "ExitStatus"), __name(ExitStatus, "ExitStatus");
                var GOT = {},
                  CurrentModuleWeakSymbols = new Set([]),
                  GOTHandler = {
                    get: function (e, t) {
                      var r = GOT[t];
                      return r || (r = GOT[t] = new WebAssembly.Global({
                        value: "i32",
                        mutable: !0
                      })), CurrentModuleWeakSymbols.has(t) || (r.required = !0), r;
                    }
                  };
                function callRuntimeCallbacks(e) {
                  for (; e.length > 0;) e.shift()(Module);
                }
                __name(callRuntimeCallbacks, "callRuntimeCallbacks"), __name(callRuntimeCallbacks, "callRuntimeCallbacks");
                function getDylinkMetadata(e) {
                  var t = 0,
                    r = 0;
                  function _() {
                    for (var r = 0, _ = 1;;) {
                      var n = e[t++];
                      if (r += (127 & n) * _, _ *= 128, !(128 & n)) break;
                    }
                    return r;
                  }
                  _(_, "_"), __name(_, "_");
                  function n() {
                    var r = _();
                    return UTF8ArrayToString(e, (t += r) - r, r);
                  }
                  n(n, "i"), __name(n, "n");
                  function s(e, t) {
                    if (e) throw new Error(t);
                  }
                  s(s, "s"), __name(s, "s");
                  var a = "dylink.0";
                  if (e instanceof WebAssembly.Module) {
                    var o = WebAssembly.Module.customSections(e, a);
                    o.length === 0 && (a = "dylink", o = WebAssembly.Module.customSections(e, a)), s(o.length === 0, "need dylink section"), r = (e = new Uint8Array(o[0])).length;
                  } else {
                    s(new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0] != 1836278016, "need to see wasm magic number"), s(e[8] !== 0, "need the dylink section to be first"), t = 9;
                    var i = _();
                    r = t + i, a = n();
                  }
                  var l = {
                    neededDynlibs: [],
                    tlsExports: new Set(),
                    weakImports: new Set()
                  };
                  if (a == "dylink") {
                    l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();
                    for (var u = _(), d = 0; d < u; ++d) {
                      var c = n();
                      l.neededDynlibs.push(c);
                    }
                  } else for (s(a !== "dylink.0"); t < r;) {
                    var m = e[t++],
                      p = _();
                    if (m === 1) l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();else if (m === 2) for (u = _(), d = 0; d < u; ++d) c = n(), l.neededDynlibs.push(c);else if (m === 3) for (var f = _(); f--;) {
                      var h = n();
                      256 & _() && l.tlsExports.add(h);
                    } else if (m === 4) for (f = _(); f--;) n(), h = n(), (3 & _()) == 1 && l.weakImports.add(h);else t += p;
                  }
                  return l;
                }
                __name(getDylinkMetadata, "getDylinkMetadata"), __name(getDylinkMetadata, "getDylinkMetadata");
                function getValue(e, t = "i8") {
                  switch (t.endsWith("*") && (t = "*"), t) {
                    case "i1":
                    case "i8":
                      return HEAP8[e >> 0];
                    case "i16":
                      return HEAP16[e >> 1];
                    case "i32":
                    case "i64":
                      return HEAP32[e >> 2];
                    case "float":
                      return HEAPF32[e >> 2];
                    case "double":
                      return HEAPF64[e >> 3];
                    case "*":
                      return HEAPU32[e >> 2];
                    default:
                      abort("invalid type for getValue: " + t);
                  }
                  return null;
                }
                __name(getValue, "getValue"), __name(getValue, "getValue");
                function asmjsMangle(e) {
                  return e.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"].includes(e) ? e : "_" + e;
                }
                __name(asmjsMangle, "asmjsMangle"), __name(asmjsMangle, "asmjsMangle");
                function mergeLibSymbols(e, t) {
                  for (var r in e) if (e.hasOwnProperty(r)) {
                    asmLibraryArg.hasOwnProperty(r) || (asmLibraryArg[r] = e[r]);
                    var _ = asmjsMangle(r);
                    Module.hasOwnProperty(_) || (Module[_] = e[r]), r == "__main_argc_argv" && (Module._main = e[r]);
                  }
                }
                __name(mergeLibSymbols, "mergeLibSymbols"), __name(mergeLibSymbols, "mergeLibSymbols");
                var LDSO = {
                  loadedLibsByName: {},
                  loadedLibsByHandle: {}
                };
                function dynCallLegacy(e, t, r) {
                  var _ = Module["dynCall_" + e];
                  return r && r.length ? _.apply(null, [t].concat(r)) : _.call(null, t);
                }
                __name(dynCallLegacy, "dynCallLegacy"), __name(dynCallLegacy, "dynCallLegacy");
                var wasmTableMirror = [];
                function getWasmTableEntry(e) {
                  var t = wasmTableMirror[e];
                  return t || (e >= wasmTableMirror.length && (wasmTableMirror.length = e + 1), wasmTableMirror[e] = t = wasmTable.get(e)), t;
                }
                __name(getWasmTableEntry, "getWasmTableEntry"), __name(getWasmTableEntry, "getWasmTableEntry");
                function dynCall(e, t, r) {
                  return e.includes("j") ? dynCallLegacy(e, t, r) : getWasmTableEntry(t).apply(null, r);
                }
                __name(dynCall, "dynCall"), __name(dynCall, "dynCall");
                function createInvokeFunction(e) {
                  return function () {
                    var t = stackSave();
                    try {
                      return dynCall(e, arguments[0], Array.prototype.slice.call(arguments, 1));
                    } catch (e) {
                      if (stackRestore(t), e !== e + 0) throw e;
                      _setThrew(1, 0);
                    }
                  };
                }
                __name(createInvokeFunction, "createInvokeFunction"), __name(createInvokeFunction, "createInvokeFunction");
                var ___heap_base = 78144;
                function zeroMemory(e, t) {
                  return HEAPU8.fill(0, e, e + t), e;
                }
                __name(zeroMemory, "zeroMemory"), __name(zeroMemory, "zeroMemory");
                function getMemory(e) {
                  if (runtimeInitialized) return zeroMemory(_malloc(e), e);
                  var t = ___heap_base,
                    r = t + e + 15 & -16;
                  return ___heap_base = r, GOT.__heap_base.value = r, t;
                }
                __name(getMemory, "getMemory"), __name(getMemory, "getMemory");
                function isInternalSym(e) {
                  return ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm"].includes(e);
                }
                __name(isInternalSym, "isInternalSym"), __name(isInternalSym, "isInternalSym");
                function uleb128Encode(e, t) {
                  e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
                }
                __name(uleb128Encode, "uleb128Encode"), __name(uleb128Encode, "uleb128Encode");
                function sigToWasmTypes(e) {
                  for (var t = {
                      i: "i32",
                      j: "i32",
                      f: "f32",
                      d: "f64",
                      p: "i32"
                    }, r = {
                      parameters: [],
                      results: e[0] == "v" ? [] : [t[e[0]]]
                    }, _ = 1; _ < e.length; ++_) r.parameters.push(t[e[_]]), e[_] === "j" && r.parameters.push("i32");
                  return r;
                }
                __name(sigToWasmTypes, "sigToWasmTypes"), __name(sigToWasmTypes, "sigToWasmTypes");
                function generateFuncType(e, t) {
                  var r = e.slice(0, 1),
                    _ = e.slice(1),
                    n = {
                      i: 127,
                      p: 127,
                      j: 126,
                      f: 125,
                      d: 124
                    };
                  t.push(96), uleb128Encode(_.length, t);
                  for (var s = 0; s < _.length; ++s) t.push(n[_[s]]);
                  r == "v" ? t.push(0) : t.push(1, n[r]);
                }
                __name(generateFuncType, "generateFuncType"), __name(generateFuncType, "generateFuncType");
                function convertJsFunctionToWasm(e, t) {
                  if (typeof WebAssembly.Function == "function") return new WebAssembly.Function(sigToWasmTypes(t), e);
                  var r = [1];
                  generateFuncType(t, r);
                  var _ = [0, 97, 115, 109, 1, 0, 0, 0, 1];
                  uleb128Encode(r.length, _), _.push.apply(_, r), _.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
                  var n = new WebAssembly.Module(new Uint8Array(_));
                  return new WebAssembly.Instance(n, {
                    e: {
                      f: e
                    }
                  }).exports.f;
                }
                __name(convertJsFunctionToWasm, "convertJsFunctionToWasm"), __name(convertJsFunctionToWasm, "convertJsFunctionToWasm");
                function updateTableMap(e, t) {
                  if (functionsInTableMap) for (var r = e; r < e + t; r++) {
                    var _ = getWasmTableEntry(r);
                    _ && functionsInTableMap.set(_, r);
                  }
                }
                __name(updateTableMap, "updateTableMap"), __name(updateTableMap, "updateTableMap");
                var functionsInTableMap = void 0,
                  freeTableIndexes = [];
                function getEmptyTableSlot() {
                  if (freeTableIndexes.length) return freeTableIndexes.pop();
                  try {
                    wasmTable.grow(1);
                  } catch (e) {
                    throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
                  }
                  return wasmTable.length - 1;
                }
                __name(getEmptyTableSlot, "getEmptyTableSlot"), __name(getEmptyTableSlot, "getEmptyTableSlot");
                function setWasmTableEntry(e, t) {
                  wasmTable.set(e, t), wasmTableMirror[e] = wasmTable.get(e);
                }
                __name(setWasmTableEntry, "setWasmTableEntry"), __name(setWasmTableEntry, "setWasmTableEntry");
                function addFunction(e, t) {
                  if (functionsInTableMap || (functionsInTableMap = new WeakMap(), updateTableMap(0, wasmTable.length)), functionsInTableMap.has(e)) return functionsInTableMap.get(e);
                  var r = getEmptyTableSlot();
                  try {
                    setWasmTableEntry(r, e);
                  } catch (_) {
                    if (!(_ instanceof TypeError)) throw _;
                    setWasmTableEntry(r, convertJsFunctionToWasm(e, t));
                  }
                  return functionsInTableMap.set(e, r), r;
                }
                __name(addFunction, "addFunction"), __name(addFunction, "addFunction");
                function updateGOT(e, t) {
                  for (var r in e) if (!isInternalSym(r)) {
                    var _ = e[r];
                    r.startsWith("orig$") && (r = r.split("$")[1], t = !0), GOT[r] || (GOT[r] = new WebAssembly.Global({
                      value: "i32",
                      mutable: !0
                    })), (t || GOT[r].value == 0) && (typeof _ == "function" ? GOT[r].value = addFunction(_) : typeof _ == "number" ? GOT[r].value = _ : err("unhandled export type for `" + r + "`: " + typeof _));
                  }
                }
                __name(updateGOT, "updateGOT"), __name(updateGOT, "updateGOT");
                function relocateExports(e, t, r) {
                  var _ = {};
                  for (var n in e) {
                    var s = e[n];
                    typeof s == "object" && (s = s.value), typeof s == "number" && (s += t), _[n] = s;
                  }
                  return updateGOT(_, r), _;
                }
                __name(relocateExports, "relocateExports"), __name(relocateExports, "relocateExports");
                function resolveGlobalSymbol(e, t) {
                  var r;
                  return t && (r = asmLibraryArg["orig$" + e]), r || (r = asmLibraryArg[e]) && r.stub && (r = void 0), r || (r = Module[asmjsMangle(e)]), !r && e.startsWith("invoke_") && (r = createInvokeFunction(e.split("_")[1])), r;
                }
                __name(resolveGlobalSymbol, "resolveGlobalSymbol"), __name(resolveGlobalSymbol, "resolveGlobalSymbol");
                function alignMemory(e, t) {
                  return Math.ceil(e / t) * t;
                }
                __name(alignMemory, "alignMemory"), __name(alignMemory, "alignMemory");
                function loadWebAssemblyModule(binary, flags, handle) {
                  var metadata = getDylinkMetadata(binary);
                  function loadModule() {
                    var firstLoad = !handle || !HEAP8[handle + 12 >> 0];
                    if (firstLoad) {
                      var memAlign = Math.pow(2, metadata.memoryAlign);
                      memAlign = Math.max(memAlign, STACK_ALIGN);
                      var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0,
                        tableBase = metadata.tableSize ? wasmTable.length : 0;
                      handle && (HEAP8[handle + 12 >> 0] = 1, HEAPU32[handle + 16 >> 2] = memoryBase, HEAP32[handle + 20 >> 2] = metadata.memorySize, HEAPU32[handle + 24 >> 2] = tableBase, HEAP32[handle + 28 >> 2] = metadata.tableSize);
                    } else memoryBase = HEAPU32[handle + 16 >> 2], tableBase = HEAPU32[handle + 24 >> 2];
                    var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length,
                      moduleExports;
                    function resolveSymbol(e) {
                      var t = resolveGlobalSymbol(e, !1);
                      return t || (t = moduleExports[e]), t;
                    }
                    __name(resolveSymbol, "resolveSymbol"), __name(resolveSymbol, "resolveSymbol"), tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
                    var proxyHandler = {
                        get: function (e, t) {
                          switch (t) {
                            case "__memory_base":
                              return memoryBase;
                            case "__table_base":
                              return tableBase;
                          }
                          if (t in asmLibraryArg) return asmLibraryArg[t];
                          var r;
                          return t in e || (e[t] = function () {
                            return r || (r = resolveSymbol(t)), r.apply(null, arguments);
                          }), e[t];
                        }
                      },
                      proxy = new Proxy({}, proxyHandler),
                      info = {
                        "GOT.mem": new Proxy({}, GOTHandler),
                        "GOT.func": new Proxy({}, GOTHandler),
                        env: proxy,
                        wasi_snapshot_preview1: proxy
                      };
                    function postInstantiation(instance) {
                      function addEmAsm(addr, body) {
                        for (var args = [], arity = 0; arity < 16 && body.indexOf("$" + arity) != -1; arity++) args.push("$" + arity);
                        args = args.join(",");
                        var func = "(" + args + " ) => { " + body + "};";
                        ASM_CONSTS[start] = eval(func);
                      }
                      if (__name(addEmAsm, "addEmAsm"), __name(addEmAsm, "addEmAsm"), updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols(), "__start_em_asm" in moduleExports) for (var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start < stop;) {
                        var jsString = UTF8ToString(start);
                        addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
                      }
                      var applyRelocs = moduleExports.__wasm_apply_data_relocs;
                      applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
                      var init = moduleExports.__wasm_call_ctors;
                      return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
                    }
                    if (__name(postInstantiation, "postInstantiation"), __name(postInstantiation, "postInstantiation"), flags.loadAsync) {
                      if (binary instanceof WebAssembly.Module) {
                        var instance = new WebAssembly.Instance(binary, info);
                        return Promise.resolve(postInstantiation(instance));
                      }
                      return WebAssembly.instantiate(binary, info).then(function (e) {
                        return postInstantiation(e.instance);
                      });
                    }
                    var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
                      instance = new WebAssembly.Instance(module, info);
                    return postInstantiation(instance);
                  }
                  return __name(loadModule, "loadModule"), __name(loadModule, "loadModule"), CurrentModuleWeakSymbols = metadata.weakImports, flags.loadAsync ? metadata.neededDynlibs.reduce(function (e, t) {
                    return e.then(function () {
                      return loadDynamicLibrary(t, flags);
                    });
                  }, Promise.resolve()).then(function () {
                    return loadModule();
                  }) : (metadata.neededDynlibs.forEach(function (e) {
                    loadDynamicLibrary(e, flags);
                  }), loadModule());
                }
                __name(loadWebAssemblyModule, "loadWebAssemblyModule"), __name(loadWebAssemblyModule, "loadWebAssemblyModule");
                function loadDynamicLibrary(e, t, r) {
                  t = t || {
                    global: !0,
                    nodelete: !0
                  };
                  var _ = LDSO.loadedLibsByName[e];
                  if (_) return t.global && !_.global && (_.global = !0, _.module !== "loading" && mergeLibSymbols(_.module, e)), t.nodelete && _.refcount !== 1 / 0 && (_.refcount = 1 / 0), _.refcount++, r && (LDSO.loadedLibsByHandle[r] = _), !t.loadAsync || Promise.resolve(!0);
                  function n(e) {
                    if (t.fs && t.fs.findObject(e)) {
                      var r = t.fs.readFile(e, {
                        encoding: "binary"
                      });
                      return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r;
                    }
                    if (e = locateFile(e), t.loadAsync) return new Promise(function (t, r) {
                      readAsync(e, e => t(new Uint8Array(e)), r);
                    });
                    if (!readBinary) throw new Error(e + ": file not found, and synchronous loading of external files is not available");
                    return readBinary(e);
                  }
                  n(n, "i"), __name(n, "n");
                  function s() {
                    if (typeof preloadedWasm < "u" && preloadedWasm[e]) {
                      var _ = preloadedWasm[e];
                      return t.loadAsync ? Promise.resolve(_) : _;
                    }
                    return t.loadAsync ? n(e).then(function (e) {
                      return loadWebAssemblyModule(e, t, r);
                    }) : loadWebAssemblyModule(n(e), t, r);
                  }
                  s(s, "s"), __name(s, "s");
                  function a(t) {
                    _.global && mergeLibSymbols(t, e), _.module = t;
                  }
                  return a(a, "a"), __name(a, "a"), _ = {
                    refcount: t.nodelete ? 1 / 0 : 1,
                    name: e,
                    module: "loading",
                    global: t.global
                  }, LDSO.loadedLibsByName[e] = _, r && (LDSO.loadedLibsByHandle[r] = _), t.loadAsync ? s().then(function (e) {
                    return a(e), !0;
                  }) : (a(s()), !0);
                }
                __name(loadDynamicLibrary, "loadDynamicLibrary"), __name(loadDynamicLibrary, "loadDynamicLibrary");
                function reportUndefinedSymbols() {
                  for (var e in GOT) if (GOT[e].value == 0) {
                    var t = resolveGlobalSymbol(e, !0);
                    if (!t && !GOT[e].required) continue;
                    if (typeof t == "function") GOT[e].value = addFunction(t, t.sig);else {
                      if (typeof t != "number") throw new Error("bad export type for `" + e + "`: " + typeof t);
                      GOT[e].value = t;
                    }
                  }
                }
                __name(reportUndefinedSymbols, "reportUndefinedSymbols"), __name(reportUndefinedSymbols, "reportUndefinedSymbols");
                function preloadDylibs() {
                  dynamicLibraries.length ? (addRunDependency("preloadDylibs"), dynamicLibraries.reduce(function (e, t) {
                    return e.then(function () {
                      return loadDynamicLibrary(t, {
                        loadAsync: !0,
                        global: !0,
                        nodelete: !0,
                        allowUndefined: !0
                      });
                    });
                  }, Promise.resolve()).then(function () {
                    reportUndefinedSymbols(), removeRunDependency("preloadDylibs");
                  })) : reportUndefinedSymbols();
                }
                __name(preloadDylibs, "preloadDylibs"), __name(preloadDylibs, "preloadDylibs");
                function setValue(e, t, r = "i8") {
                  switch (r.endsWith("*") && (r = "*"), r) {
                    case "i1":
                    case "i8":
                      HEAP8[e >> 0] = t;
                      break;
                    case "i16":
                      HEAP16[e >> 1] = t;
                      break;
                    case "i32":
                      HEAP32[e >> 2] = t;
                      break;
                    case "i64":
                      tempI64 = [t >>> 0, (tempDouble = t, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[e >> 2] = tempI64[0], HEAP32[e + 4 >> 2] = tempI64[1];
                      break;
                    case "float":
                      HEAPF32[e >> 2] = t;
                      break;
                    case "double":
                      HEAPF64[e >> 3] = t;
                      break;
                    case "*":
                      HEAPU32[e >> 2] = t;
                      break;
                    default:
                      abort("invalid type for setValue: " + r);
                  }
                }
                __name(setValue, "setValue"), __name(setValue, "setValue");
                var ___memory_base = new WebAssembly.Global({
                    value: "i32",
                    mutable: !1
                  }, 1024),
                  ___stack_pointer = new WebAssembly.Global({
                    value: "i32",
                    mutable: !0
                  }, 78144),
                  ___table_base = new WebAssembly.Global({
                    value: "i32",
                    mutable: !1
                  }, 1),
                  nowIsMonotonic = !0,
                  _emscripten_get_now;
                function __emscripten_get_now_is_monotonic() {
                  return nowIsMonotonic;
                }
                __name(__emscripten_get_now_is_monotonic, "__emscripten_get_now_is_monotonic"), __name(__emscripten_get_now_is_monotonic, "__emscripten_get_now_is_monotonic");
                function _abort() {
                  abort("");
                }
                __name(_abort, "_abort"), __name(_abort, "_abort");
                function _emscripten_date_now() {
                  return Date.now();
                }
                __name(_emscripten_date_now, "_emscripten_date_now"), __name(_emscripten_date_now, "_emscripten_date_now");
                function _emscripten_memcpy_big(e, t, r) {
                  HEAPU8.copyWithin(e, t, t + r);
                }
                __name(_emscripten_memcpy_big, "_emscripten_memcpy_big"), __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
                function getHeapMax() {
                  return 2147483648;
                }
                __name(getHeapMax, "getHeapMax"), __name(getHeapMax, "getHeapMax");
                function emscripten_realloc_buffer(e) {
                  try {
                    return wasmMemory.grow(e - buffer.byteLength + 65535 >>> 16), updateGlobalBufferAndViews(wasmMemory.buffer), 1;
                  } catch {}
                }
                __name(emscripten_realloc_buffer, "emscripten_realloc_buffer"), __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
                function _emscripten_resize_heap(e) {
                  var t = HEAPU8.length;
                  e >>>= 0;
                  var r = getHeapMax();
                  if (e > r) return !1;
                  for (var _ = 1; _ <= 4; _ *= 2) {
                    var n = t * (1 + .2 / _);
                    if (n = Math.min(n, e + 100663296), emscripten_realloc_buffer(Math.min(r, (s = Math.max(e, n)) + ((a = 65536) - s % a) % a))) return !0;
                  }
                  var s, a;
                  return !1;
                }
                __name(_emscripten_resize_heap, "_emscripten_resize_heap"), __name(_emscripten_resize_heap, "_emscripten_resize_heap"), __emscripten_get_now_is_monotonic.sig = "i", Module._abort = _abort, _abort.sig = "v", _emscripten_date_now.sig = "d", _emscripten_get_now = ENVIRONMENT_IS_NODE ? () => {
                  var e = process.hrtime();
                  return 1e3 * e[0] + e[1] / 1e6;
                } : () => performance.now(), _emscripten_get_now.sig = "d", _emscripten_memcpy_big.sig = "vppp", _emscripten_resize_heap.sig = "ip";
                var SYSCALLS = {
                  DEFAULT_POLLMASK: 5,
                  calculateAt: function (e, t, r) {
                    if (PATH.isAbs(t)) return t;
                    var _;
                    if (e === -100 ? _ = FS.cwd() : _ = SYSCALLS.getStreamFromFD(e).path, t.length == 0) {
                      if (!r) throw new FS.ErrnoError(44);
                      return _;
                    }
                    return PATH.join2(_, t);
                  },
                  doStat: function (e, t, r) {
                    try {
                      var _ = e(t);
                    } catch (e) {
                      if (e && e.node && PATH.normalize(t) !== PATH.normalize(FS.getPath(e.node))) return -54;
                      throw e;
                    }
                    HEAP32[r >> 2] = _.dev, HEAP32[r + 8 >> 2] = _.ino, HEAP32[r + 12 >> 2] = _.mode, HEAPU32[r + 16 >> 2] = _.nlink, HEAP32[r + 20 >> 2] = _.uid, HEAP32[r + 24 >> 2] = _.gid, HEAP32[r + 28 >> 2] = _.rdev, tempI64 = [_.size >>> 0, (tempDouble = _.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 40 >> 2] = tempI64[0], HEAP32[r + 44 >> 2] = tempI64[1], HEAP32[r + 48 >> 2] = 4096, HEAP32[r + 52 >> 2] = _.blocks;
                    var n = _.atime.getTime(),
                      s = _.mtime.getTime(),
                      a = _.ctime.getTime();
                    return tempI64 = [Math.floor(n / 1e3) >>> 0, (tempDouble = Math.floor(n / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 56 >> 2] = tempI64[0], HEAP32[r + 60 >> 2] = tempI64[1], HEAPU32[r + 64 >> 2] = n % 1e3 * 1e3, tempI64 = [Math.floor(s / 1e3) >>> 0, (tempDouble = Math.floor(s / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 72 >> 2] = tempI64[0], HEAP32[r + 76 >> 2] = tempI64[1], HEAPU32[r + 80 >> 2] = s % 1e3 * 1e3, tempI64 = [Math.floor(a / 1e3) >>> 0, (tempDouble = Math.floor(a / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 88 >> 2] = tempI64[0], HEAP32[r + 92 >> 2] = tempI64[1], HEAPU32[r + 96 >> 2] = a % 1e3 * 1e3, tempI64 = [_.ino >>> 0, (tempDouble = _.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 104 >> 2] = tempI64[0], HEAP32[r + 108 >> 2] = tempI64[1], 0;
                  },
                  doMsync: function (e, t, r, _, n) {
                    if (!FS.isFile(t.node.mode)) throw new FS.ErrnoError(43);
                    if (2 & _) return 0;
                    var s = HEAPU8.slice(e, e + r);
                    FS.msync(t, s, n, r, _);
                  },
                  varargs: void 0,
                  get: function () {
                    return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2];
                  },
                  getStr: function (e) {
                    return UTF8ToString(e);
                  },
                  getStreamFromFD: function (e) {
                    var t = FS.getStream(e);
                    if (!t) throw new FS.ErrnoError(8);
                    return t;
                  }
                };
                function _proc_exit(e) {
                  EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit && Module.onExit(e), ABORT = !0), quit_(e, new ExitStatus(e));
                }
                __name(_proc_exit, "_proc_exit"), __name(_proc_exit, "_proc_exit");
                function exitJS(e, t) {
                  EXITSTATUS = e, _proc_exit(e);
                }
                __name(exitJS, "exitJS"), __name(exitJS, "exitJS"), _proc_exit.sig = "vi";
                var _exit = exitJS;
                function _fd_close(e) {
                  try {
                    var t = SYSCALLS.getStreamFromFD(e);
                    return FS.close(t), 0;
                  } catch (e) {
                    if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                    return e.errno;
                  }
                }
                __name(_fd_close, "_fd_close"), __name(_fd_close, "_fd_close");
                function convertI32PairToI53Checked(e, t) {
                  return t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN;
                }
                __name(convertI32PairToI53Checked, "convertI32PairToI53Checked"), __name(convertI32PairToI53Checked, "convertI32PairToI53Checked");
                function _fd_seek(e, t, r, _, n) {
                  try {
                    var s = convertI32PairToI53Checked(t, r);
                    if (isNaN(s)) return 61;
                    var a = SYSCALLS.getStreamFromFD(e);
                    return FS.llseek(a, s, _), tempI64 = [a.position >>> 0, (tempDouble = a.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[n >> 2] = tempI64[0], HEAP32[n + 4 >> 2] = tempI64[1], a.getdents && s === 0 && _ === 0 && (a.getdents = null), 0;
                  } catch (e) {
                    if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                    return e.errno;
                  }
                }
                __name(_fd_seek, "_fd_seek"), __name(_fd_seek, "_fd_seek");
                function doWritev(e, t, r, _) {
                  for (var n = 0, s = 0; s < r; s++) {
                    var a = HEAPU32[t >> 2],
                      o = HEAPU32[t + 4 >> 2];
                    t += 8;
                    var i = FS.write(e, HEAP8, a, o, _);
                    if (i < 0) return -1;
                    n += i, _ !== void 0 && (_ += i);
                  }
                  return n;
                }
                __name(doWritev, "doWritev"), __name(doWritev, "doWritev");
                function _fd_write(e, t, r, _) {
                  try {
                    var n = doWritev(SYSCALLS.getStreamFromFD(e), t, r);
                    return HEAPU32[_ >> 2] = n, 0;
                  } catch (e) {
                    if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                    return e.errno;
                  }
                }
                __name(_fd_write, "_fd_write"), __name(_fd_write, "_fd_write");
                function _tree_sitter_log_callback(e, t) {
                  if (currentLogCallback) {
                    let r = UTF8ToString(t);
                    currentLogCallback(r, e !== 0);
                  }
                }
                __name(_tree_sitter_log_callback, "_tree_sitter_log_callback"), __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
                function _tree_sitter_parse_callback(e, t, r, _, n) {
                  var s = currentParseCallback(t, {
                    row: r,
                    column: _
                  });
                  typeof s == "string" ? (setValue(n, s.length, "i32"), stringToUTF16(s, e, 10240)) : setValue(n, 0, "i32");
                }
                __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback"), __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
                function handleException(e) {
                  if (e instanceof ExitStatus || e == "unwind") return EXITSTATUS;
                  quit_(1, e);
                }
                __name(handleException, "handleException"), __name(handleException, "handleException");
                function allocateUTF8OnStack(e) {
                  var t = lengthBytesUTF8(e) + 1,
                    r = stackAlloc(t);
                  return stringToUTF8Array(e, HEAP8, r, t), r;
                }
                __name(allocateUTF8OnStack, "allocateUTF8OnStack"), __name(allocateUTF8OnStack, "allocateUTF8OnStack");
                function stringToUTF16(e, t, r) {
                  if (r === void 0 && (r = 2147483647), r < 2) return 0;
                  for (var _ = t, n = (r -= 2) < 2 * e.length ? r / 2 : e.length, s = 0; s < n; ++s) {
                    var a = e.charCodeAt(s);
                    HEAP16[t >> 1] = a, t += 2;
                  }
                  return HEAP16[t >> 1] = 0, t - _;
                }
                __name(stringToUTF16, "stringToUTF16"), __name(stringToUTF16, "stringToUTF16");
                function AsciiToString(e) {
                  for (var t = "";;) {
                    var r = HEAPU8[e++ >> 0];
                    if (!r) return t;
                    t += String.fromCharCode(r);
                  }
                }
                __name(AsciiToString, "AsciiToString"), __name(AsciiToString, "AsciiToString"), _exit.sig = "vi", _fd_close.sig = "ii", _fd_seek.sig = "iijip", _fd_write.sig = "iippp";
                var asmLibraryArg = {
                    __heap_base: ___heap_base,
                    __indirect_function_table: wasmTable,
                    __memory_base: ___memory_base,
                    __stack_pointer: ___stack_pointer,
                    __table_base: ___table_base,
                    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
                    abort: _abort,
                    emscripten_get_now: _emscripten_get_now,
                    emscripten_memcpy_big: _emscripten_memcpy_big,
                    emscripten_resize_heap: _emscripten_resize_heap,
                    exit: _exit,
                    fd_close: _fd_close,
                    fd_seek: _fd_seek,
                    fd_write: _fd_write,
                    memory: wasmMemory,
                    tree_sitter_log_callback: _tree_sitter_log_callback,
                    tree_sitter_parse_callback: _tree_sitter_parse_callback
                  },
                  asm = createWasm(),
                  ___wasm_call_ctors = Module.___wasm_call_ctors = function () {
                    return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
                  },
                  ___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = function () {
                    return (___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = Module.asm.__wasm_apply_data_relocs).apply(null, arguments);
                  },
                  _malloc = Module._malloc = function () {
                    return (_malloc = Module._malloc = Module.asm.malloc).apply(null, arguments);
                  },
                  _calloc = Module._calloc = function () {
                    return (_calloc = Module._calloc = Module.asm.calloc).apply(null, arguments);
                  },
                  _realloc = Module._realloc = function () {
                    return (_realloc = Module._realloc = Module.asm.realloc).apply(null, arguments);
                  },
                  _free = Module._free = function () {
                    return (_free = Module._free = Module.asm.free).apply(null, arguments);
                  },
                  _ts_language_symbol_count = Module._ts_language_symbol_count = function () {
                    return (_ts_language_symbol_count = Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
                  },
                  _ts_language_version = Module._ts_language_version = function () {
                    return (_ts_language_version = Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
                  },
                  _ts_language_field_count = Module._ts_language_field_count = function () {
                    return (_ts_language_field_count = Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
                  },
                  _ts_language_symbol_name = Module._ts_language_symbol_name = function () {
                    return (_ts_language_symbol_name = Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
                  },
                  _ts_language_symbol_for_name = Module._ts_language_symbol_for_name = function () {
                    return (_ts_language_symbol_for_name = Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
                  },
                  _ts_language_symbol_type = Module._ts_language_symbol_type = function () {
                    return (_ts_language_symbol_type = Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
                  },
                  _ts_language_field_name_for_id = Module._ts_language_field_name_for_id = function () {
                    return (_ts_language_field_name_for_id = Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
                  },
                  _memset = Module._memset = function () {
                    return (_memset = Module._memset = Module.asm.memset).apply(null, arguments);
                  },
                  _memcpy = Module._memcpy = function () {
                    return (_memcpy = Module._memcpy = Module.asm.memcpy).apply(null, arguments);
                  },
                  _ts_parser_delete = Module._ts_parser_delete = function () {
                    return (_ts_parser_delete = Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
                  },
                  _ts_parser_reset = Module._ts_parser_reset = function () {
                    return (_ts_parser_reset = Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
                  },
                  _ts_parser_set_language = Module._ts_parser_set_language = function () {
                    return (_ts_parser_set_language = Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
                  },
                  _ts_parser_timeout_micros = Module._ts_parser_timeout_micros = function () {
                    return (_ts_parser_timeout_micros = Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
                  },
                  _ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = function () {
                    return (_ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
                  },
                  _memmove = Module._memmove = function () {
                    return (_memmove = Module._memmove = Module.asm.memmove).apply(null, arguments);
                  },
                  _memcmp = Module._memcmp = function () {
                    return (_memcmp = Module._memcmp = Module.asm.memcmp).apply(null, arguments);
                  },
                  _ts_query_new = Module._ts_query_new = function () {
                    return (_ts_query_new = Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
                  },
                  _ts_query_delete = Module._ts_query_delete = function () {
                    return (_ts_query_delete = Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
                  },
                  _iswspace = Module._iswspace = function () {
                    return (_iswspace = Module._iswspace = Module.asm.iswspace).apply(null, arguments);
                  },
                  _iswalnum = Module._iswalnum = function () {
                    return (_iswalnum = Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
                  },
                  _ts_query_pattern_count = Module._ts_query_pattern_count = function () {
                    return (_ts_query_pattern_count = Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
                  },
                  _ts_query_capture_count = Module._ts_query_capture_count = function () {
                    return (_ts_query_capture_count = Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
                  },
                  _ts_query_string_count = Module._ts_query_string_count = function () {
                    return (_ts_query_string_count = Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
                  },
                  _ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = function () {
                    return (_ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
                  },
                  _ts_query_string_value_for_id = Module._ts_query_string_value_for_id = function () {
                    return (_ts_query_string_value_for_id = Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
                  },
                  _ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = function () {
                    return (_ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
                  },
                  _ts_tree_copy = Module._ts_tree_copy = function () {
                    return (_ts_tree_copy = Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
                  },
                  _ts_tree_delete = Module._ts_tree_delete = function () {
                    return (_ts_tree_delete = Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
                  },
                  _ts_init = Module._ts_init = function () {
                    return (_ts_init = Module._ts_init = Module.asm.ts_init).apply(null, arguments);
                  },
                  _ts_parser_new_wasm = Module._ts_parser_new_wasm = function () {
                    return (_ts_parser_new_wasm = Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
                  },
                  _ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = function () {
                    return (_ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
                  },
                  _ts_parser_parse_wasm = Module._ts_parser_parse_wasm = function () {
                    return (_ts_parser_parse_wasm = Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
                  },
                  _ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = function () {
                    return (_ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
                  },
                  _ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = function () {
                    return (_ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
                  },
                  _ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = function () {
                    return (_ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
                  },
                  _ts_tree_edit_wasm = Module._ts_tree_edit_wasm = function () {
                    return (_ts_tree_edit_wasm = Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
                  },
                  _ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = function () {
                    return (_ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = function () {
                    return (_ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = function () {
                    return (_ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = function () {
                    return (_ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = function () {
                    return (_ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = function () {
                    return (_ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = function () {
                    return (_ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = function () {
                    return (_ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = function () {
                    return (_ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = function () {
                    return (_ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = function () {
                    return (_ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = function () {
                    return (_ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = function () {
                    return (_ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = function () {
                    return (_ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = function () {
                    return (_ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = function () {
                    return (_ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
                  },
                  _ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = function () {
                    return (_ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
                  },
                  _ts_node_symbol_wasm = Module._ts_node_symbol_wasm = function () {
                    return (_ts_node_symbol_wasm = Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
                  },
                  _ts_node_child_count_wasm = Module._ts_node_child_count_wasm = function () {
                    return (_ts_node_child_count_wasm = Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
                  },
                  _ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = function () {
                    return (_ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
                  },
                  _ts_node_child_wasm = Module._ts_node_child_wasm = function () {
                    return (_ts_node_child_wasm = Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
                  },
                  _ts_node_named_child_wasm = Module._ts_node_named_child_wasm = function () {
                    return (_ts_node_named_child_wasm = Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
                  },
                  _ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = function () {
                    return (_ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
                  },
                  _ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = function () {
                    return (_ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
                  },
                  _ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = function () {
                    return (_ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
                  },
                  _ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = function () {
                    return (_ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
                  },
                  _ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = function () {
                    return (_ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
                  },
                  _ts_node_parent_wasm = Module._ts_node_parent_wasm = function () {
                    return (_ts_node_parent_wasm = Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
                  },
                  _ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = function () {
                    return (_ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
                  },
                  _ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = function () {
                    return (_ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
                  },
                  _ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = function () {
                    return (_ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
                  },
                  _ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = function () {
                    return (_ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
                  },
                  _ts_node_start_point_wasm = Module._ts_node_start_point_wasm = function () {
                    return (_ts_node_start_point_wasm = Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
                  },
                  _ts_node_end_point_wasm = Module._ts_node_end_point_wasm = function () {
                    return (_ts_node_end_point_wasm = Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
                  },
                  _ts_node_start_index_wasm = Module._ts_node_start_index_wasm = function () {
                    return (_ts_node_start_index_wasm = Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
                  },
                  _ts_node_end_index_wasm = Module._ts_node_end_index_wasm = function () {
                    return (_ts_node_end_index_wasm = Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
                  },
                  _ts_node_to_string_wasm = Module._ts_node_to_string_wasm = function () {
                    return (_ts_node_to_string_wasm = Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
                  },
                  _ts_node_children_wasm = Module._ts_node_children_wasm = function () {
                    return (_ts_node_children_wasm = Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
                  },
                  _ts_node_named_children_wasm = Module._ts_node_named_children_wasm = function () {
                    return (_ts_node_named_children_wasm = Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
                  },
                  _ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = function () {
                    return (_ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
                  },
                  _ts_node_is_named_wasm = Module._ts_node_is_named_wasm = function () {
                    return (_ts_node_is_named_wasm = Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
                  },
                  _ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = function () {
                    return (_ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
                  },
                  _ts_node_has_error_wasm = Module._ts_node_has_error_wasm = function () {
                    return (_ts_node_has_error_wasm = Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
                  },
                  _ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = function () {
                    return (_ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
                  },
                  _ts_query_matches_wasm = Module._ts_query_matches_wasm = function () {
                    return (_ts_query_matches_wasm = Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
                  },
                  _ts_query_captures_wasm = Module._ts_query_captures_wasm = function () {
                    return (_ts_query_captures_wasm = Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
                  },
                  ___cxa_atexit = Module.___cxa_atexit = function () {
                    return (___cxa_atexit = Module.___cxa_atexit = Module.asm.__cxa_atexit).apply(null, arguments);
                  },
                  _iswdigit = Module._iswdigit = function () {
                    return (_iswdigit = Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
                  },
                  _iswalpha = Module._iswalpha = function () {
                    return (_iswalpha = Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
                  },
                  _iswlower = Module._iswlower = function () {
                    return (_iswlower = Module._iswlower = Module.asm.iswlower).apply(null, arguments);
                  },
                  _memchr = Module._memchr = function () {
                    return (_memchr = Module._memchr = Module.asm.memchr).apply(null, arguments);
                  },
                  _strlen = Module._strlen = function () {
                    return (_strlen = Module._strlen = Module.asm.strlen).apply(null, arguments);
                  },
                  _towupper = Module._towupper = function () {
                    return (_towupper = Module._towupper = Module.asm.towupper).apply(null, arguments);
                  },
                  _setThrew = Module._setThrew = function () {
                    return (_setThrew = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
                  },
                  stackSave = Module.stackSave = function () {
                    return (stackSave = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
                  },
                  stackRestore = Module.stackRestore = function () {
                    return (stackRestore = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
                  },
                  stackAlloc = Module.stackAlloc = function () {
                    return (stackAlloc = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
                  },
                  __Znwm = Module.__Znwm = function () {
                    return (__Znwm = Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
                  },
                  __ZdlPv = Module.__ZdlPv = function () {
                    return (__ZdlPv = Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
                  },
                  __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {
                    return (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {
                    return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
                  },
                  __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = function () {
                    return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw).apply(null, arguments);
                  },
                  dynCall_jiji = Module.dynCall_jiji = function () {
                    return (dynCall_jiji = Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments);
                  },
                  _orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = function () {
                    return (_orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
                  },
                  _orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = function () {
                    return (_orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
                  },
                  calledRun;
                function callMain(e) {
                  var t = Module._main;
                  if (t) {
                    (e = e || []).unshift(thisProgram);
                    var r = e.length,
                      _ = stackAlloc(4 * (r + 1)),
                      n = _ >> 2;
                    e.forEach(e => {
                      HEAP32[n++] = allocateUTF8OnStack(e);
                    }), HEAP32[n] = 0;
                    try {
                      var s = t(r, _);
                      return exitJS(s, !0), s;
                    } catch (e) {
                      return handleException(e);
                    }
                  }
                }
                __name(callMain, "callMain"), __name(callMain, "callMain"), Module.AsciiToString = AsciiToString, Module.stringToUTF16 = stringToUTF16, dependenciesFulfilled = __name(__name(function e() {
                  calledRun || run(), calledRun || (dependenciesFulfilled = e);
                }, "n"), "e");
                var dylibsLoaded = !1;
                function run(e) {
                  function t() {
                    calledRun || (calledRun = !0, Module.calledRun = !0, ABORT || (initRuntime(), preMain(), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), shouldRunNow && callMain(e), postRun()));
                  }
                  t(t, "t"), __name(t, "t"), e = e || arguments_, runDependencies > 0 || !dylibsLoaded && (preloadDylibs(), dylibsLoaded = !0, runDependencies > 0) || (preRun(), runDependencies > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function () {
                    setTimeout(function () {
                      Module.setStatus("");
                    }, 1), t();
                  }, 1)) : t()));
                }
                if (__name(run, "run"), __name(run, "run"), Module.preInit) for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;) Module.preInit.pop()();
                var shouldRunNow = !0;
                Module.noInitialRun && (shouldRunNow = !1), run();
                let C = Module,
                  INTERNAL = {},
                  SIZE_OF_INT = 4,
                  SIZE_OF_NODE = 5 * SIZE_OF_INT,
                  SIZE_OF_POINT = 2 * SIZE_OF_INT,
                  SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
                  ZERO_POINT = {
                    row: 0,
                    column: 0
                  },
                  QUERY_WORD_REGEX = /[\w-.]*/g,
                  PREDICATE_STEP_TYPE_CAPTURE = 1,
                  PREDICATE_STEP_TYPE_STRING = 2,
                  LANGUAGE_FUNCTION_REGEX = /^_?tree_sitter_\w+/;
                var VERSION, MIN_COMPATIBLE_VERSION, TRANSFER_BUFFER, currentParseCallback, currentLogCallback;
                class ParserImpl {
                  static {
                    __name(this, "ParserImpl");
                  }
                  static {
                    __name(this, "ParserImpl");
                  }
                  static init() {
                    TRANSFER_BUFFER = C._ts_init(), VERSION = getValue(TRANSFER_BUFFER, "i32"), MIN_COMPATIBLE_VERSION = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  }
                  initialize() {
                    C._ts_parser_new_wasm(), this[0] = getValue(TRANSFER_BUFFER, "i32"), this[1] = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  }
                  delete() {
                    C._ts_parser_delete(this[0]), C._free(this[1]), this[0] = 0, this[1] = 0;
                  }
                  setLanguage(e) {
                    let t;
                    if (e) {
                      if (e.constructor !== Language) throw new Error("Argument must be a Language");
                      {
                        t = e[0];
                        let r = C._ts_language_version(t);
                        if (r < MIN_COMPATIBLE_VERSION || VERSION < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${VERSION}.`);
                      }
                    } else t = 0, e = null;
                    return this.language = e, C._ts_parser_set_language(this[0], t), this;
                  }
                  getLanguage() {
                    return this.language;
                  }
                  parse(e, t, r) {
                    if (typeof e == "string") currentParseCallback = __name((t, r, _) => e.slice(t, _), "currentParseCallback");else {
                      if (typeof e != "function") throw new Error("Argument must be a string or a function");
                      currentParseCallback = e;
                    }
                    this.logCallback ? (currentLogCallback = this.logCallback, C._ts_parser_enable_logger_wasm(this[0], 1)) : (currentLogCallback = null, C._ts_parser_enable_logger_wasm(this[0], 0));
                    let _ = 0,
                      n = 0;
                    if (r && r.includedRanges) {
                      _ = r.includedRanges.length, n = C._calloc(_, SIZE_OF_RANGE);
                      let e = n;
                      for (let t = 0; t < _; t++) marshalRange(e, r.includedRanges[t]), e += SIZE_OF_RANGE;
                    }
                    let s = C._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, n, _);
                    if (!s) throw currentParseCallback = null, currentLogCallback = null, new Error("Parsing failed");
                    let a = new Tree(INTERNAL, s, this.language, currentParseCallback);
                    return currentParseCallback = null, currentLogCallback = null, a;
                  }
                  reset() {
                    C._ts_parser_reset(this[0]);
                  }
                  setTimeoutMicros(e) {
                    C._ts_parser_set_timeout_micros(this[0], e);
                  }
                  getTimeoutMicros() {
                    return C._ts_parser_timeout_micros(this[0]);
                  }
                  setLogger(e) {
                    if (e) {
                      if (typeof e != "function") throw new Error("Logger callback must be a function");
                    } else e = null;
                    return this.logCallback = e, this;
                  }
                  getLogger() {
                    return this.logCallback;
                  }
                }
                class Tree {
                  static {
                    __name(this, "Tree");
                  }
                  static {
                    __name(this, "Tree");
                  }
                  constructor(e, t, r, _) {
                    assertInternal(e), this[0] = t, this.language = r, this.textCallback = _;
                  }
                  copy() {
                    let e = C._ts_tree_copy(this[0]);
                    return new Tree(INTERNAL, e, this.language, this.textCallback);
                  }
                  delete() {
                    C._ts_tree_delete(this[0]), this[0] = 0;
                  }
                  edit(e) {
                    marshalEdit(e), C._ts_tree_edit_wasm(this[0]);
                  }
                  get rootNode() {
                    return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this);
                  }
                  getLanguage() {
                    return this.language;
                  }
                  walk() {
                    return this.rootNode.walk();
                  }
                  getChangedRanges(e) {
                    if (e.constructor !== Tree) throw new TypeError("Argument must be a Tree");
                    C._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                    let t = getValue(TRANSFER_BUFFER, "i32"),
                      r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                      _ = new Array(t);
                    if (t > 0) {
                      let e = r;
                      for (let r = 0; r < t; r++) _[r] = unmarshalRange(e), e += SIZE_OF_RANGE;
                      C._free(r);
                    }
                    return _;
                  }
                }
                class Node {
                  static {
                    __name(this, "Node");
                  }
                  static {
                    __name(this, "Node");
                  }
                  constructor(e, t) {
                    assertInternal(e), this.tree = t;
                  }
                  get typeId() {
                    return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0]);
                  }
                  get type() {
                    return this.tree.language.types[this.typeId] || "ERROR";
                  }
                  get endPosition() {
                    return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                  }
                  get endIndex() {
                    return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0]);
                  }
                  get text() {
                    return getText(this.tree, this.startIndex, this.endIndex);
                  }
                  isNamed() {
                    return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1;
                  }
                  hasError() {
                    return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1;
                  }
                  hasChanges() {
                    return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1;
                  }
                  isMissing() {
                    return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1;
                  }
                  equals(e) {
                    return this.id === e.id;
                  }
                  child(e) {
                    return marshalNode(this), C._ts_node_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
                  }
                  namedChild(e) {
                    return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
                  }
                  childForFieldId(e) {
                    return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], e), unmarshalNode(this.tree);
                  }
                  childForFieldName(e) {
                    let t = this.tree.language.fields.indexOf(e);
                    if (t !== -1) return this.childForFieldId(t);
                  }
                  get childCount() {
                    return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0]);
                  }
                  get namedChildCount() {
                    return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0]);
                  }
                  get firstChild() {
                    return this.child(0);
                  }
                  get firstNamedChild() {
                    return this.namedChild(0);
                  }
                  get lastChild() {
                    return this.child(this.childCount - 1);
                  }
                  get lastNamedChild() {
                    return this.namedChild(this.namedChildCount - 1);
                  }
                  get children() {
                    if (!this._children) {
                      marshalNode(this), C._ts_node_children_wasm(this.tree[0]);
                      let e = getValue(TRANSFER_BUFFER, "i32"),
                        t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                      if (this._children = new Array(e), e > 0) {
                        let r = t;
                        for (let t = 0; t < e; t++) this._children[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                        C._free(t);
                      }
                    }
                    return this._children;
                  }
                  get namedChildren() {
                    if (!this._namedChildren) {
                      marshalNode(this), C._ts_node_named_children_wasm(this.tree[0]);
                      let e = getValue(TRANSFER_BUFFER, "i32"),
                        t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                      if (this._namedChildren = new Array(e), e > 0) {
                        let r = t;
                        for (let t = 0; t < e; t++) this._namedChildren[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                        C._free(t);
                      }
                    }
                    return this._namedChildren;
                  }
                  descendantsOfType(e, t, r) {
                    Array.isArray(e) || (e = [e]), t || (t = ZERO_POINT), r || (r = ZERO_POINT);
                    let _ = [],
                      n = this.tree.language.types;
                    for (let t = 0, r = n.length; t < r; t++) e.includes(n[t]) && _.push(t);
                    let s = C._malloc(SIZE_OF_INT * _.length);
                    for (let e = 0, t = _.length; e < t; e++) setValue(s + e * SIZE_OF_INT, _[e], "i32");
                    marshalNode(this), C._ts_node_descendants_of_type_wasm(this.tree[0], s, _.length, t.row, t.column, r.row, r.column);
                    let a = getValue(TRANSFER_BUFFER, "i32"),
                      o = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                      i = new Array(a);
                    if (a > 0) {
                      let e = o;
                      for (let t = 0; t < a; t++) i[t] = unmarshalNode(this.tree, e), e += SIZE_OF_NODE;
                    }
                    return C._free(o), C._free(s), i;
                  }
                  get nextSibling() {
                    return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  get previousSibling() {
                    return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  get nextNamedSibling() {
                    return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  get previousNamedSibling() {
                    return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  get parent() {
                    return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  descendantForIndex(e, t = e) {
                    if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                    marshalNode(this);
                    let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                    return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  namedDescendantForIndex(e, t = e) {
                    if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                    marshalNode(this);
                    let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                    return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_named_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  descendantForPosition(e, t = e) {
                    if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                    marshalNode(this);
                    let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                    return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  namedDescendantForPosition(e, t = e) {
                    if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                    marshalNode(this);
                    let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                    return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_named_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  walk() {
                    return marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree);
                  }
                  toString() {
                    marshalNode(this);
                    let e = C._ts_node_to_string_wasm(this.tree[0]),
                      t = AsciiToString(e);
                    return C._free(e), t;
                  }
                }
                class TreeCursor {
                  static {
                    __name(this, "TreeCursor");
                  }
                  static {
                    __name(this, "TreeCursor");
                  }
                  constructor(e, t) {
                    assertInternal(e), this.tree = t, unmarshalTreeCursor(this);
                  }
                  delete() {
                    marshalTreeCursor(this), C._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
                  }
                  reset(e) {
                    marshalNode(e), marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE), C._ts_tree_cursor_reset_wasm(this.tree[0]), unmarshalTreeCursor(this);
                  }
                  get nodeType() {
                    return this.tree.language.types[this.nodeTypeId] || "ERROR";
                  }
                  get nodeTypeId() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
                  }
                  get nodeId() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
                  }
                  get nodeIsNamed() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
                  }
                  get nodeIsMissing() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
                  }
                  get nodeText() {
                    marshalTreeCursor(this);
                    let e = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
                      t = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                    return getText(this.tree, e, t);
                  }
                  get startPosition() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_start_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                  }
                  get endPosition() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_end_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
                  }
                  get startIndex() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0]);
                  }
                  get endIndex() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                  }
                  currentNode() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree);
                  }
                  currentFieldId() {
                    return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
                  }
                  currentFieldName() {
                    return this.tree.language.fields[this.currentFieldId()];
                  }
                  gotoFirstChild() {
                    marshalTreeCursor(this);
                    let e = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                    return unmarshalTreeCursor(this), e === 1;
                  }
                  gotoNextSibling() {
                    marshalTreeCursor(this);
                    let e = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                    return unmarshalTreeCursor(this), e === 1;
                  }
                  gotoParent() {
                    marshalTreeCursor(this);
                    let e = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                    return unmarshalTreeCursor(this), e === 1;
                  }
                }
                class Language {
                  static {
                    __name(this, "Language");
                  }
                  static {
                    __name(this, "Language");
                  }
                  constructor(e, t) {
                    assertInternal(e), this[0] = t, this.types = new Array(C._ts_language_symbol_count(this[0]));
                    for (let e = 0, t = this.types.length; e < t; e++) C._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = UTF8ToString(C._ts_language_symbol_name(this[0], e)));
                    this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
                    for (let e = 0, t = this.fields.length; e < t; e++) {
                      let t = C._ts_language_field_name_for_id(this[0], e);
                      this.fields[e] = t !== 0 ? UTF8ToString(t) : null;
                    }
                  }
                  get version() {
                    return C._ts_language_version(this[0]);
                  }
                  get fieldCount() {
                    return this.fields.length - 1;
                  }
                  fieldIdForName(e) {
                    let t = this.fields.indexOf(e);
                    return t !== -1 ? t : null;
                  }
                  fieldNameForId(e) {
                    return this.fields[e] || null;
                  }
                  idForNodeType(e, t) {
                    let r = lengthBytesUTF8(e),
                      _ = C._malloc(r + 1);
                    stringToUTF8(e, _, r + 1);
                    let n = C._ts_language_symbol_for_name(this[0], _, r, t);
                    return C._free(_), n || null;
                  }
                  get nodeTypeCount() {
                    return C._ts_language_symbol_count(this[0]);
                  }
                  nodeTypeForId(e) {
                    let t = C._ts_language_symbol_name(this[0], e);
                    return t ? UTF8ToString(t) : null;
                  }
                  nodeTypeIsNamed(e) {
                    return !!C._ts_language_type_is_named_wasm(this[0], e);
                  }
                  nodeTypeIsVisible(e) {
                    return !!C._ts_language_type_is_visible_wasm(this[0], e);
                  }
                  query(e) {
                    let t = lengthBytesUTF8(e),
                      r = C._malloc(t + 1);
                    stringToUTF8(e, r, t + 1);
                    let _ = C._ts_query_new(this[0], r, t, TRANSFER_BUFFER, TRANSFER_BUFFER + SIZE_OF_INT);
                    if (!_) {
                      let t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                        _ = UTF8ToString(r, getValue(TRANSFER_BUFFER, "i32")).length,
                        n = e.substr(_, 100).split(`
`)[0],
                        s,
                        a = n.match(QUERY_WORD_REGEX)[0];
                      switch (t) {
                        case 2:
                          s = new RangeError(`Bad node name '${a}'`);
                          break;
                        case 3:
                          s = new RangeError(`Bad field name '${a}'`);
                          break;
                        case 4:
                          s = new RangeError(`Bad capture name @${a}`);
                          break;
                        case 5:
                          s = new TypeError(`Bad pattern structure at offset ${_}: '${n}'...`), a = "";
                          break;
                        default:
                          s = new SyntaxError(`Bad syntax at offset ${_}: '${n}'...`), a = "";
                      }
                      throw s.index = _, s.length = a.length, C._free(r), s;
                    }
                    let n = C._ts_query_string_count(_),
                      s = C._ts_query_capture_count(_),
                      a = C._ts_query_pattern_count(_),
                      o = new Array(s),
                      i = new Array(n);
                    for (let e = 0; e < s; e++) {
                      let t = C._ts_query_capture_name_for_id(_, e, TRANSFER_BUFFER),
                        r = getValue(TRANSFER_BUFFER, "i32");
                      o[e] = UTF8ToString(t, r);
                    }
                    for (let e = 0; e < n; e++) {
                      let t = C._ts_query_string_value_for_id(_, e, TRANSFER_BUFFER),
                        r = getValue(TRANSFER_BUFFER, "i32");
                      i[e] = UTF8ToString(t, r);
                    }
                    let l = new Array(a),
                      u = new Array(a),
                      d = new Array(a),
                      c = new Array(a),
                      m = new Array(a);
                    for (let e = 0; e < a; e++) {
                      let t = C._ts_query_predicates_for_pattern(_, e, TRANSFER_BUFFER),
                        r = getValue(TRANSFER_BUFFER, "i32");
                      c[e] = [], m[e] = [];
                      let n = [],
                        s = t;
                      for (let t = 0; t < r; t++) {
                        let t = getValue(s, "i32");
                        s += SIZE_OF_INT;
                        let r = getValue(s, "i32");
                        if (s += SIZE_OF_INT, t === PREDICATE_STEP_TYPE_CAPTURE) n.push({
                          type: "capture",
                          name: o[r]
                        });else if (t === PREDICATE_STEP_TYPE_STRING) n.push({
                          type: "string",
                          value: i[r]
                        });else if (n.length > 0) {
                          if (n[0].type !== "string") throw new Error("Predicates must begin with a literal value");
                          let t = n[0].value,
                            r = !0;
                          switch (t) {
                            case "not-eq?":
                              r = !1;
                            case "eq?":
                              if (n.length !== 3) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (n.length - 1));
                              if (n[1].type !== "capture") throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${n[1].value}"`);
                              if (n[2].type === "capture") {
                                let t = n[1].name,
                                  _ = n[2].name;
                                m[e].push(function (e) {
                                  let n, s;
                                  for (let r of e) r.name === t && (n = r.node), r.name === _ && (s = r.node);
                                  return n === void 0 || s === void 0 || n.text === s.text === r;
                                });
                              } else {
                                let t = n[1].name,
                                  _ = n[2].value;
                                m[e].push(function (e) {
                                  for (let n of e) if (n.name === t) return n.node.text === _ === r;
                                  return !0;
                                });
                              }
                              break;
                            case "not-match?":
                              r = !1;
                            case "match?":
                              if (n.length !== 3) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${n.length - 1}.`);
                              if (n[1].type !== "capture") throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${n[1].value}".`);
                              if (n[2].type !== "string") throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${n[2].value}.`);
                              let _ = n[1].name,
                                s = new RegExp(n[2].value);
                              m[e].push(function (e) {
                                for (let t of e) if (t.name === _) return s.test(t.node.text) === r;
                                return !0;
                              });
                              break;
                            case "set!":
                              if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                              if (n.some(e => e.type !== "string")) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                              l[e] || (l[e] = {}), l[e][n[1].value] = n[2] ? n[2].value : null;
                              break;
                            case "is?":
                            case "is-not?":
                              if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                              if (n.some(e => e.type !== "string")) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                              let a = t === "is?" ? u : d;
                              a[e] || (a[e] = {}), a[e][n[1].value] = n[2] ? n[2].value : null;
                              break;
                            default:
                              c[e].push({
                                operator: t,
                                operands: n.slice(1)
                              });
                          }
                          n.length = 0;
                        }
                      }
                      Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e]);
                    }
                    return C._free(r), new Query(INTERNAL, _, o, m, c, Object.freeze(l), Object.freeze(u), Object.freeze(d));
                  }
                  static load(e) {
                    let t;
                    if (e instanceof Uint8Array) t = Promise.resolve(e);else {
                      let r = e;
                      if (typeof process < "u" && process.versions && process.versions.node) {
                        let e = require("fs");
                        t = Promise.resolve(e.readFileSync(r));
                      } else t = fetch(r).then(e => e.arrayBuffer().then(t => {
                        if (e.ok) return new Uint8Array(t);
                        {
                          let r = new TextDecoder("utf-8").decode(t);
                          throw new Error(`Language.load failed with status ${e.status}.

${r}`);
                        }
                      }));
                    }
                    let r = typeof loadSideModule == "function" ? loadSideModule : loadWebAssemblyModule;
                    return t.then(e => r(e, {
                      loadAsync: !0
                    })).then(e => {
                      let t = Object.keys(e),
                        r = t.find(e => LANGUAGE_FUNCTION_REGEX.test(e) && !e.includes("external_scanner_"));
                      r || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t, null, 2)}`);
                      let _ = e[r]();
                      return new Language(INTERNAL, _);
                    });
                  }
                }
                class Query {
                  static {
                    __name(this, "Query");
                  }
                  static {
                    __name(this, "Query");
                  }
                  constructor(e, t, r, _, n, s, a, o) {
                    assertInternal(e), this[0] = t, this.captureNames = r, this.textPredicates = _, this.predicates = n, this.setProperties = s, this.assertedProperties = a, this.refutedProperties = o, this.exceededMatchLimit = !1;
                  }
                  delete() {
                    C._ts_query_delete(this[0]), this[0] = 0;
                  }
                  matches(e, t, r, _) {
                    t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                    let n = _.matchLimit;
                    if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                    marshalNode(e), C._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                    let s = getValue(TRANSFER_BUFFER, "i32"),
                      a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                      o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                      i = new Array(s);
                    this.exceededMatchLimit = !!o;
                    let l = 0,
                      u = a;
                    for (let t = 0; t < s; t++) {
                      let r = getValue(u, "i32");
                      u += SIZE_OF_INT;
                      let _ = getValue(u, "i32");
                      u += SIZE_OF_INT;
                      let n = new Array(_);
                      if (u = unmarshalCaptures(this, e.tree, u, n), this.textPredicates[r].every(e => e(n))) {
                        i[l++] = {
                          pattern: r,
                          captures: n
                        };
                        let e = this.setProperties[r];
                        e && (i[t].setProperties = e);
                        let _ = this.assertedProperties[r];
                        _ && (i[t].assertedProperties = _);
                        let s = this.refutedProperties[r];
                        s && (i[t].refutedProperties = s);
                      }
                    }
                    return i.length = l, C._free(a), i;
                  }
                  captures(e, t, r, _) {
                    t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                    let n = _.matchLimit;
                    if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                    marshalNode(e), C._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                    let s = getValue(TRANSFER_BUFFER, "i32"),
                      a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                      o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                      i = [];
                    this.exceededMatchLimit = !!o;
                    let l = [],
                      u = a;
                    for (let t = 0; t < s; t++) {
                      let t = getValue(u, "i32");
                      u += SIZE_OF_INT;
                      let r = getValue(u, "i32");
                      u += SIZE_OF_INT;
                      let _ = getValue(u, "i32");
                      if (u += SIZE_OF_INT, l.length = r, u = unmarshalCaptures(this, e.tree, u, l), this.textPredicates[t].every(e => e(l))) {
                        let e = l[_],
                          r = this.setProperties[t];
                        r && (e.setProperties = r);
                        let n = this.assertedProperties[t];
                        n && (e.assertedProperties = n);
                        let s = this.refutedProperties[t];
                        s && (e.refutedProperties = s), i.push(e);
                      }
                    }
                    return C._free(a), i;
                  }
                  predicatesForPattern(e) {
                    return this.predicates[e];
                  }
                  didExceedMatchLimit() {
                    return this.exceededMatchLimit;
                  }
                }
                function getText(e, t, r) {
                  let _ = r - t,
                    n = e.textCallback(t, null, r);
                  for (t += n.length; t < r;) {
                    let _ = e.textCallback(t, null, r);
                    if (!(_ && _.length > 0)) break;
                    t += _.length, n += _;
                  }
                  return t > r && (n = n.slice(0, _)), n;
                }
                __name(getText, "getText"), __name(getText, "getText");
                function unmarshalCaptures(e, t, r, _) {
                  for (let n = 0, s = _.length; n < s; n++) {
                    let s = getValue(r, "i32"),
                      a = unmarshalNode(t, r += SIZE_OF_INT);
                    r += SIZE_OF_NODE, _[n] = {
                      name: e.captureNames[s],
                      node: a
                    };
                  }
                  return r;
                }
                __name(unmarshalCaptures, "unmarshalCaptures"), __name(unmarshalCaptures, "unmarshalCaptures");
                function assertInternal(e) {
                  if (e !== INTERNAL) throw new Error("Illegal constructor");
                }
                __name(assertInternal, "assertInternal"), __name(assertInternal, "assertInternal");
                function isPoint(e) {
                  return e && typeof e.row == "number" && typeof e.column == "number";
                }
                __name(isPoint, "isPoint"), __name(isPoint, "isPoint");
                function marshalNode(e) {
                  let t = TRANSFER_BUFFER;
                  setValue(t, e.id, "i32"), t += SIZE_OF_INT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.row, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.column, "i32"), t += SIZE_OF_INT, setValue(t, e[0], "i32");
                }
                __name(marshalNode, "marshalNode"), __name(marshalNode, "marshalNode");
                function unmarshalNode(e, t = TRANSFER_BUFFER) {
                  let r = getValue(t, "i32");
                  if (r === 0) return null;
                  let _ = getValue(t += SIZE_OF_INT, "i32"),
                    n = getValue(t += SIZE_OF_INT, "i32"),
                    s = getValue(t += SIZE_OF_INT, "i32"),
                    a = getValue(t += SIZE_OF_INT, "i32"),
                    o = new Node(INTERNAL, e);
                  return o.id = r, o.startIndex = _, o.startPosition = {
                    row: n,
                    column: s
                  }, o[0] = a, o;
                }
                __name(unmarshalNode, "unmarshalNode"), __name(unmarshalNode, "unmarshalNode");
                function marshalTreeCursor(e, t = TRANSFER_BUFFER) {
                  setValue(t + 0 * SIZE_OF_INT, e[0], "i32"), setValue(t + 1 * SIZE_OF_INT, e[1], "i32"), setValue(t + 2 * SIZE_OF_INT, e[2], "i32");
                }
                __name(marshalTreeCursor, "marshalTreeCursor"), __name(marshalTreeCursor, "marshalTreeCursor");
                function unmarshalTreeCursor(e) {
                  e[0] = getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32"), e[1] = getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32"), e[2] = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
                }
                __name(unmarshalTreeCursor, "unmarshalTreeCursor"), __name(unmarshalTreeCursor, "unmarshalTreeCursor");
                function marshalPoint(e, t) {
                  setValue(e, t.row, "i32"), setValue(e + SIZE_OF_INT, t.column, "i32");
                }
                __name(marshalPoint, "marshalPoint"), __name(marshalPoint, "marshalPoint");
                function unmarshalPoint(e) {
                  return {
                    row: getValue(e, "i32"),
                    column: getValue(e + SIZE_OF_INT, "i32")
                  };
                }
                __name(unmarshalPoint, "unmarshalPoint"), __name(unmarshalPoint, "unmarshalPoint");
                function marshalRange(e, t) {
                  marshalPoint(e, t.startPosition), marshalPoint(e += SIZE_OF_POINT, t.endPosition), setValue(e += SIZE_OF_POINT, t.startIndex, "i32"), setValue(e += SIZE_OF_INT, t.endIndex, "i32"), e += SIZE_OF_INT;
                }
                __name(marshalRange, "marshalRange"), __name(marshalRange, "marshalRange");
                function unmarshalRange(e) {
                  let t = {};
                  return t.startPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.endPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.startIndex = getValue(e, "i32"), e += SIZE_OF_INT, t.endIndex = getValue(e, "i32"), t;
                }
                __name(unmarshalRange, "unmarshalRange"), __name(unmarshalRange, "unmarshalRange");
                function marshalEdit(e) {
                  let t = TRANSFER_BUFFER;
                  marshalPoint(t, e.startPosition), t += SIZE_OF_POINT, marshalPoint(t, e.oldEndPosition), t += SIZE_OF_POINT, marshalPoint(t, e.newEndPosition), t += SIZE_OF_POINT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.oldEndIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.newEndIndex, "i32"), t += SIZE_OF_INT;
                }
                __name(marshalEdit, "marshalEdit"), __name(marshalEdit, "marshalEdit");
                for (let e of Object.getOwnPropertyNames(ParserImpl.prototype)) Object.defineProperty(Parser.prototype, e, {
                  value: ParserImpl.prototype[e],
                  enumerable: !1,
                  writable: !1
                });
                Parser.Language = Language, Module.onRuntimeInitialized = () => {
                  ParserImpl.init(), resolveInitPromise();
                };
              }));
            }
          }
          return Parser;
        }();
      typeof exports == "object" && (module.exports = TreeSitter);
    }),
    Jr = z((nt, Cn) => {
      (function (root, factory) {
        if (typeof exports == "object" && typeof module == "object") module.exports = factory();else if (typeof define == "function" && define.amd) define([], factory);else {
          var a = factory();
          for (var i in a) (typeof exports == "object" ? exports : root)[i] = a[i];
        }
      })(this, () => (() => {
        "use strict";

        var t = {
            470: t => {
              function assertPath(path) {
                if (typeof path != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
              }
              assertPath(assertPath, "assertPath"), assertPath(assertPath, "assertPath");
              function normalizeStringPosix(path, allowAboveRoot) {
                for (var code, res = "", lastSegmentLength = 0, lastSlash = -lastSlash, dots = 0, i = 0; i <= path.length; ++i) {
                  if (i < path.length) code = path.charCodeAt(i);else {
                    if (code === 47) break;
                    code = 47;
                  }
                  if (code === 47) {
                    if (!(lastSlash === i - 1 || dots === 1)) if (lastSlash !== i - 1 && dots === 2) {
                      if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                        if (res.length > 2) {
                          var lastSlashIndex = res.lastIndexOf("/");
                          if (lastSlashIndex !== res.length - 1) {
                            lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : lastSegmentLength = (res = res.slice(0, lastSlashIndex)).length - 1 - res.lastIndexOf("/"), lastSlash = i, dots = 0;
                            continue;
                          }
                        } else if (res.length === 2 || res.length === 1) {
                          res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;
                          continue;
                        }
                      }
                      allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);
                    } else res.length > 0 ? res += "/" + path.slice(lastSlash + 1, i) : res = path.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;
                    lastSlash = i, dots = 0;
                  } else code === 46 && dots !== -code ? ++dots : dots = -dots;
                }
                return res;
              }
              normalizeStringPosix(normalizeStringPosix, "normalizeStringPosix"), normalizeStringPosix(normalizeStringPosix, "normalizeStringPosix");
              var posix = {
                resolve: function () {
                  for (var cwd, resolvedPath = "", resolvedAbsolute = !resolvedAbsolute, i = arguments.length - 1; i >= -i && !resolvedAbsolute; i--) {
                    var path;
                    i >= 0 ? path = arguments[i] : (cwd === void i && (cwd = process.cwd()), path = cwd), assertPath(path), path.length !== 0 && (resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47);
                  }
                  return resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute), resolvedAbsolute ? resolvedPath.length > 0 ? "/" + resolvedPath : "/" : resolvedPath.length > 0 ? resolvedPath : ".";
                },
                normalize: function (path) {
                  if (assertPath(path), path.length === 0) return ".";
                  var isAbsolute = path.charCodeAt(0) === 47,
                    trailingSeparator = path.charCodeAt(path.length - 1) === 47;
                  return (path = normalizeStringPosix(path, !isAbsolute)).length !== 0 || isAbsolute || (path = "."), path.length > 0 && trailingSeparator && (path += "/"), isAbsolute ? "/" + path : path;
                },
                isAbsolute: function (path) {
                  return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
                },
                join: function () {
                  if (arguments.length === 0) return ".";
                  for (var joined, i = 0; i < arguments.length; ++i) {
                    var arg = arguments[i];
                    assertPath(arg), arg.length > 0 && (joined === void 0 ? joined = arg : joined += "/" + arg);
                  }
                  return joined === void 0 ? "." : posix.normalize(joined);
                },
                relative: function (from, to) {
                  if (assertPath(from), assertPath(to), from === to || (from = posix.resolve(from)) === (to = posix.resolve(to))) return "";
                  for (var fromStart = 1; fromStart < from.length && from.charCodeAt(fromStart) === 47; ++fromStart);
                  for (var fromEnd = from.length, fromLen = fromEnd - fromStart, toStart = 1; toStart < to.length && to.charCodeAt(toStart) === 47; ++toStart);
                  for (var toLen = to.length - toStart, length = fromLen < toLen ? fromLen : toLen, lastCommonSep = -lastCommonSep, i = 0; i <= length; ++i) {
                    if (i === length) {
                      if (toLen > length) {
                        if (to.charCodeAt(toStart + i) === 47) return to.slice(toStart + i + 1);
                        if (i === 0) return to.slice(toStart + i);
                      } else fromLen > length && (from.charCodeAt(fromStart + i) === 47 ? lastCommonSep = i : i === 0 && (lastCommonSep = 0));
                      break;
                    }
                    var fromCode = from.charCodeAt(fromStart + i);
                    if (fromCode !== to.charCodeAt(toStart + i)) break;
                    fromCode === 47 && (lastCommonSep = i);
                  }
                  var out = "";
                  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) i !== fromEnd && from.charCodeAt(i) !== 47 || (out.length === 0 ? out += ".." : out += "/..");
                  return out.length > 0 ? out + to.slice(toStart + lastCommonSep) : (toStart += lastCommonSep, to.charCodeAt(toStart) === 47 && ++toStart, to.slice(toStart));
                },
                _makeLong: function (path) {
                  return path;
                },
                dirname: function (path) {
                  if (assertPath(path), path.length === 0) return ".";
                  for (var code = path.charCodeAt(0), hasRoot = code === 47, end = -end, matchedSlash = !matchedSlash, i = path.length - 1; i >= 1; --i) if ((code = path.charCodeAt(i)) === 47) {
                    if (!matchedSlash) {
                      end = i;
                      break;
                    }
                  } else matchedSlash = !matchedSlash;
                  return end === -1 ? hasRoot ? "/" : "." : hasRoot && end === 1 ? "//" : path.slice(0, end);
                },
                basename: function (path, ext) {
                  if (ext !== void 0 && typeof ext != "string") throw new TypeError('"ext" argument must be a string');
                  assertPath(path);
                  var i,
                    start = 0,
                    end = -end,
                    matchedSlash = !matchedSlash;
                  if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                    if (ext.length === path.length && ext === path) return "";
                    var extIdx = ext.length - 1,
                      firstNonSlashEnd = -firstNonSlashEnd;
                    for (i = path.length - 1; i >= 0; --i) {
                      var code = path.charCodeAt(i);
                      if (code === 47) {
                        if (!matchedSlash) {
                          start = i + 1;
                          break;
                        }
                      } else firstNonSlashEnd === -1 && (matchedSlash = !matchedSlash, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx == -extIdx && (end = i) : (extIdx = -extIdx, end = firstNonSlashEnd));
                    }
                    return start === end ? end = firstNonSlashEnd : end === -firstNonSlashEnd && (end = path.length), path.slice(start, end);
                  }
                  for (i = path.length - 1; i >= 0; --i) if (path.charCodeAt(i) === 47) {
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else end === -1 && (matchedSlash = !matchedSlash, end = i + 1);
                  return end === -1 ? "" : path.slice(start, end);
                },
                extname: function (path) {
                  assertPath(path);
                  for (var startDot = -startDot, startPart = 0, end = -end, matchedSlash = !matchedSlash, preDotState = 0, i = path.length - 1; i >= 0; --i) {
                    var code = path.charCodeAt(i);
                    if (code !== 47) end === -code && (matchedSlash = !matchedSlash, end = i + 1), code === 46 ? startDot === -code ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -preDotState);else if (!matchedSlash) {
                      startPart = i + 1;
                      break;
                    }
                  }
                  return startDot === -1 || end === -startDot || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
                },
                format: function (pathObject) {
                  if (pathObject === null || typeof pathObject != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
                  return function (sep, pathObject) {
                    var dir = pathObject.dir || pathObject.root,
                      base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
                    return dir ? dir === pathObject.root ? dir + base : dir + "/" + base : base;
                  }(0, pathObject);
                },
                parse: function (path) {
                  assertPath(path);
                  var ret = {
                    root: "",
                    dir: "",
                    base: "",
                    ext: "",
                    name: ""
                  };
                  if (path.length === 0) return ret;
                  var start,
                    code = path.charCodeAt(0),
                    isAbsolute = code === 47;
                  isAbsolute ? (ret.root = "/", start = 1) : start = 0;
                  for (var startDot = -startDot, startPart = 0, end = -end, matchedSlash = !matchedSlash, i = path.length - 1, preDotState = 0; i >= start; --i) if ((code = path.charCodeAt(i)) !== 47) end === -i && (matchedSlash = !matchedSlash, end = i + 1), code === 46 ? startDot === -code ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -preDotState);else if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                  }
                  return startDot === -1 || end === -startDot || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (ret.base = ret.name = startPart === 0 && isAbsolute ? path.slice(1, end) : path.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path.slice(1, startDot), ret.base = path.slice(1, end)) : (ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end)), ret.ext = path.slice(startDot, end)), startPart > 0 ? ret.dir = path.slice(0, startPart - 1) : isAbsolute && (ret.dir = "/"), ret;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
              };
              posix.posix = posix, module.exports = posix;
            },
            posix: (posix, posix) => {
              if (posix.defineProperty(e, "__esModule", {
                value: !0
              }), e.isWindows = void 0, typeof process == "object") e.isWindows = process.platform === "win32";else if (typeof navigator == "object") {
                var userAgent = navigator.userAgent;
                e.isWindows = userAgent.indexOf("Windows") >= 0;
              }
            },
            796: function (t, e, r) {
              var n,
                o,
                i = this && this.__extends || (n = __name(function (t, e) {
                  return n = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function (t, e) {
                    t.__proto__ = e;
                  } || function (t, e) {
                    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                  }, n(t, e);
                }, "n"), function (t, e) {
                  if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
                  function r() {
                    this.constructor = t;
                  }
                  r(r, "r"), __name(r, "r"), n(t, e), t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
                });
              Object.defineProperty(e, "__esModule", {
                value: !0
              }), e.uriToFsPath = e.URI = void 0;
              var a = r(674),
                _schemePattern = /^\w[\w\d+.-]*$/,
                _singleSlashStart = /^\//,
                _doubleSlashStart = /^\/\//;
              function _validateUri(ret, _strict) {
                if (!ret.scheme && _strict) throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(ret.authority, '", path: "').concat(ret.path, '", query: "').concat(ret.query, '", fragment: "').concat(ret.fragment, '"}'));
                if (ret.scheme && !_schemePattern.test(ret.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                if (ret.path) {
                  if (ret.authority) {
                    if (!_singleSlashStart.test(ret.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                  } else if (_doubleSlashStart.test(ret.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                }
              }
              _validateUri(_validateUri, "_validateUri"), _validateUri(_validateUri, "_validateUri");
              var _empty = "",
                _slash = "/",
                _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
                d = function () {
                  function t(schemeOrData, authority, path, query, fragment, _strict) {
                    _strict === void _strict && (_strict = !_strict), typeof schemeOrData == "object" ? (this.scheme = schemeOrData.scheme || _empty, this.authority = schemeOrData.authority || _empty, this.path = schemeOrData.path || _empty, this.query = schemeOrData.query || _empty, this.fragment = schemeOrData.fragment || _empty) : (this.scheme = function (scheme, _strict) {
                      return scheme || _strict ? scheme : "file";
                    }(schemeOrData, _strict), this.authority = authority || _empty, this.path = function (scheme, path) {
                      switch (scheme) {
                        case "https":
                        case "http":
                        case "file":
                          path ? path[0] !== _slash && (path = _slash + path) : path = _slash;
                      }
                      return path;
                    }(this.scheme, path || _empty), this.query = query || _empty, this.fragment = fragment || _empty, _validateUri(this, _strict));
                  }
                  return t(t, "t"), __name(t, "t"), t.isUri = function (thing) {
                    return thing instanceof URI || !!thing && typeof thing.authority == "string" && typeof thing.fragment == "string" && typeof thing.path == "string" && typeof thing.query == "string" && typeof thing.scheme == "string" && typeof thing.fsPath == "string" && typeof thing.with == "function" && typeof thing.toString == "function";
                  }, Object.defineProperty(t.prototype, "fsPath", {
                    get: function () {
                      return uriToFsPath(this, !this);
                    },
                    enumerable: !1,
                    configurable: !0
                  }), t.prototype.with = function (change) {
                    if (!change) return this;
                    var scheme = change.scheme,
                      authority = change.authority,
                      path = change.path,
                      query = change.query,
                      fragment = change.fragment;
                    return scheme === void 0 ? scheme = this.scheme : scheme === null && (scheme = _empty), authority === void _empty ? authority = this.authority : authority === null && (authority = _empty), path === void _empty ? path = this.path : path === null && (path = _empty), query === void _empty ? query = this.query : query === null && (query = _empty), fragment === void _empty ? fragment = this.fragment : fragment === null && (fragment = _empty), scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment ? this : new Uri(scheme, authority, path, query, fragment);
                  }, t.parse = function (value, _strict) {
                    _strict === void _strict && (_strict = !_strict);
                    var match = _regexp.exec(value);
                    return match ? new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict) : new Uri(_empty, _empty, _empty, _empty, _empty);
                  }, t.file = function (path) {
                    var authority = _empty;
                    if (a.isWindows && (path = path.replace(/\\/g, _slash)), path[0] === _slash && path[1] === _slash) {
                      var idx = path.indexOf(_slash, 2);
                      idx === -1 ? (authority = path.substring(2), path = _slash) : (authority = path.substring(2, idx), path = path.substring(idx) || _slash);
                    }
                    return new Uri("file", authority, path, _empty, _empty);
                  }, t.from = function (components) {
                    var result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
                    return _validateUri(result, !result), result;
                  }, t.prototype.toString = function (skipEncoding) {
                    return skipEncoding === void 0 && (skipEncoding = !skipEncoding), _asFormatted(this, skipEncoding);
                  }, t.prototype.toJSON = function () {
                    return this;
                  }, t.revive = function (data) {
                    if (data) {
                      if (data instanceof URI) return data;
                      var result = new Uri(data);
                      return result._formatted = data.external, result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null, result;
                    }
                    return data;
                  }, t;
                }();
              e.URI = URI;
              var _pathSepMarker = a.isWindows ? 1 : void 0,
                v = function (t) {
                  function e() {
                    var e = t !== null && t.apply(this, arguments) || this;
                    return e._formatted = null, e._fsPath = null, e;
                  }
                  return e(e, "e"), __name(e, "e"), i(e, t), Object.defineProperty(e.prototype, "fsPath", {
                    get: function () {
                      return this._fsPath || (this._fsPath = uriToFsPath(this, !this)), this._fsPath;
                    },
                    enumerable: !1,
                    configurable: !0
                  }), e.prototype.toString = function (skipEncoding) {
                    return skipEncoding === void 0 && (skipEncoding = !skipEncoding), skipEncoding ? _asFormatted(this, !this) : (this._formatted || (this._formatted = _asFormatted(this, !this)), this._formatted);
                  }, e.prototype.toJSON = function () {
                    var res = {
                      $mid: 1
                    };
                    return this._fsPath && (res.fsPath = this._fsPath, res._sep = _pathSepMarker), this._formatted && (res.external = this._formatted), this.path && (res.path = this.path), this.scheme && (res.scheme = this.scheme), this.authority && (res.authority = this.authority), this.query && (res.query = this.query), this.fragment && (res.fragment = this.fragment), res;
                  }, e;
                }(URI),
                encodeTable = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
              function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
                for (var res = void res, nativeEncodePos = -nativeEncodePos, pos = 0; pos < uriComponent.length; pos++) {
                  var code = uriComponent.charCodeAt(pos);
                  if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) nativeEncodePos !== -code && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos)), nativeEncodePos = -nativeEncodePos), res !== void 0 && (res += uriComponent.charAt(pos));else {
                    res === void 0 && (res = uriComponent.substr(0, pos));
                    var escaped = encodeTable[code];
                    escaped !== void code ? (nativeEncodePos !== -escaped && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos)), nativeEncodePos = -nativeEncodePos), res += escaped) : nativeEncodePos === -escaped && (nativeEncodePos = pos);
                  }
                }
                return nativeEncodePos !== -1 && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos))), res !== void nativeEncodePos ? res : uriComponent;
              }
              encodeURIComponentFast(encodeURIComponentFast, "encodeURIComponentFast"), encodeURIComponentFast(encodeURIComponentFast, "encodeURIComponentFast");
              function encodeURIComponentMinimal(path) {
                for (var res = void res, pos = 0; pos < path.length; pos++) {
                  var code = path.charCodeAt(pos);
                  code === 35 || code === 63 ? (res === void code && (res = path.substr(0, pos)), res += encodeTable[code]) : res !== void code && (res += path[pos]);
                }
                return res !== void 0 ? res : path;
              }
              encodeURIComponentMinimal(encodeURIComponentMinimal, "encodeURIComponentMinimal"), encodeURIComponentMinimal(encodeURIComponentMinimal, "encodeURIComponentMinimal");
              function uriToFsPath(uri, keepDriveLetterCasing) {
                var value;
                return value = uri.authority && uri.path.length > 1 && uri.scheme === "file" ? "//".concat(uri.authority).concat(uri.path) : uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58 ? keepDriveLetterCasing ? uri.path.substr(1) : uri.path[1].toLowerCase() + uri.path.substr(2) : uri.path, a.isWindows && (value = value.replace(/\//g, "\\")), value;
              }
              uriToFsPath(uriToFsPath, "uriToFsPath"), uriToFsPath(uriToFsPath, "uriToFsPath");
              function _asFormatted(uri, skipEncoding) {
                var encoder = skipEncoding ? encodeURIComponentMinimal : encodeURIComponentFast,
                  res = "",
                  scheme = uri.scheme,
                  authority = uri.authority,
                  path = uri.path,
                  query = uri.query,
                  fragment = uri.fragment;
                if (scheme && (res += scheme, res += ":"), (authority || scheme === "file") && (res += _slash, res += _slash), authority) {
                  var idx = authority.indexOf("@");
                  if (idx !== -1) {
                    var userinfo = authority.substr(0, idx);
                    authority = authority.substr(idx + 1), (idx = userinfo.lastIndexOf(":")) === -1 ? res += encoder(userinfo, !userinfo, !1) : (res += encoder(userinfo.substr(0, idx), !idx, !1), res += ":", res += encoder(userinfo.substr(idx + 1), !1, !0)), res += "@";
                  }
                  (idx = (authority = authority.toLowerCase()).lastIndexOf(":")) === -1 ? res += encoder(authority, !authority, !0) : (res += encoder(authority.substr(0, idx), !idx, !0), res += authority.substr(idx));
                }
                if (path) {
                  if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) (code = path.charCodeAt(1)) >= 65 && code <= 90 && (path = "/".concat(String.fromCharCode(code + 32), ":").concat(path.substr(3)));else if (path.length >= 2 && path.charCodeAt(1) === 58) {
                    var code;
                    (code = path.charCodeAt(0)) >= 65 && code <= 90 && (path = "".concat(String.fromCharCode(code + 32), ":").concat(path.substr(2)));
                  }
                  res += encoder(path, !path, !1);
                }
                return query && (res += "?", res += encoder(query, !query, !1)), fragment && (res += "#", res += skipEncoding ? fragment : encodeURIComponentFast(fragment, !fragment, !1)), res;
              }
              _asFormatted(_asFormatted, "_asFormatted"), _asFormatted(_asFormatted, "_asFormatted");
              function decodeURIComponentGraceful(str) {
                try {
                  return decodeURIComponent(str);
                } catch {
                  return str.length > 3 ? str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3)) : str;
                }
              }
              decodeURIComponentGraceful(decodeURIComponentGraceful, "decodeURIComponentGraceful"), decodeURIComponentGraceful(decodeURIComponentGraceful, "decodeURIComponentGraceful"), e.uriToFsPath = C;
              var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
              function percentDecode(str) {
                return str.match(_rEncodedAsHex) ? str.replace(_rEncodedAsHex, function (match) {
                  return decodeURIComponentGraceful(match);
                }) : str;
              }
              percentDecode(percentDecode, "percentDecode"), percentDecode(percentDecode, "percentDecode");
            },
            679: function (t, e, r) {
              var n = this && this.__spreadArray || function (t, e, r) {
                if (r || arguments.length === 2) for (var n, o = 0, i = e.length; o < i; o++) !n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);
                return t.concat(n || Array.prototype.slice.call(e));
              };
              Object.defineProperty(e, "__esModule", {
                value: !0
              }), e.Utils = void 0;
              var Utils,
                i = r(470),
                posixPath = nodePath.posix || nodePath,
                slash = "/";
              (Utils = e.Utils || (e.Utils = {})).joinPath = function (uri) {
                for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
                return uri.with({
                  path: posixPath.join.apply(posixPath, n([uri.path], paths, !paths))
                });
              }, o.resolvePath = function (uri) {
                for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
                var path = uri.path,
                  slashAdded = !slashAdded;
                path[0] !== slash && (path = slash + path, slashAdded = !slashAdded);
                var resolvedPath = posixPath.resolve.apply(posixPath, n([path], paths, !paths));
                return slashAdded && resolvedPath[0] === slash && !uri.authority && (resolvedPath = resolvedPath.substring(1)), uri.with({
                  path: resolvedPath
                });
              }, o.dirname = function (uri) {
                if (uri.path.length === 0 || uri.path === slash) return uri;
                var path = posixPath.dirname(uri.path);
                return path.length === 1 && path.charCodeAt(0) === 46 && (path = ""), uri.with({
                  path: e
                });
              }, o.basename = function (uri) {
                return posixPath.basename(uri.path);
              }, o.extname = function (uri) {
                return posixPath.extname(uri.path);
              };
            }
          },
          __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) return cachedModule.exports;
          var module = __webpack_module_cache__[moduleId] = {
            exports: {}
          };
          return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.exports;
        }
        __webpack_require__(__webpack_require__, "__webpack_require__"), __webpack_require__(__webpack_require__, "__webpack_require__");
        var n = {};
        return (() => {
          var t = n;
          Object.defineProperty(t, "__esModule", {
            value: !0
          }), t.Utils = t.URI = void 0;
          var e = r(796);
          Object.defineProperty(t, "URI", {
            enumerable: !0,
            get: function () {
              return e.URI;
            }
          });
          var o = r(679);
          Object.defineProperty(t, "Utils", {
            enumerable: !0,
            get: function () {
              return o.Utils;
            }
          });
        })(), n;
      })());
    }),
    require_base64 = __commonJSMin(exports => {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function (number) {
        if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
        throw new TypeError("Must be between 0 and 63: " + number);
      }, exports.decode = function (charCode) {
        var bigA = 65,
          bigZ = 90,
          littleA = 97,
          littleZ = 122,
          zero = 48,
          nine = 57,
          plus = 43,
          slash = 47,
          littleOffset = 26,
          numberOffset = 52;
        return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
      };
    }),
    require_base64_vlq = __commonJSMin(exports => {
      var base64 = ii(),
        VLQ_BASE_SHIFT = 5,
        VLQ_BASE = 1 << VLQ_BASE_SHIFT,
        VLQ_BASE_MASK = VLQ_BASE - 1,
        VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      toVLQSigned(toVLQSigned, "toVLQSigned"), __name(toVLQSigned, "toVLQSigned");
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1,
          shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      fromVLQSigned(fromVLQSigned, "fromVLQSigned"), __name(fromVLQSigned, "fromVLQSigned"), exports.encode = __name(function (aValue) {
        var encoded = "",
          digit,
          vlq = toVLQSigned(aValue);
        do digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit); while (vlq > 0);
        return encoded;
      }, "base64VLQ_encode"), exports.decode = __name(function (aStr, aIndex, aOutParam) {
        var strLen = aStr.length,
          result = 0,
          shift = 0,
          continuation,
          digit;
        do {
          if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
          if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
      }, "base64VLQ_decode");
    }),
    require_util = __commonJSMin(exports => {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) return aArgs[aName];
        if (arguments.length === 3) return aDefaultValue;
        throw new Error('"' + aName + '" is a required argument.');
      }
      getArg(getArg, "getArg"), __name(getArg, "getArg"), exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,
        dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        return match ? {
          scheme: match[1],
          auth: match[2],
          host: match[3],
          port: match[4],
          path: match[5]
        } : null;
      }
      urlParse(urlParse, "urlParse"), __name(urlParse, "urlParse"), exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), aParsedUrl.path && (url += aParsedUrl.path), url;
      }
      urlGenerate(urlGenerate, "urlGenerate"), __name(urlGenerate, "urlGenerate"), exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath,
          url = urlParse(aPath);
        if (url) {
          if (!url.path) return aPath;
          path = url.path;
        }
        for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i = parts.length - 1; i >= 0; i--) part = parts[i], part === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
        return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url ? (url.path = path, urlGenerate(url)) : path;
      }
      normalize(normalize, "normalize"), __name(normalize, "normalize"), exports.normalize = normalize;
      function join(aRoot, aPath) {
        aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
        var aPathUrl = urlParse(aPath),
          aRootUrl = urlParse(aRoot);
        if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme) return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
        if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) return aRootUrl.host = aPath, urlGenerate(aRootUrl);
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
      }
      join(join, "join"), __name(join, "join"), exports.join = join, exports.isAbsolute = function (aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
        for (var level = 0; aPath.indexOf(aRoot + "/") !== 0;) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/))) return aPath;
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      relative(relative, "relative"), __name(relative, "relative"), exports.relative = relative;
      var supportsNullProto = function () {
        var obj = Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity(s) {
        return s;
      }
      identity(identity, "identity"), __name(identity, "identity");
      function toSetString(aStr) {
        return isProtoString(aStr) ? "$" + aStr : aStr;
      }
      toSetString(toSetString, "toSetString"), __name(toSetString, "toSetString"), exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        return isProtoString(aStr) ? aStr.slice(1) : aStr;
      }
      fromSetString(fromSetString, "fromSetString"), __name(fromSetString, "fromSetString"), exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s) {
        if (!s) return !1;
        var length = s.length;
        if (length < 9 || s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) return !1;
        for (var i = length - 10; i >= 0; i--) if (s.charCodeAt(i) !== 36) return !1;
        return !0;
      }
      isProtoString(isProtoString, "isProtoString"), __name(isProtoString, "isProtoString");
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
      }
      compareByOriginalPositions(compareByOriginalPositions, "compareByOriginalPositions"), __name(compareByOriginalPositions, "compareByOriginalPositions"), exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
      }
      compareByGeneratedPositionsDeflated(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated"), __name(compareByGeneratedPositionsDeflated, "compareByGeneratedPositionsDeflated"), exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
      }
      strcmp(strcmp, "strcmp"), __name(strcmp, "strcmp");
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
      }
      compareByGeneratedPositionsInflated(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated"), __name(compareByGeneratedPositionsInflated, "compareByGeneratedPositionsInflated"), exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      parseSourceMapInput(parseSourceMapInput, "parseSourceMapInput"), __name(parseSourceMapInput, "parseSourceMapInput"), exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) throw new Error("sourceMapURL could not be parsed");
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      computeSourceURL(computeSourceURL, "computeSourceURL"), __name(computeSourceURL, "computeSourceURL"), exports.computeSourceURL = computeSourceURL;
    }),
    require_array_set = __commonJSMin(exports => {
      var util = We(),
        has = Object.prototype.hasOwnProperty,
        hasNativeMap = typeof Map < "u";
      function ArraySet() {
        this._array = [], this._set = hasNativeMap ? new Map() : Object.create(null);
      }
      ArraySet(ArraySet, "ArraySet"), __name(ArraySet, "ArraySet"), ArraySet.fromArray = __name(function (aArray, aAllowDuplicates) {
        for (var set = new ArraySet(), i = 0, len = aArray.length; i < len; i++) set.add(aArray[i], aAllowDuplicates);
        return set;
      }, "ArraySet_fromArray"), ArraySet.prototype.size = __name(function () {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      }, "ArraySet_size"), ArraySet.prototype.add = __name(function (aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr),
          isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr),
          idx = this._array.length;
        (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
      }, "ArraySet_add"), ArraySet.prototype.has = __name(function (aStr) {
        if (hasNativeMap) return this._set.has(aStr);
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }, "ArraySet_has"), ArraySet.prototype.indexOf = __name(function (aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) return idx;
        } else {
          var sStr = util.toSetString(aStr);
          if (has.call(this._set, sStr)) return this._set[sStr];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      }, "ArraySet_indexOf"), ArraySet.prototype.at = __name(function (aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
        throw new Error("No element indexed by " + aIdx);
      }, "ArraySet_at"), ArraySet.prototype.toArray = __name(function () {
        return this._array.slice();
      }, "ArraySet_toArray"), exports.ArraySet = ArraySet;
    }),
    require_mapping_list = __commonJSMin(exports => {
      var util = We();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine,
          lineB = mappingB.generatedLine,
          columnA = mappingA.generatedColumn,
          columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      generatedPositionAfter(generatedPositionAfter, "generatedPositionAfter"), __name(generatedPositionAfter, "generatedPositionAfter");
      function MappingList() {
        this._array = [], this._sorted = !0, this._last = {
          generatedLine: -1,
          generatedColumn: 0
        };
      }
      MappingList(MappingList, "MappingList"), __name(MappingList, "MappingList"), MappingList.prototype.unsortedForEach = __name(function (aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      }, "MappingList_forEach"), MappingList.prototype.add = __name(function (aMapping) {
        generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
      }, "MappingList_add"), MappingList.prototype.toArray = __name(function () {
        return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
      }, "MappingList_toArray"), exports.MappingList = MappingList;
    }),
    require_source_map_generator = __commonJSMin(exports => {
      var base64VLQ = On(),
        util = We(),
        ArraySet = Wn().ArraySet,
        MappingList = gi().MappingList;
      function SourceMapGenerator(aArgs) {
        aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
      }
      SourceMapGenerator(SourceMapGenerator, "SourceMapGenerator"), __name(SourceMapGenerator, "SourceMapGenerator"), SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = __name(function (aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot,
          generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
        return aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util.relative(sourceRoot, newMapping.source)), newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
        }), aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var sourceRelative = sourceFile;
          sourceRoot !== null && (sourceRelative = util.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          content != null && generator.setSourceContent(sourceFile, content);
        }), generator;
      }, "SourceMapGenerator_fromSourceMap"), SourceMapGenerator.prototype.addMapping = __name(function (aArgs) {
        var generated = util.getArg(aArgs, "generated"),
          original = util.getArg(aArgs, "original", null),
          source = util.getArg(aArgs, "source", null),
          name = util.getArg(aArgs, "name", null);
        this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name
        });
      }, "SourceMapGenerator_addMapping"), SourceMapGenerator.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
        var source = aSourceFile;
        this._sourceRoot != null && (source = util.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
      }, "SourceMapGenerator_setSourceContent"), SourceMapGenerator.prototype.applySourceMap = __name(function (aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile));
        var newSources = new ArraySet(),
          newNames = new ArraySet();
        this._mappings.unsortedForEach(function (mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
          }
          var source = mapping.source;
          source != null && !newSources.has(source) && newSources.add(source);
          var name = mapping.name;
          name != null && !newNames.has(name) && newNames.add(name);
        }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          content != null && (aSourceMapPath != null && (sourceFile = util.join(aSourceMapPath, sourceFile)), sourceRoot != null && (sourceFile = util.relative(sourceRoot, sourceFile)), this.setSourceContent(sourceFile, content));
        }, this);
      }, "SourceMapGenerator_applySourceMap"), SourceMapGenerator.prototype._validateMapping = __name(function (aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
        if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
          if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      }, "SourceMapGenerator_validateMapping"), SourceMapGenerator.prototype._serializeMappings = __name(function () {
        for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
          if (mapping = mappings[i], next = "", mapping.generatedLine !== previousGeneratedLine) for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine;) next += ";", previousGeneratedLine++;else if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
            next += ",";
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
        }
        return result;
      }, "SourceMapGenerator_serializeMappings"), SourceMapGenerator.prototype._generateSourcesContent = __name(function (aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) return null;
          aSourceRoot != null && (source = util.relative(aSourceRoot, source));
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      }, "SourceMapGenerator_generateSourcesContent"), SourceMapGenerator.prototype.toJSON = __name(function () {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
      }, "SourceMapGenerator_toJSON"), SourceMapGenerator.prototype.toString = __name(function () {
        return JSON.stringify(this.toJSON());
      }, "SourceMapGenerator_toString"), exports.SourceMapGenerator = SourceMapGenerator;
    }),
    require_binary_search = __commonJSMin(exports => {
      exports.GREATEST_LOWER_BOUND = 1, exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow,
          cmp = aCompare(aNeedle, aHaystack[mid], !0);
        return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
      }
      recursiveSearch(recursiveSearch, "recursiveSearch"), __name(recursiveSearch, "recursiveSearch"), exports.search = __name(function (aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) return -1;
        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
        if (index < 0) return -1;
        for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0;) --index;
        return index;
      }, "search");
    }),
    require_quick_sort = __commonJSMin(exports => {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y], ary[y] = temp;
      }
      swap(swap, "swap"), __name(swap, "swap");
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      randomIntInRange(randomIntInRange, "randomIntInRange"), __name(randomIntInRange, "randomIntInRange");
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r),
            i = p - 1;
          swap(ary, pivotIndex, r);
          for (var pivot = ary[r], j = p; j < r; j++) comparator(ary[j], pivot) <= 0 && (i += 1, swap(ary, i, j));
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
        }
      }
      doQuickSort(doQuickSort, "doQuickSort"), __name(doQuickSort, "doQuickSort"), exports.quickSort = function (ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }),
    require_source_map_consumer = __commonJSMin(exports => {
      var util = We(),
        binarySearch = yi(),
        ArraySet = Wn().ArraySet,
        base64VLQ = On(),
        quickSort = Si().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        return typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer(SourceMapConsumer, "SourceMapConsumer"), __name(SourceMapConsumer, "SourceMapConsumer"), SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: !0,
        enumerable: !0,
        get: function () {
          return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
        }
      }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: !0,
        enumerable: !0,
        get: function () {
          return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
        }
      }), SourceMapConsumer.prototype._charIsMappingSeparator = __name(function (aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      }, "SourceMapConsumer_charIsMappingSeparator"), SourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      }, "SourceMapConsumer_parseMappings"), SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, SourceMapConsumer.prototype.eachMapping = __name(function (aCallback, aContext, aOrder) {
        var context = aContext || null,
          order = aOrder || SourceMapConsumer.GENERATED_ORDER,
          mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          return source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      }, "SourceMapConsumer_eachMapping"), SourceMapConsumer.prototype.allGeneratedPositionsFor = __name(function (aArgs) {
        var line = util.getArg(aArgs, "line"),
          needle = {
            source: util.getArg(aArgs, "source"),
            originalLine: line,
            originalColumn: util.getArg(aArgs, "column", 0)
          };
        if (needle.source = this._findSourceIndex(needle.source), needle.source < 0) return [];
        var mappings = [],
          index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine;) mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          }), mapping = this._originalMappings[++index];else for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn;) mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          }), mapping = this._originalMappings[++index];
        }
        return mappings;
      }, "SourceMapConsumer_allGeneratedPositionsFor"), exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
        var version = util.getArg(sourceMap, "version"),
          sources = util.getArg(sourceMap, "sources"),
          names = util.getArg(sourceMap, "names", []),
          sourceRoot = util.getArg(sourceMap, "sourceRoot", null),
          sourcesContent = util.getArg(sourceMap, "sourcesContent", null),
          mappings = util.getArg(sourceMap, "mappings"),
          file = util.getArg(sourceMap, "file", null);
        if (version != this._version) throw new Error("Unsupported version: " + version);
        sourceRoot && (sourceRoot = util.normalize(sourceRoot)), sources = sources.map(String).map(util.normalize).map(function (source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function (s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
      }
      BasicSourceMapConsumer(BasicSourceMapConsumer, "BasicSourceMapConsumer"), __name(BasicSourceMapConsumer, "BasicSourceMapConsumer"), BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) if (this._absoluteSources[i] == aSource) return i;
        return -1;
      }, BasicSourceMapConsumer.fromSourceMap = __name(function (aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype),
          names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0),
          sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
        smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function (s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i],
            destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
        }
        return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
      }, "SourceMapConsumer_fromSourceMap"), BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function () {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
      }
      Mapping(Mapping, "Mapping"), __name(Mapping, "Mapping"), BasicSourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
        for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str, segment, end, value; index < length;) if (aStr.charAt(index) === ";") generatedLine++, index++, previousGeneratedColumn = 0;else if (aStr.charAt(index) === ",") index++;else {
          for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++);
          if (str = aStr.slice(index, end), segment = cachedSegments[str], segment) index += str.length;else {
            for (segment = []; index < end;) base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
            if (segment.length === 2) throw new Error("Found a source, but no line and column");
            if (segment.length === 3) throw new Error("Found a source and line, but no column");
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
      }, "SourceMapConsumer_parseMappings"), BasicSourceMapConsumer.prototype._findMapping = __name(function (aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      }, "SourceMapConsumer_findMapping"), BasicSourceMapConsumer.prototype.computeColumnSpans = __name(function () {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = 1 / 0;
        }
      }, "SourceMapConsumer_computeColumnSpans"), BasicSourceMapConsumer.prototype.originalPositionFor = __name(function (aArgs) {
        var needle = {
            generatedLine: util.getArg(aArgs, "line"),
            generatedColumn: util.getArg(aArgs, "column")
          },
          index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            source !== null && (source = this._sources.at(source), source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
            var name = util.getArg(mapping, "name", null);
            return name !== null && (name = this._names.at(name)), {
              source: source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name: name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }, "SourceMapConsumer_originalPositionFor"), BasicSourceMapConsumer.prototype.hasContentsOfAllSources = __name(function () {
        return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
          return sc == null;
        }) : !1;
      }, "BasicSourceMapConsumer_hasContentsOfAllSources"), BasicSourceMapConsumer.prototype.sourceContentFor = __name(function (aSource, nullOnMissing) {
        if (!this.sourcesContent) return null;
        var index = this._findSourceIndex(aSource);
        if (index >= 0) return this.sourcesContent[index];
        var relativeSource = aSource;
        this.sourceRoot != null && (relativeSource = util.relative(this.sourceRoot, relativeSource));
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
        if (nullOnMissing) return null;
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }, "SourceMapConsumer_sourceContentFor"), BasicSourceMapConsumer.prototype.generatedPositionFor = __name(function (aArgs) {
        var source = util.getArg(aArgs, "source");
        if (source = this._findSourceIndex(source), source < 0) return {
          line: null,
          column: null,
          lastColumn: null
        };
        var needle = {
            source: source,
            originalLine: util.getArg(aArgs, "line"),
            originalColumn: util.getArg(aArgs, "column")
          },
          index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }, "SourceMapConsumer_generatedPositionFor"), exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        typeof aSourceMap == "string" && (sourceMap = util.parseSourceMapInput(aSourceMap));
        var version = util.getArg(sourceMap, "version"),
          sections = util.getArg(sourceMap, "sections");
        if (version != this._version) throw new Error("Unsupported version: " + version);
        this._sources = new ArraySet(), this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function (s) {
          if (s.url) throw new Error("Support for url field in sections not implemented.");
          var offset = util.getArg(s, "offset"),
            offsetLine = util.getArg(offset, "line"),
            offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
          return lastOffset = offset, {
            generatedOffset: {
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer(IndexedSourceMapConsumer, "IndexedSourceMapConsumer"), __name(IndexedSourceMapConsumer, "IndexedSourceMapConsumer"), IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function () {
          for (var sources = [], i = 0; i < this._sections.length; i++) for (var j = 0; j < this._sections[i].consumer.sources.length; j++) sources.push(this._sections[i].consumer.sources[j]);
          return sources;
        }
      }), IndexedSourceMapConsumer.prototype.originalPositionFor = __name(function (aArgs) {
        var needle = {
            generatedLine: util.getArg(aArgs, "line"),
            generatedColumn: util.getArg(aArgs, "column")
          },
          sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
            return cmp || needle.generatedColumn - section.generatedOffset.generatedColumn;
          }),
          section = this._sections[sectionIndex];
        return section ? section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        }) : {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }, "IndexedSourceMapConsumer_originalPositionFor"), IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = __name(function () {
        return this._sections.every(function (s) {
          return s.consumer.hasContentsOfAllSources();
        });
      }, "IndexedSourceMapConsumer_hasContentsOfAllSources"), IndexedSourceMapConsumer.prototype.sourceContentFor = __name(function (aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i],
            content = section.consumer.sourceContentFor(aSource, !0);
          if (content) return content;
        }
        if (nullOnMissing) return null;
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }, "IndexedSourceMapConsumer_sourceContentFor"), IndexedSourceMapConsumer.prototype.generatedPositionFor = __name(function (aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) !== -1) {
            var generatedPosition = section.consumer.generatedPositionFor(aArgs);
            if (generatedPosition) {
              var ret = {
                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
              };
              return ret;
            }
          }
        }
        return {
          line: null,
          column: null
        };
      }, "IndexedSourceMapConsumer_generatedPositionFor"), IndexedSourceMapConsumer.prototype._parseMappings = __name(function (aStr, aSourceRoot) {
        this.__generatedMappings = [], this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j],
            source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
          var name = null;
          mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };
          this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
      }, "IndexedSourceMapConsumer_parseMappings"), exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }),
    require_source_node = __commonJSMin(exports => {
      var SourceMapGenerator = Un().SourceMapGenerator,
        util = We(),
        REGEX_NEWLINE = /(\r?\n)/,
        NEWLINE_CODE = 10,
        isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
      }
      SourceNode(SourceNode, "SourceNode"), __name(SourceNode, "SourceNode"), SourceNode.fromStringWithSourceMap = __name(function (aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode(),
          remainingLines = aGeneratedCode.split(REGEX_NEWLINE),
          remainingLinesIndex = 0,
          shiftNextLine = __name(function () {
            var lineContents = getNextLine(),
              newLine = getNextLine() || "";
            return lineContents + newLine;
            function getNextLine() {
              return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
            }
          }, "shiftNextLine"),
          lastGeneratedLine = 1,
          lastGeneratedColumn = 0,
          lastMapping = null;
        return aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;else {
            var nextLine = remainingLines[remainingLinesIndex] || "",
              code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
            return;
          }
          for (; lastGeneratedLine < mapping.generatedLine;) node.add(shiftNextLine()), lastGeneratedLine++;
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          content != null && (aRelativePath != null && (sourceFile = util.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
        }), node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) node.add(code);else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
          }
        }
      }, "SourceNode_fromStringWithSourceMap"), SourceNode.prototype.add = __name(function (aChunk) {
        if (Array.isArray(aChunk)) aChunk.forEach(function (chunk) {
          this.add(chunk);
        }, this);else if (aChunk[isSourceNode] || typeof aChunk == "string") aChunk && this.children.push(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
        return this;
      }, "SourceNode_add"), SourceNode.prototype.prepend = __name(function (aChunk) {
        if (Array.isArray(aChunk)) for (var i = aChunk.length - 1; i >= 0; i--) this.prepend(aChunk[i]);else if (aChunk[isSourceNode] || typeof aChunk == "string") this.children.unshift(aChunk);else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
        return this;
      }, "SourceNode_prepend"), SourceNode.prototype.walk = __name(function (aFn) {
        for (var chunk, i = 0, len = this.children.length; i < len; i++) chunk = this.children[i], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }, "SourceNode_walk"), SourceNode.prototype.join = __name(function (aSep) {
        var newChildren,
          i,
          len = this.children.length;
        if (len > 0) {
          for (newChildren = [], i = 0; i < len - 1; i++) newChildren.push(this.children[i]), newChildren.push(aSep);
          newChildren.push(this.children[i]), this.children = newChildren;
        }
        return this;
      }, "SourceNode_join"), SourceNode.prototype.replaceRight = __name(function (aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
      }, "SourceNode_replaceRight"), SourceNode.prototype.setSourceContent = __name(function (aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      }, "SourceNode_setSourceContent"), SourceNode.prototype.walkSourceContents = __name(function (aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
        for (var sources = Object.keys(this.sourceContents), i = 0, len = sources.length; i < len; i++) aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }, "SourceNode_walkSourceContents"), SourceNode.prototype.toString = __name(function () {
        var str = "";
        return this.walk(function (chunk) {
          str += chunk;
        }), str;
      }, "SourceNode_toString"), SourceNode.prototype.toStringWithSourceMap = __name(function (aArgs) {
        var generated = {
            code: "",
            line: 1,
            column: 0
          },
          map = new SourceMapGenerator(aArgs),
          sourceMappingActive = !1,
          lastOriginalSource = null,
          lastOriginalLine = null,
          lastOriginalColumn = null,
          lastOriginalName = null;
        return this.walk(function (chunk, original) {
          generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          }), lastOriginalSource = null, sourceMappingActive = !1);
          for (var idx = 0, length = chunk.length; idx < length; idx++) chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          })) : generated.column++;
        }), this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        }), {
          code: generated.code,
          map: map
        };
      }, "SourceNode_toStringWithSourceMap"), exports.SourceNode = SourceNode;
    }),
    require_source_map = __commonJSMin(exports => {
      exports.SourceMapGenerator = Un().SourceMapGenerator, exports.SourceMapConsumer = Ei().SourceMapConsumer, exports.SourceNode = Mi().SourceNode;
    }),
    require_buffer_from = __commonJSMin((exports, module) => {
      var toString = Object.prototype.toString,
        isModern = typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
      function isArrayBuffer(input) {
        return toString.call(input).slice(8, -1) === "ArrayBuffer";
      }
      isArrayBuffer(isArrayBuffer, "isArrayBuffer"), __name(isArrayBuffer, "isArrayBuffer");
      function fromArrayBuffer(obj, byteOffset, length) {
        byteOffset >>>= 0;
        var maxLength = obj.byteLength - byteOffset;
        if (maxLength < 0) throw new RangeError("'offset' is out of bounds");
        if (length === void 0) length = maxLength;else if (length >>>= 0, length > maxLength) throw new RangeError("'length' is out of bounds");
        return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
      }
      fromArrayBuffer(fromArrayBuffer, "fromArrayBuffer"), __name(fromArrayBuffer, "fromArrayBuffer");
      function fromString(string, encoding) {
        if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
        return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
      }
      fromString(fromString, "fromString"), __name(fromString, "fromString");
      function bufferFrom(value, encodingOrOffset, length) {
        if (typeof value == "number") throw new TypeError('"value" argument must not be a number');
        return isArrayBuffer(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
      }
      bufferFrom(bufferFrom, "bufferFrom"), __name(bufferFrom, "bufferFrom"), module.exports = bufferFrom;
    }),
    require_source_map_support = __commonJSMin((exports, module) => {
      var SourceMapConsumer = Ii().SourceMapConsumer,
        path = require("path"),
        fs;
      try {
        fs = require("fs"), (!fs.existsSync || !fs.readFileSync) && (fs = null);
      } catch {}
      var bufferFrom = Li();
      function dynamicRequire(mod, request) {
        return mod.require(request);
      }
      dynamicRequire(dynamicRequire, "dynamicRequire"), __name(dynamicRequire, "dynamicRequire");
      var errorFormatterInstalled = !1,
        uncaughtShimInstalled = !1,
        emptyCacheBetweenOperations = !1,
        environment = "auto",
        fileContentsCache = {},
        sourceMapCache = {},
        reSourceMap = /^data:application\/json[^,]+base64,/,
        retrieveFileHandlers = [],
        retrieveMapHandlers = [];
      function isInBrowser() {
        return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
      }
      isInBrowser(isInBrowser, "isInBrowser"), __name(isInBrowser, "isInBrowser");
      function hasGlobalProcessEventEmitter() {
        return typeof process == "object" && process !== null && typeof process.on == "function";
      }
      hasGlobalProcessEventEmitter(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter"), __name(hasGlobalProcessEventEmitter, "hasGlobalProcessEventEmitter");
      function globalProcessVersion() {
        return typeof process == "object" && process !== null ? process.version : "";
      }
      globalProcessVersion(globalProcessVersion, "globalProcessVersion"), __name(globalProcessVersion, "globalProcessVersion");
      function globalProcessStderr() {
        if (typeof process == "object" && process !== null) return process.stderr;
      }
      globalProcessStderr(globalProcessStderr, "globalProcessStderr"), __name(globalProcessStderr, "globalProcessStderr");
      function globalProcessExit(code) {
        if (typeof process == "object" && process !== null && typeof process.exit == "function") return process.exit(code);
      }
      globalProcessExit(globalProcessExit, "globalProcessExit"), __name(globalProcessExit, "globalProcessExit");
      function handlerExec(list) {
        return function (arg) {
          for (var i = 0; i < list.length; i++) {
            var ret = list[i](arg);
            if (ret) return ret;
          }
          return null;
        };
      }
      handlerExec(handlerExec, "handlerExec"), __name(handlerExec, "handlerExec");
      var retrieveFile = handlerExec(retrieveFileHandlers);
      retrieveFileHandlers.push(function (path) {
        if (path = path.trim(), /^file:/.test(path) && (path = path.replace(/file:\/\/\/(\w:)?/, function (protocol, drive) {
          return drive ? "" : "/";
        })), path in fileContentsCache) return fileContentsCache[path];
        var contents = "";
        try {
          if (fs) fs.existsSync(path) && (contents = fs.readFileSync(path, "utf8"));else {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", path, !1), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
          }
        } catch {}
        return fileContentsCache[path] = contents;
      });
      function supportRelativeURL(file, url) {
        if (!file) return url;
        var dir = path.dirname(file),
          match = /^\w+:\/\/[^\/]*/.exec(dir),
          protocol = match ? match[0] : "",
          startPath = dir.slice(protocol.length);
        return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url);
      }
      supportRelativeURL(supportRelativeURL, "supportRelativeURL"), __name(supportRelativeURL, "supportRelativeURL");
      function retrieveSourceMapURL(source) {
        var fileData;
        if (isInBrowser()) try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) return sourceMapHeader;
        } catch {}
        fileData = retrieveFile(source);
        for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData);) lastMatch = match;
        return lastMatch ? lastMatch[1] : null;
      }
      retrieveSourceMapURL(retrieveSourceMapURL, "retrieveSourceMapURL"), __name(retrieveSourceMapURL, "retrieveSourceMapURL");
      var retrieveSourceMap = handlerExec(retrieveMapHandlers);
      retrieveMapHandlers.push(function (source) {
        var sourceMappingURL = retrieveSourceMapURL(source);
        if (!sourceMappingURL) return null;
        var sourceMapData;
        if (reSourceMap.test(sourceMappingURL)) {
          var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
          sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
        } else sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
        return sourceMapData ? {
          url: sourceMappingURL,
          map: sourceMapData
        } : null;
      });
      function mapSourcePosition(position) {
        var sourceMap = sourceMapCache[position.source];
        if (!sourceMap) {
          var urlAndMap = retrieveSourceMap(position.source);
          urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function (source, i) {
            var contents = sourceMap.map.sourcesContent[i];
            if (contents) {
              var url = supportRelativeURL(sourceMap.url, source);
              fileContentsCache[url] = contents;
            }
          })) : sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
        }
        if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
          var originalPosition = sourceMap.map.originalPositionFor(position);
          if (originalPosition.source !== null) return originalPosition.source = supportRelativeURL(sourceMap.url, originalPosition.source), originalPosition;
        }
        return position;
      }
      mapSourcePosition(mapSourcePosition, "mapSourcePosition"), __name(mapSourcePosition, "mapSourcePosition");
      function mapEvalOrigin(origin) {
        var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
        if (match) {
          var position = mapSourcePosition({
            source: match[2],
            line: +match[3],
            column: match[4] - 1
          });
          return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
        }
        return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
      }
      mapEvalOrigin(mapEvalOrigin, "mapEvalOrigin"), __name(mapEvalOrigin, "mapEvalOrigin");
      function CallSiteToString() {
        var fileName,
          fileLocation = "";
        if (this.isNative()) fileLocation = "native";else {
          fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
          var lineNumber = this.getLineNumber();
          if (lineNumber != null) {
            fileLocation += ":" + lineNumber;
            var columnNumber = this.getColumnNumber();
            columnNumber && (fileLocation += ":" + columnNumber);
          }
        }
        var line = "",
          functionName = this.getFunctionName(),
          addSuffix = !0,
          isConstructor = this.isConstructor(),
          isMethodCall = !(this.isToplevel() || isConstructor);
        if (isMethodCall) {
          var typeName = this.getTypeName();
          typeName === "[object Object]" && (typeName = "null");
          var methodName = this.getMethodName();
          functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
        } else isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
        return addSuffix && (line += " (" + fileLocation + ")"), line;
      }
      CallSiteToString(CallSiteToString, "CallSiteToString"), __name(CallSiteToString, "CallSiteToString");
      function cloneCallSite(frame) {
        var object = {};
        return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function (name) {
          object[name] = /^(?:is|get)/.test(name) ? function () {
            return frame[name].call(frame);
          } : frame[name];
        }), object.toString = CallSiteToString, object;
      }
      cloneCallSite(cloneCallSite, "cloneCallSite"), __name(cloneCallSite, "cloneCallSite");
      function wrapCallSite(frame, state) {
        if (state === void 0 && (state = {
          nextPosition: null,
          curPosition: null
        }), frame.isNative()) return state.curPosition = null, frame;
        var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
        if (source) {
          var line = frame.getLineNumber(),
            column = frame.getColumnNumber() - 1,
            noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/,
            headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
          line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
          var position = mapSourcePosition({
            source: source,
            line: line,
            column: column
          });
          state.curPosition = position, frame = cloneCallSite(frame);
          var originalFunctionName = frame.getFunctionName;
          return frame.getFunctionName = function () {
            return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
          }, frame.getFileName = function () {
            return position.source;
          }, frame.getLineNumber = function () {
            return position.line;
          }, frame.getColumnNumber = function () {
            return position.column + 1;
          }, frame.getScriptNameOrSourceURL = function () {
            return position.source;
          }, frame;
        }
        var origin = frame.isEval() && frame.getEvalOrigin();
        return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function () {
          return origin;
        }), frame;
      }
      wrapCallSite(wrapCallSite, "wrapCallSite"), __name(wrapCallSite, "wrapCallSite");
      function prepareStackTrace(error, stack) {
        emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
        for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = {
            nextPosition: null,
            curPosition: null
          }, processedStack = [], i = stack.length - 1; i >= 0; i--) processedStack.push(`
    at ` + wrapCallSite(stack[i], state)), state.nextPosition = state.curPosition;
        return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
      }
      prepareStackTrace(prepareStackTrace, "prepareStackTrace"), __name(prepareStackTrace, "prepareStackTrace");
      function getErrorSource(error) {
        var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
        if (match) {
          var source = match[1],
            line = +match[2],
            column = +match[3],
            contents = fileContentsCache[source];
          if (!contents && fs && fs.existsSync(source)) try {
            contents = fs.readFileSync(source, "utf8");
          } catch {
            contents = "";
          }
          if (contents) {
            var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
            if (code) return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
          }
        }
        return null;
      }
      getErrorSource(getErrorSource, "getErrorSource"), __name(getErrorSource, "getErrorSource");
      function printErrorAndExit(error) {
        var source = getErrorSource(error),
          stderr = globalProcessStderr();
        stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
      }
      printErrorAndExit(printErrorAndExit, "printErrorAndExit"), __name(printErrorAndExit, "printErrorAndExit");
      function shimEmitUncaughtException() {
        var origEmit = process.emit;
        process.emit = function (type) {
          if (type === "uncaughtException") {
            var hasStack = arguments[1] && arguments[1].stack,
              hasListeners = this.listeners(type).length > 0;
            if (hasStack && !hasListeners) return printErrorAndExit(arguments[1]);
          }
          return origEmit.apply(this, arguments);
        };
      }
      shimEmitUncaughtException(shimEmitUncaughtException, "shimEmitUncaughtException"), __name(shimEmitUncaughtException, "shimEmitUncaughtException");
      var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0),
        originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
      exports.wrapCallSite = wrapCallSite, exports.getErrorSource = getErrorSource, exports.mapSourcePosition = mapSourcePosition, exports.retrieveSourceMap = retrieveSourceMap, exports.install = function (options) {
        if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1)) throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
          var Module = dynamicRequire(module, "module"),
            $compile = Module.prototype._compile;
          $compile.__sourceMapSupport || (Module.prototype._compile = function (content, filename) {
            return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
          }, Module.prototype._compile.__sourceMapSupport = !0);
        }
        if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
          var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
          try {
            var worker_threads = dynamicRequire(module, "worker_threads");
            worker_threads.isMainThread === !1 && (installHandler = !1);
          } catch {}
          installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
        }
      }, exports.resetRetrieveHandlers = function () {
        retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
      };
    }),
    require_register = __commonJSMin(() => {
      Ri().install();
    }),
    lib_exports = {};
  __export(lib_exports, {
    CursorHistoryMatcher: () => CursorHistoryMatcher,
    CursorSnippetsPickingStrategy: () => CursorSnippetsPickingStrategy,
    DEFAULT_NUM_OF_SNIPPETS: () => DEFAULT_NUM_OF_SNIPPETS,
    DEFAULT_TREE_TRAVERSAL_CONFIG: () => DEFAULT_TREE_TRAVERSAL_CONFIG,
    ElidableText: () => ElidableText,
    FileSystem: () => FileSystem,
    LanguageMarkerOption: () => LanguageMarkerOption,
    LineEndingOptions: () => LineEndingOptions,
    LineWithValueAndCost: () => LineWithValueAndCost,
    LocalImportContextOption: () => LocalImportContextOption,
    MAX_EDIT_DISTANCE_LENGTH: () => MAX_EDIT_DISTANCE_LENGTH,
    MAX_PROMPT_LENGTH: () => MAX_PROMPT_LENGTH,
    NeighboringSnippetType: () => NeighboringSnippetType,
    NeighboringTabsOption: () => NeighboringTabsOption,
    PathMarkerOption: () => PathMarkerOption,
    PromptOptions: () => PromptOptions,
    ProviderTimeoutError: () => ProviderTimeoutError,
    SnippetOrchestrator: () => SnippetOrchestrator,
    SnippetPositionOption: () => SnippetPositionOption,
    SnippetProviderType: () => SnippetProviderType,
    SnippetSelectionOption: () => SnippetSelectionOption,
    SnippetSemantics: () => SnippetSemantics,
    SuffixMatchOption: () => SuffixMatchOption,
    SuffixOption: () => SuffixOption,
    SuffixStartMode: () => SuffixStartMode,
    TOKENS_RESERVED_FOR_SUFFIX_ENCODING: () => TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
    TokenizerName: () => TokenizerName,
    WASMLanguage: () => WASMLanguage,
    blankNode: () => blankNode,
    buildLabelRules: () => buildLabelRules,
    clearLabels: () => clearLabels,
    clearLabelsIf: () => clearLabelsIf,
    combineClosersAndOpeners: () => combineClosersAndOpeners,
    comment: () => comment,
    commentBlockAsSingles: () => commentBlockAsSingles,
    createWorker: () => createWorker,
    cutTreeAfterLine: () => cutTreeAfterLine,
    deparseAndCutTree: () => deparseAndCutTree,
    deparseLine: () => deparseLine,
    deparseTree: () => deparseTree,
    describeTree: () => describeTree,
    duplicateTree: () => duplicateTree,
    elidableTextForDiff: () => elidableTextForDiff,
    elidableTextForSourceCode: () => elidableTextForSourceCode,
    encodeTree: () => encodeTree,
    firstLineOf: () => firstLineOf,
    flattenVirtual: () => flattenVirtual,
    foldTree: () => foldTree,
    fromTreeWithFocussedLines: () => fromTreeWithFocussedLines,
    fromTreeWithValuedLines: () => fromTreeWithValuedLines,
    getAncestorWithSiblingFunctions: () => getAncestorWithSiblingFunctions,
    getBlockCloseToken: () => getBlockCloseToken,
    getBlockParser: () => getBlockParser,
    getCallSites: () => getCallSites,
    getCursorContext: () => getCursorContext,
    getFirstPrecedingComment: () => getFirstPrecedingComment,
    getFunctionPositions: () => getFunctionPositions,
    getLanguage: () => getLanguage,
    getNodeStart: () => getNodeStart,
    getPrompt: () => getPrompt,
    getTokenizer: () => getTokenizer,
    groupBlocks: () => groupBlocks,
    isBlank: () => isBlank,
    isBlockBodyFinished: () => isBlockBodyFinished,
    isEmptyBlockStart: () => isEmptyBlockStart,
    isFunction: () => isFunction,
    isFunctionDefinition: () => isFunctionDefinition,
    isLine: () => isLine,
    isSupportedLanguageId: () => isSupportedLanguageId,
    isTop: () => isTop,
    isVirtual: () => isVirtual,
    labelLines: () => labelLines,
    labelVirtualInherited: () => labelVirtualInherited,
    languageCommentMarkers: () => languageCommentMarkers,
    languageIdToWasmLanguage: () => languageIdToWasmLanguage,
    lastLineOf: () => lastLineOf,
    lineNode: () => lineNode,
    mapLabels: () => mapLabels,
    normalizeLanguageId: () => normalizeLanguageId,
    parseRaw: () => parseRaw,
    parseTree: () => parseTree,
    parseTreeSitter: () => parseTreeSitter,
    parsesWithoutError: () => parsesWithoutError,
    providersErrors: () => providersErrors,
    providersPerformance: () => providersPerformance,
    providersSnippets: () => providersSnippets,
    queryExports: () => queryExports,
    queryFunctions: () => queryFunctions,
    queryGlobalVars: () => queryGlobalVars,
    queryImports: () => queryImports,
    queryPythonIsDocstring: () => queryPythonIsDocstring,
    rebuildTree: () => rebuildTree,
    registerLanguageSpecificParser: () => registerLanguageSpecificParser,
    resetLineNumbers: () => resetLineNumbers,
    topNode: () => topNode,
    virtualNode: () => virtualNode,
    visitTree: () => visitTree,
    visitTreeConditionally: () => visitTreeConditionally
  });
  module.exports = __toCommonJS(lib_exports);
  var import_path = require("path"),
    import_worker_threads = require("worker_threads"),
    fs = ct(require("fs")),
    path = ct(require("path")),
    import_util = require("util"),
    range = __name((x, y) => Array.from(Array(y).keys()).slice(x), "range"),
    ord = __name(x => x.charCodeAt(0), "ord"),
    chr = __name(x => String.fromCharCode(x), "chr"),
    textDecoder = new _t.TextDecoder("utf-8"),
    decodeStr = __name(arr => textDecoder.decode(new Uint8Array(arr)), "decodeStr"),
    dictZip = __name((x, y) => {
      let result = new Map();
      return x.forEach((_, i) => {
        result.set(x[i], y[i]);
      }), result;
    }, "dictZip");
  function bytes_to_unicode(map) {
    let bs = range(ord("!"), ord("~") + 1).concat(range(ord("\xA1"), ord("\xAC") + 1), range(ord("\xAE"), ord("\xFF") + 1)),
      cs = bs.slice(),
      n = 0;
    for (let b = 0; b < 2 ** 8; b++) bs.includes(b) || (bs.push(b), cs.push(2 ** 8 + n), n = n + 1);
    let cs_ = cs.map(x => chr(x));
    for (let i = 0; i < bs.length; i++) map.set(bs[i], cs_[i]);
  }
  bytes_to_unicode(bytes_to_unicode, "io");
  __name(bytes_to_unicode, "bytes_to_unicode");
  function get_char_pairs(word) {
    let pairs = new Set(),
      prev_char = word[0];
    for (let i = 1; i < word.length; i++) {
      let char = word[i];
      pairs.add([prev_char, char]), prev_char = char;
    }
    return pairs;
  }
  get_char_pairs(get_char_pairs, "rr");
  __name(get_char_pairs, "get_char_pairs");
  var TokenizerName = (TokenizerName => (TokenizerName.cl100k = "cl100k", TokenizerName.mock = "mock", TokenizerName))(TokenizerName || {}),
    tokenizers = new Map();
  function getTokenizer(name = "cl100k") {
    let tokenizer = tokenizers.get(name);
    return tokenizer !== void 0 || (name === "mock" ? tokenizer = new MockTokenizer() : tokenizer = new BPETokenizer(name), tokenizers.set(name, tokenizer)), tokenizer;
  }
  getTokenizer(getTokenizer, "X");
  __name(getTokenizer, "getTokenizer");
  var BPETokenizer = class {
      static {
        __name(this, "Yt");
      }
      constructor(name = "cl100k") {
        this.decoder = new Map(), this.byte_encoder = new Map(), this.byte_decoder = new Map(), this.cache = new Map(), this.textEncoder = new _t.TextEncoder(), this.encodeStr = str => Array.from(this.textEncoder.encode(str));
        let VOCAB = "",
          ENCODER = "";
        if (name === "cl100k") VOCAB = "vocab_cushman002.bpe", ENCODER = "tokenizer_cushman002.json", this.pat = /'s|'t|'re|'ve|'m|'ll|'d|[^\r\n\p{L}\p{N}]?\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]+[\r\n]*|\s*[\r\n]+|\s+(?!\S)|\s+/giu;else throw new Error(`Unknown tokenizer name: ${name}`);
        let encoder_json, bpe_file;
        try {
          let encoder_text = Qt.readFileSync(Xt.resolve(__dirname, "resources", name, ENCODER));
          encoder_json = JSON.parse(encoder_text.toString()), bpe_file = Qt.readFileSync(Xt.resolve(__dirname, "resources", name, VOCAB), "utf-8");
        } catch (e) {
          if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code === "EPERM") && e instanceof Error || e instanceof SyntaxError) {
            let error = new Error(`Could not load tokenizer: ${name}`);
            throw error.code = "CopilotPromptLoadFailure", error;
          }
          throw e;
        }
        this.encoder = new Map(Object.entries(encoder_json));
        for (let [key, value] of this.encoder) this.decoder.set(value, key);
        let bpe_merges = bpe_file.split(`
`).slice(1).filter(l => l.trim().length > 0);
        this.bpe_ranks = dictZip(bpe_merges, range(0, bpe_merges.length)), bytes_to_unicode(this.byte_encoder), this.byte_encoder.forEach((value, key, _) => {
          this.byte_decoder.set(value, key);
        });
      }
      static {
        __name(this, "BPETokenizer");
      }
      byteEncodeStr(s) {
        return this.encodeStr(s).map(x => this.byte_encoder.get(x));
      }
      mutatingConcat(dest, src) {
        for (let i = 0; i < src.length; i++) dest.push(src[i]);
        return dest;
      }
      bpe(chunk) {
        if (this.cache.has(chunk)) return this.cache.get(chunk);
        let bytes = this.byteEncodeStr(chunk),
          pairs = get_char_pairs(bytes);
        if (!pairs) return bytes.map(x => this.encoder.get(x));
        for (;;) {
          let minPairs = new Map();
          pairs.forEach(pair => {
            let joined_pair = pair.join(" "),
              rank = this.bpe_ranks.get(joined_pair);
            minPairs.set(rank === void 0 || isNaN(rank) ? 1e11 : rank, pair);
          });
          let minPairsKeys = Array.from(minPairs.keys()).map(x => Number(x)),
            bigram = minPairs.get(Math.min(...minPairsKeys));
          if (!bigram || !this.bpe_ranks.has(bigram.join(" "))) break;
          let first = bigram[0],
            second = bigram[1],
            new_bytes = [],
            i = 0;
          for (; i < bytes.length;) {
            let j = bytes.indexOf(first, i);
            if (j === -1) {
              this.mutatingConcat(new_bytes, bytes.slice(i));
              break;
            }
            this.mutatingConcat(new_bytes, bytes.slice(i, j)), i = j, bytes[i] === first && i < bytes.length - 1 && bytes[i + 1] === second ? (new_bytes.push(first + second), i = i + 2) : (new_bytes.push(bytes[i]), i = i + 1);
          }
          if (bytes = new_bytes, bytes.length === 1) break;
          pairs = get_char_pairs(bytes);
        }
        let tokens = bytes.map(x => this.encoder.get(x));
        return this.cache.set(chunk, tokens), tokens;
      }
      tokenize(text) {
        let tokens = [],
          matches = Array.from(text.matchAll(this.pat)).map(x => x[0]);
        for (let chunk of matches) {
          let chunk_tokens = this.bpe(chunk);
          this.mutatingConcat(tokens, chunk_tokens);
        }
        return tokens;
      }
      tokenLength(text) {
        return this.tokenize(text).length;
      }
      takeLastTokens(text, n) {
        if (n <= 0) return "";
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          suffix = text.slice(-chars),
          suffixT = this.tokenize(suffix);
        for (; suffixT.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), suffix = text.slice(-chars), suffixT = this.tokenize(suffix);
        return suffixT.length < n ? text : (suffixT = suffixT.slice(-n), this.detokenize(suffixT));
      }
      takeFirstTokens(text, n) {
        if (n <= 0) return {
          text: "",
          tokens: []
        };
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          prefix = text.slice(0, chars),
          prefix_t = this.tokenize(prefix);
        for (; prefix_t.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), prefix = text.slice(0, chars), prefix_t = this.tokenize(prefix);
        return prefix_t.length < n ? {
          text: text,
          tokens: prefix_t
        } : (prefix_t = prefix_t.slice(0, n), {
          text: this.detokenize(prefix_t),
          tokens: prefix_t
        });
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
      detokenize(tokens) {
        let text = tokens.map(x => this.decoder.get(x)).join("");
        return text = decodeStr(text.split("").map(x => this.byte_decoder.get(x))), text;
      }
      tokenizeStrings(text) {
        return this.tokenize(text).map(token => decodeStr(this.decoder.get(token).split("").map(char => this.byte_decoder.get(char))));
      }
    },
    MockTokenizer = class {
      static {
        __name(this, "en");
      }
      constructor() {
        this.hash = str => {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            let char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char, hash &= hash & 65535;
          }
          return hash;
        };
      }
      static {
        __name(this, "MockTokenizer");
      }
      tokenize(text) {
        return this.tokenizeStrings(text).map(this.hash);
      }
      detokenize(tokens) {
        return tokens.map(token => token.toString()).join(" ");
      }
      tokenizeStrings(text) {
        return text.split(/\b/);
      }
      tokenLength(text) {
        return this.tokenizeStrings(text).length;
      }
      takeLastTokens(text, n) {
        return this.tokenizeStrings(text).slice(-n).join("");
      }
      takeFirstTokens(text, n) {
        let tokens = this.tokenizeStrings(text).slice(0, n);
        return {
          text: tokens.join(""),
          tokens: tokens.map(this.hash)
        };
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
    };
  function virtualNode(indentation, subs, label) {
    return {
      type: "virtual",
      indentation: indentation,
      subs: subs,
      label: label
    };
  }
  virtualNode(virtualNode, "ft");
  __name(virtualNode, "virtualNode");
  function lineNode(indentation, lineNumber, sourceLine, subs, label) {
    if (sourceLine === "") throw new Error("Cannot create a line node with an empty source line");
    return {
      type: "line",
      indentation: indentation,
      lineNumber: lineNumber,
      sourceLine: sourceLine,
      subs: subs,
      label: label
    };
  }
  lineNode(lineNode, "tn");
  __name(lineNode, "lineNode");
  function blankNode(line) {
    return {
      type: "blank",
      lineNumber: line,
      subs: []
    };
  }
  blankNode(blankNode, "mt");
  __name(blankNode, "blankNode");
  function topNode(subs) {
    return {
      type: "top",
      indentation: -1,
      subs: subs ?? []
    };
  }
  topNode(topNode, "He");
  __name(topNode, "topNode");
  function isBlank(tree) {
    return tree.type === "blank";
  }
  isBlank(isBlank, "O");
  __name(isBlank, "isBlank");
  function isLine(tree) {
    return tree.type === "line";
  }
  isLine(isLine, "Y");
  __name(isLine, "isLine");
  function isVirtual(tree) {
    return tree.type === "virtual";
  }
  isVirtual(isVirtual, "H");
  __name(isVirtual, "isVirtual");
  function isTop(tree) {
    return tree.type === "top";
  }
  isTop(isTop, "pe");
  __name(isTop, "isTop");
  function cutTreeAfterLine(tree, lineNumber) {
    function cut(tree) {
      if (!isVirtual(tree) && !isTop(tree) && tree.lineNumber === lineNumber) return tree.subs = [], !0;
      for (let i = 0; i < tree.subs.length; i++) if (cut(tree.subs[i])) return tree.subs = tree.subs.slice(0, i + 1), !0;
      return !1;
    }
    cut(cut, "cut"), __name(cut, "cut"), cut(tree);
  }
  cutTreeAfterLine(cutTreeAfterLine, "oo");
  __name(cutTreeAfterLine, "cutTreeAfterLine");
  function duplicateTree(tree) {
    return JSON.parse(JSON.stringify(tree));
  }
  duplicateTree(duplicateTree, "so");
  __name(duplicateTree, "duplicateTree");
  function clearLabels(tree) {
    return visitTree(tree, tree => {
      tree.label = void 0;
    }, "bottomUp"), tree;
  }
  clearLabels(clearLabels, "or");
  __name(clearLabels, "clearLabels");
  function clearLabelsIf(tree, condition) {
    return visitTree(tree, tree => {
      tree.label = tree.label ? condition(tree.label) ? void 0 : tree.label : void 0;
    }, "bottomUp"), tree;
  }
  clearLabelsIf(clearLabelsIf, "nn");
  __name(clearLabelsIf, "clearLabelsIf");
  function mapLabels(tree, map) {
    switch (tree.type) {
      case "line":
      case "virtual":
        let newSubs = tree.subs.map(sub => mapLabels(sub, map));
        return {
          ...tree,
          subs: newSubs,
          label: tree.label ? map(tree.label) : void 0
        };
      case "blank":
        return {
          ...tree,
          label: tree.label ? map(tree.label) : void 0
        };
      case "top":
        return {
          ...tree,
          subs: tree.subs.map(sub => mapLabels(sub, map)),
          label: tree.label ? map(tree.label) : void 0
        };
    }
  }
  mapLabels(mapLabels, "ne");
  __name(mapLabels, "mapLabels");
  function resetLineNumbers(tree) {
    let lineNumber = 0;
    function visitor(tree) {
      !isVirtual(tree) && !isTop(tree) && (tree.lineNumber = lineNumber, lineNumber++);
    }
    visitor(visitor, "visitor"), __name(visitor, "visitor"), visitTree(tree, visitor, "topDown");
  }
  resetLineNumbers(resetLineNumbers, "ao");
  __name(resetLineNumbers, "resetLineNumbers");
  function visitTree(tree, visitor, direction) {
    function _visit(tree) {
      direction === "topDown" && visitor(tree), tree.subs.forEach(subtree => {
        _visit(subtree);
      }), direction === "bottomUp" && visitor(tree);
    }
    _visit(_visit, "_visit"), __name(_visit, "_visit"), _visit(tree);
  }
  visitTree(visitTree, "R");
  __name(visitTree, "visitTree");
  function visitTreeConditionally(tree, visitor, direction) {
    function _visit(tree) {
      if (direction === "topDown" && !visitor(tree)) return !1;
      let shouldContinue = !0;
      return tree.subs.forEach(subtree => {
        shouldContinue = shouldContinue && _visit(subtree);
      }), direction === "bottomUp" && (shouldContinue = shouldContinue && visitor(tree)), shouldContinue;
    }
    _visit(_visit, "_visit"), __name(_visit, "_visit"), _visit(tree);
  }
  visitTreeConditionally(visitTreeConditionally, "lo");
  __name(visitTreeConditionally, "visitTreeConditionally");
  function foldTree(tree, init, accumulator, direction) {
    let acc = init;
    function visitor(tree) {
      acc = accumulator(tree, acc);
    }
    return visitor(visitor, "visitor"), __name(visitor, "visitor"), visitTree(tree, visitor, direction), acc;
  }
  foldTree(foldTree, "Ve");
  __name(foldTree, "foldTree");
  function rebuildTree(tree, visitor, skip) {
    let rebuild = __name(tree => {
        if (skip !== void 0 && skip(tree)) return tree;
        {
          let newSubs = tree.subs.map(rebuild).filter(sub => sub !== void 0);
          return tree.subs = newSubs, visitor(tree);
        }
      }, "rebuild"),
      rebuilt = rebuild(tree);
    return rebuilt !== void 0 ? rebuilt : topNode();
  }
  rebuildTree(rebuildTree, "Ze");
  __name(rebuildTree, "rebuildTree");
  function parseRaw(source) {
    let rawLines = source.split(`
`),
      indentations = rawLines.map(line => line.match(/^\s*/)[0].length),
      lines = rawLines.map(line => line.trimLeft());
    function parseNode(line) {
      let [subs, nextLine] = parseSubs(line + 1, indentations[line]);
      return [lineNode(indentations[line], line, lines[line], subs), nextLine];
    }
    parseNode(parseNode, "i"), __name(parseNode, "parseNode");
    function parseSubs(initialLine, parentIndentation) {
      let sub,
        subs = [],
        line = initialLine,
        lastBlank;
      for (; line < lines.length && (lines[line] === "" || indentations[line] > parentIndentation);) if (lines[line] === "") lastBlank === void 0 && (lastBlank = line), line += 1;else {
        if (lastBlank !== void 0) {
          for (let i = lastBlank; i < line; i++) subs.push(blankNode(i));
          lastBlank = void 0;
        }
        [sub, line] = parseNode(line), subs.push(sub);
      }
      return lastBlank !== void 0 && (line = lastBlank), [subs, line];
    }
    parseSubs(parseSubs, "parseSubs"), __name(parseSubs, "parseSubs");
    let [subs, parsedLine] = parseSubs(0, -1),
      line = parsedLine;
    for (; line < lines.length && lines[line] === "";) subs.push(blankNode(line)), line += 1;
    if (line < lines.length) throw new Error(`Parsing did not go to end of file. Ended at ${line} out of ${lines.length}`);
    return topNode(subs);
  }
  parseRaw(parseRaw, "sr");
  __name(parseRaw, "parseRaw");
  function labelLines(tree, labelRules) {
    function visitor(tree) {
      if (isLine(tree)) {
        let rule = labelRules.find(rule => rule.matches(tree.sourceLine));
        rule && (tree.label = rule.label);
      }
    }
    visitor(visitor, "visitor"), __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
  }
  labelLines(labelLines, "Ce");
  __name(labelLines, "labelLines");
  function labelVirtualInherited(tree) {
    function visitor(tree) {
      if (isVirtual(tree) && tree.label === void 0) {
        let subs = tree.subs.filter(sub => !isBlank(sub));
        subs.length === 1 && (tree.label = subs[0].label);
      }
    }
    visitor(visitor, "visitor"), __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
  }
  labelVirtualInherited(labelVirtualInherited, "$e");
  __name(labelVirtualInherited, "labelVirtualInherited");
  function buildLabelRules(ruleMap) {
    return Object.keys(ruleMap).map(key => {
      let matches;
      return ruleMap[key].test ? matches = __name(sourceLine => ruleMap[key].test(sourceLine), "matches") : matches = ruleMap[key], {
        matches: matches,
        label: key
      };
    });
  }
  buildLabelRules(buildLabelRules, "Pe");
  __name(buildLabelRules, "buildLabelRules");
  function combineClosersAndOpeners(tree) {
    let returnTree = rebuildTree(tree, __name(function (tree) {
      if (tree.subs.length === 0 || tree.subs.findIndex(sub => sub.label === "closer" || sub.label === "opener") === -1) return tree;
      let newSubs = [],
        lastNew;
      for (let i = 0; i < tree.subs.length; i++) {
        let sub = tree.subs[i],
          directOlderSibling = tree.subs[i - 1];
        if (sub.label === "opener" && directOlderSibling !== void 0 && isLine(directOlderSibling)) directOlderSibling.subs.push(sub), sub.subs.forEach(sub => directOlderSibling.subs.push(sub)), sub.subs = [];else if (sub.label === "closer" && lastNew !== void 0 && (isLine(sub) || isVirtual(sub)) && sub.indentation >= lastNew.indentation) {
          let j = newSubs.length - 1;
          for (; j > 0 && isBlank(newSubs[j]);) j -= 1;
          if (lastNew.subs.push(...newSubs.splice(j + 1)), sub.subs.length > 0) {
            let firstNonVirtual = lastNew.subs.findIndex(sub => sub.label !== "newVirtual"),
              subsToKeep = lastNew.subs.slice(0, firstNonVirtual),
              subsToWrap = lastNew.subs.slice(firstNonVirtual),
              wrappedSubs = subsToWrap.length > 0 ? [virtualNode(sub.indentation, subsToWrap, "newVirtual")] : [];
            lastNew.subs = [...subsToKeep, ...wrappedSubs, sub];
          } else lastNew.subs.push(sub);
        } else newSubs.push(sub), isBlank(sub) || (lastNew = sub);
      }
      return tree.subs = newSubs, tree;
    }, "rebuilder"));
    return clearLabelsIf(tree, arg => arg === "newVirtual"), returnTree;
  }
  combineClosersAndOpeners(combineClosersAndOpeners, "ht");
  __name(combineClosersAndOpeners, "combineClosersAndOpeners");
  function groupBlocks(tree, isDelimiter = isBlank, label) {
    return rebuildTree(tree, __name(function (tree) {
      if (tree.subs.length <= 1) return tree;
      let newSubs = [],
        nodesSinceLastFlush = [],
        currentBlockIndentation,
        lastNodeWasDelimiter = !1;
      function flushBlockIntoNewSubs(final = !1) {
        if (currentBlockIndentation !== void 0 && (newSubs.length > 0 || !final)) {
          let virtual = virtualNode(currentBlockIndentation, nodesSinceLastFlush, label);
          newSubs.push(virtual);
        } else nodesSinceLastFlush.forEach(node => newSubs.push(node));
      }
      flushBlockIntoNewSubs(flushBlockIntoNewSubs, "flushBlockIntoNewSubs"), __name(flushBlockIntoNewSubs, "flushBlockIntoNewSubs");
      for (let i = 0; i < tree.subs.length; i++) {
        let sub = tree.subs[i],
          subIsDelimiter = isDelimiter(sub);
        !subIsDelimiter && lastNodeWasDelimiter && (flushBlockIntoNewSubs(), nodesSinceLastFlush = []), lastNodeWasDelimiter = subIsDelimiter, nodesSinceLastFlush.push(sub), isBlank(sub) || (currentBlockIndentation = currentBlockIndentation ?? sub.indentation);
      }
      return flushBlockIntoNewSubs(!0), tree.subs = newSubs, tree;
    }, "rebuilder"));
  }
  groupBlocks(groupBlocks, "rn");
  __name(groupBlocks, "groupBlocks");
  function flattenVirtual(tree) {
    return rebuildTree(tree, __name(function (tree) {
      return isVirtual(tree) && tree.label === void 0 && tree.subs.length <= 1 ? tree.subs.length === 0 ? void 0 : tree.subs[0] : (tree.subs.length === 1 && isVirtual(tree.subs[0]) && tree.subs[0].label === void 0 && (tree.subs = tree.subs[0].subs), tree);
    }, "rebuilder"));
  }
  flattenVirtual(flattenVirtual, "re");
  __name(flattenVirtual, "flattenVirtual");
  var _genericLabelRules = {
      opener: /^[\[({]/,
      closer: /^[\])}]/
    },
    genericLabelRules = buildLabelRules(_genericLabelRules),
    LANGUAGE_SPECIFIC_PARSERS = {};
  function registerLanguageSpecificParser(language, parser) {
    LANGUAGE_SPECIFIC_PARSERS[language] = parser;
  }
  registerLanguageSpecificParser(registerLanguageSpecificParser, "gt");
  __name(registerLanguageSpecificParser, "registerLanguageSpecificParser");
  function parseTree(source, languageId) {
    let raw = parseRaw(source),
      languageSpecificParser = LANGUAGE_SPECIFIC_PARSERS[languageId ?? ""];
    return languageSpecificParser ? languageSpecificParser(raw) : (labelLines(raw, genericLabelRules), combineClosersAndOpeners(raw));
  }
  parseTree(parseTree, "fe");
  __name(parseTree, "parseTree");
  var _javaLabelRules = {
      package: /^package /,
      import: /^import /,
      class: /\bclass /,
      interface: /\binterface /,
      javadoc: /^\/\*\*/,
      comment_multi: /^\/\*[^*]/,
      comment_single: /^\/\//,
      annotation: /^@/,
      opener: /^[\[({]/,
      closer: /^[\])}]/
    },
    javaLabelRules = buildLabelRules(_javaLabelRules);
  function processJava(originalTree) {
    let tree = originalTree;
    return labelLines(tree, javaLabelRules), tree = combineClosersAndOpeners(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), visitTree(tree, tree => {
      if (tree.label === "class" || tree.label === "interface") for (let sub of tree.subs) !isBlank(sub) && (sub.label === void 0 || sub.label === "annotation") && (sub.label = "member");
    }, "bottomUp"), tree;
  }
  processJava(processJava, "lr");
  __name(processJava, "processJava");
  var _MarkdownLabelRules = {
      heading: /^# /,
      subheading: /^## /,
      subsubheading: /### /
    },
    MarkdownLabelRules = buildLabelRules(_MarkdownLabelRules);
  function processMarkdown(originalTree) {
    let tree = originalTree;
    if (labelLines(tree, MarkdownLabelRules), isBlank(tree)) return tree;
    function headingLevel(sub) {
      if (sub.label === "heading") return 1;
      if (sub.label === "subheading") return 2;
      if (sub.label === "subsubheading") return 3;
    }
    headingLevel(headingLevel, "headingLevel"), __name(headingLevel, "headingLevel");
    let currentHierarchy = [tree],
      oldTreeSubs = [...tree.subs];
    tree.subs = [];
    for (let sub of oldTreeSubs) {
      let level = headingLevel(sub);
      if (level === void 0 || isBlank(sub)) currentHierarchy[currentHierarchy.length - 1].subs.push(sub);else {
        for (; currentHierarchy.length < level;) currentHierarchy.push(currentHierarchy[currentHierarchy.length - 1]);
        for (currentHierarchy[level - 1].subs.push(sub), currentHierarchy[level] = sub; currentHierarchy.length > level + 1;) currentHierarchy.pop();
      }
    }
    return tree = groupBlocks(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), tree;
  }
  processMarkdown(processMarkdown, "ur");
  __name(processMarkdown, "processMarkdown");
  function deparseLine(node) {
    return " ".repeat(node.indentation) + node.sourceLine + `
`;
  }
  deparseLine(deparseLine, "Ge");
  __name(deparseLine, "deparseLine");
  function deparseTree(tree) {
    function accumulator(tree, accum) {
      let str = "";
      return isLine(tree) ? str = deparseLine(tree) : isBlank(tree) && (str = `
`), accum + str;
    }
    return accumulator(accumulator, "accumulator"), __name(accumulator, "accumulator"), foldTree(tree, "", accumulator, "topDown");
  }
  deparseTree(deparseTree, "cr");
  __name(deparseTree, "deparseTree");
  function deparseAndCutTree(tree, cutAt) {
    let cutAtSet = new Set(cutAt),
      cuts = [],
      curUndef = "";
    function visit(tree) {
      tree.label !== void 0 && cutAtSet.has(tree.label) ? (curUndef !== "" && cuts.push({
        label: void 0,
        source: curUndef
      }), cuts.push({
        label: tree.label,
        source: deparseTree(tree)
      }), curUndef = "") : (isLine(tree) && (curUndef += deparseLine(tree)), tree.subs.forEach(visit));
    }
    return visit(visit, "visit"), __name(visit, "visit"), visit(tree), curUndef !== "" && cuts.push({
      label: void 0,
      source: curUndef
    }), cuts;
  }
  deparseAndCutTree(deparseAndCutTree, "ho");
  __name(deparseAndCutTree, "deparseAndCutTree");
  function describeTree(tree, indent = 0) {
    let ind = " ".repeat(indent);
    if (tree === void 0) return "UNDEFINED NODE";
    let children;
    tree.subs === void 0 ? children = "UNDEFINED SUBS" : children = tree.subs.map(child => describeTree(child, indent + 2)).join(`,
`), children === "" ? children = "[]" : children = `[
${children}
      ${ind}]`;
    let prefix = (isVirtual(tree) || isTop(tree) ? "   " : String(tree.lineNumber).padStart(3, " ")) + `:  ${ind}`,
      labelString = tree.label === void 0 ? "" : JSON.stringify(tree.label);
    return isVirtual(tree) || isTop(tree) ? `${prefix}vnode(${tree.indentation}, ${labelString}, ${children})` : isBlank(tree) ? `${prefix}blank(${labelString ?? ""})` : `${prefix}lnode(${tree.indentation}, ${labelString}, ${JSON.stringify(tree.sourceLine)}, ${children})`;
  }
  describeTree(describeTree, "dr");
  __name(describeTree, "describeTree");
  function encodeTree(tree, indent = "") {
    let labelString = tree.label === void 0 ? "" : `, ${JSON.stringify(tree.label)}`,
      subString = !isBlank(tree) && tree.subs.length > 0 ? `[
${tree.subs.map(node => encodeTree(node, indent + "  ")).join(`, 
`)}
${indent}]` : "[]";
    switch (tree.type) {
      case "blank":
        return `${indent}blankNode(${tree.lineNumber}${labelString})`;
      case "top":
        return `topNode(${subString}${labelString})`;
      case "virtual":
        return `${indent}virtualNode(${tree.indentation}, ${subString}${labelString})`;
      case "line":
        return `${indent}lineNode(${tree.indentation}, ${tree.lineNumber}, "${tree.sourceLine}", ${subString}${labelString})`;
    }
  }
  encodeTree(encodeTree, "_r");
  __name(encodeTree, "encodeTree");
  function firstLineOf(tree) {
    if (isLine(tree) || isBlank(tree)) return tree.lineNumber;
    for (let sub of tree.subs) {
      let firstLine = firstLineOf(sub);
      if (firstLine !== void 0) return firstLine;
    }
  }
  firstLineOf(firstLineOf, "pr");
  __name(firstLineOf, "firstLineOf");
  function lastLineOf(tree) {
    let lastLine,
      i = tree.subs.length - 1;
    for (; i >= 0 && lastLine === void 0;) lastLine = lastLineOf(tree.subs[i]), i--;
    return lastLine === void 0 && !isVirtual(tree) && !isTop(tree) ? tree.lineNumber : lastLine;
  }
  lastLineOf(lastLineOf, "fr");
  __name(lastLineOf, "lastLineOf");
  registerLanguageSpecificParser("markdown", processMarkdown);
  registerLanguageSpecificParser("java", processJava);
  var DEFAULT_TREE_TRAVERSAL_CONFIG = {
    worthUp: .9,
    worthSibling: .88,
    worthDown: .8
  };
  function fromTreeWithFocussedLines(tree, config = DEFAULT_TREE_TRAVERSAL_CONFIG) {
    let treeWithDistances = mapLabels(tree, x => x ? 1 : void 0);
    return visitTree(treeWithDistances, node => {
      if (isBlank(node)) return;
      let maxChildLabel = Math.max(...node.subs.map(child => child.label ?? 0));
      node.label = Math.max(node.label ?? 0, maxChildLabel * config.worthUp);
    }, "bottomUp"), visitTree(treeWithDistances, node => {
      if (isBlank(node)) return;
      let values = node.subs.map(sub => sub.label ?? 0),
        new_values = [...values];
      for (let i = 0; i < values.length; i++) values[i] !== 0 && (new_values = new_values.map((v, j) => Math.max(v, Math.pow(config.worthSibling, Math.abs(i - j)) * values[i])));
      let nodeLabel = node.label;
      nodeLabel !== void 0 && (new_values = new_values.map(v => Math.max(v, config.worthDown * nodeLabel))), node.subs.forEach((sub, i) => sub.label = new_values[i]);
    }, "topDown"), fromTreeWithValuedLines(treeWithDistances);
  }
  fromTreeWithFocussedLines(fromTreeWithFocussedLines, "ke");
  __name(fromTreeWithFocussedLines, "fromTreeWithFocussedLines");
  function fromTreeWithValuedLines(tree) {
    let valuedLines = foldTree(tree, [], (node, acc) => ((node.type === "line" || node.type === "blank") && acc.push(node.type === "line" ? [deparseLine(node).trimEnd(), node.label ?? 0] : ["", node.label ?? 0]), acc), "topDown");
    return new ElidableText(...valuedLines);
  }
  fromTreeWithValuedLines(fromTreeWithValuedLines, "hr");
  __name(fromTreeWithValuedLines, "fromTreeWithValuedLines");
  function elidableTextForSourceCode(contents, focusOnLastLeaf = !0, focusOnFirstLine = !0) {
    let tree = typeof contents == "string" ? parseTree(contents) : parseTree(contents.source, contents.languageId);
    flattenVirtual(tree);
    let treeWithFocussedLines = mapLabels(tree, label => focusOnLastLeaf && label !== "closer");
    return visitTree(treeWithFocussedLines, node => {
      node.label === void 0 && (node.label = focusOnLastLeaf && node.label !== !1);
    }, "topDown"), focusOnLastLeaf && visitTree(treeWithFocussedLines, node => {
      if (node.label) {
        let foundLastTrue = !1;
        for (let subnode of [...node.subs].reverse()) subnode.label && !foundLastTrue ? foundLastTrue = !0 : subnode.label = !1;
      } else for (let subnode of node.subs) subnode.label = !1;
      node.subs.length > 0 && (node.label = !1);
    }, "topDown"), focusOnFirstLine && visitTree(treeWithFocussedLines, node => {
      node.label ||= (isLine(node) || isBlank(node)) && node.lineNumber == 0;
    }, "topDown"), fromTreeWithFocussedLines(treeWithFocussedLines);
  }
  elidableTextForSourceCode(elidableTextForSourceCode, "on");
  __name(elidableTextForSourceCode, "elidableTextForSourceCode");
  var LineWithValueAndCost = class _LineWithValueAndCost {
      static {
        __name(this, "n");
      }
      constructor(text, _value, _cost = getTokenizer().tokenLength(text + `
`), validate = "strict") {
        if (this.text = text, this._value = _value, this._cost = _cost, text.includes(`
`) && validate !== "none") throw new Error("LineWithValueAndCost: text contains newline");
        if (_value < 0 && validate !== "none") throw new Error("LineWithValueAndCost: value is negative");
        if (_cost < 0 && validate !== "none") throw new Error("LineWithValueAndCost: cost is negative");
        if (validate == "strict" && _value > 1) throw new Error("Value should normally be between 0 and 1 -- set validation to `loose` to ignore this error");
      }
      static {
        __name(this, "LineWithValueAndCost");
      }
      get value() {
        return this._value;
      }
      get cost() {
        return this._cost;
      }
      adjustValue(multiplier) {
        return this._value *= multiplier, this;
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        return this._cost = coster(this.text), this;
      }
      copy() {
        return new _LineWithValueAndCost(this.text, this.value, this.cost, "none");
      }
    },
    ElidableText = class _ElidableText {
      static {
        __name(this, "n");
      }
      constructor(...chunks) {
        this.lines = [];
        let lines = [];
        for (let chunk of chunks) {
          let value = Array.isArray(chunk) ? chunk[1] : 1,
            input = Array.isArray(chunk) ? chunk[0] : chunk;
          typeof input == "string" ? input.split(`
`).forEach(line => lines.push(new LineWithValueAndCost(line, value))) : input instanceof _ElidableText ? lines.push(...input.lines.map(line => line.copy().adjustValue(value))) : "source" in input && "languageId" in input && lines.push(...elidableTextForSourceCode(input).lines.map(line => line.copy().adjustValue(value)));
        }
        this.lines = lines;
      }
      static {
        __name(this, "ElidableText");
      }
      adjust(multiplier) {
        this.lines.forEach(line => line.adjustValue(multiplier));
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        this.lines.forEach(line => line.recost(coster));
      }
      makePrompt(maxTokens, ellipsis = "[...]", indentEllipses = !0, strategy = "removeLeastDesirable", tokenizer = getTokenizer()) {
        let lines = this.lines.map(line => line.copy());
        return makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer);
      }
    };
  function makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer) {
    if (tokenizer.tokenLength(ellipsis + `
`) > maxTokens) throw new Error("maxTokens must be larger than the ellipsis length");
    strategy === "removeLeastBangForBuck" && lines.forEach(line => line.adjustValue(1 / line.cost));
    let infiniteWorth = lines.reduce((a, b) => Math.max(a, b.value), 0) + 1,
      infiniteIndentation = lines.reduce((a, b) => Math.max(a, b.text.length), 0) + 1,
      trimmedEllipsis = ellipsis.trim(),
      totalCost = lines.reduce((sum, line) => sum + line.cost, 0),
      defensiveCounter = lines.length + 1;
    for (; totalCost > maxTokens && defensiveCounter-- >= -1;) {
      let leastDesirable = lines.reduce((least, line) => line.value < least.value ? line : least),
        index = lines.indexOf(leastDesirable),
        mostRecentNonBlankLine = lines.slice(0, index + 1).reverse().find(line => line.text.trim() !== "") ?? {
          text: ""
        },
        indentation = indentEllipses ? Math.min(mostRecentNonBlankLine.text.match(/^\s*/)?.[0].length ?? 0, lines[index - 1]?.text.trim() === trimmedEllipsis ? lines[index - 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation, lines[index + 1]?.text.trim() === trimmedEllipsis ? lines[index + 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation) : 0,
        insert = " ".repeat(indentation) + ellipsis,
        newEllipis = new LineWithValueAndCost(insert, infiniteWorth, tokenizer.tokenLength(insert + `
`), "loose");
      lines.splice(index, 1, newEllipis), lines[index + 1]?.text.trim() === trimmedEllipsis && lines.splice(index + 1, 1), lines[index - 1]?.text.trim() === trimmedEllipsis && lines.splice(index - 1, 1);
      let newTotalCost = lines.reduce((sum, line) => sum + line.cost, 0);
      newTotalCost >= totalCost && lines.every(line => line.value === infiniteWorth) && (indentEllipses = !1), totalCost = newTotalCost;
    }
    if (defensiveCounter < 0) throw new Error("Infinite loop in ElidableText.makePrompt: Defensive counter < 0 in ElidableText.makePrompt with end text");
    return lines.map(line => line.text).join(`
`);
  }
  makePrompt(makePrompt, "go");
  __name(makePrompt, "makePrompt");
  function Diff() {}
  Diff(Diff, "ue");
  __name(Diff, "Diff");
  Diff.prototype = {
    diff: __name(function (oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        callback = options.callback;
      typeof options == "function" && (callback = options, options = {}), this.options = options;
      var self = this;
      function done(value) {
        return callback ? (setTimeout(function () {
          callback(void 0, value);
        }, 0), !0) : value;
      }
      done(done, "s"), __name(done, "done"), oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString)), newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
        oldLen = oldString.length,
        editLength = 1,
        maxEditLength = newLen + oldLen;
      options.maxEditLength && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
      var bestPath = [{
          newPos: -1,
          components: []
        }],
        oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) return done([{
        value: this.join(newString),
        count: newString.length
      }]);
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0,
            addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
          addPath && (bestPath[diagonalPath - 1] = void 0);
          var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
          if (!canAdd && !canRemove) {
            bestPath[diagonalPath] = void 0;
            continue;
          }
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), self.pushComponent(basePath.components, void 0, !0)) : (basePath = addPath, basePath.newPos++, self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          bestPath[diagonalPath] = basePath;
        }
        editLength++;
      }
      if (execEditLength(execEditLength, "m"), __name(execEditLength, "execEditLength"), callback) __name(__name(function exec() {
        setTimeout(function () {
          if (editLength > maxEditLength) return callback();
          execEditLength() || exec();
        }, 0);
      }, "f"), "exec")();else for (; editLength <= maxEditLength;) {
        var ret = execEditLength();
        if (ret) return ret;
      }
    }, "diff"),
    pushComponent: __name(function (components, added, removed) {
      var last = components[components.length - 1];
      last && last.added === added && last.removed === removed ? components[components.length - 1] = {
        count: last.count + 1,
        added: added,
        removed: removed
      } : components.push({
        count: 1,
        added: added,
        removed: removed
      });
    }, "pushComponent"),
    extractCommon: __name(function (basePath, newString, oldString, diagonalPath) {
      for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1]);) newPos++, oldPos++, commonCount++;
      return commonCount && basePath.components.push({
        count: commonCount
      }), basePath.newPos = newPos, oldPos;
    }, "extractCommon"),
    equals: __name(function (left, right) {
      return this.options.comparator ? this.options.comparator(left, right) : left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }, "equals"),
    removeEmpty: __name(function (array) {
      for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
      return ret;
    }, "removeEmpty"),
    castInput: __name(function (value) {
      return value;
    }, "castInput"),
    tokenize: __name(function (value) {
      return value.split("");
    }, "tokenize"),
    join: __name(function (chars) {
      return chars.join("");
    }, "join")
  };
  function buildValues(diff, components, newString, oldString, useLongestToken) {
    for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];
      if (component.removed) {
        if (component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), oldPos += component.count, componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos], components[componentPos] = tmp;
        }
      } else {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          }), component.value = diff.join(value);
        } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
        newPos += component.count, component.added || (oldPos += component.count);
      }
    }
    var lastComponent = components[componentLen - 1];
    return componentLen > 1 && typeof lastComponent.value == "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, components.pop()), components;
  }
  buildValues(buildValues, "bo");
  __name(buildValues, "buildValues");
  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }
  clonePath(clonePath, "yo");
  __name(clonePath, "clonePath");
  var characterDiff = new Diff(),
    extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,
    reWhitespace = /\S/,
    wordDiff = new Diff();
  wordDiff.equals = function (left, right) {
    return this.options.ignoreCase && (left = left.toLowerCase(), right = right.toLowerCase()), left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };
  wordDiff.tokenize = function (value) {
    for (var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), i = 0; i < tokens.length - 1; i++) !tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2]) && (tokens[i] += tokens[i + 2], tokens.splice(i + 1, 2), i--);
    return tokens;
  };
  var lineDiff = new Diff();
  lineDiff.tokenize = function (value) {
    var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/);
    linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];
      i % 2 && !this.options.newlineIsToken ? retLines[retLines.length - 1] += line : (this.options.ignoreWhitespace && (line = line.trim()), retLines.push(line));
    }
    return retLines;
  };
  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }
  diffLines(diffLines, "wo");
  __name(diffLines, "diffLines");
  var sentenceDiff = new Diff();
  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };
  var cssDiff = new Diff();
  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = __name(function (obj) {
      return typeof obj;
    }, "_typeof") : _typeof = __name(function (obj) {
      return obj && typeof Symbol == "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, "_typeof"), _typeof(obj);
  }
  _typeof(_typeof, "bt");
  __name(_typeof, "_typeof");
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  _toConsumableArray(_toConsumableArray, "sn");
  __name(_toConsumableArray, "_toConsumableArray");
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  _arrayWithoutHoles(_arrayWithoutHoles, "Eo");
  __name(_arrayWithoutHoles, "_arrayWithoutHoles");
  function _iterableToArray(iter) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  _iterableToArray(_iterableToArray, "xo");
  __name(_iterableToArray, "_iterableToArray");
  function _unsupportedIterableToArray(o, minLen) {
    if (o) {
      if (typeof o == "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
  }
  _unsupportedIterableToArray(_unsupportedIterableToArray, "Mo");
  __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
  function _arrayLikeToArray(arr, len) {
    (len == null || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  _arrayLikeToArray(_arrayLikeToArray, "an");
  __name(_arrayLikeToArray, "_arrayLikeToArray");
  function _nonIterableSpread() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  _nonIterableSpread(_nonIterableSpread, "Io");
  __name(_nonIterableSpread, "_nonIterableSpread");
  var objectPrototypeToString = Object.prototype.toString,
    jsonDiff = new Diff();
  jsonDiff.useLongestToken = !0;
  jsonDiff.tokenize = lineDiff.tokenize;
  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
      undefinedReplacement = _this$options.undefinedReplacement,
      _this$options$stringi = _this$options.stringifyReplacer,
      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
        return typeof v > "u" ? undefinedReplacement : v;
      } : _this$options$stringi;
    return typeof value == "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
  };
  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
  };
  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [], replacementStack = replacementStack || [], replacer && (obj = replacer(key, obj));
    var i;
    for (i = 0; i < stack.length; i += 1) if (stack[i] === obj) return replacementStack[i];
    var canonicalizedObj;
    if (objectPrototypeToString.call(obj) === "[object Array]") {
      for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      return stack.pop(), replacementStack.pop(), canonicalizedObj;
    }
    if (obj && obj.toJSON && (obj = obj.toJSON()), _typeof(obj) === "object" && obj !== null) {
      stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
      var sortedKeys = [],
        _key;
      for (_key in obj) obj.hasOwnProperty(_key) && sortedKeys.push(_key);
      for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) _key = sortedKeys[i], canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      stack.pop(), replacementStack.pop();
    } else canonicalizedObj = obj;
    return canonicalizedObj;
  }
  canonicalize(canonicalize, "ln");
  __name(canonicalize, "canonicalize");
  var arrayDiff = new Diff();
  arrayDiff.tokenize = function (value) {
    return value.slice();
  };
  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };
  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    options || (options = {}), typeof options.context > "u" && (options.context = 4);
    var diff = diffLines(oldStr, newStr, options);
    if (!diff) return;
    diff.push({
      value: "",
      lines: []
    });
    function contextLines(lines) {
      return lines.map(function (entry) {
        return " " + entry;
      });
    }
    contextLines(contextLines, "u"), __name(contextLines, "contextLines");
    for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = __name(function (i) {
        var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, "").split(`
`);
        if (current.lines = lines, current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i - 1];
            oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
          }
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
            return (current.added ? "+" : "-") + entry;
          }))), current.added ? newLine += lines.length : oldLine += lines.length;
        } else {
          if (oldRangeStart) if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2;
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3,
              contextSize = Math.min(lines.length, options.context);
            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            if (i >= diff.length - 2 && lines.length <= options.context) {
              var oldEOFNewline = /\n$/.test(oldStr),
                newEOFNewline = /\n$/.test(newStr),
                noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
              !oldEOFNewline && noNlBeforeAdds && oldStr.length > 0 && curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file"), (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) && curRange.push("\\ No newline at end of file");
            }
            hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
          }
          oldLine += lines.length, newLine += lines.length;
        }
      }, "_loop"), i = 0; i < diff.length; i++) _loop(i);
    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }
  structuredPatch(structuredPatch, "wr");
  __name(structuredPatch, "structuredPatch");
  function elidableTextForDiff(oldContent, newContent) {
    let languageId = typeof oldContent == "string" ? typeof newContent == "string" ? void 0 : newContent.languageId : typeof newContent == "string" || oldContent.languageId === newContent.languageId ? oldContent.languageId : void 0;
    oldContent = typeof oldContent == "string" ? oldContent : oldContent.source, newContent = typeof newContent == "string" ? newContent : newContent.source;
    let patch = structuredPatch("", "", oldContent, newContent),
      changedLinesOld = new Set(),
      changedLinesNew = new Set();
    for (let hunk of patch.hunks) {
      for (let i = hunk.oldStart; i < hunk.oldStart + hunk.oldLines; i++) changedLinesOld.add(i);
      for (let i = hunk.newStart; i < hunk.newStart + hunk.newLines; i++) changedLinesNew.add(i);
    }
    let oldTree = mapLabels(flattenVirtual(parseTree(oldContent, languageId)), () => !1),
      newTree = mapLabels(flattenVirtual(parseTree(newContent, languageId)), () => !1);
    return visitTree(oldTree, node => {
      (node.type === "line" || node.type === "blank") && changedLinesOld.has(node.lineNumber) && (node.label = !0);
    }, "topDown"), visitTree(newTree, node => {
      (node.type === "line" || node.type === "blank") && changedLinesNew.has(node.lineNumber) && (node.label = !0);
    }, "topDown"), [fromTreeWithFocussedLines(oldTree), fromTreeWithFocussedLines(newTree)];
  }
  elidableTextForDiff(elidableTextForDiff, "No");
  __name(elidableTextForDiff, "elidableTextForDiff");
  var import_fs = require("fs"),
    FileSystem = class {
      static {
        __name(this, "yt");
      }
      static {
        __name(this, "FileSystem");
      }
    },
    defaultFileSystem = {
      readFile(uri) {
        return dn.fsp.readFile(uri);
      },
      async stat(uri) {
        let stat = await dn.fsp.stat(uri);
        return {
          ctime: stat.ctimeMs,
          mtime: stat.mtimeMs,
          size: stat.size
        };
      }
    },
    languageCommentMarkers = {
      abap: {
        start: '"',
        end: ""
      },
      bat: {
        start: "REM",
        end: ""
      },
      bibtex: {
        start: "%",
        end: ""
      },
      blade: {
        start: "#",
        end: ""
      },
      c: {
        start: "//",
        end: ""
      },
      clojure: {
        start: ";",
        end: ""
      },
      coffeescript: {
        start: "//",
        end: ""
      },
      cpp: {
        start: "//",
        end: ""
      },
      csharp: {
        start: "//",
        end: ""
      },
      css: {
        start: "/*",
        end: "*/"
      },
      dart: {
        start: "//",
        end: ""
      },
      dockerfile: {
        start: "#",
        end: ""
      },
      elixir: {
        start: "#",
        end: ""
      },
      erb: {
        start: "<%#",
        end: "%>"
      },
      erlang: {
        start: "%",
        end: ""
      },
      fsharp: {
        start: "//",
        end: ""
      },
      go: {
        start: "//",
        end: ""
      },
      groovy: {
        start: "//",
        end: ""
      },
      haml: {
        start: "-#",
        end: ""
      },
      handlebars: {
        start: "{{!",
        end: "}}"
      },
      haskell: {
        start: "--",
        end: ""
      },
      html: {
        start: "<!--",
        end: "-->"
      },
      ini: {
        start: ";",
        end: ""
      },
      java: {
        start: "//",
        end: ""
      },
      javascript: {
        start: "//",
        end: ""
      },
      javascriptreact: {
        start: "//",
        end: ""
      },
      jsonc: {
        start: "//",
        end: ""
      },
      jsx: {
        start: "//",
        end: ""
      },
      julia: {
        start: "#",
        end: ""
      },
      kotlin: {
        start: "//",
        end: ""
      },
      latex: {
        start: "%",
        end: ""
      },
      less: {
        start: "//",
        end: ""
      },
      lua: {
        start: "--",
        end: ""
      },
      makefile: {
        start: "#",
        end: ""
      },
      markdown: {
        start: "[]: #",
        end: ""
      },
      "objective-c": {
        start: "//",
        end: ""
      },
      "objective-cpp": {
        start: "//",
        end: ""
      },
      perl: {
        start: "#",
        end: ""
      },
      php: {
        start: "//",
        end: ""
      },
      powershell: {
        start: "#",
        end: ""
      },
      pug: {
        start: "//",
        end: ""
      },
      python: {
        start: "#",
        end: ""
      },
      ql: {
        start: "//",
        end: ""
      },
      r: {
        start: "#",
        end: ""
      },
      razor: {
        start: "<!--",
        end: "-->"
      },
      ruby: {
        start: "#",
        end: ""
      },
      rust: {
        start: "//",
        end: ""
      },
      sass: {
        start: "//",
        end: ""
      },
      scala: {
        start: "//",
        end: ""
      },
      scss: {
        start: "//",
        end: ""
      },
      shellscript: {
        start: "#",
        end: ""
      },
      slim: {
        start: "/",
        end: ""
      },
      solidity: {
        start: "//",
        end: ""
      },
      sql: {
        start: "--",
        end: ""
      },
      stylus: {
        start: "//",
        end: ""
      },
      svelte: {
        start: "<!--",
        end: "-->"
      },
      swift: {
        start: "//",
        end: ""
      },
      terraform: {
        start: "#",
        end: ""
      },
      tex: {
        start: "%",
        end: ""
      },
      typescript: {
        start: "//",
        end: ""
      },
      typescriptreact: {
        start: "//",
        end: ""
      },
      vb: {
        start: "'",
        end: ""
      },
      verilog: {
        start: "//",
        end: ""
      },
      "vue-html": {
        start: "<!--",
        end: "-->"
      },
      vue: {
        start: "//",
        end: ""
      },
      xml: {
        start: "<!--",
        end: "-->"
      },
      xsl: {
        start: "<!--",
        end: "-->"
      },
      yaml: {
        start: "#",
        end: ""
      }
    },
    dontAddLanguageMarker = ["php", "plaintext"],
    shebangLines = {
      html: "<!DOCTYPE html>",
      python: "#!/usr/bin/env python3",
      ruby: "#!/usr/bin/env ruby",
      shellscript: "#!/bin/sh",
      yaml: "# YAML data"
    };
  function hasLanguageMarker({
    source: source
  }) {
    return source.startsWith("#!") || source.startsWith("<!DOCTYPE");
  }
  hasLanguageMarker(hasLanguageMarker, "Po");
  __name(hasLanguageMarker, "hasLanguageMarker");
  function comment(text, languageId) {
    let markers = languageCommentMarkers[languageId];
    if (markers) {
      let end = markers.end == "" ? "" : " " + markers.end;
      return `${markers.start} ${text}${end}`;
    }
    return "";
  }
  comment(comment, "Qe");
  __name(comment, "comment");
  function commentBlockAsSingles(text, languageId) {
    if (!languageCommentMarkers[languageId] || text === "") return "";
    let trailingNewline = text.endsWith(`
`),
      commented = (trailingNewline ? text.slice(0, -1) : text).split(`
`).map(line => comment(line, languageId)).join(`
`);
    return trailingNewline ? commented + `
` : commented;
  }
  commentBlockAsSingles(commentBlockAsSingles, "St");
  __name(commentBlockAsSingles, "commentBlockAsSingles");
  function getLanguageMarker(doc) {
    let {
      languageId: languageId
    } = doc;
    return dontAddLanguageMarker.indexOf(languageId) === -1 && !hasLanguageMarker(doc) ? languageId in shebangLines ? shebangLines[languageId] : comment(`Language: ${languageId}`, languageId) : "";
  }
  getLanguageMarker(getLanguageMarker, "Er");
  __name(getLanguageMarker, "getLanguageMarker");
  function getPathMarker(doc) {
    return doc.relativePath ? comment(`Path: ${doc.relativePath}`, doc.languageId) : "";
  }
  getPathMarker(getPathMarker, "xr");
  __name(getPathMarker, "getPathMarker");
  function newLineEnded(str) {
    return str === "" || str.endsWith(`
`) ? str : str + `
`;
  }
  newLineEnded(newLineEnded, "me");
  __name(newLineEnded, "newLineEnded");
  var import_path = require("path"),
    import_web_tree_sitter = ct(Mr()),
    WASMLanguage = (WASMLanguage => (WASMLanguage.Python = "python", WASMLanguage.JavaScript = "javascript", WASMLanguage.TypeScript = "typescript", WASMLanguage.TSX = "tsx", WASMLanguage.Go = "go", WASMLanguage.Ruby = "ruby", WASMLanguage))(WASMLanguage || {}),
    languageIdToWasmLanguageMapping = {
      python: "python",
      javascript: "javascript",
      javascriptreact: "javascript",
      jsx: "javascript",
      typescript: "typescript",
      typescriptreact: "tsx",
      go: "go",
      ruby: "ruby"
    };
  function isSupportedLanguageId(languageId) {
    return languageId in languageIdToWasmLanguageMapping;
  }
  isSupportedLanguageId(isSupportedLanguageId, "ce");
  __name(isSupportedLanguageId, "isSupportedLanguageId");
  function languageIdToWasmLanguage(languageId) {
    if (!(languageId in languageIdToWasmLanguageMapping)) throw new Error(`Unrecognized language: ${languageId}`);
    return languageIdToWasmLanguageMapping[languageId];
  }
  languageIdToWasmLanguage(languageIdToWasmLanguage, "$");
  __name(languageIdToWasmLanguage, "languageIdToWasmLanguage");
  var jsFunctionQuery = `[
    (function body: (statement_block) @body)
    (function_declaration body: (statement_block) @body)
    (generator_function body: (statement_block) @body)
    (generator_function_declaration body: (statement_block) @body)
    (method_definition body: (statement_block) @body)
    (arrow_function body: (statement_block) @body)
  ] @function`,
    functionQuery = {
      python: [[`(function_definition body: (block
             (expression_statement (string))? @docstring) @body) @function`], ['(ERROR ("def" (identifier) (parameters))) @function']],
      javascript: [[jsFunctionQuery]],
      typescript: [[jsFunctionQuery]],
      tsx: [[jsFunctionQuery]],
      go: [[`[
            (function_declaration body: (block) @body)
            (method_declaration body: (block) @body)
          ] @function`]],
      ruby: [[`[
            (method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
          ] @function`]]
    },
    requireCall = '(call_expression function: ((identifier) @req (#eq? @req "require")))',
    declaratorWithRequire = `(variable_declarator value: ${requireCall})`,
    commonJsImport = `
    (lexical_declaration ${declaratorWithRequire}+)
    (variable_declaration ${declaratorWithRequire}+)
`,
    tsImportQueries = [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) (import_alias) ] @import)"]],
    importsQuery = {
      python: [["(module (future_import_statement) @import)"], ["(module (import_statement) @import)"], ["(module (import_from_statement) @import)"]],
      javascript: [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) ] @import)"]],
      typescript: tsImportQueries,
      tsx: tsImportQueries,
      go: [],
      ruby: []
    },
    jsExportQueries = [["(program (export_statement) @export)"]],
    exportsQuery = {
      python: [],
      javascript: jsExportQueries,
      typescript: jsExportQueries,
      tsx: jsExportQueries,
      go: [],
      ruby: []
    },
    globalVarsQuery = {
      python: [["(module (global_statement) @globalVar)"], ["(module (expression_statement) @globalVar)"]],
      javascript: [],
      typescript: [],
      tsx: [],
      go: [],
      ruby: []
    },
    jsFunctionTypes = ["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"],
    functionTypes = {
      python: new Set(["function_definition"]),
      javascript: new Set(jsFunctionTypes),
      typescript: new Set(jsFunctionTypes),
      tsx: new Set(jsFunctionTypes),
      go: new Set(["function_declaration", "method_declaration"]),
      ruby: new Set(["method", "singleton_method"])
    },
    isFunctionParent = {
      python: nd => nd.type === "module" || nd.type === "block" && nd.parent?.type === "class_definition",
      javascript: nd => nd.type === "program" || nd.type === "class_body",
      typescript: nd => nd.type === "program" || nd.type === "class_body",
      tsx: nd => nd.type === "program" || nd.type === "class_body",
      go: nd => nd.type === "source_file",
      ruby: nd => nd.type === "program" || nd.type === "class"
    },
    loadedLanguages = new Map();
  async function loadWasmLanguage(language) {
    await Et.Parser.init();
    let wasmFile = (0, Nr.resolve)(__dirname, "..", "dist", `tree-sitter-${language}.wasm`);
    try {
      return Et.Parser.Language.load(wasmFile);
    } catch (e) {
      if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code == "EPERM") && e instanceof Error) {
        let error = new Error(`Could not load tree-sitter-${language}.wasm`);
        throw error.code = "CopilotPromptLoadFailure", error;
      }
      throw e;
    }
  }
  loadWasmLanguage(loadWasmLanguage, "Wo");
  __name(loadWasmLanguage, "loadWasmLanguage");
  async function getLanguage(language) {
    let wasmLanguage = languageIdToWasmLanguage(language);
    if (!loadedLanguages.has(wasmLanguage)) {
      let loadedLang = await loadWasmLanguage(wasmLanguage);
      loadedLanguages.set(wasmLanguage, loadedLang);
    }
    return loadedLanguages.get(wasmLanguage);
  }
  getLanguage(getLanguage, "kr");
  __name(getLanguage, "getLanguage");
  async function parseTreeSitter(language, source) {
    let treeSitterLanguage = await getLanguage(language),
      parser = new Et.Parser();
    parser.setLanguage(treeSitterLanguage);
    let parsedTree = parser.parse(source);
    return parser.delete(), parsedTree;
  }
  parseTreeSitter(parseTreeSitter, "G");
  __name(parseTreeSitter, "parseTreeSitter");
  async function parsesWithoutError(language, source) {
    let tree = await parseTreeSitter(language, source),
      result = !tree.rootNode.hasError();
    return tree.delete(), result;
  }
  parsesWithoutError(parsesWithoutError, "Uo");
  __name(parsesWithoutError, "parsesWithoutError");
  function getBlockCloseToken(language) {
    switch (languageIdToWasmLanguage(language)) {
      case "python":
        return null;
      case "javascript":
      case "typescript":
      case "tsx":
      case "go":
        return "}";
      case "ruby":
        return "end";
    }
  }
  getBlockCloseToken(getBlockCloseToken, "zo");
  __name(getBlockCloseToken, "getBlockCloseToken");
  function innerQuery(queries, root) {
    let matches = [];
    for (let query of queries) {
      if (!query[1]) {
        let lang = root.tree.getLanguage();
        query[1] = lang.query(query[0]);
      }
      matches.push(...query[1].matches(root));
    }
    return matches;
  }
  innerQuery(innerQuery, "Fe");
  __name(innerQuery, "innerQuery");
  function queryFunctions(language, root) {
    let queries = functionQuery[languageIdToWasmLanguage(language)];
    return innerQuery(queries, root);
  }
  queryFunctions(queryFunctions, "Ar");
  __name(queryFunctions, "queryFunctions");
  function queryImports(language, root) {
    let queries = importsQuery[languageIdToWasmLanguage(language)];
    return innerQuery(queries, root);
  }
  queryImports(queryImports, "qo");
  __name(queryImports, "queryImports");
  function queryExports(language, root) {
    let queries = exportsQuery[languageIdToWasmLanguage(language)];
    return innerQuery(queries, root);
  }
  queryExports(queryExports, "hn");
  __name(queryExports, "queryExports");
  function queryGlobalVars(language, root) {
    let queries = globalVarsQuery[languageIdToWasmLanguage(language)];
    return innerQuery(queries, root);
  }
  queryGlobalVars(queryGlobalVars, "jo");
  __name(queryGlobalVars, "queryGlobalVars");
  var docstringQuery = [`[
    (class_definition (block (expression_statement (string))))
    (function_definition (block (expression_statement (string))))
]`];
  function queryPythonIsDocstring(blockNode) {
    return innerQuery([docstringQuery], blockNode).length == 1;
  }
  queryPythonIsDocstring(queryPythonIsDocstring, "gn");
  __name(queryPythonIsDocstring, "queryPythonIsDocstring");
  function getAncestorWithSiblingFunctions(language, nd) {
    let check = isFunctionParent[languageIdToWasmLanguage(language)];
    for (; nd.parent;) {
      if (check(nd.parent)) return nd;
      nd = nd.parent;
    }
    return nd.parent ? nd : null;
  }
  getAncestorWithSiblingFunctions(getAncestorWithSiblingFunctions, "bn");
  __name(getAncestorWithSiblingFunctions, "getAncestorWithSiblingFunctions");
  function isFunction(language, nd) {
    return functionTypes[languageIdToWasmLanguage(language)].has(nd.type);
  }
  isFunction(isFunction, "vt");
  __name(isFunction, "isFunction");
  function isFunctionDefinition(language, nd) {
    switch (languageIdToWasmLanguage(language)) {
      case "python":
      case "go":
      case "ruby":
        return isFunction(language, nd);
      case "javascript":
      case "typescript":
      case "tsx":
        if (nd.type === "function_declaration" || nd.type === "generator_function_declaration" || nd.type === "method_definition") return !0;
        if (nd.type === "lexical_declaration" || nd.type === "variable_declaration") {
          if (nd.namedChildCount > 1) return !1;
          let declarator = nd.namedChild(0);
          if (declarator == null) return !1;
          let init = declarator.namedChild(1);
          return init !== null && isFunction(language, init);
        }
        if (nd.type === "expression_statement") {
          let expr = nd.namedChild(0);
          if (expr?.type === "assignment_expression") {
            let rhs = expr.namedChild(1);
            return rhs !== null && isFunction(language, rhs);
          }
        }
        return !1;
    }
  }
  isFunctionDefinition(isFunctionDefinition, "yn");
  __name(isFunctionDefinition, "isFunctionDefinition");
  function getFirstPrecedingComment(nd) {
    let cur = nd;
    for (; cur.previousSibling?.type === "comment";) {
      let prev = cur.previousSibling;
      if (prev.endPosition.row < cur.startPosition.row - 1) break;
      cur = prev;
    }
    return cur?.type === "comment" ? cur : null;
  }
  getFirstPrecedingComment(getFirstPrecedingComment, "Oe");
  __name(getFirstPrecedingComment, "getFirstPrecedingComment");
  async function getFunctionPositions(language, source) {
    let tree = await parseTreeSitter(language, source),
      positions = queryFunctions(language, tree.rootNode).map(res => {
        let fn = res.captures.find(c => c.name === "function").node;
        return {
          startIndex: fn.startIndex,
          endIndex: fn.endIndex
        };
      });
    return tree.delete(), positions;
  }
  getFunctionPositions(getFunctionPositions, "wn");
  __name(getFunctionPositions, "getFunctionPositions");
  var callSiteQuery = {
    python: [[`(call
            function:  [
                (identifier) @caller
                (attribute attribute:(identifier) @caller)
            ]
            arguments: (argument_list) @args
        )`]],
    javascript: [],
    tsx: [],
    typescript: [],
    go: [],
    ruby: []
  };
  async function getCallSites(docInfo) {
    if (!(docInfo.languageId in callSiteQuery)) return [];
    let offset = docInfo.offset,
      source = docInfo.source.substring(0, offset),
      pretruncateOffset = Math.max(source.length - 5e3, 0),
      linesBeforeTruncation = source.substring(0, pretruncateOffset).split(`
`).length - 1;
    offset -= pretruncateOffset, source = source.substring(pretruncateOffset), source = source + ")))))";
    let callers = [],
      tree = await parseTreeSitter(docInfo.languageId, source),
      queries = callSiteQuery[languageIdToWasmLanguageMapping[docInfo.languageId]];
    return innerQuery(queries, tree.rootNode).forEach((res, resIndex) => {
      let callerName = "",
        callerLineNo = 0,
        callerStartChar = 0,
        argsStartIndex = 0,
        argsEndIndex = 0;
      if (res.captures.forEach((cap, capIndex) => {
        let node = cap.node;
        cap.name == "caller" ? (callerName = source.substring(node.startIndex, node.endIndex), callerLineNo = node.startPosition.row + linesBeforeTruncation, callerStartChar = node.startPosition.column) : cap.name == "args" && (argsStartIndex = node.startIndex, argsEndIndex = node.endIndex);
      }), offset >= argsStartIndex && offset <= argsEndIndex) {
        let callerLineCol = {
          line: callerLineNo,
          character: callerStartChar
        };
        callers.push([callerName, callerLineCol]);
      }
    }), tree.delete(), callers.map(([name, position]) => ({
      name: name,
      position: position
    }));
  }
  getCallSites(getCallSites, "Vo");
  __name(getCallSites, "getCallSites");
  async function getSiblingFunctionStart({
    source: source,
    offset: offset,
    languageId: languageId
  }) {
    if (isSupportedLanguageId(languageId)) {
      let tree = await parseTreeSitter(languageId, source);
      try {
        let startingOffset = offset;
        for (; startingOffset >= 0 && /\s/.test(source[startingOffset]);) startingOffset--;
        let nd = tree.rootNode.descendantForIndex(startingOffset),
          anc = getAncestorWithSiblingFunctions(languageId, nd);
        if (anc) {
          for (let sibling = anc.nextSibling; sibling; sibling = sibling.nextSibling) if (isFunctionDefinition(languageId, sibling)) {
            let startIndex = getFirstPrecedingComment(sibling)?.startIndex ?? sibling.startIndex;
            if (startIndex < offset) continue;
            return startIndex;
          }
          if (anc.endIndex >= offset) return anc.endIndex;
        }
      } finally {
        tree.delete();
      }
    }
    return offset;
  }
  getSiblingFunctionStart(getSiblingFunctionStart, "Fr");
  __name(getSiblingFunctionStart, "getSiblingFunctionStart");
  var defaultCursorContextOptions = {
    tokenizerName: "cl100k"
  };
  function cursorContextOptions(options) {
    return {
      ...defaultCursorContextOptions,
      ...options
    };
  }
  cursorContextOptions(cursorContextOptions, "$o");
  __name(cursorContextOptions, "cursorContextOptions");
  function getCursorContext(doc, options = {}) {
    let completeOptions = cursorContextOptions(options),
      tokenizer = getTokenizer(completeOptions.tokenizerName);
    if (completeOptions.maxLineCount !== void 0 && completeOptions.maxLineCount < 0) throw new Error("maxLineCount must be non-negative if defined");
    if (completeOptions.maxTokenLength !== void 0 && completeOptions.maxTokenLength < 0) throw new Error("maxTokenLength must be non-negative if defined");
    if (completeOptions.maxLineCount === 0 || completeOptions.maxTokenLength === 0) return {
      context: "",
      lineCount: 0,
      tokenLength: 0,
      tokenizerName: completeOptions.tokenizerName
    };
    let context = doc.source.slice(0, doc.offset);
    return completeOptions.maxLineCount !== void 0 && (context = context.split(`
`).slice(-completeOptions.maxLineCount).join(`
`)), completeOptions.maxTokenLength !== void 0 && (context = tokenizer.takeLastLinesTokens(context, completeOptions.maxTokenLength)), {
      context: context,
      lineCount: context.split(`
`).length,
      tokenLength: tokenizer.tokenLength(context),
      tokenizerName: completeOptions.tokenizerName
    };
  }
  getCursorContext(getCursorContext, "we");
  __name(getCursorContext, "getCursorContext");
  var SnippetProviderType = (SnippetProviderType => (SnippetProviderType.NeighboringTabs = "neighboring-tabs", SnippetProviderType.Retrieval = "retrieval", SnippetProviderType.SymbolDef = "symbol-def", SnippetProviderType.Language = "language", SnippetProviderType.Path = "path", SnippetProviderType.LocalImportContext = "local-import-context", SnippetProviderType))(SnippetProviderType || {}),
    SnippetSemantics = (SnippetSemantics => (SnippetSemantics.Function = "function", SnippetSemantics.Snippet = "snippet", SnippetSemantics.Variable = "variable", SnippetSemantics.Parameter = "parameter", SnippetSemantics.Method = "method", SnippetSemantics.Class = "class", SnippetSemantics.Module = "module", SnippetSemantics.Alias = "alias", SnippetSemantics.Enum = "enum member", SnippetSemantics.Interface = "interface", SnippetSemantics))(SnippetSemantics || {}),
    snippetSemanticsToString = {
      function: "function",
      snippet: "snippet",
      variable: "variable",
      parameter: "parameter",
      method: "method",
      class: "class",
      module: "module",
      alias: "alias",
      "enum member": "enum member",
      interface: "interface"
    };
  function announceSnippet(snippet, targetDocLanguageId) {
    let semantics = snippetSemanticsToString[snippet.semantics],
      headlinedSnippet = (snippet.relativePath ? `Compare this ${semantics} from ${snippet.relativePath}:` : `Compare this ${semantics}:`) + `
` + snippet.snippet;
    return headlinedSnippet.endsWith(`
`) || (headlinedSnippet += `
`), commentBlockAsSingles(headlinedSnippet, targetDocLanguageId);
  }
  announceSnippet(announceSnippet, "Ko");
  __name(announceSnippet, "announceSnippet");
  function normalizeSnippetScore(snippet, providerOptions) {
    let options = providerOptions[snippet.provider];
    if (!options) throw new Error("Unknown snippet provider: " + snippet.provider);
    let {
        score: providerScore,
        ...snippetRem
      } = snippet,
      normalizedScore = providerScore;
    if (options.normalizationFunction === "affine") {
      let [a, b] = options.normalizationParams;
      normalizedScore = a * providerScore + b;
    } else throw new Error(`Unknown normalization function ${options.normalizationFunction} for snippet provider ${snippet.provider}`);
    return {
      ...snippetRem,
      providerScore: providerScore,
      normalizedScore: normalizedScore
    };
  }
  normalizeSnippetScore(normalizeSnippetScore, "Jo");
  __name(normalizeSnippetScore, "normalizeSnippetScore");
  function sortSnippetsDescending(snippets) {
    snippets.sort((a, b) => b.normalizedScore - a.normalizedScore);
  }
  sortSnippetsDescending(sortSnippetsDescending, "Mt");
  __name(sortSnippetsDescending, "sortSnippetsDescending");
  function selectSnippets(snippets, numberOfSnippets, providerOptions) {
    if (numberOfSnippets == 0) return {
      reserved: [],
      candidates: []
    };
    let normalizedSnippets = snippets.map(snippet => normalizeSnippetScore(snippet, providerOptions)),
      snippetsByProvider = new Map(),
      provider;
    for (provider in providerOptions) snippetsByProvider.set(provider, []);
    for (let snippet of normalizedSnippets) {
      let snippets = snippetsByProvider.get(snippet.provider);
      if (!snippets) throw new Error("Unknown snippet provider: " + snippet.provider);
      snippets.push(snippet);
    }
    for (let [_provider, snippets] of snippetsByProvider) sortSnippetsDescending(snippets);
    let reserved = [];
    for (provider in providerOptions) {
      let count = providerOptions[provider].reservedSnippetCount || 0;
      if (count > 0) {
        let snippets = snippetsByProvider.get(provider) || [];
        reserved = reserved.concat(snippets.slice(0, count)), snippetsByProvider.set(provider, snippets.slice(count));
      }
    }
    sortSnippetsDescending(reserved);
    let candidates = [];
    if (reserved.length > numberOfSnippets) throw new Error("Reserved snippet count exceeds number of snippets");
    if (reserved.length < numberOfSnippets) {
      let remaining = Array.from(snippetsByProvider.values()).flat();
      sortSnippetsDescending(remaining), candidates = remaining.slice(0, numberOfSnippets - reserved.length);
    }
    return {
      reserved: reserved,
      candidates: candidates
    };
  }
  selectSnippets(selectSnippets, "Qo");
  __name(selectSnippets, "selectSnippets");
  function processSnippetsForWishlist(snippets, targetDocLanguageId, tokenizer, providerOptions, priorities, totalPrioritized, highPriorityBudget) {
    let {
        reserved: reserved,
        candidates: candidates
      } = selectSnippets(snippets, totalPrioritized, providerOptions),
      usedBudget = 0,
      processedSnippets = [],
      nextHighPriority = priorities.high,
      nextLowPriority = priorities.low;
    function process(snippet, usedBudget) {
      let announced = announceSnippet(snippet, targetDocLanguageId),
        tokens = tokenizer.tokenLength(announced),
        priority;
      return usedBudget + tokens <= highPriorityBudget ? (priority = nextHighPriority, nextHighPriority = priorities.priorities.justBelow(priority)) : (priority = nextLowPriority, nextLowPriority = priorities.priorities.justBelow(priority)), processedSnippets.push({
        announcedSnippet: announced,
        provider: snippet.provider,
        providerScore: snippet.providerScore,
        normalizedScore: snippet.normalizedScore,
        priority: priority,
        tokens: tokens,
        relativePath: snippet.relativePath
      }), usedBudget + tokens;
    }
    process(process, "process"), __name(process, "process");
    for (let snippet of [...reserved, ...candidates]) {
      if (processedSnippets.length >= totalPrioritized) break;
      usedBudget = process(snippet, usedBudget);
    }
    return sortSnippetsDescending(processedSnippets), processedSnippets.reverse(), processedSnippets;
  }
  processSnippetsForWishlist(processSnippetsForWishlist, "Or");
  __name(processSnippetsForWishlist, "processSnippetsForWishlist");
  var FifoCache = class {
      static {
        __name(this, "Sn");
      }
      constructor(size) {
        this.keys = [], this.cache = {}, this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    },
    Tokenizer = class {
      static {
        __name(this, "vn");
      }
      static {
        __name(this, "Tokenizer");
      }
      constructor(doc) {
        this.stopsForLanguage = SPECIFIC_STOPS.get(doc.languageId) ?? GENERIC_STOPS;
      }
      tokenize(a) {
        return new Set(splitIntoWords(a).filter(x => !this.stopsForLanguage.has(x)));
      }
    },
    WINDOWED_TOKEN_SET_CACHE = new FifoCache(20),
    WindowedMatcher = class {
      static {
        __name(this, "Se");
      }
      static {
        __name(this, "WindowedMatcher");
      }
      constructor(referenceDoc) {
        this.referenceDoc = referenceDoc, this.tokenizer = new Tokenizer(referenceDoc);
      }
      get referenceTokens() {
        return this.tokenizer.tokenize(this._getCursorContextInfo(this.referenceDoc).context);
      }
      sortScoredSnippets(snippets, sortOption = "descending") {
        return sortOption == "ascending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "descending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      retrieveAllSnippets(objectDoc, sortOption = "descending") {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
      async findMatches(objectDoc, snippetSelectionOption = "snippetSelectionOption", snippetSelectionK) {
        if (snippetSelectionOption == "snippetSelectionOption") {
          let snippet = await this.findBestMatch(objectDoc);
          return snippet ? [snippet] : [];
        }
        return snippetSelectionOption == "snippetSelectionOption" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        return snippets.length === 0 || snippets[0].score === 0 ? void 0 : {
          snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippets[0]
        };
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        if (snippets.length === 0 || snippets[0].score === 0) return;
        let nonOverlappingSnippets = [snippets[0]];
        for (let currentIndex = 1; currentIndex < snippets.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippets[currentIndex].startLine < snippet.endLine && snippets[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippets[currentIndex]);
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippetMarker
        }));
      }
    };
  async function getNeighboringFunctions(neighbor) {
    let neighborFuncs = [];
    if (isSupportedLanguageId(neighbor.languageId)) {
      let funcPositions = await getFunctionPositions(neighbor.languageId, neighbor.source);
      for (let i = 0; i < funcPositions.length; i++) {
        let {
            startIndex: startIndex,
            endIndex: endIndex
          } = funcPositions[i],
          func_source = neighbor.source.substring(startIndex, endIndex);
        neighborFuncs.push({
          source: func_source,
          relativePath: neighbor.relativePath,
          languageId: neighbor.languageId,
          uri: neighbor.uri
        });
      }
    }
    return neighborFuncs;
  }
  getNeighboringFunctions(getNeighboringFunctions, "Xo");
  __name(getNeighboringFunctions, "getNeighboringFunctions");
  var FunctionalMatcher = class extends WindowedMatcher {
    static {
      __name(this, "It");
    }
    static {
      __name(this, "FunctionalMatcher");
    }
    constructor(referenceDoc) {
      super(referenceDoc);
    }
    getMatchingScore(neighborDoc) {
      let neighborDocTokens = this.tokenizer.tokenize(neighborDoc.source),
        score = this.similarityScore(neighborDocTokens, this.referenceTokens);
      return {
        snippet: neighborDoc.source,
        score: score,
        startLine: 0,
        endLine: 0
      };
    }
    async findBestMatch(objectDoc) {
      let snippets = await this.findMatches(objectDoc);
      if (snippets.length !== 0 && snippets[0].score !== 0) return snippets[0];
    }
    async findMatches(objectDoc, snippetSelectionOption, snippetSelectionK) {
      if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return [];
      let neighborFuncs = await getNeighboringFunctions(objectDoc);
      if (neighborFuncs.length == 0) {
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        return snippets.length === 0 ? [] : snippets[0].score === 0 ? [] : [{
          snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippets[0]
        }];
      }
      let snippets = [];
      for (let func of neighborFuncs) {
        let snippet = this.getMatchingScore(func);
        snippets.push({
          semantics: "function",
          provider: "neighboring-tabs",
          ...snippet
        });
      }
      return snippets;
    }
  };
  function splitIntoWords(a) {
    return a.split(/[^a-zA-Z0-9]/).filter(x => x.length > 0);
  }
  splitIntoWords(splitIntoWords, "Yo");
  __name(splitIntoWords, "splitIntoWords");
  var ENGLISH_STOPS = new Set(["we", "our", "you", "it", "its", "they", "them", "their", "this", "that", "these", "those", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "can", "don", "t", "s", "will", "would", "should", "what", "which", "who", "when", "where", "why", "how", "a", "an", "the", "and", "or", "not", "no", "but", "because", "as", "until", "again", "further", "then", "once", "here", "there", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "above", "below", "to", "during", "before", "after", "of", "at", "by", "about", "between", "into", "through", "from", "up", "down", "in", "out", "on", "off", "over", "under", "only", "own", "same", "so", "than", "too", "very", "just", "now"]),
    GENERIC_STOPS = new Set(["if", "then", "else", "for", "while", "with", "def", "function", "return", "TODO", "import", "try", "catch", "raise", "finally", "repeat", "switch", "case", "match", "assert", "continue", "break", "const", "class", "enum", "struct", "static", "new", "super", "this", "var", ...ENGLISH_STOPS]),
    SPECIFIC_STOPS = new Map([]);
  function getBasicWindowDelineations(windowLength, lines) {
    let windows = [],
      length = lines.length;
    if (length == 0) return [];
    if (length < windowLength) return [[0, length]];
    for (let startLine = 0; startLine < length - windowLength + 1; startLine++) windows.push([startLine, startLine + windowLength]);
    return windows;
  }
  getBasicWindowDelineations(getBasicWindowDelineations, "Ye");
  __name(getBasicWindowDelineations, "getBasicWindowDelineations");
  var FixedWindowSizeJaccardMatcher = class _FixedWindowSizeJaccardMatcher extends WindowedMatcher {
      static {
        __name(this, "n");
      }
      constructor(referenceDoc, windowLength) {
        super(referenceDoc), this.windowLength = windowLength;
      }
      static {
        __name(this, "FixedWindowSizeJaccardMatcher");
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FixedWindowSizeJaccardMatcher(referenceDoc, windowLength)
        });
      }
      id() {
        return "fixed:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    },
    FunctionJaccardMatcher = class _FunctionJaccardMatcher extends FunctionalMatcher {
      static {
        __name(this, "n");
      }
      constructor(referenceDoc, windowLength) {
        super(referenceDoc), this.windowLength = windowLength;
      }
      static {
        __name(this, "FunctionJaccardMatcher");
      }
      id() {
        return "function:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FunctionJaccardMatcher(referenceDoc, windowLength)
        });
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    };
  function computeScore(a, b) {
    let intersection = new Set();
    return a.forEach(x => {
      b.has(x) && intersection.add(x);
    }), intersection.size / (a.size + b.size - intersection.size);
  }
  computeScore(computeScore, "Nt");
  __name(computeScore, "computeScore");
  var CursorSnippetsPickingStrategy = (CursorSnippetsPickingStrategy => (CursorSnippetsPickingStrategy.CursorOnly = "cursoronly", CursorSnippetsPickingStrategy.CursorJaccard = "cursorjaccard", CursorSnippetsPickingStrategy.JaccardCursor = "jaccardcursor", CursorSnippetsPickingStrategy))(CursorSnippetsPickingStrategy || {}),
    FifoCache = class {
      static {
        __name(this, "En");
      }
      constructor(size) {
        this.keys = [], this.cache = {}, this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    },
    WINDOWED_TOKEN_SET_CACHE = new FifoCache(20),
    CustomizedFixedWindowSizeJaccardMatcher = class extends WindowedMatcher {
      static {
        __name(this, "xn");
      }
      constructor(referenceDoc, windowLength) {
        super(referenceDoc), this.windowLength = windowLength;
      }
      static {
        __name(this, "CustomizedFixedWindowSizeJaccardMatcher");
      }
      id() {
        return "CustomizedFixedWindowSizeJaccardMatcher:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
      retrieveAllSnippets(objectDoc, sortOption = "sortOption", candidates) {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          if (candidates !== void 0 && candidates.get(startLine) !== endLine) continue;
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
    },
    CursorHistoryMatcher = class _CursorHistoryMatcher {
      static {
        __name(this, "n");
      }
      static {
        __name(this, "CursorHistoryMatcher");
      }
      constructor(referenceDoc, windowLength, lineCursorHistory, strategy) {
        this.windowLength = windowLength, this.lineCursorHistory = lineCursorHistory, this.jaccardMatcher = new CustomizedFixedWindowSizeJaccardMatcher(referenceDoc, windowLength), this.strategy = strategy;
      }
      static {
        this.FACTORY = (windowLength, lineCursorHistory, strategy) => ({
          to: referenceDoc => new _CursorHistoryMatcher(referenceDoc, windowLength, lineCursorHistory, strategy)
        });
      }
      sortScoredSnippets(snippets, sortOption = "sortOption") {
        return sortOption == "sortOption" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "sortOption" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      markerToSnippet(nonOverlappingSnippets, lines) {
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          provider: "neighboring-tabs",
          semantics: "snippet",
          ...snippetMarker
        }));
      }
      async findMatches(objectDoc, snippetSelectionOption = "snippetSelectionOption", snippetSelectionK) {
        if (snippetSelectionOption == "snippetSelectionOption") {
          let bestMatch = await this.findBestMatch(objectDoc);
          return bestMatch === void 0 ? [] : [bestMatch];
        }
        return snippetSelectionOption == "snippetSelectionOption" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length !== 0) {
          if (this.strategy === "cursoronly") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippets = snippetsByCursor.filter(s => s.score === bestCursorScore),
              bestInMiddle = bestSnippets.sort((a, b) => a.startLine - b.startLine)[Math.floor(bestSnippets.length / 2)];
            return {
              snippet: objectDoc.source.split(`
`).slice(bestInMiddle.startLine, bestInMiddle.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestInMiddle
            };
          } else if (this.strategy === "cursorjaccard") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippetsByCursor = [],
              bestSnippetsBoundaryByCursor = new Map();
            for (let snippet of snippetsByCursor) snippet.score === bestCursorScore && (bestSnippetsByCursor.push(snippet), bestSnippetsBoundaryByCursor.set(snippet.startLine, snippet.endLine));
            let bestSnippets = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "objectDoc", bestSnippetsBoundaryByCursor);
            if (bestSnippets.length === 0) return;
            let bestSnippet = bestSnippets[0];
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return {
              snippet: objectDoc.source.split(`
`).slice(bestSnippet.startLine, bestSnippet.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestSnippet
            };
          } else if (this.strategy === "jaccardcursor") {
            let bestSnippet = await this.jaccardMatcher.findBestMatch(objectDoc);
            if (bestSnippet === void 0) return;
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor"), snippetsByCursor.length === 0) return;
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return bestSnippet;
          }
        }
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
        if (snippetsByCursor.length !== 0) {
          if (this.strategy === "cursoronly") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "cursorjaccard") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor");
            let snippetCandidates = new Map(snippetsByCursor.map(s => [s.startLine, s.endLine])),
              jaccardMap = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "objectDoc", snippetCandidates).reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            snippetsByCursor.forEach(v => v.score += jaccardMap.get([v.startLine, v.endLine].join(",")) ?? 0), snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "snippetsByCursor");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "jaccardcursor") {
            let topKByJaccard = await this.jaccardMatcher.findTopKMatches(objectDoc, snippetSelectionK);
            if (topKByJaccard === void 0) return;
            let cursorMap = snippetsByCursor.reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            topKByJaccard.forEach(v => v.score += cursorMap.get([v.startLine, v.endLine].join(",")) ?? 0);
            let resortedTopKByJaccard = this.sortScoredSnippets(topKByJaccard, "topKByJaccard");
            return this.markerToSnippet(resortedTopKByJaccard, lines);
          }
        }
      }
      gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK) {
        let nonOverlappingSnippets = [snippetsByCursor[0]];
        for (let currentIndex = 1; currentIndex < snippetsByCursor.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippetsByCursor[currentIndex].startLine < snippet.endLine && snippetsByCursor[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippetsByCursor[currentIndex]);
        return nonOverlappingSnippets;
      }
      retrieveCursorSnippets(objectDoc) {
        let snippets = [];
        if (objectDoc.source.length === 0) return snippets;
        let cursors = this.lineCursorHistory.get(objectDoc.uri);
        if (cursors === void 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          pointType;
        (pointType => (pointType[pointType.leftBoundary = 0] = "leftBoundary", pointType[pointType.rightBoundary = 1] = "rightBoundary"))(pointType ||= {});
        let sparsePoints = [];
        for (let [line, num] of cursors.entries()) line >= lines.length || (sparsePoints.push([Math.max(0, line - this.windowLength + 1), 0, num]), sparsePoints.push([line + 1, 1, num]));
        sparsePoints.push([lines.length, 0, 0]), sparsePoints = sparsePoints.sort((a, b) => a[0] - b[0]);
        let numCursors = 0,
          previousLine = 0;
        for (let [line, type, num] of sparsePoints) {
          if (numCursors > 0) for (let index = previousLine; index < line && (index == 0 || index + this.windowLength <= lines.length); index++) snippets.push({
            score: numCursors,
            startLine: index,
            endLine: Math.min(lines.length, index + this.windowLength)
          });
          type === 0 ? numCursors += num : numCursors -= num, previousLine = line;
        }
        return snippets;
      }
    },
    import_assert = require("assert"),
    NeighboringTabsOption = (NeighboringTabsOption => (NeighboringTabsOption.None = "none", NeighboringTabsOption.Conservative = "conservative", NeighboringTabsOption.Medium = "medium", NeighboringTabsOption.Eager = "eager", NeighboringTabsOption.EagerButLittle = "eagerButLittle", NeighboringTabsOption.EagerButMedium = "eagerButMedium", NeighboringTabsOption.EagerButMuch = "eagerButMuch", NeighboringTabsOption.RetrievalComparable = "retrievalComparable", NeighboringTabsOption))(NeighboringTabsOption || {}),
    NeighboringSnippetType = (NeighboringSnippetType => (NeighboringSnippetType.NeighboringFunctions = "neighboringFunction", NeighboringSnippetType.NeighboringSnippets = "neighboringSnippet", NeighboringSnippetType.CursorHistoryMatcher = "cursorhistorymatcher", NeighboringSnippetType))(NeighboringSnippetType || {}),
    neighborOptionToSelection = {
      none: {
        snippetLength: 1,
        threshold: -1,
        numberOfSnippets: 0
      },
      conservative: {
        snippetLength: 10,
        threshold: .3,
        numberOfSnippets: 1
      },
      medium: {
        snippetLength: 20,
        threshold: .1,
        numberOfSnippets: 2
      },
      eager: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButLittle: {
        snippetLength: 10,
        threshold: 0,
        numberOfSnippets: 1
      },
      eagerButMedium: {
        snippetLength: 20,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButMuch: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 6
      },
      retrievalComparable: {
        snippetLength: 30,
        threshold: 0,
        numberOfSnippets: 4
      }
    },
    MAX_CHARACTERS_PER_FILE = 1e4,
    MAX_NUMBER_OF_FILES = 20;
  function getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy = "cursorSnippetsPickingStrategy") {
    let matcherFactory;
    return neighboringSnippetTypes === "neighboringSnippet" ? matcherFactory = FixedWindowSizeJaccardMatcher.FACTORY(selection.snippetLength) : neighboringSnippetTypes === "neighboringFunction" ? matcherFactory = FunctionJaccardMatcher.FACTORY(selection.snippetLength) : ((0, Br.ok)(lineCursorHistory !== void 0, "lineCursorHistory should not be undefined"), matcherFactory = CursorHistoryMatcher.FACTORY(selection.snippetLength, lineCursorHistory, cursorSnippetsPickingStrategy)), matcherFactory.to(doc);
  }
  getMatcher(getMatcher, "ss");
  __name(getMatcher, "getMatcher");
  async function getNeighborSnippets(doc, neighbors, neighboringSnippetTypes, options, snippetSelectionOption, snippetSelectionK, lineCursorHistory, cursorSnippetsPickingStrategy) {
    let selection = {
        ...neighborOptionToSelection[options]
      },
      matcher = getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy);
    return selection.numberOfSnippets === 0 ? [] : (await neighbors.filter(neighbor => neighbor.source.length < MAX_CHARACTERS_PER_FILE && neighbor.source.length > 0).slice(0, MAX_NUMBER_OF_FILES).reduce(async (acc, neighbor) => (await acc).concat((await matcher.findMatches(neighbor, snippetSelectionOption, snippetSelectionK)).map(snippet => ({
      relativePath: neighbor.relativePath,
      ...snippet
    }))), Promise.resolve([]))).filter(neighbor => neighbor.score && neighbor.snippet && neighbor.score > selection.threshold).sort((a, b) => a.score - b.score).slice(-selection.numberOfSnippets);
  }
  getNeighborSnippets(getNeighborSnippets, "Wr");
  __name(getNeighborSnippets, "getNeighborSnippets");
  function findEditDistanceScore(a, b) {
    if (a.length === 0 || b.length === 0) return {
      score: a.length + b.length
    };
    let matrix = Array.from({
      length: a.length
    }).map(() => Array.from({
      length: b.length
    }).map(() => 0));
    for (let i = 0; i < a.length; i++) matrix[i][0] = i;
    for (let i = 0; i < b.length; i++) matrix[0][i] = i;
    for (let j = 0; j < b.length; j++) for (let i = 0; i < a.length; i++) matrix[i][j] = Math.min((i == 0 ? j : matrix[i - 1][j]) + 1, (j == 0 ? i : matrix[i][j - 1]) + 1, (i == 0 || j == 0 ? Math.max(i, j) : matrix[i - 1][j - 1]) + (a[i] == b[j] ? 0 : 1));
    return {
      score: matrix[a.length - 1][b.length - 1]
    };
  }
  findEditDistanceScore(findEditDistanceScore, "Ur");
  __name(findEditDistanceScore, "findEditDistanceScore");
  var PromptBackground = class {
      static {
        __name(this, "Mn");
      }
      constructor() {
        this.used = new Map(), this.unused = new Map();
      }
      static {
        __name(this, "PromptBackground");
      }
      markUsed(element) {
        this.IsSnippet(element) && this.used.set(element.id, this.convert(element));
      }
      undoMarkUsed(element) {
        this.IsSnippet(element) && this.used.delete(element.id);
      }
      markUnused(element) {
        this.IsSnippet(element) && this.unused.set(element.id, this.convert(element));
      }
      convert(element) {
        return {
          score: element.score.toFixed(4),
          length: element.text.length
        };
      }
      IsSnippet(element) {
        return element.kind == "SimilarFile" || element.kind == "RetrievalSnippet";
      }
    },
    PromptChoices = class {
      static {
        __name(this, "In");
      }
      constructor() {
        this.used = new Map(), this.unused = new Map(), this.usedCounts = new Map(), this.unusedCounts = new Map();
      }
      static {
        __name(this, "PromptChoices");
      }
      markUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) + element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) + 1);
      }
      undoMarkUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) - element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) - 1);
      }
      markUnused(element) {
        this.unused.set(element.kind, (this.unused.get(element.kind) || 0) + element.tokens), this.unusedCounts.set(element.kind, (this.unusedCounts.get(element.kind) || 0) + 1);
      }
    },
    PromptElementRanges = class {
      static {
        __name(this, "kt");
      }
      constructor(usedElements) {
        this.ranges = new Array();
        let nextRangeStart = 0,
          previousKind;
        for (let {
          element: element
        } of usedElements) element.text.length !== 0 && (previousKind === "BeforeCursor" && element.kind === "BeforeCursor" ? this.ranges[this.ranges.length - 1].end += element.text.length : this.ranges.push({
          kind: element.kind,
          start: nextRangeStart,
          end: nextRangeStart + element.text.length
        }), previousKind = element.kind, nextRangeStart += element.text.length);
      }
      static {
        __name(this, "PromptElementRanges");
      }
    },
    PromptWishlist = class {
      static {
        __name(this, "At");
      }
      constructor(tokenizer, lineEndingOption) {
        this.tokenizer = tokenizer, this.content = [], this.tokenizer = tokenizer, this.lineEndingOption = lineEndingOption;
      }
      static {
        __name(this, "PromptWishlist");
      }
      getContent() {
        return [...this.content];
      }
      convertLineEndings(text) {
        return this.lineEndingOption === "unix" && (text = text.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), text;
      }
      append(text, kind, priority, tokens = this.tokenizer.tokenLength(text), score = NaN) {
        text = this.convertLineEndings(text);
        let id = this.content.length;
        return this.content.push({
          id: id,
          text: text,
          kind: kind,
          priority: priority,
          tokens: tokens,
          requires: [],
          excludes: [],
          score: score
        }), id;
      }
      appendLineForLine(text, kind, priority) {
        text = this.convertLineEndings(text);
        let rawLines = text.split(`
`);
        for (let i = 0; i < rawLines.length - 1; i++) rawLines[i] += `
`;
        let lines = [];
        rawLines.forEach((line, i) => {
          line === `
` && lines.length > 0 && !lines[lines.length - 1].endsWith(`

`) ? lines[lines.length - 1] += `
` : lines.push(line);
        });
        let returns = [];
        return lines.forEach((line, i) => {
          line !== "" && (returns.push(this.append(line, kind, priority)), i > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]));
        }), returns;
      }
      require(dependentId, dependeeId) {
        let dependent = this.content.find(e => e.id === dependentId),
          dependee = this.content.find(e => e.id === dependeeId);
        dependent && dependee && dependent.requires.push(dependee);
      }
      exclude(excludingId, excludedId) {
        let excluding = this.content.find(e => e.id === excludingId),
          excluded = this.content.find(e => e.id === excludedId);
        excluding && excluded && excluding.excludes.push(excluded);
      }
      fulfill(maxPromptLength) {
        let tallyOfChoices = new PromptChoices(),
          promptBackground = new PromptBackground(),
          indexedContent = this.content.map((e, i) => ({
            element: e,
            index: i
          }));
        indexedContent.sort((a, b) => a.element.priority === b.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
        let idsThatHaveAlreadyBeenAdded = new Set(),
          idsConflictingWithAlreadyAddedIds = new Set(),
          budgetBreakingElement,
          remainingContent = [],
          remainingBudget = maxPromptLength;
        indexedContent.forEach(e => {
          let element = e.element;
          if (remainingBudget >= 0 && (remainingBudget > 0 || budgetBreakingElement === void 0) && element.requires.every(r => idsThatHaveAlreadyBeenAdded.has(r.id)) && !idsConflictingWithAlreadyAddedIds.has(element.id)) {
            let budgetUse = element.tokens;
            remainingBudget >= budgetUse ? (remainingBudget -= budgetUse, idsThatHaveAlreadyBeenAdded.add(element.id), element.excludes.forEach(e => idsConflictingWithAlreadyAddedIds.add(e.id)), tallyOfChoices.markUsed(element), promptBackground.markUsed(element), remainingContent.push(e)) : budgetBreakingElement === void 0 ? budgetBreakingElement = e : (tallyOfChoices.markUnused(e.element), promptBackground.markUnused(e.element));
          } else tallyOfChoices.markUnused(element), promptBackground.markUnused(element);
        }), remainingContent.sort((a, b) => a.index - b.index);
        let prompt = remainingContent.reduce((a, b) => a + b.element.text, ""),
          promptLength = this.tokenizer.tokenLength(prompt);
        for (; promptLength > maxPromptLength;) {
          remainingContent.sort((a, b) => b.element.priority === a.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
          let removeAfterAll = remainingContent.pop();
          removeAfterAll && (tallyOfChoices.undoMarkUsed(removeAfterAll.element), tallyOfChoices.markUnused(removeAfterAll.element), promptBackground.undoMarkUsed(removeAfterAll.element), promptBackground.markUnused(removeAfterAll.element), budgetBreakingElement !== void 0 && (tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element)), budgetBreakingElement = void 0), remainingContent.sort((a, b) => a.index - b.index), prompt = remainingContent.reduce((a, b) => a + b.element.text, ""), promptLength = this.tokenizer.tokenLength(prompt);
        }
        let extendedContent = [...remainingContent];
        if (budgetBreakingElement !== void 0) {
          extendedContent.push(budgetBreakingElement), extendedContent.sort((a, b) => a.index - b.index);
          let prompt = extendedContent.reduce((a, b) => a + b.element.text, ""),
            promptLength = this.tokenizer.tokenLength(prompt);
          if (promptLength <= maxPromptLength) {
            tallyOfChoices.markUsed(budgetBreakingElement.element), promptBackground.markUsed(budgetBreakingElement.element);
            let promptElementRanges = new PromptElementRanges(extendedContent);
            return {
              prefix: prompt,
              suffix: "",
              prefixLength: promptLength,
              suffixLength: 0,
              promptChoices: tallyOfChoices,
              promptBackground: promptBackground,
              promptElementRanges: promptElementRanges
            };
          } else tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element);
        }
        let promptElementRanges = new PromptElementRanges(remainingContent);
        return {
          prefix: prompt,
          suffix: "",
          prefixLength: promptLength,
          suffixLength: 0,
          promptChoices: tallyOfChoices,
          promptBackground: promptBackground,
          promptElementRanges: promptElementRanges
        };
      }
    },
    Priorities = class _Priorities {
      static {
        __name(this, "n");
      }
      constructor() {
        this.registeredPriorities = [0, 1];
      }
      static {
        __name(this, "Priorities");
      }
      static {
        this.TOP = 1;
      }
      static {
        this.BOTTOM = 0;
      }
      register(priority) {
        if (priority > _Priorities.TOP || priority < _Priorities.BOTTOM) throw new Error("Priority must be between 0 and 1");
        return this.registeredPriorities.push(priority), priority;
      }
      justAbove(...priorities) {
        let priority = Math.max(...priorities),
          nearestNeighbor = Math.min(...this.registeredPriorities.filter(p => p > priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      justBelow(...priorities) {
        let priority = Math.min(...priorities),
          nearestNeighbor = Math.max(...this.registeredPriorities.filter(p => p < priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      between(lower, higher) {
        if (this.registeredPriorities.some(p => p > lower && p < higher) || !(this.registeredPriorities.includes(lower) && this.registeredPriorities.includes(higher))) throw new Error("Priorities must be adjacent in the list of priorities");
        return this.register((lower + higher) / 2);
      }
    },
    cachedSuffix = {
      text: "",
      tokens: []
    },
    MAX_PROMPT_LENGTH = 1500,
    MAX_EDIT_DISTANCE_LENGTH = 50,
    TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5,
    DEFAULT_NUM_OF_SNIPPETS = 4,
    LanguageMarkerOption = (LanguageMarkerOption => (LanguageMarkerOption.NoMarker = "nomarker", LanguageMarkerOption.Top = "top", LanguageMarkerOption.Always = "always", LanguageMarkerOption))(LanguageMarkerOption || {}),
    PathMarkerOption = (PathMarkerOption => (PathMarkerOption.NoMarker = "nomarker", PathMarkerOption.Top = "top", PathMarkerOption.Always = "always", PathMarkerOption))(PathMarkerOption || {}),
    SnippetPositionOption = (SnippetPositionOption => (SnippetPositionOption.TopOfText = "top", SnippetPositionOption.DirectlyAboveCursor = "aboveCursor", SnippetPositionOption.AfterSiblings = "afterSiblings", SnippetPositionOption))(SnippetPositionOption || {}),
    SnippetSelectionOption = (SnippetSelectionOption => (SnippetSelectionOption.BestMatch = "bestMatch", SnippetSelectionOption.TopK = "topK", SnippetSelectionOption))(SnippetSelectionOption || {}),
    LocalImportContextOption = (LocalImportContextOption => (LocalImportContextOption.NoContext = "nocontext", LocalImportContextOption.Declarations = "declarations", LocalImportContextOption))(LocalImportContextOption || {}),
    LineEndingOptions = (LineEndingOptions => (LineEndingOptions.ConvertToUnix = "unix", LineEndingOptions.KeepOriginal = "keep", LineEndingOptions))(LineEndingOptions || {}),
    SuffixOption = (SuffixOption => (SuffixOption.None = "none", SuffixOption.FifteenPercent = "fifteenPercent", SuffixOption))(SuffixOption || {}),
    SuffixMatchOption = (SuffixMatchOption => (SuffixMatchOption.Equal = "equal", SuffixMatchOption.Levenshtein = "levenshteineditdistance", SuffixMatchOption))(SuffixMatchOption || {}),
    SuffixStartMode = (SuffixStartMode => (SuffixStartMode.Cursor = "cursor", SuffixStartMode.CursorTrimStart = "cursortrimstart", SuffixStartMode.SiblingBlock = "siblingblock", SuffixStartMode.SiblingBlockTrimStart = "siblingblocktrimstart", SuffixStartMode))(SuffixStartMode || {}),
    PromptOptions = class {
      static {
        __name(this, "Ot");
      }
      constructor(fs, options) {
        if (this.fs = fs, this.maxPromptLength = MAX_PROMPT_LENGTH, this.languageMarker = "top", this.pathMarker = "top", this.localImportContext = "nocontext", this.snippetPosition = "top", this.numberOfSnippets = DEFAULT_NUM_OF_SNIPPETS, this.snippetProviderOptions = {
          "neighboring-tabs": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          retrieval: {
            normalizationFunction: "affine",
            normalizationParams: [-1, 0]
          },
          "symbol-def": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0],
            reservedSnippetCount: 2
          },
          language: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          path: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          "local-import-context": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          }
        }, this.neighboringTabs = "eager", this.neighboringSnippetTypes = "neighboringSnippet", this.lineEnding = "unix", this.suffixPercent = 0, this.snippetPercent = 0, this.suffixStartMode = "cursor", this.tokenizerName = "cl100k", this.suffixMatchThreshold = 0, this.suffixMatchCriteria = "levenshteineditdistance", this.fimSuffixLengthThreshold = 0, this.cursorSnippetsPickingStrategy = "cursorjaccard", options) {
          let selectionValue = options?.snippetSelection;
          if (selectionValue && !Object.values(SnippetSelectionOption).includes(selectionValue)) throw new Error(`Invalid value for snippetSelection: ${selectionValue}`);
          for (let key in options) if (key !== "snippetProviderOptions") this[key] = options[key];else {
            let newOptions = options.snippetProviderOptions || {},
              provider;
            for (provider in newOptions) {
              let providerOptions = newOptions[provider];
              providerOptions && (this.snippetProviderOptions[provider] = {
                ...this.snippetProviderOptions[provider],
                ...providerOptions
              });
            }
          }
        }
        if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);
        if (this.snippetPercent < 0 || this.snippetPercent > 100) throw new Error(`snippetPercent must be between 0 and 100, but was ${this.snippetPercent}`);
        if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100) throw new Error(`suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`);
        if (this.fimSuffixLengthThreshold < -1) throw new Error(`fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`);
        if (this.snippetSelection === "topK" && this.snippetSelectionK === void 0) throw new Error("snippetSelectionK must be defined.");
        if (this.snippetSelection === "topK" && this.snippetSelectionK && this.snippetSelectionK <= 0) throw new Error(`snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`);
      }
      static {
        __name(this, "PromptOptions");
      }
    },
    languageNormalizationMap = {
      javascriptreact: "javascript",
      jsx: "javascript",
      typescriptreact: "typescript",
      jade: "pug",
      cshtml: "razor"
    };
  function normalizeLanguageId(languageId) {
    return languageId = languageId.toLowerCase(), languageNormalizationMap[languageId] ?? languageId;
  }
  normalizeLanguageId(normalizeLanguageId, "Re");
  __name(normalizeLanguageId, "normalizeLanguageId");
  async function getPrompt(fileSystem, doc, options = {}, snippets = []) {
    let completeOptions = new PromptOptions(fileSystem, options),
      tokenizer = getTokenizer(completeOptions.tokenizerName),
      useCachedSuffix = !1,
      {
        source: source,
        offset: offset
      } = doc;
    if (offset < 0 || offset > source.length) throw new Error(`Offset ${offset} is out of range.`);
    doc.languageId = normalizeLanguageId(doc.languageId);
    let priorities = new Priorities(),
      directContextPriority = priorities.justBelow(Priorities.TOP),
      languageMarkerPriority = completeOptions.languageMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
      pathMarkerPriority = completeOptions.pathMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
      localImportContextPriority = priorities.justBelow(directContextPriority),
      lowSnippetPriority = priorities.justBelow(localImportContextPriority),
      highSnippetPriority = priorities.justAbove(directContextPriority),
      promptWishlist = new PromptWishlist(tokenizer, completeOptions.lineEnding),
      languageSnippet = snippets.find(s => s.provider === "language"),
      languageMarkerLine;
    completeOptions.languageMarker !== "nomarker" && languageSnippet && (languageMarkerLine = promptWishlist.append(languageSnippet.snippet, "LanguageMarker", languageMarkerPriority));
    let pathSnippet = snippets.find(s => s.provider === "path"),
      pathMarkerLine;
    completeOptions.pathMarker !== "nomarker" && pathSnippet !== void 0 && pathSnippet.snippet.length > 0 && (pathMarkerLine = promptWishlist.append(pathSnippet.snippet, "PathMarker", pathMarkerPriority));
    let localImportSnippet = snippets.filter(s => s.provider === "local-import-context");
    if (completeOptions.localImportContext !== "nocontext") for (let localImportContext of localImportSnippet) promptWishlist.append(newLineEnded(localImportContext.snippet), "ImportedFile", localImportContextPriority);
    snippets = snippets.filter(s => s.provider !== "language" && s.provider !== "path" && s.provider !== "local-import-context");
    function addSnippetsNow() {
      let budget = Math.round(completeOptions.snippetPercent / 100 * completeOptions.maxPromptLength);
      processSnippetsForWishlist(snippets, doc.languageId, tokenizer, completeOptions.snippetProviderOptions, {
        priorities: priorities,
        low: lowSnippetPriority,
        high: highSnippetPriority
      }, completeOptions.numberOfSnippets, budget).forEach(snippet => {
        let kind = "kind";
        snippet.provider === "retrieval" ? kind = "kind" : snippet.provider == "symbol-def" && (kind = "kind"), promptWishlist.append(snippet.announcedSnippet, kind, snippet.priority, snippet.tokens, snippet.normalizedScore);
      });
    }
    addSnippetsNow(addSnippetsNow, "addSnippetsNow"), __name(addSnippetsNow, "addSnippetsNow"), completeOptions.snippetPosition === "top" && addSnippetsNow();
    let source_lines = [],
      directContext;
    if (directContext = source.substring(0, offset), completeOptions.snippetPosition === "aboveCursor") {
      let lastLineStart = directContext.lastIndexOf(`
`) + 1,
        directContextBeforePartialLastLine = directContext.substring(0, lastLineStart),
        partialLastLine = directContext.substring(lastLineStart);
      promptWishlist.appendLineForLine(directContextBeforePartialLastLine, "directContextBeforePartialLastLine", directContextPriority).forEach(id => source_lines.push(id)), addSnippetsNow(), partialLastLine.length > 0 && (source_lines.push(promptWishlist.append(partialLastLine, "partialLastLine", directContextPriority)), source_lines.length > 1 && promptWishlist.require(source_lines[source_lines.length - 2], source_lines[source_lines.length - 1]));
    } else promptWishlist.appendLineForLine(directContext, "directContext", directContextPriority).forEach(id => source_lines.push(id));
    completeOptions.languageMarker === "top" && source_lines.length > 0 && languageMarkerLine !== void 0 && promptWishlist.require(languageMarkerLine, source_lines[0]), completeOptions.pathMarker === "top" && source_lines.length > 0 && pathMarkerLine !== void 0 && (languageMarkerLine ? promptWishlist.require(pathMarkerLine, languageMarkerLine) : promptWishlist.require(pathMarkerLine, source_lines[0])), languageMarkerLine !== void 0 && pathMarkerLine !== void 0 && promptWishlist.exclude(pathMarkerLine, languageMarkerLine);
    let actualSuffix = source.slice(offset);
    if (completeOptions.suffixPercent === 0 || actualSuffix.length <= completeOptions.fimSuffixLengthThreshold) return promptWishlist.fulfill(completeOptions.maxPromptLength);
    {
      let offset = doc.offset;
      completeOptions.suffixStartMode !== "cursor" && completeOptions.suffixStartMode !== "cursortrimstart" && (offset = await getSiblingFunctionStart(doc));
      let availableTokens = completeOptions.maxPromptLength - TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
        prefixTargetTokens = Math.floor(availableTokens * (100 - completeOptions.suffixPercent) / 100),
        promptInfo = promptWishlist.fulfill(prefixTargetTokens),
        suffixTargetTokens = availableTokens - promptInfo.prefixLength,
        suffixText = source.slice(offset);
      (completeOptions.suffixStartMode === "siblingblocktrimstart" || completeOptions.suffixStartMode === "cursortrimstart") && (suffixText = suffixText.trimStart());
      let suffix = tokenizer.takeFirstTokens(suffixText, suffixTargetTokens);
      return suffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - suffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), completeOptions.suffixMatchCriteria === "equal" ? suffix.tokens.length === cachedSuffix.tokens.length && suffix.tokens.every((v, i) => v === cachedSuffix.tokens[i]) && (useCachedSuffix = !0) : completeOptions.suffixMatchCriteria === "levenshteineditdistance" && suffix.tokens.length > 0 && completeOptions.suffixMatchThreshold > 0 && 100 * findEditDistanceScore(suffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH), cachedSuffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH))?.score < completeOptions.suffixMatchThreshold * Math.min(MAX_EDIT_DISTANCE_LENGTH, suffix.tokens.length) && (useCachedSuffix = !0), useCachedSuffix === !0 && cachedSuffix.tokens.length <= suffixTargetTokens ? (cachedSuffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - cachedSuffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), promptInfo.suffix = cachedSuffix.text, promptInfo.suffixLength = cachedSuffix.tokens.length) : (promptInfo.suffix = suffix.text, promptInfo.suffixLength = suffix.tokens.length, cachedSuffix = suffix), promptInfo;
    }
  }
  getPrompt(getPrompt, "ls");
  __name(getPrompt, "getPrompt");
  var ProviderTimeoutError = class extends Error {
      static {
        __name(this, "ge");
      }
      static {
        __name(this, "ProviderTimeoutError");
      }
      constructor(message) {
        super(message), this.name = "ProviderTimeoutError";
      }
    },
    SnippetProvider = class {
      static {
        __name(this, "oe");
      }
      static {
        __name(this, "SnippetProvider");
      }
      constructor(workerProxy) {
        this.api = workerProxy;
      }
      getSnippets(context, signal) {
        return new Promise((resolve, reject) => {
          signal.aborted && reject({
            error: new ProviderTimeoutError("provider aborted"),
            providerType: this.type
          }), signal.addEventListener("abort", () => {
            reject({
              error: new ProviderTimeoutError(`max runtime exceeded: ${TIMEOUT_MS} ms`),
              providerType: this.type
            });
          }, {
            once: !0
          });
          let startTime = performance.now();
          this.buildSnippets(context).then(snippets => {
            let endTime = performance.now();
            resolve({
              snippets: snippets,
              providerType: this.type,
              runtime: endTime - startTime
            });
          }).catch(error => {
            reject({
              error: error,
              providerType: this.type
            });
          });
        });
      }
    },
    LanguageSnippetProvider = class extends SnippetProvider {
      static {
        __name(this, "Rt");
      }
      constructor() {
        super(...arguments), this.type = "language";
      }
      static {
        __name(this, "LanguageSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getLanguageMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    },
    LocalImportContextSnippetProvider = class extends SnippetProvider {
      static {
        __name(this, "Dt");
      }
      constructor() {
        super(...arguments), this.type = "local-import-context";
      }
      static {
        __name(this, "LocalImportContextSnippetProvider");
      }
      formSnippets(imports, currentFile) {
        return imports.map(importPath => ({
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(importPath),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 1
        }));
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          options: options,
          fileSystem: fileSystem
        } = context;
        if (options.localImportContext == "nocontext") return [];
        let localImportContext = await this.api.extractLocalImportContext(currentFile, fileSystem);
        return this.formSnippets(localImportContext, currentFile);
      }
    },
    NeighborFilesProvider = class extends SnippetProvider {
      static {
        __name(this, "Bt");
      }
      constructor() {
        super(...arguments), this.type = "neighboring-tabs";
      }
      static {
        __name(this, "NeighborFilesProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          neighborFiles: neighborFiles,
          options: options,
          lineCursorHistory: lineCursorHistory
        } = context;
        return options && neighborFiles && neighborFiles.length && options.neighboringTabs !== "none" ? await this.api.getNeighborSnippets(currentFile, neighborFiles, options.neighboringSnippetTypes, options.neighboringTabs, options.snippetSelection, options.snippetSelectionK, lineCursorHistory, options.cursorSnippetsPickingStrategy) : [];
      }
    },
    PathSnippetProvider = class extends SnippetProvider {
      static {
        __name(this, "Wt");
      }
      constructor() {
        super(...arguments), this.type = "path";
      }
      static {
        __name(this, "PathSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getPathMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    },
    import_path = require("path"),
    import_worker_threads = require("worker_threads"),
    import_path = require("path"),
    import_vscode_uri = ct(Jr());
  function resolveLocalTypeScriptImport(importerPath, imp) {
    let src = imp.namedChild(1)?.text.slice(1, -1);
    if (!src || !src.startsWith(".")) return null;
    if ((0, Ee.extname)(src) === "") src = src + ".ts";else if ((0, Ee.extname)(src) !== ".ts") return null;
    return (0, Ee.join)((0, Ee.dirname)(importerPath), src);
  }
  resolveLocalTypeScriptImport(resolveLocalTypeScriptImport, "us");
  __name(resolveLocalTypeScriptImport, "resolveLocalTypeScriptImport");
  function getTypescriptImportedNames(imp) {
    let names = [];
    if (imp.namedChild(0)?.type === "import_clause") {
      let importClause = imp.namedChild(0);
      if (importClause?.namedChild(0)?.type === "named_imports") {
        let namedImports = importClause.namedChild(0);
        for (let namedImport of namedImports?.namedChildren ?? []) if (namedImport.type === "import_specifier") {
          let name = namedImport.childForFieldName("name")?.text;
          if (name) {
            let alias = namedImport.childForFieldName("alias")?.text;
            names.push({
              name: name,
              alias: alias
            });
          }
        }
      }
    }
    return names;
  }
  getTypescriptImportedNames(getTypescriptImportedNames, "cs");
  __name(getTypescriptImportedNames, "getTypescriptImportedNames");
  var exportsCache = new Map(),
    EXPORTS_CACHE_LOW_WATER_MARK = 1e3,
    EXPORTS_CACHE_HIGH_WATER_MARK = 2e3;
  function extractTypeScriptDeclaration(srcString, defn) {
    let name = defn?.childForFieldName("name")?.text ?? "";
    switch (defn?.type) {
      case "ambient_declaration":
        return extractTypeScriptDeclaration(srcString, defn.namedChild(0));
      case "interface_declaration":
      case "enum_declaration":
      case "type_alias_declaration":
        return {
          name: name,
          decl: defn.text
        };
      case "function_declaration":
      case "function_signature":
        return {
          name: name,
          decl: extractTypeScriptFunctionDeclaration(srcString, defn)
        };
      case "class_declaration":
        {
          let memberDecls = extractTypeScriptBodyDecls(srcString, defn),
            decl = "";
          if (memberDecls) {
            let body = defn.childForFieldName("body");
            decl = `declare ${srcString.substring(defn.startIndex, body.startIndex + 1)}`, decl += memberDecls.map(d => `
` + d).join(""), decl += `
}`;
          }
          return {
            name: name,
            decl: decl
          };
        }
    }
    return {
      name: name,
      decl: ""
    };
  }
  extractTypeScriptDeclaration(extractTypeScriptDeclaration, "Xr");
  __name(extractTypeScriptDeclaration, "extractTypeScriptDeclaration");
  function extractTypeScriptFunctionDeclaration(srcString, defn) {
    let endIndex = defn.childForFieldName("return_type")?.endIndex ?? defn.childForFieldName("parameters")?.endIndex;
    if (endIndex !== void 0) {
      let signature = srcString.substring(defn.startIndex, endIndex) + ";";
      return defn.type === "function_declaration" || defn.type === "function_signature" ? "declare " + signature : signature;
    }
    return "";
  }
  extractTypeScriptFunctionDeclaration(extractTypeScriptFunctionDeclaration, "Yr");
  __name(extractTypeScriptFunctionDeclaration, "extractTypeScriptFunctionDeclaration");
  function getIndentation(srcString, node) {
    let i = node.startIndex - 1;
    for (; i >= 0 && (srcString[i] === " " || srcString[i] === "	");) i--;
    if (i < 0 || srcString[i] === `
`) return srcString.substring(i + 1, node.startIndex);
  }
  getIndentation(getIndentation, "ps");
  __name(getIndentation, "getIndentation");
  function getDocComment(srcString, node) {
    let docCommentNode = getFirstPrecedingComment(node);
    return docCommentNode ? srcString.substring(docCommentNode.startIndex, node.startIndex) : "";
  }
  getDocComment(getDocComment, "ei");
  __name(getDocComment, "getDocComment");
  function extractTypeScriptMemberDeclaration(srcString, defn) {
    if (defn?.firstChild?.type === "accessibility_modifier" && defn.firstChild.text === "private") return "";
    let commentNode = getFirstPrecedingComment(defn),
      indentation = getIndentation(srcString, commentNode ?? defn) ?? "  ",
      docComment = getDocComment(srcString, defn);
    switch (defn.type) {
      case "ambient_declaration":
        let inner = defn.namedChild(0);
        return inner ? indentation + docComment + extractTypeScriptMemberDeclaration(srcString, inner) : "";
      case "method_definition":
      case "method_signature":
        return indentation + docComment + extractTypeScriptFunctionDeclaration(srcString, defn);
      case "public_field_definition":
        {
          let endIndex = defn.childForFieldName("type")?.endIndex ?? defn.childForFieldName("name")?.endIndex;
          if (endIndex !== void 0) return indentation + docComment + srcString.substring(defn.startIndex, endIndex) + ";";
        }
    }
    return "";
  }
  extractTypeScriptMemberDeclaration(extractTypeScriptMemberDeclaration, "ti");
  __name(extractTypeScriptMemberDeclaration, "extractTypeScriptMemberDeclaration");
  function extractTypeScriptBodyDecls(srcString, defn) {
    let body = defn.childForFieldName("body");
    return body ? body.namedChildren.map(member => extractTypeScriptMemberDeclaration(srcString, member)).filter(decl => decl) : void 0;
  }
  extractTypeScriptBodyDecls(extractTypeScriptBodyDecls, "ms");
  __name(extractTypeScriptBodyDecls, "extractTypeScriptBodyDecls");
  async function getExportedDeclarations(uri, lang, fs) {
    let exports = new Map(),
      mtime = -1;
    try {
      mtime = (await fs.stat(uri)).mtime;
    } catch {
      return exports;
    }
    let entry = exportsCache.get(uri);
    if (entry && entry.mtime === mtime) return entry.exports;
    if (lang === "typescript") {
      let tree = null;
      try {
        let srcString = (await fs.readFile(uri)).toString();
        tree = await parseTreeSitter(lang, srcString);
        for (let em of queryExports(lang, tree.rootNode)) for (let ec of em.captures) {
          let exp = ec.node;
          if (exp.type === "export_statement") {
            let decl = exp.childForFieldName("declaration");
            if (decl?.hasError()) continue;
            let {
              name: name,
              decl: exportedDecl
            } = extractTypeScriptDeclaration(srcString, decl);
            if (name) {
              exportedDecl = getDocComment(srcString, exp) + exportedDecl;
              let exportedDecls = exports.get(name);
              exportedDecls || (exportedDecls = [], exports.set(name, exportedDecls)), exportedDecls.push(exportedDecl);
            }
          }
        }
      } catch {} finally {
        tree && tree.delete();
      }
    }
    if (exportsCache.size > EXPORTS_CACHE_HIGH_WATER_MARK) {
      for (let key of exportsCache.keys()) if (exportsCache.delete(key), exports.size <= EXPORTS_CACHE_LOW_WATER_MARK) break;
    }
    return exportsCache.set(uri, {
      mtime: mtime,
      exports: exports
    }), exports;
  }
  getExportedDeclarations(getExportedDeclarations, "hs");
  __name(getExportedDeclarations, "getExportedDeclarations");
  function getTypeScriptImports(root) {
    let imports = [];
    for (let toplevelStmt of root.namedChildren) toplevelStmt.type === "import_statement" && imports.push(toplevelStmt);
    return imports;
  }
  getTypeScriptImports(getTypeScriptImports, "gs");
  __name(getTypeScriptImports, "getTypeScriptImports");
  var localImportRegex = /^\s*import\s*(type|)\s*\{[^}]*\}\s*from\s*['"]\./gm;
  function lastTypeScriptLocalImportOffset(source) {
    let lastImport = -1;
    localImportRegex.lastIndex = -1;
    let m;
    do m = localImportRegex.exec(source), m && (lastImport = localImportRegex.lastIndex + m.length); while (m);
    if (lastImport === -1) return -1;
    let newlineAfterLastImport = source.indexOf(`
`, lastImport);
    return newlineAfterLastImport !== -1 ? newlineAfterLastImport : source.length;
  }
  lastTypeScriptLocalImportOffset(lastTypeScriptLocalImportOffset, "bs");
  __name(lastTypeScriptLocalImportOffset, "lastTypeScriptLocalImportOffset");
  async function extractTypeScriptLocalImportContext(source, uri, fs) {
    let languageId = "typescript",
      localImportContext = [],
      lastImportOffset = lastTypeScriptLocalImportOffset(source);
    if (lastImportOffset === -1) return localImportContext;
    source = source.substring(0, lastImportOffset);
    let tree = await parseTreeSitter(languageId, source);
    try {
      for (let imp of getTypeScriptImports(tree.rootNode)) {
        let srcUri = resolveLocalTypeScriptImport(uri, imp);
        if (!srcUri) continue;
        let importedNames = getTypescriptImportedNames(imp);
        if (importedNames.length === 0) continue;
        let exports = await getExportedDeclarations(srcUri, languageId, fs);
        for (let importedName of importedNames) exports.has(importedName.name) && localImportContext.push(...exports.get(importedName.name));
      }
    } finally {
      tree.delete();
    }
    return localImportContext;
  }
  extractTypeScriptLocalImportContext(extractTypeScriptLocalImportContext, "ys");
  __name(extractTypeScriptLocalImportContext, "extractTypeScriptLocalImportContext");
  async function extractLocalImportContext(doc, fs) {
    let {
        source: source,
        languageId: languageId
      } = doc,
      uri = Qr.URI.parse(doc.uri);
    return languageId === "typescript" && uri.scheme === "file" ? extractTypeScriptLocalImportContext(source, uri.fsPath, fs ?? defaultFileSystem) : [];
  }
  extractLocalImportContext(extractLocalImportContext, "ni");
  __name(extractLocalImportContext, "extractLocalImportContext");
  function sleep(delay) {
    return new Promise(resolve => {
      setTimeout(() => resolve(`delay: ${delay}`), delay);
    });
  }
  sleep(sleep, "ia");
  __name(sleep, "sleep");
  var workerFns = ["getNeighborSnippets", "extractLocalImportContext", "sleep"],
    WorkerProxy = class {
      static {
        __name(this, "er");
      }
      constructor() {
        this.nextHandlerId = 0, this.handlers = new Map(), this.fns = new Map(), this.extractLocalImportContext = extractLocalImportContext, this.getNeighborSnippets = getNeighborSnippets, this.sleep = sleep, !ae.isMainThread && ae.workerData?.port && (Di(), process.cwd = () => ae.workerData.cwd, this.configureWorkerResponse(ae.workerData.port));
      }
      static {
        __name(this, "WorkerProxy");
      }
      initWorker() {
        let {
          port1: port1,
          port2: port2
        } = new ae.MessageChannel();
        this.port = port1, this.worker = new ae.Worker((0, Wi.resolve)(__dirname, "..", "dist", "workerProxy.js"), {
          workerData: {
            port: port2,
            cwd: process.cwd()
          },
          transferList: [port2]
        }), this.port.on("message", m => this.handleMessage(m)), this.port.on("error", e => this.handleError(e));
      }
      startThreading() {
        if (this.worker) throw new Error("Worker thread already initialized.");
        this.proxyFunctions(), this.initWorker();
      }
      stopThreading() {
        this.worker && (this.worker.terminate(), this.worker.removeAllListeners(), this.worker = void 0, this.unproxyFunctions(), this.handlers.clear());
      }
      proxyFunctions() {
        for (let fn of workerFns) this.fns.set(fn, this[fn]), this.proxy(fn);
      }
      unproxyFunctions() {
        for (let fn of workerFns) {
          let originalFn = this.fns.get(fn);
          if (originalFn) this[fn] = originalFn;else throw new Error(`Unproxy function not found: ${fn}`);
        }
      }
      configureWorkerResponse(port) {
        this.port = port, this.port.on("message", async ({
          id: id,
          fn: fn,
          args: args
        }) => {
          let proxiedFunction = this[fn];
          if (!proxiedFunction) throw new Error(`Function not found: ${fn}`);
          try {
            let res = await proxiedFunction.apply(this, args);
            this.port.postMessage({
              id: id,
              res: res
            });
          } catch (err) {
            if (!(err instanceof Error)) throw err;
            typeof err.code == "string" ? this.port.postMessage({
              id: id,
              err: err,
              code: err.code
            }) : this.port.postMessage({
              id: id,
              err: err
            });
          }
        });
      }
      handleMessage({
        id: id,
        err: err,
        code: code,
        res: res
      }) {
        let handler = this.handlers.get(id);
        handler && (this.handlers.delete(id), err ? (err.code = code, handler.reject(err)) : handler.resolve(res));
      }
      handleError(maybeError) {
        console.log(maybeError);
        let err;
        if (maybeError instanceof Error) {
          err = maybeError, err.code === "MODULE_NOT_FOUND" && err.message?.endsWith("workerProxy.js'") && (err = new Error("Failed to load workerProxy.js"), err.code = "CopilotPromptLoadFailure");
          let ourStack = new Error().stack;
          err.stack && ourStack?.match(/^Error\n/) && (err.stack += ourStack.replace(/^Error/, ""));
        } else maybeError?.name === "ExitStatus" && typeof maybeError.status == "number" ? (err = new Error(`workerProxy.js exited with status ${maybeError.status}`), err.code = `CopilotPromptWorkerExit${maybeError.status}`) : err = new Error(`Non-error thrown: ${maybeError}`);
        for (let handler of this.handlers.values()) handler.reject(err);
        throw err;
      }
      proxy(fn) {
        this[fn] = function (...args) {
          let id = this.nextHandlerId++;
          return new Promise((resolve, reject) => {
            this.handlers.set(id, {
              resolve: resolve,
              reject: reject
            }), this.port?.postMessage({
              id: id,
              fn: fn,
              args: args
            });
          });
        };
      }
    },
    workerProxy = new WorkerProxy(),
    TIMEOUT_MS = 300,
    defaultProviders = [LanguageSnippetProvider, PathSnippetProvider, NeighborFilesProvider, LocalImportContextSnippetProvider];
  function isFulfilledResult(result) {
    return result.status === "fulfilled";
  }
  isFulfilledResult(isFulfilledResult, "Ui");
  __name(isFulfilledResult, "isFulfilledResult");
  function isRejectedResult(result) {
    return result.status === "rejected";
  }
  isRejectedResult(isRejectedResult, "sa");
  __name(isRejectedResult, "isRejectedResult");
  function providersSnippets(results) {
    return results.filter(isFulfilledResult).flatMap(r => r.value.snippets);
  }
  providersSnippets(providersSnippets, "zi");
  __name(providersSnippets, "providersSnippets");
  function providersErrors(results) {
    return results.filter(isRejectedResult).flatMap(r => r.reason);
  }
  providersErrors(providersErrors, "qi");
  __name(providersErrors, "providersErrors");
  function providersPerformance(results) {
    let runtimes = {},
      timeouts = {};
    return results.forEach(result => {
      isFulfilledResult(result) ? runtimes[result.value.providerType] = Math.round(result.value.runtime) : result.reason.error instanceof ProviderTimeoutError && (timeouts[result.reason.providerType] = !0);
    }), {
      runtimes: runtimes,
      timeouts: timeouts
    };
  }
  providersPerformance(providersPerformance, "ji");
  __name(providersPerformance, "providersPerformance");
  var SnippetOrchestrator = class {
      static {
        __name(this, "$t");
      }
      constructor(providers = defaultProviders) {
        this.startThreading = () => workerProxy.startThreading(), this.stopThreading = () => workerProxy.stopThreading(), this.providers = providers.map(provider => new provider(workerProxy));
      }
      static {
        __name(this, "SnippetOrchestrator");
      }
      async getSnippets(context) {
        let signal = AbortSignal.timeout(TIMEOUT_MS);
        return Promise.allSettled(this.providers.map(provider => provider.getSnippets(context, signal)));
      }
    },
    BaseBlockParser = class {
      static {
        __name(this, "Gt");
      }
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        this.languageId = languageId, this.nodeMatch = nodeMatch, this.nodeTypesWithBlockOrStmtChild = nodeTypesWithBlockOrStmtChild;
      }
      static {
        __name(this, "BaseBlockParser");
      }
      async getNodeMatchAtPosition(text, offset, cb) {
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeToComplete = tree.rootNode.descendantForIndex(offset);
          for (; nodeToComplete;) {
            let blockNodeType = this.nodeMatch[nodeToComplete.type];
            if (blockNodeType) {
              if (!this.nodeTypesWithBlockOrStmtChild.has(nodeToComplete.type)) break;
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(nodeToComplete.type);
              if ((fieldLabel == "" ? nodeToComplete.namedChildren[0] : nodeToComplete.childForFieldName(fieldLabel))?.type == blockNodeType) break;
            }
            nodeToComplete = nodeToComplete.parent;
          }
          return nodeToComplete ? cb(nodeToComplete) : void 0;
        } finally {
          tree.delete();
        }
      }
      getNextBlockAtPosition(text, offset, cb) {
        return this.getNodeMatchAtPosition(text, offset, nodeToComplete => {
          let block = nodeToComplete.children.reverse().find(x => x.type == this.nodeMatch[nodeToComplete.type]);
          if (block) {
            if (this.languageId == "python" && block.parent) {
              let parent = block.parent.type == ":" ? block.parent.parent : block.parent,
                nextComment = parent?.nextSibling;
              for (; nextComment && nextComment.type == "comment";) {
                let commentInline = nextComment.startPosition.row == block.endPosition.row && nextComment.startPosition.column >= block.endPosition.column,
                  commentAtEnd = nextComment.startPosition.row > parent.endPosition.row && nextComment.startPosition.column > parent.startPosition.column;
                if (commentInline || commentAtEnd) block = nextComment, nextComment = nextComment.nextSibling;else break;
              }
            }
            if (!(block.endIndex >= block.tree.rootNode.endIndex - 1 && (block.hasError() || block.parent.hasError()))) return cb(block);
          }
        });
      }
      async isBlockBodyFinished(prefix, completion, offset) {
        let solution = (prefix + completion).trimEnd(),
          endIndex = await this.getNextBlockAtPosition(solution, offset, block => block.endIndex);
        if (endIndex !== void 0 && endIndex < solution.length) {
          let lengthOfBlock = endIndex - prefix.length;
          return lengthOfBlock > 0 ? lengthOfBlock : void 0;
        }
      }
      getNodeStart(text, offset) {
        let solution = text.trimEnd();
        return this.getNodeMatchAtPosition(solution, offset, block => block.startIndex);
      }
    },
    RegexBasedBlockParser = class extends BaseBlockParser {
      static {
        __name(this, "Kt");
      }
      constructor(languageId, blockEmptyMatch, lineMatch, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild), this.blockEmptyMatch = blockEmptyMatch, this.lineMatch = lineMatch;
      }
      static {
        __name(this, "RegexBasedBlockParser");
      }
      isBlockStart(line) {
        return this.lineMatch.test(line.trimStart());
      }
      async isBlockBodyEmpty(text, offset) {
        let res = await this.getNextBlockAtPosition(text, offset, block => {
          block.startIndex < offset && (offset = block.startIndex);
          let blockText = text.substring(offset, block.endIndex).trim();
          return blockText == "" || blockText.replace(/\s/g, "") == this.blockEmptyMatch;
        });
        return res === void 0 || res;
      }
      async isEmptyBlockStart(text, offset) {
        return offset = rewindToNearestNonWs(text, offset), this.isBlockStart(getLineAtOffset(text, offset)) && this.isBlockBodyEmpty(text, offset);
      }
    };
  function getLineAtOffset(text, offset) {
    let prevNewline = text.lastIndexOf(`
`, offset - 1),
      nextNewline = text.indexOf(`
`, offset);
    return nextNewline < 0 && (nextNewline = text.length), text.slice(prevNewline + 1, nextNewline);
  }
  getLineAtOffset(getLineAtOffset, "aa");
  __name(getLineAtOffset, "getLineAtOffset");
  function rewindToNearestNonWs(text, offset) {
    let result = offset;
    for (; result > 0 && /\s/.test(text.charAt(result - 1));) result--;
    return result;
  }
  rewindToNearestNonWs(rewindToNearestNonWs, "Vi");
  __name(rewindToNearestNonWs, "rewindToNearestNonWs");
  function indent(nd, source) {
    let startIndex = nd.startIndex,
      lineStart = nd.startIndex - nd.startPosition.column,
      prefix = source.substring(lineStart, startIndex);
    if (/^\s*$/.test(prefix)) return prefix;
  }
  indent(indent, "Hi");
  __name(indent, "indent");
  function outdented(fst, snd, source) {
    if (snd.startPosition.row <= fst.startPosition.row) return !1;
    let fstIndent = indent(fst, source),
      sndIndent = indent(snd, source);
    return fstIndent !== void 0 && sndIndent !== void 0 && fstIndent.startsWith(sndIndent);
  }
  outdented(outdented, "la");
  __name(outdented, "outdented");
  var TreeSitterBasedBlockParser = class extends BaseBlockParser {
      static {
        __name(this, "qe");
      }
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild, startKeywords, blockNodeType, emptyStatementType, curlyBraceLanguage) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild), this.startKeywords = startKeywords, this.blockNodeType = blockNodeType, this.emptyStatementType = emptyStatementType, this.curlyBraceLanguage = curlyBraceLanguage;
      }
      static {
        __name(this, "TreeSitterBasedBlockParser");
      }
      isBlockEmpty(block, offset) {
        let trimmed = block.text.trim();
        return this.curlyBraceLanguage && (trimmed.startsWith("{") && (trimmed = trimmed.slice(1)), trimmed.endsWith("}") && (trimmed = trimmed.slice(0, -1)), trimmed = trimmed.trim()), !!(trimmed.length == 0 || this.languageId == "python" && (block.parent?.type == "class_definition" || block.parent?.type == "function_definition") && block.children.length == 1 && queryPythonIsDocstring(block.parent));
      }
      async isEmptyBlockStart(text, offset) {
        if (offset > text.length) throw new RangeError("Invalid offset");
        for (let i = offset; i < text.length && text.charAt(i) != `
`; i++) if (/\S/.test(text.charAt(i))) return !1;
        offset = rewindToNearestNonWs(text, offset);
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeAtPos = tree.rootNode.descendantForIndex(offset - 1);
          if (nodeAtPos == null || this.curlyBraceLanguage && nodeAtPos.type == "}") return !1;
          if ((this.languageId == "javascript" || this.languageId == "typescript") && nodeAtPos.parent && nodeAtPos.parent.type == "object" && nodeAtPos.parent.text.trim() == "{") return !0;
          if (this.languageId == "typescript") {
            let currNode = nodeAtPos;
            for (; currNode.parent;) {
              if (currNode.type == "function_signature" || currNode.type == "method_signature") {
                let next = nodeAtPos.nextSibling;
                return next && currNode.hasError() && outdented(currNode, next, text) ? !0 : !currNode.children.find(c => c.type == ";") && currNode.endIndex <= offset;
              }
              currNode = currNode.parent;
            }
          }
          let errorNode = null,
            blockNode = null,
            blockParentNode = null,
            currNode = nodeAtPos;
          for (; currNode != null;) {
            if (currNode.type == this.blockNodeType) {
              blockNode = currNode;
              break;
            }
            if (this.nodeMatch[currNode.type]) {
              blockParentNode = currNode;
              break;
            }
            if (currNode.type == "ERROR") {
              errorNode = currNode;
              break;
            }
            currNode = currNode.parent;
          }
          if (blockNode != null) {
            if (!blockNode.parent || !this.nodeMatch[blockNode.parent.type]) return !1;
            if (this.languageId == "python") {
              let prevSibling = blockNode.previousSibling;
              if (prevSibling != null && prevSibling.hasError() && (prevSibling.text.startsWith('"""') || prevSibling.text.startsWith("'''"))) return !0;
            }
            return this.isBlockEmpty(blockNode, offset);
          }
          if (errorNode != null) {
            if (errorNode.previousSibling?.type == "module" || errorNode.previousSibling?.type == "internal_module" || errorNode.previousSibling?.type == "def") return !0;
            let children = [...errorNode.children].reverse(),
              keyword = children.find(child => this.startKeywords.includes(child.type)),
              block = children.find(child => child.type == this.blockNodeType);
            if (keyword) {
              switch (this.languageId) {
                case "python":
                  {
                    keyword.type == "try" && nodeAtPos.type == "identifier" && nodeAtPos.text.length > 4 && (block = children.find(child => child.hasError())?.children.find(child => child.type == "block"));
                    let colonNode,
                      parenCount = 0;
                    for (let child of errorNode.children) {
                      if (child.type == ":" && parenCount == 0) {
                        colonNode = child;
                        break;
                      }
                      child.type == "(" && (parenCount += 1), child.type == ")" && (parenCount -= 1);
                    }
                    if (colonNode && keyword.endIndex <= colonNode.startIndex && colonNode.nextSibling) {
                      if (keyword.type == "def") {
                        let sibling = colonNode.nextSibling;
                        if (sibling.type == '"' || sibling.type == "'" || sibling.type == "ERROR" && (sibling.text == '"""' || sibling.text == "'''")) return !0;
                      }
                      return !1;
                    }
                    break;
                  }
                case "javascript":
                  {
                    let formalParameters = children.find(child => child.type == "formal_parameters");
                    if (keyword.type == "class" && formalParameters) return !0;
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
                case "typescript":
                  {
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
              }
              return block && block.startIndex > keyword.endIndex ? this.isBlockEmpty(block, offset) : !0;
            }
          }
          if (blockParentNode != null) {
            let expectedType = this.nodeMatch[blockParentNode.type],
              block = blockParentNode.children.slice().reverse().find(x => x.type == expectedType);
            if (block) return this.isBlockEmpty(block, offset);
            if (this.nodeTypesWithBlockOrStmtChild.has(blockParentNode.type)) {
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(blockParentNode.type),
                child = fieldLabel == "" ? blockParentNode.children[0] : blockParentNode.childForFieldName(fieldLabel);
              if (child && child.type != this.blockNodeType && child.type != this.emptyStatementType) return !1;
            }
            return !0;
          }
          return !1;
        } finally {
          tree.delete();
        }
      }
    },
    wasmLanguageToBlockParser = {
      python: new TreeSitterBasedBlockParser("python", {
        class_definition: "block",
        elif_clause: "block",
        else_clause: "block",
        except_clause: "block",
        finally_clause: "block",
        for_statement: "block",
        function_definition: "block",
        if_statement: "block",
        try_statement: "block",
        while_statement: "block",
        with_statement: "block"
      }, new Map(), ["def", "class", "if", "elif", "else", "for", "while", "try", "except", "finally", "with"], "block", null, !1),
      javascript: new TreeSitterBasedBlockParser("javascript", {
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        method_definition: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        with_statement: "statement_block",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      typescript: new TreeSitterBasedBlockParser("typescript", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      tsx: new TreeSitterBasedBlockParser("typescriptreact", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      go: new RegexBasedBlockParser("go", "{}", /\b(func|if|else|for)\b/, {
        communication_case: "block",
        default_case: "block",
        expression_case: "block",
        for_statement: "block",
        func_literal: "block",
        function_declaration: "block",
        if_statement: "block",
        labeled_statement: "block",
        method_declaration: "block",
        type_case: "block"
      }, new Map()),
      ruby: new RegexBasedBlockParser("ruby", "end", /\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\b|->/, {
        begin_block: "}",
        block: "}",
        end_block: "}",
        lambda: "block",
        for: "do",
        until: "do",
        while: "do",
        case: "end",
        do: "end",
        if: "end",
        method: "end",
        module: "end",
        unless: "end",
        do_block: "end"
      }, new Map())
    };
  function getBlockParser(languageId) {
    return wasmLanguageToBlockParser[languageIdToWasmLanguage(languageId)];
  }
  getBlockParser(getBlockParser, "Jt");
  __name(getBlockParser, "getBlockParser");
  async function isEmptyBlockStart(languageId, text, offset) {
    return isSupportedLanguageId(languageId) ? getBlockParser(languageId).isEmptyBlockStart(text, offset) : !1;
  }
  isEmptyBlockStart(isEmptyBlockStart, "ca");
  __name(isEmptyBlockStart, "isEmptyBlockStart");
  async function isBlockBodyFinished(languageId, prefix, completion, offset) {
    if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).isBlockBodyFinished(prefix, completion, offset);
  }
  isBlockBodyFinished(isBlockBodyFinished, "da");
  __name(isBlockBodyFinished, "isBlockBodyFinished");
  async function getNodeStart(languageId, text, offset) {
    if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).getNodeStart(text, offset);
  }
  getNodeStart(getNodeStart, "_a");
  __name(getNodeStart, "getNodeStart");
  function createWorker() {
    return new $i.Worker((0, Zi.resolve)(__dirname, "..", "dist", "worker.js"), {
      workerData: {
        cwd: process.cwd()
      }
    });
  }
  createWorker(createWorker, "pa");
  __name(createWorker, "createWorker");
});
var require_core = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory() : typeof define == "function" && define.amd ? define([], factory) : root.CryptoJS = factory();
  })(exports, function () {
    var CryptoJS = CryptoJS || function (Math, undefined) {
      var crypto;
      if (typeof window < "u" && window.crypto && (crypto = window.crypto), typeof self < "u" && self.crypto && (crypto = self.crypto), typeof globalThis < "u" && globalThis.crypto && (crypto = globalThis.crypto), !crypto && typeof window < "u" && window.msCrypto && (crypto = window.msCrypto), !crypto && typeof global < "u" && global.crypto && (crypto = global.crypto), !crypto && typeof require == "function") try {
        crypto = require("crypto");
      } catch {}
      var cryptoSecureRandomInt = __name(function () {
          if (crypto) {
            if (typeof crypto.getRandomValues == "function") try {
              return crypto.getRandomValues(new Uint32Array(1))[0];
            } catch {}
            if (typeof crypto.randomBytes == "function") try {
              return crypto.randomBytes(4).readInt32LE();
            } catch {}
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, "cryptoSecureRandomInt"),
        create = Object.create || function () {
          function F() {}
          return __name(F, "F"), function (obj) {
            var subtype;
            return F.prototype = obj, subtype = new F(), F.prototype = null, subtype;
          };
        }(),
        C = {},
        C_lib = C.lib = {},
        Base = C_lib.Base = function () {
          return {
            extend: function (overrides) {
              var subtype = create(this);
              return overrides && subtype.mixIn(overrides), (!subtype.hasOwnProperty("init") || this.init === subtype.init) && (subtype.init = function () {
                subtype.$super.init.apply(this, arguments);
              }), subtype.init.prototype = subtype, subtype.$super = this, subtype;
            },
            create: function () {
              var instance = this.extend();
              return instance.init.apply(instance, arguments), instance;
            },
            init: function () {},
            mixIn: function (properties) {
              for (var propertyName in properties) properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]);
              properties.hasOwnProperty("toString") && (this.toString = properties.toString);
            },
            clone: function () {
              return this.init.prototype.extend(this);
            }
          };
        }(),
        WordArray = C_lib.WordArray = Base.extend({
          init: function (words, sigBytes) {
            words = this.words = words || [], sigBytes != undefined ? this.sigBytes = sigBytes : this.sigBytes = words.length * 4;
          },
          toString: function (encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function (wordArray) {
            var thisWords = this.words,
              thatWords = wordArray.words,
              thisSigBytes = this.sigBytes,
              thatSigBytes = wordArray.sigBytes;
            if (this.clamp(), thisSigBytes % 4) for (var i = 0; i < thatSigBytes; i++) {
              var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
            } else for (var j = 0; j < thatSigBytes; j += 4) thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
            return this.sigBytes += thatSigBytes, this;
          },
          clamp: function () {
            var words = this.words,
              sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8, words.length = Math.ceil(sigBytes / 4);
          },
          clone: function () {
            var clone = Base.clone.call(this);
            return clone.words = this.words.slice(0), clone;
          },
          random: function (nBytes) {
            for (var words = [], i = 0; i < nBytes; i += 4) words.push(cryptoSecureRandomInt());
            return new WordArray.init(words, nBytes);
          }
        }),
        C_enc = C.enc = {},
        Hex = C_enc.Hex = {
          stringify: function (wordArray) {
            for (var words = wordArray.words, sigBytes = wordArray.sigBytes, hexChars = [], i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16)), hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function (hexStr) {
            for (var hexStrLength = hexStr.length, words = [], i = 0; i < hexStrLength; i += 2) words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            return new WordArray.init(words, hexStrLength / 2);
          }
        },
        Latin1 = C_enc.Latin1 = {
          stringify: function (wordArray) {
            for (var words = wordArray.words, sigBytes = wordArray.sigBytes, latin1Chars = [], i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function (latin1Str) {
            for (var latin1StrLength = latin1Str.length, words = [], i = 0; i < latin1StrLength; i++) words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            return new WordArray.init(words, latin1StrLength);
          }
        },
        Utf8 = C_enc.Utf8 = {
          stringify: function (wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        },
        BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function () {
            this._data = new WordArray.init(), this._nDataBytes = 0;
          },
          _append: function (data) {
            typeof data == "string" && (data = Utf8.parse(data)), this._data.concat(data), this._nDataBytes += data.sigBytes;
          },
          _process: function (doFlush) {
            var processedWords,
              data = this._data,
              dataWords = data.words,
              dataSigBytes = data.sigBytes,
              blockSize = this.blockSize,
              blockSizeBytes = blockSize * 4,
              nBlocksReady = dataSigBytes / blockSizeBytes;
            doFlush ? nBlocksReady = Math.ceil(nBlocksReady) : nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            var nWordsReady = nBlocksReady * blockSize,
              nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) this._doProcessBlock(dataWords, offset);
              processedWords = dataWords.splice(0, nWordsReady), data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function () {
            var clone = Base.clone.call(this);
            return clone._data = this._data.clone(), clone;
          },
          _minBufferSize: 0
        }),
        Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function (cfg) {
            this.cfg = this.cfg.extend(cfg), this.reset();
          },
          reset: function () {
            BufferedBlockAlgorithm.reset.call(this), this._doReset();
          },
          update: function (messageUpdate) {
            return this._append(messageUpdate), this._process(), this;
          },
          finalize: function (messageUpdate) {
            messageUpdate && this._append(messageUpdate);
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function (hasher) {
            return function (message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function (hasher) {
            return function (message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        }),
        C_algo = C.algo = {};
      return C;
    }(Math);
    return CryptoJS;
  });
});
var require_x64_core = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (undefined) {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        X32WordArray = C_lib.WordArray,
        C_x64 = C.x64 = {},
        X64Word = C_x64.Word = Base.extend({
          init: function (high, low) {
            this.high = high, this.low = low;
          }
        }),
        X64WordArray = C_x64.WordArray = Base.extend({
          init: function (words, sigBytes) {
            words = this.words = words || [], sigBytes != undefined ? this.sigBytes = sigBytes : this.sigBytes = words.length * 8;
          },
          toX32: function () {
            for (var x64Words = this.words, x64WordsLength = x64Words.length, x32Words = [], i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high), x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function () {
            for (var clone = Base.clone.call(this), words = clone.words = this.words.slice(0), wordsLength = words.length, i = 0; i < wordsLength; i++) words[i] = words[i].clone();
            return clone;
          }
        });
    }(), CryptoJS;
  });
});
var require_lib_typedarrays = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      if (typeof ArrayBuffer == "function") {
        var C = CryptoJS,
          C_lib = C.lib,
          WordArray = C_lib.WordArray,
          superInit = WordArray.init,
          subInit = WordArray.init = function (typedArray) {
            if (typedArray instanceof ArrayBuffer && (typedArray = new Uint8Array(typedArray)), (typedArray instanceof Int8Array || typeof Uint8ClampedArray < "u" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) && (typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength)), typedArray instanceof Uint8Array) {
              for (var typedArrayByteLength = typedArray.byteLength, words = [], i = 0; i < typedArrayByteLength; i++) words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
              superInit.call(this, words, typedArrayByteLength);
            } else superInit.apply(this, arguments);
          };
        subInit.prototype = WordArray;
      }
    }(), CryptoJS.lib.WordArray;
  });
});
var require_enc_utf16 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        C_enc = C.enc,
        Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function (wordArray) {
            for (var words = wordArray.words, sigBytes = wordArray.sigBytes, utf16Chars = [], i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function (utf16Str) {
            for (var utf16StrLength = utf16Str.length, words = [], i = 0; i < utf16StrLength; i++) words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
      C_enc.Utf16LE = {
        stringify: function (wordArray) {
          for (var words = wordArray.words, sigBytes = wordArray.sigBytes, utf16Chars = [], i = 0; i < sigBytes; i += 2) {
            var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
            utf16Chars.push(String.fromCharCode(codePoint));
          }
          return utf16Chars.join("");
        },
        parse: function (utf16Str) {
          for (var utf16StrLength = utf16Str.length, words = [], i = 0; i < utf16StrLength; i++) words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
          return WordArray.create(words, utf16StrLength * 2);
        }
      };
      function swapEndian(word) {
        return word << 8 & 4278255360 | word >>> 8 & 16711935;
      }
      __name(swapEndian, "swapEndian");
    }(), CryptoJS.enc.Utf16;
  });
});
var require_enc_base64 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        C_enc = C.enc,
        Base64 = C_enc.Base64 = {
          stringify: function (wordArray) {
            var words = wordArray.words,
              sigBytes = wordArray.sigBytes,
              map = this._map;
            wordArray.clamp();
            for (var base64Chars = [], i = 0; i < sigBytes; i += 3) for (var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255, byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255, byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, triplet = byte1 << 16 | byte2 << 8 | byte3, j = 0; j < 4 && i + j * .75 < sigBytes; j++) base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            var paddingChar = map.charAt(64);
            if (paddingChar) for (; base64Chars.length % 4;) base64Chars.push(paddingChar);
            return base64Chars.join("");
          },
          parse: function (base64Str) {
            var base64StrLength = base64Str.length,
              map = this._map,
              reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) reverseMap[map.charCodeAt(j)] = j;
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              paddingIndex !== -1 && (base64StrLength = paddingIndex);
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
      function parseLoop(base64Str, base64StrLength, reverseMap) {
        for (var words = [], nBytes = 0, i = 0; i < base64StrLength; i++) if (i % 4) {
          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2,
            bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2,
            bitsCombined = bits1 | bits2;
          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8, nBytes++;
        }
        return WordArray.create(words, nBytes);
      }
      __name(parseLoop, "parseLoop");
    }(), CryptoJS.enc.Base64;
  });
});
var require_enc_base64url = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        C_enc = C.enc,
        Base64url = C_enc.Base64url = {
          stringify: function (wordArray, urlSafe) {
            urlSafe === void 0 && (urlSafe = !0);
            var words = wordArray.words,
              sigBytes = wordArray.sigBytes,
              map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            for (var base64Chars = [], i = 0; i < sigBytes; i += 3) for (var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255, byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255, byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, triplet = byte1 << 16 | byte2 << 8 | byte3, j = 0; j < 4 && i + j * .75 < sigBytes; j++) base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            var paddingChar = map.charAt(64);
            if (paddingChar) for (; base64Chars.length % 4;) base64Chars.push(paddingChar);
            return base64Chars.join("");
          },
          parse: function (base64Str, urlSafe) {
            urlSafe === void 0 && (urlSafe = !0);
            var base64StrLength = base64Str.length,
              map = urlSafe ? this._safe_map : this._map,
              reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) reverseMap[map.charCodeAt(j)] = j;
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              paddingIndex !== -1 && (base64StrLength = paddingIndex);
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
      function parseLoop(base64Str, base64StrLength, reverseMap) {
        for (var words = [], nBytes = 0, i = 0; i < base64StrLength; i++) if (i % 4) {
          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2,
            bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2,
            bitsCombined = bits1 | bits2;
          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8, nBytes++;
        }
        return WordArray.create(words, nBytes);
      }
      __name(parseLoop, "parseLoop");
    }(), CryptoJS.enc.Base64url;
  });
});
var require_md5 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (Math) {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_algo = C.algo,
        T = [];
      (function () {
        for (var i = 0; i < 64; i++) T[i] = Math.abs(Math.sin(i + 1)) * 4294967296 | 0;
      })();
      var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
          this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]);
        },
        _doProcessBlock: function (M, offset) {
          for (var i = 0; i < 16; i++) {
            var offset_i = offset + i,
              M_offset_i = M[offset_i];
            M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
          }
          var H = this._hash.words,
            M_offset_0 = M[offset + 0],
            M_offset_1 = M[offset + 1],
            M_offset_2 = M[offset + 2],
            M_offset_3 = M[offset + 3],
            M_offset_4 = M[offset + 4],
            M_offset_5 = M[offset + 5],
            M_offset_6 = M[offset + 6],
            M_offset_7 = M[offset + 7],
            M_offset_8 = M[offset + 8],
            M_offset_9 = M[offset + 9],
            M_offset_10 = M[offset + 10],
            M_offset_11 = M[offset + 11],
            M_offset_12 = M[offset + 12],
            M_offset_13 = M[offset + 13],
            M_offset_14 = M[offset + 14],
            M_offset_15 = M[offset + 15],
            a = H[0],
            b = H[1],
            c = H[2],
            d = H[3];
          a = FF(a, b, c, d, M_offset_0, 7, T[0]), d = FF(d, a, b, c, M_offset_1, 12, T[1]), c = FF(c, d, a, b, M_offset_2, 17, T[2]), b = FF(b, c, d, a, M_offset_3, 22, T[3]), a = FF(a, b, c, d, M_offset_4, 7, T[4]), d = FF(d, a, b, c, M_offset_5, 12, T[5]), c = FF(c, d, a, b, M_offset_6, 17, T[6]), b = FF(b, c, d, a, M_offset_7, 22, T[7]), a = FF(a, b, c, d, M_offset_8, 7, T[8]), d = FF(d, a, b, c, M_offset_9, 12, T[9]), c = FF(c, d, a, b, M_offset_10, 17, T[10]), b = FF(b, c, d, a, M_offset_11, 22, T[11]), a = FF(a, b, c, d, M_offset_12, 7, T[12]), d = FF(d, a, b, c, M_offset_13, 12, T[13]), c = FF(c, d, a, b, M_offset_14, 17, T[14]), b = FF(b, c, d, a, M_offset_15, 22, T[15]), a = GG(a, b, c, d, M_offset_1, 5, T[16]), d = GG(d, a, b, c, M_offset_6, 9, T[17]), c = GG(c, d, a, b, M_offset_11, 14, T[18]), b = GG(b, c, d, a, M_offset_0, 20, T[19]), a = GG(a, b, c, d, M_offset_5, 5, T[20]), d = GG(d, a, b, c, M_offset_10, 9, T[21]), c = GG(c, d, a, b, M_offset_15, 14, T[22]), b = GG(b, c, d, a, M_offset_4, 20, T[23]), a = GG(a, b, c, d, M_offset_9, 5, T[24]), d = GG(d, a, b, c, M_offset_14, 9, T[25]), c = GG(c, d, a, b, M_offset_3, 14, T[26]), b = GG(b, c, d, a, M_offset_8, 20, T[27]), a = GG(a, b, c, d, M_offset_13, 5, T[28]), d = GG(d, a, b, c, M_offset_2, 9, T[29]), c = GG(c, d, a, b, M_offset_7, 14, T[30]), b = GG(b, c, d, a, M_offset_12, 20, T[31]), a = HH(a, b, c, d, M_offset_5, 4, T[32]), d = HH(d, a, b, c, M_offset_8, 11, T[33]), c = HH(c, d, a, b, M_offset_11, 16, T[34]), b = HH(b, c, d, a, M_offset_14, 23, T[35]), a = HH(a, b, c, d, M_offset_1, 4, T[36]), d = HH(d, a, b, c, M_offset_4, 11, T[37]), c = HH(c, d, a, b, M_offset_7, 16, T[38]), b = HH(b, c, d, a, M_offset_10, 23, T[39]), a = HH(a, b, c, d, M_offset_13, 4, T[40]), d = HH(d, a, b, c, M_offset_0, 11, T[41]), c = HH(c, d, a, b, M_offset_3, 16, T[42]), b = HH(b, c, d, a, M_offset_6, 23, T[43]), a = HH(a, b, c, d, M_offset_9, 4, T[44]), d = HH(d, a, b, c, M_offset_12, 11, T[45]), c = HH(c, d, a, b, M_offset_15, 16, T[46]), b = HH(b, c, d, a, M_offset_2, 23, T[47]), a = II(a, b, c, d, M_offset_0, 6, T[48]), d = II(d, a, b, c, M_offset_7, 10, T[49]), c = II(c, d, a, b, M_offset_14, 15, T[50]), b = II(b, c, d, a, M_offset_5, 21, T[51]), a = II(a, b, c, d, M_offset_12, 6, T[52]), d = II(d, a, b, c, M_offset_3, 10, T[53]), c = II(c, d, a, b, M_offset_10, 15, T[54]), b = II(b, c, d, a, M_offset_1, 21, T[55]), a = II(a, b, c, d, M_offset_8, 6, T[56]), d = II(d, a, b, c, M_offset_15, 10, T[57]), c = II(c, d, a, b, M_offset_6, 15, T[58]), b = II(b, c, d, a, M_offset_13, 21, T[59]), a = II(a, b, c, d, M_offset_4, 6, T[60]), d = II(d, a, b, c, M_offset_11, 10, T[61]), c = II(c, d, a, b, M_offset_2, 15, T[62]), b = II(b, c, d, a, M_offset_9, 21, T[63]), H[0] = H[0] + a | 0, H[1] = H[1] + b | 0, H[2] = H[2] + c | 0, H[3] = H[3] + d | 0;
        },
        _doFinalize: function () {
          var data = this._data,
            dataWords = data.words,
            nBitsTotal = this._nDataBytes * 8,
            nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          var nBitsTotalH = Math.floor(nBitsTotal / 4294967296),
            nBitsTotalL = nBitsTotal;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360, dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360, data.sigBytes = (dataWords.length + 1) * 4, this._process();
          for (var hash = this._hash, H = hash.words, i = 0; i < 4; i++) {
            var H_i = H[i];
            H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
          }
          return hash;
        },
        clone: function () {
          var clone = Hasher.clone.call(this);
          return clone._hash = this._hash.clone(), clone;
        }
      });
      function FF(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      __name(FF, "FF");
      function GG(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      __name(GG, "GG");
      function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      __name(HH, "HH");
      function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return (n << s | n >>> 32 - s) + b;
      }
      __name(II, "II"), C.MD5 = Hasher._createHelper(MD5), C.HmacMD5 = Hasher._createHmacHelper(MD5);
    }(Math), CryptoJS.MD5;
  });
});
var require_sha1 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_algo = C.algo,
        W = [],
        SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function () {
            this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function (M, offset) {
            for (var H = this._hash.words, a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], i = 0; i < 80; i++) {
              if (i < 16) W[i] = M[offset + i] | 0;else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              i < 20 ? t += (b & c | ~b & d) + 1518500249 : i < 40 ? t += (b ^ c ^ d) + 1859775393 : i < 60 ? t += (b & c | b & d | c & d) - 1894007588 : t += (b ^ c ^ d) - 899497514, e = d, d = c, c = b << 30 | b >>> 2, b = a, a = t;
            }
            H[0] = H[0] + a | 0, H[1] = H[1] + b | 0, H[2] = H[2] + c | 0, H[3] = H[3] + d | 0, H[4] = H[4] + e | 0;
          },
          _doFinalize: function () {
            var data = this._data,
              dataWords = data.words,
              nBitsTotal = this._nDataBytes * 8,
              nBitsLeft = data.sigBytes * 8;
            return dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32, dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296), dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal, data.sigBytes = dataWords.length * 4, this._process(), this._hash;
          },
          clone: function () {
            var clone = Hasher.clone.call(this);
            return clone._hash = this._hash.clone(), clone;
          }
        });
      C.SHA1 = Hasher._createHelper(SHA1), C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
    }(), CryptoJS.SHA1;
  });
});
var require_sha256 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (Math) {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_algo = C.algo,
        H = [],
        K = [];
      (function () {
        function isPrime(n) {
          for (var sqrtN = Math.sqrt(n), factor = 2; factor <= sqrtN; factor++) if (!(n % factor)) return !1;
          return !0;
        }
        __name(isPrime, "isPrime");
        function getFractionalBits(n) {
          return (n - (n | 0)) * 4294967296 | 0;
        }
        __name(getFractionalBits, "getFractionalBits");
        for (var n = 2, nPrime = 0; nPrime < 64;) isPrime(n) && (nPrime < 8 && (H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2))), K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3)), nPrime++), n++;
      })();
      var W = [],
        SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function (M, offset) {
            for (var H = this._hash.words, a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7], i = 0; i < 64; i++) {
              if (i < 16) W[i] = M[offset + i] | 0;else {
                var gamma0x = W[i - 15],
                  gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3,
                  gamma1x = W[i - 2],
                  gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g,
                maj = a & b ^ a & c ^ b & c,
                sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22),
                sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25),
                t1 = h + sigma1 + ch + K[i] + W[i],
                t2 = sigma0 + maj;
              h = g, g = f, f = e, e = d + t1 | 0, d = c, c = b, b = a, a = t1 + t2 | 0;
            }
            H[0] = H[0] + a | 0, H[1] = H[1] + b | 0, H[2] = H[2] + c | 0, H[3] = H[3] + d | 0, H[4] = H[4] + e | 0, H[5] = H[5] + f | 0, H[6] = H[6] + g | 0, H[7] = H[7] + h | 0;
          },
          _doFinalize: function () {
            var data = this._data,
              dataWords = data.words,
              nBitsTotal = this._nDataBytes * 8,
              nBitsLeft = data.sigBytes * 8;
            return dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32, dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296), dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal, data.sigBytes = dataWords.length * 4, this._process(), this._hash;
          },
          clone: function () {
            var clone = Hasher.clone.call(this);
            return clone._hash = this._hash.clone(), clone;
          }
        });
      C.SHA256 = Hasher._createHelper(SHA256), C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
    }(Math), CryptoJS.SHA256;
  });
});
var require_sha224 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Ny()) : typeof define == "function" && define.amd ? define(["./core", "./sha256"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        C_algo = C.algo,
        SHA256 = C_algo.SHA256,
        SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function () {
            this._hash = new WordArray.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
          },
          _doFinalize: function () {
            var hash = SHA256._doFinalize.call(this);
            return hash.sigBytes -= 4, hash;
          }
        });
      C.SHA224 = SHA256._createHelper(SHA224), C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
    }(), CryptoJS.SHA224;
  });
});
var require_sha512 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), O3()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Hasher = C_lib.Hasher,
        C_x64 = C.x64,
        X64Word = C_x64.Word,
        X64WordArray = C_x64.WordArray,
        C_algo = C.algo;
      function X64Word_create() {
        return X64Word.create.apply(X64Word, arguments);
      }
      __name(X64Word_create, "X64Word_create");
      var K = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)],
        W = [];
      (function () {
        for (var i = 0; i < 80; i++) W[i] = X64Word_create();
      })();
      var SHA512 = C_algo.SHA512 = Hasher.extend({
        _doReset: function () {
          this._hash = new X64WordArray.init([new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209)]);
        },
        _doProcessBlock: function (M, offset) {
          for (var H = this._hash.words, H0 = H[0], H1 = H[1], H2 = H[2], H3 = H[3], H4 = H[4], H5 = H[5], H6 = H[6], H7 = H[7], H0h = H0.high, H0l = H0.low, H1h = H1.high, H1l = H1.low, H2h = H2.high, H2l = H2.low, H3h = H3.high, H3l = H3.low, H4h = H4.high, H4l = H4.low, H5h = H5.high, H5l = H5.low, H6h = H6.high, H6l = H6.low, H7h = H7.high, H7l = H7.low, ah = H0h, al = H0l, bh = H1h, bl = H1l, ch = H2h, cl = H2l, dh = H3h, dl = H3l, eh = H4h, el = H4l, fh = H5h, fl = H5l, gh = H6h, gl = H6l, hh = H7h, hl = H7l, i = 0; i < 80; i++) {
            var Wil,
              Wih,
              Wi = W[i];
            if (i < 16) Wih = Wi.high = M[offset + i * 2] | 0, Wil = Wi.low = M[offset + i * 2 + 1] | 0;else {
              var gamma0x = W[i - 15],
                gamma0xh = gamma0x.high,
                gamma0xl = gamma0x.low,
                gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7,
                gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25),
                gamma1x = W[i - 2],
                gamma1xh = gamma1x.high,
                gamma1xl = gamma1x.low,
                gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6,
                gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26),
                Wi7 = W[i - 7],
                Wi7h = Wi7.high,
                Wi7l = Wi7.low,
                Wi16 = W[i - 16],
                Wi16h = Wi16.high,
                Wi16l = Wi16.low;
              Wil = gamma0l + Wi7l, Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0), Wil = Wil + gamma1l, Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0), Wil = Wil + Wi16l, Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0), Wi.high = Wih, Wi.low = Wil;
            }
            var chh = eh & fh ^ ~eh & gh,
              chl = el & fl ^ ~el & gl,
              majh = ah & bh ^ ah & ch ^ bh & ch,
              majl = al & bl ^ al & cl ^ bl & cl,
              sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7),
              sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7),
              sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9),
              sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9),
              Ki = K[i],
              Kih = Ki.high,
              Kil = Ki.low,
              t1l = hl + sigma1l,
              t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0),
              t1l = t1l + chl,
              t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0),
              t1l = t1l + Kil,
              t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0),
              t1l = t1l + Wil,
              t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0),
              t2l = sigma0l + majl,
              t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
            hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, el = dl + t1l | 0, eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0, dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, al = t1l + t2l | 0, ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
          }
          H0l = H0.low = H0l + al, H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0), H1l = H1.low = H1l + bl, H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0), H2l = H2.low = H2l + cl, H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0), H3l = H3.low = H3l + dl, H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0), H4l = H4.low = H4l + el, H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0), H5l = H5.low = H5l + fl, H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0), H6l = H6.low = H6l + gl, H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0), H7l = H7.low = H7l + hl, H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
        },
        _doFinalize: function () {
          var data = this._data,
            dataWords = data.words,
            nBitsTotal = this._nDataBytes * 8,
            nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32, dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296), dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal, data.sigBytes = dataWords.length * 4, this._process();
          var hash = this._hash.toX32();
          return hash;
        },
        clone: function () {
          var clone = Hasher.clone.call(this);
          return clone._hash = this._hash.clone(), clone;
        },
        blockSize: 1024 / 32
      });
      C.SHA512 = Hasher._createHelper(SHA512), C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
    }(), CryptoJS.SHA512;
  });
});
var require_sha384 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), O3(), PT()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core", "./sha512"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_x64 = C.x64,
        X64Word = C_x64.Word,
        X64WordArray = C_x64.WordArray,
        C_algo = C.algo,
        SHA512 = C_algo.SHA512,
        SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function () {
            this._hash = new X64WordArray.init([new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428)]);
          },
          _doFinalize: function () {
            var hash = SHA512._doFinalize.call(this);
            return hash.sigBytes -= 16, hash;
          }
        });
      C.SHA384 = SHA512._createHelper(SHA384), C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
    }(), CryptoJS.SHA384;
  });
});
var require_sha3 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), O3()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (Math) {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_x64 = C.x64,
        X64Word = C_x64.Word,
        C_algo = C.algo,
        RHO_OFFSETS = [],
        PI_INDEXES = [],
        ROUND_CONSTANTS = [];
      (function () {
        for (var x = 1, y = 0, t = 0; t < 24; t++) {
          RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
          var newX = y % 5,
            newY = (2 * x + 3 * y) % 5;
          x = newX, y = newY;
        }
        for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
        for (var LFSR = 1, i = 0; i < 24; i++) {
          for (var roundConstantMsw = 0, roundConstantLsw = 0, j = 0; j < 7; j++) {
            if (LFSR & 1) {
              var bitPosition = (1 << j) - 1;
              bitPosition < 32 ? roundConstantLsw ^= 1 << bitPosition : roundConstantMsw ^= 1 << bitPosition - 32;
            }
            LFSR & 128 ? LFSR = LFSR << 1 ^ 113 : LFSR <<= 1;
          }
          ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
        }
      })();
      var T = [];
      (function () {
        for (var i = 0; i < 25; i++) T[i] = X64Word.create();
      })();
      var SHA3 = C_algo.SHA3 = Hasher.extend({
        cfg: Hasher.cfg.extend({
          outputLength: 512
        }),
        _doReset: function () {
          for (var state = this._state = [], i = 0; i < 25; i++) state[i] = new X64Word.init();
          this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
        },
        _doProcessBlock: function (M, offset) {
          for (var state = this._state, nBlockSizeLanes = this.blockSize / 2, i = 0; i < nBlockSizeLanes; i++) {
            var M2i = M[offset + 2 * i],
              M2i1 = M[offset + 2 * i + 1];
            M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360, M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
            var lane = state[i];
            lane.high ^= M2i1, lane.low ^= M2i;
          }
          for (var round = 0; round < 24; round++) {
            for (var x = 0; x < 5; x++) {
              for (var tMsw = 0, tLsw = 0, y = 0; y < 5; y++) {
                var lane = state[x + 5 * y];
                tMsw ^= lane.high, tLsw ^= lane.low;
              }
              var Tx = T[x];
              Tx.high = tMsw, Tx.low = tLsw;
            }
            for (var x = 0; x < 5; x++) for (var Tx4 = T[(x + 4) % 5], Tx1 = T[(x + 1) % 5], Tx1Msw = Tx1.high, Tx1Lsw = Tx1.low, tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31), tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31), y = 0; y < 5; y++) {
              var lane = state[x + 5 * y];
              lane.high ^= tMsw, lane.low ^= tLsw;
            }
            for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
              var tMsw,
                tLsw,
                lane = state[laneIndex],
                laneMsw = lane.high,
                laneLsw = lane.low,
                rhoOffset = RHO_OFFSETS[laneIndex];
              rhoOffset < 32 ? (tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset, tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset) : (tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset, tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset);
              var TPiLane = T[PI_INDEXES[laneIndex]];
              TPiLane.high = tMsw, TPiLane.low = tLsw;
            }
            var T0 = T[0],
              state0 = state[0];
            T0.high = state0.high, T0.low = state0.low;
            for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) {
              var laneIndex = x + 5 * y,
                lane = state[laneIndex],
                TLane = T[laneIndex],
                Tx1Lane = T[(x + 1) % 5 + 5 * y],
                Tx2Lane = T[(x + 2) % 5 + 5 * y];
              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high, lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
            }
            var lane = state[0],
              roundConstant = ROUND_CONSTANTS[round];
            lane.high ^= roundConstant.high, lane.low ^= roundConstant.low;
          }
        },
        _doFinalize: function () {
          var data = this._data,
            dataWords = data.words,
            nBitsTotal = this._nDataBytes * 8,
            nBitsLeft = data.sigBytes * 8,
            blockSizeBits = this.blockSize * 32;
          dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32, dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128, data.sigBytes = dataWords.length * 4, this._process();
          for (var state = this._state, outputLengthBytes = this.cfg.outputLength / 8, outputLengthLanes = outputLengthBytes / 8, hashWords = [], i = 0; i < outputLengthLanes; i++) {
            var lane = state[i],
              laneMsw = lane.high,
              laneLsw = lane.low;
            laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360, laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360, hashWords.push(laneLsw), hashWords.push(laneMsw);
          }
          return new WordArray.init(hashWords, outputLengthBytes);
        },
        clone: function () {
          for (var clone = Hasher.clone.call(this), state = clone._state = this._state.slice(0), i = 0; i < 25; i++) state[i] = state[i].clone();
          return clone;
        }
      });
      C.SHA3 = Hasher._createHelper(SHA3), C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
    }(Math), CryptoJS.SHA3;
  });
});
var require_ripemd160 = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (Math) {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        Hasher = C_lib.Hasher,
        C_algo = C.algo,
        _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
        _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
        _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
        _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
        _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
        _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
        RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function () {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function (M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i,
                M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words,
              hl = _hl.words,
              hr = _hr.words,
              zl = _zl.words,
              zr = _zr.words,
              sl = _sl.words,
              sr = _sr.words,
              al,
              bl,
              cl,
              dl,
              el,
              ar,
              br,
              cr,
              dr,
              er;
            ar = al = H[0], br = bl = H[1], cr = cl = H[2], dr = dl = H[3], er = el = H[4];
            for (var t, i = 0; i < 80; i += 1) t = al + M[offset + zl[i]] | 0, i < 16 ? t += f1(bl, cl, dl) + hl[0] : i < 32 ? t += f2(bl, cl, dl) + hl[1] : i < 48 ? t += f3(bl, cl, dl) + hl[2] : i < 64 ? t += f4(bl, cl, dl) + hl[3] : t += f5(bl, cl, dl) + hl[4], t = t | 0, t = rotl(t, sl[i]), t = t + el | 0, al = el, el = dl, dl = rotl(cl, 10), cl = bl, bl = t, t = ar + M[offset + zr[i]] | 0, i < 16 ? t += f5(br, cr, dr) + hr[0] : i < 32 ? t += f4(br, cr, dr) + hr[1] : i < 48 ? t += f3(br, cr, dr) + hr[2] : i < 64 ? t += f2(br, cr, dr) + hr[3] : t += f1(br, cr, dr) + hr[4], t = t | 0, t = rotl(t, sr[i]), t = t + er | 0, ar = er, er = dr, dr = rotl(cr, 10), cr = br, br = t;
            t = H[1] + cl + dr | 0, H[1] = H[2] + dl + er | 0, H[2] = H[3] + el + ar | 0, H[3] = H[4] + al + br | 0, H[4] = H[0] + bl + cr | 0, H[0] = t;
          },
          _doFinalize: function () {
            var data = this._data,
              dataWords = data.words,
              nBitsTotal = this._nDataBytes * 8,
              nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32, dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360, data.sigBytes = (dataWords.length + 1) * 4, this._process();
            for (var hash = this._hash, H = hash.words, i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function () {
            var clone = Hasher.clone.call(this);
            return clone._hash = this._hash.clone(), clone;
          }
        });
      function f1(x, y, z) {
        return x ^ y ^ z;
      }
      __name(f1, "f1");
      function f2(x, y, z) {
        return x & y | ~x & z;
      }
      __name(f2, "f2");
      function f3(x, y, z) {
        return (x | ~y) ^ z;
      }
      __name(f3, "f3");
      function f4(x, y, z) {
        return x & z | y & ~z;
      }
      __name(f4, "f4");
      function f5(x, y, z) {
        return x ^ (y | ~z);
      }
      __name(f5, "f5");
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      __name(rotl, "rotl"), C.RIPEMD160 = Hasher._createHelper(RIPEMD160), C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
    }(Math), CryptoJS.RIPEMD160;
  });
});
var require_hmac = __commonJSMin((exports, module) => {
  (function (root, factory) {
    typeof exports == "object" ? module.exports = exports = factory(Ea()) : typeof define == "function" && define.amd ? define(["./core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    (function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        C_enc = C.enc,
        Utf8 = C_enc.Utf8,
        C_algo = C.algo,
        HMAC = C_algo.HMAC = Base.extend({
          init: function (hasher, key) {
            hasher = this._hasher = new hasher.init(), typeof key == "string" && (key = Utf8.parse(key));
            var hasherBlockSize = hasher.blockSize,
              hasherBlockSizeBytes = hasherBlockSize * 4;
            key.sigBytes > hasherBlockSizeBytes && (key = hasher.finalize(key)), key.clamp();
            for (var oKey = this._oKey = key.clone(), iKey = this._iKey = key.clone(), oKeyWords = oKey.words, iKeyWords = iKey.words, i = 0; i < hasherBlockSize; i++) oKeyWords[i] ^= 1549556828, iKeyWords[i] ^= 909522486;
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes, this.reset();
          },
          reset: function () {
            var hasher = this._hasher;
            hasher.reset(), hasher.update(this._iKey);
          },
          update: function (messageUpdate) {
            return this._hasher.update(messageUpdate), this;
          },
          finalize: function (messageUpdate) {
            var hasher = this._hasher,
              innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
    })();
  });
});
var require_pbkdf2 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Ny(), Fy()) : typeof define == "function" && define.amd ? define(["./core", "./sha256", "./hmac"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        C_algo = C.algo,
        SHA256 = C_algo.SHA256,
        HMAC = C_algo.HMAC,
        PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function (password, salt) {
            for (var cfg = this.cfg, hmac = HMAC.create(cfg.hasher, password), derivedKey = WordArray.create(), blockIndex = WordArray.create([1]), derivedKeyWords = derivedKey.words, blockIndexWords = blockIndex.words, keySize = cfg.keySize, iterations = cfg.iterations; derivedKeyWords.length < keySize;) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              for (var blockWords = block.words, blockWordsLength = blockWords.length, intermediate = block, i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate), hmac.reset();
                for (var intermediateWords = intermediate.words, j = 0; j < blockWordsLength; j++) blockWords[j] ^= intermediateWords[j];
              }
              derivedKey.concat(block), blockIndexWords[0]++;
            }
            return derivedKey.sigBytes = keySize * 4, derivedKey;
          }
        });
      C.PBKDF2 = function (password, salt, cfg) {
        return PBKDF2.create(cfg).compute(password, salt);
      };
    }(), CryptoJS.PBKDF2;
  });
});
var require_evpkdf = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), AT(), Fy()) : typeof define == "function" && define.amd ? define(["./core", "./sha1", "./hmac"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        C_algo = C.algo,
        MD5 = C_algo.MD5,
        EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function (password, salt) {
            for (var block, cfg = this.cfg, hasher = cfg.hasher.create(), derivedKey = WordArray.create(), derivedKeyWords = derivedKey.words, keySize = cfg.keySize, iterations = cfg.iterations; derivedKeyWords.length < keySize;) {
              block && hasher.update(block), block = hasher.update(password).finalize(salt), hasher.reset();
              for (var i = 1; i < iterations; i++) block = hasher.finalize(block), hasher.reset();
              derivedKey.concat(block);
            }
            return derivedKey.sigBytes = keySize * 4, derivedKey;
          }
        });
      C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
      };
    }(), CryptoJS.EvpKDF;
  });
});
var require_cipher_core = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), fd()) : typeof define == "function" && define.amd ? define(["./core", "./evpkdf"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    CryptoJS.lib.Cipher || function (undefined) {
      var C = CryptoJS,
        C_lib = C.lib,
        Base = C_lib.Base,
        WordArray = C_lib.WordArray,
        BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm,
        C_enc = C.enc,
        Utf8 = C_enc.Utf8,
        Base64 = C_enc.Base64,
        C_algo = C.algo,
        EvpKDF = C_algo.EvpKDF,
        Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function (xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg), this._xformMode = xformMode, this._key = key, this.reset();
          },
          reset: function () {
            BufferedBlockAlgorithm.reset.call(this), this._doReset();
          },
          process: function (dataUpdate) {
            return this._append(dataUpdate), this._process();
          },
          finalize: function (dataUpdate) {
            dataUpdate && this._append(dataUpdate);
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function () {
            function selectCipherStrategy(key) {
              return typeof key == "string" ? PasswordBasedCipher : SerializableCipher;
            }
            return __name(selectCipherStrategy, "selectCipherStrategy"), function (cipher) {
              return {
                encrypt: function (message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function (ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        }),
        StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function () {
            var finalProcessedBlocks = this._process(!0);
            return finalProcessedBlocks;
          },
          blockSize: 1
        }),
        C_mode = C.mode = {},
        BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function (cipher, iv) {
            this._cipher = cipher, this._iv = iv;
          }
        }),
        CBC = C_mode.CBC = function () {
          var CBC = BlockCipherMode.extend();
          CBC.Encryptor = CBC.extend({
            processBlock: function (words, offset) {
              var cipher = this._cipher,
                blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize), cipher.encryptBlock(words, offset), this._prevBlock = words.slice(offset, offset + blockSize);
            }
          }), CBC.Decryptor = CBC.extend({
            processBlock: function (words, offset) {
              var cipher = this._cipher,
                blockSize = cipher.blockSize,
                thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset), xorBlock.call(this, words, offset, blockSize), this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block,
              iv = this._iv;
            iv ? (block = iv, this._iv = undefined) : block = this._prevBlock;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= block[i];
          }
          return __name(xorBlock, "xorBlock"), CBC;
        }(),
        C_pad = C.pad = {},
        Pkcs7 = C_pad.Pkcs7 = {
          pad: function (data, blockSize) {
            for (var blockSizeBytes = blockSize * 4, nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes, paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes, paddingWords = [], i = 0; i < nPaddingBytes; i += 4) paddingWords.push(paddingWord);
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function (data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        },
        BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function () {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg,
              iv = cfg.iv,
              mode = cfg.mode;
            this._xformMode == this._ENC_XFORM_MODE ? modeCreator = mode.createEncryptor : (modeCreator = mode.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == modeCreator ? this._mode.init(this, iv && iv.words) : (this._mode = modeCreator.call(mode, this, iv && iv.words), this._mode.__creator = modeCreator);
          },
          _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function () {
            var finalProcessedBlocks,
              padding = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (padding.pad(this._data, this.blockSize), finalProcessedBlocks = this._process(!0)) : (finalProcessedBlocks = this._process(!0), padding.unpad(finalProcessedBlocks)), finalProcessedBlocks;
          },
          blockSize: 128 / 32
        }),
        CipherParams = C_lib.CipherParams = Base.extend({
          init: function (cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        }),
        C_format = C.format = {},
        OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function (cipherParams) {
            var wordArray,
              ciphertext = cipherParams.ciphertext,
              salt = cipherParams.salt;
            return salt ? wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext) : wordArray = ciphertext, wordArray.toString(Base64);
          },
          parse: function (openSSLStr) {
            var salt,
              ciphertext = Base64.parse(openSSLStr),
              ciphertextWords = ciphertext.words;
            return ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831 && (salt = WordArray.create(ciphertextWords.slice(2, 4)), ciphertextWords.splice(0, 4), ciphertext.sigBytes -= 16), CipherParams.create({
              ciphertext: ciphertext,
              salt: salt
            });
          }
        },
        SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function (cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg),
              ciphertext = encryptor.finalize(message),
              cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext: ciphertext,
              key: key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function (cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg), ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function (ciphertext, format) {
            return typeof ciphertext == "string" ? format.parse(ciphertext, this) : ciphertext;
          }
        }),
        C_kdf = C.kdf = {},
        OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function (password, keySize, ivSize, salt, hasher) {
            if (salt || (salt = WordArray.random(64 / 8)), hasher) var key = EvpKDF.create({
              keySize: keySize + ivSize,
              hasher: hasher
            }).compute(password, salt);else var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            return key.sigBytes = keySize * 4, CipherParams.create({
              key: key,
              iv: iv,
              salt: salt
            });
          }
        },
        PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function (cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            return ciphertext.mixIn(derivedParams), ciphertext;
          },
          decrypt: function (cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg), ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
    }();
  });
});
var require_mode_cfb = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.CFB = function () {
      var CFB = CryptoJS.lib.BlockCipherMode.extend();
      CFB.Encryptor = CFB.extend({
        processBlock: function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize;
          generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher), this._prevBlock = words.slice(offset, offset + blockSize);
        }
      }), CFB.Decryptor = CFB.extend({
        processBlock: function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize,
            thisBlock = words.slice(offset, offset + blockSize);
          generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher), this._prevBlock = thisBlock;
        }
      });
      function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
        var keystream,
          iv = this._iv;
        iv ? (keystream = iv.slice(0), this._iv = void 0) : keystream = this._prevBlock, cipher.encryptBlock(keystream, 0);
        for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
      }
      return __name(generateKeystreamAndEncrypt, "generateKeystreamAndEncrypt"), CFB;
    }(), CryptoJS.mode.CFB;
  });
});
var require_mode_ctr = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.CTR = function () {
      var CTR = CryptoJS.lib.BlockCipherMode.extend(),
        Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function (words, offset) {
            var cipher = this._cipher,
              blockSize = cipher.blockSize,
              iv = this._iv,
              counter = this._counter;
            iv && (counter = this._counter = iv.slice(0), this._iv = void 0);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0), counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
      return CTR.Decryptor = Encryptor, CTR;
    }(), CryptoJS.mode.CTR;
  });
});
var require_mode_ctr_gladman = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.CTRGladman = function () {
      var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
      function incWord(word) {
        if ((word >> 24 & 255) === 255) {
          var b1 = word >> 16 & 255,
            b2 = word >> 8 & 255,
            b3 = word & 255;
          b1 === 255 ? (b1 = 0, b2 === 255 ? (b2 = 0, b3 === 255 ? b3 = 0 : ++b3) : ++b2) : ++b1, word = 0, word += b1 << 16, word += b2 << 8, word += b3;
        } else word += 1 << 24;
        return word;
      }
      __name(incWord, "incWord");
      function incCounter(counter) {
        return (counter[0] = incWord(counter[0])) === 0 && (counter[1] = incWord(counter[1])), counter;
      }
      __name(incCounter, "incCounter");
      var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
        processBlock: function (words, offset) {
          var cipher = this._cipher,
            blockSize = cipher.blockSize,
            iv = this._iv,
            counter = this._counter;
          iv && (counter = this._counter = iv.slice(0), this._iv = void 0), incCounter(counter);
          var keystream = counter.slice(0);
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
        }
      });
      return CTRGladman.Decryptor = Encryptor, CTRGladman;
    }(), CryptoJS.mode.CTRGladman;
  });
});
var require_mode_ofb = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.OFB = function () {
      var OFB = CryptoJS.lib.BlockCipherMode.extend(),
        Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function (words, offset) {
            var cipher = this._cipher,
              blockSize = cipher.blockSize,
              iv = this._iv,
              keystream = this._keystream;
            iv && (keystream = this._keystream = iv.slice(0), this._iv = void 0), cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
      return OFB.Decryptor = Encryptor, OFB;
    }(), CryptoJS.mode.OFB;
  });
});
var require_mode_ecb = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.mode.ECB = function () {
      var ECB = CryptoJS.lib.BlockCipherMode.extend();
      return ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
          this._cipher.encryptBlock(words, offset);
        }
      }), ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
          this._cipher.decryptBlock(words, offset);
        }
      }), ECB;
    }(), CryptoJS.mode.ECB;
  });
});
var require_pad_ansix923 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.pad.AnsiX923 = {
      pad: function (data, blockSize) {
        var dataSigBytes = data.sigBytes,
          blockSizeBytes = blockSize * 4,
          nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes,
          lastBytePos = dataSigBytes + nPaddingBytes - 1;
        data.clamp(), data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8, data.sigBytes += nPaddingBytes;
      },
      unpad: function (data) {
        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
        data.sigBytes -= nPaddingBytes;
      }
    }, CryptoJS.pad.Ansix923;
  });
});
var require_pad_iso10126 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.pad.Iso10126 = {
      pad: function (data, blockSize) {
        var blockSizeBytes = blockSize * 4,
          nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
      },
      unpad: function (data) {
        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
        data.sigBytes -= nPaddingBytes;
      }
    }, CryptoJS.pad.Iso10126;
  });
});
var require_pad_iso97971 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.pad.Iso97971 = {
      pad: function (data, blockSize) {
        data.concat(CryptoJS.lib.WordArray.create([2147483648], 1)), CryptoJS.pad.ZeroPadding.pad(data, blockSize);
      },
      unpad: function (data) {
        CryptoJS.pad.ZeroPadding.unpad(data), data.sigBytes--;
      }
    }, CryptoJS.pad.Iso97971;
  });
});
var require_pad_zeropadding = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.pad.ZeroPadding = {
      pad: function (data, blockSize) {
        var blockSizeBytes = blockSize * 4;
        data.clamp(), data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
      },
      unpad: function (data) {
        for (var dataWords = data.words, i = data.sigBytes - 1, i = data.sigBytes - 1; i >= 0; i--) if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
          data.sigBytes = i + 1;
          break;
        }
      }
    }, CryptoJS.pad.ZeroPadding;
  });
});
var require_pad_nopadding = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS.pad.NoPadding = {
      pad: function () {},
      unpad: function () {}
    }, CryptoJS.pad.NoPadding;
  });
});
var require_format_hex = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function (undefined) {
      var C = CryptoJS,
        C_lib = C.lib,
        CipherParams = C_lib.CipherParams,
        C_enc = C.enc,
        Hex = C_enc.Hex,
        C_format = C.format,
        HexFormatter = C_format.Hex = {
          stringify: function (cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function (input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({
              ciphertext: ciphertext
            });
          }
        };
    }(), CryptoJS.format.Hex;
  });
});
var require_aes = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        BlockCipher = C_lib.BlockCipher,
        C_algo = C.algo,
        SBOX = [],
        INV_SBOX = [],
        SUB_MIX_0 = [],
        SUB_MIX_1 = [],
        SUB_MIX_2 = [],
        SUB_MIX_3 = [],
        INV_SUB_MIX_0 = [],
        INV_SUB_MIX_1 = [],
        INV_SUB_MIX_2 = [],
        INV_SUB_MIX_3 = [];
      (function () {
        for (var d = [], i = 0; i < 256; i++) i < 128 ? d[i] = i << 1 : d[i] = i << 1 ^ 283;
        for (var x = 0, xi = 0, i = 0; i < 256; i++) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99, SBOX[x] = sx, INV_SBOX[sx] = x;
          var x2 = d[x],
            x4 = d[x2],
            x8 = d[x4],
            t = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX_0[x] = t << 24 | t >>> 8, SUB_MIX_1[x] = t << 16 | t >>> 16, SUB_MIX_2[x] = t << 8 | t >>> 24, SUB_MIX_3[x] = t;
          var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX_0[sx] = t << 24 | t >>> 8, INV_SUB_MIX_1[sx] = t << 16 | t >>> 16, INV_SUB_MIX_2[sx] = t << 8 | t >>> 24, INV_SUB_MIX_3[sx] = t, x ? (x = x2 ^ d[d[d[x8 ^ x2]]], xi ^= d[d[xi]]) : x = xi = 1;
        }
      })();
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
        AES = C_algo.AES = BlockCipher.extend({
          _doReset: function () {
            var t;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var key = this._keyPriorReset = this._key, keyWords = key.words, keySize = key.sigBytes / 4, nRounds = this._nRounds = keySize + 6, ksRows = (nRounds + 1) * 4, keySchedule = this._keySchedule = [], ksRow = 0; ksRow < ksRows; ksRow++) ksRow < keySize ? keySchedule[ksRow] = keyWords[ksRow] : (t = keySchedule[ksRow - 1], ksRow % keySize ? keySize > 6 && ksRow % keySize == 4 && (t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255]) : (t = t << 8 | t >>> 24, t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255], t ^= RCON[ksRow / keySize | 0] << 24), keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t);
              for (var invKeySchedule = this._invKeySchedule = [], invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) var t = keySchedule[ksRow];else var t = keySchedule[ksRow - 4];
                invKsRow < 4 || ksRow <= 4 ? invKeySchedule[invKsRow] = t : invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function (M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3], M[offset + 3] = t, this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3], M[offset + 3] = t;
          },
          _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            for (var nRounds = this._nRounds, s0 = M[offset] ^ keySchedule[0], s1 = M[offset + 1] ^ keySchedule[1], s2 = M[offset + 2] ^ keySchedule[2], s3 = M[offset + 3] ^ keySchedule[3], ksRow = 4, round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++],
                t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++],
                t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++],
                t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0, s1 = t1, s2 = t2, s3 = t3;
            }
            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++],
              t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++],
              t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++],
              t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0, M[offset + 1] = t1, M[offset + 2] = t2, M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
      C.AES = BlockCipher._createHelper(AES);
    }(), CryptoJS.AES;
  });
});
var require_tripledes = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        WordArray = C_lib.WordArray,
        BlockCipher = C_lib.BlockCipher,
        C_algo = C.algo,
        PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
        PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
        BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
        SBOX_P = [{
          0: 8421888,
          268435456: 32768,
          536870912: 8421378,
          805306368: 2,
          1073741824: 512,
          1342177280: 8421890,
          1610612736: 8389122,
          1879048192: 8388608,
          2147483648: 514,
          2415919104: 8389120,
          2684354560: 33280,
          2952790016: 8421376,
          3221225472: 32770,
          3489660928: 8388610,
          3758096384: 0,
          4026531840: 33282,
          134217728: 0,
          402653184: 8421890,
          671088640: 33282,
          939524096: 32768,
          1207959552: 8421888,
          1476395008: 512,
          1744830464: 8421378,
          2013265920: 2,
          2281701376: 8389120,
          2550136832: 33280,
          2818572288: 8421376,
          3087007744: 8389122,
          3355443200: 8388610,
          3623878656: 32770,
          3892314112: 514,
          4160749568: 8388608,
          1: 32768,
          268435457: 2,
          536870913: 8421888,
          805306369: 8388608,
          1073741825: 8421378,
          1342177281: 33280,
          1610612737: 512,
          1879048193: 8389122,
          2147483649: 8421890,
          2415919105: 8421376,
          2684354561: 8388610,
          2952790017: 33282,
          3221225473: 514,
          3489660929: 8389120,
          3758096385: 32770,
          4026531841: 0,
          134217729: 8421890,
          402653185: 8421376,
          671088641: 8388608,
          939524097: 512,
          1207959553: 32768,
          1476395009: 8388610,
          1744830465: 2,
          2013265921: 33282,
          2281701377: 32770,
          2550136833: 8389122,
          2818572289: 514,
          3087007745: 8421888,
          3355443201: 8389120,
          3623878657: 0,
          3892314113: 33280,
          4160749569: 8421378
        }, {
          0: 1074282512,
          16777216: 16384,
          33554432: 524288,
          50331648: 1074266128,
          67108864: 1073741840,
          83886080: 1074282496,
          100663296: 1073758208,
          117440512: 16,
          134217728: 540672,
          150994944: 1073758224,
          167772160: 1073741824,
          184549376: 540688,
          201326592: 524304,
          218103808: 0,
          234881024: 16400,
          251658240: 1074266112,
          8388608: 1073758208,
          25165824: 540688,
          41943040: 16,
          58720256: 1073758224,
          75497472: 1074282512,
          92274688: 1073741824,
          109051904: 524288,
          125829120: 1074266128,
          142606336: 524304,
          159383552: 0,
          176160768: 16384,
          192937984: 1074266112,
          209715200: 1073741840,
          226492416: 540672,
          243269632: 1074282496,
          260046848: 16400,
          268435456: 0,
          285212672: 1074266128,
          301989888: 1073758224,
          318767104: 1074282496,
          335544320: 1074266112,
          352321536: 16,
          369098752: 540688,
          385875968: 16384,
          402653184: 16400,
          419430400: 524288,
          436207616: 524304,
          452984832: 1073741840,
          469762048: 540672,
          486539264: 1073758208,
          503316480: 1073741824,
          520093696: 1074282512,
          276824064: 540688,
          293601280: 524288,
          310378496: 1074266112,
          327155712: 16384,
          343932928: 1073758208,
          360710144: 1074282512,
          377487360: 16,
          394264576: 1073741824,
          411041792: 1074282496,
          427819008: 1073741840,
          444596224: 1073758224,
          461373440: 524304,
          478150656: 0,
          494927872: 16400,
          511705088: 1074266128,
          528482304: 540672
        }, {
          0: 260,
          1048576: 0,
          2097152: 67109120,
          3145728: 65796,
          4194304: 65540,
          5242880: 67108868,
          6291456: 67174660,
          7340032: 67174400,
          8388608: 67108864,
          9437184: 67174656,
          10485760: 65792,
          11534336: 67174404,
          12582912: 67109124,
          13631488: 65536,
          14680064: 4,
          15728640: 256,
          524288: 67174656,
          1572864: 67174404,
          2621440: 0,
          3670016: 67109120,
          4718592: 67108868,
          5767168: 65536,
          6815744: 65540,
          7864320: 260,
          8912896: 4,
          9961472: 256,
          11010048: 67174400,
          12058624: 65796,
          13107200: 65792,
          14155776: 67109124,
          15204352: 67174660,
          16252928: 67108864,
          16777216: 67174656,
          17825792: 65540,
          18874368: 65536,
          19922944: 67109120,
          20971520: 256,
          22020096: 67174660,
          23068672: 67108868,
          24117248: 0,
          25165824: 67109124,
          26214400: 67108864,
          27262976: 4,
          28311552: 65792,
          29360128: 67174400,
          30408704: 260,
          31457280: 65796,
          32505856: 67174404,
          17301504: 67108864,
          18350080: 260,
          19398656: 67174656,
          20447232: 0,
          21495808: 65540,
          22544384: 67109120,
          23592960: 256,
          24641536: 67174404,
          25690112: 65536,
          26738688: 67174660,
          27787264: 65796,
          28835840: 67108868,
          29884416: 67109124,
          30932992: 67174400,
          31981568: 4,
          33030144: 65792
        }, {
          0: 2151682048,
          65536: 2147487808,
          131072: 4198464,
          196608: 2151677952,
          262144: 0,
          327680: 4198400,
          393216: 2147483712,
          458752: 4194368,
          524288: 2147483648,
          589824: 4194304,
          655360: 64,
          720896: 2147487744,
          786432: 2151678016,
          851968: 4160,
          917504: 4096,
          983040: 2151682112,
          32768: 2147487808,
          98304: 64,
          163840: 2151678016,
          229376: 2147487744,
          294912: 4198400,
          360448: 2151682112,
          425984: 0,
          491520: 2151677952,
          557056: 4096,
          622592: 2151682048,
          688128: 4194304,
          753664: 4160,
          819200: 2147483648,
          884736: 4194368,
          950272: 4198464,
          1015808: 2147483712,
          1048576: 4194368,
          1114112: 4198400,
          1179648: 2147483712,
          1245184: 0,
          1310720: 4160,
          1376256: 2151678016,
          1441792: 2151682048,
          1507328: 2147487808,
          1572864: 2151682112,
          1638400: 2147483648,
          1703936: 2151677952,
          1769472: 4198464,
          1835008: 2147487744,
          1900544: 4194304,
          1966080: 64,
          2031616: 4096,
          1081344: 2151677952,
          1146880: 2151682112,
          1212416: 0,
          1277952: 4198400,
          1343488: 4194368,
          1409024: 2147483648,
          1474560: 2147487808,
          1540096: 64,
          1605632: 2147483712,
          1671168: 4096,
          1736704: 2147487744,
          1802240: 2151678016,
          1867776: 4160,
          1933312: 2151682048,
          1998848: 4194304,
          2064384: 4198464
        }, {
          0: 128,
          4096: 17039360,
          8192: 262144,
          12288: 536870912,
          16384: 537133184,
          20480: 16777344,
          24576: 553648256,
          28672: 262272,
          32768: 16777216,
          36864: 537133056,
          40960: 536871040,
          45056: 553910400,
          49152: 553910272,
          53248: 0,
          57344: 17039488,
          61440: 553648128,
          2048: 17039488,
          6144: 553648256,
          10240: 128,
          14336: 17039360,
          18432: 262144,
          22528: 537133184,
          26624: 553910272,
          30720: 536870912,
          34816: 537133056,
          38912: 0,
          43008: 553910400,
          47104: 16777344,
          51200: 536871040,
          55296: 553648128,
          59392: 16777216,
          63488: 262272,
          65536: 262144,
          69632: 128,
          73728: 536870912,
          77824: 553648256,
          81920: 16777344,
          86016: 553910272,
          90112: 537133184,
          94208: 16777216,
          98304: 553910400,
          102400: 553648128,
          106496: 17039360,
          110592: 537133056,
          114688: 262272,
          118784: 536871040,
          122880: 0,
          126976: 17039488,
          67584: 553648256,
          71680: 16777216,
          75776: 17039360,
          79872: 537133184,
          83968: 536870912,
          88064: 17039488,
          92160: 128,
          96256: 553910272,
          100352: 262272,
          104448: 553910400,
          108544: 0,
          112640: 553648128,
          116736: 16777344,
          120832: 262144,
          124928: 537133056,
          129024: 536871040
        }, {
          0: 268435464,
          256: 8192,
          512: 270532608,
          768: 270540808,
          1024: 268443648,
          1280: 2097152,
          1536: 2097160,
          1792: 268435456,
          2048: 0,
          2304: 268443656,
          2560: 2105344,
          2816: 8,
          3072: 270532616,
          3328: 2105352,
          3584: 8200,
          3840: 270540800,
          128: 270532608,
          384: 270540808,
          640: 8,
          896: 2097152,
          1152: 2105352,
          1408: 268435464,
          1664: 268443648,
          1920: 8200,
          2176: 2097160,
          2432: 8192,
          2688: 268443656,
          2944: 270532616,
          3200: 0,
          3456: 270540800,
          3712: 2105344,
          3968: 268435456,
          4096: 268443648,
          4352: 270532616,
          4608: 270540808,
          4864: 8200,
          5120: 2097152,
          5376: 268435456,
          5632: 268435464,
          5888: 2105344,
          6144: 2105352,
          6400: 0,
          6656: 8,
          6912: 270532608,
          7168: 8192,
          7424: 268443656,
          7680: 270540800,
          7936: 2097160,
          4224: 8,
          4480: 2105344,
          4736: 2097152,
          4992: 268435464,
          5248: 268443648,
          5504: 8200,
          5760: 270540808,
          6016: 270532608,
          6272: 270540800,
          6528: 270532616,
          6784: 8192,
          7040: 2105352,
          7296: 2097160,
          7552: 0,
          7808: 268435456,
          8064: 268443656
        }, {
          0: 1048576,
          16: 33555457,
          32: 1024,
          48: 1049601,
          64: 34604033,
          80: 0,
          96: 1,
          112: 34603009,
          128: 33555456,
          144: 1048577,
          160: 33554433,
          176: 34604032,
          192: 34603008,
          208: 1025,
          224: 1049600,
          240: 33554432,
          8: 34603009,
          24: 0,
          40: 33555457,
          56: 34604032,
          72: 1048576,
          88: 33554433,
          104: 33554432,
          120: 1025,
          136: 1049601,
          152: 33555456,
          168: 34603008,
          184: 1048577,
          200: 1024,
          216: 34604033,
          232: 1,
          248: 1049600,
          256: 33554432,
          272: 1048576,
          288: 33555457,
          304: 34603009,
          320: 1048577,
          336: 33555456,
          352: 34604032,
          368: 1049601,
          384: 1025,
          400: 34604033,
          416: 1049600,
          432: 1,
          448: 0,
          464: 34603008,
          480: 33554433,
          496: 1024,
          264: 1049600,
          280: 33555457,
          296: 34603009,
          312: 1,
          328: 33554432,
          344: 1048576,
          360: 1025,
          376: 34604032,
          392: 33554433,
          408: 34603008,
          424: 0,
          440: 34604033,
          456: 1049601,
          472: 1024,
          488: 33555456,
          504: 1048577
        }, {
          0: 134219808,
          1: 131072,
          2: 134217728,
          3: 32,
          4: 131104,
          5: 134350880,
          6: 134350848,
          7: 2048,
          8: 134348800,
          9: 134219776,
          10: 133120,
          11: 134348832,
          12: 2080,
          13: 0,
          14: 134217760,
          15: 133152,
          2147483648: 2048,
          2147483649: 134350880,
          2147483650: 134219808,
          2147483651: 134217728,
          2147483652: 134348800,
          2147483653: 133120,
          2147483654: 133152,
          2147483655: 32,
          2147483656: 134217760,
          2147483657: 2080,
          2147483658: 131104,
          2147483659: 134350848,
          2147483660: 0,
          2147483661: 134348832,
          2147483662: 134219776,
          2147483663: 131072,
          16: 133152,
          17: 134350848,
          18: 32,
          19: 2048,
          20: 134219776,
          21: 134217760,
          22: 134348832,
          23: 131072,
          24: 0,
          25: 131104,
          26: 134348800,
          27: 134219808,
          28: 134350880,
          29: 133120,
          30: 2080,
          31: 134217728,
          2147483664: 131072,
          2147483665: 2048,
          2147483666: 134348832,
          2147483667: 133152,
          2147483668: 32,
          2147483669: 134348800,
          2147483670: 134217728,
          2147483671: 134219808,
          2147483672: 134350880,
          2147483673: 134217760,
          2147483674: 134219776,
          2147483675: 0,
          2147483676: 133120,
          2147483677: 2080,
          2147483678: 131104,
          2147483679: 134350848
        }],
        SBOX_MASK = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
        DES = C_algo.DES = BlockCipher.extend({
          _doReset: function () {
            for (var key = this._key, keyWords = key.words, keyBits = [], i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            for (var subKeys = this._subKeys = [], nSubKey = 0; nSubKey < 16; nSubKey++) {
              for (var subKey = subKeys[nSubKey] = [], bitShift = BIT_SHIFTS[nSubKey], i = 0; i < 24; i++) subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6, subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            for (var invSubKeys = this._invSubKeys = [], i = 0; i < 16; i++) invSubKeys[i] = subKeys[15 - i];
          },
          encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function (M, offset, subKeys) {
            this._lBlock = M[offset], this._rBlock = M[offset + 1], exchangeLR.call(this, 4, 252645135), exchangeLR.call(this, 16, 65535), exchangeRL.call(this, 2, 858993459), exchangeRL.call(this, 8, 16711935), exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              for (var subKey = subKeys[round], lBlock = this._lBlock, rBlock = this._rBlock, f = 0, i = 0; i < 8; i++) f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              this._lBlock = rBlock, this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = t, exchangeLR.call(this, 1, 1431655765), exchangeRL.call(this, 8, 16711935), exchangeRL.call(this, 2, 858993459), exchangeLR.call(this, 16, 65535), exchangeLR.call(this, 4, 252645135), M[offset] = this._lBlock, M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
      function exchangeLR(offset, mask) {
        var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
        this._rBlock ^= t, this._lBlock ^= t << offset;
      }
      __name(exchangeLR, "exchangeLR");
      function exchangeRL(offset, mask) {
        var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
        this._lBlock ^= t, this._rBlock ^= t << offset;
      }
      __name(exchangeRL, "exchangeRL"), C.DES = BlockCipher._createHelper(DES);
      var TripleDES = C_algo.TripleDES = BlockCipher.extend({
        _doReset: function () {
          var key = this._key,
            keyWords = key.words;
          if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
          var key1 = keyWords.slice(0, 2),
            key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4),
            key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
          this._des1 = DES.createEncryptor(WordArray.create(key1)), this._des2 = DES.createEncryptor(WordArray.create(key2)), this._des3 = DES.createEncryptor(WordArray.create(key3));
        },
        encryptBlock: function (M, offset) {
          this._des1.encryptBlock(M, offset), this._des2.decryptBlock(M, offset), this._des3.encryptBlock(M, offset);
        },
        decryptBlock: function (M, offset) {
          this._des3.decryptBlock(M, offset), this._des2.encryptBlock(M, offset), this._des1.decryptBlock(M, offset);
        },
        keySize: 192 / 32,
        ivSize: 64 / 32,
        blockSize: 64 / 32
      });
      C.TripleDES = BlockCipher._createHelper(TripleDES);
    }(), CryptoJS.TripleDES;
  });
});
var require_rc4 = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        StreamCipher = C_lib.StreamCipher,
        C_algo = C.algo,
        RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function () {
            for (var key = this._key, keyWords = key.words, keySigBytes = key.sigBytes, S = this._S = [], i = 0; i < 256; i++) S[i] = i;
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes,
                keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j], S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function (M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
      function generateKeystreamWord() {
        for (var S = this._S, i = this._i, j = this._j, keystreamWord = 0, n = 0; n < 4; n++) {
          i = (i + 1) % 256, j = (j + S[i]) % 256;
          var t = S[i];
          S[i] = S[j], S[j] = t, keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
        }
        return this._i = i, this._j = j, keystreamWord;
      }
      __name(generateKeystreamWord, "generateKeystreamWord"), C.RC4 = StreamCipher._createHelper(RC4);
      var RC4Drop = C_algo.RC4Drop = RC4.extend({
        cfg: RC4.cfg.extend({
          drop: 192
        }),
        _doReset: function () {
          RC4._doReset.call(this);
          for (var i = this.cfg.drop; i > 0; i--) generateKeystreamWord.call(this);
        }
      });
      C.RC4Drop = StreamCipher._createHelper(RC4Drop);
    }(), CryptoJS.RC4;
  });
});
var require_rabbit = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        StreamCipher = C_lib.StreamCipher,
        C_algo = C.algo,
        S = [],
        C_ = [],
        G = [],
        Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function () {
            for (var K = this._key.words, iv = this.cfg.iv, i = 0; i < 4; i++) K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16],
              C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words,
                IV_0 = IV[0],
                IV_1 = IV[1],
                i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360,
                i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360,
                i1 = i0 >>> 16 | i2 & 4294901760,
                i3 = i2 << 16 | i0 & 65535;
              C[0] ^= i0, C[1] ^= i1, C[2] ^= i2, C[3] ^= i3, C[4] ^= i0, C[5] ^= i1, C[6] ^= i2, C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function (M, offset) {
            var X = this._X;
            nextState.call(this), S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16, S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16, S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16, S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360, M[offset + i] ^= S[i];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
      function nextState() {
        for (var X = this._X, C = this._C, i = 0; i < 8; i++) C_[i] = C[i];
        C[0] = C[0] + 1295307597 + this._b | 0, C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0, C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0, C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0, C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0, C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0, C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0, C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0, this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
        for (var i = 0; i < 8; i++) {
          var gx = X[i] + C[i],
            ga = gx & 65535,
            gb = gx >>> 16,
            gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb,
            gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
          G[i] = gh ^ gl;
        }
        X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0, X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0, X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0, X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0, X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0, X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0, X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0, X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
      }
      __name(nextState, "nextState"), C.Rabbit = StreamCipher._createHelper(Rabbit);
    }(), CryptoJS.Rabbit;
  });
});
var require_rabbit_legacy = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        StreamCipher = C_lib.StreamCipher,
        C_algo = C.algo,
        S = [],
        C_ = [],
        G = [],
        RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function () {
            var K = this._key.words,
              iv = this.cfg.iv,
              X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16],
              C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 4294901760 | K[1] & 65535, K[3] << 16 | K[3] >>> 16, K[1] & 4294901760 | K[2] & 65535, K[0] << 16 | K[0] >>> 16, K[2] & 4294901760 | K[3] & 65535, K[1] << 16 | K[1] >>> 16, K[3] & 4294901760 | K[0] & 65535];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words,
                IV_0 = IV[0],
                IV_1 = IV[1],
                i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360,
                i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360,
                i1 = i0 >>> 16 | i2 & 4294901760,
                i3 = i2 << 16 | i0 & 65535;
              C[0] ^= i0, C[1] ^= i1, C[2] ^= i2, C[3] ^= i3, C[4] ^= i0, C[5] ^= i1, C[6] ^= i2, C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function (M, offset) {
            var X = this._X;
            nextState.call(this), S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16, S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16, S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16, S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360, M[offset + i] ^= S[i];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
      function nextState() {
        for (var X = this._X, C = this._C, i = 0; i < 8; i++) C_[i] = C[i];
        C[0] = C[0] + 1295307597 + this._b | 0, C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0, C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0, C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0, C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0, C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0, C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0, C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0, this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
        for (var i = 0; i < 8; i++) {
          var gx = X[i] + C[i],
            ga = gx & 65535,
            gb = gx >>> 16,
            gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb,
            gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
          G[i] = gh ^ gl;
        }
        X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0, X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0, X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0, X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0, X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0, X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0, X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0, X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
      }
      __name(nextState, "nextState"), C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
    }(), CryptoJS.RabbitLegacy;
  });
});
var require_blowfish = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), up(), fp(), fd(), Q0()) : typeof define == "function" && define.amd ? define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) : factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return function () {
      var C = CryptoJS,
        C_lib = C.lib,
        BlockCipher = C_lib.BlockCipher,
        C_algo = C.algo;
      let N = 16,
        ORIG_P = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731],
        ORIG_S = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]];
      var BLOWFISH_CTX = {
        pbox: [],
        sbox: []
      };
      function F(ctx, x) {
        let a = x >> 24 & 255,
          b = x >> 16 & 255,
          c = x >> 8 & 255,
          d = x & 255,
          y = ctx.sbox[0][a] + ctx.sbox[1][b];
        return y = y ^ ctx.sbox[2][c], y = y + ctx.sbox[3][d], y;
      }
      __name(F, "F");
      function BlowFish_Encrypt(ctx, left, right) {
        let Xl = left,
          Xr = right,
          temp;
        for (let i = 0; i < N; ++i) Xl = Xl ^ ctx.pbox[i], Xr = F(ctx, Xl) ^ Xr, temp = Xl, Xl = Xr, Xr = temp;
        return temp = Xl, Xl = Xr, Xr = temp, Xr = Xr ^ ctx.pbox[N], Xl = Xl ^ ctx.pbox[N + 1], {
          left: Xl,
          right: Xr
        };
      }
      __name(BlowFish_Encrypt, "BlowFish_Encrypt");
      function BlowFish_Decrypt(ctx, left, right) {
        let Xl = left,
          Xr = right,
          temp;
        for (let i = N + 1; i > 1; --i) Xl = Xl ^ ctx.pbox[i], Xr = F(ctx, Xl) ^ Xr, temp = Xl, Xl = Xr, Xr = temp;
        return temp = Xl, Xl = Xr, Xr = temp, Xr = Xr ^ ctx.pbox[1], Xl = Xl ^ ctx.pbox[0], {
          left: Xl,
          right: Xr
        };
      }
      __name(BlowFish_Decrypt, "BlowFish_Decrypt");
      function BlowFishInit(ctx, key, keysize) {
        for (let Row = 0; Row < 4; Row++) {
          ctx.sbox[Row] = [];
          for (let Col = 0; Col < 256; Col++) ctx.sbox[Row][Col] = ORIG_S[Row][Col];
        }
        let keyIndex = 0;
        for (let index = 0; index < N + 2; index++) ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex], keyIndex++, keyIndex >= keysize && (keyIndex = 0);
        let Data1 = 0,
          Data2 = 0,
          res = 0;
        for (let i = 0; i < N + 2; i += 2) res = BlowFish_Encrypt(ctx, Data1, Data2), Data1 = res.left, Data2 = res.right, ctx.pbox[i] = Data1, ctx.pbox[i + 1] = Data2;
        for (let i = 0; i < 4; i++) for (let j = 0; j < 256; j += 2) res = BlowFish_Encrypt(ctx, Data1, Data2), Data1 = res.left, Data2 = res.right, ctx.sbox[i][j] = Data1, ctx.sbox[i][j + 1] = Data2;
        return !0;
      }
      __name(BlowFishInit, "BlowFishInit");
      var Blowfish = C_algo.Blowfish = BlockCipher.extend({
        _doReset: function () {
          if (this._keyPriorReset !== this._key) {
            var key = this._keyPriorReset = this._key,
              keyWords = key.words,
              keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          }
        },
        encryptBlock: function (M, offset) {
          var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
          M[offset] = res.left, M[offset + 1] = res.right;
        },
        decryptBlock: function (M, offset) {
          var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
          M[offset] = res.left, M[offset + 1] = res.right;
        },
        blockSize: 64 / 32,
        keySize: 128 / 32,
        ivSize: 64 / 32
      });
      C.Blowfish = BlockCipher._createHelper(Blowfish);
    }(), CryptoJS.Blowfish;
  });
});
var require_crypto_js = __commonJSMin((exports, module) => {
  (function (root, factory, undef) {
    typeof exports == "object" ? module.exports = exports = factory(Ea(), O3(), RM(), OM(), up(), DM(), fp(), AT(), Ny(), qM(), PT(), $M(), GM(), WM(), Fy(), YM(), fd(), Q0(), eB(), rB(), iB(), oB(), lB(), uB(), dB(), mB(), gB(), yB(), xB(), EB(), TB(), wB(), AB(), RB(), OB()) : typeof define == "function" && define.amd ? define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory) : root.CryptoJS = factory(root.CryptoJS);
  })(exports, function (CryptoJS) {
    return CryptoJS;
  });
});
var B1 = T((L3, NT) => {
  (function (root, factory) {
    if (typeof exports == "object" && typeof module == "object") module.exports = factory();else if (typeof define == "function" && define.amd) define([], factory);else {
      var a = factory();
      for (var i in a) (typeof exports == "object" ? exports : root)[i] = a[i];
    }
  })(this, () => (() => {
    "use strict";

    var t = {
        470: t => {
          function assertPath(path) {
            if (typeof path != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
          }
          assertPath(assertPath, "assertPath");
          function normalizeStringPosix(path, allowAboveRoot) {
            for (var code, res = "", lastSegmentLength = 0, lastSlash = -lastSlash, dots = 0, i = 0; i <= path.length; ++i) {
              if (i < path.length) code = path.charCodeAt(i);else {
                if (code === 47) break;
                code = 47;
              }
              if (code === 47) {
                if (!(lastSlash === i - 1 || dots === 1)) if (lastSlash !== i - 1 && dots === 2) {
                  if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                      var lastSlashIndex = res.lastIndexOf("/");
                      if (lastSlashIndex !== res.length - 1) {
                        lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : lastSegmentLength = (res = res.slice(0, lastSlashIndex)).length - 1 - res.lastIndexOf("/"), lastSlash = i, dots = 0;
                        continue;
                      }
                    } else if (res.length === 2 || res.length === 1) {
                      res = "", lastSegmentLength = 0, lastSlash = i, dots = 0;
                      continue;
                    }
                  }
                  allowAboveRoot && (res.length > 0 ? res += "/.." : res = "..", lastSegmentLength = 2);
                } else res.length > 0 ? res += "/" + path.slice(lastSlash + 1, i) : res = path.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;
                lastSlash = i, dots = 0;
              } else code === 46 && dots !== -code ? ++dots : dots = -dots;
            }
            return res;
          }
          normalizeStringPosix(normalizeStringPosix, "normalizeStringPosix");
          var posix = {
            resolve: function () {
              for (var cwd, resolvedPath = "", resolvedAbsolute = !resolvedAbsolute, i = arguments.length - 1; i >= -i && !resolvedAbsolute; i--) {
                var path;
                i >= 0 ? path = arguments[i] : (cwd === void i && (cwd = process.cwd()), path = cwd), assertPath(path), path.length !== 0 && (resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47);
              }
              return resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute), resolvedAbsolute ? resolvedPath.length > 0 ? "/" + resolvedPath : "/" : resolvedPath.length > 0 ? resolvedPath : ".";
            },
            normalize: function (path) {
              if (assertPath(path), path.length === 0) return ".";
              var isAbsolute = path.charCodeAt(0) === 47,
                trailingSeparator = path.charCodeAt(path.length - 1) === 47;
              return (path = normalizeStringPosix(path, !isAbsolute)).length !== 0 || isAbsolute || (path = "."), path.length > 0 && trailingSeparator && (path += "/"), isAbsolute ? "/" + path : path;
            },
            isAbsolute: function (path) {
              return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
            },
            join: function () {
              if (arguments.length === 0) return ".";
              for (var joined, i = 0; i < arguments.length; ++i) {
                var arg = arguments[i];
                assertPath(arg), arg.length > 0 && (joined === void 0 ? joined = arg : joined += "/" + arg);
              }
              return joined === void 0 ? "." : posix.normalize(joined);
            },
            relative: function (from, to) {
              if (assertPath(from), assertPath(to), from === to || (from = posix.resolve(from)) === (to = posix.resolve(to))) return "";
              for (var fromStart = 1; fromStart < from.length && from.charCodeAt(fromStart) === 47; ++fromStart);
              for (var fromEnd = from.length, fromLen = fromEnd - fromStart, toStart = 1; toStart < to.length && to.charCodeAt(toStart) === 47; ++toStart);
              for (var toLen = to.length - toStart, length = fromLen < toLen ? fromLen : toLen, lastCommonSep = -lastCommonSep, i = 0; i <= length; ++i) {
                if (i === length) {
                  if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47) return to.slice(toStart + i + 1);
                    if (i === 0) return to.slice(toStart + i);
                  } else fromLen > length && (from.charCodeAt(fromStart + i) === 47 ? lastCommonSep = i : i === 0 && (lastCommonSep = 0));
                  break;
                }
                var fromCode = from.charCodeAt(fromStart + i);
                if (fromCode !== to.charCodeAt(toStart + i)) break;
                fromCode === 47 && (lastCommonSep = i);
              }
              var out = "";
              for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) i !== fromEnd && from.charCodeAt(i) !== 47 || (out.length === 0 ? out += ".." : out += "/..");
              return out.length > 0 ? out + to.slice(toStart + lastCommonSep) : (toStart += lastCommonSep, to.charCodeAt(toStart) === 47 && ++toStart, to.slice(toStart));
            },
            _makeLong: function (path) {
              return path;
            },
            dirname: function (path) {
              if (assertPath(path), path.length === 0) return ".";
              for (var code = path.charCodeAt(0), hasRoot = code === 47, end = -end, matchedSlash = !matchedSlash, i = path.length - 1; i >= 1; --i) if ((code = path.charCodeAt(i)) === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else matchedSlash = !matchedSlash;
              return end === -1 ? hasRoot ? "/" : "." : hasRoot && end === 1 ? "//" : path.slice(0, end);
            },
            basename: function (path, ext) {
              if (ext !== void 0 && typeof ext != "string") throw new TypeError('"ext" argument must be a string');
              assertPath(path);
              var i,
                start = 0,
                end = -end,
                matchedSlash = !matchedSlash;
              if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                if (ext.length === path.length && ext === path) return "";
                var extIdx = ext.length - 1,
                  firstNonSlashEnd = -firstNonSlashEnd;
                for (i = path.length - 1; i >= 0; --i) {
                  var code = path.charCodeAt(i);
                  if (code === 47) {
                    if (!matchedSlash) {
                      start = i + 1;
                      break;
                    }
                  } else firstNonSlashEnd === -1 && (matchedSlash = !matchedSlash, firstNonSlashEnd = i + 1), extIdx >= 0 && (code === ext.charCodeAt(extIdx) ? --extIdx == -extIdx && (end = i) : (extIdx = -extIdx, end = firstNonSlashEnd));
                }
                return start === end ? end = firstNonSlashEnd : end === -firstNonSlashEnd && (end = path.length), path.slice(start, end);
              }
              for (i = path.length - 1; i >= 0; --i) if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else end === -1 && (matchedSlash = !matchedSlash, end = i + 1);
              return end === -1 ? "" : path.slice(start, end);
            },
            extname: function (path) {
              assertPath(path);
              for (var startDot = -startDot, startPart = 0, end = -end, matchedSlash = !matchedSlash, preDotState = 0, i = path.length - 1; i >= 0; --i) {
                var code = path.charCodeAt(i);
                if (code !== 47) end === -code && (matchedSlash = !matchedSlash, end = i + 1), code === 46 ? startDot === -code ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -preDotState);else if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
              }
              return startDot === -1 || end === -startDot || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
            },
            format: function (pathObject) {
              if (pathObject === null || typeof pathObject != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
              return function (sep, pathObject) {
                var dir = pathObject.dir || pathObject.root,
                  base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
                return dir ? dir === pathObject.root ? dir + base : dir + "/" + base : base;
              }(0, pathObject);
            },
            parse: function (path) {
              assertPath(path);
              var ret = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
              };
              if (path.length === 0) return ret;
              var start,
                code = path.charCodeAt(0),
                isAbsolute = code === 47;
              isAbsolute ? (ret.root = "/", start = 1) : start = 0;
              for (var startDot = -startDot, startPart = 0, end = -end, matchedSlash = !matchedSlash, i = path.length - 1, preDotState = 0; i >= start; --i) if ((code = path.charCodeAt(i)) !== 47) end === -i && (matchedSlash = !matchedSlash, end = i + 1), code === 46 ? startDot === -code ? startDot = i : preDotState !== 1 && (preDotState = 1) : startDot !== -1 && (preDotState = -preDotState);else if (!matchedSlash) {
                startPart = i + 1;
                break;
              }
              return startDot === -1 || end === -startDot || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1 ? end !== -1 && (ret.base = ret.name = startPart === 0 && isAbsolute ? path.slice(1, end) : path.slice(startPart, end)) : (startPart === 0 && isAbsolute ? (ret.name = path.slice(1, startDot), ret.base = path.slice(1, end)) : (ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end)), ret.ext = path.slice(startDot, end)), startPart > 0 ? ret.dir = path.slice(0, startPart - 1) : isAbsolute && (ret.dir = "/"), ret;
            },
            sep: "/",
            delimiter: ":",
            win32: null,
            posix: null
          };
          posix.posix = posix, module.exports = posix;
        },
        posix: (posix, posix) => {
          if (posix.defineProperty(e, "__esModule", {
            value: !0
          }), e.isWindows = void 0, typeof process == "object") e.isWindows = process.platform === "win32";else if (typeof navigator == "object") {
            var userAgent = navigator.userAgent;
            e.isWindows = userAgent.indexOf("Windows") >= 0;
          }
        },
        796: function (t, e, r) {
          var n,
            o,
            i = this && this.__extends || (n = __name(function (t, e) {
              return n = Object.setPrototypeOf || {
                __proto__: []
              } instanceof Array && function (t, e) {
                t.__proto__ = e;
              } || function (t, e) {
                for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
              }, n(t, e);
            }, "n"), function (t, e) {
              if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
              function r() {
                this.constructor = t;
              }
              __name(r, "r"), n(t, e), t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
            });
          Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.uriToFsPath = e.URI = void 0;
          var a = r(674),
            _schemePattern = /^\w[\w\d+.-]*$/,
            _singleSlashStart = /^\//,
            _doubleSlashStart = /^\/\//;
          function _validateUri(ret, _strict) {
            if (!ret.scheme && _strict) throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(ret.authority, '", path: "').concat(ret.path, '", query: "').concat(ret.query, '", fragment: "').concat(ret.fragment, '"}'));
            if (ret.scheme && !_schemePattern.test(ret.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
            if (ret.path) {
              if (ret.authority) {
                if (!_singleSlashStart.test(ret.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
              } else if (_doubleSlashStart.test(ret.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
          }
          _validateUri(_validateUri, "_validateUri");
          var _empty = "",
            _slash = "/",
            _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,
            d = function () {
              function t(schemeOrData, authority, path, query, fragment, _strict) {
                _strict === void _strict && (_strict = !_strict), typeof schemeOrData == "object" ? (this.scheme = schemeOrData.scheme || _empty, this.authority = schemeOrData.authority || _empty, this.path = schemeOrData.path || _empty, this.query = schemeOrData.query || _empty, this.fragment = schemeOrData.fragment || _empty) : (this.scheme = function (scheme, _strict) {
                  return scheme || _strict ? scheme : "file";
                }(schemeOrData, _strict), this.authority = authority || _empty, this.path = function (scheme, path) {
                  switch (scheme) {
                    case "https":
                    case "http":
                    case "file":
                      path ? path[0] !== _slash && (path = _slash + path) : path = _slash;
                  }
                  return path;
                }(this.scheme, path || _empty), this.query = query || _empty, this.fragment = fragment || _empty, _validateUri(this, _strict));
              }
              return __name(t, "t"), t.isUri = function (thing) {
                return thing instanceof URI || !!thing && typeof thing.authority == "string" && typeof thing.fragment == "string" && typeof thing.path == "string" && typeof thing.query == "string" && typeof thing.scheme == "string" && typeof thing.fsPath == "string" && typeof thing.with == "function" && typeof thing.toString == "function";
              }, Object.defineProperty(t.prototype, "fsPath", {
                get: function () {
                  return uriToFsPath(this, !this);
                },
                enumerable: !1,
                configurable: !0
              }), t.prototype.with = function (change) {
                if (!change) return this;
                var scheme = change.scheme,
                  authority = change.authority,
                  path = change.path,
                  query = change.query,
                  fragment = change.fragment;
                return scheme === void 0 ? scheme = this.scheme : scheme === null && (scheme = _empty), authority === void _empty ? authority = this.authority : authority === null && (authority = _empty), path === void _empty ? path = this.path : path === null && (path = _empty), query === void _empty ? query = this.query : query === null && (query = _empty), fragment === void _empty ? fragment = this.fragment : fragment === null && (fragment = _empty), scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment ? this : new Uri(scheme, authority, path, query, fragment);
              }, t.parse = function (value, _strict) {
                _strict === void _strict && (_strict = !_strict);
                var match = _regexp.exec(value);
                return match ? new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict) : new Uri(_empty, _empty, _empty, _empty, _empty);
              }, t.file = function (path) {
                var authority = _empty;
                if (a.isWindows && (path = path.replace(/\\/g, _slash)), path[0] === _slash && path[1] === _slash) {
                  var idx = path.indexOf(_slash, 2);
                  idx === -1 ? (authority = path.substring(2), path = _slash) : (authority = path.substring(2, idx), path = path.substring(idx) || _slash);
                }
                return new Uri("file", authority, path, _empty, _empty);
              }, t.from = function (components) {
                var result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);
                return _validateUri(result, !result), result;
              }, t.prototype.toString = function (skipEncoding) {
                return skipEncoding === void 0 && (skipEncoding = !skipEncoding), _asFormatted(this, skipEncoding);
              }, t.prototype.toJSON = function () {
                return this;
              }, t.revive = function (data) {
                if (data) {
                  if (data instanceof URI) return data;
                  var result = new Uri(data);
                  return result._formatted = data.external, result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null, result;
                }
                return data;
              }, t;
            }();
          e.URI = URI;
          var _pathSepMarker = a.isWindows ? 1 : void 0,
            v = function (t) {
              function e() {
                var e = t !== null && t.apply(this, arguments) || this;
                return e._formatted = null, e._fsPath = null, e;
              }
              return __name(e, "e"), i(e, t), Object.defineProperty(e.prototype, "fsPath", {
                get: function () {
                  return this._fsPath || (this._fsPath = uriToFsPath(this, !this)), this._fsPath;
                },
                enumerable: !1,
                configurable: !0
              }), e.prototype.toString = function (skipEncoding) {
                return skipEncoding === void 0 && (skipEncoding = !skipEncoding), skipEncoding ? _asFormatted(this, !this) : (this._formatted || (this._formatted = _asFormatted(this, !this)), this._formatted);
              }, e.prototype.toJSON = function () {
                var res = {
                  $mid: 1
                };
                return this._fsPath && (res.fsPath = this._fsPath, res._sep = _pathSepMarker), this._formatted && (res.external = this._formatted), this.path && (res.path = this.path), this.scheme && (res.scheme = this.scheme), this.authority && (res.authority = this.authority), this.query && (res.query = this.query), this.fragment && (res.fragment = this.fragment), res;
              }, e;
            }(URI),
            encodeTable = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
          function encodeURIComponentFast(uriComponent, isPath, isAuthority) {
            for (var res = void res, nativeEncodePos = -nativeEncodePos, pos = 0; pos < uriComponent.length; pos++) {
              var code = uriComponent.charCodeAt(pos);
              if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || isPath && code === 47 || isAuthority && code === 91 || isAuthority && code === 93 || isAuthority && code === 58) nativeEncodePos !== -code && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos)), nativeEncodePos = -nativeEncodePos), res !== void 0 && (res += uriComponent.charAt(pos));else {
                res === void 0 && (res = uriComponent.substr(0, pos));
                var escaped = encodeTable[code];
                escaped !== void code ? (nativeEncodePos !== -escaped && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos)), nativeEncodePos = -nativeEncodePos), res += escaped) : nativeEncodePos === -escaped && (nativeEncodePos = pos);
              }
            }
            return nativeEncodePos !== -1 && (res += encodeURIComponent(uriComponent.substring(nativeEncodePos))), res !== void nativeEncodePos ? res : uriComponent;
          }
          encodeURIComponentFast(encodeURIComponentFast, "encodeURIComponentFast");
          function encodeURIComponentMinimal(path) {
            for (var res = void res, pos = 0; pos < path.length; pos++) {
              var code = path.charCodeAt(pos);
              code === 35 || code === 63 ? (res === void code && (res = path.substr(0, pos)), res += encodeTable[code]) : res !== void code && (res += path[pos]);
            }
            return res !== void 0 ? res : path;
          }
          encodeURIComponentMinimal(encodeURIComponentMinimal, "encodeURIComponentMinimal");
          function uriToFsPath(uri, keepDriveLetterCasing) {
            var value;
            return value = uri.authority && uri.path.length > 1 && uri.scheme === "file" ? "//".concat(uri.authority).concat(uri.path) : uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58 ? keepDriveLetterCasing ? uri.path.substr(1) : uri.path[1].toLowerCase() + uri.path.substr(2) : uri.path, a.isWindows && (value = value.replace(/\//g, "\\")), value;
          }
          uriToFsPath(uriToFsPath, "uriToFsPath");
          function _asFormatted(uri, skipEncoding) {
            var encoder = skipEncoding ? encodeURIComponentMinimal : encodeURIComponentFast,
              res = "",
              scheme = uri.scheme,
              authority = uri.authority,
              path = uri.path,
              query = uri.query,
              fragment = uri.fragment;
            if (scheme && (res += scheme, res += ":"), (authority || scheme === "file") && (res += _slash, res += _slash), authority) {
              var idx = authority.indexOf("@");
              if (idx !== -1) {
                var userinfo = authority.substr(0, idx);
                authority = authority.substr(idx + 1), (idx = userinfo.lastIndexOf(":")) === -1 ? res += encoder(userinfo, !userinfo, !1) : (res += encoder(userinfo.substr(0, idx), !idx, !1), res += ":", res += encoder(userinfo.substr(idx + 1), !1, !0)), res += "@";
              }
              (idx = (authority = authority.toLowerCase()).lastIndexOf(":")) === -1 ? res += encoder(authority, !authority, !0) : (res += encoder(authority.substr(0, idx), !idx, !0), res += authority.substr(idx));
            }
            if (path) {
              if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) (code = path.charCodeAt(1)) >= 65 && code <= 90 && (path = "/".concat(String.fromCharCode(code + 32), ":").concat(path.substr(3)));else if (path.length >= 2 && path.charCodeAt(1) === 58) {
                var code;
                (code = path.charCodeAt(0)) >= 65 && code <= 90 && (path = "".concat(String.fromCharCode(code + 32), ":").concat(path.substr(2)));
              }
              res += encoder(path, !path, !1);
            }
            return query && (res += "?", res += encoder(query, !query, !1)), fragment && (res += "#", res += skipEncoding ? fragment : encodeURIComponentFast(fragment, !fragment, !1)), res;
          }
          _asFormatted(_asFormatted, "_asFormatted");
          function decodeURIComponentGraceful(str) {
            try {
              return decodeURIComponent(str);
            } catch {
              return str.length > 3 ? str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3)) : str;
            }
          }
          decodeURIComponentGraceful(decodeURIComponentGraceful, "decodeURIComponentGraceful"), e.uriToFsPath = C;
          var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
          function percentDecode(str) {
            return str.match(_rEncodedAsHex) ? str.replace(_rEncodedAsHex, function (match) {
              return decodeURIComponentGraceful(match);
            }) : str;
          }
          percentDecode(percentDecode, "percentDecode");
        },
        679: function (t, e, r) {
          var n = this && this.__spreadArray || function (t, e, r) {
            if (r || arguments.length === 2) for (var n, o = 0, i = e.length; o < i; o++) !n && o in e || (n || (n = Array.prototype.slice.call(e, 0, o)), n[o] = e[o]);
            return t.concat(n || Array.prototype.slice.call(e));
          };
          Object.defineProperty(e, "__esModule", {
            value: !0
          }), e.Utils = void 0;
          var Utils,
            i = r(470),
            posixPath = nodePath.posix || nodePath,
            slash = "/";
          (Utils = e.Utils || (e.Utils = {})).joinPath = function (uri) {
            for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
            return uri.with({
              path: posixPath.join.apply(posixPath, n([uri.path], paths, !paths))
            });
          }, o.resolvePath = function (uri) {
            for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
            var path = uri.path,
              slashAdded = !slashAdded;
            path[0] !== slash && (path = slash + path, slashAdded = !slashAdded);
            var resolvedPath = posixPath.resolve.apply(posixPath, n([path], paths, !paths));
            return slashAdded && resolvedPath[0] === slash && !uri.authority && (resolvedPath = resolvedPath.substring(1)), uri.with({
              path: resolvedPath
            });
          }, o.dirname = function (uri) {
            if (uri.path.length === 0 || uri.path === slash) return uri;
            var path = posixPath.dirname(uri.path);
            return path.length === 1 && path.charCodeAt(0) === 46 && (path = ""), uri.with({
              path: e
            });
          }, o.basename = function (uri) {
            return posixPath.basename(uri.path);
          }, o.extname = function (uri) {
            return posixPath.extname(uri.path);
          };
        }
      },
      __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
      var cachedModule = __webpack_module_cache__[moduleId];
      if (cachedModule !== void 0) return cachedModule.exports;
      var module = __webpack_module_cache__[moduleId] = {
        exports: {}
      };
      return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.exports;
    }
    __webpack_require__(__webpack_require__, "r");
    var n = {};
    return (() => {
      var t = n;
      Object.defineProperty(t, "__esModule", {
        value: !0
      }), t.Utils = t.URI = void 0;
      var e = r(796);
      Object.defineProperty(t, "URI", {
        enumerable: !0,
        get: function () {
          return e.URI;
        }
      });
      var o = r(679);
      Object.defineProperty(t, "Utils", {
        enumerable: !0,
        get: function () {
          return o.Utils;
        }
      });
    })(), n;
  })());
});
var require_typebox = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = void 0;
  exports.Readonly = Symbol.for("TypeBox.Readonly");
  exports.Optional = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}$`;
  exports.PatternStringExact = `^${exports.PatternString}$`;
  var TypeRegistry;
  (function (TypeRegistry) {
    let map = new Map();
    function Entries() {
      return new Map(map);
    }
    __name(Entries, "Entries"), TypeRegistry.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    __name(Clear, "Clear"), TypeRegistry.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    __name(Delete, "Delete"), TypeRegistry.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    __name(Has, "Has"), TypeRegistry.Has = Has;
    function Set(kind, func) {
      map.set(kind, func);
    }
    __name(Set, "Set"), TypeRegistry.Set = Set;
    function Get(kind) {
      return map.get(kind);
    }
    __name(Get, "Get"), TypeRegistry.Get = Get;
  })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
  var FormatRegistry;
  (function (FormatRegistry) {
    let map = new Map();
    function Entries() {
      return new Map(map);
    }
    __name(Entries, "Entries"), FormatRegistry.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    __name(Clear, "Clear"), FormatRegistry.Clear = Clear;
    function Delete(format) {
      return map.delete(format);
    }
    __name(Delete, "Delete"), FormatRegistry.Delete = Delete;
    function Has(format) {
      return map.has(format);
    }
    __name(Has, "Has"), FormatRegistry.Has = Has;
    function Set(format, func) {
      map.set(format, func);
    }
    __name(Set, "Set"), FormatRegistry.Set = Set;
    function Get(format) {
      return map.get(format);
    }
    __name(Get, "Get"), FormatRegistry.Get = Get;
  })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function (ValueGuard) {
    function IsObject(value) {
      return typeof value == "object" && value !== null;
    }
    __name(IsObject, "IsObject"), ValueGuard.IsObject = IsObject;
    function IsArray(value) {
      return Array.isArray(value);
    }
    __name(IsArray, "IsArray"), ValueGuard.IsArray = IsArray;
    function IsBoolean(value) {
      return typeof value == "boolean";
    }
    __name(IsBoolean, "IsBoolean"), ValueGuard.IsBoolean = IsBoolean;
    function IsNull(value) {
      return value === null;
    }
    __name(IsNull, "IsNull"), ValueGuard.IsNull = IsNull;
    function IsUndefined(value) {
      return value === void 0;
    }
    __name(IsUndefined, "IsUndefined"), ValueGuard.IsUndefined = IsUndefined;
    function IsBigInt(value) {
      return typeof value == "bigint";
    }
    __name(IsBigInt, "IsBigInt"), ValueGuard.IsBigInt = IsBigInt;
    function IsNumber(value) {
      return typeof value == "number";
    }
    __name(IsNumber, "IsNumber"), ValueGuard.IsNumber = IsNumber;
    function IsString(value) {
      return typeof value == "string";
    }
    __name(IsString, "IsString"), ValueGuard.IsString = IsString;
  })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
  var TypeGuardUnknownTypeError = class extends Error {
    static {
      __name(this, "TypeGuardUnknownTypeError");
    }
    constructor(schema) {
      super("TypeGuard: Unknown type"), this.schema = schema;
    }
  };
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function (TypeGuard) {
    function IsPattern(value) {
      try {
        return new RegExp(value), !0;
      } catch {
        return !1;
      }
    }
    __name(IsPattern, "IsPattern");
    function IsControlCharacterFree(value) {
      if (!ValueGuard.IsString(value)) return !1;
      for (let i = 0; i < value.length; i++) {
        let code = value.charCodeAt(i);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) return !1;
      }
      return !0;
    }
    __name(IsControlCharacterFree, "IsControlCharacterFree");
    function IsAdditionalProperties(value) {
      return IsOptionalBoolean(value) || TSchema(value);
    }
    __name(IsAdditionalProperties, "IsAdditionalProperties");
    function IsOptionalBigInt(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    __name(IsOptionalBigInt, "IsOptionalBigInt");
    function IsOptionalNumber(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    __name(IsOptionalNumber, "IsOptionalNumber");
    function IsOptionalBoolean(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    __name(IsOptionalBoolean, "IsOptionalBoolean");
    function IsOptionalString(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    __name(IsOptionalString, "IsOptionalString");
    function IsOptionalPattern(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
    }
    __name(IsOptionalPattern, "IsOptionalPattern");
    function IsOptionalFormat(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
    }
    __name(IsOptionalFormat, "IsOptionalFormat");
    function IsOptionalSchema(value) {
      return ValueGuard.IsUndefined(value) || TSchema(value);
    }
    __name(IsOptionalSchema, "IsOptionalSchema");
    function TAny(schema) {
      return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
    }
    __name(TAny, "TAny"), TypeGuard.TAny = TAny;
    function TArray(schema) {
      return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
    }
    __name(TArray, "TArray"), TypeGuard.TArray = TArray;
    function TAsyncIterator(schema) {
      return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    __name(TAsyncIterator, "TAsyncIterator"), TypeGuard.TAsyncIterator = TAsyncIterator;
    function TBigInt(schema) {
      return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);
    }
    __name(TBigInt, "TBigInt"), TypeGuard.TBigInt = TBigInt;
    function TBoolean(schema) {
      return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
    }
    __name(TBoolean, "TBoolean"), TypeGuard.TBoolean = TBoolean;
    function TConstructor(schema) {
      if (!(TKindOf(schema, "Constructor") && schema.type === "constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && TSchema(schema.returns))) return !1;
      for (let parameter of schema.parameters) if (!TSchema(parameter)) return !1;
      return !0;
    }
    __name(TConstructor, "TConstructor"), TypeGuard.TConstructor = TConstructor;
    function TDate(schema) {
      return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);
    }
    __name(TDate, "TDate"), TypeGuard.TDate = TDate;
    function TFunction(schema) {
      if (!(TKindOf(schema, "Function") && schema.type === "function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && TSchema(schema.returns))) return !1;
      for (let parameter of schema.parameters) if (!TSchema(parameter)) return !1;
      return !0;
    }
    __name(TFunction, "TFunction"), TypeGuard.TFunction = TFunction;
    function TInteger(schema) {
      return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
    }
    __name(TInteger, "TInteger"), TypeGuard.TInteger = TInteger;
    function TIntersect(schema) {
      if (!(TKindOf(schema, "Intersect") && ValueGuard.IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id)) || "type" in schema && schema.type !== "object") return !1;
      for (let inner of schema.allOf) if (!TSchema(inner)) return !1;
      return !0;
    }
    __name(TIntersect, "TIntersect"), TypeGuard.TIntersect = TIntersect;
    function TIterator(schema) {
      return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    __name(TIterator, "TIterator"), TypeGuard.TIterator = TIterator;
    function TKindOf(schema, kind) {
      return TKind(schema) && schema[exports.Kind] === kind;
    }
    __name(TKindOf, "TKindOf"), TypeGuard.TKindOf = TKindOf;
    function TKind(schema) {
      return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
    }
    __name(TKind, "TKind"), TypeGuard.TKind = TKind;
    function TLiteralString(schema) {
      return TLiteral(schema) && ValueGuard.IsString(schema.const);
    }
    __name(TLiteralString, "TLiteralString"), TypeGuard.TLiteralString = TLiteralString;
    function TLiteralNumber(schema) {
      return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
    }
    __name(TLiteralNumber, "TLiteralNumber"), TypeGuard.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema) {
      return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
    }
    __name(TLiteralBoolean, "TLiteralBoolean"), TypeGuard.TLiteralBoolean = TLiteralBoolean;
    function TLiteral(schema) {
      return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
    }
    __name(TLiteral, "TLiteral"), TypeGuard.TLiteral = TLiteral;
    function TNever(schema) {
      return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
    }
    __name(TNever, "TNever"), TypeGuard.TNever = TNever;
    function TNot(schema) {
      return TKindOf(schema, "Not") && TSchema(schema.not);
    }
    __name(TNot, "TNot"), TypeGuard.TNot = TNot;
    function TNull(schema) {
      return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
    }
    __name(TNull, "TNull"), TypeGuard.TNull = TNull;
    function TNumber(schema) {
      return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);
    }
    __name(TNumber, "TNumber"), TypeGuard.TNumber = TNumber;
    function TObject(schema) {
      if (!(TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) return !1;
      for (let [key, value] of Object.entries(schema.properties)) if (!IsControlCharacterFree(key) || !TSchema(value)) return !1;
      return !0;
    }
    __name(TObject, "TObject"), TypeGuard.TObject = TObject;
    function TPromise(schema) {
      return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
    }
    __name(TPromise, "TPromise"), TypeGuard.TPromise = TPromise;
    function TRecord(schema) {
      if (!(TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties))) return !1;
      let keys = Object.getOwnPropertyNames(schema.patternProperties);
      return !(keys.length !== 1 || !IsPattern(keys[0]) || !TSchema(schema.patternProperties[keys[0]]));
    }
    __name(TRecord, "TRecord"), TypeGuard.TRecord = TRecord;
    function TRef(schema) {
      return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    __name(TRef, "TRef"), TypeGuard.TRef = TRef;
    function TString(schema) {
      return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
    }
    __name(TString, "TString"), TypeGuard.TString = TString;
    function TSymbol(schema) {
      return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
    }
    __name(TSymbol, "TSymbol"), TypeGuard.TSymbol = TSymbol;
    function TTemplateLiteral(schema) {
      return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
    }
    __name(TTemplateLiteral, "TTemplateLiteral"), TypeGuard.TTemplateLiteral = TTemplateLiteral;
    function TThis(schema) {
      return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    __name(TThis, "TThis"), TypeGuard.TThis = TThis;
    function TTuple(schema) {
      if (!(TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) return !1;
      if (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0) return !0;
      if (!ValueGuard.IsArray(schema.items)) return !1;
      for (let inner of schema.items) if (!TSchema(inner)) return !1;
      return !0;
    }
    __name(TTuple, "TTuple"), TypeGuard.TTuple = TTuple;
    function TUndefined(schema) {
      return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
    }
    __name(TUndefined, "TUndefined"), TypeGuard.TUndefined = TUndefined;
    function TUnionLiteral(schema) {
      return TUnion(schema) && schema.anyOf.every(schema => TLiteralString(schema) || TLiteralNumber(schema));
    }
    __name(TUnionLiteral, "TUnionLiteral"), TypeGuard.TUnionLiteral = TUnionLiteral;
    function TUnion(schema) {
      if (!(TKindOf(schema, "Union") && ValueGuard.IsArray(schema.anyOf) && IsOptionalString(schema.$id))) return !1;
      for (let inner of schema.anyOf) if (!TSchema(inner)) return !1;
      return !0;
    }
    __name(TUnion, "TUnion"), TypeGuard.TUnion = TUnion;
    function TUint8Array(schema) {
      return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    __name(TUint8Array, "TUint8Array"), TypeGuard.TUint8Array = TUint8Array;
    function TUnknown(schema) {
      return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
    }
    __name(TUnknown, "TUnknown"), TypeGuard.TUnknown = TUnknown;
    function TUnsafe(schema) {
      return TKindOf(schema, "Unsafe");
    }
    __name(TUnsafe, "TUnsafe"), TypeGuard.TUnsafe = TUnsafe;
    function TVoid(schema) {
      return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
    }
    __name(TVoid, "TVoid"), TypeGuard.TVoid = TVoid;
    function TReadonly(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
    }
    __name(TReadonly, "TReadonly"), TypeGuard.TReadonly = TReadonly;
    function TOptional(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
    }
    __name(TOptional, "TOptional"), TypeGuard.TOptional = TOptional;
    function TSchema(schema) {
      return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
    }
    __name(TSchema, "TSchema"), TypeGuard.TSchema = TSchema;
  })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function (ExtendsUndefined) {
    function Check(schema) {
      return schema[exports.Kind] === "Undefined" ? !0 : schema[exports.Kind] === "Not" ? !Check(schema.not) : schema[exports.Kind] === "Intersect" ? schema.allOf.every(schema => Check(schema)) : schema[exports.Kind] === "Union" ? schema.anyOf.some(schema => Check(schema)) : !1;
    }
    __name(Check, "Check"), ExtendsUndefined.Check = Check;
  })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
  var TypeExtendsResult;
  (function (TypeExtendsResult) {
    TypeExtendsResult[TypeExtendsResult.Union = 0] = "Union", TypeExtendsResult[TypeExtendsResult.True = 1] = "True", TypeExtendsResult[TypeExtendsResult.False = 2] = "False";
  })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function (TypeExtends) {
    function IntoBooleanResult(result) {
      return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    __name(IntoBooleanResult, "IntoBooleanResult");
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    __name(IsStructuralRight, "IsStructuralRight");
    function StructuralRight(left, right) {
      if (TypeGuard.TNever(right)) return TNeverRight(left, right);
      if (TypeGuard.TIntersect(right)) return TIntersectRight(left, right);
      if (TypeGuard.TUnion(right)) return TUnionRight(left, right);
      if (TypeGuard.TUnknown(right)) return TUnknownRight(left, right);
      if (TypeGuard.TAny(right)) return TAnyRight(left, right);
      throw Error("TypeExtends: StructuralRight");
    }
    __name(StructuralRight, "StructuralRight");
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    __name(TAnyRight, "TAnyRight");
    function TAny(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some(schema => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) || TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    __name(TAny, "TAny");
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TArrayRight, "TArrayRight");
    function TArray(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) ? IntoBooleanResult(Visit(left.items, right.items)) : TypeExtendsResult.False;
    }
    __name(TArray, "TArray");
    function TAsyncIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TAsyncIterator(right) ? IntoBooleanResult(Visit(left.items, right.items)) : TypeExtendsResult.False;
    }
    __name(TAsyncIterator, "TAsyncIterator");
    function TBigInt(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TBigInt, "TBigInt");
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) || TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TBooleanRight, "TBooleanRight");
    function TBoolean(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TBoolean, "TBoolean");
    function TConstructor(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) || left.parameters.length > right.parameters.length || !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    __name(TConstructor, "TConstructor");
    function TDate(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TDate, "TDate");
    function TFunction(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) || left.parameters.length > right.parameters.length || !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    __name(TFunction, "TFunction");
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) || TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TIntegerRight, "TIntegerRight");
    function TInteger(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TInteger, "TInteger");
    function TIntersectRight(left, right) {
      return right.allOf.every(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TIntersectRight, "TIntersectRight");
    function TIntersect(left, right) {
      return left.allOf.some(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TIntersect, "TIntersect");
    function TIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TIterator(right) ? IntoBooleanResult(Visit(left.items, right.items)) : TypeExtendsResult.False;
    }
    __name(TIterator, "TIterator");
    function TLiteral(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TLiteral, "TLiteral");
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    __name(TNeverRight, "TNeverRight");
    function TNever(left, right) {
      return TypeExtendsResult.True;
    }
    __name(TNever, "TNever");
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      for (; TypeGuard.TNot(current);) current = current.not, depth += 1;
      return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    __name(UnwrapTNot, "UnwrapTNot");
    function TNot(left, right) {
      if (TypeGuard.TNot(left)) return Visit(UnwrapTNot(left), right);
      if (TypeGuard.TNot(right)) return Visit(left, UnwrapTNot(right));
      throw new Error("TypeExtends: Invalid fallthrough for Not");
    }
    __name(TNot, "TNot");
    function TNull(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TNull, "TNull");
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) || TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TNumberRight, "TNumberRight");
    function TNumber(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TNumber, "TNumber");
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    __name(IsObjectPropertyCount, "IsObjectPropertyCount");
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    __name(IsObjectStringLike, "IsObjectStringLike");
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
    }
    __name(IsObjectSymbolLike, "IsObjectSymbolLike");
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    __name(IsObjectNumberLike, "IsObjectNumberLike");
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    __name(IsObjectBooleanLike, "IsObjectBooleanLike");
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    __name(IsObjectBigIntLike, "IsObjectBigIntLike");
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    __name(IsObjectDateLike, "IsObjectDateLike");
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    __name(IsObjectUint8ArrayLike, "IsObjectUint8ArrayLike");
    function IsObjectFunctionLike(schema) {
      let length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties.length, length)) === TypeExtendsResult.True;
    }
    __name(IsObjectFunctionLike, "IsObjectFunctionLike");
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    __name(IsObjectConstructorLike, "IsObjectConstructorLike");
    function IsObjectArrayLike(schema) {
      let length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties.length, length)) === TypeExtendsResult.True;
    }
    __name(IsObjectArrayLike, "IsObjectArrayLike");
    function IsObjectPromiseLike(schema) {
      let then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties.then, then)) === TypeExtendsResult.True;
    }
    __name(IsObjectPromiseLike, "IsObjectPromiseLike");
    function Property(left, right) {
      return Visit(left, right) === TypeExtendsResult.False || TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    __name(Property, "Property");
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) && IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TObjectRight, "TObjectRight");
    function TObject(left, right) {
      if (IsStructuralRight(right)) return StructuralRight(left, right);
      if (TypeGuard.TRecord(right)) return TRecordRight(left, right);
      if (!TypeGuard.TObject(right)) return TypeExtendsResult.False;
      for (let key of Object.getOwnPropertyNames(right.properties)) if (!(key in left.properties) || Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) return TypeExtendsResult.False;
      return TypeExtendsResult.True;
    }
    __name(TObject, "TObject");
    function TPromise(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : TypeGuard.TPromise(right) ? IntoBooleanResult(Visit(left.item, right.item)) : TypeExtendsResult.False;
    }
    __name(TPromise, "TPromise");
    function RecordKey(schema) {
      if (exports.PatternNumberExact in schema.patternProperties) return exports.Type.Number();
      if (exports.PatternStringExact in schema.patternProperties) return exports.Type.String();
      throw Error("TypeExtends: Cannot get record key");
    }
    __name(RecordKey, "RecordKey");
    function RecordValue(schema) {
      if (exports.PatternNumberExact in schema.patternProperties) return schema.patternProperties[exports.PatternNumberExact];
      if (exports.PatternStringExact in schema.patternProperties) return schema.patternProperties[exports.PatternStringExact];
      throw Error("TypeExtends: Cannot get record value");
    }
    __name(RecordValue, "RecordValue");
    function TRecordRight(left, right) {
      let Key = RecordKey(right),
        Value = RecordValue(right);
      if (TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) return TypeExtendsResult.True;
      if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) || TypeGuard.TString(left) && TypeGuard.TNumber(Key) || TypeGuard.TArray(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);
      if (TypeGuard.TObject(left)) {
        for (let key of Object.getOwnPropertyNames(left.properties)) if (Property(Value, left.properties[key]) === TypeExtendsResult.False) return TypeExtendsResult.False;
        return TypeExtendsResult.True;
      }
      return TypeExtendsResult.False;
    }
    __name(TRecordRight, "TRecordRight");
    function TRecord(left, right) {
      let Value = RecordValue(left);
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? Visit(Value, RecordValue(right)) : TypeExtendsResult.False;
    }
    __name(TRecord, "TRecord");
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) || TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TStringRight, "TStringRight");
    function TString(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TString, "TString");
    function TSymbol(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TSymbol, "TSymbol");
    function TTemplateLiteral(left, right) {
      if (TypeGuard.TTemplateLiteral(left)) return Visit(TemplateLiteralResolver.Resolve(left), right);
      if (TypeGuard.TTemplateLiteral(right)) return Visit(left, TemplateLiteralResolver.Resolve(right));
      throw new Error("TypeExtends: Invalid fallthrough for TemplateLiteral");
    }
    __name(TTemplateLiteral, "TTemplateLiteral");
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every(schema => Visit(schema, right.items) === TypeExtendsResult.True);
    }
    __name(IsArrayOfTuple, "IsArrayOfTuple");
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    __name(TTupleRight, "TTupleRight");
    function TTuple(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) || TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) || ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TTuple, "TTuple");
    function TUint8Array(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TUint8Array, "TUint8Array");
    function TUndefined(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TUndefined, "TUndefined");
    function TUnionRight(left, right) {
      return right.anyOf.some(schema => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TUnionRight, "TUnionRight");
    function TUnion(left, right) {
      return left.anyOf.every(schema => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TUnion, "TUnion");
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    __name(TUnknownRight, "TUnknownRight");
    function TUnknown(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TUnknown, "TUnknown");
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) || TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(VoidRight, "VoidRight");
    function TVoid(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    __name(TVoid, "TVoid");
    function Visit(left, right) {
      if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right)) return TTemplateLiteral(left, right);
      if (TypeGuard.TNot(left) || TypeGuard.TNot(right)) return TNot(left, right);
      if (TypeGuard.TAny(left)) return TAny(left, right);
      if (TypeGuard.TArray(left)) return TArray(left, right);
      if (TypeGuard.TBigInt(left)) return TBigInt(left, right);
      if (TypeGuard.TBoolean(left)) return TBoolean(left, right);
      if (TypeGuard.TAsyncIterator(left)) return TAsyncIterator(left, right);
      if (TypeGuard.TConstructor(left)) return TConstructor(left, right);
      if (TypeGuard.TDate(left)) return TDate(left, right);
      if (TypeGuard.TFunction(left)) return TFunction(left, right);
      if (TypeGuard.TInteger(left)) return TInteger(left, right);
      if (TypeGuard.TIntersect(left)) return TIntersect(left, right);
      if (TypeGuard.TIterator(left)) return TIterator(left, right);
      if (TypeGuard.TLiteral(left)) return TLiteral(left, right);
      if (TypeGuard.TNever(left)) return TNever(left, right);
      if (TypeGuard.TNull(left)) return TNull(left, right);
      if (TypeGuard.TNumber(left)) return TNumber(left, right);
      if (TypeGuard.TObject(left)) return TObject(left, right);
      if (TypeGuard.TRecord(left)) return TRecord(left, right);
      if (TypeGuard.TString(left)) return TString(left, right);
      if (TypeGuard.TSymbol(left)) return TSymbol(left, right);
      if (TypeGuard.TTuple(left)) return TTuple(left, right);
      if (TypeGuard.TPromise(left)) return TPromise(left, right);
      if (TypeGuard.TUint8Array(left)) return TUint8Array(left, right);
      if (TypeGuard.TUndefined(left)) return TUndefined(left, right);
      if (TypeGuard.TUnion(left)) return TUnion(left, right);
      if (TypeGuard.TUnknown(left)) return TUnknown(left, right);
      if (TypeGuard.TVoid(left)) return TVoid(left, right);
      throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
    }
    __name(Visit, "Visit");
    function Extends(left, right) {
      return Visit(left, right);
    }
    __name(Extends, "Extends"), TypeExtends.Extends = Extends;
  })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function (TypeClone) {
    function ObjectType(value) {
      let clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({
          ...acc,
          [key]: Visit(value[key])
        }), {}),
        clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({
          ...acc,
          [key]: Visit(value[key])
        }), {});
      return {
        ...clonedProperties,
        ...clonedSymbols
      };
    }
    __name(ObjectType, "ObjectType");
    function ArrayType(value) {
      return value.map(value => Visit(value));
    }
    __name(ArrayType, "ArrayType");
    function Visit(value) {
      return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
    }
    __name(Visit, "Visit");
    function Clone(schema, options = {}) {
      return {
        ...Visit(schema),
        ...options
      };
    }
    __name(Clone, "Clone"), TypeClone.Clone = Clone;
  })(TypeClone || (exports.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function (IndexedAccessor) {
    function OptionalUnwrap(schema) {
      return schema.map(schema => {
        let {
          [exports.Optional]: _,
          ...clone
        } = TypeClone.Clone(schema);
        return clone;
      });
    }
    __name(OptionalUnwrap, "OptionalUnwrap");
    function IsIntersectOptional(schema) {
      return schema.every(schema => TypeGuard.TOptional(schema));
    }
    __name(IsIntersectOptional, "IsIntersectOptional");
    function IsUnionOptional(schema) {
      return schema.some(schema => TypeGuard.TOptional(schema));
    }
    __name(IsUnionOptional, "IsUnionOptional");
    function ResolveIntersect(schema) {
      return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    __name(ResolveIntersect, "ResolveIntersect");
    function ResolveUnion(schema) {
      return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    __name(ResolveUnion, "ResolveUnion");
    function ResolveOptional(schema) {
      return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
    }
    __name(ResolveOptional, "ResolveOptional");
    function TIntersect(schema, key) {
      let resolved = schema.allOf.reduce((acc, schema) => {
        let indexed = Visit(schema, key);
        return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports.Type.Intersect(resolved));
    }
    __name(TIntersect, "TIntersect");
    function TUnion(schema, key) {
      let resolved = schema.anyOf.map(schema => Visit(schema, key));
      return ResolveOptional(exports.Type.Union(resolved));
    }
    __name(TUnion, "TUnion");
    function TObject(schema, key) {
      let property = schema.properties[key];
      return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    __name(TObject, "TObject");
    function TTuple(schema, key) {
      let items = schema.items;
      if (ValueGuard.IsUndefined(items)) return exports.Type.Never();
      let element = items[key];
      return ValueGuard.IsUndefined(element) ? exports.Type.Never() : element;
    }
    __name(TTuple, "TTuple");
    function Visit(schema, key) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
    }
    __name(Visit, "Visit");
    function Resolve(schema, keys, options = {}) {
      let resolved = keys.map(key => Visit(schema, key.toString()));
      return ResolveOptional(exports.Type.Union(resolved, options));
    }
    __name(Resolve, "Resolve"), IndexedAccessor.Resolve = Resolve;
  })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
  var ObjectMap;
  (function (ObjectMap) {
    function TIntersect(schema, callback) {
      return exports.Type.Intersect(schema.allOf.map(inner => Visit(inner, callback)), {
        ...schema
      });
    }
    __name(TIntersect, "TIntersect");
    function TUnion(schema, callback) {
      return exports.Type.Union(schema.anyOf.map(inner => Visit(inner, callback)), {
        ...schema
      });
    }
    __name(TUnion, "TUnion");
    function TObject(schema, callback) {
      return callback(schema);
    }
    __name(TObject, "TObject");
    function Visit(schema, callback) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
    }
    __name(Visit, "Visit");
    function Map(schema, callback, options) {
      return {
        ...Visit(TypeClone.Clone(schema), callback),
        ...options
      };
    }
    __name(Map, "Map"), ObjectMap.Map = Map;
  })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function (KeyResolver) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    __name(UnwrapPattern, "UnwrapPattern");
    function TIntersect(schema, options) {
      return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);
    }
    __name(TIntersect, "TIntersect");
    function TUnion(schema, options) {
      let sets = schema.anyOf.map(inner => Visit(inner, options));
      return [...sets.reduce((set, outer) => outer.map(key => sets.every(inner => inner.includes(key)) ? set.add(key) : set)[0], new Set())];
    }
    __name(TUnion, "TUnion");
    function TObject(schema, options) {
      return Object.getOwnPropertyNames(schema.properties);
    }
    __name(TObject, "TObject");
    function TRecord(schema, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    __name(TRecord, "TRecord");
    function Visit(schema, options) {
      return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
    }
    __name(Visit, "Visit");
    function ResolveKeys(schema, options) {
      return [...new Set(Visit(schema, options))];
    }
    __name(ResolveKeys, "ResolveKeys"), KeyResolver.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema) {
      return `^(${ResolveKeys(schema, {
        includePatterns: !0
      }).map(key => `(${UnwrapPattern(key)})`).join("|")})$`;
    }
    __name(ResolvePattern, "ResolvePattern"), KeyResolver.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
  var KeyArrayResolver;
  (function (KeyArrayResolver) {
    function Resolve(schema) {
      if (Array.isArray(schema)) return schema;
      if (TypeGuard.TUnionLiteral(schema)) return schema.anyOf.map(schema => schema.const.toString());
      if (TypeGuard.TLiteral(schema)) return [schema.const];
      if (TypeGuard.TTemplateLiteral(schema)) {
        let expression = TemplateLiteralParser.ParseExact(schema.pattern);
        if (!TemplateLiteralFinite.Check(expression)) throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      }
      return [];
    }
    __name(Resolve, "Resolve"), KeyArrayResolver.Resolve = Resolve;
  })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function (UnionResolver) {
    function* TUnion(union) {
      for (let schema of union.anyOf) schema[exports.Kind] === "Union" ? yield* TUnion(schema) : yield schema;
    }
    __name(TUnion, "TUnion");
    function Resolve(union) {
      return exports.Type.Union([...TUnion(union)], {
        ...union
      });
    }
    __name(Resolve, "Resolve"), UnionResolver.Resolve = Resolve;
  })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
  var TemplateLiteralPattern;
  (function (TemplateLiteralPattern) {
    function Escape(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    __name(Escape, "Escape");
    function Visit(schema, acc) {
      if (TypeGuard.TTemplateLiteral(schema)) return schema.pattern.slice(1, schema.pattern.length - 1);
      if (TypeGuard.TUnion(schema)) return `(${schema.anyOf.map(schema => Visit(schema, acc)).join("|")})`;
      if (TypeGuard.TNumber(schema)) return `${acc}${exports.PatternNumber}`;
      if (TypeGuard.TInteger(schema)) return `${acc}${exports.PatternNumber}`;
      if (TypeGuard.TBigInt(schema)) return `${acc}${exports.PatternNumber}`;
      if (TypeGuard.TString(schema)) return `${acc}${exports.PatternString}`;
      if (TypeGuard.TLiteral(schema)) return `${acc}${Escape(schema.const.toString())}`;
      if (TypeGuard.TBoolean(schema)) return `${acc}${exports.PatternBoolean}`;
      throw TypeGuard.TNever(schema) ? Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever") : Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
    }
    __name(Visit, "Visit");
    function Create(kinds) {
      return `^${kinds.map(schema => Visit(schema, "")).join("")}$`;
    }
    __name(Create, "Create"), TemplateLiteralPattern.Create = Create;
  })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function (TemplateLiteralResolver) {
    function Resolve(template) {
      let expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression)) return exports.Type.String();
      let literals = [...TemplateLiteralGenerator.Generate(expression)].map(value => exports.Type.Literal(value));
      return exports.Type.Union(literals);
    }
    __name(Resolve, "Resolve"), TemplateLiteralResolver.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
  var TemplateLiteralParserError = class extends Error {
    static {
      __name(this, "TemplateLiteralParserError");
    }
    constructor(message) {
      super(message);
    }
  };
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function (TemplateLiteralParser) {
    function IsNonEscaped(pattern, index, char) {
      return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    __name(IsNonEscaped, "IsNonEscaped");
    function IsOpenParen(pattern, index) {
      return IsNonEscaped(pattern, index, "(");
    }
    __name(IsOpenParen, "IsOpenParen");
    function IsCloseParen(pattern, index) {
      return IsNonEscaped(pattern, index, ")");
    }
    __name(IsCloseParen, "IsCloseParen");
    function IsSeparator(pattern, index) {
      return IsNonEscaped(pattern, index, "|");
    }
    __name(IsSeparator, "IsSeparator");
    function IsGroup(pattern) {
      if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return !1;
      let count = 0;
      for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), count === 0 && index !== pattern.length - 1) return !1;
      return !0;
    }
    __name(IsGroup, "IsGroup");
    function InGroup(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    __name(InGroup, "InGroup");
    function IsPrecedenceOr(pattern) {
      let count = 0;
      for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), IsSeparator(pattern, index) && count === 0) return !0;
      return !1;
    }
    __name(IsPrecedenceOr, "IsPrecedenceOr");
    function IsPrecedenceAnd(pattern) {
      for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index)) return !0;
      return !1;
    }
    __name(IsPrecedenceAnd, "IsPrecedenceAnd");
    function Or(pattern) {
      let [count, start] = [0, 0],
        expressions = [];
      for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index) && (count += 1), IsCloseParen(pattern, index) && (count -= 1), IsSeparator(pattern, index) && count === 0) {
        let range = pattern.slice(start, index);
        range.length > 0 && expressions.push(Parse(range)), start = index + 1;
      }
      let range = pattern.slice(start);
      return range.length > 0 && expressions.push(Parse(range)), expressions.length === 0 ? {
        type: "const",
        const: ""
      } : expressions.length === 1 ? expressions[0] : {
        type: "or",
        expr: expressions
      };
    }
    __name(Or, "Or");
    function And(pattern) {
      function Group(value, index) {
        if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError("TemplateLiteralParser: Index must point to open parens");
        let count = 0;
        for (let scan = index; scan < value.length; scan++) if (IsOpenParen(value, scan) && (count += 1), IsCloseParen(value, scan) && (count -= 1), count === 0) return [index, scan];
        throw new TemplateLiteralParserError("TemplateLiteralParser: Unclosed group parens in expression");
      }
      __name(Group, "Group");
      function Range(pattern, index) {
        for (let scan = index; scan < pattern.length; scan++) if (IsOpenParen(pattern, scan)) return [index, scan];
        return [index, pattern.length];
      }
      __name(Range, "Range");
      let expressions = [];
      for (let index = 0; index < pattern.length; index++) if (IsOpenParen(pattern, index)) {
        let [start, end] = Group(pattern, index),
          range = pattern.slice(start, end + 1);
        expressions.push(Parse(range)), index = end;
      } else {
        let [start, end] = Range(pattern, index),
          range = pattern.slice(start, end);
        range.length > 0 && expressions.push(Parse(range)), index = end - 1;
      }
      return expressions.length === 0 ? {
        type: "const",
        const: ""
      } : expressions.length === 1 ? expressions[0] : {
        type: "and",
        expr: expressions
      };
    }
    __name(And, "And");
    function Parse(pattern) {
      return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : {
        type: "const",
        const: pattern
      };
    }
    __name(Parse, "Parse"), TemplateLiteralParser.Parse = Parse;
    function ParseExact(pattern) {
      return Parse(pattern.slice(1, pattern.length - 1));
    }
    __name(ParseExact, "ParseExact"), TemplateLiteralParser.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
  var TemplateLiteralFinite;
  (function (TemplateLiteralFinite) {
    function IsNumber(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    __name(IsNumber, "IsNumber");
    function IsBoolean(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    __name(IsBoolean, "IsBoolean");
    function IsString(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    __name(IsString, "IsString");
    function Check(expression) {
      if (IsBoolean(expression)) return !0;
      if (IsNumber(expression) || IsString(expression)) return !1;
      if (expression.type === "and") return expression.expr.every(expr => Check(expr));
      if (expression.type === "or") return expression.expr.every(expr => Check(expr));
      if (expression.type === "const") return !0;
      throw Error("TemplateLiteralFinite: Unknown expression type");
    }
    __name(Check, "Check"), TemplateLiteralFinite.Check = Check;
  })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
  var TemplateLiteralGenerator;
  (function (TemplateLiteralGenerator) {
    function* Reduce(buffer) {
      if (buffer.length === 1) return yield* buffer[0];
      for (let left of buffer[0]) for (let right of Reduce(buffer.slice(1))) yield `${left}${right}`;
    }
    __name(Reduce, "Reduce");
    function* And(expression) {
      return yield* Reduce(expression.expr.map(expr => [...Generate(expr)]));
    }
    __name(And, "And");
    function* Or(expression) {
      for (let expr of expression.expr) yield* Generate(expr);
    }
    __name(Or, "Or");
    function* Const(expression) {
      return yield expression.const;
    }
    __name(Const, "Const");
    function* Generate(expression) {
      if (expression.type === "and") return yield* And(expression);
      if (expression.type === "or") return yield* Or(expression);
      if (expression.type === "const") return yield* Const(expression);
      throw Error("TemplateLiteralGenerator: Unknown expression");
    }
    __name(Generate, "Generate"), TemplateLiteralGenerator.Generate = Generate;
  })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function (TemplateLiteralDslParser) {
    function* ParseUnion(template) {
      let trim = template.trim().replace(/"|'/g, "");
      if (trim === "boolean") return yield exports.Type.Boolean();
      if (trim === "number") return yield exports.Type.Number();
      if (trim === "bigint") return yield exports.Type.BigInt();
      if (trim === "string") return yield exports.Type.String();
      let literals = trim.split("|").map(literal => exports.Type.Literal(literal.trim()));
      return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
    }
    __name(ParseUnion, "ParseUnion");
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        let L = exports.Type.Literal("$"),
          R = ParseLiteral(template.slice(1));
        return yield* [L, ...R];
      }
      for (let i = 2; i < template.length; i++) if (template[i] === "}") {
        let L = ParseUnion(template.slice(2, i)),
          R = ParseLiteral(template.slice(i + 1));
        return yield* [...L, ...R];
      }
      yield exports.Type.Literal(template);
    }
    __name(ParseTerminal, "ParseTerminal");
    function* ParseLiteral(template) {
      for (let i = 0; i < template.length; i++) if (template[i] === "$") {
        let L = exports.Type.Literal(template.slice(0, i)),
          R = ParseTerminal(template.slice(i));
        return yield* [L, ...R];
      }
      yield exports.Type.Literal(template);
    }
    __name(ParseLiteral, "ParseLiteral");
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    __name(Parse, "Parse"), TemplateLiteralDslParser.Parse = Parse;
  })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
  var TypeOrdinal = 0,
    TypeBuilder = class {
      static {
        __name(this, "TypeBuilder");
      }
      Create(schema) {
        return schema;
      }
      Discard(schema, key) {
        let {
          [key]: _,
          ...rest
        } = schema;
        return rest;
      }
      Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
      }
    };
  exports.TypeBuilder = TypeBuilder;
  var StandardTypeBuilder = class extends TypeBuilder {
    static {
      __name(this, "StandardTypeBuilder");
    }
    ReadonlyOptional(schema) {
      return this.Readonly(this.Optional(schema));
    }
    Readonly(schema) {
      return {
        ...TypeClone.Clone(schema),
        [exports.Readonly]: "Readonly"
      };
    }
    Optional(schema) {
      return {
        ...TypeClone.Clone(schema),
        [exports.Optional]: "Optional"
      };
    }
    Any(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Any"
      });
    }
    Array(schema, options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Array",
        type: "array",
        items: TypeClone.Clone(schema)
      });
    }
    Boolean(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Boolean",
        type: "boolean"
      });
    }
    Capitalize(schema, options = {}) {
      let [first, rest] = [schema.const.slice(0, 1), schema.const.slice(1)];
      return exports.Type.Literal(`${first.toUpperCase()}${rest}`, options);
    }
    Composite(objects, options) {
      let intersect = exports.Type.Intersect(objects, {}),
        properties = KeyResolver.ResolveKeys(intersect, {
          includePatterns: !1
        }).reduce((acc, key) => ({
          ...acc,
          [key]: exports.Type.Index(intersect, [key])
        }), {});
      return exports.Type.Object(properties, options);
    }
    Enum(item, options = {}) {
      let anyOf = Object.getOwnPropertyNames(item).filter(key => isNaN(key)).map(key => item[key]).map(value => ValueGuard.IsString(value) ? {
        [exports.Kind]: "Literal",
        type: "string",
        const: value
      } : {
        [exports.Kind]: "Literal",
        type: "number",
        const: value
      });
      return this.Create({
        ...options,
        [exports.Kind]: "Union",
        anyOf: anyOf
      });
    }
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Clone(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Clone(falseType, options);
      }
    }
    Exclude(unionType, excludedMembers, options = {}) {
      if (TypeGuard.TTemplateLiteral(unionType)) return this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options);
      if (TypeGuard.TTemplateLiteral(excludedMembers)) return this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options);
      if (TypeGuard.TUnion(unionType)) {
        let narrowed = unionType.anyOf.filter(inner => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
      } else return TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(unionType, options);
    }
    Extract(type, union, options = {}) {
      if (TypeGuard.TTemplateLiteral(type)) return this.Extract(TemplateLiteralResolver.Resolve(type), union, options);
      if (TypeGuard.TTemplateLiteral(union)) return this.Extract(type, TemplateLiteralResolver.Resolve(union), options);
      if (TypeGuard.TUnion(type)) {
        let narrowed = type.anyOf.filter(inner => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);
      } else return TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Clone(type, options) : this.Never(options);
    }
    Index(schema, unresolved, options = {}) {
      if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) return TypeClone.Clone(schema.items, options);
      if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {
        let cloned = (ValueGuard.IsUndefined(schema.items) ? [] : schema.items).map(schema => TypeClone.Clone(schema));
        return this.Union(cloned, options);
      } else {
        let keys = KeyArrayResolver.Resolve(unresolved),
          clone = TypeClone.Clone(schema);
        return IndexedAccessor.Resolve(clone, keys, options);
      }
    }
    Integer(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Integer",
        type: "integer"
      });
    }
    Intersect(allOf, options = {}) {
      if (allOf.length === 0) return exports.Type.Never();
      if (allOf.length === 1) return TypeClone.Clone(allOf[0], options);
      let objects = allOf.every(schema => TypeGuard.TObject(schema)),
        cloned = allOf.map(schema => TypeClone.Clone(schema)),
        clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? {
          unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties)
        } : {};
      return options.unevaluatedProperties === !1 || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({
        ...options,
        ...clonedUnevaluatedProperties,
        [exports.Kind]: "Intersect",
        type: "object",
        allOf: cloned
      }) : this.Create({
        ...options,
        ...clonedUnevaluatedProperties,
        [exports.Kind]: "Intersect",
        allOf: cloned
      });
    }
    KeyOf(schema, options = {}) {
      if (TypeGuard.TRecord(schema)) {
        let pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        if (pattern === exports.PatternNumberExact) return this.Number(options);
        if (pattern === exports.PatternStringExact) return this.String(options);
        throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
      } else if (TypeGuard.TTuple(schema)) {
        let literals = (ValueGuard.IsUndefined(schema.items) ? [] : schema.items).map((_, index) => exports.Type.Literal(index));
        return this.Union(literals, options);
      } else {
        if (TypeGuard.TArray(schema)) return this.Number(options);
        {
          let keys = KeyResolver.ResolveKeys(schema, {
            includePatterns: !1
          });
          if (keys.length === 0) return this.Never(options);
          let literals = keys.map(key => this.Literal(key));
          return this.Union(literals, options);
        }
      }
    }
    Literal(value, options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Literal",
        const: value,
        type: typeof value
      });
    }
    Lowercase(schema, options = {}) {
      return exports.Type.Literal(schema.const.toLowerCase(), options);
    }
    Never(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Never",
        not: {}
      });
    }
    Not(schema, options) {
      return this.Create({
        ...options,
        [exports.Kind]: "Not",
        not: TypeClone.Clone(schema)
      });
    }
    Null(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Null",
        type: "null"
      });
    }
    Number(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Number",
        type: "number"
      });
    }
    Object(properties, options = {}) {
      let propertyKeys = Object.getOwnPropertyNames(properties),
        optionalKeys = propertyKeys.filter(key => TypeGuard.TOptional(properties[key])),
        requiredKeys = propertyKeys.filter(name => !optionalKeys.includes(name)),
        clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? {
          additionalProperties: TypeClone.Clone(options.additionalProperties)
        } : {},
        clonedProperties = propertyKeys.reduce((acc, key) => ({
          ...acc,
          [key]: TypeClone.Clone(properties[key])
        }), {});
      return requiredKeys.length > 0 ? this.Create({
        ...options,
        ...clonedAdditionalProperties,
        [exports.Kind]: "Object",
        type: "object",
        properties: clonedProperties,
        required: requiredKeys
      }) : this.Create({
        ...options,
        ...clonedAdditionalProperties,
        [exports.Kind]: "Object",
        type: "object",
        properties: clonedProperties
      });
    }
    Omit(schema, unresolved, options = {}) {
      let keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(TypeClone.Clone(schema), object => {
        ValueGuard.IsArray(object.required) && (object.required = object.required.filter(key => !keys.includes(key)), object.required.length === 0 && delete object.required);
        for (let key of Object.getOwnPropertyNames(object.properties)) keys.includes(key) && delete object.properties[key];
        return this.Create(object);
      }, options);
    }
    Partial(schema, options = {}) {
      return ObjectMap.Map(schema, object => {
        let properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => ({
          ...acc,
          [key]: this.Optional(object.properties[key])
        }), {});
        return this.Object(properties, this.Discard(object, "required"));
      }, options);
    }
    Pick(schema, unresolved, options = {}) {
      let keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(TypeClone.Clone(schema), object => {
        ValueGuard.IsArray(object.required) && (object.required = object.required.filter(key => keys.includes(key)), object.required.length === 0 && delete object.required);
        for (let key of Object.getOwnPropertyNames(object.properties)) keys.includes(key) || delete object.properties[key];
        return this.Create(object);
      }, options);
    }
    Record(key, schema, options = {}) {
      if (TypeGuard.TTemplateLiteral(key)) {
        let expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({
          ...acc,
          [key]: TypeClone.Clone(schema)
        }), {}), options) : this.Create({
          ...options,
          [exports.Kind]: "Record",
          type: "object",
          patternProperties: {
            [key.pattern]: TypeClone.Clone(schema)
          }
        });
      } else if (TypeGuard.TUnion(key)) {
        let union = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union)) {
          let properties = union.anyOf.reduce((acc, literal) => ({
            ...acc,
            [literal.const]: TypeClone.Clone(schema)
          }), {});
          return this.Object(properties, {
            ...options,
            [exports.Hint]: "Record"
          });
        } else throw Error("StandardTypeBuilder: Record key of type union contains non-literal types");
      } else if (TypeGuard.TLiteral(key)) {
        if (ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const)) return this.Object({
          [key.const]: TypeClone.Clone(schema)
        }, options);
        throw Error("StandardTypeBuilder: Record key of type literal is not of type string or number");
      } else {
        if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) return this.Create({
          ...options,
          [exports.Kind]: "Record",
          type: "object",
          patternProperties: {
            [exports.PatternNumberExact]: TypeClone.Clone(schema)
          }
        });
        if (TypeGuard.TString(key)) {
          let pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
          return this.Create({
            ...options,
            [exports.Kind]: "Record",
            type: "object",
            patternProperties: {
              [pattern]: TypeClone.Clone(schema)
            }
          });
        } else throw Error("StandardTypeBuilder: Record key is an invalid type");
      }
    }
    Recursive(callback, options = {}) {
      ValueGuard.IsUndefined(options.$id) && (options.$id = `T${TypeOrdinal++}`);
      let thisType = callback({
        [exports.Kind]: "This",
        $ref: `${options.$id}`
      });
      return thisType.$id = options.$id, this.Create({
        ...options,
        [exports.Hint]: "Recursive",
        ...thisType
      });
    }
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved)) return this.Create({
        ...options,
        [exports.Kind]: "Ref",
        $ref: unresolved
      });
      if (ValueGuard.IsUndefined(unresolved.$id)) throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
      return this.Create({
        ...options,
        [exports.Kind]: "Ref",
        $ref: unresolved.$id
      });
    }
    Required(schema, options = {}) {
      return ObjectMap.Map(schema, object => {
        let properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => ({
          ...acc,
          [key]: this.Discard(object.properties[key], exports.Optional)
        }), {});
        return this.Object(properties, object);
      }, options);
    }
    Rest(schema) {
      return TypeGuard.TTuple(schema) ? ValueGuard.IsUndefined(schema.items) ? [] : schema.items.map(schema => TypeClone.Clone(schema)) : [TypeClone.Clone(schema)];
    }
    String(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "String",
        type: "string"
      });
    }
    TemplateLiteral(unresolved, options = {}) {
      let pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({
        ...options,
        [exports.Kind]: "TemplateLiteral",
        type: "string",
        pattern: pattern
      });
    }
    Tuple(items, options = {}) {
      let [additionalItems, minItems, maxItems] = [!1, items.length, items.length],
        clonedItems = items.map(item => TypeClone.Clone(item)),
        schema = items.length > 0 ? {
          ...options,
          [exports.Kind]: "Tuple",
          type: "array",
          items: clonedItems,
          additionalItems: additionalItems,
          minItems: minItems,
          maxItems: maxItems
        } : {
          ...options,
          [exports.Kind]: "Tuple",
          type: "array",
          minItems: minItems,
          maxItems: maxItems
        };
      return this.Create(schema);
    }
    Uncapitalize(schema, options = {}) {
      let [first, rest] = [schema.const.slice(0, 1), schema.const.slice(1)];
      return exports.Type.Literal(`${first.toLocaleLowerCase()}${rest}`, options);
    }
    Union(union, options = {}) {
      if (TypeGuard.TTemplateLiteral(union)) return TemplateLiteralResolver.Resolve(union);
      {
        let anyOf = union;
        if (anyOf.length === 0) return this.Never(options);
        if (anyOf.length === 1) return this.Create(TypeClone.Clone(anyOf[0], options));
        let clonedAnyOf = anyOf.map(schema => TypeClone.Clone(schema));
        return this.Create({
          ...options,
          [exports.Kind]: "Union",
          anyOf: clonedAnyOf
        });
      }
    }
    Unknown(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Unknown"
      });
    }
    Unsafe(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: options[exports.Kind] || "Unsafe"
      });
    }
    Uppercase(schema, options = {}) {
      return exports.Type.Literal(schema.const.toUpperCase(), options);
    }
  };
  exports.StandardTypeBuilder = StandardTypeBuilder;
  var ExtendedTypeBuilder = class extends StandardTypeBuilder {
    static {
      __name(this, "ExtendedTypeBuilder");
    }
    AsyncIterator(items, options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "AsyncIterator",
        type: "AsyncIterator",
        items: TypeClone.Clone(items)
      });
    }
    Awaited(schema, options = {}) {
      let AwaitedRest = __name(rest => {
        if (rest.length === 0) return rest;
        let [L, ...R] = rest;
        return [this.Awaited(L), ...AwaitedRest(R)];
      }, "AwaitedRest");
      return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(AwaitedRest(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(AwaitedRest(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Clone(schema, options);
    }
    BigInt(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "BigInt",
        type: "bigint"
      });
    }
    ConstructorParameters(schema, options = {}) {
      return this.Tuple([...schema.parameters], {
        ...options
      });
    }
    Constructor(parameters, returns, options) {
      let clonedReturns = TypeClone.Clone(returns),
        clonedParameters = parameters.map(parameter => TypeClone.Clone(parameter));
      return this.Create({
        ...options,
        [exports.Kind]: "Constructor",
        type: "constructor",
        parameters: clonedParameters,
        returns: clonedReturns
      });
    }
    Date(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Date",
        type: "Date"
      });
    }
    Function(parameters, returns, options) {
      let clonedReturns = TypeClone.Clone(returns, {}),
        clonedParameters = parameters.map(parameter => TypeClone.Clone(parameter));
      return this.Create({
        ...options,
        [exports.Kind]: "Function",
        type: "function",
        parameters: clonedParameters,
        returns: clonedReturns
      });
    }
    InstanceType(schema, options = {}) {
      return TypeClone.Clone(schema.returns, options);
    }
    Iterator(items, options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Iterator",
        type: "Iterator",
        items: TypeClone.Clone(items)
      });
    }
    Parameters(schema, options = {}) {
      return this.Tuple(schema.parameters, {
        ...options
      });
    }
    Promise(item, options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Promise",
        type: "Promise",
        item: TypeClone.Clone(item)
      });
    }
    RegExp(unresolved, options = {}) {
      let pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({
        ...options,
        [exports.Kind]: "String",
        type: "string",
        pattern: pattern
      });
    }
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    ReturnType(schema, options = {}) {
      return TypeClone.Clone(schema.returns, options);
    }
    Symbol(options) {
      return this.Create({
        ...options,
        [exports.Kind]: "Symbol",
        type: "symbol"
      });
    }
    Undefined(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Undefined",
        type: "undefined"
      });
    }
    Uint8Array(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Uint8Array",
        type: "Uint8Array"
      });
    }
    Void(options = {}) {
      return this.Create({
        ...options,
        [exports.Kind]: "Void",
        type: "void"
      });
    }
  };
  exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
  exports.StandardType = new StandardTypeBuilder();
  exports.Type = new ExtendedTypeBuilder();
});
var require_system = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
  var Types = ou(),
    TypeSystemDuplicateTypeKind = class extends Error {
      static {
        __name(this, "TypeSystemDuplicateTypeKind");
      }
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
  var TypeSystemDuplicateFormat = class extends Error {
    static {
      __name(this, "TypeSystemDuplicateFormat");
    }
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  };
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function (TypeSystem) {
    TypeSystem.ExactOptionalPropertyTypes = !1, TypeSystem.AllowArrayObjects = !1, TypeSystem.AllowNaN = !1, TypeSystem.AllowVoidNull = !1;
    function Type(kind, check) {
      if (Types.TypeRegistry.Has(kind)) throw new TypeSystemDuplicateTypeKind(kind);
      return Types.TypeRegistry.Set(kind, check), (options = {}) => Types.Type.Unsafe({
        ...options,
        [Types.Kind]: kind
      });
    }
    __name(Type, "Type"), TypeSystem.Type = Type;
    function Format(format, check) {
      if (Types.FormatRegistry.Has(format)) throw new TypeSystemDuplicateFormat(format);
      return Types.FormatRegistry.Set(format, check), format;
    }
    __name(Format, "Format"), TypeSystem.Format = Format;
  })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
});
var require_system = __commonJSMin(exports => {
  "use strict";

  var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: function () {
          return m[k];
        }
      }), Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }),
    __exportStar = exports && exports.__exportStar || function (m, exports) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p) && __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  __exportStar(HB(), exports);
});
var require_guard = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = void 0;
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  __name(IsAsyncIterator, "IsAsyncIterator");
  exports.IsAsyncIterator = IsAsyncIterator;
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  __name(IsIterator, "IsIterator");
  exports.IsIterator = IsIterator;
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  __name(IsTypedArray, "IsTypedArray");
  exports.IsTypedArray = IsTypedArray;
  function IsPromise(value) {
    return value instanceof Promise;
  }
  __name(IsPromise, "IsPromise");
  exports.IsPromise = IsPromise;
  function IsUint8Array(value) {
    return value instanceof Uint8Array;
  }
  __name(IsUint8Array, "IsUint8Array");
  exports.IsUint8Array = IsUint8Array;
  function IsDate(value) {
    return value instanceof Date;
  }
  __name(IsDate, "IsDate");
  exports.IsDate = IsDate;
  function HasPropertyKey(value, key) {
    return key in value;
  }
  __name(HasPropertyKey, "HasPropertyKey");
  exports.HasPropertyKey = HasPropertyKey;
  function IsPlainObject(value) {
    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
  }
  __name(IsPlainObject, "IsPlainObject");
  exports.IsPlainObject = IsPlainObject;
  function IsObject(value) {
    return value !== null && typeof value == "object";
  }
  __name(IsObject, "IsObject");
  exports.IsObject = IsObject;
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  __name(IsArray, "IsArray");
  exports.IsArray = IsArray;
  function IsUndefined(value) {
    return value === void 0;
  }
  __name(IsUndefined, "IsUndefined");
  exports.IsUndefined = IsUndefined;
  function IsNull(value) {
    return value === null;
  }
  __name(IsNull, "IsNull");
  exports.IsNull = IsNull;
  function IsBoolean(value) {
    return typeof value == "boolean";
  }
  __name(IsBoolean, "IsBoolean");
  exports.IsBoolean = IsBoolean;
  function IsNumber(value) {
    return typeof value == "number";
  }
  __name(IsNumber, "IsNumber");
  exports.IsNumber = IsNumber;
  function IsInteger(value) {
    return IsNumber(value) && Number.isInteger(value);
  }
  __name(IsInteger, "IsInteger");
  exports.IsInteger = IsInteger;
  function IsBigInt(value) {
    return typeof value == "bigint";
  }
  __name(IsBigInt, "IsBigInt");
  exports.IsBigInt = IsBigInt;
  function IsString(value) {
    return typeof value == "string";
  }
  __name(IsString, "IsString");
  exports.IsString = IsString;
  function IsFunction(value) {
    return typeof value == "function";
  }
  __name(IsFunction, "IsFunction");
  exports.IsFunction = IsFunction;
  function IsSymbol(value) {
    return typeof value == "symbol";
  }
  __name(IsSymbol, "IsSymbol");
  exports.IsSymbol = IsSymbol;
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
  __name(IsValueType, "IsValueType");
  exports.IsValueType = IsValueType;
});
var require_hash = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;
  var ValueGuard = au(),
    ValueHashError = class extends Error {
      static {
        __name(this, "ValueHashError");
      }
      constructor(value) {
        super("Hash: Unable to hash value"), this.value = value;
      }
    };
  exports.ValueHashError = ValueHashError;
  var ByteMarker;
  (function (ByteMarker) {
    ByteMarker[ByteMarker.Undefined = 0] = "Undefined", ByteMarker[ByteMarker.Null = 1] = "Null", ByteMarker[ByteMarker.Boolean = 2] = "Boolean", ByteMarker[ByteMarker.Number = 3] = "Number", ByteMarker[ByteMarker.String = 4] = "String", ByteMarker[ByteMarker.Object = 5] = "Object", ByteMarker[ByteMarker.Array = 6] = "Array", ByteMarker[ByteMarker.Date = 7] = "Date", ByteMarker[ByteMarker.Uint8Array = 8] = "Uint8Array", ByteMarker[ByteMarker.Symbol = 9] = "Symbol", ByteMarker[ByteMarker.BigInt = 10] = "BigInt";
  })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037"),
    [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")],
    Bytes = Array.from({
      length: 256
    }).map((_, i) => BigInt(i)),
    F64 = new Float64Array(1),
    F64In = new DataView(F64.buffer),
    F64Out = new Uint8Array(F64.buffer);
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (let item of value) Visit(item);
  }
  __name(ArrayType, "ArrayType");
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean), FNV1A64(value ? 1 : 0);
  }
  __name(BooleanType, "BooleanType");
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt), F64In.setBigInt64(0, value);
    for (let byte of F64Out) FNV1A64(byte);
  }
  __name(BigIntType, "BigIntType");
  function DateType(value) {
    FNV1A64(ByteMarker.Date), Visit(value.getTime());
  }
  __name(DateType, "DateType");
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  __name(NullType, "NullType");
  function NumberType(value) {
    FNV1A64(ByteMarker.Number), F64In.setFloat64(0, value);
    for (let byte of F64Out) FNV1A64(byte);
  }
  __name(NumberType, "NumberType");
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (let key of globalThis.Object.keys(value).sort()) Visit(key), Visit(value[key]);
  }
  __name(ObjectType, "ObjectType");
  function StringType(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0; i < value.length; i++) FNV1A64(value.charCodeAt(i));
  }
  __name(StringType, "StringType");
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol), Visit(value.description);
  }
  __name(SymbolType, "SymbolType");
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0; i < value.length; i++) FNV1A64(value[i]);
  }
  __name(Uint8ArrayType, "Uint8ArrayType");
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  __name(UndefinedType, "UndefinedType");
  function Visit(value) {
    if (ValueGuard.IsArray(value)) return ArrayType(value);
    if (ValueGuard.IsBoolean(value)) return BooleanType(value);
    if (ValueGuard.IsBigInt(value)) return BigIntType(value);
    if (ValueGuard.IsDate(value)) return DateType(value);
    if (ValueGuard.IsNull(value)) return NullType(value);
    if (ValueGuard.IsNumber(value)) return NumberType(value);
    if (ValueGuard.IsPlainObject(value)) return ObjectType(value);
    if (ValueGuard.IsString(value)) return StringType(value);
    if (ValueGuard.IsSymbol(value)) return SymbolType(value);
    if (ValueGuard.IsUint8Array(value)) return Uint8ArrayType(value);
    if (ValueGuard.IsUndefined(value)) return UndefinedType(value);
    throw new ValueHashError(value);
  }
  __name(Visit, "Visit");
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte], Accumulator = Accumulator * Prime % Size;
  }
  __name(FNV1A64, "FNV1A64");
  function Hash(value) {
    return Accumulator = BigInt("14695981039346656037"), Visit(value), Accumulator;
  }
  __name(Hash, "Hash");
  exports.Hash = Hash;
});
var require_errors = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Errors = exports.ValueErrorsDereferenceError = exports.ValueErrorsUnknownTypeError = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
  var index_1 = q3(),
    Types = ou(),
    ValueHash = j3(),
    ValueGuard = au(),
    ValueErrorType;
  (function (ValueErrorType) {
    ValueErrorType[ValueErrorType.Array = 0] = "Array", ValueErrorType[ValueErrorType.ArrayMinItems = 1] = "ArrayMinItems", ValueErrorType[ValueErrorType.ArrayMaxItems = 2] = "ArrayMaxItems", ValueErrorType[ValueErrorType.ArrayContains = 3] = "ArrayContains", ValueErrorType[ValueErrorType.ArrayMinContains = 4] = "ArrayMinContains", ValueErrorType[ValueErrorType.ArrayMaxContains = 5] = "ArrayMaxContains", ValueErrorType[ValueErrorType.ArrayUniqueItems = 6] = "ArrayUniqueItems", ValueErrorType[ValueErrorType.AsyncIterator = 7] = "AsyncIterator", ValueErrorType[ValueErrorType.BigInt = 8] = "BigInt", ValueErrorType[ValueErrorType.BigIntMultipleOf = 9] = "BigIntMultipleOf", ValueErrorType[ValueErrorType.BigIntExclusiveMinimum = 10] = "BigIntExclusiveMinimum", ValueErrorType[ValueErrorType.BigIntExclusiveMaximum = 11] = "BigIntExclusiveMaximum", ValueErrorType[ValueErrorType.BigIntMinimum = 12] = "BigIntMinimum", ValueErrorType[ValueErrorType.BigIntMaximum = 13] = "BigIntMaximum", ValueErrorType[ValueErrorType.Boolean = 14] = "Boolean", ValueErrorType[ValueErrorType.Date = 15] = "Date", ValueErrorType[ValueErrorType.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", ValueErrorType[ValueErrorType.DateExclusiveMaximumTimestamp = 17] = "DateExclusiveMaximumTimestamp", ValueErrorType[ValueErrorType.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", ValueErrorType[ValueErrorType.DateMaximumTimestamp = 19] = "DateMaximumTimestamp", ValueErrorType[ValueErrorType.Function = 20] = "Function", ValueErrorType[ValueErrorType.Integer = 21] = "Integer", ValueErrorType[ValueErrorType.IntegerMultipleOf = 22] = "IntegerMultipleOf", ValueErrorType[ValueErrorType.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", ValueErrorType[ValueErrorType.IntegerExclusiveMaximum = 24] = "IntegerExclusiveMaximum", ValueErrorType[ValueErrorType.IntegerMinimum = 25] = "IntegerMinimum", ValueErrorType[ValueErrorType.IntegerMaximum = 26] = "IntegerMaximum", ValueErrorType[ValueErrorType.Intersect = 27] = "Intersect", ValueErrorType[ValueErrorType.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", ValueErrorType[ValueErrorType.Iterator = 29] = "Iterator", ValueErrorType[ValueErrorType.Literal = 30] = "Literal", ValueErrorType[ValueErrorType.Never = 31] = "Never", ValueErrorType[ValueErrorType.Not = 32] = "Not", ValueErrorType[ValueErrorType.Null = 33] = "Null", ValueErrorType[ValueErrorType.Number = 34] = "Number", ValueErrorType[ValueErrorType.NumberMultipleOf = 35] = "NumberMultipleOf", ValueErrorType[ValueErrorType.NumberExclusiveMinimum = 36] = "NumberExclusiveMinimum", ValueErrorType[ValueErrorType.NumberExclusiveMaximum = 37] = "NumberExclusiveMaximum", ValueErrorType[ValueErrorType.NumberMinimum = 38] = "NumberMinimum", ValueErrorType[ValueErrorType.NumberMaximum = 39] = "NumberMaximum", ValueErrorType[ValueErrorType.Object = 40] = "Object", ValueErrorType[ValueErrorType.ObjectMinProperties = 41] = "ObjectMinProperties", ValueErrorType[ValueErrorType.ObjectMaxProperties = 42] = "ObjectMaxProperties", ValueErrorType[ValueErrorType.ObjectAdditionalProperties = 43] = "ObjectAdditionalProperties", ValueErrorType[ValueErrorType.ObjectRequiredProperties = 44] = "ObjectRequiredProperties", ValueErrorType[ValueErrorType.Promise = 45] = "Promise", ValueErrorType[ValueErrorType.RecordKeyNumeric = 46] = "RecordKeyNumeric", ValueErrorType[ValueErrorType.RecordKeyString = 47] = "RecordKeyString", ValueErrorType[ValueErrorType.String = 48] = "String", ValueErrorType[ValueErrorType.StringMinLength = 49] = "StringMinLength", ValueErrorType[ValueErrorType.StringMaxLength = 50] = "StringMaxLength", ValueErrorType[ValueErrorType.StringPattern = 51] = "StringPattern", ValueErrorType[ValueErrorType.StringFormatUnknown = 52] = "StringFormatUnknown", ValueErrorType[ValueErrorType.StringFormat = 53] = "StringFormat", ValueErrorType[ValueErrorType.Symbol = 54] = "Symbol", ValueErrorType[ValueErrorType.TupleZeroLength = 55] = "TupleZeroLength", ValueErrorType[ValueErrorType.TupleLength = 56] = "TupleLength", ValueErrorType[ValueErrorType.Undefined = 57] = "Undefined", ValueErrorType[ValueErrorType.Union = 58] = "Union", ValueErrorType[ValueErrorType.Uint8Array = 59] = "Uint8Array", ValueErrorType[ValueErrorType.Uint8ArrayMinByteLength = 60] = "Uint8ArrayMinByteLength", ValueErrorType[ValueErrorType.Uint8ArrayMaxByteLength = 61] = "Uint8ArrayMaxByteLength", ValueErrorType[ValueErrorType.Void = 62] = "Void", ValueErrorType[ValueErrorType.Kind = 63] = "Kind";
  })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));
  var ValueErrorIterator = class {
    static {
      __name(this, "ValueErrorIterator");
    }
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      let next = this.iterator.next();
      return next.done ? void 0 : next.value;
    }
  };
  exports.ValueErrorIterator = ValueErrorIterator;
  var ValueErrorsUnknownTypeError = class extends Error {
    static {
      __name(this, "ValueErrorsUnknownTypeError");
    }
    constructor(schema) {
      super("ValueErrors: Unknown type"), this.schema = schema;
    }
  };
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  var ValueErrorsDereferenceError = class extends Error {
    static {
      __name(this, "ValueErrorsDereferenceError");
    }
    constructor(schema) {
      super(`ValueErrors: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.ValueErrorsDereferenceError = ValueErrorsDereferenceError;
  function IsDefined(value) {
    return value !== void 0;
  }
  __name(IsDefined, "IsDefined");
  function IsExactOptionalProperty(value, key) {
    return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  __name(IsExactOptionalProperty, "IsExactOptionalProperty");
  function IsObject(value) {
    let isObject = ValueGuard.IsObject(value);
    return index_1.TypeSystem.AllowArrayObjects ? isObject : isObject && !ValueGuard.IsArray(value);
  }
  __name(IsObject, "IsObject");
  function IsRecordObject(value) {
    return IsObject(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  __name(IsRecordObject, "IsRecordObject");
  function IsNumber(value) {
    let isNumber = ValueGuard.IsNumber(value);
    return index_1.TypeSystem.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  __name(IsNumber, "IsNumber");
  function IsVoid(value) {
    let isUndefined = ValueGuard.IsUndefined(value);
    return index_1.TypeSystem.AllowVoidNull ? isUndefined || value === null : isUndefined;
  }
  __name(IsVoid, "IsVoid");
  function* TAny(schema, references, path, value) {}
  __name(TAny, "TAny");
  function* TArray(schema, references, path, value) {
    if (!ValueGuard.IsArray(value)) return yield {
      type: ValueErrorType.Array,
      schema: schema,
      path: path,
      value: value,
      message: "Expected array"
    };
    IsDefined(schema.minItems) && !(value.length >= schema.minItems) && (yield {
      type: ValueErrorType.ArrayMinItems,
      schema: schema,
      path: path,
      value: value,
      message: `Expected array length to be greater or equal to ${schema.minItems}`
    }), IsDefined(schema.maxItems) && !(value.length <= schema.maxItems) && (yield {
      type: ValueErrorType.ArrayMinItems,
      schema: schema,
      path: path,
      value: value,
      message: `Expected array length to be less or equal to ${schema.maxItems}`
    });
    for (let i = 0; i < value.length; i++) yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
    if (schema.uniqueItems === !0 && !function () {
      let set = new Set();
      for (let element of value) {
        let hashed = ValueHash.Hash(element);
        if (set.has(hashed)) return !1;
        set.add(hashed);
      }
      return !0;
    }() && (yield {
      type: ValueErrorType.ArrayUniqueItems,
      schema: schema,
      path: path,
      value: value,
      message: "Expected array elements to be unique"
    }), !(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) return;
    let containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never(),
      containsCount = value.reduce((acc, value, index) => Visit(containsSchema, references, `${path}${index}`, value).next().done === !0 ? acc + 1 : acc, 0);
    containsCount === 0 && (yield {
      type: ValueErrorType.ArrayContains,
      schema: schema,
      path: path,
      value: value,
      message: "Expected array to contain at least one matching type"
    }), ValueGuard.IsNumber(schema.minContains) && containsCount < schema.minContains && (yield {
      type: ValueErrorType.ArrayMinContains,
      schema: schema,
      path: path,
      value: value,
      message: `Expected array to contain at least ${schema.minContains} matching types`
    }), ValueGuard.IsNumber(schema.maxContains) && containsCount > schema.maxContains && (yield {
      type: ValueErrorType.ArrayMaxContains,
      schema: schema,
      path: path,
      value: value,
      message: `Expected array to contain no more than ${schema.maxContains} matching types`
    });
  }
  __name(TArray, "TArray");
  function* TAsyncIterator(schema, references, path, value) {
    ValueGuard.IsAsyncIterator(value) || (yield {
      type: ValueErrorType.AsyncIterator,
      schema: schema,
      path: path,
      value: value,
      message: "Expected value to be an async iterator"
    });
  }
  __name(TAsyncIterator, "TAsyncIterator");
  function* TBigInt(schema, references, path, value) {
    if (!ValueGuard.IsBigInt(value)) return yield {
      type: ValueErrorType.BigInt,
      schema: schema,
      path: path,
      value: value,
      message: "Expected bigint"
    };
    IsDefined(schema.multipleOf) && value % schema.multipleOf !== BigInt(0) && (yield {
      type: ValueErrorType.BigIntMultipleOf,
      schema: schema,
      path: path,
      value: value,
      message: `Expected bigint to be a multiple of ${schema.multipleOf}`
    }), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield {
      type: ValueErrorType.BigIntExclusiveMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected bigint to be greater than ${schema.exclusiveMinimum}`
    }), IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield {
      type: ValueErrorType.BigIntExclusiveMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected bigint to be less than ${schema.exclusiveMaximum}`
    }), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield {
      type: ValueErrorType.BigIntMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected bigint to be greater or equal to ${schema.minimum}`
    }), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield {
      type: ValueErrorType.BigIntMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected bigint to be less or equal to ${schema.maximum}`
    });
  }
  __name(TBigInt, "TBigInt");
  function* TBoolean(schema, references, path, value) {
    if (!ValueGuard.IsBoolean(value)) return yield {
      type: ValueErrorType.Boolean,
      schema: schema,
      path: path,
      value: value,
      message: "Expected boolean"
    };
  }
  __name(TBoolean, "TBoolean");
  function* TConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  __name(TConstructor, "TConstructor");
  function* TDate(schema, references, path, value) {
    if (!ValueGuard.IsDate(value)) return yield {
      type: ValueErrorType.Date,
      schema: schema,
      path: path,
      value: value,
      message: "Expected Date object"
    };
    if (!isFinite(value.getTime())) return yield {
      type: ValueErrorType.Date,
      schema: schema,
      path: path,
      value: value,
      message: "Invalid Date"
    };
    IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp) && (yield {
      type: ValueErrorType.DateExclusiveMinimumTimestamp,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Date timestamp to be greater than ${schema.exclusiveMinimum}`
    }), IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp) && (yield {
      type: ValueErrorType.DateExclusiveMaximumTimestamp,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Date timestamp to be less than ${schema.exclusiveMaximum}`
    }), IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp) && (yield {
      type: ValueErrorType.DateMinimumTimestamp,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Date timestamp to be greater or equal to ${schema.minimum}`
    }), IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp) && (yield {
      type: ValueErrorType.DateMaximumTimestamp,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Date timestamp to be less or equal to ${schema.maximum}`
    });
  }
  __name(TDate, "TDate");
  function* TFunction(schema, references, path, value) {
    if (!ValueGuard.IsFunction(value)) return yield {
      type: ValueErrorType.Function,
      schema: schema,
      path: path,
      value: value,
      message: "Expected function"
    };
  }
  __name(TFunction, "TFunction");
  function* TInteger(schema, references, path, value) {
    if (!ValueGuard.IsInteger(value)) return yield {
      type: ValueErrorType.Integer,
      schema: schema,
      path: path,
      value: value,
      message: "Expected integer"
    };
    IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 && (yield {
      type: ValueErrorType.IntegerMultipleOf,
      schema: schema,
      path: path,
      value: value,
      message: `Expected integer to be a multiple of ${schema.multipleOf}`
    }), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield {
      type: ValueErrorType.IntegerExclusiveMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected integer to be greater than ${schema.exclusiveMinimum}`
    }), IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield {
      type: ValueErrorType.IntegerExclusiveMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected integer to be less than ${schema.exclusiveMaximum}`
    }), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield {
      type: ValueErrorType.IntegerMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected integer to be greater or equal to ${schema.minimum}`
    }), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield {
      type: ValueErrorType.IntegerMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected integer to be less or equal to ${schema.maximum}`
    });
  }
  __name(TInteger, "TInteger");
  function* TIntersect(schema, references, path, value) {
    for (let inner of schema.allOf) {
      let next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield next.value, yield {
          type: ValueErrorType.Intersect,
          schema: schema,
          path: path,
          value: value,
          message: "Expected all sub schemas to be valid"
        };
        return;
      }
    }
    if (schema.unevaluatedProperties === !1) {
      let keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (let valueKey of Object.getOwnPropertyNames(value)) keyCheck.test(valueKey) || (yield {
        type: ValueErrorType.IntersectUnevaluatedProperties,
        schema: schema,
        path: `${path}/${valueKey}`,
        value: value,
        message: "Unexpected property"
      });
    }
    if (typeof schema.unevaluatedProperties == "object") {
      let keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (let valueKey of Object.getOwnPropertyNames(value)) if (!keyCheck.test(valueKey)) {
        let next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done) {
          yield next.value, yield {
            type: ValueErrorType.IntersectUnevaluatedProperties,
            schema: schema,
            path: `${path}/${valueKey}`,
            value: value,
            message: "Invalid additional property"
          };
          return;
        }
      }
    }
  }
  __name(TIntersect, "TIntersect");
  function* TIterator(schema, references, path, value) {
    IsObject(value) && Symbol.iterator in value || (yield {
      type: ValueErrorType.Iterator,
      schema: schema,
      path: path,
      value: value,
      message: "Expected value to be an iterator"
    });
  }
  __name(TIterator, "TIterator");
  function* TLiteral(schema, references, path, value) {
    if (value !== schema.const) {
      let error = typeof schema.const == "string" ? `'${schema.const}'` : schema.const;
      return yield {
        type: ValueErrorType.Literal,
        schema: schema,
        path: path,
        value: value,
        message: `Expected ${error}`
      };
    }
  }
  __name(TLiteral, "TLiteral");
  function* TNever(schema, references, path, value) {
    yield {
      type: ValueErrorType.Never,
      schema: schema,
      path: path,
      value: value,
      message: "Value cannot be validated"
    };
  }
  __name(TNever, "TNever");
  function* TNot(schema, references, path, value) {
    Visit(schema.not, references, path, value).next().done === !0 && (yield {
      type: ValueErrorType.Not,
      schema: schema,
      path: path,
      value: value,
      message: "Value should not validate"
    });
  }
  __name(TNot, "TNot");
  function* TNull(schema, references, path, value) {
    if (!ValueGuard.IsNull(value)) return yield {
      type: ValueErrorType.Null,
      schema: schema,
      path: path,
      value: value,
      message: "Expected null"
    };
  }
  __name(TNull, "TNull");
  function* TNumber(schema, references, path, value) {
    if (!IsNumber(value)) return yield {
      type: ValueErrorType.Number,
      schema: schema,
      path: path,
      value: value,
      message: "Expected number"
    };
    IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 && (yield {
      type: ValueErrorType.NumberMultipleOf,
      schema: schema,
      path: path,
      value: value,
      message: `Expected number to be a multiple of ${schema.multipleOf}`
    }), IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) && (yield {
      type: ValueErrorType.NumberExclusiveMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected number to be greater than ${schema.exclusiveMinimum}`
    }), IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) && (yield {
      type: ValueErrorType.NumberExclusiveMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected number to be less than ${schema.exclusiveMaximum}`
    }), IsDefined(schema.minimum) && !(value >= schema.minimum) && (yield {
      type: ValueErrorType.NumberMinimum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected number to be greater or equal to ${schema.minimum}`
    }), IsDefined(schema.maximum) && !(value <= schema.maximum) && (yield {
      type: ValueErrorType.NumberMaximum,
      schema: schema,
      path: path,
      value: value,
      message: `Expected number to be less or equal to ${schema.maximum}`
    });
  }
  __name(TNumber, "TNumber");
  function* TObject(schema, references, path, value) {
    if (!IsObject(value)) return yield {
      type: ValueErrorType.Object,
      schema: schema,
      path: path,
      value: value,
      message: "Expected object"
    };
    IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) && (yield {
      type: ValueErrorType.ObjectMinProperties,
      schema: schema,
      path: path,
      value: value,
      message: `Expected object to have at least ${schema.minProperties} properties`
    }), IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties) && (yield {
      type: ValueErrorType.ObjectMaxProperties,
      schema: schema,
      path: path,
      value: value,
      message: `Expected object to have no more than ${schema.maxProperties} properties`
    });
    let requiredKeys = Array.isArray(schema.required) ? schema.required : [],
      knownKeys = Object.getOwnPropertyNames(schema.properties),
      unknownKeys = Object.getOwnPropertyNames(value);
    for (let knownKey of knownKeys) {
      let property = schema.properties[knownKey];
      schema.required && schema.required.includes(knownKey) ? (yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]), Types.ExtendsUndefined.Check(schema) && !(knownKey in value) && (yield {
        type: ValueErrorType.ObjectRequiredProperties,
        schema: property,
        path: `${path}/${knownKey}`,
        value: void 0,
        message: "Expected required property"
      })) : IsExactOptionalProperty(value, knownKey) && (yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]));
    }
    for (let requiredKey of requiredKeys) unknownKeys.includes(requiredKey) || (yield {
      type: ValueErrorType.ObjectRequiredProperties,
      schema: schema.properties[requiredKey],
      path: `${path}/${requiredKey}`,
      value: void 0,
      message: "Expected required property"
    });
    if (schema.additionalProperties === !1) for (let valueKey of unknownKeys) knownKeys.includes(valueKey) || (yield {
      type: ValueErrorType.ObjectAdditionalProperties,
      schema: schema,
      path: `${path}/${valueKey}`,
      value: value[valueKey],
      message: "Unexpected property"
    });
    if (typeof schema.additionalProperties == "object") for (let valueKey of unknownKeys) knownKeys.includes(valueKey) || (yield* Visit(schema.additionalProperties, references, `${path}/${valueKey}`, value[valueKey]));
  }
  __name(TObject, "TObject");
  function* TPromise(schema, references, path, value) {
    ValueGuard.IsPromise(value) || (yield {
      type: ValueErrorType.Promise,
      schema: schema,
      path: path,
      value: value,
      message: "Expected Promise"
    });
  }
  __name(TPromise, "TPromise");
  function* TRecord(schema, references, path, value) {
    if (!IsRecordObject(value)) return yield {
      type: ValueErrorType.Object,
      schema: schema,
      path: path,
      value: value,
      message: "Expected record object"
    };
    IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) && (yield {
      type: ValueErrorType.ObjectMinProperties,
      schema: schema,
      path: path,
      value: value,
      message: `Expected object to have at least ${schema.minProperties} properties`
    }), IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties) && (yield {
      type: ValueErrorType.ObjectMaxProperties,
      schema: schema,
      path: path,
      value: value,
      message: `Expected object to have no more than ${schema.maxProperties} properties`
    });
    let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
      regex = new RegExp(patternKey);
    for (let [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey)) {
        yield* Visit(patternSchema, references, `${path}/${propertyKey}`, propertyValue);
        continue;
      }
      if (typeof schema.additionalProperties == "object" && (yield* Visit(schema.additionalProperties, references, `${path}/${propertyKey}`, propertyValue)), schema.additionalProperties === !1) {
        let propertyPath = `${path}/${propertyKey}`,
          message = `Unexpected property '${propertyPath}'`;
        return yield {
          type: ValueErrorType.ObjectAdditionalProperties,
          schema: schema,
          path: propertyPath,
          value: propertyValue,
          message: message
        };
      }
    }
  }
  __name(TRecord, "TRecord");
  function* TRef(schema, references, path, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueErrorsDereferenceError(schema);
    let target = references[index];
    yield* Visit(target, references, path, value);
  }
  __name(TRef, "TRef");
  function* TString(schema, references, path, value) {
    if (!ValueGuard.IsString(value)) return yield {
      type: ValueErrorType.String,
      schema: schema,
      path: path,
      value: value,
      message: "Expected string"
    };
    IsDefined(schema.minLength) && !(value.length >= schema.minLength) && (yield {
      type: ValueErrorType.StringMinLength,
      schema: schema,
      path: path,
      value: value,
      message: `Expected string length greater or equal to ${schema.minLength}`
    }), IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) && (yield {
      type: ValueErrorType.StringMaxLength,
      schema: schema,
      path: path,
      value: value,
      message: `Expected string length less or equal to ${schema.maxLength}`
    }), ValueGuard.IsString(schema.pattern) && (new RegExp(schema.pattern).test(value) || (yield {
      type: ValueErrorType.StringPattern,
      schema: schema,
      path: path,
      value: value,
      message: `Expected string to match pattern ${schema.pattern}`
    })), ValueGuard.IsString(schema.format) && (Types.FormatRegistry.Has(schema.format) ? Types.FormatRegistry.Get(schema.format)(value) || (yield {
      type: ValueErrorType.StringFormat,
      schema: schema,
      path: path,
      value: value,
      message: `Expected string to match format '${schema.format}'`
    }) : yield {
      type: ValueErrorType.StringFormatUnknown,
      schema: schema,
      path: path,
      value: value,
      message: `Unknown string format '${schema.format}'`
    });
  }
  __name(TString, "TString");
  function* TSymbol(schema, references, path, value) {
    if (!ValueGuard.IsSymbol(value)) return yield {
      type: ValueErrorType.Symbol,
      schema: schema,
      path: path,
      value: value,
      message: "Expected symbol"
    };
  }
  __name(TSymbol, "TSymbol");
  function* TTemplateLiteral(schema, references, path, value) {
    if (!ValueGuard.IsString(value)) return yield {
      type: ValueErrorType.String,
      schema: schema,
      path: path,
      value: value,
      message: "Expected string"
    };
    new RegExp(schema.pattern).test(value) || (yield {
      type: ValueErrorType.StringPattern,
      schema: schema,
      path: path,
      value: value,
      message: `Expected string to match pattern ${schema.pattern}`
    });
  }
  __name(TTemplateLiteral, "TTemplateLiteral");
  function* TThis(schema, references, path, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueErrorsDereferenceError(schema);
    let target = references[index];
    yield* Visit(target, references, path, value);
  }
  __name(TThis, "TThis");
  function* TTuple(schema, references, path, value) {
    if (!ValueGuard.IsArray(value)) return yield {
      type: ValueErrorType.Array,
      schema: schema,
      path: path,
      value: value,
      message: "Expected Array"
    };
    if (schema.items === void 0 && value.length !== 0) return yield {
      type: ValueErrorType.TupleZeroLength,
      schema: schema,
      path: path,
      value: value,
      message: "Expected tuple to have 0 elements"
    };
    if (value.length !== schema.maxItems && (yield {
      type: ValueErrorType.TupleLength,
      schema: schema,
      path: path,
      value: value,
      message: `Expected tuple to have ${schema.maxItems} elements`
    }), !!schema.items) for (let i = 0; i < schema.items.length; i++) yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
  }
  __name(TTuple, "TTuple");
  function* TUndefined(schema, references, path, value) {
    value !== void 0 && (yield {
      type: ValueErrorType.Undefined,
      schema: schema,
      path: path,
      value: value,
      message: "Expected undefined"
    });
  }
  __name(TUndefined, "TUndefined");
  function* TUnion(schema, references, path, value) {
    let errors = [];
    for (let inner of schema.anyOf) {
      let variantErrors = [...Visit(inner, references, path, value)];
      if (variantErrors.length === 0) return;
      errors.push(...variantErrors);
    }
    errors.length > 0 && (yield {
      type: ValueErrorType.Union,
      schema: schema,
      path: path,
      value: value,
      message: "Expected value of union"
    });
    for (let error of errors) yield error;
  }
  __name(TUnion, "TUnion");
  function* TUint8Array(schema, references, path, value) {
    if (!ValueGuard.IsUint8Array(value)) return yield {
      type: ValueErrorType.Uint8Array,
      schema: schema,
      path: path,
      value: value,
      message: "Expected Uint8Array"
    };
    IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength) && (yield {
      type: ValueErrorType.Uint8ArrayMaxByteLength,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Uint8Array to have a byte length less or equal to ${schema.maxByteLength}`
    }), IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength) && (yield {
      type: ValueErrorType.Uint8ArrayMinByteLength,
      schema: schema,
      path: path,
      value: value,
      message: `Expected Uint8Array to have a byte length greater or equal to ${schema.maxByteLength}`
    });
  }
  __name(TUint8Array, "TUint8Array");
  function* TUnknown(schema, references, path, value) {}
  __name(TUnknown, "TUnknown");
  function* TVoid(schema, references, path, value) {
    if (!IsVoid(value)) return yield {
      type: ValueErrorType.Void,
      schema: schema,
      path: path,
      value: value,
      message: "Expected void"
    };
  }
  __name(TVoid, "TVoid");
  function* TKind(schema, references, path, value) {
    if (!Types.TypeRegistry.Get(schema[Types.Kind])(schema, value)) return yield {
      type: ValueErrorType.Kind,
      schema: schema,
      path: path,
      value: value,
      message: `Expected kind ${schema[Types.Kind]}`
    };
  }
  __name(TKind, "TKind");
  function* Visit(schema, references, path, value) {
    let references_ = IsDefined(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny(schema_, references_, path, value);
      case "Array":
        return yield* TArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* TAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* TBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* TBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* TConstructor(schema_, references_, path, value);
      case "Date":
        return yield* TDate(schema_, references_, path, value);
      case "Function":
        return yield* TFunction(schema_, references_, path, value);
      case "Integer":
        return yield* TInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* TIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* TIterator(schema_, references_, path, value);
      case "Literal":
        return yield* TLiteral(schema_, references_, path, value);
      case "Never":
        return yield* TNever(schema_, references_, path, value);
      case "Not":
        return yield* TNot(schema_, references_, path, value);
      case "Null":
        return yield* TNull(schema_, references_, path, value);
      case "Number":
        return yield* TNumber(schema_, references_, path, value);
      case "Object":
        return yield* TObject(schema_, references_, path, value);
      case "Promise":
        return yield* TPromise(schema_, references_, path, value);
      case "Record":
        return yield* TRecord(schema_, references_, path, value);
      case "Ref":
        return yield* TRef(schema_, references_, path, value);
      case "String":
        return yield* TString(schema_, references_, path, value);
      case "Symbol":
        return yield* TSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* TTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* TThis(schema_, references_, path, value);
      case "Tuple":
        return yield* TTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* TUndefined(schema_, references_, path, value);
      case "Union":
        return yield* TUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* TUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* TUnknown(schema_, references_, path, value);
      case "Void":
        return yield* TVoid(schema_, references_, path, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind(schema_, references_, path, value);
    }
  }
  __name(Visit, "Visit");
  function Errors(...args) {
    let iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
  __name(Errors, "Errors");
  exports.Errors = Errors;
});
var require_errors = __commonJSMin(exports => {
  "use strict";

  var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: function () {
          return m[k];
        }
      }), Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }),
    __exportStar = exports && exports.__exportStar || function (m, exports) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p) && __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  __exportStar(JB(), exports);
});
var require_compiler = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.TypeCompiler = exports.TypeCompilerTypeGuardError = exports.TypeCompilerDereferenceError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
  var index_1 = q3(),
    Types = ou(),
    ValueErrors = $3(),
    ValueHash = j3(),
    ValueGuard = au(),
    TypeCheck = class {
      static {
        __name(this, "TypeCheck");
      }
      constructor(schema, references, checkFunc, code) {
        this.schema = schema, this.references = references, this.checkFunc = checkFunc, this.code = code;
      }
      Code() {
        return this.code;
      }
      Errors(value) {
        return ValueErrors.Errors(this.schema, this.references, value);
      }
      Check(value) {
        return this.checkFunc(value);
      }
    };
  exports.TypeCheck = TypeCheck;
  var Character;
  (function (Character) {
    function DollarSign(code) {
      return code === 36;
    }
    __name(DollarSign, "DollarSign"), Character.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    __name(IsUnderscore, "IsUnderscore"), Character.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    __name(IsAlpha, "IsAlpha"), Character.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    __name(IsNumeric, "IsNumeric"), Character.IsNumeric = IsNumeric;
  })(Character || (Character = {}));
  var MemberExpression;
  (function (MemberExpression) {
    function IsFirstCharacterNumeric(value) {
      return value.length === 0 ? !1 : Character.IsNumeric(value.charCodeAt(0));
    }
    __name(IsFirstCharacterNumeric, "IsFirstCharacterNumeric");
    function IsAccessor(value) {
      if (IsFirstCharacterNumeric(value)) return !1;
      for (let i = 0; i < value.length; i++) {
        let code = value.charCodeAt(i);
        if (!(Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code))) return !1;
      }
      return !0;
    }
    __name(IsAccessor, "IsAccessor");
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    __name(EscapeHyphen, "EscapeHyphen");
    function Encode(object, key) {
      return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    __name(Encode, "Encode"), MemberExpression.Encode = Encode;
  })(MemberExpression || (MemberExpression = {}));
  var Identifier;
  (function (Identifier) {
    function Encode($id) {
      let buffer = [];
      for (let i = 0; i < $id.length; i++) {
        let code = $id.charCodeAt(i);
        Character.IsNumeric(code) || Character.IsAlpha(code) ? buffer.push($id.charAt(i)) : buffer.push(`_${code}_`);
      }
      return buffer.join("").replace(/__/g, "_");
    }
    __name(Encode, "Encode"), Identifier.Encode = Encode;
  })(Identifier || (Identifier = {}));
  var TypeCompilerUnknownTypeError = class extends Error {
    static {
      __name(this, "TypeCompilerUnknownTypeError");
    }
    constructor(schema) {
      super("TypeCompiler: Unknown type"), this.schema = schema;
    }
  };
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
  var TypeCompilerDereferenceError = class extends Error {
    static {
      __name(this, "TypeCompilerDereferenceError");
    }
    constructor(schema) {
      super(`TypeCompiler: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.TypeCompilerDereferenceError = TypeCompilerDereferenceError;
  var TypeCompilerTypeGuardError = class extends Error {
    static {
      __name(this, "TypeCompilerTypeGuardError");
    }
    constructor(schema) {
      super("TypeCompiler: Preflight validation check failed to guard for the given schema"), this.schema = schema;
    }
  };
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
  var TypeCompiler;
  (function (TypeCompiler) {
    function IsAnyOrUnknown(schema) {
      return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
    }
    __name(IsAnyOrUnknown, "IsAnyOrUnknown");
    function IsExactOptionalProperty(value, key, expression) {
      return index_1.TypeSystem.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    __name(IsExactOptionalProperty, "IsExactOptionalProperty");
    function IsObjectCheck(value) {
      return index_1.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null)` : `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))`;
    }
    __name(IsObjectCheck, "IsObjectCheck");
    function IsRecordCheck(value) {
      return index_1.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    __name(IsRecordCheck, "IsRecordCheck");
    function IsNumberCheck(value) {
      return index_1.TypeSystem.AllowNaN ? `typeof ${value} === 'number'` : `(typeof ${value} === 'number' && Number.isFinite(${value}))`;
    }
    __name(IsNumberCheck, "IsNumberCheck");
    function IsVoidCheck(value) {
      return index_1.TypeSystem.AllowVoidNull ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    __name(IsVoidCheck, "IsVoidCheck");
    function* TAny(schema, references, value) {
      yield "true";
    }
    __name(TAny, "TAny");
    function* TArray(schema, references, value) {
      yield `Array.isArray(${value})`;
      let [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      ValueGuard.IsNumber(schema.minItems) && (yield `${value}.length >= ${schema.minItems}`), ValueGuard.IsNumber(schema.maxItems) && (yield `${value}.length <= ${schema.maxItems}`);
      let elementExpression = CreateExpression(schema.items, references, "value");
      if (yield `${value}.every((${parameter}) => ${elementExpression})`, Types.TypeGuard.TSchema(schema.contains) || ValueGuard.IsNumber(schema.minContains) || ValueGuard.IsNumber(schema.maxContains)) {
        let containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never(),
          checkExpression = CreateExpression(containsSchema, references, "value"),
          checkMinContains = ValueGuard.IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [],
          checkMaxContains = ValueGuard.IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [],
          checkCount = `const count = ${value}.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`,
          check = ["(count > 0)", ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
      }
      schema.uniqueItems === !0 && (yield `((${parameter}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${value})`);
    }
    __name(TArray, "TArray");
    function* TAsyncIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    __name(TAsyncIterator, "TAsyncIterator");
    function* TBigInt(schema, references, value) {
      yield `(typeof ${value} === 'bigint')`, ValueGuard.IsBigInt(schema.multipleOf) && (yield `(${value} % BigInt(${schema.multipleOf})) === 0`), ValueGuard.IsBigInt(schema.exclusiveMinimum) && (yield `${value} > BigInt(${schema.exclusiveMinimum})`), ValueGuard.IsBigInt(schema.exclusiveMaximum) && (yield `${value} < BigInt(${schema.exclusiveMaximum})`), ValueGuard.IsBigInt(schema.minimum) && (yield `${value} >= BigInt(${schema.minimum})`), ValueGuard.IsBigInt(schema.maximum) && (yield `${value} <= BigInt(${schema.maximum})`);
    }
    __name(TBigInt, "TBigInt");
    function* TBoolean(schema, references, value) {
      yield `(typeof ${value} === 'boolean')`;
    }
    __name(TBoolean, "TBoolean");
    function* TConstructor(schema, references, value) {
      yield* Visit(schema.returns, references, `${value}.prototype`);
    }
    __name(TConstructor, "TConstructor");
    function* TDate(schema, references, value) {
      yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`, ValueGuard.IsNumber(schema.exclusiveMinimumTimestamp) && (yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`), ValueGuard.IsNumber(schema.exclusiveMaximumTimestamp) && (yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`), ValueGuard.IsNumber(schema.minimumTimestamp) && (yield `${value}.getTime() >= ${schema.minimumTimestamp}`), ValueGuard.IsNumber(schema.maximumTimestamp) && (yield `${value}.getTime() <= ${schema.maximumTimestamp}`);
    }
    __name(TDate, "TDate");
    function* TFunction(schema, references, value) {
      yield `(typeof ${value} === 'function')`;
    }
    __name(TFunction, "TFunction");
    function* TInteger(schema, references, value) {
      yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`, ValueGuard.IsNumber(schema.multipleOf) && (yield `(${value} % ${schema.multipleOf}) === 0`), ValueGuard.IsNumber(schema.exclusiveMinimum) && (yield `${value} > ${schema.exclusiveMinimum}`), ValueGuard.IsNumber(schema.exclusiveMaximum) && (yield `${value} < ${schema.exclusiveMaximum}`), ValueGuard.IsNumber(schema.minimum) && (yield `${value} >= ${schema.minimum}`), ValueGuard.IsNumber(schema.maximum) && (yield `${value} <= ${schema.maximum}`);
    }
    __name(TInteger, "TInteger");
    function* TIntersect(schema, references, value) {
      let check1 = schema.allOf.map(schema => CreateExpression(schema, references, value)).join(" && ");
      if (schema.unevaluatedProperties === !1) {
        let keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`),
          check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check2})`;
      } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
        let keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`),
          check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
        yield `(${check1} && ${check2})`;
      } else yield `(${check1})`;
    }
    __name(TIntersect, "TIntersect");
    function* TIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    __name(TIterator, "TIterator");
    function* TLiteral(schema, references, value) {
      typeof schema.const == "number" || typeof schema.const == "boolean" ? yield `(${value} === ${schema.const})` : yield `(${value} === '${schema.const}')`;
    }
    __name(TLiteral, "TLiteral");
    function* TNever(schema, references, value) {
      yield "false";
    }
    __name(TNever, "TNever");
    function* TNot(schema, references, value) {
      yield `(!${CreateExpression(schema.not, references, value)})`;
    }
    __name(TNot, "TNot");
    function* TNull(schema, references, value) {
      yield `(${value} === null)`;
    }
    __name(TNull, "TNull");
    function* TNumber(schema, references, value) {
      yield IsNumberCheck(value), ValueGuard.IsNumber(schema.multipleOf) && (yield `(${value} % ${schema.multipleOf}) === 0`), ValueGuard.IsNumber(schema.exclusiveMinimum) && (yield `${value} > ${schema.exclusiveMinimum}`), ValueGuard.IsNumber(schema.exclusiveMaximum) && (yield `${value} < ${schema.exclusiveMaximum}`), ValueGuard.IsNumber(schema.minimum) && (yield `${value} >= ${schema.minimum}`), ValueGuard.IsNumber(schema.maximum) && (yield `${value} <= ${schema.maximum}`);
    }
    __name(TNumber, "TNumber");
    function* TObject(schema, references, value) {
      yield IsObjectCheck(value), ValueGuard.IsNumber(schema.minProperties) && (yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`), ValueGuard.IsNumber(schema.maxProperties) && (yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`);
      let knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (let knownKey of knownKeys) {
        let memberExpression = MemberExpression.Encode(value, knownKey),
          property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) yield* Visit(property, references, memberExpression), (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && (yield `('${knownKey}' in ${value})`);else {
          let expression = CreateExpression(property, references, memberExpression);
          yield IsExactOptionalProperty(value, knownKey, expression);
        }
      }
      if (schema.additionalProperties === !1) if (schema.required && schema.required.length === knownKeys.length) yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;else {
        let keys = `[${knownKeys.map(key => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
      if (typeof schema.additionalProperties == "object") {
        let expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`),
          keys = `[${knownKeys.map(key => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    __name(TObject, "TObject");
    function* TPromise(schema, references, value) {
      yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
    }
    __name(TPromise, "TPromise");
    function* TRecord(schema, references, value) {
      yield IsRecordCheck(value), ValueGuard.IsNumber(schema.minProperties) && (yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`), ValueGuard.IsNumber(schema.maxProperties) && (yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`);
      let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
        variable = CreateVariable(`new RegExp(/${patternKey}/)`),
        check1 = CreateExpression(patternSchema, references, "value"),
        check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === !1 ? "false" : "true",
        expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
      yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    __name(TRecord, "TRecord");
    function* TRef(schema, references, value) {
      let index = references.findIndex(foreign => foreign.$id === schema.$ref);
      if (index === -1) throw new TypeCompilerDereferenceError(schema);
      let target = references[index];
      if (state.functions.has(schema.$ref)) return yield `${CreateFunctionName(schema.$ref)}(${value})`;
      yield* Visit(target, references, value);
    }
    __name(TRef, "TRef");
    function* TString(schema, references, value) {
      yield `(typeof ${value} === 'string')`, ValueGuard.IsNumber(schema.minLength) && (yield `${value}.length >= ${schema.minLength}`), ValueGuard.IsNumber(schema.maxLength) && (yield `${value}.length <= ${schema.maxLength}`), schema.pattern !== void 0 && (yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`), schema.format !== void 0 && (yield `format('${schema.format}', ${value})`);
    }
    __name(TString, "TString");
    function* TSymbol(schema, references, value) {
      yield `(typeof ${value} === 'symbol')`;
    }
    __name(TSymbol, "TSymbol");
    function* TTemplateLiteral(schema, references, value) {
      yield `(typeof ${value} === 'string')`, yield `${CreateVariable(`${new RegExp(schema.pattern)};`)}.test(${value})`;
    }
    __name(TTemplateLiteral, "TTemplateLiteral");
    function* TThis(schema, references, value) {
      yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    __name(TThis, "TThis");
    function* TTuple(schema, references, value) {
      if (yield `Array.isArray(${value})`, schema.items === void 0) return yield `${value}.length === 0`;
      yield `(${value}.length === ${schema.maxItems})`;
      for (let i = 0; i < schema.items.length; i++) yield `${CreateExpression(schema.items[i], references, `${value}[${i}]`)}`;
    }
    __name(TTuple, "TTuple");
    function* TUndefined(schema, references, value) {
      yield `${value} === undefined`;
    }
    __name(TUndefined, "TUndefined");
    function* TUnion(schema, references, value) {
      yield `(${schema.anyOf.map(schema => CreateExpression(schema, references, value)).join(" || ")})`;
    }
    __name(TUnion, "TUnion");
    function* TUint8Array(schema, references, value) {
      yield `${value} instanceof Uint8Array`, ValueGuard.IsNumber(schema.maxByteLength) && (yield `(${value}.length <= ${schema.maxByteLength})`), ValueGuard.IsNumber(schema.minByteLength) && (yield `(${value}.length >= ${schema.minByteLength})`);
    }
    __name(TUint8Array, "TUint8Array");
    function* TUnknown(schema, references, value) {
      yield "true";
    }
    __name(TUnknown, "TUnknown");
    function* TVoid(schema, references, value) {
      yield IsVoidCheck(value);
    }
    __name(TVoid, "TVoid");
    function* TKind(schema, references, value) {
      yield `kind('${schema[Types.Kind]}', ${value})`;
    }
    __name(TKind, "TKind");
    function* Visit(schema, references, value, useHoisting = !0) {
      let references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references,
        schema_ = schema;
      if (useHoisting && ValueGuard.IsString(schema.$id)) {
        let functionName = CreateFunctionName(schema.$id);
        if (state.functions.has(functionName)) return yield `${functionName}(${value})`;
        {
          let functionCode = CreateFunction(functionName, schema, references, "value", !1);
          return state.functions.set(functionName, functionCode), yield `${functionName}(${value})`;
        }
      }
      switch (schema_[Types.Kind]) {
        case "Any":
          return yield* TAny(schema_, references_, value);
        case "Array":
          return yield* TArray(schema_, references_, value);
        case "AsyncIterator":
          return yield* TAsyncIterator(schema_, references_, value);
        case "BigInt":
          return yield* TBigInt(schema_, references_, value);
        case "Boolean":
          return yield* TBoolean(schema_, references_, value);
        case "Constructor":
          return yield* TConstructor(schema_, references_, value);
        case "Date":
          return yield* TDate(schema_, references_, value);
        case "Function":
          return yield* TFunction(schema_, references_, value);
        case "Integer":
          return yield* TInteger(schema_, references_, value);
        case "Intersect":
          return yield* TIntersect(schema_, references_, value);
        case "Iterator":
          return yield* TIterator(schema_, references_, value);
        case "Literal":
          return yield* TLiteral(schema_, references_, value);
        case "Never":
          return yield* TNever(schema_, references_, value);
        case "Not":
          return yield* TNot(schema_, references_, value);
        case "Null":
          return yield* TNull(schema_, references_, value);
        case "Number":
          return yield* TNumber(schema_, references_, value);
        case "Object":
          return yield* TObject(schema_, references_, value);
        case "Promise":
          return yield* TPromise(schema_, references_, value);
        case "Record":
          return yield* TRecord(schema_, references_, value);
        case "Ref":
          return yield* TRef(schema_, references_, value);
        case "String":
          return yield* TString(schema_, references_, value);
        case "Symbol":
          return yield* TSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return yield* TTemplateLiteral(schema_, references_, value);
        case "This":
          return yield* TThis(schema_, references_, value);
        case "Tuple":
          return yield* TTuple(schema_, references_, value);
        case "Undefined":
          return yield* TUndefined(schema_, references_, value);
        case "Union":
          return yield* TUnion(schema_, references_, value);
        case "Uint8Array":
          return yield* TUint8Array(schema_, references_, value);
        case "Unknown":
          return yield* TUnknown(schema_, references_, value);
        case "Void":
          return yield* TVoid(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new TypeCompilerUnknownTypeError(schema);
          return yield* TKind(schema_, references_, value);
      }
    }
    __name(Visit, "Visit");
    let state = {
      language: "javascript",
      functions: new Map(),
      variables: new Map()
    };
    function CreateExpression(schema, references, value, useHoisting = !0) {
      return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
    }
    __name(CreateExpression, "CreateExpression");
    function CreateFunctionName($id) {
      return `check_${Identifier.Encode($id)}`;
    }
    __name(CreateFunctionName, "CreateFunctionName");
    function CreateVariable(expression) {
      let variableName = `local_${state.variables.size}`;
      return state.variables.set(variableName, `const ${variableName} = ${expression}`), variableName;
    }
    __name(CreateVariable, "CreateVariable");
    function CreateFunction(name, schema, references, value, useHoisting = !0) {
      let [newline, pad] = [`
`, length => "".padStart(length, " ")],
        parameter = CreateParameter("value", "any"),
        returns = CreateReturns("boolean"),
        expression = [...Visit(schema, references, value, useHoisting)].map(expression => `${pad(4)}${expression}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
    }
    __name(CreateFunction, "CreateFunction");
    function CreateParameter(name, type) {
      let annotation = state.language === "typescript" ? `: ${type}` : "";
      return `${name}${annotation}`;
    }
    __name(CreateParameter, "CreateParameter");
    function CreateReturns(type) {
      return state.language === "typescript" ? `: ${type}` : "";
    }
    __name(CreateReturns, "CreateReturns");
    function Build(schema, references, options) {
      let functionCode = CreateFunction("check", schema, references, "value"),
        parameter = CreateParameter("value", "any"),
        returns = CreateReturns("boolean"),
        functions = [...state.functions.values()],
        variables = [...state.variables.values()],
        checkFunction = ValueGuard.IsString(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join(`
`);
    }
    __name(Build, "Build");
    function Code(...args) {
      let defaults = {
          language: "javascript"
        },
        [schema, references, options] = args.length === 2 && ValueGuard.IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !ValueGuard.IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
      if (state.language = options.language, state.variables.clear(), state.functions.clear(), !Types.TypeGuard.TSchema(schema)) throw new TypeCompilerTypeGuardError(schema);
      for (let schema of references) if (!Types.TypeGuard.TSchema(schema)) throw new TypeCompilerTypeGuardError(schema);
      return Build(schema, references, options);
    }
    __name(Code, "Code"), TypeCompiler.Code = Code;
    function Compile(schema, references = []) {
      let generatedCode = Code(schema, references, {
          language: "javascript"
        }),
        compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      function typeRegistryFunction(kind, value) {
        return Types.TypeRegistry.Has(kind) ? Types.TypeRegistry.Get(kind)(schema, value) : !1;
      }
      __name(typeRegistryFunction, "typeRegistryFunction");
      function formatRegistryFunction(format, value) {
        return Types.FormatRegistry.Has(format) ? Types.FormatRegistry.Get(format)(value) : !1;
      }
      __name(formatRegistryFunction, "formatRegistryFunction");
      function valueHashFunction(value) {
        return ValueHash.Hash(value);
      }
      __name(valueHashFunction, "valueHashFunction");
      let checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, valueHashFunction);
      return new TypeCheck(schema, references, checkFunction, generatedCode);
    }
    __name(Compile, "Compile"), TypeCompiler.Compile = Compile;
  })(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));
});
var require_compiler = __commonJSMin(exports => {
  "use strict";

  var __createBinding = exports && exports.__createBinding || (Object.create ? function (o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = {
        enumerable: !0,
        get: function () {
          return m[k];
        }
      }), Object.defineProperty(o, k2, desc);
    } : function (o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }),
    __exportStar = exports && exports.__exportStar || function (m, exports) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p) && __createBinding(exports, m, p);
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.ValueErrorType = void 0;
  var index_1 = $3();
  Object.defineProperty(exports, "ValueErrorType", {
    enumerable: !0,
    get: function () {
      return index_1.ValueErrorType;
    }
  });
  __exportStar(tF(), exports);
});
var require_ms = __commonJSMin((exports, module) => {
  var s = 1e3,
    m = s * 60,
    h = m * 60,
    d = h * 24,
    w = d * 7,
    y = d * 365.25;
  module.exports = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) return parse(val);
    if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    if (str = String(str), !(str.length > 100)) {
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (match) {
        var n = parseFloat(match[1]),
          type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return;
        }
      }
    }
  }
  __name(parse, "parse");
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
});
var require_common = __commonJSMin((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = aF(), createDebug.destroy = destroy, Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor"), createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime,
        enableOverride = null,
        namespacesCache,
        enabledCache;
      function debug(...args) {
        if (!debug.enabled) return;
        let self = debug,
          curr = Number(new Date()),
          ms = curr - (prevTime || curr);
        self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") return "%";
          index++;
          let formatter = createDebug.formatters[format];
          if (typeof formatter == "function") {
            let val = args[index];
            match = formatter.call(self, val), args.splice(index, 1), index--;
          }
          return match;
        }), createDebug.formatArgs.call(self, args), (self.log || createDebug.log).apply(self, args);
      }
      return __name(debug, "debug"), debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),
        set: v => {
          enableOverride = v;
        }
      }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      let newDebug = createDebug(this.namespace + (typeof delimiter > "u" ? ":" : delimiter) + namespace);
      return newDebug.log = this.log, newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
      let i,
        split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/),
        len = split.length;
      for (i = 0; i < len; i++) split[i] && (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
    }
    __name(enable, "enable");
    function disable() {
      let namespaces = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => "-" + namespace)].join(",");
      return createDebug.enable(""), namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") return !0;
      let i, len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
      for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
      return !1;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce(val) {
      return val instanceof Error ? val.stack || val.message : val;
    }
    __name(coerce, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return __name(destroy, "destroy"), createDebug.enable(createDebug.load()), createDebug;
  }
  __name(setup, "setup");
  module.exports = setup;
});
var require_browser = __commonJSMin((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = !1;
    return () => {
      warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function useColors() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  __name(useColors, "useColors");
  function formatArgs(args) {
    if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), !this.useColors) return;
    let c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0,
      lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      match !== "%%" && (index++, match === "%c" && (lastC = index));
    }), args.splice(lastC, 0, c);
  }
  __name(formatArgs, "formatArgs");
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
    } catch {}
  }
  __name(save, "save");
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch {}
    return !r && typeof process < "u" && "env" in process && (r = process.env.DEBUG), r;
  }
  __name(load, "load");
  function localstorage() {
    try {
      return localStorage;
    } catch {}
  }
  __name(localstorage, "localstorage");
  module.exports = $T()(exports);
  var {
    formatters: formatters
  } = module.exports;
  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});
var require_has_flag = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = (flag, argv = process.argv) => {
    let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--",
      position = argv.indexOf(prefix + flag),
      terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});
var require_supports_color = __commonJSMin((exports, module) => {
  "use strict";

  var os = require("os"),
    tty = require("tty"),
    hasFlag = fF(),
    {
      env: env
    } = process,
    forceColor;
  hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? forceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = 1);
  "FORCE_COLOR" in env && (env.FORCE_COLOR === "true" ? forceColor = 1 : env.FORCE_COLOR === "false" ? forceColor = 0 : forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3));
  function translateLevel(level) {
    return level === 0 ? !1 : {
      level: level,
      hasBasic: !0,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  __name(translateLevel, "translateLevel");
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) return 0;
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
    if (hasFlag("color=256")) return 2;
    if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
    let min = forceColor || 0;
    if (env.TERM === "dumb") return min;
    if (process.platform === "win32") {
      let osRelease = os.release().split(".");
      return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in env) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some(sign => sign in env) || env.CI_NAME === "codeship" ? 1 : min;
    if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    if (env.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in env) {
      let version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
  }
  __name(supportsColor, "supportsColor");
  function getSupportLevel(stream) {
    let level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  __name(getSupportLevel, "getSupportLevel");
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(!0, tty.isatty(1))),
    stderr: translateLevel(supportsColor(!0, tty.isatty(2)))
  };
});
var require_node = __commonJSMin((exports, module) => {
  var tty = require("tty"),
    util = require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    let supportsColor = mF();
    supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
  } catch {}
  exports.inspectOpts = Object.keys(process.env).filter(key => /^debug_/i.test(key)).reduce((obj, key) => {
    let prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase()),
      val = process.env[key];
    return /^(yes|on|true|enabled)$/i.test(val) ? val = !0 : /^(no|off|false|disabled)$/i.test(val) ? val = !1 : val === "null" ? val = null : val = Number(val), obj[prop] = val, obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? !!exports.inspectOpts.colors : tty.isatty(process.stderr.fd);
  }
  __name(useColors, "useColors");
  function formatArgs(args) {
    let {
      namespace: name,
      useColors: useColors
    } = this;
    if (useColors) {
      let c = this.color,
        colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c),
        prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else args[0] = getDate() + name + " " + args[0];
  }
  __name(formatArgs, "formatArgs");
  function getDate() {
    return exports.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
  }
  __name(getDate, "getDate");
  function log(...args) {
    return process.stderr.write(util.format(...args) + `
`);
  }
  __name(log, "log");
  function save(namespaces) {
    namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
  }
  __name(save, "save");
  function load() {
    return process.env.DEBUG;
  }
  __name(load, "load");
  function init(debug) {
    debug.inspectOpts = {};
    let keys = Object.keys(exports.inspectOpts);
    for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
  __name(init, "init");
  module.exports = $T()(exports);
  var {
    formatters: formatters
  } = module.exports;
  formatters.o = function (v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split(`
`).map(str => str.trim()).join(" ");
  };
  formatters.O = function (v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
  };
});
var require_src = __commonJSMin((exports, module) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? module.exports = cF() : module.exports = gF();
});
var require_lru_cache = __commonJSMin((exports, module) => {
  var perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date,
    hasAbortController = typeof AbortController == "function",
    AC = hasAbortController ? AbortController : class {
      static {
        __name(this, "AbortController");
      }
      constructor() {
        this.signal = new AS();
      }
      abort() {
        this.signal.dispatchEvent("abort");
      }
    },
    hasAbortSignal = typeof AbortSignal == "function",
    hasACAbortSignal = typeof AC.AbortSignal == "function",
    AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this.aborted = !1, this._listeners = [];
      }
      dispatchEvent(type) {
        if (type === "abort") {
          this.aborted = !0;
          let e = {
            type: type,
            target: this
          };
          this.onabort(e), this._listeners.forEach(f => f(e), this);
        }
      }
      onabort() {}
      addEventListener(ev, fn) {
        ev === "abort" && this._listeners.push(fn);
      }
      removeEventListener(ev, fn) {
        ev === "abort" && (this._listeners = this._listeners.filter(f => f !== fn));
      }
    },
    warned = new Set(),
    deprecatedOption = __name((opt, instead) => {
      let code = `LRU_CACHE_OPTION_${opt}`;
      shouldWarn(code) && warn(code, `${opt} option`, `options.${instead}`, LRUCache);
    }, "deprecatedOption"),
    deprecatedMethod = __name((method, instead) => {
      let code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        let {
            prototype: prototype
          } = LRUCache,
          {
            get: get
          } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get);
      }
    }, "deprecatedMethod"),
    deprecatedProperty = __name((field, instead) => {
      let code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        let {
            prototype: prototype
          } = LRUCache,
          {
            get: get
          } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get);
      }
    }, "deprecatedProperty"),
    emitWarning = __name((...a) => {
      typeof process == "object" && process && typeof process.emitWarning == "function" ? process.emitWarning(...a) : console.error(...a);
    }, "emitWarning"),
    shouldWarn = __name(code => !warned.has(code), "shouldWarn"),
    warn = __name((code, what, instead, fn) => {
      warned.add(code);
      let msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    }, "warn"),
    isPosInt = __name(n => n && n === Math.floor(n) && n > 0 && isFinite(n), "isPosInt"),
    getUintArray = __name(max => isPosInt(max) ? max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null, "getUintArray"),
    ZeroArray = class extends Array {
      static {
        __name(this, "ZeroArray");
      }
      constructor(size) {
        super(size), this.fill(0);
      }
    },
    Stack = class {
      static {
        __name(this, "Stack");
      }
      constructor(max) {
        if (max === 0) return [];
        let UintArray = getUintArray(max);
        this.heap = new UintArray(max), this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    },
    LRUCache = class _LRUCache {
      static {
        __name(this, "LRUCache");
      }
      constructor(options = {}) {
        let {
            max = 0,
            ttl: ttl,
            ttlResolution = 1,
            ttlAutopurge: ttlAutopurge,
            updateAgeOnGet: updateAgeOnGet,
            updateAgeOnHas: updateAgeOnHas,
            allowStale: allowStale,
            dispose: dispose,
            disposeAfter: disposeAfter,
            noDisposeOnSet: noDisposeOnSet,
            noUpdateTTL: noUpdateTTL,
            maxSize = 0,
            sizeCalculation: sizeCalculation,
            fetchMethod: fetchMethod,
            fetchContext: fetchContext,
            noDeleteOnFetchRejection: noDeleteOnFetchRejection,
            noDeleteOnStaleGet: noDeleteOnStaleGet
          } = options,
          {
            length: length,
            maxAge: maxAge,
            stale: stale
          } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) throw new TypeError("max option must be a nonnegative integer");
        let UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) throw new Error("invalid max value: " + max);
        if (this.max = max, this.maxSize = maxSize, this.sizeCalculation = sizeCalculation || length, this.sizeCalculation) {
          if (!this.maxSize) throw new TypeError("cannot set sizeCalculation without setting maxSize");
          if (typeof this.sizeCalculation != "function") throw new TypeError("sizeCalculation set to non-function");
        }
        if (this.fetchMethod = fetchMethod || null, this.fetchMethod && typeof this.fetchMethod != "function") throw new TypeError("fetchMethod must be a function if specified");
        if (this.fetchContext = fetchContext, !this.fetchMethod && fetchContext !== void 0) throw new TypeError("cannot set fetchContext without fetchMethod");
        if (this.keyMap = new Map(), this.keyList = new Array(max).fill(null), this.valList = new Array(max).fill(null), this.next = new UintArray(max), this.prev = new UintArray(max), this.head = 0, this.tail = 0, this.free = new Stack(max), this.initialFill = 1, this.size = 0, typeof dispose == "function" && (this.dispose = dispose), typeof disposeAfter == "function" ? (this.disposeAfter = disposeAfter, this.disposed = []) : (this.disposeAfter = null, this.disposed = null), this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.maxSize !== 0) {
          if (!isPosInt(this.maxSize)) throw new TypeError("maxSize must be a positive integer if specified");
          this.initializeSizeTracking();
        }
        if (this.allowStale = !!allowStale || !!stale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || maxAge || 0, this.ttl) {
          if (!isPosInt(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) throw new TypeError("At least one of max, maxSize, or ttl is required");
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          let code = "LRU_CACHE_UNBOUNDED";
          shouldWarn(code) && (warned.add(code), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", code, _LRUCache));
        }
        stale && deprecatedOption("stale", "allowStale"), maxAge && deprecatedOption("maxAge", "ttl"), length && deprecatedOption("length", "sizeCalculation");
      }
      getRemainingTTL(key) {
        return this.has(key, {
          updateAgeOnHas: !1
        }) ? 1 / 0 : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max), this.starts = new ZeroArray(this.max), this.setItemTTL = (index, ttl, start = perf.now()) => {
          if (this.starts[index] = ttl !== 0 ? start : 0, this.ttls[index] = ttl, ttl !== 0 && this.ttlAutopurge) {
            let t = setTimeout(() => {
              this.isStale(index) && this.delete(this.keyList[index]);
            }, ttl + 1);
            t.unref && t.unref();
          }
        }, this.updateItemAge = index => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        let cachedNow = 0,
          getNow = __name(() => {
            let n = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n;
              let t = setTimeout(() => cachedNow = 0, this.ttlResolution);
              t.unref && t.unref();
            }
            return n;
          }, "getNow");
        this.getRemainingTTL = key => {
          let index = this.keyMap.get(key);
          return index === void 0 ? 0 : this.ttls[index] === 0 || this.starts[index] === 0 ? 1 / 0 : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        }, this.isStale = index => this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
      }
      updateItemAge(index) {}
      setItemTTL(index, ttl, start) {}
      isStale(index) {
        return !1;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0, this.sizes = new ZeroArray(this.max), this.removeItemSize = index => {
          this.calculatedSize -= this.sizes[index], this.sizes[index] = 0;
        }, this.requireSize = (k, v, size, sizeCalculation) => {
          if (!isPosInt(size)) if (sizeCalculation) {
            if (typeof sizeCalculation != "function") throw new TypeError("sizeCalculation must be a function");
            if (size = sizeCalculation(v, k), !isPosInt(size)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          } else throw new TypeError("invalid size value (must be positive integer)");
          return size;
        }, this.addItemSize = (index, size) => {
          this.sizes[index] = size;
          let maxSize = this.maxSize - this.sizes[index];
          for (; this.calculatedSize > maxSize;) this.evict(!0);
          this.calculatedSize += this.sizes[index];
        };
      }
      removeItemSize(index) {}
      addItemSize(index, size) {}
      requireSize(k, v, size, sizeCalculation) {
        if (size || sizeCalculation) throw new TypeError("cannot set size without setting maxSize on cache");
      }
      *indexes({
        allowStale = this.allowStale
      } = {}) {
        if (this.size) for (let i = this.tail; !(!this.isValidIndex(i) || ((allowStale || !this.isStale(i)) && (yield i), i === this.head));) i = this.prev[i];
      }
      *rindexes({
        allowStale = this.allowStale
      } = {}) {
        if (this.size) for (let i = this.head; !(!this.isValidIndex(i) || ((allowStale || !this.isStale(i)) && (yield i), i === this.tail));) i = this.next[i];
      }
      isValidIndex(index) {
        return this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (let i of this.indexes()) yield [this.keyList[i], this.valList[i]];
      }
      *rentries() {
        for (let i of this.rindexes()) yield [this.keyList[i], this.valList[i]];
      }
      *keys() {
        for (let i of this.indexes()) yield this.keyList[i];
      }
      *rkeys() {
        for (let i of this.rindexes()) yield this.keyList[i];
      }
      *values() {
        for (let i of this.indexes()) yield this.valList[i];
      }
      *rvalues() {
        for (let i of this.rindexes()) yield this.valList[i];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (let i of this.indexes()) if (fn(this.valList[i], this.keyList[i], this)) return this.get(this.keyList[i], getOptions);
      }
      forEach(fn, thisp = this) {
        for (let i of this.indexes()) fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
      rforEach(fn, thisp = this) {
        for (let i of this.rindexes()) fn.call(thisp, this.valList[i], this.keyList[i], this);
      }
      get prune() {
        return deprecatedMethod("prune", "purgeStale"), this.purgeStale;
      }
      purgeStale() {
        let deleted = !1;
        for (let i of this.rindexes({
          allowStale: !0
        })) this.isStale(i) && (this.delete(this.keyList[i]), deleted = !0);
        return deleted;
      }
      dump() {
        let arr = [];
        for (let i of this.indexes({
          allowStale: !0
        })) {
          let key = this.keyList[i],
            v = this.valList[i],
            entry = {
              value: this.isBackgroundFetch(v) ? v.__staleWhileFetching : v
            };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            let age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          this.sizes && (entry.size = this.sizes[i]), arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (let [key, entry] of arr) {
          if (entry.start) {
            let age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(v, k, reason) {}
      set(k, v, {
        ttl = this.ttl,
        start: start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL
      } = {}) {
        if (size = this.requireSize(k, v, size, sizeCalculation), this.maxSize && size > this.maxSize) return this;
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) index = this.newIndex(), this.keyList[index] = k, this.valList[index] = v, this.keyMap.set(k, index), this.next[this.tail] = index, this.prev[index] = this.tail, this.tail = index, this.size++, this.addItemSize(index, size), noUpdateTTL = !1;else {
          let oldVal = this.valList[index];
          v !== oldVal && (this.isBackgroundFetch(oldVal) ? oldVal.__abortController.abort() : noDisposeOnSet || (this.dispose(oldVal, k, "set"), this.disposeAfter && this.disposed.push([oldVal, k, "set"])), this.removeItemSize(index), this.valList[index] = v, this.addItemSize(index, size)), this.moveToTail(index);
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls && this.initializeTTLTracking(), noUpdateTTL || this.setItemTTL(index, ttl, start), this.disposeAfter) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
        return this;
      }
      newIndex() {
        return this.size === 0 ? this.tail : this.size === this.max && this.max !== 0 ? this.evict(!1) : this.free.length !== 0 ? this.free.pop() : this.initialFill++;
      }
      pop() {
        if (this.size) {
          let val = this.valList[this.head];
          return this.evict(!0), val;
        }
      }
      evict(free) {
        let head = this.head,
          k = this.keyList[head],
          v = this.valList[head];
        return this.isBackgroundFetch(v) ? v.__abortController.abort() : (this.dispose(v, k, "evict"), this.disposeAfter && this.disposed.push([v, k, "evict"])), this.removeItemSize(head), free && (this.keyList[head] = null, this.valList[head] = null, this.free.push(head)), this.head = this.next[head], this.keyMap.delete(k), this.size--, head;
      }
      has(k, {
        updateAgeOnHas = this.updateAgeOnHas
      } = {}) {
        let index = this.keyMap.get(k);
        return index !== void 0 && !this.isStale(index) ? (updateAgeOnHas && this.updateItemAge(index), !0) : !1;
      }
      peek(k, {
        allowStale = this.allowStale
      } = {}) {
        let index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          let v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context) {
        let v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) return v;
        let ac = new AC(),
          fetchOpts = {
            signal: ac.signal,
            options: options,
            context: context
          },
          cb = __name(v => (ac.signal.aborted || this.set(k, v, fetchOpts.options), v), "cb"),
          eb = __name(er => {
            if (this.valList[index] === p && (!options.noDeleteOnFetchRejection || p.__staleWhileFetching === void 0 ? this.delete(k) : this.valList[index] = p.__staleWhileFetching), p.__returned === p) throw er;
          }, "eb"),
          pcall = __name(res => res(this.fetchMethod(k, v, fetchOpts)), "pcall"),
          p = new Promise(pcall).then(cb, eb);
        return p.__abortController = ac, p.__staleWhileFetching = v, p.__returned = null, index === void 0 ? (this.set(k, p, fetchOpts.options), index = this.keyMap.get(k)) : this.valList[index] = p, p;
      }
      isBackgroundFetch(p) {
        return p && typeof p == "object" && typeof p.then == "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      async fetch(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        fetchContext = this.fetchContext,
        forceRefresh = !1
      } = {}) {
        if (!this.fetchMethod) return this.get(k, {
          allowStale: allowStale,
          updateAgeOnGet: updateAgeOnGet,
          noDeleteOnStaleGet: noDeleteOnStaleGet
        });
        let options = {
            allowStale: allowStale,
            updateAgeOnGet: updateAgeOnGet,
            noDeleteOnStaleGet: noDeleteOnStaleGet,
            ttl: ttl,
            noDisposeOnSet: noDisposeOnSet,
            size: size,
            sizeCalculation: sizeCalculation,
            noUpdateTTL: noUpdateTTL,
            noDeleteOnFetchRejection: noDeleteOnFetchRejection
          },
          index = this.keyMap.get(k);
        if (index === void 0) {
          let p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          let v = this.valList[index];
          if (this.isBackgroundFetch(v)) return allowStale && v.__staleWhileFetching !== void 0 ? v.__staleWhileFetching : v.__returned = v;
          if (!forceRefresh && !this.isStale(index)) return this.moveToTail(index), updateAgeOnGet && this.updateItemAge(index), v;
          let p = this.backgroundFetch(k, index, options, fetchContext);
          return allowStale && p.__staleWhileFetching !== void 0 ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet
      } = {}) {
        let index = this.keyMap.get(k);
        if (index !== void 0) {
          let value = this.valList[index],
            fetching = this.isBackgroundFetch(value);
          return this.isStale(index) ? fetching ? allowStale ? value.__staleWhileFetching : void 0 : (noDeleteOnStaleGet || this.delete(k), allowStale ? value : void 0) : fetching ? void 0 : (this.moveToTail(index), updateAgeOnGet && this.updateItemAge(index), value);
        }
      }
      connect(p, n) {
        this.prev[n] = p, this.next[p] = n;
      }
      moveToTail(index) {
        index !== this.tail && (index === this.head ? this.head = this.next[index] : this.connect(this.prev[index], this.next[index]), this.connect(this.tail, index), this.tail = index);
      }
      get del() {
        return deprecatedMethod("del", "delete"), this.delete;
      }
      delete(k) {
        let deleted = !1;
        if (this.size !== 0) {
          let index = this.keyMap.get(k);
          if (index !== void 0) if (deleted = !0, this.size === 1) this.clear();else {
            this.removeItemSize(index);
            let v = this.valList[index];
            this.isBackgroundFetch(v) ? v.__abortController.abort() : (this.dispose(v, k, "delete"), this.disposeAfter && this.disposed.push([v, k, "delete"])), this.keyMap.delete(k), this.keyList[index] = null, this.valList[index] = null, index === this.tail ? this.tail = this.prev[index] : index === this.head ? this.head = this.next[index] : (this.next[this.prev[index]] = this.next[index], this.prev[this.next[index]] = this.prev[index]), this.size--, this.free.push(index);
          }
        }
        if (this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
        return deleted;
      }
      clear() {
        for (let index of this.rindexes({
          allowStale: !0
        })) {
          let v = this.valList[index];
          if (this.isBackgroundFetch(v)) v.__abortController.abort();else {
            let k = this.keyList[index];
            this.dispose(v, k, "delete"), this.disposeAfter && this.disposed.push([v, k, "delete"]);
          }
        }
        if (this.keyMap.clear(), this.valList.fill(null), this.keyList.fill(null), this.ttls && (this.ttls.fill(0), this.starts.fill(0)), this.sizes && this.sizes.fill(0), this.head = 0, this.tail = 0, this.initialFill = 1, this.free.length = 0, this.calculatedSize = 0, this.size = 0, this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());
      }
      get reset() {
        return deprecatedMethod("reset", "clear"), this.clear;
      }
      get length() {
        return deprecatedProperty("length", "size"), this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
  module.exports = LRUCache;
});
var require_errors = __commonJSMin((exports, module) => {
  "use strict";

  var FetchBaseError = class extends Error {
      static {
        __name(this, "FetchBaseError");
      }
      constructor(message, type, name) {
        super(message), this.type = type, this._name = name;
      }
      get name() {
        return this._name;
      }
      get [Symbol.toStringTag]() {
        return this._name;
      }
    },
    FetchError = class extends FetchBaseError {
      static {
        __name(this, "FetchError");
      }
      constructor(message, type, systemError) {
        super(message, type, "FetchError"), systemError && (this.code = systemError.code, this.errno = systemError.errno, this.erroredSysCall = systemError.syscall);
      }
    },
    AbortError = class extends FetchBaseError {
      static {
        __name(this, "AbortError");
      }
      constructor(message, type = "aborted") {
        super(message, type, "AbortError");
      }
    };
  module.exports = {
    FetchBaseError: FetchBaseError,
    FetchError: FetchError,
    AbortError: AbortError
  };
});
var require_utils = __commonJSMin((exports, module) => {
  "use strict";

  var {
      constants: {
        MAX_LENGTH: maxBufferLength
      }
    } = require("buffer"),
    {
      pipeline: pipeline,
      PassThrough: PassThrough
    } = require("stream"),
    {
      promisify: promisify
    } = require("util"),
    {
      createGunzip: createGunzip,
      createInflate: createInflate,
      createBrotliDecompress: createBrotliDecompress,
      constants: {
        Z_SYNC_FLUSH: Z_SYNC_FLUSH
      }
    } = require("zlib"),
    debug = Gu()("helix-fetch:utils"),
    asyncPipeline = promisify(pipeline),
    canDecode = __name((statusCode, headers) => statusCode === 204 || statusCode === 304 || +headers["content-length"] == 0 ? !1 : /^\s*(?:(x-)?deflate|(x-)?gzip|br)\s*$/.test(headers["content-encoding"]), "canDecode"),
    decodeStream = __name((statusCode, headers, readableStream, onError) => {
      if (!canDecode(statusCode, headers)) return readableStream;
      let cb = __name(err => {
        err && (debug(`encountered error while decoding stream: ${err}`), onError(err));
      }, "cb");
      switch (headers["content-encoding"].trim()) {
        case "gzip":
        case "x-gzip":
          return pipeline(readableStream, createGunzip({
            flush: Z_SYNC_FLUSH,
            finishFlush: Z_SYNC_FLUSH
          }), cb);
        case "deflate":
        case "x-deflate":
          return pipeline(readableStream, createInflate(), cb);
        case "br":
          return pipeline(readableStream, createBrotliDecompress(), cb);
        default:
          return readableStream;
      }
    }, "decodeStream"),
    isPlainObject = __name(val => {
      if (!val || typeof val != "object" || Object.prototype.toString.call(val) !== "[object Object]") return !1;
      if (Object.getPrototypeOf(val) === null) return !0;
      let proto = val;
      for (; Object.getPrototypeOf(proto) !== null;) proto = Object.getPrototypeOf(proto);
      return Object.getPrototypeOf(val) === proto;
    }, "isPlainObject"),
    calcSize = __name((obj, processed) => {
      if (Buffer.isBuffer(obj)) return obj.length;
      switch (typeof obj) {
        case "string":
          return obj.length * 2;
        case "boolean":
          return 4;
        case "number":
          return 8;
        case "symbol":
          return Symbol.keyFor(obj) ? Symbol.keyFor(obj).length * 2 : (obj.toString().length - 8) * 2;
        case "object":
          return Array.isArray(obj) ? calcArraySize(obj, processed) : calcObjectSize(obj, processed);
        default:
          return 0;
      }
    }, "calcSize"),
    calcArraySize = __name((arr, processed) => (processed.add(arr), arr.map(entry => processed.has(entry) ? 0 : calcSize(entry, processed)).reduce((acc, curr) => acc + curr, 0)), "calcArraySize"),
    calcObjectSize = __name((obj, processed) => {
      if (obj == null) return 0;
      processed.add(obj);
      let bytes = 0,
        names = [];
      for (let key in obj) names.push(key);
      return names.push(...Object.getOwnPropertySymbols(obj)), names.forEach(nm => {
        if (bytes += calcSize(nm, processed), typeof obj[nm] == "object" && obj[nm] !== null) {
          if (processed.has(obj[nm])) return;
          processed.add(obj[nm]);
        }
        bytes += calcSize(obj[nm], processed);
      }), bytes;
    }, "calcObjectSize"),
    sizeof = __name(obj => calcSize(obj, new WeakSet()), "sizeof"),
    streamToBuffer = __name(async stream => {
      let passThroughStream = new PassThrough(),
        length = 0,
        chunks = [];
      return passThroughStream.on("data", chunk => {
        if (length + chunk.length > maxBufferLength) throw new Error("Buffer.constants.MAX_SIZE exceeded");
        chunks.push(chunk), length += chunk.length;
      }), await asyncPipeline(stream, passThroughStream), Buffer.concat(chunks, length);
    }, "streamToBuffer");
  module.exports = {
    decodeStream: decodeStream,
    isPlainObject: isPlainObject,
    sizeof: sizeof,
    streamToBuffer: streamToBuffer
  };
});
var require_body = __commonJSMin((exports, module) => {
  "use strict";

  var {
      PassThrough: PassThrough,
      Readable: Readable
    } = require("stream"),
    {
      types: {
        isAnyArrayBuffer: isAnyArrayBuffer
      }
    } = require("util"),
    {
      FetchError: FetchError,
      FetchBaseError: FetchBaseError
    } = tS(),
    {
      streamToBuffer: streamToBuffer
    } = gd(),
    EMPTY_BUFFER = Buffer.alloc(0),
    INTERNALS = Symbol("Body internals"),
    toArrayBuffer = __name(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength), "toArrayBuffer"),
    consume = __name(async body => {
      if (body[INTERNALS].disturbed) throw new TypeError("Already read");
      if (body[INTERNALS].error) throw new TypeError(`Stream had error: ${body[INTERNALS].error.message}`);
      body[INTERNALS].disturbed = !0;
      let {
        stream: stream
      } = body[INTERNALS];
      return stream === null ? EMPTY_BUFFER : streamToBuffer(stream);
    }, "consume"),
    Body = class {
      static {
        __name(this, "Body");
      }
      constructor(body) {
        let stream;
        body == null ? stream = null : body instanceof URLSearchParams ? stream = Readable.from(body.toString()) : body instanceof Readable ? stream = body : Buffer.isBuffer(body) ? stream = Readable.from(body) : isAnyArrayBuffer(body) ? stream = Readable.from(Buffer.from(body)) : typeof body == "string" || body instanceof String ? stream = Readable.from(body) : stream = Readable.from(String(body)), this[INTERNALS] = {
          stream: stream,
          disturbed: !1,
          error: null
        }, body instanceof Readable && stream.on("error", err => {
          let error = err instanceof FetchBaseError ? err : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, "system", err);
          this[INTERNALS].error = error;
        });
      }
      get body() {
        return this[INTERNALS].stream;
      }
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      }
      async buffer() {
        return consume(this);
      }
      async arrayBuffer() {
        return toArrayBuffer(await this.buffer());
      }
      async text() {
        return (await consume(this)).toString();
      }
      async json() {
        return JSON.parse(await this.text());
      }
    };
  Object.defineProperties(Body.prototype, {
    body: {
      enumerable: !0
    },
    bodyUsed: {
      enumerable: !0
    },
    arrayBuffer: {
      enumerable: !0
    },
    json: {
      enumerable: !0
    },
    text: {
      enumerable: !0
    }
  });
  var cloneStream = __name(body => {
      if (body[INTERNALS].disturbed) throw new TypeError("Cannot clone: already read");
      let {
          stream: stream
        } = body[INTERNALS],
        result = stream;
      if (stream instanceof Readable) {
        result = new PassThrough();
        let clonedStream = new PassThrough();
        stream.pipe(result), stream.pipe(clonedStream), body[INTERNALS].stream = clonedStream;
      }
      return result;
    }, "cloneStream"),
    guessContentType = __name(body => body === null ? null : typeof body == "string" ? "text/plain; charset=utf-8" : body instanceof URLSearchParams ? "application/x-www-form-urlencoded; charset=utf-8" : Buffer.isBuffer(body) || isAnyArrayBuffer(body) || body instanceof Readable ? null : "text/plain; charset=utf-8", "guessContentType");
  module.exports = {
    Body: Body,
    cloneStream: cloneStream,
    guessContentType: guessContentType
  };
});
var require_headers = __commonJSMin((exports, module) => {
  "use strict";

  var {
      validateHeaderName: validateHeaderName,
      validateHeaderValue: validateHeaderValue
    } = require("http"),
    {
      isPlainObject: isPlainObject
    } = gd(),
    INTERNALS = Symbol("Headers internals"),
    normalizeName = __name(name => {
      let nm = typeof name != "string" ? String(name) : name;
      if (typeof validateHeaderName == "function") validateHeaderName(nm);else if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(nm)) {
        let err = new TypeError(`Header name must be a valid HTTP token [${nm}]`);
        throw Object.defineProperty(err, "code", {
          value: "ERR_INVALID_HTTP_TOKEN"
        }), err;
      }
      return nm.toLowerCase();
    }, "normalizeName"),
    normalizeValue = __name((value, name) => {
      let val = typeof value != "string" ? String(value) : value;
      if (typeof validateHeaderValue == "function") validateHeaderValue(name, val);else if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(val)) {
        let err = new TypeError(`Invalid character in header content ["${name}"]`);
        throw Object.defineProperty(err, "code", {
          value: "ERR_INVALID_CHAR"
        }), err;
      }
      return val;
    }, "normalizeValue"),
    Headers = class _Headers {
      static {
        __name(this, "Headers");
      }
      constructor(init = {}) {
        if (this[INTERNALS] = {
          map: new Map()
        }, init instanceof _Headers) init.forEach((value, name) => {
          this.append(name, value);
        });else if (Array.isArray(init)) init.forEach(([name, value]) => {
          this.append(name, value);
        });else if (isPlainObject(init)) for (let [name, value] of Object.entries(init)) this.append(name, value);
      }
      set(name, value) {
        this[INTERNALS].map.set(normalizeName(name), normalizeValue(value, name));
      }
      has(name) {
        return this[INTERNALS].map.has(normalizeName(name));
      }
      get(name) {
        let val = this[INTERNALS].map.get(normalizeName(name));
        return val === void 0 ? null : val;
      }
      append(name, value) {
        let nm = normalizeName(name),
          val = normalizeValue(value, name),
          oldVal = this[INTERNALS].map.get(nm);
        this[INTERNALS].map.set(nm, oldVal ? `${oldVal}, ${val}` : val);
      }
      delete(name) {
        this[INTERNALS].map.delete(normalizeName(name));
      }
      forEach(callback, thisArg) {
        for (let name of this.keys()) callback.call(thisArg, this.get(name), name);
      }
      keys() {
        return Array.from(this[INTERNALS].map.keys()).sort();
      }
      *values() {
        for (let name of this.keys()) yield this.get(name);
      }
      *entries() {
        for (let name of this.keys()) yield [name, this.get(name)];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      plain() {
        return Object.fromEntries(this[INTERNALS].map);
      }
    };
  Object.defineProperties(Headers.prototype, ["append", "delete", "entries", "forEach", "get", "has", "keys", "set", "values"].reduce((result, property) => (result[property] = {
    enumerable: !0
  }, result), {}));
  module.exports = {
    Headers: Headers
  };
});
var require_abort = __commonJSMin((exports, module) => {
  "use strict";

  var {
      EventEmitter: EventEmitter
    } = require("events"),
    SIGNAL_INTERNALS = Symbol("AbortSignal internals"),
    AbortSignal = class {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this[SIGNAL_INTERNALS] = {
          eventEmitter: new EventEmitter(),
          onabort: null,
          aborted: !1
        };
      }
      get aborted() {
        return this[SIGNAL_INTERNALS].aborted;
      }
      get onabort() {
        return this[SIGNAL_INTERNALS].onabort;
      }
      set onabort(handler) {
        this[SIGNAL_INTERNALS].onabort = handler;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      removeEventListener(name, handler) {
        this[SIGNAL_INTERNALS].eventEmitter.removeListener(name, handler);
      }
      addEventListener(name, handler) {
        this[SIGNAL_INTERNALS].eventEmitter.on(name, handler);
      }
      dispatchEvent(type) {
        let event = {
            type: type,
            target: this
          },
          handlerName = `on${type}`;
        typeof this[SIGNAL_INTERNALS][handlerName] == "function" && this[handlerName](event), this[SIGNAL_INTERNALS].eventEmitter.emit(type, event);
      }
      fire() {
        this[SIGNAL_INTERNALS].aborted = !0, this.dispatchEvent("abort");
      }
    };
  Object.defineProperties(AbortSignal.prototype, {
    addEventListener: {
      enumerable: !0
    },
    removeEventListener: {
      enumerable: !0
    },
    dispatchEvent: {
      enumerable: !0
    },
    aborted: {
      enumerable: !0
    },
    onabort: {
      enumerable: !0
    }
  });
  var TimeoutSignal = class extends AbortSignal {
    static {
      __name(this, "TimeoutSignal");
    }
    constructor(timeout) {
      if (!Number.isInteger(timeout)) throw new TypeError(`Expected an integer, got ${typeof timeout}`);
      super(), this[SIGNAL_INTERNALS].timerId = setTimeout(() => {
        this.fire();
      }, timeout);
    }
    clear() {
      clearTimeout(this[SIGNAL_INTERNALS].timerId);
    }
  };
  Object.defineProperties(TimeoutSignal.prototype, {
    clear: {
      enumerable: !0
    }
  });
  var CONTROLLER_INTERNALS = Symbol("AbortController internals"),
    AbortController = class {
      static {
        __name(this, "AbortController");
      }
      constructor() {
        this[CONTROLLER_INTERNALS] = {
          signal: new AbortSignal()
        };
      }
      get signal() {
        return this[CONTROLLER_INTERNALS].signal;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      abort() {
        this[CONTROLLER_INTERNALS].signal.aborted || this[CONTROLLER_INTERNALS].signal.fire();
      }
    };
  Object.defineProperties(AbortController.prototype, {
    signal: {
      enumerable: !0
    },
    abort: {
      enumerable: !0
    }
  });
  module.exports = {
    AbortController: AbortController,
    AbortSignal: AbortSignal,
    TimeoutSignal: TimeoutSignal
  };
});
var require_formData = __commonJSMin((exports, module) => {
  "use strict";

  var {
      randomBytes: randomBytes
    } = require("crypto"),
    {
      Readable: Readable
    } = require("stream"),
    isBlob = __name(obj => typeof obj == "object" && ["arrayBuffer", "stream", "text", "slice", "constructor"].map(nm => typeof obj[nm]).filter(type => type !== "function").length === 0 && typeof obj.type == "string" && typeof obj.size == "number" && /^(Blob|File)$/.test(obj[Symbol.toStringTag]), "isBlob"),
    isFormData = __name(obj => obj != null && typeof obj == "object" && ["append", "delete", "get", "getAll", "has", "set", "keys", "values", "entries", "constructor"].map(nm => typeof obj[nm]).filter(type => type !== "function").length === 0 && obj[Symbol.toStringTag] === "FormData", "isFormData"),
    getFooter = __name(boundary => `--${boundary}--\r
\r
`, "getFooter"),
    getHeader = __name((boundary, name, field) => {
      let header = "";
      return header += `--${boundary}\r
`, header += `Content-Disposition: form-data; name="${name}"`, isBlob(field) && (header += `; filename="${field.name}"\r
`, header += `Content-Type: ${field.type || "application/octet-stream"}`), `${header}\r
\r
`;
    }, "getHeader");
  async function* formDataIterator(form, boundary) {
    for (let [name, value] of form) yield getHeader(boundary, name, value), isBlob(value) ? yield* value.stream() : yield value, yield `\r
`;
    yield getFooter(boundary);
  }
  __name(formDataIterator, "formDataIterator");
  var getFormDataLength = __name((form, boundary) => {
      let length = 0;
      for (let [name, value] of form) length += Buffer.byteLength(getHeader(boundary, name, value)), length += isBlob(value) ? value.size : Buffer.byteLength(String(value)), length += Buffer.byteLength(`\r
`);
      return length += Buffer.byteLength(getFooter(boundary)), length;
    }, "getFormDataLength"),
    FormDataSerializer = class {
      static {
        __name(this, "FormDataSerializer");
      }
      constructor(formData) {
        this.fd = formData, this.boundary = randomBytes(8).toString("hex");
      }
      length() {
        return typeof this._length > "u" && (this._length = getFormDataLength(this.fd, this.boundary)), this._length;
      }
      contentType() {
        return `multipart/form-data; boundary=${this.boundary}`;
      }
      stream() {
        return Readable.from(formDataIterator(this.fd, this.boundary));
      }
    };
  module.exports = {
    isFormData: isFormData,
    FormDataSerializer: FormDataSerializer
  };
});
var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      AbortSignal: AbortSignal
    } = rS(),
    {
      Body: Body,
      cloneStream: cloneStream,
      guessContentType: guessContentType
    } = H8(),
    {
      Headers: Headers
    } = $h(),
    {
      isPlainObject: isPlainObject
    } = gd(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = Y3(),
    DEFAULT_FOLLOW = 20,
    INTERNALS = Symbol("Request internals"),
    Request = class _Request extends Body {
      static {
        __name(this, "Request");
      }
      constructor(input, init = {}) {
        let req = input instanceof _Request ? input : null,
          parsedURL = req ? new URL(req.url) : new URL(input),
          method = init.method || req && req.method || "GET";
        if (method = method.toUpperCase(), (init.body != null || req && req.body !== null) && ["GET", "HEAD"].includes(method)) throw new TypeError("Request with GET/HEAD method cannot have body");
        let body = init.body || (req && req.body ? cloneStream(req) : null),
          headers = new Headers(init.headers || req && req.headers || {});
        if (isFormData(body) && !headers.has("content-type")) {
          let fd = new FormDataSerializer(body);
          body = fd.stream(), headers.set("content-type", fd.contentType()), !headers.has("transfer-encoding") && !headers.has("content-length") && headers.set("content-length", fd.length());
        }
        if (!headers.has("content-type")) if (isPlainObject(body)) body = JSON.stringify(body), headers.set("content-type", "application/json");else {
          let contentType = guessContentType(body);
          contentType && headers.set("content-type", contentType);
        }
        super(body);
        let signal = req ? req.signal : null;
        if ("signal" in init && (signal = init.signal), signal && !(signal instanceof AbortSignal)) throw new TypeError("signal needs to be an instance of AbortSignal");
        let redirect = init.redirect || req && req.redirect || "follow";
        if (!["follow", "error", "manual"].includes(redirect)) throw new TypeError(`'${redirect}' is not a valid redirect option`);
        let cache = init.cache || req && req.cache || "default";
        if (!["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"].includes(cache)) throw new TypeError(`'${cache}' is not a valid cache option`);
        this[INTERNALS] = {
          init: {
            ...init
          },
          method: method,
          redirect: redirect,
          cache: cache,
          headers: headers,
          parsedURL: parsedURL,
          signal: signal
        }, init.follow === void 0 ? !req || req.follow === void 0 ? this.follow = DEFAULT_FOLLOW : this.follow = req.follow : this.follow = init.follow, this.counter = init.counter || req && req.counter || 0, init.compress === void 0 ? !req || req.compress === void 0 ? this.compress = !0 : this.compress = req.compress : this.compress = init.compress, init.decode === void 0 ? !req || req.decode === void 0 ? this.decode = !0 : this.decode = req.decode : this.decode = init.decode;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return this[INTERNALS].parsedURL.toString();
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get cache() {
        return this[INTERNALS].cache;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new _Request(this);
      }
      get init() {
        return this[INTERNALS].init;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  Object.defineProperties(Request.prototype, {
    method: {
      enumerable: !0
    },
    url: {
      enumerable: !0
    },
    headers: {
      enumerable: !0
    },
    redirect: {
      enumerable: !0
    },
    cache: {
      enumerable: !0
    },
    clone: {
      enumerable: !0
    },
    signal: {
      enumerable: !0
    }
  });
  module.exports = {
    Request: Request
  };
});
var require_response = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Body: Body,
      cloneStream: cloneStream,
      guessContentType: guessContentType
    } = H8(),
    {
      Headers: Headers
    } = $h(),
    {
      isPlainObject: isPlainObject
    } = gd(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = Y3(),
    INTERNALS = Symbol("Response internals"),
    Response = class _Response extends Body {
      static {
        __name(this, "Response");
      }
      constructor(body = null, init = {}) {
        let headers = new Headers(init.headers),
          respBody = body;
        if (isFormData(respBody) && !headers.has("content-type")) {
          let fd = new FormDataSerializer(respBody);
          respBody = fd.stream(), headers.set("content-type", fd.contentType()), !headers.has("transfer-encoding") && !headers.has("content-length") && headers.set("content-length", fd.length());
        }
        if (respBody !== null && !headers.has("content-type")) if (isPlainObject(respBody)) respBody = JSON.stringify(respBody), headers.set("content-type", "application/json");else {
          let contentType = guessContentType(respBody);
          contentType && headers.set("content-type", contentType);
        }
        super(respBody), this[INTERNALS] = {
          url: init.url,
          status: init.status || 200,
          statusText: init.statusText || "",
          headers: headers,
          httpVersion: init.httpVersion,
          decoded: init.decoded,
          counter: init.counter
        };
      }
      get url() {
        return this[INTERNALS].url || "";
      }
      get status() {
        return this[INTERNALS].status;
      }
      get statusText() {
        return this[INTERNALS].statusText;
      }
      get ok() {
        return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
      }
      get redirected() {
        return this[INTERNALS].counter > 0;
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get httpVersion() {
        return this[INTERNALS].httpVersion;
      }
      get decoded() {
        return this[INTERNALS].decoded;
      }
      static redirect(url, status = 302) {
        if (![301, 302, 303, 307, 308].includes(status)) throw new RangeError("Invalid status code");
        return new _Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status: status
        });
      }
      clone() {
        if (this.bodyUsed) throw new TypeError("Cannot clone: already read");
        return new _Response(cloneStream(this), {
          ...this[INTERNALS]
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
  Object.defineProperties(Response.prototype, {
    url: {
      enumerable: !0
    },
    status: {
      enumerable: !0
    },
    ok: {
      enumerable: !0
    },
    redirected: {
      enumerable: !0
    },
    statusText: {
      enumerable: !0
    },
    headers: {
      enumerable: !0
    },
    clone: {
      enumerable: !0
    }
  });
  module.exports = {
    Response: Response
  };
});
var require_http_cache_semantics = __commonJSMin((exports, module) => {
  "use strict";

  var statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]),
    understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]),
    errorStatusCodes = new Set([500, 502, 503, 504]),
    hopByHopHeaders = {
      date: !0,
      connection: !0,
      "keep-alive": !0,
      "proxy-authenticate": !0,
      "proxy-authorization": !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0
    },
    excludedFromRevalidationUpdate = {
      "content-length": !0,
      "content-encoding": !0,
      "transfer-encoding": !0,
      "content-range": !0
    };
  function toNumberOrZero(s) {
    let n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
  }
  __name(toNumberOrZero, "toNumberOrZero");
  function isErrorResponse(response) {
    return response ? errorStatusCodes.has(response.status) : !0;
  }
  __name(isErrorResponse, "isErrorResponse");
  function parseCacheControl(header) {
    let cc = {};
    if (!header) return cc;
    let parts = header.trim().split(/,/);
    for (let part of parts) {
      let [k, v] = part.split(/=/, 2);
      cc[k.trim()] = v === void 0 ? !0 : v.trim().replace(/^"|"$/g, "");
    }
    return cc;
  }
  __name(parseCacheControl, "parseCacheControl");
  function formatCacheControl(cc) {
    let parts = [];
    for (let k in cc) {
      let v = cc[k];
      parts.push(v === !0 ? k : k + "=" + v);
    }
    if (parts.length) return parts.join(", ");
  }
  __name(formatCacheControl, "formatCacheControl");
  module.exports = class {
    static {
      __name(this, "CachePolicy");
    }
    constructor(req, res, {
      shared: shared,
      cacheHeuristic: cacheHeuristic,
      immutableMinTimeToLive: immutableMinTimeToLive,
      ignoreCargoCult: ignoreCargoCult,
      _fromObject: _fromObject
    } = {}) {
      if (_fromObject) {
        this._fromObject(_fromObject);
        return;
      }
      if (!res || !res.headers) throw Error("Response headers missing");
      this._assertRequestHasHeaders(req), this._responseTime = this.now(), this._isShared = shared !== !1, this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : .1, this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3, this._status = "status" in res ? res.status : 200, this._resHeaders = res.headers, this._rescc = parseCacheControl(res.headers["cache-control"]), this._method = "method" in req ? req.method : "GET", this._url = req.url, this._host = req.headers.host, this._noAuthorization = !req.headers.authorization, this._reqHeaders = res.headers.vary ? req.headers : null, this._reqcc = parseCacheControl(req.headers["cache-control"]), ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"], delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalidate"], this._resHeaders = Object.assign({}, this._resHeaders, {
        "cache-control": formatCacheControl(this._rescc)
      }), delete this._resHeaders.expires, delete this._resHeaders.pragma), res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma) && (this._rescc["no-cache"] = !0);
    }
    now() {
      return Date.now();
    }
    storable() {
      return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
    }
    _hasExplicitExpiration() {
      return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
    }
    _assertRequestHasHeaders(req) {
      if (!req || !req.headers) throw Error("Request headers missing");
    }
    satisfiesWithoutRevalidation(req) {
      this._assertRequestHasHeaders(req);
      let requestCC = parseCacheControl(req.headers["cache-control"]);
      return requestCC["no-cache"] || /no-cache/.test(req.headers.pragma) || requestCC["max-age"] && this.age() > requestCC["max-age"] || requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"] || this.stale() && !(requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === !0 || requestCC["max-stale"] > this.age() - this.maxAge())) ? !1 : this._requestMatches(req, !1);
    }
    _requestMatches(req, allowHeadMethod) {
      return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
    }
    _allowsStoringAuthenticated() {
      return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
    }
    _varyMatches(req) {
      if (!this._resHeaders.vary) return !0;
      if (this._resHeaders.vary === "*") return !1;
      let fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
      for (let name of fields) if (req.headers[name] !== this._reqHeaders[name]) return !1;
      return !0;
    }
    _copyWithoutHopByHopHeaders(inHeaders) {
      let headers = {};
      for (let name in inHeaders) hopByHopHeaders[name] || (headers[name] = inHeaders[name]);
      if (inHeaders.connection) {
        let tokens = inHeaders.connection.trim().split(/\s*,\s*/);
        for (let name of tokens) delete headers[name];
      }
      if (headers.warning) {
        let warnings = headers.warning.split(/,/).filter(warning => !/^\s*1[0-9][0-9]/.test(warning));
        warnings.length ? headers.warning = warnings.join(",").trim() : delete headers.warning;
      }
      return headers;
    }
    responseHeaders() {
      let headers = this._copyWithoutHopByHopHeaders(this._resHeaders),
        age = this.age();
      return age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24 && (headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"'), headers.age = `${Math.round(age)}`, headers.date = new Date(this.now()).toUTCString(), headers;
    }
    date() {
      let serverDate = Date.parse(this._resHeaders.date);
      return isFinite(serverDate) ? serverDate : this._responseTime;
    }
    age() {
      let age = this._ageValue(),
        residentTime = (this.now() - this._responseTime) / 1e3;
      return age + residentTime;
    }
    _ageValue() {
      return toNumberOrZero(this._resHeaders.age);
    }
    maxAge() {
      if (!this.storable() || this._rescc["no-cache"] || this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable || this._resHeaders.vary === "*") return 0;
      if (this._isShared) {
        if (this._rescc["proxy-revalidate"]) return 0;
        if (this._rescc["s-maxage"]) return toNumberOrZero(this._rescc["s-maxage"]);
      }
      if (this._rescc["max-age"]) return toNumberOrZero(this._rescc["max-age"]);
      let defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0,
        serverDate = this.date();
      if (this._resHeaders.expires) {
        let expires = Date.parse(this._resHeaders.expires);
        return Number.isNaN(expires) || expires < serverDate ? 0 : Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
      }
      if (this._resHeaders["last-modified"]) {
        let lastModified = Date.parse(this._resHeaders["last-modified"]);
        if (isFinite(lastModified) && serverDate > lastModified) return Math.max(defaultMinTtl, (serverDate - lastModified) / 1e3 * this._cacheHeuristic);
      }
      return defaultMinTtl;
    }
    timeToLive() {
      let age = this.maxAge() - this.age(),
        staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]),
        staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
      return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
    }
    stale() {
      return this.maxAge() <= this.age();
    }
    _useStaleIfError() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
    }
    useStaleWhileRevalidate() {
      return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
    }
    static fromObject(obj) {
      return new this(void 0, void 0, {
        _fromObject: obj
      });
    }
    _fromObject(obj) {
      if (this._responseTime) throw Error("Reinitialized");
      if (!obj || obj.v !== 1) throw Error("Invalid serialization");
      this._responseTime = obj.t, this._isShared = obj.sh, this._cacheHeuristic = obj.ch, this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3, this._status = obj.st, this._resHeaders = obj.resh, this._rescc = obj.rescc, this._method = obj.m, this._url = obj.u, this._host = obj.h, this._noAuthorization = obj.a, this._reqHeaders = obj.reqh, this._reqcc = obj.reqcc;
    }
    toObject() {
      return {
        v: 1,
        t: this._responseTime,
        sh: this._isShared,
        ch: this._cacheHeuristic,
        imm: this._immutableMinTtl,
        st: this._status,
        resh: this._resHeaders,
        rescc: this._rescc,
        m: this._method,
        u: this._url,
        h: this._host,
        a: this._noAuthorization,
        reqh: this._reqHeaders,
        reqcc: this._reqcc
      };
    }
    revalidationHeaders(incomingReq) {
      this._assertRequestHasHeaders(incomingReq);
      let headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
      if (delete headers["if-range"], !this._requestMatches(incomingReq, !0) || !this.storable()) return delete headers["if-none-match"], delete headers["if-modified-since"], headers;
      if (this._resHeaders.etag && (headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag), headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET") {
        if (delete headers["if-modified-since"], headers["if-none-match"]) {
          let etags = headers["if-none-match"].split(/,/).filter(etag => !/^\s*W\//.test(etag));
          etags.length ? headers["if-none-match"] = etags.join(",").trim() : delete headers["if-none-match"];
        }
      } else this._resHeaders["last-modified"] && !headers["if-modified-since"] && (headers["if-modified-since"] = this._resHeaders["last-modified"]);
      return headers;
    }
    revalidatedPolicy(request, response) {
      if (this._assertRequestHasHeaders(request), this._useStaleIfError() && isErrorResponse(response)) return {
        modified: !1,
        matches: !1,
        policy: this
      };
      if (!response || !response.headers) throw Error("Response headers missing");
      let matches = !1;
      if (response.status !== void 0 && response.status != 304 ? matches = !1 : response.headers.etag && !/^\s*W\//.test(response.headers.etag) ? matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag : this._resHeaders.etag && response.headers.etag ? matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? matches = this._resHeaders["last-modified"] === response.headers["last-modified"] : !this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"] && (matches = !0), !matches) return {
        policy: new this.constructor(request, response),
        modified: response.status != 304,
        matches: !1
      };
      let headers = {};
      for (let k in this._resHeaders) headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
      let newResponse = Object.assign({}, response, {
        status: this._status,
        method: this._method,
        headers: headers
      });
      return {
        policy: new this.constructor(request, newResponse, {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl
        }),
        modified: !1,
        matches: !0
      };
    }
  };
});
var require_policy = __commonJSMin((exports, module) => {
  "use strict";

  var CachePolicy = qF(),
    {
      Headers: Headers
    } = $h(),
    convertRequest = __name(req => ({
      url: req.url,
      method: req.method,
      headers: req.headers.plain()
    }), "convertRequest"),
    convertResponse = __name(res => ({
      status: res.status,
      headers: res.headers.plain()
    }), "convertResponse"),
    CachePolicyWrapper = class {
      static {
        __name(this, "CachePolicyWrapper");
      }
      constructor(req, res, options) {
        this.policy = new CachePolicy(convertRequest(req), convertResponse(res), options);
      }
      storable() {
        return this.policy.storable();
      }
      satisfiesWithoutRevalidation(req) {
        return this.policy.satisfiesWithoutRevalidation(convertRequest(req));
      }
      responseHeaders(res) {
        return new Headers(this.policy.responseHeaders(convertResponse(res)));
      }
      timeToLive() {
        return this.policy.timeToLive();
      }
    };
  module.exports = CachePolicyWrapper;
});
var require_cacheableResponse = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Readable: Readable
    } = require("stream"),
    {
      Headers: Headers
    } = $h(),
    {
      Response: Response
    } = sS(),
    INTERNALS = Symbol("CacheableResponse internals"),
    toArrayBuffer = __name(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength), "toArrayBuffer"),
    CacheableResponse = class _CacheableResponse extends Response {
      static {
        __name(this, "CacheableResponse");
      }
      constructor(body, init) {
        super(body, init);
        let headers = new Headers(init.headers);
        this[INTERNALS] = {
          headers: headers,
          bufferedBody: body
        };
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      set headers(headers) {
        if (headers instanceof Headers) this[INTERNALS].headers = headers;else throw new TypeError("instance of Headers expected");
      }
      get body() {
        return Readable.from(this[INTERNALS].bufferedBody);
      }
      get bodyUsed() {
        return !1;
      }
      async buffer() {
        return this[INTERNALS].bufferedBody;
      }
      async arrayBuffer() {
        return toArrayBuffer(this[INTERNALS].bufferedBody);
      }
      async text() {
        return this[INTERNALS].bufferedBody.toString();
      }
      async json() {
        return JSON.parse(await this.text());
      }
      clone() {
        let {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        } = this;
        return new _CacheableResponse(this[INTERNALS].bufferedBody, {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    },
    cacheableResponse = __name(async res => {
      let buf = await res.buffer(),
        {
          url: url,
          status: status,
          statusText: statusText,
          headers: headers,
          httpVersion: httpVersion,
          decoded: decoded,
          counter: counter
        } = res;
      return new CacheableResponse(buf, {
        url: url,
        status: status,
        statusText: statusText,
        headers: headers,
        httpVersion: httpVersion,
        decoded: decoded,
        counter: counter
      });
    }, "cacheableResponse");
  module.exports = {
    cacheableResponse: cacheableResponse
  };
});
var require_errors = __commonJSMin((exports, module) => {
  "use strict";

  var RequestAbortedError = class extends Error {
    static {
      __name(this, "RequestAbortedError");
    }
    get name() {
      return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
  module.exports = {
    RequestAbortedError: RequestAbortedError
  };
});
var require_h1 = __commonJSMin((exports, module) => {
  "use strict";

  var http = require("http"),
    https = require("https"),
    {
      Readable: Readable
    } = require("stream"),
    debug = Gu()("helix-fetch:h1"),
    {
      RequestAbortedError: RequestAbortedError
    } = X8(),
    {
      decodeStream: decodeStream
    } = gd(),
    getAgent = __name((ctx, protocol) => {
      let {
        h1: h1,
        options: {
          h1: opts,
          rejectUnauthorized: rejectUnauthorized
        }
      } = ctx;
      return protocol === "https:" ? h1.httpsAgent ? h1.httpsAgent : opts || typeof rejectUnauthorized == "boolean" ? (h1.httpsAgent = new https.Agent(typeof rejectUnauthorized == "boolean" ? {
        ...(opts || {}),
        rejectUnauthorized: rejectUnauthorized
      } : opts), h1.httpsAgent) : void 0 : h1.httpAgent ? h1.httpAgent : opts ? (h1.httpAgent = new http.Agent(opts), h1.httpAgent) : void 0;
    }, "getAgent"),
    setupContext = __name(ctx => {
      ctx.h1 = {};
    }, "setupContext"),
    resetContext = __name(async ({
      h1: h1
    }) => {
      h1.httpAgent && (debug("resetContext: destroying httpAgent"), h1.httpAgent.destroy(), delete h1.httpAgent), h1.httpsAgent && (debug("resetContext: destroying httpsAgent"), h1.httpsAgent.destroy(), delete h1.httpsAgent);
    }, "resetContext"),
    createResponse = __name((incomingMessage, decode, onError) => {
      let {
          statusCode: statusCode,
          statusMessage: statusMessage,
          httpVersion: httpVersion,
          httpVersionMajor: httpVersionMajor,
          httpVersionMinor: httpVersionMinor,
          headers: headers
        } = incomingMessage,
        readable = decode ? decodeStream(statusCode, headers, incomingMessage, onError) : incomingMessage;
      return {
        statusCode: statusCode,
        statusText: statusMessage,
        httpVersion: httpVersion,
        httpVersionMajor: httpVersionMajor,
        httpVersionMinor: httpVersionMinor,
        headers: headers,
        readable: readable,
        decoded: !!(decode && readable !== incomingMessage)
      };
    }, "createResponse"),
    h1Request = __name(async (ctx, url, options) => {
      let {
          request: request
        } = url.protocol === "https:" ? https : http,
        agent = getAgent(ctx, url.protocol),
        opts = {
          ...options,
          agent: agent
        },
        {
          socket: socket,
          body: body
        } = opts;
      return socket && (delete opts.socket, socket.assigned || (socket.assigned = !0, agent ? opts.agent = new Proxy(agent, {
        get: (target, property) => property === "createConnection" && !socket.inUse ? (_connectOptions, cb) => {
          debug(`agent reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, cb(null, socket);
        } : target[property]
      }) : opts.createConnection = (_connectOptions, cb) => {
        debug(`reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, cb(null, socket);
      })), new Promise((resolve, reject) => {
        debug(`${opts.method} ${url.href}`);
        let req,
          {
            signal: signal
          } = opts,
          onAbortSignal = __name(() => {
            signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), reject(new RequestAbortedError()), req && req.abort();
          }, "onAbortSignal");
        if (signal) {
          if (signal.aborted) {
            reject(new RequestAbortedError());
            return;
          }
          signal.addEventListener("abort", onAbortSignal);
        }
        req = request(url, opts), req.once("response", res => {
          signal && signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), resolve(createResponse(res, opts.decode, reject));
        }), req.once("error", err => {
          signal && signal.removeEventListener("abort", onAbortSignal), socket && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy()), req.aborted || (debug(`${opts.method} ${url.href} failed with: ${err.message}`), req.abort(), reject(err));
        }), body instanceof Readable ? body.pipe(req) : (body && req.write(body), req.end());
      });
    }, "h1Request");
  module.exports = {
    request: h1Request,
    setupContext: setupContext,
    resetContext: resetContext
  };
});
var require_h2 = __commonJSMin((exports, module) => {
  "use strict";

  var {
      connect: connect,
      constants: constants
    } = require("http2"),
    {
      Readable: Readable
    } = require("stream"),
    debug = Gu()("helix-fetch:h2"),
    {
      RequestAbortedError: RequestAbortedError
    } = X8(),
    {
      decodeStream: decodeStream
    } = gd(),
    {
      NGHTTP2_CANCEL: NGHTTP2_CANCEL
    } = constants,
    SESSION_IDLE_TIMEOUT = 5 * 60 * 1e3,
    PUSHED_STREAM_IDLE_TIMEOUT = 5e3,
    setupContext = __name(ctx => {
      ctx.h2 = {
        sessionCache: {}
      };
    }, "setupContext"),
    resetContext = __name(async ({
      h2: h2
    }) => Promise.all(Object.values(h2.sessionCache).map(session => new Promise(resolve => {
      session.on("close", resolve), debug(`resetContext: destroying session (socket #${session.socket && session.socket.id}, ${session.socket && session.socket.servername})`), session.destroy();
    }))), "resetContext"),
    createResponse = __name((headers, clientHttp2Stream, decode, onError = () => {}) => {
      let hdrs = {
          ...headers
        },
        statusCode = hdrs[":status"];
      delete hdrs[":status"];
      let readable = decode ? decodeStream(statusCode, headers, clientHttp2Stream, onError) : clientHttp2Stream;
      return {
        statusCode: statusCode,
        statusText: "",
        httpVersion: "2.0",
        httpVersionMajor: 2,
        httpVersionMinor: 0,
        headers: hdrs,
        readable: readable,
        decoded: !!(decode && readable !== clientHttp2Stream)
      };
    }, "createResponse"),
    handlePush = __name((ctx, origin, decode, pushedStream, requestHeaders, flags) => {
      let {
          options: {
            h2: {
              pushPromiseHandler: pushPromiseHandler,
              pushHandler: pushHandler,
              pushedStreamIdleTimeout = PUSHED_STREAM_IDLE_TIMEOUT
            }
          }
        } = ctx,
        path = requestHeaders[":path"],
        url = `${origin}${path}`;
      debug(`received PUSH_PROMISE: ${url}, stream #${pushedStream.id}, headers: ${JSON.stringify(requestHeaders)}, flags: ${flags}`), pushPromiseHandler && pushPromiseHandler(url, requestHeaders, __name(() => {
        pushedStream.close(NGHTTP2_CANCEL);
      }, "rejectPush")), pushedStream.on("push", (responseHeaders, flgs) => {
        debug(`received push headers for ${origin}${path}, stream #${pushedStream.id}, headers: ${JSON.stringify(responseHeaders)}, flags: ${flgs}`), pushedStream.setTimeout(pushedStreamIdleTimeout, () => {
          debug(`closing pushed stream #${pushedStream.id} after ${pushedStreamIdleTimeout} ms of inactivity`), pushedStream.close(NGHTTP2_CANCEL);
        }), pushHandler && pushHandler(url, requestHeaders, createResponse(responseHeaders, pushedStream, decode));
      }), pushedStream.on("aborted", () => {
        debug(`pushed stream #${pushedStream.id} aborted`);
      }), pushedStream.on("error", err => {
        debug(`pushed stream #${pushedStream.id} encountered error: ${err}`);
      }), pushedStream.on("frameError", (type, code, id) => {
        debug(`pushed stream #${pushedStream.id} encountered frameError: type: ${type}, code: ${code}, id: ${id}`);
      });
    }, "handlePush"),
    request = __name(async (ctx, url, options) => {
      let {
          origin: origin,
          pathname: pathname,
          search: search,
          hash: hash
        } = url,
        path = `${pathname}${search}${hash}`,
        {
          options: {
            h2: ctxOpts = {}
          },
          h2: {
            sessionCache: sessionCache
          }
        } = ctx,
        {
          idleSessionTimeout = SESSION_IDLE_TIMEOUT,
          pushPromiseHandler: pushPromiseHandler,
          pushHandler: pushHandler
        } = ctxOpts,
        opts = {
          ...options
        },
        {
          method: method,
          headers: headers,
          socket: socket,
          body: body,
          decode: decode
        } = opts;
      return socket && delete opts.socket, headers.host && (headers[":authority"] = headers.host, delete headers.host), new Promise((resolve, reject) => {
        let session = sessionCache[origin];
        if (!session || session.closed || session.destroyed) {
          let rejectUnauthorized = !(ctx.options.rejectUnauthorized === !1 || ctxOpts.rejectUnauthorized === !1),
            connectOptions = {
              ...ctxOpts,
              rejectUnauthorized: rejectUnauthorized
            };
          socket && !socket.inUse && (connectOptions.createConnection = () => (debug(`reusing socket #${socket.id} (${socket.servername})`), socket.inUse = !0, socket)), session = connect(origin, {
            ...connectOptions,
            settings: {
              enablePush: !!(pushPromiseHandler || pushHandler)
            }
          }), session.setMaxListeners(1e3), session.setTimeout(idleSessionTimeout, () => {
            debug(`closing session ${origin} after ${idleSessionTimeout} ms of inactivity`), session.close();
          }), session.once("connect", () => {
            debug(`session ${origin} established`), debug(`caching session ${origin}`), sessionCache[origin] = session;
          }), session.on("localSettings", settings => {
            debug(`session ${origin} localSettings: ${JSON.stringify(settings)}`);
          }), session.on("remoteSettings", settings => {
            debug(`session ${origin} remoteSettings: ${JSON.stringify(settings)}`);
          }), session.once("close", () => {
            debug(`session ${origin} closed`), sessionCache[origin] === session && (debug(`discarding cached session ${origin}`), delete sessionCache[origin]);
          }), session.once("error", err => {
            debug(`session ${origin} encountered error: ${err}`), sessionCache[origin] === session && (debug(`discarding cached session ${origin}`), delete sessionCache[origin]);
          }), session.on("frameError", (type, code, id) => {
            debug(`session ${origin} encountered frameError: type: ${type}, code: ${code}, id: ${id}`);
          }), session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
            debug(`session ${origin} received GOAWAY frame: errorCode: ${errorCode}, lastStreamID: ${lastStreamID}, opaqueData: ${opaqueData ? opaqueData.toString() : void 0}`);
          }), session.on("stream", (stream, hdrs, flags) => {
            handlePush(ctx, origin, decode, stream, hdrs, flags);
          });
        } else socket && socket.id !== session.socket.id && !socket.inUse && (debug(`discarding redundant socket used for ALPN: #${socket.id} ${socket.servername}`), socket.destroy());
        debug(`${method} ${url.host}${path}`);
        let req,
          {
            signal: signal
          } = opts,
          onAbortSignal = __name(() => {
            signal.removeEventListener("abort", onAbortSignal), reject(new RequestAbortedError()), req && req.close(NGHTTP2_CANCEL);
          }, "onAbortSignal");
        if (signal) {
          if (signal.aborted) {
            reject(new RequestAbortedError());
            return;
          }
          signal.addEventListener("abort", onAbortSignal);
        }
        let onSessionError = __name(err => {
          debug(`session ${origin} encountered error during ${opts.method} ${url.href}: ${err}`), reject(err);
        }, "onSessionError");
        session.once("error", onSessionError), req = session.request({
          ":method": method,
          ":path": path,
          ...headers
        }), req.once("response", hdrs => {
          session.off("error", onSessionError), signal && signal.removeEventListener("abort", onAbortSignal), resolve(createResponse(hdrs, req, opts.decode, reject));
        }), req.once("error", err => {
          session.off("error", onSessionError), signal && signal.removeEventListener("abort", onAbortSignal), req.rstCode !== NGHTTP2_CANCEL && (debug(`${opts.method} ${url.href} failed with: ${err.message}`), req.close(NGHTTP2_CANCEL), reject(err));
        }), req.once("frameError", (type, code, id) => {
          session.off("error", onSessionError), debug(`encountered frameError during ${opts.method} ${url.href}: type: ${type}, code: ${code}, id: ${id}`);
        }), req.on("push", (hdrs, flags) => {
          debug(`received 'push' event: headers: ${JSON.stringify(hdrs)}, flags: ${flags}`);
        }), body instanceof Readable ? body.pipe(req) : (body && req.write(body), req.end());
      });
    }, "request");
  module.exports = {
    request: request,
    setupContext: setupContext,
    resetContext: resetContext
  };
});
var require_lock = __commonJSMin((exports, module) => {
  "use strict";

  var {
      EventEmitter: EventEmitter
    } = require("events"),
    lock = __name(() => {
      let locked = {},
        ee = new EventEmitter();
      return ee.setMaxListeners(0), {
        acquire: key => new Promise(resolve => {
          if (!locked[key]) {
            locked[key] = !0, resolve();
            return;
          }
          let tryAcquire = __name(value => {
            locked[key] || (locked[key] = !0, ee.removeListener(key, tryAcquire), resolve(value));
          }, "tryAcquire");
          ee.on(key, tryAcquire);
        }),
        release: (key, value) => {
          Reflect.deleteProperty(locked, key), setImmediate(() => ee.emit(key, value));
        }
      };
    }, "lock");
  module.exports = lock;
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "@adobe/helix-fetch",
    version: "3.1.1",
    description: "Light-weight Fetch implementation transparently supporting both HTTP/1(.1) and HTTP/2",
    main: "src/index.js",
    scripts: {
      test: "nyc mocha",
      lint: "./node_modules/.bin/eslint .",
      "semantic-release": "semantic-release"
    },
    mocha: {
      timeout: "5000",
      recursive: "true",
      reporter: "mocha-multi-reporters",
      "reporter-options": "configFile=.mocha-multi.json"
    },
    engines: {
      node: ">=12.0"
    },
    types: "src/index.d.ts",
    exports: {
      import: "./src/index.mjs",
      require: "./src/index.js"
    },
    repository: {
      type: "git",
      url: "https://github.com/adobe/helix-fetch"
    },
    author: "",
    license: "Apache-2.0",
    bugs: {
      url: "https://github.com/adobe/helix-fetch/issues"
    },
    homepage: "https://github.com/adobe/helix-fetch#readme",
    keywords: ["fetch", "whatwg", "Fetch API", "http", "https", "http2", "h2", "promise", "async", "request", "RFC 7234", "7234", "caching", "cache"],
    dependencies: {
      debug: "4.3.4",
      "http-cache-semantics": "^4.1.1",
      "lru-cache": "7.13.1"
    },
    devDependencies: {
      "@adobe/eslint-config-helix": "1.3.2",
      "@semantic-release/changelog": "6.0.1",
      "@semantic-release/git": "10.0.1",
      chai: "4.3.6",
      "chai-as-promised": "7.1.1",
      "chai-bytes": "0.1.2",
      "chai-iterator": "3.0.2",
      eslint: "8.21.0",
      "eslint-plugin-header": "3.1.1",
      "eslint-plugin-import": "2.26.0",
      "formdata-node": "4.3.3",
      "lint-staged": "13.0.3",
      mocha: "10.0.0",
      "mocha-multi-reporters": "1.5.1",
      nock: "13.2.9",
      nyc: "15.1.0",
      "parse-cache-control": "1.0.1",
      pem: "1.14.6",
      proxy: "^1.0.2",
      "semantic-release": "19.0.3",
      sinon: "14.0.0",
      "stream-buffers": "3.0.2",
      tunnel: "^0.0.6"
    },
    "lint-staged": {
      "*.js": "eslint"
    },
    config: {
      commitizen: {
        path: "node_modules/cz-conventional-changelog"
      },
      ghooks: {
        "pre-commit": "npx lint-staged"
      }
    }
  };
});
var require_request = __commonJSMin((exports, module) => {
  "use strict";

  var {
      Readable: Readable
    } = require("stream"),
    tls = require("tls"),
    {
      types: {
        isAnyArrayBuffer: isAnyArrayBuffer
      }
    } = require("util"),
    LRU = ZT(),
    debug = Gu()("helix-fetch:core"),
    {
      RequestAbortedError: RequestAbortedError
    } = X8(),
    h1 = JF(),
    h2 = nU(),
    lock = sU(),
    {
      isPlainObject: isPlainObject
    } = gd(),
    {
      isFormData: isFormData,
      FormDataSerializer: FormDataSerializer
    } = Y3(),
    {
      version: version
    } = oU(),
    ALPN_HTTP2 = "h2",
    ALPN_HTTP2C = "h2c",
    ALPN_HTTP1_0 = "http/1.0",
    ALPN_HTTP1_1 = "http/1.1",
    ALPN_CACHE_SIZE = 100,
    ALPN_CACHE_TTL = 60 * 60 * 1e3,
    ALPN_PROTOCOLS = [ALPN_HTTP2, ALPN_HTTP1_1, ALPN_HTTP1_0],
    DEFAULT_USER_AGENT = `helix-fetch/${version}`,
    DEFAULT_OPTIONS = {
      method: "GET",
      compress: !0,
      decode: !0
    },
    socketIdCounter = 0,
    connectionLock = lock(),
    connectTLS = __name((url, options) => new Promise((resolve, reject) => {
      let {
          signal: signal
        } = options,
        socket,
        onAbortSignal = __name(() => {
          signal.removeEventListener("abort", onAbortSignal);
          let err = new RequestAbortedError();
          reject(err), socket && socket.destroy(err);
        }, "onAbortSignal");
      if (signal) {
        if (signal.aborted) {
          reject(new RequestAbortedError());
          return;
        }
        signal.addEventListener("abort", onAbortSignal);
      }
      let port = +url.port || 443,
        onError = __name(err => {
          signal && signal.removeEventListener("abort", onAbortSignal), err instanceof RequestAbortedError || (debug(`connecting to ${url.hostname}:${port} failed with: ${err.message}`), reject(err));
        }, "onError");
      socket = tls.connect(port, url.hostname, options), socket.once("secureConnect", () => {
        signal && signal.removeEventListener("abort", onAbortSignal), socket.off("error", onError), socketIdCounter += 1, socket.id = socketIdCounter, socket.secureConnecting = !1, debug(`established TLS connection: #${socket.id} (${socket.servername})`), resolve(socket);
      }), socket.once("error", onError);
    }), "connectTLS"),
    connect = __name(async (url, options) => {
      let socket = await connectionLock.acquire(url.origin);
      try {
        return socket || (socket = await connectTLS(url, options)), socket;
      } finally {
        connectionLock.release(url.origin, socket);
      }
    }, "connect"),
    determineProtocol = __name(async (ctx, url, signal) => {
      let origin = `${url.protocol}//${url.host}`,
        protocol = ctx.alpnCache.get(origin);
      if (protocol) return {
        protocol: protocol
      };
      switch (url.protocol) {
        case "http:":
          return protocol = ALPN_HTTP1_1, ctx.alpnCache.set(origin, protocol), {
            protocol: protocol
          };
        case "http2:":
          return protocol = ALPN_HTTP2C, ctx.alpnCache.set(origin, protocol), {
            protocol: protocol
          };
        case "https:":
          break;
        default:
          throw new TypeError(`unsupported protocol: ${url.protocol}`);
      }
      let {
          options: {
            rejectUnauthorized: _rejectUnauthorized,
            h1: h1Opts = {},
            h2: h2Opts = {}
          }
        } = ctx,
        rejectUnauthorized = !(_rejectUnauthorized === !1 || h1Opts.rejectUnauthorized === !1 || h2Opts.rejectUnauthorized === !1),
        connectOptions = {
          servername: url.hostname,
          ALPNProtocols: ctx.alpnProtocols,
          signal: signal,
          rejectUnauthorized: rejectUnauthorized
        };
      ctx.options.ca && (connectOptions.ca = ctx.options.ca);
      let socket = await connect(url, connectOptions);
      return protocol = socket.alpnProtocol, protocol || (protocol = ALPN_HTTP1_1), ctx.alpnCache.set(origin, protocol), {
        protocol: protocol,
        socket: socket
      };
    }, "determineProtocol"),
    sanitizeHeaders = __name(headers => {
      let result = {};
      return Object.keys(headers).forEach(name => {
        result[name.toLowerCase()] = headers[name];
      }), result;
    }, "sanitizeHeaders"),
    getProtocolAndSocketFromFactory = __name(async (socketFactory, url, requestOptions, alpns) => {
      let isSecure = url.protocol === "https:",
        port;
      url.port ? port = url.port : isSecure ? port = 443 : port = 80;
      let options = {
          ...requestOptions,
          host: url.host,
          hostname: url.hostname,
          port: port
        },
        socket = await socketFactory(options);
      if (isSecure) {
        let secOpts = {
          ...options,
          ALPNProtocols: alpns
        };
        secOpts.socket = socket, secOpts.servername = options.host;
        let secureSocket = await connectTLS(url, secOpts);
        return {
          protocol: secureSocket.alpnProtocol || ALPN_HTTP1_1,
          socket: secureSocket
        };
      }
      return {
        protocol: socket.alpnProtocol || ALPN_HTTP1_1,
        socket: socket
      };
    }, "getProtocolAndSocketFromFactory"),
    request = __name(async (ctx, uri, options) => {
      let url = new URL(uri),
        opts = {
          ...DEFAULT_OPTIONS,
          ...(options || {})
        };
      typeof opts.method == "string" && (opts.method = opts.method.toUpperCase()), opts.headers = sanitizeHeaders(opts.headers || {}), opts.headers.host === void 0 && (opts.headers.host = url.host), ctx.userAgent && opts.headers["user-agent"] === void 0 && (opts.headers["user-agent"] = ctx.userAgent);
      let contentType;
      if (opts.body instanceof URLSearchParams) contentType = "application/x-www-form-urlencoded; charset=utf-8", opts.body = opts.body.toString();else if (isFormData(opts.body)) {
        let fd = new FormDataSerializer(opts.body);
        contentType = fd.contentType(), opts.body = fd.stream(), opts.headers["transfer-encoding"] === void 0 && opts.headers["content-length"] === void 0 && (opts.headers["content-length"] = String(fd.length()));
      } else typeof opts.body == "string" || opts.body instanceof String ? contentType = "text/plain; charset=utf-8" : isPlainObject(opts.body) ? (opts.body = JSON.stringify(opts.body), contentType = "application/json") : isAnyArrayBuffer(opts.body) && (opts.body = Buffer.from(opts.body));
      opts.headers["content-type"] === void 0 && contentType !== void 0 && (opts.headers["content-type"] = contentType), opts.body != null && (opts.body instanceof Readable || (!(typeof opts.body == "string" || opts.body instanceof String) && !Buffer.isBuffer(opts.body) && (opts.body = String(opts.body)), opts.headers["transfer-encoding"] === void 0 && opts.headers["content-length"] === void 0 && (opts.headers["content-length"] = String(Buffer.isBuffer(opts.body) ? opts.body.length : Buffer.byteLength(opts.body, "utf-8"))))), opts.headers.accept === void 0 && (opts.headers.accept = "*/*"), opts.body == null && ["POST", "PUT"].includes(opts.method) && (opts.headers["content-length"] = "0"), opts.compress && opts.headers["accept-encoding"] === void 0 && (opts.headers["accept-encoding"] = "gzip,deflate,br");
      let {
          signal: signal
        } = opts,
        {
          protocol: protocol,
          socket = null
        } = ctx.socketFactory ? await getProtocolAndSocketFromFactory(ctx.socketFactory, url, opts, ctx.alpnProtocols) : await determineProtocol(ctx, url, signal);
      switch (debug(`${url.host} -> ${protocol}`), protocol) {
        case ALPN_HTTP2:
          try {
            return await h2.request(ctx, url, socket ? {
              ...opts,
              socket: socket
            } : opts);
          } catch (err) {
            let {
              code: code,
              message: message
            } = err;
            throw code === "ERR_HTTP2_ERROR" && message === "Protocol error" && ctx.alpnCache.delete(`${url.protocol}//${url.host}`), err;
          }
        case ALPN_HTTP2C:
          return h2.request(ctx, new URL(`http://${url.host}${url.pathname}${url.hash}${url.search}`), socket ? {
            ...opts,
            socket: socket
          } : opts);
        case ALPN_HTTP1_0:
        case ALPN_HTTP1_1:
          return h1.request(ctx, url, socket ? {
            ...opts,
            socket: socket
          } : opts);
        default:
          throw new TypeError(`unsupported protocol: ${protocol}`);
      }
    }, "request"),
    resetContext = __name(async ctx => (ctx.alpnCache.clear(), Promise.all([h1.resetContext(ctx), h2.resetContext(ctx)])), "resetContext"),
    setupContext = __name(ctx => {
      let {
        options: {
          alpnProtocols = ALPN_PROTOCOLS,
          alpnCacheTTL = ALPN_CACHE_TTL,
          alpnCacheSize = ALPN_CACHE_SIZE,
          userAgent = DEFAULT_USER_AGENT,
          socketFactory: socketFactory
        }
      } = ctx;
      ctx.alpnProtocols = alpnProtocols, ctx.alpnCache = new LRU({
        max: alpnCacheSize,
        ttl: alpnCacheTTL
      }), ctx.userAgent = userAgent, ctx.socketFactory = socketFactory, h1.setupContext(ctx), h2.setupContext(ctx);
    }, "setupContext");
  module.exports = {
    request: request,
    setupContext: setupContext,
    resetContext: resetContext,
    RequestAbortedError: RequestAbortedError,
    ALPN_HTTP2: ALPN_HTTP2,
    ALPN_HTTP2C: ALPN_HTTP2C,
    ALPN_HTTP1_1: ALPN_HTTP1_1,
    ALPN_HTTP1_0: ALPN_HTTP1_0
  };
});
var require_core = __commonJSMin((exports, module) => {
  "use strict";

  var debug = Gu()("helix-fetch:core"),
    {
      request: request,
      setupContext: setupContext,
      resetContext: resetContext,
      RequestAbortedError: RequestAbortedError,
      ALPN_HTTP2: ALPN_HTTP2,
      ALPN_HTTP2C: ALPN_HTTP2C,
      ALPN_HTTP1_1: ALPN_HTTP1_1,
      ALPN_HTTP1_0: ALPN_HTTP1_0
    } = fU(),
    RequestContext = class _RequestContext {
      static {
        __name(this, "RequestContext");
      }
      constructor(options) {
        this.options = {
          ...(options || {})
        }, setupContext(this);
      }
      api() {
        return {
          request: async (url, options) => this.request(url, options),
          context: (options = {}) => new _RequestContext(options).api(),
          setCA: ca => this.setCA(ca),
          reset: async () => this.reset(),
          RequestAbortedError: RequestAbortedError,
          ALPN_HTTP2: ALPN_HTTP2,
          ALPN_HTTP2C: ALPN_HTTP2C,
          ALPN_HTTP1_1: ALPN_HTTP1_1,
          ALPN_HTTP1_0: ALPN_HTTP1_0
        };
      }
      async request(url, options) {
        return request(this, url, options);
      }
      setCA(ca) {
        this.options.ca = ca;
      }
      async reset() {
        return debug("resetting context"), resetContext(this);
      }
    };
  module.exports = new RequestContext().api();
});
var require_fetch = __commonJSMin((exports, module) => {
  "use strict";

  var {
      EventEmitter: EventEmitter
    } = require("events"),
    {
      Readable: Readable
    } = require("stream"),
    debug = Gu()("helix-fetch"),
    LRU = ZT(),
    {
      Body: Body
    } = H8(),
    {
      Headers: Headers
    } = $h(),
    {
      Request: Request
    } = BF(),
    {
      Response: Response
    } = sS(),
    {
      FetchBaseError: FetchBaseError,
      FetchError: FetchError,
      AbortError: AbortError
    } = tS(),
    {
      AbortController: AbortController,
      AbortSignal: AbortSignal,
      TimeoutSignal: TimeoutSignal
    } = rS(),
    CachePolicy = VF(),
    {
      cacheableResponse: cacheableResponse
    } = WF(),
    {
      sizeof: sizeof
    } = gd(),
    {
      isFormData: isFormData
    } = Y3(),
    {
      context: context,
      RequestAbortedError: RequestAbortedError
    } = pU(),
    CACHEABLE_METHODS = ["GET", "HEAD"],
    DEFAULT_MAX_CACHE_ITEMS = 500,
    DEFAULT_MAX_CACHE_SIZE = 100 * 1024 * 1024,
    PUSH_EVENT = "push",
    fetch = __name(async (ctx, url, options) => {
      let {
          request: request
        } = ctx.context,
        req = url instanceof Request && typeof options > "u" ? url : new Request(url, options),
        {
          method: method,
          body: body,
          signal: signal,
          compress: compress,
          decode: decode,
          follow: follow,
          redirect: redirect,
          init: {
            body: initBody
          }
        } = req,
        coreResp;
      if (signal && signal.aborted) {
        let err = new AbortError("The operation was aborted.");
        throw req.init.body instanceof Readable && req.init.body.destroy(err), err;
      }
      try {
        coreResp = await request(req.url, {
          ...options,
          method: method,
          headers: req.headers.plain(),
          body: initBody && !(initBody instanceof Readable) && !isFormData(initBody) ? initBody : body,
          compress: compress,
          decode: decode,
          follow: follow,
          redirect: redirect,
          signal: signal
        });
      } catch (err) {
        throw initBody instanceof Readable && initBody.destroy(err), err instanceof TypeError ? err : err instanceof RequestAbortedError ? new AbortError("The operation was aborted.") : new FetchError(err.message, "system", err);
      }
      let abortHandler = __name(() => {
        signal.removeEventListener("abort", abortHandler);
        let err = new AbortError("The operation was aborted.");
        req.init.body instanceof Readable && req.init.body.destroy(err), coreResp.readable.emit("error", err);
      }, "abortHandler");
      signal && signal.addEventListener("abort", abortHandler);
      let {
        statusCode: statusCode,
        statusText: statusText,
        httpVersion: httpVersion,
        headers: headers,
        readable: readable,
        decoded: decoded
      } = coreResp;
      if ([301, 302, 303, 307, 308].includes(statusCode)) {
        let {
            location: location
          } = headers,
          locationURL = location == null ? null : new URL(location, req.url);
        switch (req.redirect) {
          case "manual":
            break;
          case "error":
            throw signal && signal.removeEventListener("abort", abortHandler), new FetchError(`uri requested responds with a redirect, redirect mode is set to 'error': ${req.url}`, "no-redirect");
          case "follow":
            {
              if (locationURL === null) break;
              if (req.counter >= req.follow) throw signal && signal.removeEventListener("abort", abortHandler), new FetchError(`maximum redirect reached at: ${req.url}`, "max-redirect");
              let requestOptions = {
                headers: new Headers(req.headers),
                follow: req.follow,
                compress: req.compress,
                decode: req.decode,
                counter: req.counter + 1,
                method: req.method,
                body: req.body,
                signal: req.signal
              };
              if (statusCode !== 303 && req.body && req.init.body instanceof Readable) throw signal && signal.removeEventListener("abort", abortHandler), new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect");
              return (statusCode === 303 || (statusCode === 301 || statusCode === 302) && req.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), signal && signal.removeEventListener("abort", abortHandler), fetch(ctx, new Request(locationURL, requestOptions));
            }
          default:
        }
      }
      return signal && (readable.once("end", () => {
        signal.removeEventListener("abort", abortHandler);
      }), readable.once("error", () => {
        signal.removeEventListener("abort", abortHandler);
      })), new Response(readable, {
        url: req.url,
        status: statusCode,
        statusText: statusText,
        headers: headers,
        httpVersion: httpVersion,
        decoded: decoded,
        counter: req.counter
      });
    }, "fetch"),
    cacheResponse = __name(async (ctx, request, response) => {
      if (ctx.options.maxCacheSize === 0 || !CACHEABLE_METHODS.includes(request.method)) return response;
      let policy = new CachePolicy(request, response, {
        shared: !1
      });
      if (policy.storable()) {
        let cacheable = await cacheableResponse(response);
        return ctx.cache.set(request.url, {
          policy: policy,
          response: cacheable
        }, policy.timeToLive()), cacheable;
      } else return response;
    }, "cacheResponse"),
    cachingFetch = __name(async (ctx, url, options) => {
      let req = new Request(url, options);
      if (ctx.options.maxCacheSize !== 0 && CACHEABLE_METHODS.includes(req.method) && !["no-store", "reload"].includes(req.cache)) {
        let {
          policy: policy,
          response: response
        } = ctx.cache.get(req.url) || {};
        if (policy && policy.satisfiesWithoutRevalidation(req)) {
          response.headers = new Headers(policy.responseHeaders(response));
          let resp = response.clone();
          return resp.fromCache = !0, resp;
        }
      }
      let resp = await fetch(ctx, req);
      return req.cache !== "no-store" ? cacheResponse(ctx, req, resp) : resp;
    }, "cachingFetch"),
    createUrl = __name((url, qs = {}) => {
      let urlWithQuery = new URL(url);
      if (typeof qs != "object" || Array.isArray(qs)) throw new TypeError("qs: object expected");
      return Object.entries(qs).forEach(([k, v]) => {
        Array.isArray(v) ? v.forEach(entry => urlWithQuery.searchParams.append(k, entry)) : urlWithQuery.searchParams.append(k, v);
      }), urlWithQuery.href;
    }, "createUrl"),
    timeoutSignal = __name(ms => new TimeoutSignal(ms), "timeoutSignal"),
    FetchContext = class _FetchContext {
      static {
        __name(this, "FetchContext");
      }
      constructor(options) {
        this.options = {
          ...options
        };
        let {
            maxCacheSize: maxCacheSize
          } = this.options,
          maxSize = typeof maxCacheSize == "number" && maxCacheSize >= 0 ? maxCacheSize : DEFAULT_MAX_CACHE_SIZE,
          max = DEFAULT_MAX_CACHE_ITEMS;
        maxSize === 0 && (maxSize = 1, max = 1);
        let sizeCalculation = __name(({
          response: response
        }, _) => sizeof(response), "sizeCalculation");
        this.cache = new LRU({
          max: max,
          maxSize: maxSize,
          sizeCalculation: sizeCalculation
        }), this.eventEmitter = new EventEmitter(), this.options.h2 = this.options.h2 || {}, typeof this.options.h2.enablePush > "u" && (this.options.h2.enablePush = !0);
        let {
          enablePush: enablePush
        } = this.options.h2;
        enablePush && (this.options.h2.pushPromiseHandler = (url, headers, reject) => {
          let hdrs = {
            ...headers
          };
          Object.keys(hdrs).filter(name => name.startsWith(":")).forEach(name => delete hdrs[name]), this.pushPromiseHandler(url, hdrs, reject);
        }, this.options.h2.pushHandler = (url, reqHeaders, response) => {
          let hdrs = {
            ...reqHeaders
          };
          Object.keys(hdrs).filter(name => name.startsWith(":")).forEach(name => delete hdrs[name]);
          let {
            statusCode: statusCode,
            statusText: statusText,
            httpVersion: httpVersion,
            headers: headers,
            readable: readable,
            decoded: decoded
          } = response;
          this.pushHandler(url, hdrs, new Response(readable, {
            url: url,
            status: statusCode,
            statusText: statusText,
            headers: headers,
            httpVersion: httpVersion,
            decoded: decoded
          }));
        }), this.context = context(this.options);
      }
      api() {
        return {
          fetch: async (url, options) => this.fetch(url, options),
          Body: Body,
          Headers: Headers,
          Request: Request,
          Response: Response,
          AbortController: AbortController,
          AbortSignal: AbortSignal,
          FetchBaseError: FetchBaseError,
          FetchError: FetchError,
          AbortError: AbortError,
          context: (options = {}) => new _FetchContext(options).api(),
          setCA: ca => this.setCA(ca),
          noCache: (options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0
          }).api(),
          h1: (options = {}) => new _FetchContext({
            ...options,
            alpnProtocols: [this.context.ALPN_HTTP1_1]
          }).api(),
          keepAlive: (options = {}) => new _FetchContext({
            ...options,
            alpnProtocols: [this.context.ALPN_HTTP1_1],
            h1: {
              keepAlive: !0
            }
          }).api(),
          h1NoCache: (options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0,
            alpnProtocols: [this.context.ALPN_HTTP1_1]
          }).api(),
          keepAliveNoCache: (options = {}) => new _FetchContext({
            ...options,
            maxCacheSize: 0,
            alpnProtocols: [this.context.ALPN_HTTP1_1],
            h1: {
              keepAlive: !0
            }
          }).api(),
          reset: async () => this.context.reset(),
          onPush: fn => this.onPush(fn),
          offPush: fn => this.offPush(fn),
          createUrl: createUrl,
          timeoutSignal: timeoutSignal,
          clearCache: () => this.clearCache(),
          cacheStats: () => this.cacheStats(),
          ALPN_HTTP2: this.context.ALPN_HTTP2,
          ALPN_HTTP2C: this.context.ALPN_HTTP2C,
          ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,
          ALPN_HTTP1_0: this.context.ALPN_HTTP1_0
        };
      }
      async fetch(url, options) {
        return cachingFetch(this, url, options);
      }
      setCA(ca) {
        this.options.ca = ca, this.context.setCA(ca);
      }
      onPush(fn) {
        return this.eventEmitter.on(PUSH_EVENT, fn);
      }
      offPush(fn) {
        return this.eventEmitter.off(PUSH_EVENT, fn);
      }
      clearCache() {
        this.cache.clear();
      }
      cacheStats() {
        return {
          size: this.cache.calculatedSize,
          count: this.cache.size
        };
      }
      pushPromiseHandler(url, headers, reject) {
        debug(`received server push promise: ${url}, headers: ${JSON.stringify(headers)}`);
        let req = new Request(url, {
            headers: headers
          }),
          {
            policy: policy
          } = this.cache.get(url) || {};
        policy && policy.satisfiesWithoutRevalidation(req) && (debug(`already cached, reject push promise: ${url}, headers: ${JSON.stringify(headers)}`), reject());
      }
      async pushHandler(url, headers, response) {
        debug(`caching resource pushed by server: ${url}, reqHeaders: ${JSON.stringify(headers)}, status: ${response.status}, respHeaders: ${JSON.stringify(response.headers)}`);
        let cachedResponse = await cacheResponse(this, new Request(url, {
          headers: headers
        }), response);
        this.eventEmitter.emit(PUSH_EVENT, url, cachedResponse);
      }
    };
  module.exports = new FetchContext().api();
});
var require_src = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = yU();
});
var CS = T(ma => {
  "use strict";

  var bS = ma && ma.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    ES = ma && ma.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    };
  Object.defineProperty(ma, "__esModule", {
    value: !0
  });
  ma.getShallowFileSize = ma.getShallowDirectorySizeSync = ma.getShallowDirectorySize = ma.confirmDirExists = ma.unlinkAsync = ma.readdirAsync = ma.readFileAsync = ma.writeFileAsync = ma.appendFileAsync = ma.accessAsync = ma.mkdirAsync = ma.lstatAsync = ma.statAsync = void 0;
  var fs = require("fs"),
    path = require("path"),
    util_1 = require("util");
  exports.statAsync = util_1.promisify(fs.stat);
  exports.lstatAsync = util_1.promisify(fs.lstat);
  exports.mkdirAsync = util_1.promisify(fs.mkdir);
  exports.accessAsync = util_1.promisify(fs.access);
  exports.appendFileAsync = util_1.promisify(fs.appendFile);
  exports.writeFileAsync = util_1.promisify(fs.writeFile);
  exports.readFileAsync = util_1.promisify(fs.readFile);
  exports.readdirAsync = util_1.promisify(fs.readdir);
  exports.unlinkAsync = util_1.promisify(fs.unlink);
  var confirmDirExists = __name(function (directory) {
    return __awaiter(void 0, void 0, void 0, function () {
      var t, r, n;
      return ES(this, function (i) {
        switch (i.label) {
          case 0:
            return i.trys.push([0, 2,, 7]), [4, exports.lstatAsync(directory)];
          case 1:
            if (stats = _a.sent(), !stats.isDirectory()) throw new Error("Path existed but was not a directory");
            return [3, 7];
          case 2:
            if (r = i.sent(), !(err_1 && err_1.code === "ENOENT")) return [3, 6];
            i.label = 3;
          case 3:
            return i.trys.push([3, 5,, 6]), [4, exports.mkdirAsync(directory)];
          case 4:
            return _a.sent(), [3, 6];
          case 5:
            if (n = i.sent(), mkdirErr_1 && mkdirErr_1.code !== "EEXIST") throw mkdirErr_1;
            return [3, 6];
          case 6:
            return [3, 7];
          case 7:
            return [2];
        }
      });
    });
  }, "confirmDirExists");
  exports.confirmDirExists = confirmDirExists;
  var getShallowDirectorySize = __name(function (directory) {
    return __awaiter(void 0, void 0, void 0, function () {
      var t, r, n, i, s, o;
      return ES(this, function (c) {
        switch (c.label) {
          case 0:
            return [4, exports.readdirAsync(directory)];
          case 1:
            files = _a.sent(), totalSize = 0, n = 0, files_1 = files, c.label = 2;
          case 2:
            return _i < files_1.length ? (file = files_1[_i], [4, exports.statAsync(path.join(directory, file))]) : [3, 5];
          case 3:
            fileStats = _a.sent(), fileStats.isFile() && (totalSize += fileStats.size), c.label = 4;
          case 4:
            return _i++, [3, 2];
          case 5:
            return [2, totalSize];
        }
      });
    });
  }, "getShallowDirectorySize");
  exports.getShallowDirectorySize = getShallowDirectorySize;
  var getShallowDirectorySizeSync = __name(function (directory) {
    for (var files = fs.readdirSync(directory), totalSize = 0, i = 0; i < files.length; i++) totalSize += fs.statSync(path.join(directory, files[i])).size;
    return totalSize;
  }, "getShallowDirectorySizeSync");
  exports.getShallowDirectorySizeSync = getShallowDirectorySizeSync;
  var getShallowFileSize = __name(function (filePath) {
    return __awaiter(void 0, void 0, void 0, function () {
      var t;
      return ES(this, function (r) {
        switch (r.label) {
          case 0:
            return [4, exports.statAsync(filePath)];
          case 1:
            return fileStats = _a.sent(), fileStats.isFile() ? [2, fileStats.size] : [2];
        }
      });
    });
  }, "getShallowFileSize");
  exports.getShallowFileSize = getShallowFileSize;
});
var LU = T((K1, OU) => {
  "use strict";

  var TS = K1 && K1.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    SS = K1 && K1.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    NU = K1 && K1.__spreadArrays || function () {
      for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
      for (var n = Array(e), i = 0, t = 0; t < r; t++) for (var s = arguments[t], o = 0, c = s.length; o < c; o++, i++) n[i] = s[o];
      return n;
    },
    fs = require("fs"),
    os = require("os"),
    path = require("path"),
    FileSystemHelper = CS(),
    InternalAzureLogger = function () {
      function InternalAzureLogger() {
        var _this = this;
        this.TAG = "Logger", this._cleanupTimeOut = 60 * 30 * 1e3, this._tempDir = "", this._logFileName = "", this._fileFullPath = "", this._backUpNameFormat = "", this._logToFile = !1, this._logToConsole = !0;
        var logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION;
        logDestination == "file+console" && (this._logToFile = !0), logDestination == "file" && (this._logToFile = !0, this._logToConsole = !1), this.maxSizeBytes = 5e4, this.maxHistory = 1, this._logFileName = "applicationinsights.log";
        var logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
        logFilePath ? path.isAbsolute(logFilePath) ? this._tempDir = logFilePath : this._tempDir = path.join(process.cwd(), logFilePath) : this._tempDir = path.join(os.tmpdir(), "appInsights-node"), this._fileFullPath = path.join(this._tempDir, this._logFileName), this._backUpNameFormat = "." + this._logFileName, this._logToFile && (InternalAzureLogger._fileCleanupTimer || (InternalAzureLogger._fileCleanupTimer = setInterval(function () {
          _this._fileCleanupTask();
        }, this._cleanupTimeOut), InternalAzureLogger._fileCleanupTimer.unref()));
      }
      return __name(InternalAzureLogger, "InternalAzureLogger"), InternalAzureLogger.prototype.info = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        var args = message ? __spreadArrays([message], optionalParams) : optionalParams;
        this._logToFile && this._storeToDisk(args), this._logToConsole && console.info.apply(console, args);
      }, InternalAzureLogger.prototype.warning = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        var args = message ? __spreadArrays([message], optionalParams) : optionalParams;
        this._logToFile && this._storeToDisk(args), this._logToConsole && console.warn.apply(console, args);
      }, InternalAzureLogger.getInstance = function () {
        return InternalAzureLogger._instance || (InternalAzureLogger._instance = new InternalAzureLogger()), InternalAzureLogger._instance;
      }, InternalAzureLogger.prototype._storeToDisk = function (args) {
        return TS(this, void 0, void 0, function () {
          var r, n, i, s, o, c;
          return SS(this, function (u) {
            switch (u.label) {
              case 0:
                data = args + `\r
`, u.label = 1;
              case 1:
                return u.trys.push([1, 3,, 4]), [4, FileSystemHelper.confirmDirExists(this._tempDir)];
              case 2:
                return _a.sent(), [3, 4];
              case 3:
                return n = u.sent(), console.log(this.TAG, "Failed to create directory for log file: " + (err_1 && err_1.message)), [2];
              case 4:
                return u.trys.push([4, 6,, 11]), [4, FileSystemHelper.accessAsync(this._fileFullPath, fs.constants.F_OK)];
              case 5:
                return _a.sent(), [3, 11];
              case 6:
                i = u.sent(), u.label = 7;
              case 7:
                return u.trys.push([7, 9,, 10]), [4, FileSystemHelper.appendFileAsync(this._fileFullPath, data)];
              case 8:
                return _a.sent(), [2];
              case 9:
                return s = u.sent(), console.log(this.TAG, "Failed to put log into file: " + (appendError_1 && appendError_1.message)), [2];
              case 10:
                return [3, 11];
              case 11:
                return u.trys.push([11, 17,, 18]), [4, FileSystemHelper.getShallowFileSize(this._fileFullPath)];
              case 12:
                return size = _a.sent(), size > this.maxSizeBytes ? [4, this._createBackupFile(data)] : [3, 14];
              case 13:
                return _a.sent(), [3, 16];
              case 14:
                return [4, FileSystemHelper.appendFileAsync(this._fileFullPath, data)];
              case 15:
                _a.sent(), u.label = 16;
              case 16:
                return [3, 18];
              case 17:
                return c = u.sent(), console.log(this.TAG, "Failed to create backup file: " + (err_3 && err_3.message)), [3, 18];
              case 18:
                return [2];
            }
          });
        });
      }, InternalAzureLogger.prototype._createBackupFile = function (data) {
        return TS(this, void 0, void 0, function () {
          var r, n, i;
          return SS(this, function (s) {
            switch (s.label) {
              case 0:
                return s.trys.push([0, 3, 4, 5]), [4, FileSystemHelper.readFileAsync(this._fileFullPath)];
              case 1:
                return buffer = _a.sent(), backupPath = path.join(this._tempDir, new Date().getTime() + "." + this._logFileName), [4, FileSystemHelper.writeFileAsync(backupPath, buffer)];
              case 2:
                return _a.sent(), [3, 5];
              case 3:
                return i = s.sent(), console.log("Failed to generate backup log file", err_4), [3, 5];
              case 4:
                return FileSystemHelper.writeFileAsync(this._fileFullPath, data), [7];
              case 5:
                return [2];
            }
          });
        });
      }, InternalAzureLogger.prototype._fileCleanupTask = function () {
        return TS(this, void 0, void 0, function () {
          var t,
            r,
            n,
            i,
            s,
            o = this;
          return SS(this, function (c) {
            switch (c.label) {
              case 0:
                return c.trys.push([0, 6,, 7]), [4, FileSystemHelper.readdirAsync(this._tempDir)];
              case 1:
                files = _a.sent(), files = files.filter(function (f) {
                  return path.basename(f).indexOf(_this._backUpNameFormat) > -1;
                }), files.sort(function (a, b) {
                  var aCreationDate = new Date(parseInt(a.split(_this._backUpNameFormat)[0])),
                    bCreationDate = new Date(parseInt(b.split(_this._backUpNameFormat)[0]));
                  if (aCreationDate < bCreationDate) return -1;
                  if (aCreationDate >= bCreationDate) return 1;
                }), totalFiles = files.length, i = 0, c.label = 2;
              case 2:
                return i < totalFiles - this.maxHistory ? (pathToDelete = path.join(this._tempDir, files[i]), [4, FileSystemHelper.unlinkAsync(pathToDelete)]) : [3, 5];
              case 3:
                _a.sent(), c.label = 4;
              case 4:
                return i++, [3, 2];
              case 5:
                return [3, 7];
              case 6:
                return s = c.sent(), console.log(this.TAG, "Failed to cleanup log files: " + (err_5 && err_5.message)), [3, 7];
              case 7:
                return [2];
            }
          });
        });
      }, InternalAzureLogger._fileCleanupTimer = null, InternalAzureLogger;
    }();
  module.exports = InternalAzureLogger;
});
var x0 = T((AHe, DU) => {
  "use strict";

  var InternalAzureLogger = LU(),
    Logging = function () {
      function Logging() {}
      return __name(Logging, "Logging"), Logging.info = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        this.enableDebug && InternalAzureLogger.getInstance().info(this.TAG + message, optionalParams);
      }, Logging.warn = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        this.disableWarnings || InternalAzureLogger.getInstance().warning(this.TAG + message, optionalParams);
      }, Logging.enableDebug = !1, Logging.disableWarnings = !1, Logging.TAG = "ApplicationInsights:", Logging;
    }();
  module.exports = Logging;
});
var o6 = T(s6 => {
  "use strict";

  Object.defineProperty(s6, "__esModule", {
    value: !0
  });
  s6.JsonConfig = void 0;
  var fs = require("fs"),
    path = require("path"),
    Logging = x0(),
    ENV_CONFIGURATION_FILE = "APPLICATIONINSIGHTS_CONFIGURATION_FILE",
    ENV_connectionString = "APPLICATIONINSIGHTS_CONNECTION_STRING",
    ENV_azurePrefix = "APPSETTING_",
    ENV_instrumentationKey = "APPINSIGHTS_INSTRUMENTATIONKEY",
    ENV_legacyInstrumentationKey = "APPINSIGHTS_INSTRUMENTATION_KEY",
    ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC",
    ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS",
    ENV_http_proxy = "http_proxy",
    ENV_https_proxy = "https_proxy",
    ENV_noDiagnosticChannel = "APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL",
    ENV_noStatsbeat = "APPLICATION_INSIGHTS_NO_STATSBEAT",
    ENV_noHttpAgentKeepAlive = "APPLICATION_INSIGHTS_NO_HTTP_AGENT_KEEP_ALIVE",
    ENV_noPatchModules = "APPLICATION_INSIGHTS_NO_PATCH_MODULES",
    ENV_webInstrumentationEnable = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_ENABLED",
    ENV_webInstrumentation_connectionString = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_CONNECTION_STRING",
    ENV_webInstrumentation_source = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_SOURCE",
    ENV_webSnippetEnable = "APPLICATIONINSIGHTS_WEB_SNIPPET_ENABLED",
    ENV_webSnippet_connectionString = "APPLICATIONINSIGHTS_WEB_SNIPPET_CONNECTION_STRING",
    JsonConfig = function () {
      function JsonConfig() {
        this.connectionString = process.env[ENV_connectionString], this.instrumentationKey = process.env[ENV_instrumentationKey] || process.env[ENV_azurePrefix + ENV_instrumentationKey] || process.env[ENV_legacyInstrumentationKey] || process.env[ENV_azurePrefix + ENV_legacyInstrumentationKey], !this.connectionString && this.instrumentationKey && Logging.warn("APPINSIGHTS_INSTRUMENTATIONKEY is in path of deprecation, please use APPLICATIONINSIGHTS_CONNECTION_STRING env variable to setup the SDK."), this.disableAllExtendedMetrics = !!process.env[ENV_nativeMetricsDisableAll], this.extendedMetricDisablers = process.env[ENV_nativeMetricsDisablers], this.proxyHttpUrl = process.env[ENV_http_proxy], this.proxyHttpsUrl = process.env[ENV_https_proxy], this.noDiagnosticChannel = !!process.env[ENV_noDiagnosticChannel], this.disableStatsbeat = !!process.env[ENV_noStatsbeat], this.noHttpAgentKeepAlive = !!process.env[ENV_noHttpAgentKeepAlive], this.noPatchModules = process.env[ENV_noPatchModules] || "", this.enableWebInstrumentation = !!process.env[ENV_webInstrumentationEnable] || !!process.env[ENV_webSnippetEnable], this.webInstrumentationSrc = process.env[ENV_webInstrumentation_source] || "", this.webInstrumentationConnectionString = process.env[ENV_webInstrumentation_connectionString] || process.env[ENV_webSnippet_connectionString] || "", this.enableAutoWebSnippetInjection = this.enableWebInstrumentation, this.webSnippetConnectionString = this.webInstrumentationConnectionString, this._loadJsonFile();
      }
      return __name(JsonConfig, "JsonConfig"), JsonConfig.getInstance = function () {
        return JsonConfig._instance || (JsonConfig._instance = new JsonConfig()), JsonConfig._instance;
      }, JsonConfig.prototype._loadJsonFile = function () {
        var jsonString = "",
          contentJsonConfig = process.env.APPLICATIONINSIGHTS_CONFIGURATION_CONTENT;
        if (contentJsonConfig) jsonString = contentJsonConfig;else {
          var configFileName = "applicationinsights.json",
            rootPath = path.join(__dirname, "../../"),
            tempDir = path.join(rootPath, configFileName),
            configFile = process.env[ENV_CONFIGURATION_FILE];
          configFile && (path.isAbsolute(configFile) ? tempDir = configFile : tempDir = path.join(rootPath, configFile));
          try {
            jsonString = fs.readFileSync(tempDir, "utf8");
          } catch (err) {
            Logging.info("Failed to read JSON config file: ", err);
          }
        }
        try {
          var jsonConfig = JSON.parse(jsonString);
          jsonConfig.disableStatsbeat != null && (this.disableStatsbeat = jsonConfig.disableStatsbeat), jsonConfig.disableAllExtendedMetrics != null && (this.disableAllExtendedMetrics = jsonConfig.disableStatsbeat), jsonConfig.noDiagnosticChannel != null && (this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel), jsonConfig.noHttpAgentKeepAlive != null && (this.noHttpAgentKeepAlive = jsonConfig.noHttpAgentKeepAlive), jsonConfig.connectionString != null && (this.connectionString = jsonConfig.connectionString), jsonConfig.extendedMetricDisablers != null && (this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers), jsonConfig.noDiagnosticChannel != null && (this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel), jsonConfig.proxyHttpUrl != null && (this.proxyHttpUrl = jsonConfig.proxyHttpUrl), jsonConfig.proxyHttpsUrl != null && (this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl), jsonConfig.proxyHttpsUrl != null && (this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl), jsonConfig.noPatchModules != null && (this.noPatchModules = jsonConfig.noPatchModules), jsonConfig.enableAutoWebSnippetInjection != null && (this.enableWebInstrumentation = jsonConfig.enableAutoWebSnippetInjection, this.enableAutoWebSnippetInjection = this.enableWebInstrumentation), jsonConfig.enableWebInstrumentation != null && (this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation, this.enableAutoWebSnippetInjection = this.enableWebInstrumentation), jsonConfig.webSnippetConnectionString != null && (this.webInstrumentationConnectionString = jsonConfig.webSnippetConnectionString, this.webSnippetConnectionString = this.webInstrumentationConnectionString), jsonConfig.webInstrumentationConnectionString != null && (this.webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString, this.webSnippetConnectionString = this.webInstrumentationConnectionString), jsonConfig.webInstrumentationConfig != null && (this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig), jsonConfig.webInstrumentationSrc != null && (this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc), jsonConfig.enableLoggerErrorToTrace != null && (this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace), this.endpointUrl = jsonConfig.endpointUrl, this.maxBatchSize = jsonConfig.maxBatchSize, this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs, this.disableAppInsights = jsonConfig.disableAppInsights, this.samplingPercentage = jsonConfig.samplingPercentage, this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs, this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains, this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders, this.distributedTracingMode = jsonConfig.distributedTracingMode, this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers, this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole, this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace, this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions, this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance, this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics, this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics, this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat, this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests, this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies, this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation, this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions, this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks, this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching, this.enableResendInterval = jsonConfig.enableResendInterval, this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk, this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging, this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging, this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics, this.quickPulseHost = jsonConfig.quickPulseHost;
        } catch (err) {
          Logging.info("Invalid JSON config file: ", err);
        }
      }, JsonConfig;
    }();
  exports.JsonConfig = JsonConfig;
});
var require_constants = __commonJSMin((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0",
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH = 16,
    MAX_SAFE_BUILD_LENGTH = 256 - 6,
    RELEASE_TYPES = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
  module.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    RELEASE_TYPES: RELEASE_TYPES,
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});
var require_debug = __commonJSMin((exports, module) => {
  var debug = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});
var require_re = __commonJSMin((exports, module) => {
  var {
      MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH: MAX_LENGTH
    } = r2(),
    debug = n2();
  exports = module.exports = {};
  var re = exports.re = [],
    safeRe = exports.safeRe = [],
    src = exports.src = [],
    t = exports.t = {},
    R = 0,
    LETTERDASHNUMBER = "[a-zA-Z0-9-]",
    safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]],
    makeSafeRegex = __name(value => {
      for (let [token, max] of safeRegexReplacements) value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      return value;
    }, "makeSafeRegex"),
    createToken = __name((name, value, isGlobal) => {
      let safe = makeSafeRegex(value),
        index = R++;
      debug(name, index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0), safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], !0);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var require_parse_options = __commonJSMin((exports, module) => {
  var looseOption = Object.freeze({
      loose: !0
    }),
    emptyOpts = Object.freeze({}),
    parseOptions = __name(options => options ? typeof options != "object" ? looseOption : options : emptyOpts, "parseOptions");
  module.exports = parseOptions;
});
var require_identifiers = __commonJSMin((exports, module) => {
  var numeric = /^[0-9]+$/,
    compareIdentifiers = __name((a, b) => {
      let anum = numeric.test(a),
        bnum = numeric.test(b);
      return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }, "compareIdentifiers"),
    rcompareIdentifiers = __name((a, b) => compareIdentifiers(b, a), "rcompareIdentifiers");
  module.exports = {
    compareIdentifiers: compareIdentifiers,
    rcompareIdentifiers: rcompareIdentifiers
  };
});
var require_semver = __commonJSMin((exports, module) => {
  var debug = n2(),
    {
      MAX_LENGTH: MAX_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER
    } = r2(),
    {
      safeRe: re,
      t: t
    } = Kh(),
    parseOptions = a6(),
    {
      compareIdentifiers: compareIdentifiers
    } = PS(),
    SemVer = class _SemVer {
      static {
        __name(this, "SemVer");
      }
      constructor(version, options) {
        if (options = parseOptions(options), version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
          version = version.version;
        } else if (typeof version != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease;
        let m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) throw new TypeError(`Invalid Version: ${version}`);
        if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        m[4] ? this.prerelease = m[4].split(".").map(id => {
          if (/^[0-9]+$/.test(id)) {
            let num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
          }
          return id;
        }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof _SemVer)) {
          if (typeof other == "string" && other === this.version) return 0;
          other = new _SemVer(other, this.options);
        }
        return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        return other instanceof _SemVer || (other = new _SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (other instanceof _SemVer || (other = new _SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
        if (!this.prerelease.length && other.prerelease.length) return 1;
        if (!this.prerelease.length && !other.prerelease.length) return 0;
        let i = 0;
        do {
          let a = this.prerelease[i],
            b = other.prerelease[i];
          if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0) return 0;
          if (b === void 0) return 1;
          if (a === void 0) return -1;
          if (a === b) continue;
          return compareIdentifiers(a, b);
        } while (++i);
      }
      compareBuild(other) {
        other instanceof _SemVer || (other = new _SemVer(other, this.options));
        let i = 0;
        do {
          let a = this.build[i],
            b = other.build[i];
          if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0) return 0;
          if (b === void 0) return 1;
          if (a === void 0) return -1;
          if (a === b) continue;
          return compareIdentifiers(a, b);
        } while (++i);
      }
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", identifier, identifierBase), this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            {
              let base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === !1) throw new Error("invalid increment argument: identifier is empty");
              if (this.prerelease.length === 0) this.prerelease = [base];else {
                let i = this.prerelease.length;
                for (; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
                if (i === -1) {
                  if (identifier === this.prerelease.join(".") && identifierBase === !1) throw new Error("invalid increment argument: identifier already exists");
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                identifierBase === !1 && (prerelease = [identifier]), compareIdentifiers(this.prerelease[0], identifier) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = prerelease) : this.prerelease = prerelease;
              }
              break;
            }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
      }
    };
  module.exports = SemVer;
});
var require_parse = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    parse = __name((version, options, throwErrors = !1) => {
      if (version instanceof SemVer) return version;
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) return null;
        throw er;
      }
    }, "parse");
  module.exports = parse;
});
var require_valid = __commonJSMin((exports, module) => {
  var parse = X1(),
    valid = __name((version, options) => {
      let v = parse(version, options);
      return v ? v.version : null;
    }, "valid");
  module.exports = valid;
});
var require_clean = __commonJSMin((exports, module) => {
  var parse = X1(),
    clean = __name((version, options) => {
      let s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }, "clean");
  module.exports = clean;
});
var require_inc = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    inc = __name((version, release, options, identifier, identifierBase) => {
      typeof options == "string" && (identifierBase = identifier, identifier = options, options = void 0);
      try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
      } catch {
        return null;
      }
    }, "inc");
  module.exports = inc;
});
var require_diff = __commonJSMin((exports, module) => {
  var parse = X1(),
    diff = __name((version1, version2) => {
      let v1 = parse(version1, null, !0),
        v2 = parse(version2, null, !0),
        comparison = v1.compare(v2);
      if (comparison === 0) return null;
      let v1Higher = comparison > 0,
        highVersion = v1Higher ? v1 : v2,
        lowVersion = v1Higher ? v2 : v1,
        highHasPre = !!highVersion.prerelease.length;
      if (!!lowVersion.prerelease.length && !highHasPre) return !lowVersion.patch && !lowVersion.minor ? "major" : highVersion.patch ? "patch" : highVersion.minor ? "minor" : "major";
      let prefix = highHasPre ? "pre" : "";
      return v1.major !== v2.major ? prefix + "major" : v1.minor !== v2.minor ? prefix + "minor" : v1.patch !== v2.patch ? prefix + "patch" : "prerelease";
    }, "diff");
  module.exports = diff;
});
var require_major = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    major = __name((a, loose) => new SemVer(a, loose).major, "major");
  module.exports = major;
});
var require_minor = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    minor = __name((a, loose) => new SemVer(a, loose).minor, "minor");
  module.exports = minor;
});
var require_patch = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    patch = __name((a, loose) => new SemVer(a, loose).patch, "patch");
  module.exports = patch;
});
var require_prerelease = __commonJSMin((exports, module) => {
  var parse = X1(),
    prerelease = __name((version, options) => {
      let parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, "prerelease");
  module.exports = prerelease;
});
var require_compare = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    compare = __name((a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose)), "compare");
  module.exports = compare;
});
var require_rcompare = __commonJSMin((exports, module) => {
  var compare = mu(),
    rcompare = __name((a, b, loose) => compare(b, a, loose), "rcompare");
  module.exports = rcompare;
});
var require_compare_loose = __commonJSMin((exports, module) => {
  var compare = mu(),
    compareLoose = __name((a, b) => compare(a, b, !0), "compareLoose");
  module.exports = compareLoose;
});
var require_compare_build = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    compareBuild = __name((a, b, loose) => {
      let versionA = new SemVer(a, loose),
        versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }, "compareBuild");
  module.exports = compareBuild;
});
var require_sort = __commonJSMin((exports, module) => {
  var compareBuild = u6(),
    sort = __name((list, loose) => list.sort((a, b) => compareBuild(a, b, loose)), "sort");
  module.exports = sort;
});
var require_rsort = __commonJSMin((exports, module) => {
  var compareBuild = u6(),
    rsort = __name((list, loose) => list.sort((a, b) => compareBuild(b, a, loose)), "rsort");
  module.exports = rsort;
});
var require_gt = __commonJSMin((exports, module) => {
  var compare = mu(),
    gt = __name((a, b, loose) => compare(a, b, loose) > 0, "gt");
  module.exports = gt;
});
var require_lt = __commonJSMin((exports, module) => {
  var compare = mu(),
    lt = __name((a, b, loose) => compare(a, b, loose) < 0, "lt");
  module.exports = lt;
});
var require_eq = __commonJSMin((exports, module) => {
  var compare = mu(),
    eq = __name((a, b, loose) => compare(a, b, loose) === 0, "eq");
  module.exports = eq;
});
var require_neq = __commonJSMin((exports, module) => {
  var compare = mu(),
    neq = __name((a, b, loose) => compare(a, b, loose) !== 0, "neq");
  module.exports = neq;
});
var require_gte = __commonJSMin((exports, module) => {
  var compare = mu(),
    gte = __name((a, b, loose) => compare(a, b, loose) >= 0, "gte");
  module.exports = gte;
});
var require_lte = __commonJSMin((exports, module) => {
  var compare = mu(),
    lte = __name((a, b, loose) => compare(a, b, loose) <= 0, "lte");
  module.exports = lte;
});
var require_cmp = __commonJSMin((exports, module) => {
  var eq = NS(),
    neq = OS(),
    gt = i2(),
    gte = d6(),
    lt = f6(),
    lte = p6(),
    cmp = __name((a, op, b, loose) => {
      switch (op) {
        case "===":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
        case "!==":
          return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
  module.exports = cmp;
});
var require_coerce = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    parse = X1(),
    {
      safeRe: re,
      t: t
    } = Kh(),
    coerce = __name((version, options) => {
      if (version instanceof SemVer) return version;
      if (typeof version == "number" && (version = String(version)), typeof version != "string") return null;
      options = options || {};
      let match = null;
      if (!options.rtl) match = version.match(re[t.COERCE]);else {
        let next;
        for (; (next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length);) (!match || next.index + next[0].length !== match.index + match[0].length) && (match = next), re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        re[t.COERCERTL].lastIndex = -1;
      }
      return match === null ? null : parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    }, "coerce");
  module.exports = coerce;
});
var require_iterator = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = function (Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) yield walker.value;
    };
  };
});
var require_yallist = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self = this;
    if (self instanceof Yallist || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function") list.forEach(function (item) {
      self.push(item);
    });else if (arguments.length > 0) for (var i = 0, l = arguments.length; i < l; i++) self.push(arguments[i]);
    return self;
  }
  __name(Yallist, "Yallist");
  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) throw new Error("removing node which does not belong to this list");
    var next = node.next,
      prev = node.prev;
    return next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null, next;
  };
  Yallist.prototype.unshiftNode = function (node) {
    if (node !== this.head) {
      node.list && node.list.removeNode(node);
      var head = this.head;
      node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
    }
  };
  Yallist.prototype.pushNode = function (node) {
    if (node !== this.tail) {
      node.list && node.list.removeNode(node);
      var tail = this.tail;
      node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
    }
  };
  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) push(this, arguments[i]);
    return this.length;
  };
  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) unshift(this, arguments[i]);
    return this.length;
  };
  Yallist.prototype.pop = function () {
    if (this.tail) {
      var res = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
    }
  };
  Yallist.prototype.shift = function () {
    if (this.head) {
      var res = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
    }
  };
  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) fn.call(thisp, walker.value, i, this), walker = walker.next;
  };
  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) fn.call(thisp, walker.value, i, this), walker = walker.prev;
  };
  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) walker = walker.next;
    if (i === n && walker !== null) return walker.value;
  };
  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) walker = walker.prev;
    if (i === n && walker !== null) return walker.value;
  };
  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.head; walker !== null;) res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
    return res;
  };
  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    for (var res = new Yallist(), walker = this.tail; walker !== null;) res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
    return res;
  };
  Yallist.prototype.reduce = function (fn, initial) {
    var acc,
      walker = this.head;
    if (arguments.length > 1) acc = initial;else if (this.head) walker = this.head.next, acc = this.head.value;else throw new TypeError("Reduce of empty list with no initial value");
    for (var i = 0; walker !== null; i++) acc = fn(acc, walker.value, i), walker = walker.next;
    return acc;
  };
  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc,
      walker = this.tail;
    if (arguments.length > 1) acc = initial;else if (this.tail) walker = this.tail.prev, acc = this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");
    for (var i = this.length - 1; walker !== null; i--) acc = fn(acc, walker.value, i), walker = walker.prev;
    return acc;
  };
  Yallist.prototype.toArray = function () {
    for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++) arr[i] = walker.value, walker = walker.next;
    return arr;
  };
  Yallist.prototype.toArrayReverse = function () {
    for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++) arr[i] = walker.value, walker = walker.prev;
    return arr;
  };
  Yallist.prototype.slice = function (from, to) {
    to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) walker = walker.next;
    for (; walker !== null && i < to; i++, walker = walker.next) ret.push(walker.value);
    return ret;
  };
  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    from < 0 && (from = 0), to > this.length && (to = this.length);
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) walker = walker.prev;
    for (; walker !== null && i > from; i--, walker = walker.prev) ret.push(walker.value);
    return ret;
  };
  Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
    start > this.length && (start = this.length - 1), start < 0 && (start = this.length + start);
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) walker = walker.next;
    for (var ret = [], i = 0; walker && i < deleteCount; i++) ret.push(walker.value), walker = this.removeNode(walker);
    walker === null && (walker = this.tail), walker !== this.head && walker !== this.tail && (walker = walker.prev);
    for (var i = 0; i < nodes.length; i++) walker = insert(this, walker, nodes[i]);
    return ret;
  };
  Yallist.prototype.reverse = function () {
    for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next, walker.next = p;
    }
    return this.head = tail, this.tail = head, this;
  };
  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    return inserted.next === null && (self.tail = inserted), inserted.prev === null && (self.head = inserted), self.length++, inserted;
  }
  __name(insert, "insert");
  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
  }
  __name(push, "push");
  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
  }
  __name(unshift, "unshift");
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) return new Node(value, prev, next, list);
    this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
  }
  __name(Node, "Node");
  try {
    Fq()(Yallist);
  } catch {}
});
var require_lru_cache = __commonJSMin((exports, module) => {
  "use strict";

  var Yallist = qq(),
    MAX = Symbol("max"),
    LENGTH = Symbol("length"),
    LENGTH_CALCULATOR = Symbol("lengthCalculator"),
    ALLOW_STALE = Symbol("allowStale"),
    MAX_AGE = Symbol("maxAge"),
    DISPOSE = Symbol("dispose"),
    NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"),
    LRU_LIST = Symbol("lruList"),
    CACHE = Symbol("cache"),
    UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"),
    naiveLength = __name(() => 1, "naiveLength"),
    LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor(options) {
        if (typeof options == "number" && (options = {
          max: options
        }), options || (options = {}), options.max && (typeof options.max != "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        let max = this[MAX] = options.max || 1 / 0,
          lc = options.length || naiveLength;
        if (this[LENGTH_CALCULATOR] = typeof lc != "function" ? naiveLength : lc, this[ALLOW_STALE] = options.stale || !1, options.maxAge && typeof options.maxAge != "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || !1, this.reset();
      }
      set max(mL) {
        if (typeof mL != "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || 1 / 0, trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA != "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA, trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach(hit => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
        })), trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null;) {
          let prev = walker.prev;
          forEachStep(this, fn, walker, thisp), walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null;) {
          let next = walker.next;
          forEachStep(this, fn, walker, thisp), walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map(k => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map(k => k.value);
      }
      reset() {
        this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value)), this[CACHE] = new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map(hit => isStale(this, hit) ? !1 : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter(h => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        if (maxAge = maxAge || this[MAX_AGE], maxAge && typeof maxAge != "number") throw new TypeError("maxAge must be a number");
        let now = maxAge ? Date.now() : 0,
          len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) return del(this, this[CACHE].get(key)), !1;
          let item = this[CACHE].get(key).value;
          return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), !0;
        }
        let hit = new Entry(key, value, len, now, maxAge);
        return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), !0);
      }
      has(key) {
        if (!this[CACHE].has(key)) return !1;
        let hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, !0);
      }
      peek(key) {
        return get(this, key, !1);
      }
      pop() {
        let node = this[LRU_LIST].tail;
        return node ? (del(this, node), node.value) : null;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        let now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          let hit = arr[l],
            expiresAt = hit.e || 0;
          if (expiresAt === 0) this.set(hit.k, hit.v);else {
            let maxAge = expiresAt - now;
            maxAge > 0 && this.set(hit.k, hit.v, maxAge);
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, !1));
      }
    },
    get = __name((self, key, doUse) => {
      let node = self[CACHE].get(key);
      if (node) {
        let hit = node.value;
        if (isStale(self, hit)) {
          if (del(self, node), !self[ALLOW_STALE]) return;
        } else doUse && (self[UPDATE_AGE_ON_GET] && (node.value.now = Date.now()), self[LRU_LIST].unshiftNode(node));
        return hit.value;
      }
    }, "get"),
    isStale = __name((self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE]) return !1;
      let diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    }, "isStale"),
    trim = __name(self => {
      if (self[LENGTH] > self[MAX]) for (let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
        let prev = walker.prev;
        del(self, walker), walker = prev;
      }
    }, "trim"),
    del = __name((self, node) => {
      if (node) {
        let hit = node.value;
        self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
      }
    }, "del"),
    Entry = class {
      static {
        __name(this, "Entry");
      }
      constructor(key, value, length, now, maxAge) {
        this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
      }
    },
    forEachStep = __name((self, fn, node, thisp) => {
      let hit = node.value;
      isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
    }, "forEachStep");
  module.exports = LRUCache;
});
var require_range = __commonJSMin((exports, module) => {
  var Range = class _Range {
    static {
      __name(this, "Range");
    }
    constructor(range, options) {
      if (options = parseOptions(options), range instanceof _Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new _Range(range.raw, options);
      if (range instanceof Comparator) return this.raw = range.value, this.set = [[range]], this.format(), this;
      if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(r => this.parseRange(r.trim())).filter(c => c.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        let first = this.set[0];
        if (this.set = this.set.filter(c => !isNullSet(c[0])), this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
          for (let c of this.set) if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map(comps => comps.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      let memoKey = ((this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE)) + ":" + range,
        cached = cache.get(memoKey);
      if (cached) return cached;
      let loose = this.options.loose,
        hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease)), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range), range = range.replace(re[t.TILDETRIM], tildeTrimReplace), debug("tilde trim", range), range = range.replace(re[t.CARETTRIM], caretTrimReplace), debug("caret trim", range);
      let rangeList = range.split(" ").map(comp => parseComparator(comp, this.options)).join(" ").split(/\s+/).map(comp => replaceGTE0(comp, this.options));
      loose && (rangeList = rangeList.filter(comp => (debug("loose invalid filter", comp, this.options), !!comp.match(re[t.COMPARATORLOOSE])))), debug("range list", rangeList);
      let rangeMap = new Map(),
        comparators = rangeList.map(comp => new Comparator(comp, this.options));
      for (let comp of comparators) {
        if (isNullSet(comp)) return [comp];
        rangeMap.set(comp.value, comp);
      }
      rangeMap.size > 1 && rangeMap.has("") && rangeMap.delete("");
      let result = [...rangeMap.values()];
      return cache.set(memoKey, result), result;
    }
    intersects(range, options) {
      if (!(range instanceof _Range)) throw new TypeError("a Range is required");
      return this.set.some(thisComparators => isSatisfiable(thisComparators, options) && range.set.some(rangeComparators => isSatisfiable(rangeComparators, options) && thisComparators.every(thisComparator => rangeComparators.every(rangeComparator => thisComparator.intersects(rangeComparator, options)))));
    }
    test(version) {
      if (!version) return !1;
      if (typeof version == "string") try {
        version = new SemVer(version, this.options);
      } catch {
        return !1;
      }
      for (let i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
      return !1;
    }
  };
  module.exports = Range;
  var LRU = Gq(),
    cache = new LRU({
      max: 1e3
    }),
    parseOptions = a6(),
    Comparator = a2(),
    debug = n2(),
    SemVer = Ul(),
    {
      safeRe: re,
      t: t,
      comparatorTrimReplace: comparatorTrimReplace,
      tildeTrimReplace: tildeTrimReplace,
      caretTrimReplace: caretTrimReplace
    } = Kh(),
    {
      FLAG_INCLUDE_PRERELEASE: FLAG_INCLUDE_PRERELEASE,
      FLAG_LOOSE: FLAG_LOOSE
    } = r2(),
    isNullSet = __name(c => c.value === "<0.0.0-0", "isNullSet"),
    isAny = __name(c => c.value === "", "isAny"),
    isSatisfiable = __name((comparators, options) => {
      let result = !0,
        remainingComparators = comparators.slice(),
        testComparator = remainingComparators.pop();
      for (; result && remainingComparators.length;) result = remainingComparators.every(otherComparator => testComparator.intersects(otherComparator, options)), testComparator = remainingComparators.pop();
      return result;
    }, "isSatisfiable"),
    parseComparator = __name((comp, options) => (debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp), "parseComparator"),
    isX = __name(id => !id || id.toLowerCase() === "x" || id === "*", "isX"),
    replaceTildes = __name((comp, options) => comp.trim().split(/\s+/).map(c => replaceTilde(c, options)).join(" "), "replaceTildes"),
    replaceTilde = __name((comp, options) => {
      let r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        return isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0 <${+M + 1}.0.0-0` : isX(p) ? ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0` : pr ? (debug("replaceTilde pr", pr), ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`) : ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`, debug("tilde return", ret), ret;
      });
    }, "replaceTilde"),
    replaceCarets = __name((comp, options) => comp.trim().split(/\s+/).map(c => replaceCaret(c, options)).join(" "), "replaceCarets"),
    replaceCaret = __name((comp, options) => {
      debug("caret", comp, options);
      let r = options.loose ? re[t.CARETLOOSE] : re[t.CARET],
        z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        return isX(M) ? ret = "" : isX(m) ? ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0` : isX(p) ? M === "0" ? ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0` : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0` : ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`) : (debug("no pr"), M === "0" ? m === "0" ? ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0` : ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0` : ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`), debug("caret return", ret), ret;
      });
    }, "replaceCaret"),
    replaceXRanges = __name((comp, options) => (debug("replaceXRanges", comp, options), comp.split(/\s+/).map(c => replaceXRange(c, options)).join(" ")), "replaceXRanges"),
    replaceXRange = __name((comp, options) => {
      comp = comp.trim();
      let r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        let xM = isX(M),
          xm = xM || isX(m),
          xp = xm || isX(p),
          anyX = xp;
        return gtlt === "=" && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0-0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), gtlt === "<" && (pr = "-0"), ret = `${gtlt + M}.${m}.${p}${pr}`) : xm ? ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0` : xp && (ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`), debug("xRange return", ret), ret;
      });
    }, "replaceXRange"),
    replaceStars = __name((comp, options) => (debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "")), "replaceStars"),
    replaceGTE0 = __name((comp, options) => (debug("replaceGTE0", comp, options), comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "")), "replaceGTE0"),
    hyphenReplace = __name(incPr => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => (isX(fM) ? from = "" : isX(fm) ? from = `>=${fM}.0.0${incPr ? "-0" : ""}` : isX(fp) ? from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}` : fpr ? from = `>=${from}` : from = `>=${from}${incPr ? "-0" : ""}`, isX(tM) ? to = "" : isX(tm) ? to = `<${+tM + 1}.0.0-0` : isX(tp) ? to = `<${tM}.${+tm + 1}.0-0` : tpr ? to = `<=${tM}.${tm}.${tp}-${tpr}` : incPr ? to = `<${tM}.${tm}.${+tp + 1}-0` : to = `<=${to}`, `${from} ${to}`.trim()), "hyphenReplace"),
    testSet = __name((set, version, options) => {
      for (let i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== Comparator.ANY && set[i].semver.prerelease.length > 0) {
          let allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
        }
        return !1;
      }
      return !0;
    }, "testSet");
});
var require_comparator = __commonJSMin((exports, module) => {
  var ANY = Symbol("SemVer ANY"),
    Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        if (options = parseOptions(options), comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) return comp;
          comp = comp.value;
        }
        comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
      }
      parse(comp) {
        let r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR],
          m = comp.match(r);
        if (!m) throw new TypeError(`Invalid comparator: ${comp}`);
        this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
      }
      toString() {
        return this.value;
      }
      test(version) {
        if (debug("Comparator.test", version, this.options.loose), this.semver === ANY || version === ANY) return !0;
        if (typeof version == "string") try {
          version = new SemVer(version, this.options);
        } catch {
          return !1;
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) throw new TypeError("a Comparator is required");
        return this.operator === "" ? this.value === "" ? !0 : new Range(comp.value, options).test(this.value) : comp.operator === "" ? comp.value === "" ? !0 : new Range(this.value, options).test(comp.semver) : (options = parseOptions(options), options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0") || !options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && comp.operator.startsWith(">") || this.operator.startsWith("<") && comp.operator.startsWith("<") || this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=") || cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<") || cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")));
      }
    };
  module.exports = Comparator;
  var parseOptions = a6(),
    {
      safeRe: re,
      t: t
    } = Kh(),
    cmp = LS(),
    debug = n2(),
    SemVer = Ul(),
    Range = hu();
});
var require_satisfies = __commonJSMin((exports, module) => {
  var Range = hu(),
    satisfies = __name((version, range, options) => {
      try {
        range = new Range(range, options);
      } catch {
        return !1;
      }
      return range.test(version);
    }, "satisfies");
  module.exports = satisfies;
});
var require_to_comparators = __commonJSMin((exports, module) => {
  var Range = hu(),
    toComparators = __name((range, options) => new Range(range, options).set.map(comp => comp.map(c => c.value).join(" ").trim().split(" ")), "toComparators");
  module.exports = toComparators;
});
var require_max_satisfying = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    Range = hu(),
    maxSatisfying = __name((versions, range, options) => {
      let max = null,
        maxSV = null,
        rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(v => {
        rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
      }), max;
    }, "maxSatisfying");
  module.exports = maxSatisfying;
});
var require_min_satisfying = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    Range = hu(),
    minSatisfying = __name((versions, range, options) => {
      let min = null,
        minSV = null,
        rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch {
        return null;
      }
      return versions.forEach(v => {
        rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
      }), min;
    }, "minSatisfying");
  module.exports = minSatisfying;
});
var require_min_version = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    Range = hu(),
    gt = i2(),
    minVersion = __name((range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver))) return minver;
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        let comparators = range.set[i],
          setMin = null;
        comparators.forEach(comparator => {
          let compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
            case "":
            case ">=":
              (!setMin || gt(compver, setMin)) && (setMin = compver);
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        }), setMin && (!minver || gt(minver, setMin)) && (minver = setMin);
      }
      return minver && range.test(minver) ? minver : null;
    }, "minVersion");
  module.exports = minVersion;
});
var require_valid = __commonJSMin((exports, module) => {
  var Range = hu(),
    validRange = __name((range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch {
        return null;
      }
    }, "validRange");
  module.exports = validRange;
});
var require_outside = __commonJSMin((exports, module) => {
  var SemVer = Ul(),
    Comparator = a2(),
    {
      ANY: ANY
    } = Comparator,
    Range = hu(),
    satisfies = c2(),
    gt = i2(),
    lt = f6(),
    lte = p6(),
    gte = d6(),
    outside = __name((version, range, hilo, options) => {
      version = new SemVer(version, options), range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
          break;
        case "<":
          gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) return !1;
      for (let i = 0; i < range.set.length; ++i) {
        let comparators = range.set[i],
          high = null,
          low = null;
        if (comparators.forEach(comparator => {
          comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
        }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
        if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
      }
      return !0;
    }, "outside");
  module.exports = outside;
});
var require_gtr = __commonJSMin((exports, module) => {
  var outside = _6(),
    gtr = __name((version, range, options) => outside(version, range, ">", options), "gtr");
  module.exports = gtr;
});
var require_ltr = __commonJSMin((exports, module) => {
  var outside = _6(),
    ltr = __name((version, range, options) => outside(version, range, "<", options), "ltr");
  module.exports = ltr;
});
var require_intersects = __commonJSMin((exports, module) => {
  var Range = hu(),
    intersects = __name((r1, r2, options) => (r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2, options)), "intersects");
  module.exports = intersects;
});
var require_simplify = __commonJSMin((exports, module) => {
  var satisfies = c2(),
    compare = mu();
  module.exports = (versions, range, options) => {
    let set = [],
      first = null,
      prev = null,
      v = versions.sort((a, b) => compare(a, b, options));
    for (let version of v) satisfies(version, range, options) ? (prev = version, first || (first = version)) : (prev && set.push([first, prev]), prev = null, first = null);
    first && set.push([first, null]);
    let ranges = [];
    for (let [min, max] of set) min === max ? ranges.push(min) : !max && min === v[0] ? ranges.push("*") : max ? min === v[0] ? ranges.push(`<=${max}`) : ranges.push(`${min} - ${max}`) : ranges.push(`>=${min}`);
    let simplified = ranges.join(" || "),
      original = typeof range.raw == "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});
var require_subset = __commonJSMin((exports, module) => {
  var Range = hu(),
    Comparator = a2(),
    {
      ANY: ANY
    } = Comparator,
    satisfies = c2(),
    compare = mu(),
    subset = __name((sub, dom, options = {}) => {
      if (sub === dom) return !0;
      sub = new Range(sub, options), dom = new Range(dom, options);
      let sawNonNull = !1;
      OUTER: for (let simpleSub of sub.set) {
        for (let simpleDom of dom.set) {
          let isSub = simpleSubset(simpleSub, simpleDom, options);
          if (sawNonNull = sawNonNull || isSub !== null, isSub) continue OUTER;
        }
        if (sawNonNull) return !1;
      }
      return !0;
    }, "subset"),
    minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")],
    minimumVersion = [new Comparator(">=0.0.0")],
    simpleSubset = __name((sub, dom, options) => {
      if (sub === dom) return !0;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) return !0;
        options.includePrerelease ? sub = minimumVersionWithPreRelease : sub = minimumVersion;
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) return !0;
        dom = minimumVersion;
      }
      let eqSet = new Set(),
        gt,
        lt;
      for (let c of sub) c.operator === ">" || c.operator === ">=" ? gt = higherGT(gt, c, options) : c.operator === "<" || c.operator === "<=" ? lt = lowerLT(lt, c, options) : eqSet.add(c.semver);
      if (eqSet.size > 1) return null;
      let gtltComp;
      if (gt && lt) {
        if (gtltComp = compare(gt.semver, lt.semver, options), gtltComp > 0) return null;
        if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) return null;
      }
      for (let eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options) || lt && !satisfies(eq, String(lt), options)) return null;
        for (let c of dom) if (!satisfies(eq, String(c), options)) return !1;
        return !0;
      }
      let higher,
        lower,
        hasDomLT,
        hasDomGT,
        needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : !1,
        needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : !1;
      needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0 && (needDomLTPre = !1);
      for (let c of dom) {
        if (hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=", hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=", gt) {
          if (needDomGTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch && (needDomGTPre = !1), c.operator === ">" || c.operator === ">=") {
            if (higher = higherGT(gt, c, options), higher === c && higher !== gt) return !1;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) return !1;
        }
        if (lt) {
          if (needDomLTPre && c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch && (needDomLTPre = !1), c.operator === "<" || c.operator === "<=") {
            if (lower = lowerLT(lt, c, options), lower === c && lower !== lt) return !1;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) return !1;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) return !1;
      }
      return !(gt && hasDomLT && !lt && gtltComp !== 0 || lt && hasDomGT && !gt && gtltComp !== 0 || needDomGTPre || needDomLTPre);
    }, "simpleSubset"),
    higherGT = __name((a, b, options) => {
      if (!a) return b;
      let comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 || b.operator === ">" && a.operator === ">=" ? b : a;
    }, "higherGT"),
    lowerLT = __name((a, b, options) => {
      if (!a) return b;
      let comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 || b.operator === "<" && a.operator === "<=" ? b : a;
    }, "lowerLT");
  module.exports = subset;
});
var require_semver = __commonJSMin((exports, module) => {
  var internalRe = Kh(),
    constants = r2(),
    SemVer = Ul(),
    identifiers = PS(),
    parse = X1(),
    valid = JU(),
    clean = tq(),
    inc = iq(),
    diff = aq(),
    major = cq(),
    minor = fq(),
    patch = pq(),
    prerelease = hq(),
    compare = mu(),
    rcompare = vq(),
    compareLoose = bq(),
    compareBuild = u6(),
    sort = Sq(),
    rsort = Iq(),
    gt = i2(),
    lt = f6(),
    eq = NS(),
    neq = OS(),
    gte = d6(),
    lte = p6(),
    cmp = LS(),
    coerce = Mq(),
    Comparator = a2(),
    Range = hu(),
    satisfies = c2(),
    toComparators = ij(),
    maxSatisfying = oj(),
    minSatisfying = lj(),
    minVersion = fj(),
    validRange = pj(),
    outside = _6(),
    gtr = vj(),
    ltr = bj(),
    intersects = Tj(),
    simplifyRange = wj(),
    subset = Oj();
  module.exports = {
    parse: parse,
    valid: valid,
    clean: clean,
    inc: inc,
    diff: diff,
    major: major,
    minor: minor,
    patch: patch,
    prerelease: prerelease,
    compare: compare,
    rcompare: rcompare,
    compareLoose: compareLoose,
    compareBuild: compareBuild,
    sort: sort,
    rsort: rsort,
    gt: gt,
    lt: lt,
    eq: eq,
    neq: neq,
    gte: gte,
    lte: lte,
    cmp: cmp,
    coerce: coerce,
    Comparator: Comparator,
    Range: Range,
    satisfies: satisfies,
    toComparators: toComparators,
    maxSatisfying: maxSatisfying,
    minSatisfying: minSatisfying,
    minVersion: minVersion,
    validRange: validRange,
    outside: outside,
    gtr: gtr,
    ltr: ltr,
    intersects: intersects,
    simplifyRange: simplifyRange,
    subset: subset,
    SemVer: SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});
var require_patchRequire = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.makePatchingRequire = void 0;
  var path = require("path"),
    semver = XS(),
    channel_1 = N0(),
    moduleModule = require("module"),
    nativeModules = Object.keys(process.binding("natives")),
    originalRequire = moduleModule.prototype.require;
  function makePatchingRequire(knownPatches) {
    var patchedModules = {};
    return __name(function (moduleId) {
      var originalModule = originalRequire.apply(this, arguments);
      if (knownPatches[moduleId]) {
        var modulePath = moduleModule._resolveFilename(moduleId, this);
        if (patchedModules.hasOwnProperty(modulePath)) return patchedModules[modulePath];
        var moduleVersion = void 0;
        if (nativeModules.indexOf(moduleId) < 0) try {
          moduleVersion = originalRequire.call(this, path.join(moduleId, "package.json")).version;
        } catch {
          return originalModule;
        } else moduleVersion = process.version.substring(1);
        var prereleaseTagIndex = moduleVersion.indexOf("-");
        prereleaseTagIndex >= 0 && (moduleVersion = moduleVersion.substring(0, prereleaseTagIndex));
        for (var modifiedModule = originalModule, _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {
          var modulePatcher = _a[_i];
          if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier) && (modifiedModule = modulePatcher.patch(modifiedModule, modulePath), channel_1.channel)) {
            var name_1 = modulePatcher.publisherName || moduleId;
            channel_1.channel.addPatchedModule(name_1, moduleVersion);
          }
        }
        return patchedModules[modulePath] = modifiedModule;
      }
      return originalModule;
    }, "patchedRequire");
  }
  __name(makePatchingRequire, "makePatchingRequire");
  exports.makePatchingRequire = makePatchingRequire;
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "diagnostic-channel",
    version: "1.1.1",
    main: "./dist/src/channel.js",
    types: "./dist/src/channel.d.ts",
    scripts: {
      build: "tsc",
      lint: "eslint ./ --fix",
      clean: "rimraf ./dist",
      test: "mocha ./dist/tests/**/*.js",
      debug: "mocha --inspect-brk ./dist/tests/**/*.js"
    },
    homepage: "https://github.com/Microsoft/node-diagnostic-channel",
    bugs: {
      url: "https://github.com/Microsoft/node-diagnostic-channel/issues"
    },
    repository: {
      type: "git",
      url: "https://github.com/Microsoft/node-diagnostic-channel.git"
    },
    description: "Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers",
    dependencies: {
      semver: "^7.5.3"
    },
    devDependencies: {
      "@types/mocha": "^2.2.40",
      "@types/node": "~8.0.0",
      mocha: "^3.2.0",
      rimraf: "^2.6.1",
      sinon: "1.17.6",
      typescript: "4.1.2"
    },
    files: ["dist/src/**/*.d.ts", "dist/src/**/*.js", "LICENSE", "README.md", "package.json"],
    license: "MIT"
  };
});
var require_channel = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.channel = exports.ContextPreservingEventEmitter = exports.trueFilter = exports.makePatchingRequire = void 0;
  var patchRequire_1 = YS(),
    patchRequire_2 = YS();
  Object.defineProperty(exports, "makePatchingRequire", {
    enumerable: !0,
    get: function () {
      return patchRequire_2.makePatchingRequire;
    }
  });
  var trueFilter = __name(function (publishing) {
    return !0;
  }, "trueFilter");
  exports.trueFilter = trueFilter;
  var ContextPreservingEventEmitter = function () {
    function ContextPreservingEventEmitter() {
      this.version = Uj().version, this.subscribers = {}, this.contextPreservationFunction = function (cb) {
        return cb;
      }, this.knownPatches = {}, this.modulesPatched = [], this.currentlyPublishing = !1;
    }
    return __name(ContextPreservingEventEmitter, "ContextPreservingEventEmitter"), ContextPreservingEventEmitter.prototype.shouldPublish = function (name) {
      var listeners = this.subscribers[name];
      return listeners ? listeners.some(function (_a) {
        var filter = _a.filter;
        return !filter || filter(!1);
      }) : !1;
    }, ContextPreservingEventEmitter.prototype.publish = function (name, event) {
      if (!this.currentlyPublishing) {
        var listeners = this.subscribers[name];
        if (listeners) {
          var standardEvent_1 = {
            timestamp: Date.now(),
            data: event
          };
          this.currentlyPublishing = !0, listeners.forEach(function (_a) {
            var listener = _a.listener,
              filter = _a.filter;
            try {
              filter && filter(!0) && listener(standardEvent_1);
            } catch {}
          }), this.currentlyPublishing = !1;
        }
      }
    }, ContextPreservingEventEmitter.prototype.subscribe = function (name, listener, filter, patchCallback) {
      filter === void 0 && (filter = exports.trueFilter), this.subscribers[name] || (this.subscribers[name] = []), this.subscribers[name].push({
        listener: listener,
        filter: filter,
        patchCallback: patchCallback
      });
      var patched = this.checkIfModuleIsAlreadyPatched(name);
      patched && patchCallback && patchCallback(patched.name, patched.version);
    }, ContextPreservingEventEmitter.prototype.unsubscribe = function (name, listener, filter) {
      filter === void 0 && (filter = exports.trueFilter);
      var listeners = this.subscribers[name];
      if (listeners) {
        for (var index = 0; index < listeners.length; ++index) if (listeners[index].listener === listener && listeners[index].filter === filter) return listeners.splice(index, 1), !0;
      }
      return !1;
    }, ContextPreservingEventEmitter.prototype.reset = function () {
      var _this = this;
      this.subscribers = {}, this.contextPreservationFunction = function (cb) {
        return cb;
      }, Object.getOwnPropertyNames(this.knownPatches).forEach(function (prop) {
        return delete _this.knownPatches[prop];
      });
    }, ContextPreservingEventEmitter.prototype.bindToContext = function (cb) {
      return this.contextPreservationFunction(cb);
    }, ContextPreservingEventEmitter.prototype.addContextPreservation = function (preserver) {
      var previousPreservationStack = this.contextPreservationFunction;
      this.contextPreservationFunction = function (cb) {
        return preserver(previousPreservationStack(cb));
      };
    }, ContextPreservingEventEmitter.prototype.registerMonkeyPatch = function (packageName, patcher) {
      this.knownPatches[packageName] || (this.knownPatches[packageName] = []), this.knownPatches[packageName].push(patcher);
    }, ContextPreservingEventEmitter.prototype.getPatchesObject = function () {
      return this.knownPatches;
    }, ContextPreservingEventEmitter.prototype.addPatchedModule = function (name, version) {
      for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
        var module_1 = _a[_i];
        if (module_1.name === name) return;
      }
      this.modulesPatched.push({
        name: name,
        version: version
      });
      var listeners = this.subscribers[name];
      listeners && listeners.forEach(function (listener) {
        listener.patchCallback && listener.patchCallback(name, version);
      });
    }, ContextPreservingEventEmitter.prototype.checkIfModuleIsAlreadyPatched = function (name) {
      for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
        var module_2 = _a[_i];
        if (module_2.name === name) return module_2;
      }
      return null;
    }, ContextPreservingEventEmitter;
  }();
  exports.ContextPreservingEventEmitter = ContextPreservingEventEmitter;
  global.diagnosticsSource || (global.diagnosticsSource = new ContextPreservingEventEmitter(), moduleModule = require("module"), moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject()));
  var moduleModule;
  exports.channel = global.diagnosticsSource;
});
var Hj = T(v6 => {
  "use strict";

  Object.defineProperty(v6, "__esModule", {
    value: !0
  });
  v6._globalThis = void 0;
  exports._globalThis = typeof globalThis == "object" ? globalThis : global;
});
var $j = T(J1 => {
  "use strict";

  var Vhe = J1 && J1.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Ghe = J1 && J1.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && Vhe(t, e, r);
    };
  Object.defineProperty(J1, "__esModule", {
    value: !0
  });
  __exportStar(Hj(), exports);
});
var Vj = T(em => {
  "use strict";

  var zhe = em && em.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Whe = em && em.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && zhe(t, e, r);
    };
  Object.defineProperty(em, "__esModule", {
    value: !0
  });
  __exportStar($j(), exports);
});
var QS = T(x6 => {
  "use strict";

  Object.defineProperty(x6, "__esModule", {
    value: !0
  });
  x6.VERSION = void 0;
  exports.VERSION = "1.4.1";
});
var Wj = T(Zh => {
  "use strict";

  Object.defineProperty(Zh, "__esModule", {
    value: !0
  });
  Zh.isCompatible = Zh._makeCompatibilityCheck = void 0;
  var version_1 = QS(),
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    let acceptedVersions = new Set([ownVersion]),
      rejectedVersions = new Set(),
      myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) return () => !1;
    let ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) return __name(function (globalVersion) {
      return globalVersion === ownVersion;
    }, "isExactmatch");
    function _reject(v) {
      return rejectedVersions.add(v), !1;
    }
    __name(_reject, "_reject");
    function _accept(v) {
      return acceptedVersions.add(v), !0;
    }
    return __name(_accept, "_accept"), __name(function (globalVersion) {
      if (acceptedVersions.has(globalVersion)) return !0;
      if (rejectedVersions.has(globalVersion)) return !1;
      let globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) return _reject(globalVersion);
      let globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      return globalVersionParsed.prerelease != null || ownVersionParsed.major !== globalVersionParsed.major ? _reject(globalVersion) : ownVersionParsed.major === 0 ? ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch ? _accept(globalVersion) : _reject(globalVersion) : ownVersionParsed.minor <= globalVersionParsed.minor ? _accept(globalVersion) : _reject(globalVersion);
    }, "isCompatible");
  }
  __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
  exports._makeCompatibilityCheck = _makeCompatibilityCheck;
  exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
});
var tm = T(Ep => {
  "use strict";

  Object.defineProperty(Ep, "__esModule", {
    value: !0
  });
  Ep.unregisterGlobal = Ep.getGlobal = Ep.registerGlobal = void 0;
  var platform_1 = Vj(),
    version_1 = QS(),
    semver_1 = Wj(),
    major = version_1.VERSION.split(".")[0],
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`),
    _global = platform_1._globalThis;
  function registerGlobal(type, instance, diag, allowOverride = !1) {
    var i;
    let api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
      version: version_1.VERSION
    };
    if (!allowOverride && api[type]) {
      let err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
      return diag.error(err.stack || err.message), !1;
    }
    if (api.version !== version_1.VERSION) {
      let err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
      return diag.error(err.stack || err.message), !1;
    }
    return api[type] = instance, diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`), !0;
  }
  __name(registerGlobal, "registerGlobal");
  exports.registerGlobal = registerGlobal;
  function getGlobal(type) {
    var t, r;
    let globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!(!globalVersion || !(0, semver_1.isCompatible)(globalVersion))) return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
  }
  __name(getGlobal, "getGlobal");
  exports.getGlobal = getGlobal;
  function unregisterGlobal(type, diag) {
    diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
    let api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    api && delete api[type];
  }
  __name(unregisterGlobal, "unregisterGlobal");
  exports.unregisterGlobal = unregisterGlobal;
});
var Kj = T(b6 => {
  "use strict";

  Object.defineProperty(b6, "__esModule", {
    value: !0
  });
  b6.DiagComponentLogger = void 0;
  var global_utils_1 = tm(),
    DiagComponentLogger = class {
      static {
        __name(this, "DiagComponentLogger");
      }
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args) {
        return logProxy("debug", this._namespace, args);
      }
      error(...args) {
        return logProxy("error", this._namespace, args);
      }
      info(...args) {
        return logProxy("info", this._namespace, args);
      }
      warn(...args) {
        return logProxy("warn", this._namespace, args);
      }
      verbose(...args) {
        return logProxy("verbose", this._namespace, args);
      }
    };
  exports.DiagComponentLogger = DiagComponentLogger;
  function logProxy(funcName, namespace, args) {
    let logger = (0, global_utils_1.getGlobal)("diag");
    if (logger) return args.unshift(namespace), logger[funcName](...args);
  }
  __name(logProxy, "logProxy");
});
var E6 = T(m2 => {
  "use strict";

  Object.defineProperty(m2, "__esModule", {
    value: !0
  });
  m2.DiagLogLevel = void 0;
  var DiagLogLevel;
  (function (DiagLogLevel) {
    DiagLogLevel[DiagLogLevel.NONE = 0] = "NONE", DiagLogLevel[DiagLogLevel.ERROR = 30] = "ERROR", DiagLogLevel[DiagLogLevel.WARN = 50] = "WARN", DiagLogLevel[DiagLogLevel.INFO = 60] = "INFO", DiagLogLevel[DiagLogLevel.DEBUG = 70] = "DEBUG", DiagLogLevel[DiagLogLevel.VERBOSE = 80] = "VERBOSE", DiagLogLevel[DiagLogLevel.ALL = 9999] = "ALL";
  })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
});
var Xj = T(C6 => {
  "use strict";

  Object.defineProperty(C6, "__esModule", {
    value: !0
  });
  C6.createLogLevelDiagLogger = void 0;
  var types_1 = E6();
  function createLogLevelDiagLogger(maxLevel, logger) {
    maxLevel < types_1.DiagLogLevel.NONE ? maxLevel = types_1.DiagLogLevel.NONE : maxLevel > types_1.DiagLogLevel.ALL && (maxLevel = types_1.DiagLogLevel.ALL), logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      let theFunc = logger[funcName];
      return typeof theFunc == "function" && maxLevel >= theLevel ? theFunc.bind(logger) : function () {};
    }
    return __name(_filterFunc, "_filterFunc"), {
      error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
      warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
      info: _filterFunc("info", types_1.DiagLogLevel.INFO),
      debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
    };
  }
  __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
  exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
});
var rm = T(S6 => {
  "use strict";

  Object.defineProperty(S6, "__esModule", {
    value: !0
  });
  S6.DiagAPI = void 0;
  var ComponentLogger_1 = Kj(),
    logLevelLogger_1 = Xj(),
    types_1 = E6(),
    global_utils_1 = tm(),
    API_NAME = "diag",
    DiagAPI = class _DiagAPI {
      static {
        __name(this, "DiagAPI");
      }
      constructor() {
        function _logProxy(funcName) {
          return function (...args) {
            let logger = (0, global_utils_1.getGlobal)("diag");
            if (logger) return logger[funcName](...args);
          };
        }
        __name(_logProxy, "_logProxy");
        let self = this,
          setLogger = __name((logger, optionsOrLogLevel = {
            logLevel: types_1.DiagLogLevel.INFO
          }) => {
            var o, c, u;
            if (logger === self) {
              let err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
              return self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message), !1;
            }
            typeof optionsOrLogLevel == "number" && (optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            });
            let oldLogger = (0, global_utils_1.getGlobal)("diag"),
              newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
              let stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
              oldLogger.warn(`Current logger will be overwritten from ${stack}`), newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
            }
            return (0, global_utils_1.registerGlobal)("diag", newLogger, self, !0);
          }, "setLogger");
        self.setLogger = setLogger, self.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self);
        }, self.createComponentLogger = options => new ComponentLogger_1.DiagComponentLogger(options), self.verbose = _logProxy("verbose"), self.debug = _logProxy("debug"), self.info = _logProxy("info"), self.warn = _logProxy("warn"), self.error = _logProxy("error");
      }
      static instance() {
        return this._instance || (this._instance = new _DiagAPI()), this._instance;
      }
    };
  exports.DiagAPI = DiagAPI;
});
var Qj = T(w6 => {
  "use strict";

  Object.defineProperty(w6, "__esModule", {
    value: !0
  });
  w6.BaggageImpl = void 0;
  var BaggageImpl = class _BaggageImpl {
    static {
      __name(this, "BaggageImpl");
    }
    constructor(entries) {
      this._entries = entries ? new Map(entries) : new Map();
    }
    getEntry(key) {
      let entry = this._entries.get(key);
      if (entry) return Object.assign({}, entry);
    }
    getAllEntries() {
      return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
    }
    setEntry(key, entry) {
      let newBaggage = new _BaggageImpl(this._entries);
      return newBaggage._entries.set(key, entry), newBaggage;
    }
    removeEntry(key) {
      let newBaggage = new _BaggageImpl(this._entries);
      return newBaggage._entries.delete(key), newBaggage;
    }
    removeEntries(...keys) {
      let newBaggage = new _BaggageImpl(this._entries);
      for (let key of keys) newBaggage._entries.delete(key);
      return newBaggage;
    }
    clear() {
      return new _BaggageImpl();
    }
  };
  exports.BaggageImpl = BaggageImpl;
});
var Zj = T(I6 => {
  "use strict";

  Object.defineProperty(I6, "__esModule", {
    value: !0
  });
  I6.baggageEntryMetadataSymbol = void 0;
  exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
});
var tw = T(eg => {
  "use strict";

  Object.defineProperty(eg, "__esModule", {
    value: !0
  });
  eg.baggageEntryMetadataFromString = eg.createBaggage = void 0;
  var diag_1 = rm(),
    baggage_impl_1 = Qj(),
    symbol_1 = Zj(),
    diag = diag_1.DiagAPI.instance();
  function createBaggage(entries = {}) {
    return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
  }
  __name(createBaggage, "createBaggage");
  exports.createBaggage = createBaggage;
  function baggageEntryMetadataFromString(str) {
    return typeof str != "string" && (diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`), str = ""), {
      __TYPE__: symbol_1.baggageEntryMetadataSymbol,
      toString() {
        return str;
      }
    };
  }
  __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
  exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
});
var h2 = T(tg => {
  "use strict";

  Object.defineProperty(tg, "__esModule", {
    value: !0
  });
  tg.ROOT_CONTEXT = tg.createContextKey = void 0;
  function createContextKey(description) {
    return Symbol.for(description);
  }
  __name(createContextKey, "createContextKey");
  exports.createContextKey = createContextKey;
  var BaseContext = class _BaseContext {
    static {
      __name(this, "BaseContext");
    }
    constructor(parentContext) {
      let self = this;
      self._currentContext = parentContext ? new Map(parentContext) : new Map(), self.getValue = key => self._currentContext.get(key), self.setValue = (key, value) => {
        let context = new _BaseContext(self._currentContext);
        return context._currentContext.set(key, value), context;
      }, self.deleteValue = key => {
        let context = new _BaseContext(self._currentContext);
        return context._currentContext.delete(key), context;
      };
    }
  };
  exports.ROOT_CONTEXT = new BaseContext();
});
var Jj = T(A6 => {
  "use strict";

  Object.defineProperty(A6, "__esModule", {
    value: !0
  });
  A6.DiagConsoleLogger = void 0;
  var consoleMap = [{
      n: "error",
      c: "error"
    }, {
      n: "warn",
      c: "warn"
    }, {
      n: "info",
      c: "info"
    }, {
      n: "debug",
      c: "debug"
    }, {
      n: "verbose",
      c: "trace"
    }],
    DiagConsoleLogger = class {
      static {
        __name(this, "DiagConsoleLogger");
      }
      constructor() {
        function _consoleFunc(funcName) {
          return function (...args) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc != "function" && (theFunc = console.log), typeof theFunc == "function") return theFunc.apply(console, args);
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (let i = 0; i < consoleMap.length; i++) this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    };
  exports.DiagConsoleLogger = DiagConsoleLogger;
});
var sw = T(Ws => {
  "use strict";

  Object.defineProperty(Ws, "__esModule", {
    value: !0
  });
  Ws.createNoopMeter = Ws.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = Ws.NOOP_OBSERVABLE_GAUGE_METRIC = Ws.NOOP_OBSERVABLE_COUNTER_METRIC = Ws.NOOP_UP_DOWN_COUNTER_METRIC = Ws.NOOP_HISTOGRAM_METRIC = Ws.NOOP_COUNTER_METRIC = Ws.NOOP_METER = Ws.NoopObservableUpDownCounterMetric = Ws.NoopObservableGaugeMetric = Ws.NoopObservableCounterMetric = Ws.NoopObservableMetric = Ws.NoopHistogramMetric = Ws.NoopUpDownCounterMetric = Ws.NoopCounterMetric = Ws.NoopMetric = Ws.NoopMeter = void 0;
  var NoopMeter = class {
    static {
      __name(this, "NoopMeter");
    }
    constructor() {}
    createHistogram(_name, _options) {
      return exports.NOOP_HISTOGRAM_METRIC;
    }
    createCounter(_name, _options) {
      return exports.NOOP_COUNTER_METRIC;
    }
    createUpDownCounter(_name, _options) {
      return exports.NOOP_UP_DOWN_COUNTER_METRIC;
    }
    createObservableGauge(_name, _options) {
      return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
    }
    createObservableCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
    }
    createObservableUpDownCounter(_name, _options) {
      return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    }
    addBatchObservableCallback(_callback, _observables) {}
    removeBatchObservableCallback(_callback) {}
  };
  exports.NoopMeter = NoopMeter;
  var NoopMetric = class {
    static {
      __name(this, "NoopMetric");
    }
  };
  exports.NoopMetric = NoopMetric;
  var NoopCounterMetric = class extends NoopMetric {
    static {
      __name(this, "NoopCounterMetric");
    }
    add(_value, _attributes) {}
  };
  exports.NoopCounterMetric = NoopCounterMetric;
  var NoopUpDownCounterMetric = class extends NoopMetric {
    static {
      __name(this, "NoopUpDownCounterMetric");
    }
    add(_value, _attributes) {}
  };
  exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
  var NoopHistogramMetric = class extends NoopMetric {
    static {
      __name(this, "NoopHistogramMetric");
    }
    record(_value, _attributes) {}
  };
  exports.NoopHistogramMetric = NoopHistogramMetric;
  var NoopObservableMetric = class {
    static {
      __name(this, "NoopObservableMetric");
    }
    addCallback(_callback) {}
    removeCallback(_callback) {}
  };
  exports.NoopObservableMetric = NoopObservableMetric;
  var NoopObservableCounterMetric = class extends NoopObservableMetric {
    static {
      __name(this, "NoopObservableCounterMetric");
    }
  };
  exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
  var NoopObservableGaugeMetric = class extends NoopObservableMetric {
    static {
      __name(this, "NoopObservableGaugeMetric");
    }
  };
  exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
  var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
    static {
      __name(this, "NoopObservableUpDownCounterMetric");
    }
  };
  exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
  exports.NOOP_METER = new NoopMeter();
  exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
  exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
  exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
  exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
  exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
  exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  function createNoopMeter() {
    return exports.NOOP_METER;
  }
  __name(createNoopMeter, "createNoopMeter");
  exports.createNoopMeter = createNoopMeter;
});
var eH = T(g2 => {
  "use strict";

  Object.defineProperty(g2, "__esModule", {
    value: !0
  });
  g2.ValueType = void 0;
  var ValueType;
  (function (ValueType) {
    ValueType[ValueType.INT = 0] = "INT", ValueType[ValueType.DOUBLE = 1] = "DOUBLE";
  })(ValueType = exports.ValueType || (exports.ValueType = {}));
});
var ow = T(ig => {
  "use strict";

  Object.defineProperty(ig, "__esModule", {
    value: !0
  });
  ig.defaultTextMapSetter = ig.defaultTextMapGetter = void 0;
  exports.defaultTextMapGetter = {
    get(carrier, key) {
      if (carrier != null) return carrier[key];
    },
    keys(carrier) {
      return carrier == null ? [] : Object.keys(carrier);
    }
  };
  exports.defaultTextMapSetter = {
    set(carrier, key, value) {
      carrier != null && (carrier[key] = value);
    }
  };
});
var tH = T(M6 => {
  "use strict";

  Object.defineProperty(M6, "__esModule", {
    value: !0
  });
  M6.NoopContextManager = void 0;
  var context_1 = h2(),
    NoopContextManager = class {
      static {
        __name(this, "NoopContextManager");
      }
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
        return target;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
  exports.NoopContextManager = NoopContextManager;
});
var _2 = T(B6 => {
  "use strict";

  Object.defineProperty(B6, "__esModule", {
    value: !0
  });
  B6.ContextAPI = void 0;
  var NoopContextManager_1 = tH(),
    global_utils_1 = tm(),
    diag_1 = rm(),
    API_NAME = "context",
    NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager(),
    ContextAPI = class _ContextAPI {
      static {
        __name(this, "ContextAPI");
      }
      constructor() {}
      static getInstance() {
        return this._instance || (this._instance = new _ContextAPI()), this._instance;
      }
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      active() {
        return this._getContextManager().active();
      }
      with(context, fn, thisArg, ...args) {
        return this._getContextManager().with(context, fn, thisArg, ...args);
      }
      bind(context, target) {
        return this._getContextManager().bind(context, target);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      disable() {
        this._getContextManager().disable(), (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
  exports.ContextAPI = ContextAPI;
});
var fw = T(y2 => {
  "use strict";

  Object.defineProperty(y2, "__esModule", {
    value: !0
  });
  y2.TraceFlags = void 0;
  var TraceFlags;
  (function (TraceFlags) {
    TraceFlags[TraceFlags.NONE = 0] = "NONE", TraceFlags[TraceFlags.SAMPLED = 1] = "SAMPLED";
  })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
});
var F6 = T(vf => {
  "use strict";

  Object.defineProperty(vf, "__esModule", {
    value: !0
  });
  vf.INVALID_SPAN_CONTEXT = vf.INVALID_TRACEID = vf.INVALID_SPANID = void 0;
  var trace_flags_1 = fw();
  exports.INVALID_SPANID = "0000000000000000";
  exports.INVALID_TRACEID = "00000000000000000000000000000000";
  exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
  };
});
var q6 = T(U6 => {
  "use strict";

  Object.defineProperty(U6, "__esModule", {
    value: !0
  });
  U6.NonRecordingSpan = void 0;
  var invalid_span_constants_1 = F6(),
    NonRecordingSpan = class {
      static {
        __name(this, "NonRecordingSpan");
      }
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(_key, _value) {
        return this;
      }
      setAttributes(_attributes) {
        return this;
      }
      addEvent(_name, _attributes) {
        return this;
      }
      setStatus(_status) {
        return this;
      }
      updateName(_name) {
        return this;
      }
      end(_endTime) {}
      isRecording() {
        return !1;
      }
      recordException(_exception, _time) {}
    };
  exports.NonRecordingSpan = NonRecordingSpan;
});
var hw = T(_c => {
  "use strict";

  Object.defineProperty(_c, "__esModule", {
    value: !0
  });
  _c.getSpanContext = _c.setSpanContext = _c.deleteSpan = _c.setSpan = _c.getActiveSpan = _c.getSpan = void 0;
  var context_1 = h2(),
    NonRecordingSpan_1 = q6(),
    context_2 = _2(),
    SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
  function getSpan(context) {
    return context.getValue(SPAN_KEY) || void 0;
  }
  __name(getSpan, "getSpan");
  exports.getSpan = getSpan;
  function getActiveSpan() {
    return getSpan(context_2.ContextAPI.getInstance().active());
  }
  __name(getActiveSpan, "getActiveSpan");
  exports.getActiveSpan = getActiveSpan;
  function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
  }
  __name(setSpan, "setSpan");
  exports.setSpan = setSpan;
  function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
  }
  __name(deleteSpan, "deleteSpan");
  exports.deleteSpan = deleteSpan;
  function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
  }
  __name(setSpanContext, "setSpanContext");
  exports.setSpanContext = setSpanContext;
  function getSpanContext(context) {
    var t;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
  }
  __name(getSpanContext, "getSpanContext");
  exports.getSpanContext = getSpanContext;
});
var j6 = T(xf => {
  "use strict";

  Object.defineProperty(xf, "__esModule", {
    value: !0
  });
  xf.wrapSpanContext = xf.isSpanContextValid = xf.isValidSpanId = xf.isValidTraceId = void 0;
  var invalid_span_constants_1 = F6(),
    NonRecordingSpan_1 = q6(),
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i,
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
  }
  __name(isValidTraceId, "isValidTraceId");
  exports.isValidTraceId = isValidTraceId;
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
  }
  __name(isValidSpanId, "isValidSpanId");
  exports.isValidSpanId = isValidSpanId;
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  __name(isSpanContextValid, "isSpanContextValid");
  exports.isSpanContextValid = isSpanContextValid;
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
  }
  __name(wrapSpanContext, "wrapSpanContext");
  exports.wrapSpanContext = wrapSpanContext;
});
var vw = T(H6 => {
  "use strict";

  Object.defineProperty(H6, "__esModule", {
    value: !0
  });
  H6.NoopTracer = void 0;
  var context_1 = _2(),
    context_utils_1 = hw(),
    NonRecordingSpan_1 = q6(),
    spancontext_utils_1 = j6(),
    contextApi = context_1.ContextAPI.getInstance(),
    NoopTracer = class {
      static {
        __name(this, "NoopTracer");
      }
      startSpan(name, options, context = contextApi.active()) {
        if (!!options?.root) return new NonRecordingSpan_1.NonRecordingSpan();
        let parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
        return isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext) ? new NonRecordingSpan_1.NonRecordingSpan(parentFromContext) : new NonRecordingSpan_1.NonRecordingSpan();
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts, ctx, fn;
        if (arguments.length < 2) return;
        arguments.length === 2 ? fn = arg2 : arguments.length === 3 ? (opts = arg2, fn = arg3) : (opts = arg2, ctx = arg3, fn = arg4);
        let parentContext = ctx ?? contextApi.active(),
          span = this.startSpan(name, opts, parentContext),
          contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      }
    };
  exports.NoopTracer = NoopTracer;
  function isSpanContext(spanContext) {
    return typeof spanContext == "object" && typeof spanContext.spanId == "string" && typeof spanContext.traceId == "string" && typeof spanContext.traceFlags == "number";
  }
  __name(isSpanContext, "isSpanContext");
});
var bw = T($6 => {
  "use strict";

  Object.defineProperty($6, "__esModule", {
    value: !0
  });
  $6.ProxyTracer = void 0;
  var NoopTracer_1 = vw(),
    NOOP_TRACER = new NoopTracer_1.NoopTracer(),
    ProxyTracer = class {
      static {
        __name(this, "ProxyTracer");
      }
      constructor(_provider, name, version, options) {
        this._provider = _provider, this.name = name, this.version = version, this.options = options;
      }
      startSpan(name, options, context) {
        return this._getTracer().startSpan(name, options, context);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        let tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      _getTracer() {
        if (this._delegate) return this._delegate;
        let tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        return tracer ? (this._delegate = tracer, this._delegate) : NOOP_TRACER;
      }
    };
  exports.ProxyTracer = ProxyTracer;
});
var lH = T(V6 => {
  "use strict";

  Object.defineProperty(V6, "__esModule", {
    value: !0
  });
  V6.NoopTracerProvider = void 0;
  var NoopTracer_1 = vw(),
    NoopTracerProvider = class {
      static {
        __name(this, "NoopTracerProvider");
      }
      getTracer(_name, _version, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
  exports.NoopTracerProvider = NoopTracerProvider;
});
var Tw = T(G6 => {
  "use strict";

  Object.defineProperty(G6, "__esModule", {
    value: !0
  });
  G6.ProxyTracerProvider = void 0;
  var ProxyTracer_1 = bw(),
    NoopTracerProvider_1 = lH(),
    NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider(),
    ProxyTracerProvider = class {
      static {
        __name(this, "ProxyTracerProvider");
      }
      getTracer(name, version, options) {
        var i;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version, options);
      }
      getDelegate() {
        var t;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name, version, options) {
        var i;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      }
    };
  exports.ProxyTracerProvider = ProxyTracerProvider;
});
var cH = T(v2 => {
  "use strict";

  Object.defineProperty(v2, "__esModule", {
    value: !0
  });
  v2.SamplingDecision = void 0;
  var SamplingDecision;
  (function (SamplingDecision) {
    SamplingDecision[SamplingDecision.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision[SamplingDecision.RECORD = 1] = "RECORD", SamplingDecision[SamplingDecision.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});
var uH = T(x2 => {
  "use strict";

  Object.defineProperty(x2, "__esModule", {
    value: !0
  });
  x2.SpanKind = void 0;
  var SpanKind;
  (function (SpanKind) {
    SpanKind[SpanKind.INTERNAL = 0] = "INTERNAL", SpanKind[SpanKind.SERVER = 1] = "SERVER", SpanKind[SpanKind.CLIENT = 2] = "CLIENT", SpanKind[SpanKind.PRODUCER = 3] = "PRODUCER", SpanKind[SpanKind.CONSUMER = 4] = "CONSUMER";
  })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
});
var fH = T(b2 => {
  "use strict";

  Object.defineProperty(b2, "__esModule", {
    value: !0
  });
  b2.SpanStatusCode = void 0;
  var SpanStatusCode;
  (function (SpanStatusCode) {
    SpanStatusCode[SpanStatusCode.UNSET = 0] = "UNSET", SpanStatusCode[SpanStatusCode.OK = 1] = "OK", SpanStatusCode[SpanStatusCode.ERROR = 2] = "ERROR";
  })(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
});
var dH = T(sg => {
  "use strict";

  Object.defineProperty(sg, "__esModule", {
    value: !0
  });
  sg.validateValue = sg.validateKey = void 0;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]",
    VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`,
    VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`,
    VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`),
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/,
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  __name(validateKey, "validateKey");
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  __name(validateValue, "validateValue");
  exports.validateValue = validateValue;
});
var _H = T(z6 => {
  "use strict";

  Object.defineProperty(z6, "__esModule", {
    value: !0
  });
  z6.TraceStateImpl = void 0;
  var tracestate_validators_1 = dH(),
    MAX_TRACE_STATE_ITEMS = 32,
    MAX_TRACE_STATE_LEN = 512,
    LIST_MEMBERS_SEPARATOR = ",",
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=",
    TraceStateImpl = class _TraceStateImpl {
      static {
        __name(this, "TraceStateImpl");
      }
      constructor(rawTraceState) {
        this._internalState = new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          let listMember = part.trim(),
            i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            let key = listMember.slice(0, i),
              value = listMember.slice(i + 1, part.length);
            (0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceStateImpl();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
  exports.TraceStateImpl = TraceStateImpl;
});
var yH = T(W6 => {
  "use strict";

  Object.defineProperty(W6, "__esModule", {
    value: !0
  });
  W6.createTraceState = void 0;
  var tracestate_impl_1 = _H();
  function createTraceState(rawTraceState) {
    return new tracestate_impl_1.TraceStateImpl(rawTraceState);
  }
  __name(createTraceState, "createTraceState");
  exports.createTraceState = createTraceState;
});
var vH = T(K6 => {
  "use strict";

  Object.defineProperty(K6, "__esModule", {
    value: !0
  });
  K6.context = void 0;
  var context_1 = _2();
  exports.context = context_1.ContextAPI.getInstance();
});
var xH = T(X6 => {
  "use strict";

  Object.defineProperty(X6, "__esModule", {
    value: !0
  });
  X6.diag = void 0;
  var diag_1 = rm();
  exports.diag = diag_1.DiagAPI.instance();
});
var bH = T(og => {
  "use strict";

  Object.defineProperty(og, "__esModule", {
    value: !0
  });
  og.NOOP_METER_PROVIDER = og.NoopMeterProvider = void 0;
  var NoopMeter_1 = sw(),
    NoopMeterProvider = class {
      static {
        __name(this, "NoopMeterProvider");
      }
      getMeter(_name, _version, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
  exports.NoopMeterProvider = NoopMeterProvider;
  exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
});
var CH = T(Q6 => {
  "use strict";

  Object.defineProperty(Q6, "__esModule", {
    value: !0
  });
  Q6.MetricsAPI = void 0;
  var NoopMeterProvider_1 = bH(),
    global_utils_1 = tm(),
    diag_1 = rm(),
    API_NAME = "metrics",
    MetricsAPI = class _MetricsAPI {
      static {
        __name(this, "MetricsAPI");
      }
      constructor() {}
      static getInstance() {
        return this._instance || (this._instance = new _MetricsAPI()), this._instance;
      }
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      getMeter(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      }
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
  exports.MetricsAPI = MetricsAPI;
});
var TH = T(Z6 => {
  "use strict";

  Object.defineProperty(Z6, "__esModule", {
    value: !0
  });
  Z6.metrics = void 0;
  var metrics_1 = CH();
  exports.metrics = metrics_1.MetricsAPI.getInstance();
});
var SH = T(J6 => {
  "use strict";

  Object.defineProperty(J6, "__esModule", {
    value: !0
  });
  J6.NoopTextMapPropagator = void 0;
  var NoopTextMapPropagator = class {
    static {
      __name(this, "NoopTextMapPropagator");
    }
    inject(_context, _carrier) {}
    extract(context, _carrier) {
      return context;
    }
    fields() {
      return [];
    }
  };
  exports.NoopTextMapPropagator = NoopTextMapPropagator;
});
var IH = T(bf => {
  "use strict";

  Object.defineProperty(bf, "__esModule", {
    value: !0
  });
  bf.deleteBaggage = bf.setBaggage = bf.getActiveBaggage = bf.getBaggage = void 0;
  var context_1 = _2(),
    context_2 = h2(),
    BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
  function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || void 0;
  }
  __name(getBaggage, "getBaggage");
  exports.getBaggage = getBaggage;
  function getActiveBaggage() {
    return getBaggage(context_1.ContextAPI.getInstance().active());
  }
  __name(getActiveBaggage, "getActiveBaggage");
  exports.getActiveBaggage = getActiveBaggage;
  function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
  }
  __name(setBaggage, "setBaggage");
  exports.setBaggage = setBaggage;
  function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
  }
  __name(deleteBaggage, "deleteBaggage");
  exports.deleteBaggage = deleteBaggage;
});
var RH = T(tv => {
  "use strict";

  Object.defineProperty(tv, "__esModule", {
    value: !0
  });
  tv.PropagationAPI = void 0;
  var global_utils_1 = tm(),
    NoopTextMapPropagator_1 = SH(),
    TextMapPropagator_1 = ow(),
    context_helpers_1 = IH(),
    utils_1 = tw(),
    diag_1 = rm(),
    API_NAME = "propagation",
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator(),
    PropagationAPI = class _PropagationAPI {
      static {
        __name(this, "PropagationAPI");
      }
      constructor() {
        this.createBaggage = utils_1.createBaggage, this.getBaggage = context_helpers_1.getBaggage, this.getActiveBaggage = context_helpers_1.getActiveBaggage, this.setBaggage = context_helpers_1.setBaggage, this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      static getInstance() {
        return this._instance || (this._instance = new _PropagationAPI()), this._instance;
      }
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context, carrier, setter);
      }
      extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context, carrier, getter);
      }
      fields() {
        return this._getGlobalPropagator().fields();
      }
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
  exports.PropagationAPI = PropagationAPI;
});
var NH = T(rv => {
  "use strict";

  Object.defineProperty(rv, "__esModule", {
    value: !0
  });
  rv.propagation = void 0;
  var propagation_1 = RH();
  exports.propagation = propagation_1.PropagationAPI.getInstance();
});
var DH = T(nv => {
  "use strict";

  Object.defineProperty(nv, "__esModule", {
    value: !0
  });
  nv.TraceAPI = void 0;
  var global_utils_1 = tm(),
    ProxyTracerProvider_1 = Tw(),
    spancontext_utils_1 = j6(),
    context_utils_1 = hw(),
    diag_1 = rm(),
    API_NAME = "trace",
    TraceAPI = class _TraceAPI {
      static {
        __name(this, "TraceAPI");
      }
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider(), this.wrapSpanContext = spancontext_utils_1.wrapSpanContext, this.isSpanContextValid = spancontext_utils_1.isSpanContextValid, this.deleteSpan = context_utils_1.deleteSpan, this.getSpan = context_utils_1.getSpan, this.getActiveSpan = context_utils_1.getActiveSpan, this.getSpanContext = context_utils_1.getSpanContext, this.setSpan = context_utils_1.setSpan, this.setSpanContext = context_utils_1.setSpanContext;
      }
      static getInstance() {
        return this._instance || (this._instance = new _TraceAPI()), this._instance;
      }
      setGlobalTracerProvider(provider) {
        let success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        return success && this._proxyTracerProvider.setDelegate(provider), success;
      }
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      getTracer(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      }
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance()), this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
  exports.TraceAPI = TraceAPI;
});
var MH = T(iv => {
  "use strict";

  Object.defineProperty(iv, "__esModule", {
    value: !0
  });
  iv.trace = void 0;
  var trace_1 = DH();
  exports.trace = trace_1.TraceAPI.getInstance();
});
var ha = T(Ms => {
  "use strict";

  Object.defineProperty(Ms, "__esModule", {
    value: !0
  });
  Ms.trace = Ms.propagation = Ms.metrics = Ms.diag = Ms.context = Ms.INVALID_SPAN_CONTEXT = Ms.INVALID_TRACEID = Ms.INVALID_SPANID = Ms.isValidSpanId = Ms.isValidTraceId = Ms.isSpanContextValid = Ms.createTraceState = Ms.TraceFlags = Ms.SpanStatusCode = Ms.SpanKind = Ms.SamplingDecision = Ms.ProxyTracerProvider = Ms.ProxyTracer = Ms.defaultTextMapSetter = Ms.defaultTextMapGetter = Ms.ValueType = Ms.createNoopMeter = Ms.DiagLogLevel = Ms.DiagConsoleLogger = Ms.ROOT_CONTEXT = Ms.createContextKey = Ms.baggageEntryMetadataFromString = void 0;
  var utils_1 = tw();
  Object.defineProperty(exports, "baggageEntryMetadataFromString", {
    enumerable: !0,
    get: function () {
      return utils_1.baggageEntryMetadataFromString;
    }
  });
  var context_1 = h2();
  Object.defineProperty(exports, "createContextKey", {
    enumerable: !0,
    get: function () {
      return context_1.createContextKey;
    }
  });
  Object.defineProperty(exports, "ROOT_CONTEXT", {
    enumerable: !0,
    get: function () {
      return context_1.ROOT_CONTEXT;
    }
  });
  var consoleLogger_1 = Jj();
  Object.defineProperty(exports, "DiagConsoleLogger", {
    enumerable: !0,
    get: function () {
      return consoleLogger_1.DiagConsoleLogger;
    }
  });
  var types_1 = E6();
  Object.defineProperty(exports, "DiagLogLevel", {
    enumerable: !0,
    get: function () {
      return types_1.DiagLogLevel;
    }
  });
  var NoopMeter_1 = sw();
  Object.defineProperty(exports, "createNoopMeter", {
    enumerable: !0,
    get: function () {
      return NoopMeter_1.createNoopMeter;
    }
  });
  var Metric_1 = eH();
  Object.defineProperty(exports, "ValueType", {
    enumerable: !0,
    get: function () {
      return Metric_1.ValueType;
    }
  });
  var TextMapPropagator_1 = ow();
  Object.defineProperty(exports, "defaultTextMapGetter", {
    enumerable: !0,
    get: function () {
      return TextMapPropagator_1.defaultTextMapGetter;
    }
  });
  Object.defineProperty(exports, "defaultTextMapSetter", {
    enumerable: !0,
    get: function () {
      return TextMapPropagator_1.defaultTextMapSetter;
    }
  });
  var ProxyTracer_1 = bw();
  Object.defineProperty(exports, "ProxyTracer", {
    enumerable: !0,
    get: function () {
      return ProxyTracer_1.ProxyTracer;
    }
  });
  var ProxyTracerProvider_1 = Tw();
  Object.defineProperty(exports, "ProxyTracerProvider", {
    enumerable: !0,
    get: function () {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    }
  });
  var SamplingResult_1 = cH();
  Object.defineProperty(exports, "SamplingDecision", {
    enumerable: !0,
    get: function () {
      return SamplingResult_1.SamplingDecision;
    }
  });
  var span_kind_1 = uH();
  Object.defineProperty(exports, "SpanKind", {
    enumerable: !0,
    get: function () {
      return span_kind_1.SpanKind;
    }
  });
  var status_1 = fH();
  Object.defineProperty(exports, "SpanStatusCode", {
    enumerable: !0,
    get: function () {
      return status_1.SpanStatusCode;
    }
  });
  var trace_flags_1 = fw();
  Object.defineProperty(exports, "TraceFlags", {
    enumerable: !0,
    get: function () {
      return trace_flags_1.TraceFlags;
    }
  });
  var utils_2 = yH();
  Object.defineProperty(exports, "createTraceState", {
    enumerable: !0,
    get: function () {
      return utils_2.createTraceState;
    }
  });
  var spancontext_utils_1 = j6();
  Object.defineProperty(exports, "isSpanContextValid", {
    enumerable: !0,
    get: function () {
      return spancontext_utils_1.isSpanContextValid;
    }
  });
  Object.defineProperty(exports, "isValidTraceId", {
    enumerable: !0,
    get: function () {
      return spancontext_utils_1.isValidTraceId;
    }
  });
  Object.defineProperty(exports, "isValidSpanId", {
    enumerable: !0,
    get: function () {
      return spancontext_utils_1.isValidSpanId;
    }
  });
  var invalid_span_constants_1 = F6();
  Object.defineProperty(exports, "INVALID_SPANID", {
    enumerable: !0,
    get: function () {
      return invalid_span_constants_1.INVALID_SPANID;
    }
  });
  Object.defineProperty(exports, "INVALID_TRACEID", {
    enumerable: !0,
    get: function () {
      return invalid_span_constants_1.INVALID_TRACEID;
    }
  });
  Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", {
    enumerable: !0,
    get: function () {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    }
  });
  var context_api_1 = vH();
  Object.defineProperty(exports, "context", {
    enumerable: !0,
    get: function () {
      return context_api_1.context;
    }
  });
  var diag_api_1 = xH();
  Object.defineProperty(exports, "diag", {
    enumerable: !0,
    get: function () {
      return diag_api_1.diag;
    }
  });
  var metrics_api_1 = TH();
  Object.defineProperty(exports, "metrics", {
    enumerable: !0,
    get: function () {
      return metrics_api_1.metrics;
    }
  });
  var propagation_api_1 = NH();
  Object.defineProperty(exports, "propagation", {
    enumerable: !0,
    get: function () {
      return propagation_api_1.propagation;
    }
  });
  var trace_api_1 = MH();
  Object.defineProperty(exports, "trace", {
    enumerable: !0,
    get: function () {
      return trace_api_1.trace;
    }
  });
  exports.default = {
    context: context_api_1.context,
    diag: diag_api_1.diag,
    metrics: metrics_api_1.metrics,
    propagation: propagation_api_1.propagation,
    trace: trace_api_1.trace
  };
});
var E2 = T(Cp => {
  "use strict";

  Object.defineProperty(Cp, "__esModule", {
    value: !0
  });
  Cp.isTracingSuppressed = Cp.unsuppressTracing = Cp.suppressTracing = void 0;
  var api_1 = ha(),
    SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
  function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, !0);
  }
  __name(suppressTracing, "suppressTracing");
  exports.suppressTracing = suppressTracing;
  function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
  }
  __name(unsuppressTracing, "unsuppressTracing");
  exports.unsuppressTracing = unsuppressTracing;
  function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === !0;
  }
  __name(isTracingSuppressed, "isTracingSuppressed");
  exports.isTracingSuppressed = isTracingSuppressed;
});
var jw = T(ql => {
  "use strict";

  Object.defineProperty(ql, "__esModule", {
    value: !0
  });
  ql.BAGGAGE_MAX_TOTAL_LENGTH = ql.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = ql.BAGGAGE_MAX_NAME_VALUE_PAIRS = ql.BAGGAGE_HEADER = ql.BAGGAGE_ITEMS_SEPARATOR = ql.BAGGAGE_PROPERTIES_SEPARATOR = ql.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
  exports.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
  exports.BAGGAGE_PROPERTIES_SEPARATOR = ";";
  exports.BAGGAGE_ITEMS_SEPARATOR = ",";
  exports.BAGGAGE_HEADER = "baggage";
  exports.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
  exports.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
  exports.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
});
var Hw = T(Ef => {
  "use strict";

  Object.defineProperty(Ef, "__esModule", {
    value: !0
  });
  Ef.parseKeyPairsIntoRecord = Ef.parsePairKeyValue = Ef.getKeyPairs = Ef.serializeKeyPairs = void 0;
  var api_1 = ha(),
    constants_1 = jw();
  function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
      let value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
      return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, "");
  }
  __name(serializeKeyPairs, "serializeKeyPairs");
  exports.serializeKeyPairs = serializeKeyPairs;
  function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
      let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
      return value.metadata !== void 0 && (entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString()), entry;
    });
  }
  __name(getKeyPairs, "getKeyPairs");
  exports.getKeyPairs = getKeyPairs;
  function parsePairKeyValue(entry) {
    let valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0) return;
    let keyPairPart = valueProps.shift();
    if (!keyPairPart) return;
    let separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0) return;
    let key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim()),
      value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim()),
      metadata;
    return valueProps.length > 0 && (metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR))), {
      key: key,
      value: value,
      metadata: metadata
    };
  }
  __name(parsePairKeyValue, "parsePairKeyValue");
  exports.parsePairKeyValue = parsePairKeyValue;
  function parseKeyPairsIntoRecord(value) {
    return typeof value != "string" || value.length === 0 ? {} : value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map(entry => parsePairKeyValue(entry)).filter(keyPair => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => (headers[keyPair.key] = keyPair.value, headers), {});
  }
  __name(parseKeyPairsIntoRecord, "parseKeyPairsIntoRecord");
  exports.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
});
var GH = T(sv => {
  "use strict";

  Object.defineProperty(sv, "__esModule", {
    value: !0
  });
  sv.W3CBaggagePropagator = void 0;
  var api_1 = ha(),
    suppress_tracing_1 = E2(),
    constants_1 = jw(),
    utils_1 = Hw(),
    W3CBaggagePropagator = class {
      static {
        __name(this, "W3CBaggagePropagator");
      }
      inject(context, carrier, setter) {
        let baggage = api_1.propagation.getBaggage(context);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context)) return;
        let keyPairs = (0, utils_1.getKeyPairs)(baggage).filter(pair => pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS),
          headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        headerValue.length > 0 && setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
      extract(context, carrier, getter) {
        let headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER),
          baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString) return context;
        let baggage = {};
        return baggageString.length === 0 || (baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach(entry => {
          let keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            let baggageEntry = {
              value: keyPair.value
            };
            keyPair.metadata && (baggageEntry.metadata = keyPair.metadata), baggage[keyPair.key] = baggageEntry;
          }
        }), Object.entries(baggage).length === 0) ? context : api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
  exports.W3CBaggagePropagator = W3CBaggagePropagator;
});
var zH = T(ov => {
  "use strict";

  Object.defineProperty(ov, "__esModule", {
    value: !0
  });
  ov.AnchoredClock = void 0;
  var AnchoredClock = class {
    static {
      __name(this, "AnchoredClock");
    }
    constructor(systemClock, monotonicClock) {
      this._monotonicClock = monotonicClock, this._epochMillis = systemClock.now(), this._performanceMillis = monotonicClock.now();
    }
    now() {
      let delta = this._monotonicClock.now() - this._performanceMillis;
      return this._epochMillis + delta;
    }
  };
  exports.AnchoredClock = AnchoredClock;
});
var QH = T(Tp => {
  "use strict";

  Object.defineProperty(Tp, "__esModule", {
    value: !0
  });
  Tp.isAttributeValue = Tp.isAttributeKey = Tp.sanitizeAttributes = void 0;
  var api_1 = ha();
  function sanitizeAttributes(attributes) {
    let out = {};
    if (typeof attributes != "object" || attributes == null) return out;
    for (let [key, val] of Object.entries(attributes)) {
      if (!isAttributeKey(key)) {
        api_1.diag.warn(`Invalid attribute key: ${key}`);
        continue;
      }
      if (!isAttributeValue(val)) {
        api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
        continue;
      }
      Array.isArray(val) ? out[key] = val.slice() : out[key] = val;
    }
    return out;
  }
  __name(sanitizeAttributes, "sanitizeAttributes");
  exports.sanitizeAttributes = sanitizeAttributes;
  function isAttributeKey(key) {
    return typeof key == "string" && key.length > 0;
  }
  __name(isAttributeKey, "isAttributeKey");
  exports.isAttributeKey = isAttributeKey;
  function isAttributeValue(val) {
    return val == null ? !0 : Array.isArray(val) ? isHomogeneousAttributeValueArray(val) : isValidPrimitiveAttributeValue(val);
  }
  __name(isAttributeValue, "isAttributeValue");
  exports.isAttributeValue = isAttributeValue;
  function isHomogeneousAttributeValueArray(arr) {
    let type;
    for (let element of arr) if (element != null) {
      if (!type) {
        if (isValidPrimitiveAttributeValue(element)) {
          type = typeof element;
          continue;
        }
        return !1;
      }
      if (typeof element !== type) return !1;
    }
    return !0;
  }
  __name(isHomogeneousAttributeValueArray, "isHomogeneousAttributeValueArray");
  function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
      case "number":
      case "boolean":
      case "string":
        return !0;
    }
    return !1;
  }
  __name(isValidPrimitiveAttributeValue, "isValidPrimitiveAttributeValue");
});
var Ww = T(av => {
  "use strict";

  Object.defineProperty(av, "__esModule", {
    value: !0
  });
  av.loggingErrorHandler = void 0;
  var api_1 = ha();
  function loggingErrorHandler() {
    return ex => {
      api_1.diag.error(stringifyException(ex));
    };
  }
  __name(loggingErrorHandler, "loggingErrorHandler");
  exports.loggingErrorHandler = loggingErrorHandler;
  function stringifyException(ex) {
    return typeof ex == "string" ? ex : JSON.stringify(flattenException(ex));
  }
  __name(stringifyException, "stringifyException");
  function flattenException(ex) {
    let result = {},
      current = ex;
    for (; current !== null;) Object.getOwnPropertyNames(current).forEach(propertyName => {
      if (result[propertyName]) return;
      let value = current[propertyName];
      value && (result[propertyName] = String(value));
    }), current = Object.getPrototypeOf(current);
    return result;
  }
  __name(flattenException, "flattenException");
});
var Kw = T(lg => {
  "use strict";

  Object.defineProperty(lg, "__esModule", {
    value: !0
  });
  lg.globalErrorHandler = lg.setGlobalErrorHandler = void 0;
  var logging_error_handler_1 = Ww(),
    delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
  function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
  }
  __name(setGlobalErrorHandler, "setGlobalErrorHandler");
  exports.setGlobalErrorHandler = setGlobalErrorHandler;
  function globalErrorHandler(ex) {
    try {
      delegateHandler(ex);
    } catch {}
  }
  __name(globalErrorHandler, "globalErrorHandler");
  exports.globalErrorHandler = globalErrorHandler;
});
var Xw = T(C2 => {
  "use strict";

  Object.defineProperty(C2, "__esModule", {
    value: !0
  });
  C2.TracesSamplerValues = void 0;
  var TracesSamplerValues;
  (function (TracesSamplerValues) {
    TracesSamplerValues.AlwaysOff = "always_off", TracesSamplerValues.AlwaysOn = "always_on", TracesSamplerValues.ParentBasedAlwaysOff = "parentbased_always_off", TracesSamplerValues.ParentBasedAlwaysOn = "parentbased_always_on", TracesSamplerValues.ParentBasedTraceIdRatio = "parentbased_traceidratio", TracesSamplerValues.TraceIdRatio = "traceidratio";
  })(TracesSamplerValues = exports.TracesSamplerValues || (exports.TracesSamplerValues = {}));
});
var JH = T(lv => {
  "use strict";

  Object.defineProperty(lv, "__esModule", {
    value: !0
  });
  lv._globalThis = void 0;
  exports._globalThis = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {};
});
var Qw = T(p0 => {
  "use strict";

  Object.defineProperty(p0, "__esModule", {
    value: !0
  });
  p0.getEnvWithoutDefaults = p0.parseEnvironment = p0.DEFAULT_ENVIRONMENT = p0.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = p0.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = p0.DEFAULT_ATTRIBUTE_COUNT_LIMIT = p0.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
  var api_1 = ha(),
    sampling_1 = Xw(),
    globalThis_1 = JH(),
    DEFAULT_LIST_SEPARATOR = ",",
    ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
  function isEnvVarABoolean(key) {
    return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
  }
  __name(isEnvVarABoolean, "isEnvVarABoolean");
  var ENVIRONMENT_NUMBERS_KEYS = ["OTEL_BSP_EXPORT_TIMEOUT", "OTEL_BSP_MAX_EXPORT_BATCH_SIZE", "OTEL_BSP_MAX_QUEUE_SIZE", "OTEL_BSP_SCHEDULE_DELAY", "OTEL_BLRP_EXPORT_TIMEOUT", "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE", "OTEL_BLRP_MAX_QUEUE_SIZE", "OTEL_BLRP_SCHEDULE_DELAY", "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_SPAN_LINK_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", "OTEL_EXPORTER_OTLP_TIMEOUT", "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT", "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT", "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT", "OTEL_EXPORTER_JAEGER_AGENT_PORT"];
  function isEnvVarANumber(key) {
    return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
  }
  __name(isEnvVarANumber, "isEnvVarANumber");
  var ENVIRONMENT_LISTS_KEYS = ["OTEL_NO_PATCH_MODULES", "OTEL_PROPAGATORS"];
  function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
  }
  __name(isEnvVarAList, "isEnvVarAList");
  exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0;
  exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
  exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
  exports.DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: !1,
    CONTAINER_NAME: "",
    ECS_CONTAINER_METADATA_URI_V4: "",
    ECS_CONTAINER_METADATA_URI: "",
    HOSTNAME: "",
    KUBERNETES_SERVICE_HOST: "",
    NAMESPACE: "",
    OTEL_BSP_EXPORT_TIMEOUT: 3e4,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5e3,
    OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5e3,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: "",
    OTEL_EXPORTER_JAEGER_PASSWORD: "",
    OTEL_EXPORTER_JAEGER_USER: "",
    OTEL_EXPORTER_OTLP_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
    OTEL_EXPORTER_OTLP_HEADERS: "",
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
    OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
    OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ["tracecontext", "baggage"],
    OTEL_RESOURCE_ATTRIBUTES: "",
    OTEL_SERVICE_NAME: "",
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: "",
    OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: "",
    OTEL_LOGS_EXPORTER: "",
    OTEL_EXPORTER_OTLP_INSECURE: "",
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
    OTEL_EXPORTER_OTLP_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
    OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
    OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
  };
  function parseBoolean(key, environment, values) {
    if (typeof values[key] > "u") return;
    let value = String(values[key]);
    environment[key] = value.toLowerCase() === "true";
  }
  __name(parseBoolean, "parseBoolean");
  function parseNumber(name, environment, values, min = -1 / 0, max = 1 / 0) {
    if (typeof values[name] < "u") {
      let value = Number(values[name]);
      isNaN(value) || (value < min ? environment[name] = min : value > max ? environment[name] = max : environment[name] = value);
    }
  }
  __name(parseNumber, "parseNumber");
  function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
    let givenValue = input[name];
    typeof givenValue == "string" && (output[name] = givenValue.split(separator).map(v => v.trim()));
  }
  __name(parseStringList, "parseStringList");
  var logLevelMap = {
    ALL: api_1.DiagLogLevel.ALL,
    VERBOSE: api_1.DiagLogLevel.VERBOSE,
    DEBUG: api_1.DiagLogLevel.DEBUG,
    INFO: api_1.DiagLogLevel.INFO,
    WARN: api_1.DiagLogLevel.WARN,
    ERROR: api_1.DiagLogLevel.ERROR,
    NONE: api_1.DiagLogLevel.NONE
  };
  function setLogLevelFromEnv(key, environment, values) {
    let value = values[key];
    if (typeof value == "string") {
      let theLevel = logLevelMap[value.toUpperCase()];
      theLevel != null && (environment[key] = theLevel);
    }
  }
  __name(setLogLevelFromEnv, "setLogLevelFromEnv");
  function parseEnvironment(values) {
    let environment = {};
    for (let env in exports.DEFAULT_ENVIRONMENT) {
      let key = env;
      switch (key) {
        case "OTEL_LOG_LEVEL":
          setLogLevelFromEnv(key, environment, values);
          break;
        default:
          if (isEnvVarABoolean(key)) parseBoolean(key, environment, values);else if (isEnvVarANumber(key)) parseNumber(key, environment, values);else if (isEnvVarAList(key)) parseStringList(key, environment, values);else {
            let value = values[key];
            typeof value < "u" && value !== null && (environment[key] = String(value));
          }
      }
    }
    return environment;
  }
  __name(parseEnvironment, "parseEnvironment");
  exports.parseEnvironment = parseEnvironment;
  function getEnvWithoutDefaults() {
    return typeof process < "u" && process && process.env ? parseEnvironment(process.env) : parseEnvironment(globalThis_1._globalThis);
  }
  __name(getEnvWithoutDefaults, "getEnvWithoutDefaults");
  exports.getEnvWithoutDefaults = getEnvWithoutDefaults;
});
var t$ = T(cv => {
  "use strict";

  Object.defineProperty(cv, "__esModule", {
    value: !0
  });
  cv.getEnv = void 0;
  var os = require("os"),
    environment_1 = Qw();
  function getEnv() {
    let processEnv = (0, environment_1.parseEnvironment)(process.env);
    return Object.assign({
      HOSTNAME: os.hostname()
    }, environment_1.DEFAULT_ENVIRONMENT, processEnv);
  }
  __name(getEnv, "getEnv");
  exports.getEnv = getEnv;
});
var r$ = T(uv => {
  "use strict";

  Object.defineProperty(uv, "__esModule", {
    value: !0
  });
  uv._globalThis = void 0;
  exports._globalThis = typeof globalThis == "object" ? globalThis : global;
});
var i$ = T(fv => {
  "use strict";

  Object.defineProperty(fv, "__esModule", {
    value: !0
  });
  fv.hexToBase64 = void 0;
  function intValue(charCode) {
    return charCode >= 48 && charCode <= 57 ? charCode - 48 : charCode >= 97 && charCode <= 102 ? charCode - 87 : charCode - 55;
  }
  __name(intValue, "intValue");
  var buf8 = Buffer.alloc(8),
    buf16 = Buffer.alloc(16);
  function hexToBase64(hexStr) {
    let buf;
    hexStr.length === 16 ? buf = buf8 : hexStr.length === 32 ? buf = buf16 : buf = Buffer.alloc(hexStr.length / 2);
    let offset = 0;
    for (let i = 0; i < hexStr.length; i += 2) {
      let hi = intValue(hexStr.charCodeAt(i)),
        lo = intValue(hexStr.charCodeAt(i + 1));
      buf.writeUInt8(hi << 4 | lo, offset++);
    }
    return buf.toString("base64");
  }
  __name(hexToBase64, "hexToBase64");
  exports.hexToBase64 = hexToBase64;
});
var a$ = T(pv => {
  "use strict";

  Object.defineProperty(pv, "__esModule", {
    value: !0
  });
  pv.RandomIdGenerator = void 0;
  var SPAN_ID_BYTES = 8,
    TRACE_ID_BYTES = 16,
    RandomIdGenerator = class {
      static {
        __name(this, "RandomIdGenerator");
      }
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES), this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return __name(function () {
      for (let i = 0; i < bytes / 4; i++) SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
      for (let i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++) i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
      return SHARED_BUFFER.toString("hex", 0, bytes);
    }, "generateId");
  }
  __name(getIdGenerator, "getIdGenerator");
});
var l$ = T(mv => {
  "use strict";

  Object.defineProperty(mv, "__esModule", {
    value: !0
  });
  mv.otperformance = void 0;
  var perf_hooks_1 = require("perf_hooks");
  exports.otperformance = perf_hooks_1.performance;
});
var gv = T(hv => {
  "use strict";

  Object.defineProperty(hv, "__esModule", {
    value: !0
  });
  hv.VERSION = void 0;
  exports.VERSION = "1.15.2";
});
var c$ = T(Ha => {
  "use strict";

  Object.defineProperty(Ha, "__esModule", {
    value: !0
  });
  Ha.MessageTypeValues = Ha.RpcGrpcStatusCodeValues = Ha.MessagingOperationValues = Ha.MessagingDestinationKindValues = Ha.HttpFlavorValues = Ha.NetHostConnectionSubtypeValues = Ha.NetHostConnectionTypeValues = Ha.NetTransportValues = Ha.FaasInvokedProviderValues = Ha.FaasDocumentOperationValues = Ha.FaasTriggerValues = Ha.DbCassandraConsistencyLevelValues = Ha.DbSystemValues = Ha.SemanticAttributes = void 0;
  exports.SemanticAttributes = {
    AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
    DB_SYSTEM: "db.system",
    DB_CONNECTION_STRING: "db.connection_string",
    DB_USER: "db.user",
    DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
    DB_NAME: "db.name",
    DB_STATEMENT: "db.statement",
    DB_OPERATION: "db.operation",
    DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
    DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
    DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
    DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
    DB_CASSANDRA_TABLE: "db.cassandra.table",
    DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
    DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
    DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
    DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
    DB_HBASE_NAMESPACE: "db.hbase.namespace",
    DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
    DB_MONGODB_COLLECTION: "db.mongodb.collection",
    DB_SQL_TABLE: "db.sql.table",
    EXCEPTION_TYPE: "exception.type",
    EXCEPTION_MESSAGE: "exception.message",
    EXCEPTION_STACKTRACE: "exception.stacktrace",
    EXCEPTION_ESCAPED: "exception.escaped",
    FAAS_TRIGGER: "faas.trigger",
    FAAS_EXECUTION: "faas.execution",
    FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
    FAAS_DOCUMENT_OPERATION: "faas.document.operation",
    FAAS_DOCUMENT_TIME: "faas.document.time",
    FAAS_DOCUMENT_NAME: "faas.document.name",
    FAAS_TIME: "faas.time",
    FAAS_CRON: "faas.cron",
    FAAS_COLDSTART: "faas.coldstart",
    FAAS_INVOKED_NAME: "faas.invoked_name",
    FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
    FAAS_INVOKED_REGION: "faas.invoked_region",
    NET_TRANSPORT: "net.transport",
    NET_PEER_IP: "net.peer.ip",
    NET_PEER_PORT: "net.peer.port",
    NET_PEER_NAME: "net.peer.name",
    NET_HOST_IP: "net.host.ip",
    NET_HOST_PORT: "net.host.port",
    NET_HOST_NAME: "net.host.name",
    NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
    NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
    NET_HOST_CARRIER_NAME: "net.host.carrier.name",
    NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
    NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
    NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
    PEER_SERVICE: "peer.service",
    ENDUSER_ID: "enduser.id",
    ENDUSER_ROLE: "enduser.role",
    ENDUSER_SCOPE: "enduser.scope",
    THREAD_ID: "thread.id",
    THREAD_NAME: "thread.name",
    CODE_FUNCTION: "code.function",
    CODE_NAMESPACE: "code.namespace",
    CODE_FILEPATH: "code.filepath",
    CODE_LINENO: "code.lineno",
    HTTP_METHOD: "http.method",
    HTTP_URL: "http.url",
    HTTP_TARGET: "http.target",
    HTTP_HOST: "http.host",
    HTTP_SCHEME: "http.scheme",
    HTTP_STATUS_CODE: "http.status_code",
    HTTP_FLAVOR: "http.flavor",
    HTTP_USER_AGENT: "http.user_agent",
    HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
    HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
    HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
    HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
    HTTP_SERVER_NAME: "http.server_name",
    HTTP_ROUTE: "http.route",
    HTTP_CLIENT_IP: "http.client_ip",
    AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
    AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
    AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
    AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
    AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
    AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
    AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
    AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
    AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
    AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
    AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
    AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
    AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
    AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
    AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
    AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
    AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
    AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
    AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
    AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
    AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
    MESSAGING_SYSTEM: "messaging.system",
    MESSAGING_DESTINATION: "messaging.destination",
    MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
    MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
    MESSAGING_PROTOCOL: "messaging.protocol",
    MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
    MESSAGING_URL: "messaging.url",
    MESSAGING_MESSAGE_ID: "messaging.message_id",
    MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
    MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
    MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
    MESSAGING_OPERATION: "messaging.operation",
    MESSAGING_CONSUMER_ID: "messaging.consumer_id",
    MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
    MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
    MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
    MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
    MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
    MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
    RPC_SYSTEM: "rpc.system",
    RPC_SERVICE: "rpc.service",
    RPC_METHOD: "rpc.method",
    RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
    RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
    RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
    RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
    RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
    MESSAGE_TYPE: "message.type",
    MESSAGE_ID: "message.id",
    MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
    MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
  };
  exports.DbSystemValues = {
    OTHER_SQL: "other_sql",
    MSSQL: "mssql",
    MYSQL: "mysql",
    ORACLE: "oracle",
    DB2: "db2",
    POSTGRESQL: "postgresql",
    REDSHIFT: "redshift",
    HIVE: "hive",
    CLOUDSCAPE: "cloudscape",
    HSQLDB: "hsqldb",
    PROGRESS: "progress",
    MAXDB: "maxdb",
    HANADB: "hanadb",
    INGRES: "ingres",
    FIRSTSQL: "firstsql",
    EDB: "edb",
    CACHE: "cache",
    ADABAS: "adabas",
    FIREBIRD: "firebird",
    DERBY: "derby",
    FILEMAKER: "filemaker",
    INFORMIX: "informix",
    INSTANTDB: "instantdb",
    INTERBASE: "interbase",
    MARIADB: "mariadb",
    NETEZZA: "netezza",
    PERVASIVE: "pervasive",
    POINTBASE: "pointbase",
    SQLITE: "sqlite",
    SYBASE: "sybase",
    TERADATA: "teradata",
    VERTICA: "vertica",
    H2: "h2",
    COLDFUSION: "coldfusion",
    CASSANDRA: "cassandra",
    HBASE: "hbase",
    MONGODB: "mongodb",
    REDIS: "redis",
    COUCHBASE: "couchbase",
    COUCHDB: "couchdb",
    COSMOSDB: "cosmosdb",
    DYNAMODB: "dynamodb",
    NEO4J: "neo4j",
    GEODE: "geode",
    ELASTICSEARCH: "elasticsearch",
    MEMCACHED: "memcached",
    COCKROACHDB: "cockroachdb"
  };
  exports.DbCassandraConsistencyLevelValues = {
    ALL: "all",
    EACH_QUORUM: "each_quorum",
    QUORUM: "quorum",
    LOCAL_QUORUM: "local_quorum",
    ONE: "one",
    TWO: "two",
    THREE: "three",
    LOCAL_ONE: "local_one",
    ANY: "any",
    SERIAL: "serial",
    LOCAL_SERIAL: "local_serial"
  };
  exports.FaasTriggerValues = {
    DATASOURCE: "datasource",
    HTTP: "http",
    PUBSUB: "pubsub",
    TIMER: "timer",
    OTHER: "other"
  };
  exports.FaasDocumentOperationValues = {
    INSERT: "insert",
    EDIT: "edit",
    DELETE: "delete"
  };
  exports.FaasInvokedProviderValues = {
    ALIBABA_CLOUD: "alibaba_cloud",
    AWS: "aws",
    AZURE: "azure",
    GCP: "gcp"
  };
  exports.NetTransportValues = {
    IP_TCP: "ip_tcp",
    IP_UDP: "ip_udp",
    IP: "ip",
    UNIX: "unix",
    PIPE: "pipe",
    INPROC: "inproc",
    OTHER: "other"
  };
  exports.NetHostConnectionTypeValues = {
    WIFI: "wifi",
    WIRED: "wired",
    CELL: "cell",
    UNAVAILABLE: "unavailable",
    UNKNOWN: "unknown"
  };
  exports.NetHostConnectionSubtypeValues = {
    GPRS: "gprs",
    EDGE: "edge",
    UMTS: "umts",
    CDMA: "cdma",
    EVDO_0: "evdo_0",
    EVDO_A: "evdo_a",
    CDMA2000_1XRTT: "cdma2000_1xrtt",
    HSDPA: "hsdpa",
    HSUPA: "hsupa",
    HSPA: "hspa",
    IDEN: "iden",
    EVDO_B: "evdo_b",
    LTE: "lte",
    EHRPD: "ehrpd",
    HSPAP: "hspap",
    GSM: "gsm",
    TD_SCDMA: "td_scdma",
    IWLAN: "iwlan",
    NR: "nr",
    NRNSA: "nrnsa",
    LTE_CA: "lte_ca"
  };
  exports.HttpFlavorValues = {
    HTTP_1_0: "1.0",
    HTTP_1_1: "1.1",
    HTTP_2_0: "2.0",
    SPDY: "SPDY",
    QUIC: "QUIC"
  };
  exports.MessagingDestinationKindValues = {
    QUEUE: "queue",
    TOPIC: "topic"
  };
  exports.MessagingOperationValues = {
    RECEIVE: "receive",
    PROCESS: "process"
  };
  exports.RpcGrpcStatusCodeValues = {
    OK: 0,
    CANCELLED: 1,
    UNKNOWN: 2,
    INVALID_ARGUMENT: 3,
    DEADLINE_EXCEEDED: 4,
    NOT_FOUND: 5,
    ALREADY_EXISTS: 6,
    PERMISSION_DENIED: 7,
    RESOURCE_EXHAUSTED: 8,
    FAILED_PRECONDITION: 9,
    ABORTED: 10,
    OUT_OF_RANGE: 11,
    UNIMPLEMENTED: 12,
    INTERNAL: 13,
    UNAVAILABLE: 14,
    DATA_LOSS: 15,
    UNAUTHENTICATED: 16
  };
  exports.MessageTypeValues = {
    SENT: "SENT",
    RECEIVED: "RECEIVED"
  };
});
var u$ = T(sm => {
  "use strict";

  var g3e = sm && sm.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    _3e = sm && sm.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && g3e(t, e, r);
    };
  Object.defineProperty(sm, "__esModule", {
    value: !0
  });
  __exportStar(c$(), exports);
});
var f$ = T(jl => {
  "use strict";

  Object.defineProperty(jl, "__esModule", {
    value: !0
  });
  jl.TelemetrySdkLanguageValues = jl.OsTypeValues = jl.HostArchValues = jl.AwsEcsLaunchtypeValues = jl.CloudPlatformValues = jl.CloudProviderValues = jl.SemanticResourceAttributes = void 0;
  exports.SemanticResourceAttributes = {
    CLOUD_PROVIDER: "cloud.provider",
    CLOUD_ACCOUNT_ID: "cloud.account.id",
    CLOUD_REGION: "cloud.region",
    CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
    CLOUD_PLATFORM: "cloud.platform",
    AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
    AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
    AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
    AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
    AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
    AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
    AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
    AWS_LOG_GROUP_NAMES: "aws.log.group.names",
    AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
    AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
    AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
    CONTAINER_NAME: "container.name",
    CONTAINER_ID: "container.id",
    CONTAINER_RUNTIME: "container.runtime",
    CONTAINER_IMAGE_NAME: "container.image.name",
    CONTAINER_IMAGE_TAG: "container.image.tag",
    DEPLOYMENT_ENVIRONMENT: "deployment.environment",
    DEVICE_ID: "device.id",
    DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
    DEVICE_MODEL_NAME: "device.model.name",
    FAAS_NAME: "faas.name",
    FAAS_ID: "faas.id",
    FAAS_VERSION: "faas.version",
    FAAS_INSTANCE: "faas.instance",
    FAAS_MAX_MEMORY: "faas.max_memory",
    HOST_ID: "host.id",
    HOST_NAME: "host.name",
    HOST_TYPE: "host.type",
    HOST_ARCH: "host.arch",
    HOST_IMAGE_NAME: "host.image.name",
    HOST_IMAGE_ID: "host.image.id",
    HOST_IMAGE_VERSION: "host.image.version",
    K8S_CLUSTER_NAME: "k8s.cluster.name",
    K8S_NODE_NAME: "k8s.node.name",
    K8S_NODE_UID: "k8s.node.uid",
    K8S_NAMESPACE_NAME: "k8s.namespace.name",
    K8S_POD_UID: "k8s.pod.uid",
    K8S_POD_NAME: "k8s.pod.name",
    K8S_CONTAINER_NAME: "k8s.container.name",
    K8S_REPLICASET_UID: "k8s.replicaset.uid",
    K8S_REPLICASET_NAME: "k8s.replicaset.name",
    K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
    K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
    K8S_STATEFULSET_UID: "k8s.statefulset.uid",
    K8S_STATEFULSET_NAME: "k8s.statefulset.name",
    K8S_DAEMONSET_UID: "k8s.daemonset.uid",
    K8S_DAEMONSET_NAME: "k8s.daemonset.name",
    K8S_JOB_UID: "k8s.job.uid",
    K8S_JOB_NAME: "k8s.job.name",
    K8S_CRONJOB_UID: "k8s.cronjob.uid",
    K8S_CRONJOB_NAME: "k8s.cronjob.name",
    OS_TYPE: "os.type",
    OS_DESCRIPTION: "os.description",
    OS_NAME: "os.name",
    OS_VERSION: "os.version",
    PROCESS_PID: "process.pid",
    PROCESS_EXECUTABLE_NAME: "process.executable.name",
    PROCESS_EXECUTABLE_PATH: "process.executable.path",
    PROCESS_COMMAND: "process.command",
    PROCESS_COMMAND_LINE: "process.command_line",
    PROCESS_COMMAND_ARGS: "process.command_args",
    PROCESS_OWNER: "process.owner",
    PROCESS_RUNTIME_NAME: "process.runtime.name",
    PROCESS_RUNTIME_VERSION: "process.runtime.version",
    PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
    SERVICE_NAME: "service.name",
    SERVICE_NAMESPACE: "service.namespace",
    SERVICE_INSTANCE_ID: "service.instance.id",
    SERVICE_VERSION: "service.version",
    TELEMETRY_SDK_NAME: "telemetry.sdk.name",
    TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
    TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
    TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
    WEBENGINE_NAME: "webengine.name",
    WEBENGINE_VERSION: "webengine.version",
    WEBENGINE_DESCRIPTION: "webengine.description"
  };
  exports.CloudProviderValues = {
    ALIBABA_CLOUD: "alibaba_cloud",
    AWS: "aws",
    AZURE: "azure",
    GCP: "gcp"
  };
  exports.CloudPlatformValues = {
    ALIBABA_CLOUD_ECS: "alibaba_cloud_ecs",
    ALIBABA_CLOUD_FC: "alibaba_cloud_fc",
    AWS_EC2: "aws_ec2",
    AWS_ECS: "aws_ecs",
    AWS_EKS: "aws_eks",
    AWS_LAMBDA: "aws_lambda",
    AWS_ELASTIC_BEANSTALK: "aws_elastic_beanstalk",
    AZURE_VM: "azure_vm",
    AZURE_CONTAINER_INSTANCES: "azure_container_instances",
    AZURE_AKS: "azure_aks",
    AZURE_FUNCTIONS: "azure_functions",
    AZURE_APP_SERVICE: "azure_app_service",
    GCP_COMPUTE_ENGINE: "gcp_compute_engine",
    GCP_CLOUD_RUN: "gcp_cloud_run",
    GCP_KUBERNETES_ENGINE: "gcp_kubernetes_engine",
    GCP_CLOUD_FUNCTIONS: "gcp_cloud_functions",
    GCP_APP_ENGINE: "gcp_app_engine"
  };
  exports.AwsEcsLaunchtypeValues = {
    EC2: "ec2",
    FARGATE: "fargate"
  };
  exports.HostArchValues = {
    AMD64: "amd64",
    ARM32: "arm32",
    ARM64: "arm64",
    IA64: "ia64",
    PPC32: "ppc32",
    PPC64: "ppc64",
    X86: "x86"
  };
  exports.OsTypeValues = {
    WINDOWS: "windows",
    LINUX: "linux",
    DARWIN: "darwin",
    FREEBSD: "freebsd",
    NETBSD: "netbsd",
    OPENBSD: "openbsd",
    DRAGONFLYBSD: "dragonflybsd",
    HPUX: "hpux",
    AIX: "aix",
    SOLARIS: "solaris",
    Z_OS: "z_os"
  };
  exports.TelemetrySdkLanguageValues = {
    CPP: "cpp",
    DOTNET: "dotnet",
    ERLANG: "erlang",
    GO: "go",
    JAVA: "java",
    NODEJS: "nodejs",
    PHP: "php",
    PYTHON: "python",
    RUBY: "ruby",
    WEBJS: "webjs"
  };
});
var d$ = T(om => {
  "use strict";

  var y3e = om && om.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    v3e = om && om.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && y3e(t, e, r);
    };
  Object.defineProperty(om, "__esModule", {
    value: !0
  });
  __exportStar(f$(), exports);
});
var Qu = T(wp => {
  "use strict";

  var x3e = wp && wp.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    p$ = wp && wp.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && x3e(t, e, r);
    };
  Object.defineProperty(wp, "__esModule", {
    value: !0
  });
  __exportStar(u$(), exports);
  __exportStar(d$(), exports);
});
var m$ = T(_v => {
  "use strict";

  Object.defineProperty(_v, "__esModule", {
    value: !0
  });
  _v.SDK_INFO = void 0;
  var version_1 = gv(),
    semantic_conventions_1 = Qu();
  exports.SDK_INFO = {
    [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
    [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
    [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
    [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
  };
});
var h$ = T(yv => {
  "use strict";

  Object.defineProperty(yv, "__esModule", {
    value: !0
  });
  yv.unrefTimer = void 0;
  function unrefTimer(timer) {
    timer.unref();
  }
  __name(unrefTimer, "unrefTimer");
  exports.unrefTimer = unrefTimer;
});
var g$ = T(Uc => {
  "use strict";

  var C3e = Uc && Uc.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    am = Uc && Uc.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && C3e(t, e, r);
    };
  Object.defineProperty(Uc, "__esModule", {
    value: !0
  });
  __exportStar(t$(), exports);
  __exportStar(r$(), exports);
  __exportStar(i$(), exports);
  __exportStar(a$(), exports);
  __exportStar(l$(), exports);
  __exportStar(m$(), exports);
  __exportStar(h$(), exports);
});
var Jw = T(lm => {
  "use strict";

  var T3e = lm && lm.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    S3e = lm && lm.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && T3e(t, e, r);
    };
  Object.defineProperty(lm, "__esModule", {
    value: !0
  });
  __exportStar(g$(), exports);
});
var x$ = T(n0 => {
  "use strict";

  Object.defineProperty(n0, "__esModule", {
    value: !0
  });
  n0.addHrTimes = n0.isTimeInput = n0.isTimeInputHrTime = n0.hrTimeToMicroseconds = n0.hrTimeToMilliseconds = n0.hrTimeToNanoseconds = n0.hrTimeToTimeStamp = n0.hrTimeDuration = n0.timeInputToHrTime = n0.hrTime = n0.getTimeOrigin = n0.millisToHrTime = void 0;
  var platform_1 = Jw(),
    NANOSECOND_DIGITS = 9,
    NANOSECOND_DIGITS_IN_MILLIS = 6,
    MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS),
    SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  function millisToHrTime(epochMillis) {
    let epochSeconds = epochMillis / 1e3,
      seconds = Math.trunc(epochSeconds),
      nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
  }
  __name(millisToHrTime, "millisToHrTime");
  exports.millisToHrTime = millisToHrTime;
  function getTimeOrigin() {
    let timeOrigin = platform_1.otperformance.timeOrigin;
    if (typeof timeOrigin != "number") {
      let perf = platform_1.otperformance;
      timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
  }
  __name(getTimeOrigin, "getTimeOrigin");
  exports.getTimeOrigin = getTimeOrigin;
  function hrTime(performanceNow) {
    let timeOrigin = millisToHrTime(getTimeOrigin()),
      now = millisToHrTime(typeof performanceNow == "number" ? performanceNow : platform_1.otperformance.now());
    return addHrTimes(timeOrigin, now);
  }
  __name(hrTime, "hrTime");
  exports.hrTime = hrTime;
  function timeInputToHrTime(time) {
    if (isTimeInputHrTime(time)) return time;
    if (typeof time == "number") return time < getTimeOrigin() ? hrTime(time) : millisToHrTime(time);
    if (time instanceof Date) return millisToHrTime(time.getTime());
    throw TypeError("Invalid input type");
  }
  __name(timeInputToHrTime, "timeInputToHrTime");
  exports.timeInputToHrTime = timeInputToHrTime;
  function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0],
      nanos = endTime[1] - startTime[1];
    return nanos < 0 && (seconds -= 1, nanos += SECOND_TO_NANOSECONDS), [seconds, nanos];
  }
  __name(hrTimeDuration, "hrTimeDuration");
  exports.hrTimeDuration = hrTimeDuration;
  function hrTimeToTimeStamp(time) {
    let precision = NANOSECOND_DIGITS,
      tmp = `${"0".repeat(precision)}${time[1]}Z`,
      nanoString = tmp.substr(tmp.length - precision - 1);
    return new Date(time[0] * 1e3).toISOString().replace("000Z", nanoString);
  }
  __name(hrTimeToTimeStamp, "hrTimeToTimeStamp");
  exports.hrTimeToTimeStamp = hrTimeToTimeStamp;
  function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
  }
  __name(hrTimeToNanoseconds, "hrTimeToNanoseconds");
  exports.hrTimeToNanoseconds = hrTimeToNanoseconds;
  function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
  }
  __name(hrTimeToMilliseconds, "hrTimeToMilliseconds");
  exports.hrTimeToMilliseconds = hrTimeToMilliseconds;
  function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
  }
  __name(hrTimeToMicroseconds, "hrTimeToMicroseconds");
  exports.hrTimeToMicroseconds = hrTimeToMicroseconds;
  function isTimeInputHrTime(value) {
    return Array.isArray(value) && value.length === 2 && typeof value[0] == "number" && typeof value[1] == "number";
  }
  __name(isTimeInputHrTime, "isTimeInputHrTime");
  exports.isTimeInputHrTime = isTimeInputHrTime;
  function isTimeInput(value) {
    return isTimeInputHrTime(value) || typeof value == "number" || value instanceof Date;
  }
  __name(isTimeInput, "isTimeInput");
  exports.isTimeInput = isTimeInput;
  function addHrTimes(time1, time2) {
    let out = [time1[0] + time2[0], time1[1] + time2[1]];
    return out[1] >= SECOND_TO_NANOSECONDS && (out[1] -= SECOND_TO_NANOSECONDS, out[0] += 1), out;
  }
  __name(addHrTimes, "addHrTimes");
  exports.addHrTimes = addHrTimes;
});
var E$ = T(b$ => {
  "use strict";

  Object.defineProperty(b$, "__esModule", {
    value: !0
  });
});
var C$ = T(w2 => {
  "use strict";

  Object.defineProperty(w2, "__esModule", {
    value: !0
  });
  w2.ExportResultCode = void 0;
  var ExportResultCode;
  (function (ExportResultCode) {
    ExportResultCode[ExportResultCode.SUCCESS = 0] = "SUCCESS", ExportResultCode[ExportResultCode.FAILED = 1] = "FAILED";
  })(ExportResultCode = exports.ExportResultCode || (exports.ExportResultCode = {}));
});
var S$ = T(xv => {
  "use strict";

  Object.defineProperty(xv, "__esModule", {
    value: !0
  });
  xv.CompositePropagator = void 0;
  var api_1 = ha(),
    CompositePropagator = class {
      static {
        __name(this, "CompositePropagator");
      }
      constructor(config = {}) {
        var r;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [], this._fields = Array.from(new Set(this._propagators.map(p => typeof p.fields == "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      inject(context, carrier, setter) {
        for (let propagator of this._propagators) try {
          propagator.inject(context, carrier, setter);
        } catch (err) {
          api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
        }
      }
      extract(context, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context);
      }
      fields() {
        return this._fields.slice();
      }
    };
  exports.CompositePropagator = CompositePropagator;
});
var w$ = T(cg => {
  "use strict";

  Object.defineProperty(cg, "__esModule", {
    value: !0
  });
  cg.validateValue = cg.validateKey = void 0;
  var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]",
    VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`,
    VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`,
    VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`),
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/,
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
  }
  __name(validateKey, "validateKey");
  exports.validateKey = validateKey;
  function validateValue(value) {
    return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
  }
  __name(validateValue, "validateValue");
  exports.validateValue = validateValue;
});
var oI = T(bv => {
  "use strict";

  Object.defineProperty(bv, "__esModule", {
    value: !0
  });
  bv.TraceState = void 0;
  var validators_1 = w$(),
    MAX_TRACE_STATE_ITEMS = 32,
    MAX_TRACE_STATE_LEN = 512,
    LIST_MEMBERS_SEPARATOR = ",",
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=",
    TraceState = class _TraceState {
      static {
        __name(this, "TraceState");
      }
      constructor(rawTraceState) {
        this._internalState = new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          let listMember = part.trim(),
            i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            let key = listMember.slice(0, i),
              value = listMember.slice(i + 1, part.length);
            (0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceState();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
  exports.TraceState = TraceState;
});
var O$ = T(Hl => {
  "use strict";

  Object.defineProperty(Hl, "__esModule", {
    value: !0
  });
  Hl.W3CTraceContextPropagator = Hl.parseTraceParent = Hl.TRACE_STATE_HEADER = Hl.TRACE_PARENT_HEADER = void 0;
  var api_1 = ha(),
    suppress_tracing_1 = E2(),
    TraceState_1 = oI();
  exports.TRACE_PARENT_HEADER = "traceparent";
  exports.TRACE_STATE_HEADER = "tracestate";
  var VERSION = "00",
    VERSION_PART = "(?!ff)[\\da-f]{2}",
    TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}",
    PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}",
    FLAGS_PART = "[\\da-f]{2}",
    TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
  function parseTraceParent(traceParent) {
    let match = TRACE_PARENT_REGEX.exec(traceParent);
    return !match || match[1] === "00" && match[5] ? null : {
      traceId: match[2],
      spanId: match[3],
      traceFlags: parseInt(match[4], 16)
    };
  }
  __name(parseTraceParent, "parseTraceParent");
  exports.parseTraceParent = parseTraceParent;
  var W3CTraceContextPropagator = class {
    static {
      __name(this, "W3CTraceContextPropagator");
    }
    inject(context, carrier, setter) {
      let spanContext = api_1.trace.getSpanContext(context);
      if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext)) return;
      let traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
      setter.set(carrier, exports.TRACE_PARENT_HEADER, traceParent), spanContext.traceState && setter.set(carrier, exports.TRACE_STATE_HEADER, spanContext.traceState.serialize());
    }
    extract(context, carrier, getter) {
      let traceParentHeader = getter.get(carrier, exports.TRACE_PARENT_HEADER);
      if (!traceParentHeader) return context;
      let traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent != "string") return context;
      let spanContext = parseTraceParent(traceParent);
      if (!spanContext) return context;
      spanContext.isRemote = !0;
      let traceStateHeader = getter.get(carrier, exports.TRACE_STATE_HEADER);
      if (traceStateHeader) {
        let state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState_1.TraceState(typeof state == "string" ? state : void 0);
      }
      return api_1.trace.setSpanContext(context, spanContext);
    }
    fields() {
      return [exports.TRACE_PARENT_HEADER, exports.TRACE_STATE_HEADER];
    }
  };
  exports.W3CTraceContextPropagator = W3CTraceContextPropagator;
});
var k$ = T(L$ => {
  "use strict";

  Object.defineProperty(L$, "__esModule", {
    value: !0
  });
});
var D$ = T(Zu => {
  "use strict";

  Object.defineProperty(Zu, "__esModule", {
    value: !0
  });
  Zu.getRPCMetadata = Zu.deleteRPCMetadata = Zu.setRPCMetadata = Zu.RPCType = void 0;
  var api_1 = ha(),
    RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA"),
    RPCType;
  (function (RPCType) {
    RPCType.HTTP = "http";
  })(RPCType = exports.RPCType || (exports.RPCType = {}));
  function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
  }
  __name(setRPCMetadata, "setRPCMetadata");
  exports.setRPCMetadata = setRPCMetadata;
  function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
  }
  __name(deleteRPCMetadata, "deleteRPCMetadata");
  exports.deleteRPCMetadata = deleteRPCMetadata;
  function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
  }
  __name(getRPCMetadata, "getRPCMetadata");
  exports.getRPCMetadata = getRPCMetadata;
});
var uI = T(Cv => {
  "use strict";

  Object.defineProperty(Cv, "__esModule", {
    value: !0
  });
  Cv.AlwaysOffSampler = void 0;
  var api_1 = ha(),
    AlwaysOffSampler = class {
      static {
        __name(this, "AlwaysOffSampler");
      }
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
  exports.AlwaysOffSampler = AlwaysOffSampler;
});
var dI = T(Tv => {
  "use strict";

  Object.defineProperty(Tv, "__esModule", {
    value: !0
  });
  Tv.AlwaysOnSampler = void 0;
  var api_1 = ha(),
    AlwaysOnSampler = class {
      static {
        __name(this, "AlwaysOnSampler");
      }
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
  exports.AlwaysOnSampler = AlwaysOnSampler;
});
var B$ = T(wv => {
  "use strict";

  Object.defineProperty(wv, "__esModule", {
    value: !0
  });
  wv.ParentBasedSampler = void 0;
  var api_1 = ha(),
    global_error_handler_1 = Kw(),
    AlwaysOffSampler_1 = uI(),
    AlwaysOnSampler_1 = dI(),
    ParentBasedSampler = class {
      static {
        __name(this, "ParentBasedSampler");
      }
      constructor(config) {
        var r, n, i, s;
        this._root = config.root, this._root || ((0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new AlwaysOnSampler_1.AlwaysOnSampler()), this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler(), this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler(), this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler(), this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        let parentContext = api_1.trace.getSpanContext(context);
        return !parentContext || !(0, api_1.isSpanContextValid)(parentContext) ? this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.isRemote ? parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
  exports.ParentBasedSampler = ParentBasedSampler;
});
var F$ = T(Iv => {
  "use strict";

  Object.defineProperty(Iv, "__esModule", {
    value: !0
  });
  Iv.TraceIdRatioBasedSampler = void 0;
  var api_1 = ha(),
    TraceIdRatioBasedSampler = class {
      static {
        __name(this, "TraceIdRatioBasedSampler");
      }
      constructor(_ratio = 0) {
        this._ratio = _ratio, this._ratio = this._normalize(_ratio), this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        return typeof ratio != "number" || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          let pos = i * 8,
            part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});
var $$ = T(Av => {
  "use strict";

  Object.defineProperty(Av, "__esModule", {
    value: !0
  });
  Av.isPlainObject = void 0;
  var objectTag = "[object Object]",
    nullTag = "[object Null]",
    undefinedTag = "[object Undefined]",
    funcProto = Function.prototype,
    funcToString = funcProto.toString,
    objectCtorString = funcToString.call(Object),
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectProto = Object.prototype,
    hasOwnProperty = objectProto.hasOwnProperty,
    symToStringTag = Symbol ? Symbol.toStringTag : void 0,
    nativeObjectToString = objectProto.toString;
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  __name(overArg, "overArg");
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) return !1;
    let proto = getPrototype(value);
    if (proto === null) return !0;
    let Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  __name(isPlainObject, "isPlainObject");
  exports.isPlainObject = isPlainObject;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  __name(isObjectLike, "isObjectLike");
  function baseGetTag(value) {
    return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  __name(baseGetTag, "baseGetTag");
  function getRawTag(value) {
    let isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag],
      unmasked = !1;
    try {
      value[symToStringTag] = void 0, unmasked = !0;
    } catch {}
    let result = nativeObjectToString.call(value);
    return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
  }
  __name(getRawTag, "getRawTag");
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  __name(objectToString, "objectToString");
});
var K$ = T(Nv => {
  "use strict";

  Object.defineProperty(Nv, "__esModule", {
    value: !0
  });
  Nv.merge = void 0;
  var lodash_merge_1 = $$(),
    MAX_LEVEL = 20;
  function merge(...args) {
    let result = args.shift(),
      objects = new WeakMap();
    for (; args.length > 0;) result = mergeTwoObjects(result, args.shift(), 0, objects);
    return result;
  }
  __name(merge, "merge");
  exports.merge = merge;
  function takeValue(value) {
    return isArray(value) ? value.slice() : value;
  }
  __name(takeValue, "takeValue");
  function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (!(level > MAX_LEVEL)) {
      if (level++, isPrimitive(one) || isPrimitive(two) || isFunction(two)) result = takeValue(two);else if (isArray(one)) {
        if (result = one.slice(), isArray(two)) for (let i = 0, j = two.length; i < j; i++) result.push(takeValue(two[i]));else if (isObject(two)) {
          let keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            let key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) if (isObject(two)) {
        if (!shouldMerge(one, two)) return two;
        result = Object.assign({}, one);
        let keys = Object.keys(two);
        for (let i = 0, j = keys.length; i < j; i++) {
          let key = keys[i],
            twoValue = two[key];
          if (isPrimitive(twoValue)) typeof twoValue > "u" ? delete result[key] : result[key] = twoValue;else {
            let obj1 = result[key],
              obj2 = twoValue;
            if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) delete result[key];else {
              if (isObject(obj1) && isObject(obj2)) {
                let arr1 = objects.get(obj1) || [],
                  arr2 = objects.get(obj2) || [];
                arr1.push({
                  obj: one,
                  key: key
                }), arr2.push({
                  obj: two,
                  key: key
                }), objects.set(obj1, arr1), objects.set(obj2, arr2);
              }
              result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
            }
          }
        }
      } else result = two;
      return result;
    }
  }
  __name(mergeTwoObjects, "mergeTwoObjects");
  function wasObjectReferenced(obj, key, objects) {
    let arr = objects.get(obj[key]) || [];
    for (let i = 0, j = arr.length; i < j; i++) {
      let info = arr[i];
      if (info.key === key && info.obj === obj) return !0;
    }
    return !1;
  }
  __name(wasObjectReferenced, "wasObjectReferenced");
  function isArray(value) {
    return Array.isArray(value);
  }
  __name(isArray, "isArray");
  function isFunction(value) {
    return typeof value == "function";
  }
  __name(isFunction, "isFunction");
  function isObject(value) {
    return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value == "object";
  }
  __name(isObject, "isObject");
  function isPrimitive(value) {
    return typeof value == "string" || typeof value == "number" || typeof value == "boolean" || typeof value > "u" || value instanceof Date || value instanceof RegExp || value === null;
  }
  __name(isPrimitive, "isPrimitive");
  function shouldMerge(one, two) {
    return !(!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two));
  }
  __name(shouldMerge, "shouldMerge");
});
var X$ = T(ug => {
  "use strict";

  Object.defineProperty(ug, "__esModule", {
    value: !0
  });
  ug.callWithTimeout = ug.TimeoutError = void 0;
  var TimeoutError = class _TimeoutError extends Error {
    static {
      __name(this, "TimeoutError");
    }
    constructor(message) {
      super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
    }
  };
  exports.TimeoutError = TimeoutError;
  function callWithTimeout(promise, timeout) {
    let timeoutHandle,
      timeoutPromise = new Promise(__name(function (_resolve, reject) {
        timeoutHandle = setTimeout(__name(function () {
          reject(new TimeoutError("Operation timed out."));
        }, "timeoutHandler"), timeout);
      }, "timeoutFunction"));
    return Promise.race([promise, timeoutPromise]).then(result => (clearTimeout(timeoutHandle), result), reason => {
      throw clearTimeout(timeoutHandle), reason;
    });
  }
  __name(callWithTimeout, "callWithTimeout");
  exports.callWithTimeout = callWithTimeout;
});
var Q$ = T(fg => {
  "use strict";

  Object.defineProperty(fg, "__esModule", {
    value: !0
  });
  fg.isUrlIgnored = fg.urlMatches = void 0;
  function urlMatches(url, urlToMatch) {
    return typeof urlToMatch == "string" ? url === urlToMatch : !!url.match(urlToMatch);
  }
  __name(urlMatches, "urlMatches");
  exports.urlMatches = urlMatches;
  function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) return !1;
    for (let ignoreUrl of ignoredUrls) if (urlMatches(url, ignoreUrl)) return !0;
    return !1;
  }
  __name(isUrlIgnored, "isUrlIgnored");
  exports.isUrlIgnored = isUrlIgnored;
});
var Z$ = T(Lv => {
  "use strict";

  Object.defineProperty(Lv, "__esModule", {
    value: !0
  });
  Lv.isWrapped = void 0;
  function isWrapped(func) {
    return typeof func == "function" && typeof func.__original == "function" && typeof func.__unwrap == "function" && func.__wrapped === !0;
  }
  __name(isWrapped, "isWrapped");
  exports.isWrapped = isWrapped;
});
var J$ = T(kv => {
  "use strict";

  Object.defineProperty(kv, "__esModule", {
    value: !0
  });
  kv.Deferred = void 0;
  var Deferred = class {
    static {
      __name(this, "Deferred");
    }
    constructor() {
      this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve, this._reject = reject;
      });
    }
    get promise() {
      return this._promise;
    }
    resolve(val) {
      this._resolve(val);
    }
    reject(err) {
      this._reject(err);
    }
  };
  exports.Deferred = Deferred;
});
var eV = T(Dv => {
  "use strict";

  Object.defineProperty(Dv, "__esModule", {
    value: !0
  });
  Dv.BindOnceFuture = void 0;
  var promise_1 = J$(),
    BindOnceFuture = class {
      static {
        __name(this, "BindOnceFuture");
      }
      constructor(_callback, _that) {
        this._callback = _callback, this._that = _that, this._isCalled = !1, this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then(val => this._deferred.resolve(val), err => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
  exports.BindOnceFuture = BindOnceFuture;
});
var rV = T(Mv => {
  "use strict";

  Object.defineProperty(Mv, "__esModule", {
    value: !0
  });
  Mv._export = void 0;
  var api_1 = ha(),
    suppress_tracing_1 = E2();
  function _export(exporter, arg) {
    return new Promise(resolve => {
      api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
        exporter.export(arg, result => {
          resolve(result);
        });
      });
    });
  }
  __name(_export, "_export");
  exports._export = _export;
});
var tc = T(na => {
  "use strict";

  var I2e = na && na.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Ya = na && na.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && I2e(t, e, r);
    };
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.internal = na.baggageUtils = void 0;
  __exportStar(GH(), exports);
  __exportStar(zH(), exports);
  __exportStar(QH(), exports);
  __exportStar(Kw(), exports);
  __exportStar(Ww(), exports);
  __exportStar(x$(), exports);
  __exportStar(E$(), exports);
  __exportStar(C$(), exports);
  __exportStar(gv(), exports);
  exports.baggageUtils = Hw();
  __exportStar(Jw(), exports);
  __exportStar(S$(), exports);
  __exportStar(O$(), exports);
  __exportStar(k$(), exports);
  __exportStar(D$(), exports);
  __exportStar(uI(), exports);
  __exportStar(dI(), exports);
  __exportStar(B$(), exports);
  __exportStar(F$(), exports);
  __exportStar(E2(), exports);
  __exportStar(oI(), exports);
  __exportStar(Qw(), exports);
  __exportStar(K$(), exports);
  __exportStar(Xw(), exports);
  __exportStar(X$(), exports);
  __exportStar(Q$(), exports);
  __exportStar(Z$(), exports);
  __exportStar(eV(), exports);
  __exportStar(gv(), exports);
  var exporter_1 = rV();
  exports.internal = {
    _export: exporter_1._export
  };
});
var nV = T(Bv => {
  "use strict";

  Object.defineProperty(Bv, "__esModule", {
    value: !0
  });
  Bv.ExceptionEventName = void 0;
  exports.ExceptionEventName = "exception";
});
var bI = T(Fv => {
  "use strict";

  Object.defineProperty(Fv, "__esModule", {
    value: !0
  });
  Fv.Span = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    semantic_conventions_1 = Qu(),
    enums_1 = nV(),
    Span = class {
      static {
        __name(this, "Span");
      }
      constructor(parentTracer, context, spanName, spanContext, kind, parentSpanId, links = [], startTime, _deprecatedClock) {
        this.attributes = {}, this.links = [], this.events = [], this._droppedAttributesCount = 0, this._droppedEventsCount = 0, this._droppedLinksCount = 0, this.status = {
          code: api_1.SpanStatusCode.UNSET
        }, this.endTime = [0, 0], this._ended = !1, this._duration = [-1, -1], this.name = spanName, this._spanContext = spanContext, this.parentSpanId = parentSpanId, this.kind = kind, this.links = links;
        let now = Date.now();
        this._performanceStartTime = core_1.otperformance.now(), this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)()), this._startTimeProvided = startTime != null, this.startTime = this._getTime(startTime ?? now), this.resource = parentTracer.resource, this.instrumentationLibrary = parentTracer.instrumentationLibrary, this._spanLimits = parentTracer.getSpanLimits(), this._spanProcessor = parentTracer.getActiveSpanProcessor(), this._spanProcessor.onStart(this, context), this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(key, value) {
        return value == null || this._isSpanEnded() ? this : key.length === 0 ? (api_1.diag.warn(`Invalid attribute key: ${key}`), this) : (0, core_1.isAttributeValue)(value) ? Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key) ? (this._droppedAttributesCount++, this) : (this.attributes[key] = this._truncateToSize(value), this) : (api_1.diag.warn(`Invalid attribute value set for key: ${key}`), this);
      }
      setAttributes(attributes) {
        for (let [k, v] of Object.entries(attributes)) this.setAttribute(k, v);
        return this;
      }
      addEvent(name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded()) return this;
        if (this._spanLimits.eventCountLimit === 0) return api_1.diag.warn("No events allowed."), this._droppedEventsCount++, this;
        this.events.length >= this._spanLimits.eventCountLimit && (api_1.diag.warn("Dropping extra events."), this.events.shift(), this._droppedEventsCount++), (0, core_1.isTimeInput)(attributesOrStartTime) && ((0, core_1.isTimeInput)(timeStamp) || (timeStamp = attributesOrStartTime), attributesOrStartTime = void 0);
        let attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
        return this.events.push({
          name: name,
          attributes: attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        }), this;
      }
      setStatus(status) {
        return this._isSpanEnded() ? this : (this.status = status, this);
      }
      updateName(name) {
        return this._isSpanEnded() ? this : (this.name = name, this);
      }
      end(endTime) {
        if (this._isSpanEnded()) {
          api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
          return;
        }
        this._ended = !0, this.endTime = this._getTime(endTime), this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime), this._duration[0] < 0 && (api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime), this.endTime = this.startTime.slice(), this._duration = [0, 0]), this._spanProcessor.onEnd(this);
      }
      _getTime(inp) {
        if (typeof inp == "number" && inp < core_1.otperformance.now()) return (0, core_1.hrTime)(inp + this._performanceOffset);
        if (typeof inp == "number") return (0, core_1.millisToHrTime)(inp);
        if (inp instanceof Date) return (0, core_1.millisToHrTime)(inp.getTime());
        if ((0, core_1.isTimeInputHrTime)(inp)) return inp;
        if (this._startTimeProvided) return (0, core_1.millisToHrTime)(Date.now());
        let msDuration = core_1.otperformance.now() - this._performanceStartTime;
        return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
      }
      isRecording() {
        return this._ended === !1;
      }
      recordException(exception, time) {
        let attributes = {};
        typeof exception == "string" ? attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE] = exception : exception && (exception.code ? attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString() : exception.name && (attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] = exception.name), exception.message && (attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE] = exception.message), exception.stack && (attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack)), attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] || attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE] ? this.addEvent(enums_1.ExceptionEventName, attributes, time) : api_1.diag.warn(`Failed to record an exception ${exception}`);
      }
      get duration() {
        return this._duration;
      }
      get ended() {
        return this._ended;
      }
      get droppedAttributesCount() {
        return this._droppedAttributesCount;
      }
      get droppedEventsCount() {
        return this._droppedEventsCount;
      }
      get droppedLinksCount() {
        return this._droppedLinksCount;
      }
      _isSpanEnded() {
        return this._ended && api_1.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`), this._ended;
      }
      _truncateToLimitUtil(value, limit) {
        return value.length <= limit ? value : value.substr(0, limit);
      }
      _truncateToSize(value) {
        let limit = this._attributeValueLengthLimit;
        return limit <= 0 ? (api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`), value) : typeof value == "string" ? this._truncateToLimitUtil(value, limit) : Array.isArray(value) ? value.map(val => typeof val == "string" ? this._truncateToLimitUtil(val, limit) : val) : value;
      }
    };
  exports.Span = Span;
});
var P2 = T(A2 => {
  "use strict";

  Object.defineProperty(A2, "__esModule", {
    value: !0
  });
  A2.SamplingDecision = void 0;
  var SamplingDecision;
  (function (SamplingDecision) {
    SamplingDecision[SamplingDecision.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision[SamplingDecision.RECORD = 1] = "RECORD", SamplingDecision[SamplingDecision.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
  })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
});
var qv = T(Uv => {
  "use strict";

  Object.defineProperty(Uv, "__esModule", {
    value: !0
  });
  Uv.AlwaysOffSampler = void 0;
  var Sampler_1 = P2(),
    AlwaysOffSampler = class {
      static {
        __name(this, "AlwaysOffSampler");
      }
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
  exports.AlwaysOffSampler = AlwaysOffSampler;
});
var Hv = T(jv => {
  "use strict";

  Object.defineProperty(jv, "__esModule", {
    value: !0
  });
  jv.AlwaysOnSampler = void 0;
  var Sampler_1 = P2(),
    AlwaysOnSampler = class {
      static {
        __name(this, "AlwaysOnSampler");
      }
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
  exports.AlwaysOnSampler = AlwaysOnSampler;
});
var wI = T(Vv => {
  "use strict";

  Object.defineProperty(Vv, "__esModule", {
    value: !0
  });
  Vv.ParentBasedSampler = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    AlwaysOffSampler_1 = qv(),
    AlwaysOnSampler_1 = Hv(),
    ParentBasedSampler = class {
      static {
        __name(this, "ParentBasedSampler");
      }
      constructor(config) {
        var r, n, i, s;
        this._root = config.root, this._root || ((0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new AlwaysOnSampler_1.AlwaysOnSampler()), this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler(), this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler(), this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler(), this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        let parentContext = api_1.trace.getSpanContext(context);
        return !parentContext || !(0, api_1.isSpanContextValid)(parentContext) ? this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.isRemote ? parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
  exports.ParentBasedSampler = ParentBasedSampler;
});
var AI = T(Gv => {
  "use strict";

  Object.defineProperty(Gv, "__esModule", {
    value: !0
  });
  Gv.TraceIdRatioBasedSampler = void 0;
  var api_1 = ha(),
    Sampler_1 = P2(),
    TraceIdRatioBasedSampler = class {
      static {
        __name(this, "TraceIdRatioBasedSampler");
      }
      constructor(_ratio = 0) {
        this._ratio = _ratio, this._ratio = this._normalize(_ratio), this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        return typeof ratio != "number" || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          let pos = i * 8,
            part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
  exports.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
});
var NI = T(pg => {
  "use strict";

  Object.defineProperty(pg, "__esModule", {
    value: !0
  });
  pg.buildSamplerFromEnv = pg.loadDefaultConfig = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    AlwaysOffSampler_1 = qv(),
    AlwaysOnSampler_1 = Hv(),
    ParentBasedSampler_1 = wI(),
    TraceIdRatioBasedSampler_1 = AI(),
    env = (0, core_1.getEnv)(),
    FALLBACK_OTEL_TRACES_SAMPLER = core_1.TracesSamplerValues.AlwaysOn,
    DEFAULT_RATIO = 1;
  function loadDefaultConfig() {
    return {
      sampler: buildSamplerFromEnv(env),
      forceFlushTimeoutMillis: 3e4,
      generalLimits: {
        attributeValueLengthLimit: (0, core_1.getEnv)().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: (0, core_1.getEnv)().OTEL_ATTRIBUTE_COUNT_LIMIT
      },
      spanLimits: {
        attributeValueLengthLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
        linkCountLimit: (0, core_1.getEnv)().OTEL_SPAN_LINK_COUNT_LIMIT,
        eventCountLimit: (0, core_1.getEnv)().OTEL_SPAN_EVENT_COUNT_LIMIT,
        attributePerEventCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
        attributePerLinkCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
      }
    };
  }
  __name(loadDefaultConfig, "loadDefaultConfig");
  exports.loadDefaultConfig = loadDefaultConfig;
  function buildSamplerFromEnv(environment = (0, core_1.getEnv)()) {
    switch (environment.OTEL_TRACES_SAMPLER) {
      case core_1.TracesSamplerValues.AlwaysOn:
        return new AlwaysOnSampler_1.AlwaysOnSampler();
      case core_1.TracesSamplerValues.AlwaysOff:
        return new AlwaysOffSampler_1.AlwaysOffSampler();
      case core_1.TracesSamplerValues.ParentBasedAlwaysOn:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOnSampler_1.AlwaysOnSampler()
        });
      case core_1.TracesSamplerValues.ParentBasedAlwaysOff:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new AlwaysOffSampler_1.AlwaysOffSampler()
        });
      case core_1.TracesSamplerValues.TraceIdRatio:
        return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
      case core_1.TracesSamplerValues.ParentBasedTraceIdRatio:
        return new ParentBasedSampler_1.ParentBasedSampler({
          root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
        });
      default:
        return api_1.diag.error(`OTEL_TRACES_SAMPLER value "${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}".`), new AlwaysOnSampler_1.AlwaysOnSampler();
    }
  }
  __name(buildSamplerFromEnv, "buildSamplerFromEnv");
  exports.buildSamplerFromEnv = buildSamplerFromEnv;
  function getSamplerProbabilityFromEnv(environment) {
    if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") return api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`), DEFAULT_RATIO;
    let probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    return isNaN(probability) ? (api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`), DEFAULT_RATIO) : probability < 0 || probability > 1 ? (api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`), DEFAULT_RATIO) : probability;
  }
  __name(getSamplerProbabilityFromEnv, "getSamplerProbabilityFromEnv");
});
var LI = T(mg => {
  "use strict";

  Object.defineProperty(mg, "__esModule", {
    value: !0
  });
  mg.reconfigureLimits = mg.mergeConfig = void 0;
  var config_1 = NI(),
    core_1 = tc();
  function mergeConfig(userConfig) {
    let perInstanceDefaults = {
        sampler: (0, config_1.buildSamplerFromEnv)()
      },
      DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)(),
      target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    return target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {}), target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {}), target;
  }
  __name(mergeConfig, "mergeConfig");
  exports.mergeConfig = mergeConfig;
  function reconfigureLimits(userConfig) {
    var t, r, n, i, s, o, c, u, f, d, p, m;
    let spanLimits = Object.assign({}, userConfig.spanLimits),
      parsedEnvConfig = (0, core_1.getEnvWithoutDefaults)();
    return spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : core_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT, spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : core_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT, Object.assign({}, userConfig, {
      spanLimits: spanLimits
    });
  }
  __name(reconfigureLimits, "reconfigureLimits");
  exports.reconfigureLimits = reconfigureLimits;
});
var fV = T(Wv => {
  "use strict";

  Object.defineProperty(Wv, "__esModule", {
    value: !0
  });
  Wv.BatchSpanProcessorBase = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    BatchSpanProcessorBase = class {
      static {
        __name(this, "BatchSpanProcessorBase");
      }
      constructor(_exporter, config) {
        this._exporter = _exporter, this._finishedSpans = [], this._droppedSpansCount = 0;
        let env = (0, core_1.getEnv)();
        this._maxExportBatchSize = typeof config?.maxExportBatchSize == "number" ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE, this._maxQueueSize = typeof config?.maxQueueSize == "number" ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE, this._scheduledDelayMillis = typeof config?.scheduledDelayMillis == "number" ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY, this._exportTimeoutMillis = typeof config?.exportTimeoutMillis == "number" ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT, this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this), this._maxExportBatchSize > this._maxQueueSize && (api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize"), this._maxExportBatchSize = this._maxQueueSize);
      }
      forceFlush() {
        return this._shutdownOnce.isCalled ? this._shutdownOnce.promise : this._flushAll();
      }
      onStart(_span, _parentContext) {}
      onEnd(span) {
        this._shutdownOnce.isCalled || span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED && this._addToBuffer(span);
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return Promise.resolve().then(() => this.onShutdown()).then(() => this._flushAll()).then(() => this._exporter.shutdown());
      }
      _addToBuffer(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          this._droppedSpansCount === 0 && api_1.diag.debug("maxQueueSize reached, dropping spans"), this._droppedSpansCount++;
          return;
        }
        this._droppedSpansCount > 0 && (api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`), this._droppedSpansCount = 0), this._finishedSpans.push(span), this._maybeStartTimer();
      }
      _flushAll() {
        return new Promise((resolve, reject) => {
          let promises = [],
            count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
          for (let i = 0, j = count; i < j; i++) promises.push(this._flushOneBatch());
          Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      _flushOneBatch() {
        return this._clearTimer(), this._finishedSpans.length === 0 ? Promise.resolve() : new Promise((resolve, reject) => {
          let timer = setTimeout(() => {
            reject(new Error("Timeout"));
          }, this._exportTimeoutMillis);
          api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            let spans = this._finishedSpans.splice(0, this._maxExportBatchSize),
              doExport = __name(() => this._exporter.export(spans, result => {
                var u;
                clearTimeout(timer), result.code === core_1.ExportResultCode.SUCCESS ? resolve() : reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error("BatchSpanProcessor: span export failed"));
              }), "doExport"),
              pendingResources = spans.map(span => span.resource).filter(resource => resource.asyncAttributesPending);
            pendingResources.length === 0 ? doExport() : Promise.all(pendingResources.map(resource => {
              var _a;
              return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource);
            })).then(doExport, err => {
              (0, core_1.globalErrorHandler)(err), reject(err);
            });
          });
        });
      }
      _maybeStartTimer() {
        this._timer === void 0 && (this._timer = setTimeout(() => {
          this._flushOneBatch().then(() => {
            this._finishedSpans.length > 0 && (this._clearTimer(), this._maybeStartTimer());
          }).catch(e => {
            (0, core_1.globalErrorHandler)(e);
          });
        }, this._scheduledDelayMillis), (0, core_1.unrefTimer)(this._timer));
      }
      _clearTimer() {
        this._timer !== void 0 && (clearTimeout(this._timer), this._timer = void 0);
      }
    };
  exports.BatchSpanProcessorBase = BatchSpanProcessorBase;
});
var dV = T(Kv => {
  "use strict";

  Object.defineProperty(Kv, "__esModule", {
    value: !0
  });
  Kv.BatchSpanProcessor = void 0;
  var BatchSpanProcessorBase_1 = fV(),
    BatchSpanProcessor = class extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
      static {
        __name(this, "BatchSpanProcessor");
      }
      onShutdown() {}
    };
  exports.BatchSpanProcessor = BatchSpanProcessor;
});
var hV = T(Yv => {
  "use strict";

  Object.defineProperty(Yv, "__esModule", {
    value: !0
  });
  Yv.RandomIdGenerator = void 0;
  var SPAN_ID_BYTES = 8,
    TRACE_ID_BYTES = 16,
    RandomIdGenerator = class {
      static {
        __name(this, "RandomIdGenerator");
      }
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES), this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
  exports.RandomIdGenerator = RandomIdGenerator;
  var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
  function getIdGenerator(bytes) {
    return __name(function () {
      for (let i = 0; i < bytes / 4; i++) SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
      for (let i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++) i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
      return SHARED_BUFFER.toString("hex", 0, bytes);
    }, "generateId");
  }
  __name(getIdGenerator, "getIdGenerator");
});
var _V = T(Ip => {
  "use strict";

  var H2e = Ip && Ip.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    gV = Ip && Ip.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && H2e(t, e, r);
    };
  Object.defineProperty(Ip, "__esModule", {
    value: !0
  });
  __exportStar(dV(), exports);
  __exportStar(hV(), exports);
});
var Qv = T(dm => {
  "use strict";

  var $2e = dm && dm.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    V2e = dm && dm.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && $2e(t, e, r);
    };
  Object.defineProperty(dm, "__esModule", {
    value: !0
  });
  __exportStar(_V(), exports);
});
var yV = T(Jv => {
  "use strict";

  Object.defineProperty(Jv, "__esModule", {
    value: !0
  });
  Jv.Tracer = void 0;
  var api = ha(),
    core_1 = tc(),
    Span_1 = bI(),
    utility_1 = LI(),
    platform_1 = Qv(),
    Tracer = class {
      static {
        __name(this, "Tracer");
      }
      constructor(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        let localConfig = (0, utility_1.mergeConfig)(config);
        this._sampler = localConfig.sampler, this._generalLimits = localConfig.generalLimits, this._spanLimits = localConfig.spanLimits, this._idGenerator = config.idGenerator || new platform_1.RandomIdGenerator(), this.resource = _tracerProvider.resource, this.instrumentationLibrary = instrumentationLibrary;
      }
      startSpan(name, options = {}, context = api.context.active()) {
        var i, s, o;
        options.root && (context = api.trace.deleteSpan(context));
        let parentSpan = api.trace.getSpan(context);
        if ((0, core_1.isTracingSuppressed)(context)) return api.diag.debug("Instrumentation suppressed, returning Noop Span"), api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
        let parentSpanContext = parentSpan?.spanContext(),
          spanId = this._idGenerator.generateSpanId(),
          traceId,
          traceState,
          parentSpanId;
        !parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext) ? traceId = this._idGenerator.generateTraceId() : (traceId = parentSpanContext.traceId, traceState = parentSpanContext.traceState, parentSpanId = parentSpanContext.spanId);
        let spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL,
          links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map(link => ({
            context: link.context,
            attributes: (0, core_1.sanitizeAttributes)(link.attributes)
          })),
          attributes = (0, core_1.sanitizeAttributes)(options.attributes),
          samplingResult = this._sampler.shouldSample(context, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        let traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,
          spanContext = {
            traceId: traceId,
            spanId: spanId,
            traceFlags: traceFlags,
            traceState: traceState
          };
        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) return api.diag.debug("Recording is off, propagating context in a non-recording span"), api.trace.wrapSpanContext(spanContext);
        let span = new Span_1.Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime),
          initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
        return span.setAttributes(initAttributes), span;
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts, ctx, fn;
        if (arguments.length < 2) return;
        arguments.length === 2 ? fn = arg2 : arguments.length === 3 ? (opts = arg2, fn = arg3) : (opts = arg2, ctx = arg3, fn = arg4);
        let parentContext = ctx ?? api.context.active(),
          span = this.startSpan(name, opts, parentContext),
          contextWithSpanSet = api.trace.setSpan(parentContext, span);
        return api.context.with(contextWithSpanSet, fn, void 0, span);
      }
      getGeneralLimits() {
        return this._generalLimits;
      }
      getSpanLimits() {
        return this._spanLimits;
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
      }
    };
  exports.Tracer = Tracer;
});
var vV = T(e9 => {
  "use strict";

  Object.defineProperty(e9, "__esModule", {
    value: !0
  });
  e9.defaultServiceName = void 0;
  function defaultServiceName() {
    return `unknown_service:${process.argv0}`;
  }
  __name(defaultServiceName, "defaultServiceName");
  exports.defaultServiceName = defaultServiceName;
});
var FI = T(gg => {
  "use strict";

  Object.defineProperty(gg, "__esModule", {
    value: !0
  });
  gg.normalizeType = gg.normalizeArch = void 0;
  var normalizeArch = __name(nodeArchString => {
    switch (nodeArchString) {
      case "arm":
        return "arm32";
      case "ppc":
        return "ppc32";
      case "x64":
        return "amd64";
      default:
        return nodeArchString;
    }
  }, "normalizeArch");
  exports.normalizeArch = normalizeArch;
  var normalizeType = __name(nodePlatform => {
    switch (nodePlatform) {
      case "sunos":
        return "solaris";
      case "win32":
        return "windows";
      default:
        return nodePlatform;
    }
  }, "normalizeType");
  exports.normalizeType = normalizeType;
});
var r9 = T(t9 => {
  "use strict";

  Object.defineProperty(t9, "__esModule", {
    value: !0
  });
  t9.execAsync = void 0;
  var child_process = require("child_process"),
    util = require("util");
  exports.execAsync = util.promisify(child_process.exec);
});
var xV = T(n9 => {
  "use strict";

  Object.defineProperty(n9, "__esModule", {
    value: !0
  });
  n9.getMachineId = void 0;
  var execAsync_1 = r9(),
    api_1 = ha();
  async function getMachineId() {
    try {
      let idLine = (await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"')).stdout.split(`
`).find(line => line.includes("IOPlatformUUID"));
      if (!idLine) return "";
      let parts = idLine.split('" = "');
      if (parts.length === 2) return parts[1].slice(0, -1);
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return "";
  }
  __name(getMachineId, "getMachineId");
  exports.getMachineId = getMachineId;
});
var bV = T(i9 => {
  "use strict";

  Object.defineProperty(i9, "__esModule", {
    value: !0
  });
  i9.getMachineId = void 0;
  var fs_1 = require("fs"),
    api_1 = ha();
  async function getMachineId() {
    let paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
    for (let path of paths) try {
      return (await fs_1.promises.readFile(path, {
        encoding: "utf8"
      })).trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return "";
  }
  __name(getMachineId, "getMachineId");
  exports.getMachineId = getMachineId;
});
var CV = T(s9 => {
  "use strict";

  Object.defineProperty(s9, "__esModule", {
    value: !0
  });
  s9.getMachineId = void 0;
  var fs_1 = require("fs"),
    execAsync_1 = r9(),
    api_1 = ha();
  async function getMachineId() {
    try {
      return (await fs_1.promises.readFile("/etc/hostid", {
        encoding: "utf8"
      })).trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    try {
      return (await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid")).stdout.trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return "";
  }
  __name(getMachineId, "getMachineId");
  exports.getMachineId = getMachineId;
});
var SV = T(o9 => {
  "use strict";

  Object.defineProperty(o9, "__esModule", {
    value: !0
  });
  o9.getMachineId = void 0;
  var process = require("process"),
    execAsync_1 = r9(),
    api_1 = ha();
  async function getMachineId() {
    let args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid",
      command = "%windir%\\System32\\REG.exe";
    process.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process.env && (command = "%windir%\\sysnative\\cmd.exe /c " + command);
    try {
      let parts = (await (0, execAsync_1.execAsync)(`${command} ${args}`)).stdout.split("REG_SZ");
      if (parts.length === 2) return parts[1].trim();
    } catch (e) {
      api_1.diag.debug(`error reading machine id: ${e}`);
    }
    return "";
  }
  __name(getMachineId, "getMachineId");
  exports.getMachineId = getMachineId;
});
var wV = T(a9 => {
  "use strict";

  Object.defineProperty(a9, "__esModule", {
    value: !0
  });
  a9.getMachineId = void 0;
  var api_1 = ha();
  async function getMachineId() {
    return api_1.diag.debug("could not read machine-id: unsupported platform"), "";
  }
  __name(getMachineId, "getMachineId");
  exports.getMachineId = getMachineId;
});
var IV = T(wd => {
  "use strict";

  Object.defineProperty(wd, "__esModule", {
    value: !0
  });
  wd.getMachineId = void 0;
  var process = require("process"),
    getMachineId;
  exports.getMachineId = getMachineId;
  switch (process.platform) {
    case "darwin":
      exports.getMachineId = getMachineId = xV().getMachineId;
      break;
    case "linux":
      exports.getMachineId = getMachineId = bV().getMachineId;
      break;
    case "freebsd":
      exports.getMachineId = getMachineId = CV().getMachineId;
      break;
    case "win32":
      exports.getMachineId = getMachineId = SV().getMachineId;
      break;
    default:
      exports.getMachineId = getMachineId = wV().getMachineId;
  }
});
var jI = T(l9 => {
  "use strict";

  Object.defineProperty(l9, "__esModule", {
    value: !0
  });
  l9.hostDetectorSync = void 0;
  var semantic_conventions_1 = Qu(),
    Resource_1 = pm(),
    os_1 = require("os"),
    utils_1 = FI(),
    getMachineId_1 = IV(),
    HostDetectorSync = class {
      static {
        __name(this, "HostDetectorSync");
      }
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SemanticResourceAttributes.HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then(machineId => {
          let attributes = {};
          return machineId && (attributes[semantic_conventions_1.SemanticResourceAttributes.HOST_ID] = machineId), attributes;
        });
      }
    };
  exports.hostDetectorSync = new HostDetectorSync();
});
var PV = T(c9 => {
  "use strict";

  Object.defineProperty(c9, "__esModule", {
    value: !0
  });
  c9.hostDetector = void 0;
  var HostDetectorSync_1 = jI(),
    HostDetector = class {
      static {
        __name(this, "HostDetector");
      }
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
  exports.hostDetector = new HostDetector();
});
var VI = T(u9 => {
  "use strict";

  Object.defineProperty(u9, "__esModule", {
    value: !0
  });
  u9.osDetectorSync = void 0;
  var semantic_conventions_1 = Qu(),
    Resource_1 = pm(),
    os_1 = require("os"),
    utils_1 = FI(),
    OSDetectorSync = class {
      static {
        __name(this, "OSDetectorSync");
      }
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SemanticResourceAttributes.OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
  exports.osDetectorSync = new OSDetectorSync();
});
var OV = T(f9 => {
  "use strict";

  Object.defineProperty(f9, "__esModule", {
    value: !0
  });
  f9.osDetector = void 0;
  var OSDetectorSync_1 = VI(),
    OSDetector = class {
      static {
        __name(this, "OSDetector");
      }
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
  exports.osDetector = new OSDetector();
});
var WI = T(d9 => {
  "use strict";

  Object.defineProperty(d9, "__esModule", {
    value: !0
  });
  d9.processDetectorSync = void 0;
  var api_1 = ha(),
    semantic_conventions_1 = Qu(),
    Resource_1 = pm(),
    os = require("os"),
    ProcessDetectorSync = class {
      static {
        __name(this, "ProcessDetectorSync");
      }
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_PID]: process.pid,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND_ARGS]: [process.argv[0], ...process.execArgv, ...process.argv.slice(1)],
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        process.argv.length > 1 && (attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1]);
        try {
          let userInfo = os.userInfo();
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
  exports.processDetectorSync = new ProcessDetectorSync();
});
var LV = T(p9 => {
  "use strict";

  Object.defineProperty(p9, "__esModule", {
    value: !0
  });
  p9.processDetector = void 0;
  var ProcessDetectorSync_1 = WI(),
    ProcessDetector = class {
      static {
        __name(this, "ProcessDetector");
      }
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
  exports.processDetector = new ProcessDetector();
});
var kV = T(qc => {
  "use strict";

  var S4e = qc && qc.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    mm = qc && qc.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && S4e(t, e, r);
    };
  Object.defineProperty(qc, "__esModule", {
    value: !0
  });
  __exportStar(vV(), exports);
  __exportStar(PV(), exports);
  __exportStar(OV(), exports);
  __exportStar(jI(), exports);
  __exportStar(VI(), exports);
  __exportStar(LV(), exports);
  __exportStar(WI(), exports);
});
var XI = T(hm => {
  "use strict";

  var w4e = hm && hm.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    I4e = hm && hm.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && w4e(t, e, r);
    };
  Object.defineProperty(hm, "__esModule", {
    value: !0
  });
  __exportStar(kV(), exports);
});
var pm = T(m9 => {
  "use strict";

  Object.defineProperty(m9, "__esModule", {
    value: !0
  });
  m9.Resource = void 0;
  var api_1 = ha(),
    semantic_conventions_1 = Qu(),
    core_1 = tc(),
    platform_1 = XI(),
    Resource = class _Resource {
      static {
        __name(this, "Resource");
      }
      constructor(attributes, asyncAttributesPromise) {
        var n;
        this._attributes = attributes, this.asyncAttributesPending = asyncAttributesPromise != null, this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {}, this._asyncAttributesPromise = asyncAttributesPromise?.then(asyncAttributes => (this._attributes = Object.assign({}, this._attributes, asyncAttributes), this.asyncAttributesPending = !1, asyncAttributes), err => (api_1.diag.debug("a resource's async attributes promise rejected: %s", err), this.asyncAttributesPending = !1, {}));
      }
      static empty() {
        return _Resource.EMPTY;
      }
      static default() {
        return new _Resource({
          [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var t;
        return this.asyncAttributesPending && api_1.diag.error("Accessing resource attributes before async attributes settled"), (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      async waitForAsyncAttributes() {
        this.asyncAttributesPending && (await this._asyncAttributesPromise);
      }
      merge(other) {
        var r;
        if (!other) return this;
        let mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) return new _Resource(mergedSyncAttributes);
        let mergedAttributesPromise = Promise.all([this._asyncAttributesPromise, other._asyncAttributesPromise]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var c;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
  exports.Resource = Resource;
  Resource.EMPTY = new Resource({});
});
var BV = T(MV => {
  "use strict";

  Object.defineProperty(MV, "__esModule", {
    value: !0
  });
});
var UV = T(FV => {
  "use strict";

  Object.defineProperty(FV, "__esModule", {
    value: !0
  });
});
var jV = T(qV => {
  "use strict";

  Object.defineProperty(qV, "__esModule", {
    value: !0
  });
});
var HV = T(h9 => {
  "use strict";

  Object.defineProperty(h9, "__esModule", {
    value: !0
  });
  h9.browserDetector = void 0;
  var __1 = g9(),
    BrowserDetector = class {
      static {
        __name(this, "BrowserDetector");
      }
      detect(config) {
        return Promise.resolve(__1.browserDetectorSync.detect(config));
      }
    };
  exports.browserDetector = new BrowserDetector();
});
var JI = T(_9 => {
  "use strict";

  Object.defineProperty(_9, "__esModule", {
    value: !0
  });
  _9.envDetectorSync = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    semantic_conventions_1 = Qu(),
    Resource_1 = pm(),
    EnvDetectorSync = class {
      static {
        __name(this, "EnvDetectorSync");
      }
      constructor() {
        this._MAX_LENGTH = 255, this._COMMA_SEPARATOR = ",", this._LABEL_KEY_VALUE_SPLITTER = "=", this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.", this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      detect(_config) {
        let attributes = {},
          env = (0, core_1.getEnv)(),
          rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES,
          serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes) try {
          let parsedAttributes = this._parseResourceAttributes(rawAttributes);
          Object.assign(attributes, parsedAttributes);
        } catch (e) {
          api_1.diag.debug(`EnvDetector failed: ${e.message}`);
        }
        return serviceName && (attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME] = serviceName), new Resource_1.Resource(attributes);
      }
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes) return {};
        let attributes = {},
          rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (let rawAttribute of rawAttributes) {
          let keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) continue;
          let [key, value] = keyValuePair;
          if (key = key.trim(), value = value.trim().split(/^"|"$/).join(""), !this._isValidAndNotEmpty(key)) throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          if (!this._isValid(value)) throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          let ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) return !1;
        }
        return !0;
      }
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
  exports.envDetectorSync = new EnvDetectorSync();
});
var $V = T(y9 => {
  "use strict";

  Object.defineProperty(y9, "__esModule", {
    value: !0
  });
  y9.envDetector = void 0;
  var EnvDetectorSync_1 = JI(),
    EnvDetector = class {
      static {
        __name(this, "EnvDetector");
      }
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
  exports.envDetector = new EnvDetector();
});
var VV = T(x9 => {
  "use strict";

  Object.defineProperty(x9, "__esModule", {
    value: !0
  });
  x9.browserDetectorSync = void 0;
  var semantic_conventions_1 = Qu(),
    __1 = g9(),
    api_1 = ha(),
    BrowserDetectorSync = class {
      static {
        __name(this, "BrowserDetectorSync");
      }
      detect(config) {
        if (!(typeof navigator < "u")) return __1.Resource.empty();
        let browserResource = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      _getResourceAttributes(browserResource, _config) {
        return browserResource[semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "" ? (api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. "), __1.Resource.empty()) : new __1.Resource(Object.assign({}, browserResource));
      }
    };
  exports.browserDetectorSync = new BrowserDetectorSync();
});
var GV = T(Tf => {
  "use strict";

  var M4e = Tf && Tf.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    b9 = Tf && Tf.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && M4e(t, e, r);
    };
  Object.defineProperty(Tf, "__esModule", {
    value: !0
  });
  __exportStar(HV(), exports);
  __exportStar($V(), exports);
  __exportStar(VV(), exports);
  __exportStar(JI(), exports);
});
var zV = T(E9 => {
  "use strict";

  Object.defineProperty(E9, "__esModule", {
    value: !0
  });
  E9.isPromiseLike = void 0;
  var isPromiseLike = __name(val => val !== null && typeof val == "object" && typeof val.then == "function", "isPromiseLike");
  exports.isPromiseLike = isPromiseLike;
});
var KV = T(vg => {
  "use strict";

  Object.defineProperty(vg, "__esModule", {
    value: !0
  });
  vg.detectResourcesSync = vg.detectResources = void 0;
  var Resource_1 = pm(),
    api_1 = ha(),
    utils_1 = zV(),
    detectResources = __name(async (config = {}) => {
      let resources = await Promise.all((config.detectors || []).map(async d => {
        try {
          let resource = await d.detect(config);
          return api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }));
      return logResources(resources), resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    }, "detectResources");
  exports.detectResources = detectResources;
  var detectResourcesSync = __name((config = {}) => {
    var t;
    let resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map(d => {
        try {
          let resourceOrPromise = d.detect(config),
            resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            let createPromise = __name(async () => (await resourceOrPromise).attributes, "createPromise");
            resource = new Resource_1.Resource({}, createPromise());
          } else resource = resourceOrPromise;
          return resource.waitForAsyncAttributes ? resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource)) : api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.error(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }),
      mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    return mergedResources.waitForAsyncAttributes && mergedResources.waitForAsyncAttributes().then(() => {
      logResources(resources);
    }), mergedResources;
  }, "detectResourcesSync");
  exports.detectResourcesSync = detectResourcesSync;
  var logResources = __name(resources => {
    resources.forEach(resource => {
      if (Object.keys(resource.attributes).length > 0) {
        let resourceDebugString = JSON.stringify(resource.attributes, null, 4);
        api_1.diag.verbose(resourceDebugString);
      }
    });
  }, "logResources");
});
var g9 = T(jc => {
  "use strict";

  var j4e = jc && jc.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    _m = jc && jc.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && j4e(t, e, r);
    };
  Object.defineProperty(jc, "__esModule", {
    value: !0
  });
  __exportStar(pm(), exports);
  __exportStar(BV(), exports);
  __exportStar(XI(), exports);
  __exportStar(UV(), exports);
  __exportStar(jV(), exports);
  __exportStar(GV(), exports);
  __exportStar(KV(), exports);
});
var XV = T(C9 => {
  "use strict";

  Object.defineProperty(C9, "__esModule", {
    value: !0
  });
  C9.MultiSpanProcessor = void 0;
  var core_1 = tc(),
    MultiSpanProcessor = class {
      static {
        __name(this, "MultiSpanProcessor");
      }
      constructor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      forceFlush() {
        let promises = [];
        for (let spanProcessor of this._spanProcessors) promises.push(spanProcessor.forceFlush());
        return new Promise(resolve => {
          Promise.all(promises).then(() => {
            resolve();
          }).catch(error => {
            (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed")), resolve();
          });
        });
      }
      onStart(span, context) {
        for (let spanProcessor of this._spanProcessors) spanProcessor.onStart(span, context);
      }
      onEnd(span) {
        for (let spanProcessor of this._spanProcessors) spanProcessor.onEnd(span);
      }
      shutdown() {
        let promises = [];
        for (let spanProcessor of this._spanProcessors) promises.push(spanProcessor.shutdown());
        return new Promise((resolve, reject) => {
          Promise.all(promises).then(() => {
            resolve();
          }, reject);
        });
      }
    };
  exports.MultiSpanProcessor = MultiSpanProcessor;
});
var sA = T(T9 => {
  "use strict";

  Object.defineProperty(T9, "__esModule", {
    value: !0
  });
  T9.NoopSpanProcessor = void 0;
  var NoopSpanProcessor = class {
    static {
      __name(this, "NoopSpanProcessor");
    }
    onStart(_span, _context) {}
    onEnd(_span) {}
    shutdown() {
      return Promise.resolve();
    }
    forceFlush() {
      return Promise.resolve();
    }
  };
  exports.NoopSpanProcessor = NoopSpanProcessor;
});
var QV = T(ym => {
  "use strict";

  Object.defineProperty(ym, "__esModule", {
    value: !0
  });
  ym.BasicTracerProvider = ym.ForceFlushState = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    resources_1 = g9(),
    _1 = oA(),
    config_1 = NI(),
    MultiSpanProcessor_1 = XV(),
    NoopSpanProcessor_1 = sA(),
    platform_1 = Qv(),
    utility_1 = LI(),
    ForceFlushState;
  (function (ForceFlushState) {
    ForceFlushState[ForceFlushState.resolved = 0] = "resolved", ForceFlushState[ForceFlushState.timeout = 1] = "timeout", ForceFlushState[ForceFlushState.error = 2] = "error", ForceFlushState[ForceFlushState.unresolved = 3] = "unresolved";
  })(ForceFlushState = exports.ForceFlushState || (exports.ForceFlushState = {}));
  var BasicTracerProvider = class {
    static {
      __name(this, "BasicTracerProvider");
    }
    constructor(config = {}) {
      var r;
      this._registeredSpanProcessors = [], this._tracers = new Map();
      let mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config));
      this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty(), this.resource = resources_1.Resource.default().merge(this.resource), this._config = Object.assign({}, mergedConfig, {
        resource: this.resource
      });
      let defaultExporter = this._buildExporterFromEnv();
      if (defaultExporter !== void 0) {
        let batchProcessor = new platform_1.BatchSpanProcessor(defaultExporter);
        this.activeSpanProcessor = batchProcessor;
      } else this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();
    }
    getTracer(name, version, options) {
      let key = `${name}@${version || ""}:${options?.schemaUrl || ""}`;
      return this._tracers.has(key) || this._tracers.set(key, new _1.Tracer({
        name: name,
        version: version,
        schemaUrl: options?.schemaUrl
      }, this._config, this)), this._tracers.get(key);
    }
    addSpanProcessor(spanProcessor) {
      this._registeredSpanProcessors.length === 0 && this.activeSpanProcessor.shutdown().catch(err => api_1.diag.error("Error while trying to shutdown current span processor", err)), this._registeredSpanProcessors.push(spanProcessor), this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
    }
    getActiveSpanProcessor() {
      return this.activeSpanProcessor;
    }
    register(config = {}) {
      api_1.trace.setGlobalTracerProvider(this), config.propagator === void 0 && (config.propagator = this._buildPropagatorFromEnv()), config.contextManager && api_1.context.setGlobalContextManager(config.contextManager), config.propagator && api_1.propagation.setGlobalPropagator(config.propagator);
    }
    forceFlush() {
      let timeout = this._config.forceFlushTimeoutMillis,
        promises = this._registeredSpanProcessors.map(spanProcessor => new Promise(resolve => {
          let state,
            timeoutInterval = setTimeout(() => {
              resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`)), state = ForceFlushState.timeout;
            }, timeout);
          spanProcessor.forceFlush().then(() => {
            clearTimeout(timeoutInterval), state !== ForceFlushState.timeout && (state = ForceFlushState.resolved, resolve(state));
          }).catch(error => {
            clearTimeout(timeoutInterval), state = ForceFlushState.error, resolve(error);
          });
        }));
      return new Promise((resolve, reject) => {
        Promise.all(promises).then(results => {
          let errors = results.filter(result => result !== ForceFlushState.resolved);
          errors.length > 0 ? reject(errors) : resolve();
        }).catch(error => reject([error]));
      });
    }
    shutdown() {
      return this.activeSpanProcessor.shutdown();
    }
    _getPropagator(name) {
      var r;
      return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === void 0 ? void 0 : _a();
    }
    _getSpanExporter(name) {
      var r;
      return (_a = this.constructor._registeredExporters.get(name)) === null || _a === void 0 ? void 0 : _a();
    }
    _buildPropagatorFromEnv() {
      let uniquePropagatorNames = Array.from(new Set((0, core_1.getEnv)().OTEL_PROPAGATORS)),
        validPropagators = uniquePropagatorNames.map(name => {
          let propagator = this._getPropagator(name);
          return propagator || api_1.diag.warn(`Propagator "${name}" requested through environment variable is unavailable.`), propagator;
        }).reduce((list, item) => (item && list.push(item), list), []);
      if (validPropagators.length !== 0) return uniquePropagatorNames.length === 1 ? validPropagators[0] : new core_1.CompositePropagator({
        propagators: validPropagators
      });
    }
    _buildExporterFromEnv() {
      let exporterName = (0, core_1.getEnv)().OTEL_TRACES_EXPORTER;
      if (exporterName === "none" || exporterName === "") return;
      let exporter = this._getSpanExporter(exporterName);
      return exporter || api_1.diag.error(`Exporter "${exporterName}" requested through environment variable is unavailable.`), exporter;
    }
  };
  exports.BasicTracerProvider = BasicTracerProvider;
  BasicTracerProvider._registeredPropagators = new Map([["tracecontext", () => new core_1.W3CTraceContextPropagator()], ["baggage", () => new core_1.W3CBaggagePropagator()]]);
  BasicTracerProvider._registeredExporters = new Map();
});
var ZV = T(S9 => {
  "use strict";

  Object.defineProperty(S9, "__esModule", {
    value: !0
  });
  S9.ConsoleSpanExporter = void 0;
  var core_1 = tc(),
    ConsoleSpanExporter = class {
      static {
        __name(this, "ConsoleSpanExporter");
      }
      export(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      }
      shutdown() {
        return this._sendSpans([]), this.forceFlush();
      }
      forceFlush() {
        return Promise.resolve();
      }
      _exportInfo(span) {
        var r;
        return {
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          traceState: (_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
          duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      }
      _sendSpans(spans, done) {
        for (let span of spans) console.dir(this._exportInfo(span), {
          depth: 3
        });
        if (done) return done({
          code: core_1.ExportResultCode.SUCCESS
        });
      }
    };
  exports.ConsoleSpanExporter = ConsoleSpanExporter;
});
var eG = T(w9 => {
  "use strict";

  Object.defineProperty(w9, "__esModule", {
    value: !0
  });
  w9.InMemorySpanExporter = void 0;
  var core_1 = tc(),
    InMemorySpanExporter = class {
      static {
        __name(this, "InMemorySpanExporter");
      }
      constructor() {
        this._finishedSpans = [], this._stopped = !1;
      }
      export(spans, resultCallback) {
        if (this._stopped) return resultCallback({
          code: core_1.ExportResultCode.FAILED,
          error: new Error("Exporter has been stopped")
        });
        this._finishedSpans.push(...spans), setTimeout(() => resultCallback({
          code: core_1.ExportResultCode.SUCCESS
        }), 0);
      }
      shutdown() {
        return this._stopped = !0, this._finishedSpans = [], this.forceFlush();
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._finishedSpans = [];
      }
      getFinishedSpans() {
        return this._finishedSpans;
      }
    };
  exports.InMemorySpanExporter = InMemorySpanExporter;
});
var rG = T(tG => {
  "use strict";

  Object.defineProperty(tG, "__esModule", {
    value: !0
  });
});
var nG = T(I9 => {
  "use strict";

  Object.defineProperty(I9, "__esModule", {
    value: !0
  });
  I9.SimpleSpanProcessor = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    SimpleSpanProcessor = class {
      static {
        __name(this, "SimpleSpanProcessor");
      }
      constructor(_exporter) {
        this._exporter = _exporter, this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this), this._unresolvedExports = new Set();
      }
      async forceFlush() {
        await Promise.all(Array.from(this._unresolvedExports)), this._exporter.forceFlush && (await this._exporter.forceFlush());
      }
      onStart(_span, _parentContext) {}
      onEnd(span) {
        var r, n;
        if (this._shutdownOnce.isCalled || !(span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED)) return;
        let doExport = __name(() => core_1.internal._export(this._exporter, [span]).then(result => {
          var o;
          result.code !== core_1.ExportResultCode.SUCCESS && (0, core_1.globalErrorHandler)((_a = result.error) !== null && _a !== void 0 ? _a : new Error(`SimpleSpanProcessor: span export failed (status ${result})`));
        }).catch(error => {
          (0, core_1.globalErrorHandler)(error);
        }), "doExport");
        if (span.resource.asyncAttributesPending) {
          let exportPromise = (_b = (_a = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => (exportPromise != null && this._unresolvedExports.delete(exportPromise), doExport()), err => (0, core_1.globalErrorHandler)(err));
          exportPromise != null && this._unresolvedExports.add(exportPromise);
        } else doExport();
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return this._exporter.shutdown();
      }
    };
  exports.SimpleSpanProcessor = SimpleSpanProcessor;
});
var sG = T(iG => {
  "use strict";

  Object.defineProperty(iG, "__esModule", {
    value: !0
  });
});
var aG = T(oG => {
  "use strict";

  Object.defineProperty(oG, "__esModule", {
    value: !0
  });
});
var cG = T(lG => {
  "use strict";

  Object.defineProperty(lG, "__esModule", {
    value: !0
  });
});
var fG = T(uG => {
  "use strict";

  Object.defineProperty(uG, "__esModule", {
    value: !0
  });
});
var pG = T(dG => {
  "use strict";

  Object.defineProperty(dG, "__esModule", {
    value: !0
  });
});
var oA = T(m0 => {
  "use strict";

  var Y4e = m0 && m0.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Z0 = m0 && m0.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && Y4e(t, e, r);
    };
  Object.defineProperty(m0, "__esModule", {
    value: !0
  });
  __exportStar(yV(), exports);
  __exportStar(QV(), exports);
  __exportStar(Qv(), exports);
  __exportStar(ZV(), exports);
  __exportStar(eG(), exports);
  __exportStar(rG(), exports);
  __exportStar(nG(), exports);
  __exportStar(sG(), exports);
  __exportStar(sA(), exports);
  __exportStar(qv(), exports);
  __exportStar(Hv(), exports);
  __exportStar(wI(), exports);
  __exportStar(AI(), exports);
  __exportStar(P2(), exports);
  __exportStar(bI(), exports);
  __exportStar(aG(), exports);
  __exportStar(cG(), exports);
  __exportStar(fG(), exports);
  __exportStar(pG(), exports);
});
var require_azure_coretracing_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.azureCoreTracing = exports.AzureMonitorSymbol = void 0;
  var diagnostic_channel_1 = N0();
  exports.AzureMonitorSymbol = "Azure_Monitor_Tracer";
  var publisherName = "azure-coretracing",
    isPatched = !1,
    azureCoreTracingPatchFunction = __name(function (coreTracing) {
      if (isPatched) return coreTracing;
      try {
        var tracing = oA(),
          api = ha(),
          defaultProvider = new tracing.BasicTracerProvider(),
          defaultTracer = defaultProvider.getTracer("applicationinsights tracer");
        if (coreTracing.setTracer) {
          var setTracerOriginal_1 = coreTracing.setTracer;
          coreTracing.setTracer = function (tracer) {
            var startSpanOriginal = tracer.startSpan;
            tracer.startSpan = function (name, options, context) {
              var span = startSpanOriginal.call(this, name, options, context),
                originalEnd = span.end;
              return span.end = function () {
                var result = originalEnd.apply(this, arguments);
                return diagnostic_channel_1.channel.publish(publisherName, span), result;
              }, span;
            }, tracer[exports.AzureMonitorSymbol] = !0, setTracerOriginal_1.call(this, tracer);
          }, api.trace.getSpan(api.context.active()), coreTracing.setTracer(defaultTracer);
        } else {
          var setGlobalTracerProviderOriginal_1 = api.trace.setGlobalTracerProvider;
          api.trace.setGlobalTracerProvider = function (tracerProvider) {
            var getTracerOriginal = tracerProvider.getTracer;
            return tracerProvider.getTracer = function (tracerName, version) {
              var tracer = getTracerOriginal.call(this, tracerName, version);
              if (!tracer[exports.AzureMonitorSymbol]) {
                var startSpanOriginal_1 = tracer.startSpan;
                tracer.startSpan = function (spanName, options, context) {
                  var span = startSpanOriginal_1.call(this, spanName, options, context),
                    originalEnd = span.end;
                  return span.end = function () {
                    var result = originalEnd.apply(this, arguments);
                    return diagnostic_channel_1.channel.publish(publisherName, span), result;
                  }, span;
                }, tracer[exports.AzureMonitorSymbol] = !0;
              }
              return tracer;
            }, setGlobalTracerProviderOriginal_1.call(this, tracerProvider);
          }, defaultProvider.register(), api.trace.getSpan(api.context.active());
          var openTelemetryInstr = require("@opentelemetry/instrumentation"),
            azureSdkInstr = require("@azure/opentelemetry-instrumentation-azure-sdk");
          openTelemetryInstr.registerInstrumentations({
            instrumentations: [azureSdkInstr.createAzureSdkInstrumentation()]
          });
        }
        isPatched = !0;
      } catch {}
      return coreTracing;
    }, "azureCoreTracingPatchFunction");
  exports.azureCoreTracing = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: azureCoreTracingPatchFunction,
    publisherName: publisherName
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports.azureCoreTracing);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_bunyan_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.bunyan = void 0;
  var diagnostic_channel_1 = N0(),
    bunyanPatchFunction = __name(function (originalBunyan) {
      var originalEmit = originalBunyan.prototype._emit;
      return originalBunyan.prototype._emit = function (rec, noemit) {
        var ret = originalEmit.apply(this, arguments);
        if (!noemit) {
          var str = ret;
          str || (str = originalEmit.call(this, rec, !0)), diagnostic_channel_1.channel.publish("bunyan", {
            level: rec.level,
            result: str
          });
        }
        return ret;
      }, originalBunyan;
    }, "bunyanPatchFunction");
  exports.bunyan = {
    versionSpecifier: ">= 1.0.0 < 2.0.0",
    patch: bunyanPatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports.bunyan);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_console_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.console = void 0;
  var diagnostic_channel_1 = N0(),
    stream_1 = require("stream"),
    consolePatchFunction = __name(function (originalConsole) {
      var aiLoggingOutStream = new stream_1.Writable(),
        aiLoggingErrStream = new stream_1.Writable();
      aiLoggingOutStream.write = function (chunk) {
        if (!chunk) return !0;
        var message = chunk.toString();
        return diagnostic_channel_1.channel.publish("console", {
          message: message
        }), !0;
      }, aiLoggingErrStream.write = function (chunk) {
        if (!chunk) return !0;
        var message = chunk.toString();
        return diagnostic_channel_1.channel.publish("console", {
          message: message,
          stderr: !0
        }), !0;
      };
      for (var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream), consoleMethods = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"], _loop_1 = __name(function (method) {
          var originalMethod = originalConsole[method];
          originalMethod && (originalConsole[method] = function () {
            if (aiLoggingConsole[method]) try {
              aiLoggingConsole[method].apply(aiLoggingConsole, arguments);
            } catch {}
            return originalMethod.apply(originalConsole, arguments);
          });
        }, "_loop_1"), _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {
        var method = consoleMethods_1[_i];
        _loop_1(method);
      }
      return originalConsole;
    }, "consolePatchFunction");
  exports.console = {
    versionSpecifier: ">= 4.0.0",
    patch: consolePatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("console", exports.console), require("console");
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_mongodb_core_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.mongoCore = void 0;
  var diagnostic_channel_1 = N0(),
    mongodbcorePatchFunction = __name(function (originalMongoCore) {
      var originalConnect = originalMongoCore.Server.prototype.connect;
      return originalMongoCore.Server.prototype.connect = __name(function () {
        var ret = originalConnect.apply(this, arguments),
          originalWrite = this.s.pool.write;
        this.s.pool.write = __name(function () {
          var cbidx = typeof arguments[1] == "function" ? 1 : 2;
          return typeof arguments[cbidx] == "function" && (arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx])), originalWrite.apply(this, arguments);
        }, "contextPreservingWrite");
        var originalLogout = this.s.pool.logout;
        return this.s.pool.logout = __name(function () {
          return typeof arguments[1] == "function" && (arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1])), originalLogout.apply(this, arguments);
        }, "contextPreservingLogout"), ret;
      }, "contextPreservingConnect"), originalMongoCore;
    }, "mongodbcorePatchFunction");
  exports.mongoCore = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: mongodbcorePatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports.mongoCore);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_mongodb_pub = __commonJSMin(exports => {
  "use strict";

  var __assign = exports && exports.__assign || function () {
    return __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
      }
      return t;
    }, __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.mongo330 = exports.mongo3 = exports.mongo2 = void 0;
  var diagnostic_channel_1 = N0(),
    mongodbPatchFunction = __name(function (originalMongo) {
      var listener = originalMongo.instrument({
          operationIdGenerator: {
            next: function () {
              return diagnostic_channel_1.channel.bindToContext(function (cb) {
                return cb();
              });
            }
          }
        }),
        eventMap = {};
      return listener.on("started", function (event) {
        eventMap[event.requestId] || (eventMap[event.requestId] = __assign(__assign({}, event), {
          time: new Date()
        }));
      }), listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event.operationId == "function" ? event.operationId(function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !0
          });
        }) : diagnostic_channel_1.channel.publish("mongodb", {
          startedData: startedData,
          event: event,
          succeeded: !0
        });
      }), listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event.operationId == "function" ? event.operationId(function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !1
          });
        }) : diagnostic_channel_1.channel.publish("mongodb", {
          startedData: startedData,
          event: event,
          succeeded: !1
        });
      }), originalMongo;
    }, "mongodbPatchFunction"),
    mongodb3PatchFunction = __name(function (originalMongo) {
      var listener = originalMongo.instrument(),
        eventMap = {},
        contextMap = {};
      return listener.on("started", function (event) {
        eventMap[event.requestId] || (contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) {
          return cb();
        }), eventMap[event.requestId] = __assign(__assign({}, event), {
          time: new Date()
        }));
      }), listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event == "object" && typeof contextMap[event.requestId] == "function" && (contextMap[event.requestId](function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !0
          });
        }), delete contextMap[event.requestId]);
      }), listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event == "object" && typeof contextMap[event.requestId] == "function" && (contextMap[event.requestId](function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !1
          });
        }), delete contextMap[event.requestId]);
      }), originalMongo;
    }, "mongodb3PatchFunction"),
    mongodbcorePatchFunction = __name(function (originalMongo) {
      var originalConnect = originalMongo.Server.prototype.connect;
      return originalMongo.Server.prototype.connect = __name(function () {
        var ret = originalConnect.apply(this, arguments),
          originalWrite = this.s.coreTopology.s.pool.write;
        this.s.coreTopology.s.pool.write = __name(function () {
          var cbidx = typeof arguments[1] == "function" ? 1 : 2;
          return typeof arguments[cbidx] == "function" && (arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx])), originalWrite.apply(this, arguments);
        }, "contextPreservingWrite");
        var originalLogout = this.s.coreTopology.s.pool.logout;
        return this.s.coreTopology.s.pool.logout = __name(function () {
          return typeof arguments[1] == "function" && (arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1])), originalLogout.apply(this, arguments);
        }, "contextPreservingLogout"), ret;
      }, "contextPreservingConnect"), originalMongo;
    }, "mongodbcorePatchFunction"),
    mongodb330PatchFunction = __name(function (originalMongo) {
      mongodbcorePatchFunction(originalMongo);
      var listener = originalMongo.instrument(),
        eventMap = {},
        contextMap = {};
      return listener.on("started", function (event) {
        eventMap[event.requestId] || (contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function (cb) {
          return cb();
        }), eventMap[event.requestId] = event);
      }), listener.on("succeeded", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event == "object" && typeof contextMap[event.requestId] == "function" && (contextMap[event.requestId](function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !0
          });
        }), delete contextMap[event.requestId]);
      }), listener.on("failed", function (event) {
        var startedData = eventMap[event.requestId];
        startedData && delete eventMap[event.requestId], typeof event == "object" && typeof contextMap[event.requestId] == "function" && (contextMap[event.requestId](function () {
          return diagnostic_channel_1.channel.publish("mongodb", {
            startedData: startedData,
            event: event,
            succeeded: !1
          });
        }), delete contextMap[event.requestId]);
      }), originalMongo;
    }, "mongodb330PatchFunction");
  exports.mongo2 = {
    versionSpecifier: ">= 2.0.0 <= 3.0.5",
    patch: mongodbPatchFunction
  };
  exports.mongo3 = {
    versionSpecifier: "> 3.0.5 < 3.3.0",
    patch: mongodb3PatchFunction
  };
  exports.mongo330 = {
    versionSpecifier: ">= 3.3.0 < 4.0.0",
    patch: mongodb330PatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo2), diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo3), diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports.mongo330);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_mysql_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.mysql = void 0;
  var diagnostic_channel_1 = N0(),
    path = require("path"),
    mysqlPatchFunction = __name(function (originalMysql, originalMysqlPath) {
      var patchObjectFunction = __name(function (obj, name) {
          return function (func, cbWrapper) {
            var originalFunc = obj[func];
            originalFunc && (obj[func] = __name(function () {
              for (var cbidx = arguments.length - 1, i = arguments.length - 1; i >= 0; --i) if (typeof arguments[i] == "function") {
                cbidx = i;
                break;
              } else if (typeof arguments[i] < "u") break;
              var cb = arguments[cbidx],
                resultContainer = {
                  result: null,
                  startTime: null,
                  startDate: null
                };
              typeof cb == "function" && (cbWrapper ? (resultContainer.startTime = process.hrtime(), resultContainer.startDate = new Date(), arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb))) : arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb));
              var result = originalFunc.apply(this, arguments);
              return resultContainer.result = result, result;
            }, "mysqlContextPreserver"));
          };
        }, "patchObjectFunction"),
        patchClassMemberFunction = __name(function (classObject, name) {
          return patchObjectFunction(classObject.prototype, name + ".prototype");
        }, "patchClassMemberFunction"),
        connectionCallbackFunctions = ["connect", "changeUser", "ping", "statistics", "end"],
        connectionClass = require(path.dirname(originalMysqlPath) + "/lib/Connection");
      connectionCallbackFunctions.forEach(function (value) {
        return patchClassMemberFunction(connectionClass, "Connection")(value);
      }), patchObjectFunction(connectionClass, "Connection")("createQuery", function (resultContainer, cb) {
        return function (err) {
          var hrDuration = process.hrtime(resultContainer.startTime),
            duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
          diagnostic_channel_1.channel.publish("mysql", {
            query: resultContainer.result,
            callbackArgs: arguments,
            err: err,
            duration: duration,
            time: resultContainer.startDate
          }), cb.apply(this, arguments);
        };
      });
      var poolCallbackFunctions = ["_enqueueCallback"],
        poolClass = require(path.dirname(originalMysqlPath) + "/lib/Pool");
      return poolCallbackFunctions.forEach(function (value) {
        return patchClassMemberFunction(poolClass, "Pool")(value);
      }), originalMysql;
    }, "mysqlPatchFunction");
  exports.mysql = {
    versionSpecifier: ">= 2.0.0 < 3.0.0",
    patch: mysqlPatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports.mysql);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_pg_pool_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.postgresPool1 = void 0;
  var diagnostic_channel_1 = N0();
  function postgresPool1PatchFunction(originalPgPool) {
    var originalConnect = originalPgPool.prototype.connect;
    return originalPgPool.prototype.connect = __name(function (callback) {
      return callback && (arguments[0] = diagnostic_channel_1.channel.bindToContext(callback)), originalConnect.apply(this, arguments);
    }, "connect"), originalPgPool;
  }
  __name(postgresPool1PatchFunction, "postgresPool1PatchFunction");
  exports.postgresPool1 = {
    versionSpecifier: ">= 1.0.0 < 3.0.0",
    patch: postgresPool1PatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports.postgresPool1);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_pg_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.postgres = exports.postgres6 = void 0;
  var diagnostic_channel_1 = N0(),
    events_1 = require("events"),
    publisherName = "postgres";
  function postgres6PatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query,
      diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    return originalPg.Client.prototype.query = __name(function (config, values, callback) {
      var data = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: new Date()
        },
        start = process.hrtime(),
        queryResult;
      function patchCallback(cb) {
        cb && cb[diagnosticOriginalFunc] && (cb = cb[diagnosticOriginalFunc]);
        var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
          var end = process.hrtime(start);
          if (data.result = res && {
            rowCount: res.rowCount,
            command: res.command
          }, data.error = err, data.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6), diagnostic_channel_1.channel.publish(publisherName, data), err) {
            if (cb) return cb.apply(this, arguments);
            queryResult && queryResult instanceof events_1.EventEmitter && queryResult.emit("error", err);
          } else cb && cb.apply(this, arguments);
        });
        try {
          return Object.defineProperty(trackingCallback, diagnosticOriginalFunc, {
            value: cb
          }), trackingCallback;
        } catch {
          return cb;
        }
      }
      __name(patchCallback, "patchCallback");
      try {
        typeof config == "string" ? values instanceof Array ? (data.query.preparable = {
          text: config,
          args: values
        }, callback = patchCallback(callback)) : (data.query.text = config, callback ? callback = patchCallback(callback) : values = patchCallback(values)) : (typeof config.name == "string" ? data.query.plan = config.name : config.values instanceof Array ? data.query.preparable = {
          text: config.text,
          args: config.values
        } : data.query.text = config.text, callback ? callback = patchCallback(callback) : values ? values = patchCallback(values) : config.callback = patchCallback(config.callback));
      } catch {
        return originalClientQuery.apply(this, arguments);
      }
      return arguments[0] = config, arguments[1] = values, arguments[2] = callback, arguments.length = arguments.length > 3 ? arguments.length : 3, queryResult = originalClientQuery.apply(this, arguments), queryResult;
    }, "query"), originalPg;
  }
  __name(postgres6PatchFunction, "postgres6PatchFunction");
  function postgresLatestPatchFunction(originalPg, originalPgPath) {
    var originalClientQuery = originalPg.Client.prototype.query,
      diagnosticOriginalFunc = "__diagnosticOriginalFunc";
    return originalPg.Client.prototype.query = __name(function (config, values, callback) {
      var _this = this,
        _a,
        _b,
        callbackProvided = !!callback,
        data = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: new Date()
        },
        queryResult,
        start = process.hrtime();
      function patchCallback(cb) {
        cb && cb[diagnosticOriginalFunc] && (cb = cb[diagnosticOriginalFunc]);
        var trackingCallback = diagnostic_channel_1.channel.bindToContext(function (err, res) {
          var end = process.hrtime(start);
          if (data.result = res && {
            rowCount: res.rowCount,
            command: res.command
          }, data.error = err, data.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6), diagnostic_channel_1.channel.publish(publisherName, data), err) {
            if (cb) return cb.apply(this, arguments);
            queryResult && queryResult instanceof events_1.EventEmitter && queryResult.emit("error", err);
          } else cb && cb.apply(this, arguments);
        });
        try {
          return Object.defineProperty(trackingCallback, diagnosticOriginalFunc, {
            value: cb
          }), trackingCallback;
        } catch {
          return cb;
        }
      }
      __name(patchCallback, "patchCallback");
      try {
        typeof config == "string" ? values instanceof Array ? (data.query.preparable = {
          text: config,
          args: values
        }, callbackProvided = typeof callback == "function", callback = callbackProvided ? patchCallback(callback) : callback) : (data.query.text = config, callback ? (callbackProvided = typeof callback == "function", callback = callbackProvided ? patchCallback(callback) : callback) : (callbackProvided = typeof values == "function", values = callbackProvided ? patchCallback(values) : values)) : (typeof config.name == "string" ? data.query.plan = config.name : config.values instanceof Array ? data.query.preparable = {
          text: config.text,
          args: config.values
        } : config.cursor ? data.query.text = (_a = config.cursor) === null || _a === void 0 ? void 0 : _a.text : data.query.text = config.text, callback ? (callbackProvided = typeof callback == "function", callback = patchCallback(callback)) : values ? (callbackProvided = typeof values == "function", values = callbackProvided ? patchCallback(values) : values) : (callbackProvided = typeof config.callback == "function", config.callback = callbackProvided ? patchCallback(config.callback) : config.callback));
      } catch {
        return originalClientQuery.apply(this, arguments);
      }
      arguments[0] = config, arguments[1] = values, arguments[2] = callback, arguments.length = arguments.length > 3 ? arguments.length : 3;
      try {
        queryResult = originalClientQuery.apply(this, arguments);
      } catch (err) {
        throw patchCallback()(err, void 0), err;
      }
      if (!callbackProvided) {
        if (queryResult instanceof Promise) return queryResult.then(function (result) {
          return patchCallback()(void 0, result), new _this._Promise(function (resolve, reject) {
            resolve(result);
          });
        }).catch(function (error) {
          return patchCallback()(error, void 0), new _this._Promise(function (resolve, reject) {
            reject(error);
          });
        });
        var command = queryResult.text ? queryResult.text : "";
        if (queryResult.cursor && (command = (_b = queryResult.cursor) === null || _b === void 0 ? void 0 : _b.text), command) {
          var res = {
            command: command,
            rowCount: 0
          };
          patchCallback()(void 0, res);
        }
      }
      return queryResult;
    }, "query"), originalPg;
  }
  __name(postgresLatestPatchFunction, "postgresLatestPatchFunction");
  exports.postgres6 = {
    versionSpecifier: "6.*",
    patch: postgres6PatchFunction
  };
  exports.postgres = {
    versionSpecifier: ">=7.* <=8.*",
    patch: postgresLatestPatchFunction,
    publisherName: publisherName
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres6), diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports.postgres);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_redis_pub = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.redis = void 0;
  var diagnostic_channel_1 = N0(),
    redisPatchFunction = __name(function (originalRedis) {
      var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
      return originalRedis.RedisClient.prototype.internal_send_command = function (commandObj) {
        if (commandObj) {
          var cb_1 = commandObj.callback;
          if (!cb_1 || !cb_1.pubsubBound) {
            var address_1 = this.address,
              startTime_1 = process.hrtime(),
              startDate_1 = new Date();
            commandObj.callback = diagnostic_channel_1.channel.bindToContext(function (err, result) {
              var hrDuration = process.hrtime(startTime_1),
                duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
              diagnostic_channel_1.channel.publish("redis", {
                duration: duration,
                address: address_1,
                commandObj: commandObj,
                err: err,
                result: result,
                time: startDate_1
              }), typeof cb_1 == "function" && cb_1.apply(this, arguments);
            }), commandObj.callback.pubsubBound = !0;
          }
        }
        return originalSend.call(this, commandObj);
      }, originalRedis;
    }, "redisPatchFunction");
  exports.redis = {
    versionSpecifier: ">= 2.0.0 < 4.0.0",
    patch: redisPatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports.redis);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_tedious_pub = __commonJSMin(exports => {
  "use strict";

  var __assign = exports && exports.__assign || function () {
    return __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
      }
      return t;
    }, __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.tedious = void 0;
  var diagnostic_channel_1 = N0(),
    tediousPatchFunction = __name(function (originalTedious) {
      var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
      return originalTedious.Connection.prototype.makeRequest = __name(function () {
        function getPatchedCallback(origCallback) {
          var start = process.hrtime(),
            data = {
              query: {},
              database: {
                host: null,
                port: null
              },
              result: null,
              error: null,
              duration: 0
            };
          return diagnostic_channel_1.channel.bindToContext(function (err, rowCount, rows) {
            var end = process.hrtime(start);
            data = __assign(__assign({}, data), {
              database: {
                host: this.connection.config.server,
                port: this.connection.config.options.port
              },
              result: !err && {
                rowCount: rowCount,
                rows: rows
              },
              query: {
                text: this.parametersByName.statement.value
              },
              error: err,
              duration: Math.ceil(end[0] * 1e3 + end[1] / 1e6)
            }), diagnostic_channel_1.channel.publish("tedious", data), origCallback.call(this, err, rowCount, rows);
          });
        }
        __name(getPatchedCallback, "getPatchedCallback");
        var request = arguments[0];
        arguments[0].callback = getPatchedCallback(request.callback), originalMakeRequest.apply(this, arguments);
      }, "makeRequest"), originalTedious;
    }, "tediousPatchFunction");
  exports.tedious = {
    versionSpecifier: ">= 6.0.0 < 9.0.0",
    patch: tediousPatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports.tedious);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_winston_pub = __commonJSMin(exports => {
  "use strict";

  var __extends = exports && exports.__extends || function () {
      var extendStatics = __name(function (d, b) {
        return extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        }, extendStatics(d, b);
      }, "extendStatics");
      return function (d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__"), d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }(),
    __rest = exports && exports.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (s != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      return t;
    };
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.winston2 = exports.winston3 = void 0;
  var diagnostic_channel_1 = N0(),
    winston2PatchFunction = __name(function (originalWinston) {
      var originalLog = originalWinston.Logger.prototype.log,
        curLevels,
        loggingFilter = __name(function (level, message, meta) {
          var levelKind;
          return curLevels === originalWinston.config.npm.levels ? levelKind = "npm" : curLevels === originalWinston.config.syslog.levels ? levelKind = "syslog" : levelKind = "unknown", diagnostic_channel_1.channel.publish("winston", {
            level: level,
            message: message,
            meta: meta,
            levelKind: levelKind
          }), message;
        }, "loggingFilter");
      return originalWinston.Logger.prototype.log = __name(function () {
        return curLevels = this.levels, !this.filters || this.filters.length === 0 ? this.filters = [loggingFilter] : this.filters[this.filters.length - 1] !== loggingFilter && (this.filters = this.filters.filter(function (f) {
          return f !== loggingFilter;
        }), this.filters.push(loggingFilter)), originalLog.apply(this, arguments);
      }, "log"), originalWinston;
    }, "winston2PatchFunction"),
    winston3PatchFunction = __name(function (originalWinston) {
      var mapLevelToKind = __name(function (winston, level) {
          var levelKind;
          return winston.config.npm.levels[level] != null ? levelKind = "npm" : winston.config.syslog.levels[level] != null ? levelKind = "syslog" : levelKind = "unknown", levelKind;
        }, "mapLevelToKind"),
        AppInsightsTransport = function (_super) {
          __extends(AppInsightsTransport, _super);
          function AppInsightsTransport(winston, opts) {
            var _this = _super.call(this, opts) || this;
            return _this.winston = winston, _this;
          }
          return __name(AppInsightsTransport, "AppInsightsTransport"), AppInsightsTransport.prototype.log = function (info, callback) {
            var message = info.message,
              level = info.level,
              meta = info.meta,
              splat = __rest(info, ["message", "level", "meta"]);
            level = typeof Symbol.for == "function" ? info[Symbol.for("level")] : level, message = info instanceof Error ? info : message;
            var levelKind = mapLevelToKind(this.winston, level);
            meta = meta || {};
            for (var key in splat) splat.hasOwnProperty(key) && (meta[key] = splat[key]);
            diagnostic_channel_1.channel.publish("winston", {
              message: message,
              level: level,
              levelKind: levelKind,
              meta: meta
            }), callback();
          }, AppInsightsTransport;
        }(originalWinston.Transport);
      function patchedConfigure() {
        var levels = originalWinston.config.npm.levels;
        arguments && arguments[0] && arguments[0].levels && (levels = arguments[0].levels);
        var lastLevel;
        for (var level in levels) levels.hasOwnProperty(level) && (lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel);
        this.add(new AppInsightsTransport(originalWinston, {
          level: lastLevel
        }));
      }
      __name(patchedConfigure, "patchedConfigure");
      var origCreate = originalWinston.createLogger;
      originalWinston.createLogger = __name(function () {
        var levels = originalWinston.config.npm.levels;
        arguments && arguments[0] && arguments[0].levels && (levels = arguments[0].levels);
        var lastLevel;
        for (var level in levels) levels.hasOwnProperty(level) && (lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel);
        var result = origCreate.apply(this, arguments);
        result.add(new AppInsightsTransport(originalWinston, {
          level: lastLevel
        }));
        var origConfigure = result.configure;
        return result.configure = function () {
          origConfigure.apply(this, arguments), patchedConfigure.apply(this, arguments);
        }, result;
      }, "patchedCreate");
      var origRootConfigure = originalWinston.configure;
      return originalWinston.configure = function () {
        origRootConfigure.apply(this, arguments), patchedConfigure.apply(this, arguments);
      }, originalWinston.add(new AppInsightsTransport(originalWinston)), originalWinston;
    }, "winston3PatchFunction");
  exports.winston3 = {
    versionSpecifier: "3.x",
    patch: winston3PatchFunction
  };
  exports.winston2 = {
    versionSpecifier: "2.x",
    patch: winston2PatchFunction
  };
  function enable() {
    diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston2), diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports.winston3);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var require_src = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.enable = exports.tedious = exports.pgPool = exports.pg = exports.winston = exports.redis = exports.mysql = exports.mongodb = exports.mongodbCore = exports.console = exports.bunyan = exports.azuresdk = void 0;
  var azuresdk = hG();
  exports.azuresdk = azuresdk;
  var bunyan = _G();
  exports.bunyan = bunyan;
  var consolePub = vG();
  exports.console = consolePub;
  var mongodbCore = xG();
  exports.mongodbCore = mongodbCore;
  var mongodb = bG();
  exports.mongodb = mongodb;
  var mysql = CG();
  exports.mysql = mysql;
  var pgPool = SG();
  exports.pgPool = pgPool;
  var pg = IG();
  exports.pg = pg;
  var redis = AG();
  exports.redis = redis;
  var tedious = PG();
  exports.tedious = tedious;
  var winston = RG();
  exports.winston = winston;
  function enable() {
    bunyan.enable(), consolePub.enable(), mongodbCore.enable(), mongodb.enable(), mysql.enable(), pg.enable(), pgPool.enable(), redis.enable(), winston.enable(), azuresdk.enable(), tedious.enable();
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var L9 = T(Ap => {
  "use strict";

  Object.defineProperty(Ap, "__esModule", {
    value: !0
  });
  Ap.registerContextPreservation = Ap.IsInitialized = void 0;
  var Logging = x0(),
    JsonConfig_1 = o6();
  exports.IsInitialized = !JsonConfig_1.JsonConfig.getInstance().noDiagnosticChannel;
  var TAG = "DiagnosticChannel";
  if (exports.IsInitialized) {
    publishers = HG(), individualOptOuts = JsonConfig_1.JsonConfig.getInstance().noPatchModules, unpatchedModules = individualOptOuts.split(","), modules = {
      bunyan: publishers.bunyan,
      console: publishers.console,
      mongodb: publishers.mongodb,
      mongodbCore: publishers.mongodbCore,
      mysql: publishers.mysql,
      redis: publishers.redis,
      pg: publishers.pg,
      pgPool: publishers.pgPool,
      winston: publishers.winston,
      azuresdk: publishers.azuresdk
    };
    for (mod in modules) unpatchedModules.indexOf(mod) === -1 && (modules[mod].enable(), Logging.info(TAG, "Subscribed to " + mod + " events"));
    unpatchedModules.length > 0 && Logging.info(TAG, "Some modules will not be patched", unpatchedModules);
  } else Logging.info(TAG, "Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");
  var publishers, individualOptOuts, unpatchedModules, modules, mod;
  function registerContextPreservation(cb) {
    if (exports.IsInitialized) {
      var diagChannel = N0();
      diagChannel.channel.addContextPreservation(cb);
    }
  }
  __name(registerContextPreservation, "registerContextPreservation");
  exports.registerContextPreservation = registerContextPreservation;
});
var wg = T((xXe, GG) => {
  "use strict";

  module.exports = {
    requestContextHeader: "request-context",
    requestContextSourceKey: "appId",
    requestContextTargetKey: "appId",
    requestIdHeader: "request-id",
    parentIdHeader: "x-ms-request-id",
    rootIdHeader: "x-ms-request-root-id",
    correlationContextHeader: "correlation-context",
    traceparentHeader: "traceparent",
    traceStateHeader: "tracestate"
  };
});
var il = T((CA, zG) => {
  "use strict";

  var Rp = CA && CA.__assign || function () {
      return Rp = Object.assign || function (e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
          t = arguments[r];
          for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }, Rp.apply(this, arguments);
    },
    http = require("http"),
    https = require("https"),
    url = require("url"),
    constants = require("constants"),
    Logging = x0(),
    RequestResponseHeaders = wg(),
    JsonConfig_1 = o6(),
    Util = function () {
      function Util() {
        Util._addCloseHandler();
      }
      return __name(Util, "Util"), Util.getCookie = function (name, cookie) {
        var value = "";
        if (name && name.length && typeof cookie == "string") for (var cookieName = name + "=", cookies = cookie.split(";"), i = 0; i < cookies.length; i++) {
          var cookie = cookies[i];
          if (cookie = Util.trim(cookie), cookie && cookie.indexOf(cookieName) === 0) {
            value = cookie.substring(cookieName.length, cookies[i].length);
            break;
          }
        }
        return value;
      }, Util.trim = function (str) {
        return typeof str == "string" ? str.replace(/^\s+|\s+$/g, "") : "";
      }, Util.int32ArrayToBase64 = function (array) {
        var toChar = __name(function (v, i) {
            return String.fromCharCode(v >> i & 255);
          }, "toChar"),
          int32AsString = __name(function (v) {
            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
          }, "int32AsString"),
          x = array.map(int32AsString).join(""),
          b = Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary"),
          s = b.toString("base64");
        return s.substr(0, s.indexOf("="));
      }, Util.random32 = function () {
        return 4294967296 * Math.random() | 0;
      }, Util.randomu32 = function () {
        return Util.random32() + 2147483648;
      }, Util.w3cTraceId = function () {
        for (var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], oct = "", tmp, a = 0; a < 4; a++) tmp = Util.random32(), oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
        var clockSequenceHi = hexValues[8 + Math.random() * 4 | 0];
        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
      }, Util.w3cSpanId = function () {
        return Util.w3cTraceId().substring(16);
      }, Util.isValidW3CId = function (id) {
        return id.length === 32 && id !== "00000000000000000000000000000000";
      }, Util.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      }, Util.isError = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Error]";
      }, Util.isPrimitive = function (input) {
        var propType = typeof input;
        return propType === "string" || propType === "number" || propType === "boolean";
      }, Util.isDate = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
      }, Util.msToTimeSpan = function (totalms) {
        (isNaN(totalms) || totalms < 0) && (totalms = 0);
        var sec = (totalms / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, ""),
          min = "" + Math.floor(totalms / (1e3 * 60)) % 60,
          hour = "" + Math.floor(totalms / (1e3 * 60 * 60)) % 24,
          days = Math.floor(totalms / (1e3 * 60 * 60 * 24));
        sec = sec.indexOf(".") < 2 ? "0" + sec : sec, min = min.length < 2 ? "0" + min : min, hour = hour.length < 2 ? "0" + hour : hour;
        var daysText = days > 0 ? days + "." : "";
        return daysText + hour + ":" + min + ":" + sec;
      }, Util.extractError = function (err) {
        var looseError = err;
        return {
          message: err.message,
          code: looseError.code || looseError.id || ""
        };
      }, Util.extractObject = function (origProperty) {
        return origProperty instanceof Error ? Util.extractError(origProperty) : typeof origProperty.toJSON == "function" ? origProperty.toJSON() : origProperty;
      }, Util.validateStringMap = function (obj) {
        if (typeof obj != "object") {
          Logging.info("Invalid properties dropped from payload");
          return;
        }
        var map = {};
        for (var field in obj) {
          var property = "",
            origProperty = obj[field],
            propType = typeof origProperty;
          if (Util.isPrimitive(origProperty)) property = origProperty.toString();else if (origProperty === null || propType === "undefined") property = "";else if (propType === "function") {
            Logging.info("key: " + field + " was function; will not serialize");
            continue;
          } else {
            var stringTarget = Util.isArray(origProperty) ? origProperty : Util.extractObject(origProperty);
            try {
              Util.isPrimitive(stringTarget) ? property = stringTarget : property = JSON.stringify(stringTarget);
            } catch (e) {
              property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")", Logging.info("key: " + field + ", could not be serialized");
            }
          }
          map[field] = property.substring(0, Util.MAX_PROPERTY_LENGTH);
        }
        return map;
      }, Util.canIncludeCorrelationHeader = function (client, requestUrl) {
        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) return !0;
        for (var i = 0; i < excludedDomains.length; i++) {
          var regex = new RegExp(excludedDomains[i].replace(/\./g, ".").replace(/\*/g, ".*"));
          try {
            if (regex.test(new url.URL(requestUrl).hostname)) return !1;
          } catch {}
        }
        return !0;
      }, Util.getCorrelationContextTarget = function (response, key) {
        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
        if (contextHeaders) for (var keyValues = contextHeaders.split(","), i = 0; i < keyValues.length; ++i) {
          var keyValue = keyValues[i].split("=");
          if (keyValue.length == 2 && keyValue[0] == key) return keyValue[1];
        }
      }, Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback, useProxy, useAgent) {
        useProxy === void 0 && (useProxy = !0), useAgent === void 0 && (useAgent = !0), requestUrl && requestUrl.indexOf("//") === 0 && (requestUrl = "https:" + requestUrl);
        var requestUrlParsed = new url.URL(requestUrl),
          options = __assign(__assign({}, requestOptions), {
            host: requestUrlParsed.hostname,
            port: requestUrlParsed.port,
            path: requestUrlParsed.pathname
          }),
          proxyUrl = void 0;
        if (useProxy && (requestUrlParsed.protocol === "https:" && (proxyUrl = config.proxyHttpsUrl || void 0), requestUrlParsed.protocol === "http:" && (proxyUrl = config.proxyHttpUrl || void 0), proxyUrl)) {
          proxyUrl.indexOf("//") === 0 && (proxyUrl = "http:" + proxyUrl);
          try {
            var proxyUrlParsed = new url.URL(proxyUrl);
            proxyUrlParsed.protocol === "https:" ? (Logging.info("Proxies that use HTTPS are not supported"), proxyUrl = void 0) : options = __assign(__assign({}, options), {
              host: proxyUrlParsed.hostname,
              port: proxyUrlParsed.port || "80",
              path: requestUrl,
              headers: __assign(__assign({}, options.headers), {
                Host: requestUrlParsed.hostname
              })
            });
          } catch {
            Logging.warn("Wrong proxy URL provided");
          }
        }
        var isHttps = requestUrlParsed.protocol === "https:" && !proxyUrl;
        return useAgent && (isHttps && config.httpsAgent !== void 0 ? options.agent = config.httpsAgent : !isHttps && config.httpAgent !== void 0 ? options.agent = config.httpAgent : isHttps && (options.agent = Util._useKeepAlive ? Util.keepAliveAgent : Util.tlsRestrictedAgent)), isHttps ? https.request(options, requestCallback) : http.request(options, requestCallback);
      }, Util.safeIncludeCorrelationHeader = function (client, request, correlationHeader) {
        var header;
        if (typeof correlationHeader == "string") header = correlationHeader;else if (correlationHeader instanceof Array) header = correlationHeader.join(",");else if (correlationHeader && typeof correlationHeader.toString == "function") try {
          header = correlationHeader.toString();
        } catch (err) {
          Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
        }
        header ? Util.addCorrelationIdHeaderFromString(client, request, header) : request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
      }, Util.dumpObj = function (object) {
        if (object) try {
          var objectTypeDump = Object.prototype.toString.call(object),
            propertyValueDump = "";
          return objectTypeDump === "[object Error]" ? propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'" : propertyValueDump = this.stringify(object), objectTypeDump + propertyValueDump;
        } catch {
          return object.toString();
        }
      }, Util.stringify = function (payload) {
        try {
          return JSON.stringify(payload);
        } catch (error) {
          Logging.warn("Failed to serialize payload", error, payload);
        }
      }, Util.addCorrelationIdHeaderFromString = function (client, response, correlationHeader) {
        var components = correlationHeader.split(","),
          key = RequestResponseHeaders.requestContextSourceKey + "=",
          found = components.some(function (value) {
            return value.substring(0, key.length) === key;
          });
        found || response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
      }, Util._addCloseHandler = function () {
        Util._listenerAttached || (process.on("exit", function () {
          Util.isNodeExit = !0, Util._useKeepAlive = !1;
        }), Util._listenerAttached = !0);
      }, Util._useKeepAlive = !JsonConfig_1.JsonConfig.getInstance().noHttpAgentKeepAlive, Util._listenerAttached = !1, Util.MAX_PROPERTY_LENGTH = 8192, Util.keepAliveAgent = new https.Agent({
        keepAlive: !0,
        maxSockets: 25,
        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
      }), Util.tlsRestrictedAgent = new https.Agent({
        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
      }), Util.isNodeExit = !1, Util;
    }();
  module.exports = Util;
});
var wm = T((EXe, WG) => {
  "use strict";

  var Util = il(),
    CorrelationIdManager = function () {
      function CorrelationIdManager() {}
      return __name(CorrelationIdManager, "CorrelationIdManager"), CorrelationIdManager.queryCorrelationId = function (config, callback) {}, CorrelationIdManager.cancelCorrelationIdQuery = function (config, callback) {}, CorrelationIdManager.generateRequestId = function (parentId) {
        if (parentId) {
          parentId = parentId[0] == "|" ? parentId : "|" + parentId, parentId[parentId.length - 1] !== "." && (parentId += ".");
          var suffix = (CorrelationIdManager.currentRootId++).toString(16);
          return CorrelationIdManager.appendSuffix(parentId, suffix, "_");
        } else return CorrelationIdManager.generateRootId();
      }, CorrelationIdManager.getRootId = function (id) {
        var endIndex = id.indexOf(".");
        endIndex < 0 && (endIndex = id.length);
        var startIndex = id[0] === "|" ? 1 : 0;
        return id.substring(startIndex, endIndex);
      }, CorrelationIdManager.generateRootId = function () {
        return "|" + Util.w3cTraceId() + ".";
      }, CorrelationIdManager.appendSuffix = function (parentId, suffix, delimiter) {
        if (parentId.length + suffix.length < CorrelationIdManager.requestIdMaxLength) return parentId + suffix + delimiter;
        var trimPosition = CorrelationIdManager.requestIdMaxLength - 9;
        if (parentId.length > trimPosition) for (; trimPosition > 1; --trimPosition) {
          var c = parentId[trimPosition - 1];
          if (c === "." || c === "_") break;
        }
        if (trimPosition <= 1) return CorrelationIdManager.generateRootId();
        for (suffix = Util.randomu32().toString(16); suffix.length < 8;) suffix = "0" + suffix;
        return parentId.substring(0, trimPosition) + suffix + "#";
      }, CorrelationIdManager.correlationIdPrefix = "cid-v1:", CorrelationIdManager.w3cEnabled = !0, CorrelationIdManager.HTTP_TIMEOUT = 2500, CorrelationIdManager.requestIdMaxLength = 1024, CorrelationIdManager.currentRootId = Util.randomu32(), CorrelationIdManager;
    }();
  module.exports = CorrelationIdManager;
});
var k9 = T((TXe, KG) => {
  "use strict";

  var Util = il(),
    CorrelationIdManager = wm(),
    Traceparent = function () {
      function Traceparent(traceparent, parentId) {
        if (this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG, this.version = Traceparent.DEFAULT_VERSION, traceparent && typeof traceparent == "string") {
          if (traceparent.split(",").length > 1) this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16);else {
            var traceparentArr = traceparent.trim().split("-"),
              len = traceparentArr.length;
            len >= 4 ? (this.version = traceparentArr[0], this.traceId = traceparentArr[1], this.spanId = traceparentArr[2], this.traceFlag = traceparentArr[3]) : (this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16)), this.version.match(/^[0-9a-f]{2}$/g) || (this.version = Traceparent.DEFAULT_VERSION, this.traceId = Util.w3cTraceId()), this.version === "00" && len !== 4 && (this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16)), this.version === "ff" && (this.version = Traceparent.DEFAULT_VERSION, this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16)), this.version.match(/^0[0-9a-f]$/g) || (this.version = Traceparent.DEFAULT_VERSION), this.traceFlag.match(/^[0-9a-f]{2}$/g) || (this.traceFlag = Traceparent.DEFAULT_TRACE_FLAG, this.traceId = Util.w3cTraceId()), Traceparent.isValidTraceId(this.traceId) || (this.traceId = Util.w3cTraceId()), Traceparent.isValidSpanId(this.spanId) || (this.spanId = Util.w3cTraceId().substr(0, 16), this.traceId = Util.w3cTraceId()), this.parentId = this.getBackCompatRequestId();
          }
        } else if (parentId) {
          this.parentId = parentId.slice();
          var operationId = CorrelationIdManager.getRootId(parentId);
          Traceparent.isValidTraceId(operationId) || (this.legacyRootId = operationId, operationId = Util.w3cTraceId()), parentId.indexOf("|") !== -1 && (parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1)), this.traceId = operationId, this.spanId = parentId;
        } else this.traceId = Util.w3cTraceId(), this.spanId = Util.w3cTraceId().substr(0, 16);
      }
      return __name(Traceparent, "Traceparent"), Traceparent.isValidTraceId = function (id) {
        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
      }, Traceparent.isValidSpanId = function (id) {
        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
      }, Traceparent.formatOpenTelemetryTraceFlags = function (traceFlags) {
        var formattedFlags = "0" + traceFlags.toString(16);
        return formattedFlags.substring(formattedFlags.length - 2);
      }, Traceparent.prototype.getBackCompatRequestId = function () {
        return "|" + this.traceId + "." + this.spanId + ".";
      }, Traceparent.prototype.toString = function () {
        return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
      }, Traceparent.prototype.updateSpanId = function () {
        this.spanId = Util.w3cTraceId().substr(0, 16);
      }, Traceparent.DEFAULT_TRACE_FLAG = "01", Traceparent.DEFAULT_VERSION = "00", Traceparent;
    }();
  module.exports = Traceparent;
});
var SA = T((wXe, XG) => {
  "use strict";

  var Tracestate = function () {
    function Tracestate(id) {
      this.fieldmap = [], id && (this.fieldmap = this.parseHeader(id));
    }
    return __name(Tracestate, "Tracestate"), Tracestate.prototype.toString = function () {
      var fieldarr = this.fieldmap;
      return !fieldarr || fieldarr.length == 0 ? null : fieldarr.join(", ");
    }, Tracestate.validateKeyChars = function (key) {
      var keyParts = key.split("@");
      if (keyParts.length == 2) {
        var tenant = keyParts[0].trim(),
          vendor = keyParts[1].trim(),
          tenantValid = !!tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/),
          vendorValid = !!vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/);
        return tenantValid && vendorValid;
      } else if (keyParts.length == 1) return !!key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/);
      return !1;
    }, Tracestate.prototype.parseHeader = function (id) {
      var res = [],
        keydeduper = {},
        parts = id.split(",");
      if (parts.length > 32) return null;
      for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
        var rawPart = parts_1[_i],
          part = rawPart.trim();
        if (part.length !== 0) {
          var pair = part.split("=");
          if (pair.length !== 2 || !Tracestate.validateKeyChars(pair[0]) || keydeduper[pair[0]]) return null;
          keydeduper[pair[0]] = !0, res.push(part);
        }
      }
      return res;
    }, Tracestate.strict = !0, Tracestate;
  }();
  module.exports = Tracestate;
});
var require_Domain = __commonJSMin((exports, module) => {
  "use strict";

  var Domain = function () {
    function Domain() {}
    return __name(Domain, "Domain"), Domain;
  }();
  module.exports = Domain;
});
var ZG = T((wA, QG) => {
  "use strict";

  var M_e = wA && wA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    AvailabilityData = function (_super) {
      __extends(AvailabilityData, _super);
      function AvailabilityData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(AvailabilityData, "AvailabilityData"), AvailabilityData;
    }(Domain);
  module.exports = AvailabilityData;
});
var require_Base = __commonJSMin((exports, module) => {
  "use strict";

  var Base = function () {
    function Base() {}
    return __name(Base, "Base"), Base;
  }();
  module.exports = Base;
});
var require_ContextTagKeys = __commonJSMin((exports, module) => {
  "use strict";

  var ContextTagKeys = function () {
    function ContextTagKeys() {
      this.applicationVersion = "ai.application.ver", this.deviceId = "ai.device.id", this.deviceLocale = "ai.device.locale", this.deviceModel = "ai.device.model", this.deviceOEMName = "ai.device.oemName", this.deviceOSVersion = "ai.device.osVersion", this.deviceType = "ai.device.type", this.locationIp = "ai.location.ip", this.operationId = "ai.operation.id", this.operationName = "ai.operation.name", this.operationParentId = "ai.operation.parentId", this.operationSyntheticSource = "ai.operation.syntheticSource", this.operationCorrelationVector = "ai.operation.correlationVector", this.sessionId = "ai.session.id", this.sessionIsFirst = "ai.session.isFirst", this.userAccountId = "ai.user.accountId", this.userId = "ai.user.id", this.userAuthUserId = "ai.user.authUserId", this.cloudRole = "ai.cloud.role", this.cloudRoleInstance = "ai.cloud.roleInstance", this.internalSdkVersion = "ai.internal.sdkVersion", this.internalAgentVersion = "ai.internal.agentVersion", this.internalNodeName = "ai.internal.nodeName";
    }
    return __name(ContextTagKeys, "ContextTagKeys"), ContextTagKeys;
  }();
  module.exports = ContextTagKeys;
});
var nz = T((AA, rz) => {
  "use strict";

  var j_e = AA && AA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Base = IA(),
    Data = function (_super) {
      __extends(Data, _super);
      function Data() {
        return _super.call(this) || this;
      }
      return __name(Data, "Data"), Data;
    }(Base);
  module.exports = Data;
});
var require_DataPointType = __commonJSMin((exports, module) => {
  "use strict";

  var DataPointType;
  (function (DataPointType) {
    DataPointType[DataPointType.Measurement = 0] = "Measurement", DataPointType[DataPointType.Aggregation = 1] = "Aggregation";
  })(DataPointType || (DataPointType = {}));
  module.exports = DataPointType;
});
var oz = T((BXe, sz) => {
  "use strict";

  var DataPointType = RA(),
    DataPoint = function () {
      function DataPoint() {
        this.kind = DataPointType.Measurement;
      }
      return __name(DataPoint, "DataPoint"), DataPoint;
    }();
  module.exports = DataPoint;
});
var require_Envelope = __commonJSMin((exports, module) => {
  "use strict";

  var Envelope = function () {
    function Envelope() {
      this.ver = 1, this.sampleRate = 100, this.tags = {};
    }
    return __name(Envelope, "Envelope"), Envelope;
  }();
  module.exports = Envelope;
});
var OA = T((NA, cz) => {
  "use strict";

  var W_e = NA && NA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    EventData = function (_super) {
      __extends(EventData, _super);
      function EventData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(EventData, "EventData"), EventData;
    }(Domain);
  module.exports = EventData;
});
var fz = T((LA, uz) => {
  "use strict";

  var Y_e = LA && LA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    ExceptionData = function (_super) {
      __extends(ExceptionData, _super);
      function ExceptionData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.exceptions = [], _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(ExceptionData, "ExceptionData"), ExceptionData;
    }(Domain);
  module.exports = ExceptionData;
});
var require_ExceptionDetails = __commonJSMin((exports, module) => {
  "use strict";

  var ExceptionDetails = function () {
    function ExceptionDetails() {
      this.hasFullStack = !0, this.parsedStack = [];
    }
    return __name(ExceptionDetails, "ExceptionDetails"), ExceptionDetails;
  }();
  module.exports = ExceptionDetails;
});
var hz = T((kA, mz) => {
  "use strict";

  var eye = kA && kA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    MessageData = function (_super) {
      __extends(MessageData, _super);
      function MessageData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.properties = {}, r;
      }
      return __name(MessageData, "MessageData"), MessageData;
    }(Domain);
  module.exports = MessageData;
});
var _z = T((DA, gz) => {
  "use strict";

  var nye = DA && DA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    MetricData = function (_super) {
      __extends(MetricData, _super);
      function MetricData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.metrics = [], _this.properties = {}, r;
      }
      return __name(MetricData, "MetricData"), MetricData;
    }(Domain);
  module.exports = MetricData;
});
var vz = T((MA, yz) => {
  "use strict";

  var oye = MA && MA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    EventData = OA(),
    PageViewData = function (_super) {
      __extends(PageViewData, _super);
      function PageViewData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(PageViewData, "PageViewData"), PageViewData;
    }(EventData);
  module.exports = PageViewData;
});
var bz = T((BA, xz) => {
  "use strict";

  var cye = BA && BA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    RemoteDependencyData = function (_super) {
      __extends(RemoteDependencyData, _super);
      function RemoteDependencyData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.success = !0, _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(RemoteDependencyData, "RemoteDependencyData"), RemoteDependencyData;
    }(Domain);
  module.exports = RemoteDependencyData;
});
var Cz = T((FA, Ez) => {
  "use strict";

  var dye = FA && FA.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    Domain = Pd(),
    RequestData = function (_super) {
      __extends(RequestData, _super);
      function RequestData() {
        var _this = _super.call(this) || this;
        return _this.ver = 2, _this.properties = {}, _this.measurements = {}, r;
      }
      return __name(RequestData, "RequestData"), RequestData;
    }(Domain);
  module.exports = RequestData;
});
var require_SeverityLevel = __commonJSMin((exports, module) => {
  "use strict";

  var SeverityLevel;
  (function (SeverityLevel) {
    SeverityLevel[SeverityLevel.Verbose = 0] = "Verbose", SeverityLevel[SeverityLevel.Information = 1] = "Information", SeverityLevel[SeverityLevel.Warning = 2] = "Warning", SeverityLevel[SeverityLevel.Error = 3] = "Error", SeverityLevel[SeverityLevel.Critical = 4] = "Critical";
  })(SeverityLevel || (SeverityLevel = {}));
  module.exports = SeverityLevel;
});
var require_StackFrame = __commonJSMin((exports, module) => {
  "use strict";

  var StackFrame = function () {
    function StackFrame() {}
    return __name(StackFrame, "StackFrame"), StackFrame;
  }();
  module.exports = StackFrame;
});
var require_Generated = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(G0, "__esModule", {
    value: !0
  });
  exports.AvailabilityData = ZG();
  exports.Base = IA();
  exports.ContextTagKeys = tz();
  exports.Data = nz();
  exports.DataPoint = oz();
  exports.DataPointType = RA();
  exports.Domain = Pd();
  exports.Envelope = lz();
  exports.EventData = OA();
  exports.ExceptionData = fz();
  exports.ExceptionDetails = pz();
  exports.MessageData = hz();
  exports.MetricData = _z();
  exports.PageViewData = vz();
  exports.RemoteDependencyData = bz();
  exports.RequestData = Cz();
  exports.SeverityLevel = Sz();
  exports.StackFrame = Iz();
});
var Az = T(Ag => {
  "use strict";

  Object.defineProperty(Ag, "__esModule", {
    value: !0
  });
  Ag.domainSupportsProperties = Ag.RemoteDependencyDataConstants = void 0;
  var Generated_1 = qA(),
    RemoteDependencyDataConstants = function () {
      function RemoteDependencyDataConstants() {}
      return __name(RemoteDependencyDataConstants, "RemoteDependencyDataConstants"), RemoteDependencyDataConstants.TYPE_HTTP = "Http", RemoteDependencyDataConstants.TYPE_AI = "Http (tracked component)", RemoteDependencyDataConstants;
    }();
  exports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;
  function domainSupportsProperties(domain) {
    return "properties" in domain || domain instanceof Generated_1.EventData || domain instanceof Generated_1.ExceptionData || domain instanceof Generated_1.MessageData || domain instanceof Generated_1.MetricData || domain instanceof Generated_1.PageViewData || domain instanceof Generated_1.RemoteDependencyData || domain instanceof Generated_1.RequestData;
  }
  __name(domainSupportsProperties, "domainSupportsProperties");
  exports.domainSupportsProperties = domainSupportsProperties;
});
var require_DependencyTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_EventTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_ExceptionTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_MetricTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_RequestTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_TraceTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_Telemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_NodeHttpDependencyTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_NodeHttpRequestTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_AvailabilityTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_PageViewTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_EnvelopeTelemetry = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var Jz = T(ef => {
  "use strict";

  Object.defineProperty(ef, "__esModule", {
    value: !0
  });
  ef.TelemetryType = ef.TelemetryTypeString = ef.baseTypeToTelemetryType = ef.telemetryTypeToBaseType = void 0;
  function telemetryTypeToBaseType(type) {
    switch (type) {
      case TelemetryType.Event:
        return "EventData";
      case TelemetryType.Exception:
        return "ExceptionData";
      case TelemetryType.Trace:
        return "MessageData";
      case TelemetryType.Metric:
        return "MetricData";
      case TelemetryType.Request:
        return "RequestData";
      case TelemetryType.Dependency:
        return "RemoteDependencyData";
      case TelemetryType.Availability:
        return "AvailabilityData";
      case TelemetryType.PageView:
        return "PageViewData";
    }
  }
  __name(telemetryTypeToBaseType, "telemetryTypeToBaseType");
  exports.telemetryTypeToBaseType = telemetryTypeToBaseType;
  function baseTypeToTelemetryType(baseType) {
    switch (baseType) {
      case "EventData":
        return TelemetryType.Event;
      case "ExceptionData":
        return TelemetryType.Exception;
      case "MessageData":
        return TelemetryType.Trace;
      case "MetricData":
        return TelemetryType.Metric;
      case "RequestData":
        return TelemetryType.Request;
      case "RemoteDependencyData":
        return TelemetryType.Dependency;
      case "AvailabilityData":
        return TelemetryType.Availability;
      case "PageViewData":
        return TelemetryType.PageView;
    }
  }
  __name(baseTypeToTelemetryType, "baseTypeToTelemetryType");
  exports.baseTypeToTelemetryType = baseTypeToTelemetryType;
  exports.TelemetryTypeString = {
    Event: "EventData",
    Exception: "ExceptionData",
    Trace: "MessageData",
    Metric: "MetricData",
    Request: "RequestData",
    Dependency: "RemoteDependencyData",
    Availability: "AvailabilityData",
    PageView: "PageViewData"
  };
  var TelemetryType;
  (function (TelemetryType) {
    TelemetryType[TelemetryType.Event = 0] = "Event", TelemetryType[TelemetryType.Exception = 1] = "Exception", TelemetryType[TelemetryType.Trace = 2] = "Trace", TelemetryType[TelemetryType.Metric = 3] = "Metric", TelemetryType[TelemetryType.Request = 4] = "Request", TelemetryType[TelemetryType.Dependency = 5] = "Dependency", TelemetryType[TelemetryType.Availability = 6] = "Availability", TelemetryType[TelemetryType.PageView = 7] = "PageView";
  })(TelemetryType = exports.TelemetryType || (exports.TelemetryType = {}));
});
var eW = T(J0 => {
  "use strict";

  var xye = J0 && J0.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Hc = J0 && J0.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && xye(t, e, r);
    };
  Object.defineProperty(J0, "__esModule", {
    value: !0
  });
  __exportStar(Rz(), exports);
  __exportStar(Oz(), exports);
  __exportStar(kz(), exports);
  __exportStar(Mz(), exports);
  __exportStar(Fz(), exports);
  __exportStar(qz(), exports);
  __exportStar(Hz(), exports);
  __exportStar(Vz(), exports);
  __exportStar(zz(), exports);
  __exportStar(Kz(), exports);
  __exportStar(Yz(), exports);
  __exportStar(Zz(), exports);
  __exportStar(Jz(), exports);
});
var require_MetricQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_EnvelopeQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_DocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_ExceptionDocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_MessageDocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_DependencyDocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_RequestDocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var require_EventDocumentQuickPulse = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var _W = T(vc => {
  "use strict";

  var bye = vc && vc.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    Np = vc && vc.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && bye(t, e, r);
    };
  Object.defineProperty(vc, "__esModule", {
    value: !0
  });
  __exportStar(rW(), exports);
  __exportStar(iW(), exports);
  __exportStar(oW(), exports);
  __exportStar(lW(), exports);
  __exportStar(uW(), exports);
  __exportStar(dW(), exports);
  __exportStar(mW(), exports);
  __exportStar(gW(), exports);
});
var Gl = T(wf => {
  "use strict";

  var Eye = wf && wf.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    D9 = wf && wf.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && Eye(t, e, r);
    };
  Object.defineProperty(wf, "__esModule", {
    value: !0
  });
  __exportStar(Az(), exports);
  __exportStar(qA(), exports);
  __exportStar(eW(), exports);
  __exportStar(_W(), exports);
});
var jA = T((IYe, yW) => {
  "use strict";

  var RequestParser = function () {
    function RequestParser() {}
    return __name(RequestParser, "RequestParser"), RequestParser.prototype.getUrl = function () {
      return this.url;
    }, RequestParser.prototype.RequestParser = function () {
      this.startTime = +new Date();
    }, RequestParser.prototype._setStatus = function (status, error) {
      var endTime = +new Date();
      this.duration = endTime - this.startTime, this.statusCode = status;
      var properties = this.properties || {};
      if (error) {
        if (typeof error == "string") properties.error = error;else if (error instanceof Error) properties.error = error.message;else if (typeof error == "object") for (var key in error) properties[key] = error[key] && error[key].toString && error[key].toString();
      }
      this.properties = properties;
    }, RequestParser.prototype._isSuccess = function () {
      return 0 < this.statusCode && this.statusCode < 400;
    }, RequestParser;
  }();
  module.exports = RequestParser;
});
var VA = T(($A, xW) => {
  "use strict";

  var Tye = $A && $A.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    url = require("url"),
    Contracts = Gl(),
    Util = il(),
    RequestResponseHeaders = wg(),
    RequestParser = jA(),
    CorrelationIdManager = wm(),
    Tracestate = SA(),
    Traceparent = k9(),
    HttpRequestParser = function (_super) {
      __extends(HttpRequestParser, _super);
      function HttpRequestParser(request, requestId) {
        var _this = _super.call(this) || this;
        return request && (_this.method = request.method, _this.url = _this._getAbsoluteUrl(request), _this.startTime = +new Date(), _this.socketRemoteAddress = request.socket && request.socket.remoteAddress, _this.parseHeaders(request, requestId), request.connection && (_this.connectionRemoteAddress = request.connection.remoteAddress, _this.legacySocketRemoteAddress = request.connection.socket && request.connection.socket.remoteAddress)), i;
      }
      return __name(HttpRequestParser, "HttpRequestParser"), HttpRequestParser.prototype.onError = function (error, ellapsedMilliseconds) {
        this._setStatus(void 0, error), ellapsedMilliseconds && (this.duration = ellapsedMilliseconds);
      }, HttpRequestParser.prototype.onResponse = function (response, ellapsedMilliseconds) {
        this._setStatus(response.statusCode, void 0), ellapsedMilliseconds && (this.duration = ellapsedMilliseconds);
      }, HttpRequestParser.prototype.getRequestTelemetry = function (baseTelemetry) {
        var name = this.method;
        try {
          name += " " + new url.URL(this.url).pathname;
        } catch {}
        var requestTelemetry = {
          id: this.requestId,
          name: name,
          url: this.url,
          source: this.sourceCorrelationId,
          duration: this.duration,
          resultCode: this.statusCode ? this.statusCode.toString() : null,
          success: this._isSuccess(),
          properties: this.properties
        };
        if (baseTelemetry && baseTelemetry.time ? requestTelemetry.time = baseTelemetry.time : this.startTime && (requestTelemetry.time = new Date(this.startTime)), baseTelemetry) {
          for (var key in baseTelemetry) requestTelemetry[key] || (requestTelemetry[key] = baseTelemetry[key]);
          if (baseTelemetry.properties) for (var key in baseTelemetry.properties) requestTelemetry.properties[key] = baseTelemetry.properties[key];
        }
        return requestTelemetry;
      }, HttpRequestParser.prototype.getRequestTags = function (tags) {
        var newTags = {};
        for (var key in tags) newTags[key] = tags[key];
        return newTags[HttpRequestParser.keys.locationIp] = tags[HttpRequestParser.keys.locationIp] || this._getIp(), newTags[HttpRequestParser.keys.sessionId] = tags[HttpRequestParser.keys.sessionId] || this._getId("ai_session"), newTags[HttpRequestParser.keys.userId] = tags[HttpRequestParser.keys.userId] || this._getId("ai_user"), newTags[HttpRequestParser.keys.userAuthUserId] = tags[HttpRequestParser.keys.userAuthUserId] || this._getId("ai_authUser"), newTags[HttpRequestParser.keys.operationName] = this.getOperationName(tags), newTags[HttpRequestParser.keys.operationParentId] = this.getOperationParentId(tags), newTags[HttpRequestParser.keys.operationId] = this.getOperationId(tags), newTags;
      }, HttpRequestParser.prototype.getOperationId = function (tags) {
        return tags[HttpRequestParser.keys.operationId] || this.operationId;
      }, HttpRequestParser.prototype.getOperationParentId = function (tags) {
        return tags[HttpRequestParser.keys.operationParentId] || this.parentId || this.getOperationId(tags);
      }, HttpRequestParser.prototype.getOperationName = function (tags) {
        if (tags[HttpRequestParser.keys.operationName]) return tags[HttpRequestParser.keys.operationName];
        var pathName = "";
        try {
          pathName = new url.URL(this.url).pathname;
        } catch {}
        var operationName = this.method;
        return pathName && (operationName += " " + pathName), operationName;
      }, HttpRequestParser.prototype.getRequestId = function () {
        return this.requestId;
      }, HttpRequestParser.prototype.getCorrelationContextHeader = function () {
        return this.correlationContextHeader;
      }, HttpRequestParser.prototype.getTraceparent = function () {
        return this.traceparent;
      }, HttpRequestParser.prototype.getTracestate = function () {
        return this.tracestate;
      }, HttpRequestParser.prototype.getLegacyRootId = function () {
        return this.legacyRootId;
      }, HttpRequestParser.prototype._getAbsoluteUrl = function (request) {
        if (!request.headers) return request.url;
        var encrypted = request.connection ? request.connection.encrypted : null,
          protocol = encrypted || request.headers["x-forwarded-proto"] == "https" ? "https" : "http",
          baseUrl = protocol + "://" + request.headers.host + "/",
          pathName = "",
          search = "";
        try {
          var requestUrl = new url.URL(request.url, baseUrl);
          pathName = requestUrl.pathname, search = requestUrl.search;
        } catch {}
        var absoluteUrl = url.format({
          protocol: protocol,
          host: request.headers.host,
          pathname: pathName,
          search: search
        });
        return absoluteUrl;
      }, HttpRequestParser.prototype._getIp = function () {
        var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/,
          check = __name(function (str) {
            var results = ipMatch.exec(str);
            if (results) return results[0];
          }, "check"),
          ip = check(this.rawHeaders["x-forwarded-for"]) || check(this.rawHeaders["x-client-ip"]) || check(this.rawHeaders["x-real-ip"]) || check(this.connectionRemoteAddress) || check(this.socketRemoteAddress) || check(this.legacySocketRemoteAddress);
        return !ip && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && this.connectionRemoteAddress.substr(0, 2) === "::" && (ip = "127.0.0.1"), ip;
      }, HttpRequestParser.prototype._getId = function (name) {
        var cookie = this.rawHeaders && this.rawHeaders.cookie && typeof this.rawHeaders.cookie == "string" && this.rawHeaders.cookie || "",
          value = HttpRequestParser.parseId(Util.getCookie(name, cookie));
        return value;
      }, HttpRequestParser.prototype.setBackCompatFromThisTraceContext = function () {
        this.operationId = this.traceparent.traceId, this.traceparent.legacyRootId && (this.legacyRootId = this.traceparent.legacyRootId), this.parentId = this.traceparent.parentId, this.traceparent.updateSpanId(), this.requestId = this.traceparent.getBackCompatRequestId();
      }, HttpRequestParser.prototype.parseHeaders = function (request, requestId) {
        if (this.rawHeaders = request.headers || request.rawHeaders, this.userAgent = request.headers && request.headers["user-agent"], this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey), request.headers) {
          var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader] ? request.headers[RequestResponseHeaders.traceStateHeader].toString() : null,
            traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader] ? request.headers[RequestResponseHeaders.traceparentHeader].toString() : null,
            requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader] ? request.headers[RequestResponseHeaders.requestIdHeader].toString() : null,
            legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader] ? request.headers[RequestResponseHeaders.parentIdHeader].toString() : null,
            legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader] ? request.headers[RequestResponseHeaders.rootIdHeader].toString() : null;
          this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader] ? request.headers[RequestResponseHeaders.correlationContextHeader].toString() : null, CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader) ? (this.traceparent = new Traceparent(traceparentHeader ? traceparentHeader.toString() : null), this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader ? tracestateHeader.toString() : null), this.setBackCompatFromThisTraceContext()) : requestIdHeader ? CorrelationIdManager.w3cEnabled ? (this.traceparent = new Traceparent(null, requestIdHeader), this.setBackCompatFromThisTraceContext()) : (this.parentId = requestIdHeader, this.requestId = CorrelationIdManager.generateRequestId(this.parentId), this.operationId = CorrelationIdManager.getRootId(this.requestId)) : CorrelationIdManager.w3cEnabled ? (this.traceparent = new Traceparent(), this.traceparent.parentId = legacy_parentId, this.traceparent.legacyRootId = legacy_rootId || legacy_parentId, this.setBackCompatFromThisTraceContext()) : (this.parentId = legacy_parentId, this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId), this.correlationContextHeader = null, this.operationId = CorrelationIdManager.getRootId(this.requestId)), requestId && (this.requestId = requestId, this.operationId = CorrelationIdManager.getRootId(this.requestId));
        }
      }, HttpRequestParser.parseId = function (cookieValue) {
        var cookieParts = cookieValue.split("|");
        return cookieParts.length > 0 ? cookieParts[0] : "";
      }, HttpRequestParser.keys = new Contracts.ContextTagKeys(), HttpRequestParser;
    }(RequestParser);
  module.exports = HttpRequestParser;
});
var require_semver = __commonJSMin((exports, module) => {
  exports = module.exports = SemVer;
  var debug;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? debug = __name(function () {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
  }, "debug") : debug = __name(function () {}, "debug");
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256,
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH = 16,
    MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6,
    re = exports.re = [],
    safeRe = exports.safeRe = [],
    src = exports.src = [],
    R = 0,
    LETTERDASHNUMBER = "[a-zA-Z0-9-]",
    safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];
  function makeSafeRe(value) {
    for (var i = 0; i < safeRegexReplacements.length; i++) {
      var token = safeRegexReplacements[i][0],
        max = safeRegexReplacements[i][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  __name(makeSafeRe, "makeSafeRe");
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "\\d+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++,
    FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?",
    LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
  var tildeTrimReplace = "$1~",
    TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
  var caretTrimReplace = "$1^",
    CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3",
    HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0; i < R; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]), safeRe[i] = new RegExp(makeSafeRe(src[i])));
  var i;
  exports.parse = parse;
  function parse(version, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) return version;
    if (typeof version != "string" || version.length > MAX_LENGTH) return null;
    var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
    if (!r.test(version)) return null;
    try {
      return new SemVer(version, options);
    } catch {
      return null;
    }
  }
  __name(parse, "parse");
  exports.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  __name(valid, "valid");
  exports.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  __name(clean, "clean");
  exports.SemVer = SemVer;
  function SemVer(version, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) {
      if (version.loose === options.loose) return version;
      version = version.version;
    } else if (typeof version != "string") throw new TypeError("Invalid Version: " + version);
    if (version.length > MAX_LENGTH) throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    if (!(this instanceof SemVer)) return new SemVer(version, options);
    debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
    if (!m) throw new TypeError("Invalid Version: " + version);
    if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
    }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
  }
  __name(SemVer, "SemVer");
  SemVer.prototype.format = function () {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  };
  SemVer.prototype.toString = function () {
    return this.version;
  };
  SemVer.prototype.compare = function (other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function (other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function (other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
    if (!this.prerelease.length && other.prerelease.length) return 1;
    if (!this.prerelease.length && !other.prerelease.length) return 0;
    var i = 0;
    do {
      var a = this.prerelease[i],
        b = other.prerelease[i];
      if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0) return 0;
      if (b === void 0) return 1;
      if (a === void 0) return -1;
      if (a === b) continue;
      return compareIdentifiers(a, b);
    } while (++i);
  };
  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) this.prerelease = [0];else {
          for (var i = this.prerelease.length; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          i === -1 && this.prerelease.push(0);
        }
        identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    return this.format(), this.raw = this.version, this;
  };
  exports.inc = inc;
  function inc(version, release, loose, identifier) {
    typeof loose == "string" && (identifier = loose, loose = void 0);
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch {
      return null;
    }
  }
  __name(inc, "inc");
  exports.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) return null;
    var v1 = parse(version1),
      v2 = parse(version2),
      prefix = "";
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = "pre";
      var defaultResult = "prerelease";
    }
    for (var key in v1) if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key]) return prefix + key;
    return defaultResult;
  }
  __name(diff, "diff");
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a),
      bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  __name(compareIdentifiers, "compareIdentifiers");
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  __name(rcompareIdentifiers, "rcompareIdentifiers");
  exports.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  __name(major, "major");
  exports.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  __name(minor, "minor");
  exports.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  __name(patch, "patch");
  exports.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  __name(compare, "compare");
  exports.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, !0);
  }
  __name(compareLoose, "compareLoose");
  exports.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  __name(rcompare, "rcompare");
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose);
    });
  }
  __name(sort, "sort");
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose);
    });
  }
  __name(rsort, "rsort");
  exports.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  __name(gt, "gt");
  exports.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  __name(lt, "lt");
  exports.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  __name(eq, "eq");
  exports.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  __name(neq, "neq");
  exports.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  __name(gte, "gte");
  exports.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  __name(lte, "lte");
  exports.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  __name(cmp, "cmp");
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), comp instanceof Comparator) {
      if (comp.loose === !!options.loose) return comp;
      comp = comp.value;
    }
    if (!(this instanceof Comparator)) return new Comparator(comp, options);
    comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
  }
  __name(Comparator, "Comparator");
  var ANY = {};
  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR],
      m = comp.match(r);
    if (!m) throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1], this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
  };
  Comparator.prototype.toString = function () {
    return this.value;
  };
  Comparator.prototype.test = function (version) {
    return debug("Comparator.test", version, this.options.loose), this.semver === ANY ? !0 : (typeof version == "string" && (version = new SemVer(version, this.options)), cmp(version, this.operator, this.semver, this.options));
  };
  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
    (!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    });
    var rangeTmp;
    if (this.operator === "") return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
    if (comp.operator === "") return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">"),
      sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<"),
      sameSemVer = this.semver.version === comp.semver.version,
      differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<="),
      oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"),
      oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator) return new Range(range.value, options);
    if (!(this instanceof Range)) return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  __name(Range, "Range");
  Range.prototype.format = function () {
    return this.range = this.set.map(function (comps) {
      return comps.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  Range.prototype.toString = function () {
    return this.range;
  };
  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose,
      hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, safeRe[COMPARATORTRIM]), range = range.replace(safeRe[TILDETRIM], tildeTrimReplace), range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
    var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR],
      set = range.split(" ").map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter(function (comp) {
      return !!comp.match(compRe);
    })), set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this), set;
  };
  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) throw new TypeError("a Range is required");
    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  __name(toComparators, "toComparators");
  function parseComparator(comp, options) {
    return debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp;
  }
  __name(parseComparator, "parseComparator");
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  __name(isX, "isX");
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(" ");
  }
  __name(replaceTildes, "replaceTildes");
  function replaceTilde(comp, options) {
    var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
    });
  }
  __name(replaceTilde, "replaceTilde");
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(" ");
  }
  __name(replaceCarets, "replaceCarets");
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? M === "0" ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
    });
  }
  __name(replaceCaret, "replaceCaret");
  function replaceXRanges(comp, options) {
    return debug("replaceXRanges", comp, options), comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(" ");
  }
  __name(replaceXRanges, "replaceXRanges");
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M),
        xm = xM || isX(m),
        xp = xm || isX(p),
        anyX = xp;
      return gtlt === "=" && anyX && (gtlt = ""), xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), debug("xRange return", ret), ret;
    });
  }
  __name(replaceXRange, "replaceXRange");
  function replaceStars(comp, options) {
    return debug("replaceStars", comp, options), comp.trim().replace(safeRe[STAR], "");
  }
  __name(replaceStars, "replaceStars");
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return isX(fM) ? from = "" : isX(fm) ? from = ">=" + fM + ".0.0" : isX(fp) ? from = ">=" + fM + "." + fm + ".0" : from = ">=" + from, isX(tM) ? to = "" : isX(tm) ? to = "<" + (+tM + 1) + ".0.0" : isX(tp) ? to = "<" + tM + "." + (+tm + 1) + ".0" : tpr ? to = "<=" + tM + "." + tm + "." + tp + "-" + tpr : to = "<=" + to, (from + " " + to).trim();
  }
  __name(hyphenReplace, "hyphenReplace");
  Range.prototype.test = function (version) {
    if (!version) return !1;
    typeof version == "string" && (version = new SemVer(version, this.options));
    for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
    return !1;
  };
  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
      }
      return !1;
    }
    return !0;
  }
  __name(testSet, "testSet");
  exports.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch {
      return !1;
    }
    return range.test(version);
  }
  __name(satisfies, "satisfies");
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null,
      maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch {
      return null;
    }
    return versions.forEach(function (v) {
      rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
    }), max;
  }
  __name(maxSatisfying, "maxSatisfying");
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null,
      minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch {
      return null;
    }
    return versions.forEach(function (v) {
      rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
    }), min;
  }
  __name(minSatisfying, "minSatisfying");
  exports.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver))) return minver;
    minver = null;
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
          case "":
          case ">=":
            (!minver || gt(minver, compver)) && (minver = compver);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    return minver && range.test(minver) ? minver : null;
  }
  __name(minVersion, "minVersion");
  exports.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch {
      return null;
    }
  }
  __name(validRange, "validRange");
  exports.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  __name(ltr, "ltr");
  exports.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  __name(gtr, "gtr");
  exports.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options), range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
        break;
      case "<":
        gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i],
        high = null,
        low = null;
      if (comparators.forEach(function (comparator) {
        comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
      }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
      if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
  }
  __name(outside, "outside");
  exports.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  __name(prerelease, "prerelease");
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
  }
  __name(intersects, "intersects");
  exports.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) return version;
    if (typeof version != "string") return null;
    var match = version.match(safeRe[COERCE]);
    return match == null ? null : parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
  __name(coerce, "coerce");
});
var require_shimmer = __commonJSMin((exports, module) => {
  "use strict";

  function isFunction(funktion) {
    return typeof funktion == "function";
  }
  __name(isFunction, "isFunction");
  var logger = console.error.bind(console);
  function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
      configurable: !0,
      enumerable: enumerable,
      writable: !0,
      value: value
    });
  }
  __name(defineProperty, "defineProperty");
  function shimmer(options) {
    options && options.logger && (isFunction(options.logger) ? logger = options.logger : logger("new logger isn't a function, not replacing"));
  }
  __name(shimmer, "shimmer");
  function wrap(nodule, name, wrapper) {
    if (!nodule || !nodule[name]) {
      logger("no original function " + name + " to wrap");
      return;
    }
    if (!wrapper) {
      logger("no wrapper function"), logger(new Error().stack);
      return;
    }
    if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
      logger("original object and wrapper must be functions");
      return;
    }
    var original = nodule[name],
      wrapped = wrapper(original, name);
    return defineProperty(wrapped, "__original", original), defineProperty(wrapped, "__unwrap", function () {
      nodule[name] === wrapped && defineProperty(nodule, name, original);
    }), defineProperty(wrapped, "__wrapped", !0), defineProperty(nodule, name, wrapped), wrapped;
  }
  __name(wrap, "wrap");
  function massWrap(nodules, names, wrapper) {
    if (nodules) Array.isArray(nodules) || (nodules = [nodules]);else {
      logger("must provide one or more modules to patch"), logger(new Error().stack);
      return;
    }
    if (!(names && Array.isArray(names))) {
      logger("must provide one or more functions to wrap on modules");
      return;
    }
    nodules.forEach(function (nodule) {
      names.forEach(function (name) {
        wrap(nodule, name, wrapper);
      });
    });
  }
  __name(massWrap, "massWrap");
  function unwrap(nodule, name) {
    if (!nodule || !nodule[name]) {
      logger("no function to unwrap."), logger(new Error().stack);
      return;
    }
    if (!nodule[name].__unwrap) logger("no original to unwrap to -- has " + name + " already been unwrapped?");else return nodule[name].__unwrap();
  }
  __name(unwrap, "unwrap");
  function massUnwrap(nodules, names) {
    if (nodules) Array.isArray(nodules) || (nodules = [nodules]);else {
      logger("must provide one or more modules to patch"), logger(new Error().stack);
      return;
    }
    if (!(names && Array.isArray(names))) {
      logger("must provide one or more functions to unwrap on modules");
      return;
    }
    nodules.forEach(function (nodule) {
      names.forEach(function (name) {
        unwrap(nodule, name);
      });
    });
  }
  __name(massUnwrap, "massUnwrap");
  shimmer.wrap = wrap;
  shimmer.massWrap = massWrap;
  shimmer.unwrap = unwrap;
  shimmer.massUnwrap = massUnwrap;
  module.exports = shimmer;
});
var require_listener = __commonJSMin((exports, module) => {
  "use strict";

  var shimmer = z9(),
    wrap = shimmer.wrap,
    unwrap = shimmer.unwrap,
    SYMBOL = "wrap@before";
  function defineProperty(obj, name, value) {
    var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
    Object.defineProperty(obj, name, {
      configurable: !0,
      enumerable: enumerable,
      writable: !0,
      value: value
    });
  }
  __name(defineProperty, "defineProperty");
  function _process(self, listeners) {
    for (var l = listeners.length, p = 0; p < l; p++) {
      var listener = listeners[p],
        before = self[SYMBOL];
      if (typeof before == "function") before(listener);else if (Array.isArray(before)) for (var length = before.length, i = 0; i < length; i++) before[i](listener);
    }
  }
  __name(_process, "_process");
  function _listeners(self, event) {
    var listeners;
    return listeners = self._events && self._events[event], Array.isArray(listeners) || (listeners ? listeners = [listeners] : listeners = []), listeners;
  }
  __name(_listeners, "_listeners");
  function _findAndProcess(self, event, before) {
    var after = _listeners(self, event),
      unprocessed = after.filter(function (fn) {
        return before.indexOf(fn) === -1;
      });
    unprocessed.length > 0 && _process(self, unprocessed);
  }
  __name(_findAndProcess, "_findAndProcess");
  function _wrap(unwrapped, visit) {
    if (unwrapped) {
      var wrapped = unwrapped;
      if (typeof unwrapped == "function") wrapped = visit(unwrapped);else if (Array.isArray(unwrapped)) {
        wrapped = [];
        for (var i = 0; i < unwrapped.length; i++) wrapped[i] = visit(unwrapped[i]);
      }
      return wrapped;
    }
  }
  __name(_wrap, "_wrap");
  module.exports = __name(function (emitter, onAddListener, onEmit) {
    if (!emitter || !emitter.on || !emitter.addListener || !emitter.removeListener || !emitter.emit) throw new Error("can only wrap real EEs");
    if (!onAddListener) throw new Error("must have function to run on listener addition");
    if (!onEmit) throw new Error("must have function to wrap listeners when emitting");
    function adding(on) {
      return __name(function (event, listener) {
        var existing = _listeners(this, event).slice();
        try {
          var returned = on.call(this, event, listener);
          return _findAndProcess(this, event, existing), returned;
        } finally {
          this.on.__wrapped || wrap(this, "on", adding), this.addListener.__wrapped || wrap(this, "addListener", adding);
        }
      }, "added");
    }
    __name(adding, "adding");
    function emitting(emit) {
      return __name(function (event) {
        if (!this._events || !this._events[event]) return emit.apply(this, arguments);
        var unwrapped = this._events[event];
        function remover(removeListener) {
          return __name(function () {
            this._events[event] = unwrapped;
            try {
              return removeListener.apply(this, arguments);
            } finally {
              unwrapped = this._events[event], this._events[event] = _wrap(unwrapped, onEmit);
            }
          }, "removed");
        }
        __name(remover, "remover"), wrap(this, "removeListener", remover);
        try {
          return this._events[event] = _wrap(unwrapped, onEmit), emit.apply(this, arguments);
        } finally {
          unwrap(this, "removeListener"), this._events[event] = unwrapped;
        }
      }, "emitted");
    }
    __name(emitting, "emitting"), emitter[SYMBOL] ? typeof emitter[SYMBOL] == "function" ? defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]) : Array.isArray(emitter[SYMBOL]) && emitter[SYMBOL].push(onAddListener) : defineProperty(emitter, SYMBOL, onAddListener), emitter.__wrapped || (wrap(emitter, "addListener", adding), wrap(emitter, "on", adding), wrap(emitter, "emit", emitting), defineProperty(emitter, "__unwrap", function () {
      unwrap(emitter, "addListener"), unwrap(emitter, "on"), unwrap(emitter, "emit"), delete emitter[SYMBOL], delete emitter.__wrapped;
    }), defineProperty(emitter, "__wrapped", !0));
  }, "wrapEmitter");
});
var require_context = __commonJSMin((exports, module) => {
  "use strict";

  var util = require("util"),
    assert = require("assert"),
    wrapEmitter = X9(),
    async_hooks = require("async_hooks"),
    CONTEXTS_SYMBOL = "cls@contexts",
    ERROR_SYMBOL = "error@context",
    DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED,
    currentUid = -1;
  module.exports = {
    getNamespace: getNamespace,
    createNamespace: createNamespace,
    destroyNamespace: destroyNamespace,
    reset: reset,
    ERROR_SYMBOL: ERROR_SYMBOL
  };
  function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null, this._contexts = new Map(), this._indent = 0;
  }
  __name(Namespace, "Namespace");
  Namespace.prototype.set = __name(function (key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    if (this.active[key] = value, DEBUG_CLS_HOOKED) {
      let indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(indentStr + "CONTEXT-SET KEY:" + key + "=" + value + " in ns:" + this.name + " currentUid:" + currentUid + " active:" + util.inspect(this.active, {
        showHidden: !0,
        depth: 2,
        colors: !0
      }));
    }
    return value;
  }, "set");
  Namespace.prototype.get = __name(function (key) {
    if (!this.active) {
      if (DEBUG_CLS_HOOKED) {
        let asyncHooksCurrentId = async_hooks.currentId(),
          triggerId = async_hooks.triggerAsyncId(),
          indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
      }
      return;
    }
    if (DEBUG_CLS_HOOKED) {
      let asyncHooksCurrentId = async_hooks.executionAsyncId(),
        triggerId = async_hooks.triggerAsyncId(),
        indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(indentStr + "CONTEXT-GETTING KEY:" + key + "=" + this.active[key] + " (" + this.name + ") currentUid:" + currentUid + " active:" + util.inspect(this.active, {
        showHidden: !0,
        depth: 2,
        colors: !0
      })), debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
    }
    return this.active[key];
  }, "get");
  Namespace.prototype.createContext = __name(function () {
    let context = Object.create(this.active ? this.active : Object.prototype);
    if (context._ns_name = this.name, context.id = currentUid, DEBUG_CLS_HOOKED) {
      let asyncHooksCurrentId = async_hooks.executionAsyncId(),
        triggerId = async_hooks.triggerAsyncId(),
        indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, {
        showHidden: !0,
        depth: 2,
        colors: !0
      })}`);
    }
    return context;
  }, "createContext");
  Namespace.prototype.run = __name(function (fn) {
    let context = this.createContext();
    this.enter(context);
    try {
      if (DEBUG_CLS_HOOKED) {
        let triggerId = async_hooks.triggerAsyncId(),
          asyncHooksCurrentId = async_hooks.executionAsyncId(),
          indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
      }
      return fn(context), context;
    } catch (exception) {
      throw exception && (exception[ERROR_SYMBOL] = context), exception;
    } finally {
      if (DEBUG_CLS_HOOKED) {
        let triggerId = async_hooks.triggerAsyncId(),
          asyncHooksCurrentId = async_hooks.executionAsyncId(),
          indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
      }
      this.exit(context);
    }
  }, "run");
  Namespace.prototype.runAndReturn = __name(function (fn) {
    let value;
    return this.run(function (context) {
      value = fn(context);
    }), value;
  }, "runAndReturn");
  Namespace.prototype.runPromise = __name(function (fn) {
    let context = this.createContext();
    this.enter(context);
    let promise = fn(context);
    if (!promise || !promise.then || !promise.catch) throw new Error("fn must return a promise.");
    return DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise BEFORE: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), promise.then(result => (DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise AFTER then: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), this.exit(context), result)).catch(err => {
      throw err[ERROR_SYMBOL] = context, DEBUG_CLS_HOOKED && debug2("CONTEXT-runPromise AFTER catch: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), this.exit(context), err;
    });
  }, "runPromise");
  Namespace.prototype.bind = __name(function (fn, context) {
    context || (this.active ? context = this.active : context = this.createContext());
    let self = this;
    return __name(function () {
      self.enter(context);
      try {
        return fn.apply(this, arguments);
      } catch (exception) {
        throw exception && (exception[ERROR_SYMBOL] = context), exception;
      } finally {
        self.exit(context);
      }
    }, "clsBind");
  }, "bindFactory");
  Namespace.prototype.enter = __name(function (context) {
    if (assert.ok(context, "context must be provided for entering"), DEBUG_CLS_HOOKED) {
      let asyncHooksCurrentId = async_hooks.executionAsyncId(),
        triggerId = async_hooks.triggerAsyncId(),
        indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    this._set.push(this.active), this.active = context;
  }, "enter");
  Namespace.prototype.exit = __name(function (context) {
    if (assert.ok(context, "context must be provided for exiting"), DEBUG_CLS_HOOKED) {
      let asyncHooksCurrentId = async_hooks.executionAsyncId(),
        triggerId = async_hooks.triggerAsyncId(),
        indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
      debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
    }
    if (this.active === context) {
      assert.ok(this._set.length, "can't remove top context"), this.active = this._set.pop();
      return;
    }
    let index = this._set.lastIndexOf(context);
    index < 0 ? (DEBUG_CLS_HOOKED && debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context)), assert.ok(index >= 0, `context not currently entered; can't exit. 
` + util.inspect(this) + `
` + util.inspect(context))) : (assert.ok(index, "can't remove top context"), this._set.splice(index, 1));
  }, "exit");
  Namespace.prototype.bindEmitter = __name(function (emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    let namespace = this,
      thisSymbol = "context@" + this.name;
    function attach(listener) {
      listener && (listener[CONTEXTS_SYMBOL] || (listener[CONTEXTS_SYMBOL] = Object.create(null)), listener[CONTEXTS_SYMBOL][thisSymbol] = {
        namespace: namespace,
        context: namespace.active
      });
    }
    __name(attach, "attach");
    function bind(unwrapped) {
      if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;
      let wrapped = unwrapped,
        unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
      return Object.keys(unwrappedContexts).forEach(function (name) {
        let thunk = unwrappedContexts[name];
        wrapped = thunk.namespace.bind(wrapped, thunk.context);
      }), wrapped;
    }
    __name(bind, "bind"), wrapEmitter(emitter, attach, bind);
  }, "bindEmitter");
  Namespace.prototype.fromException = __name(function (exception) {
    return exception[ERROR_SYMBOL];
  }, "fromException");
  function getNamespace(name) {
    return process.namespaces[name];
  }
  __name(getNamespace, "getNamespace");
  function createNamespace(name) {
    assert.ok(name, "namespace must be given a name."), DEBUG_CLS_HOOKED && debug2(`NS-CREATING NAMESPACE (${name})`);
    let namespace = new Namespace(name);
    return namespace.id = currentUid, async_hooks.createHook({
      init(asyncId, type, triggerId, resource) {
        if (currentUid = async_hooks.executionAsyncId(), namespace.active) {
          if (namespace._contexts.set(asyncId, namespace.active), DEBUG_CLS_HOOKED) {
            let indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
              showHidden: !0,
              depth: 2,
              colors: !0
            })} resource:${resource}`);
          }
        } else if (currentUid === 0) {
          let triggerId = async_hooks.triggerAsyncId(),
            triggerIdContext = namespace._contexts.get(triggerId);
          if (triggerIdContext) {
            if (namespace._contexts.set(asyncId, triggerIdContext), DEBUG_CLS_HOOKED) {
              let indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
                showHidden: !0,
                depth: 2,
                colors: !0
              })} resource:${resource}`);
            }
          } else if (DEBUG_CLS_HOOKED) {
            let indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
              showHidden: !0,
              depth: 2,
              colors: !0
            })} resource:${resource}`);
          }
        }
        if (DEBUG_CLS_HOOKED && type === "PROMISE") {
          debug2(util.inspect(resource, {
            showHidden: !0
          }));
          let parentId = resource.parentId,
            indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
            showHidden: !0,
            depth: 2,
            colors: !0
          })} resource:${resource}`);
        }
      },
      before(asyncId) {
        currentUid = async_hooks.executionAsyncId();
        let context;
        if (context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid), context) {
          if (DEBUG_CLS_HOOKED) {
            let triggerId = async_hooks.triggerAsyncId(),
              indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
              showHidden: !0,
              depth: 2,
              colors: !0
            })} context:${util.inspect(context)}`), namespace._indent += 2;
          }
          namespace.enter(context);
        } else if (DEBUG_CLS_HOOKED) {
          let triggerId = async_hooks.triggerAsyncId(),
            indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
            showHidden: !0,
            depth: 2,
            colors: !0
          })} namespace._contexts:${util.inspect(namespace._contexts, {
            showHidden: !0,
            depth: 2,
            colors: !0
          })}`), namespace._indent += 2;
        }
      },
      after(asyncId) {
        currentUid = async_hooks.executionAsyncId();
        let context;
        if (context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid), context) {
          if (DEBUG_CLS_HOOKED) {
            let triggerId = async_hooks.triggerAsyncId();
            namespace._indent -= 2;
            let indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
              showHidden: !0,
              depth: 2,
              colors: !0
            })} context:${util.inspect(context)}`);
          }
          namespace.exit(context);
        } else if (DEBUG_CLS_HOOKED) {
          let triggerId = async_hooks.triggerAsyncId();
          namespace._indent -= 2;
          let indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, {
            showHidden: !0,
            depth: 2,
            colors: !0
          })} context:${util.inspect(context)}`);
        }
      },
      destroy(asyncId) {
        if (currentUid = async_hooks.executionAsyncId(), DEBUG_CLS_HOOKED) {
          let triggerId = async_hooks.triggerAsyncId(),
            indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
          debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, {
            showHidden: !0,
            depth: 2,
            colors: !0
          })} context:${util.inspect(namespace._contexts.get(currentUid))}`);
        }
        namespace._contexts.delete(asyncId);
      }
    }).enable(), process.namespaces[name] = namespace, namespace;
  }
  __name(createNamespace, "createNamespace");
  function destroyNamespace(name) {
    let namespace = getNamespace(name);
    assert.ok(namespace, `can't delete nonexistent namespace! "` + name + '"'), assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace)), process.namespaces[name] = null;
  }
  __name(destroyNamespace, "destroyNamespace");
  function reset() {
    process.namespaces && Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    }), process.namespaces = Object.create(null);
  }
  __name(reset, "reset");
  process.namespaces = {};
  function debug2(...args) {
    DEBUG_CLS_HOOKED && process._rawDebug(`${util.format(...args)}`);
  }
  __name(debug2, "debug2");
});
var require_next_tick = __commonJSMin((exports, module) => {
  "use strict";

  function NextTickWrap() {}
  __name(NextTickWrap, "NextTickWrap");
  module.exports = __name(function () {
    let hooks = this._hooks,
      state = this._state,
      oldNextTick = process.nextTick;
    process.nextTick = function () {
      if (!state.enabled) return oldNextTick.apply(process, arguments);
      let args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) args[i] = arguments[i];
      let callback = args[0];
      if (typeof callback != "function") throw new TypeError("callback is not a function");
      let handle = new NextTickWrap(),
        uid = --state.counter;
      return hooks.init.call(handle, uid, 0, null, null), args[0] = function () {
        hooks.pre.call(handle, uid);
        let didThrow = !0;
        try {
          callback.apply(this, arguments), didThrow = !1;
        } finally {
          didThrow && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", function () {
            hooks.post.call(handle, uid, !0), hooks.destroy.call(null, uid);
          });
        }
        hooks.post.call(handle, uid, !1), hooks.destroy.call(null, uid);
      }, oldNextTick.apply(process, args);
    };
  }, "patch");
});
var require_promise = __commonJSMin((exports, module) => {
  "use strict";

  function PromiseWrap() {}
  __name(PromiseWrap, "PromiseWrap");
  module.exports = __name(function () {
    let hooks = this._hooks,
      state = this._state,
      Promise = global.Promise,
      oldThen = Promise.prototype.then;
    Promise.prototype.then = wrappedThen;
    function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {
      return typeof fn != "function" ? isOnFulfilled ? makeUnhandledResolutionHandler(uid) : makeUnhandledRejectionHandler(uid) : __name(function () {
        hooks.pre.call(handle, uid);
        try {
          return fn.apply(this, arguments);
        } finally {
          hooks.post.call(handle, uid, !1), hooks.destroy.call(null, uid);
        }
      }, "wrappedHandler");
    }
    __name(makeWrappedHandler, "makeWrappedHandler");
    function makeUnhandledResolutionHandler(uid) {
      return __name(function (val) {
        return hooks.destroy.call(null, uid), val;
      }, "unhandledResolutionHandler");
    }
    __name(makeUnhandledResolutionHandler, "makeUnhandledResolutionHandler");
    function makeUnhandledRejectionHandler(uid) {
      return __name(function (val) {
        throw hooks.destroy.call(null, uid), val;
      }, "unhandledRejectedHandler");
    }
    __name(makeUnhandledRejectionHandler, "makeUnhandledRejectionHandler");
    function wrappedThen(onFulfilled, onRejected) {
      if (!state.enabled) return oldThen.call(this, onFulfilled, onRejected);
      let handle = new PromiseWrap(),
        uid = --state.counter;
      return hooks.init.call(handle, uid, 0, null, null), oldThen.call(this, makeWrappedHandler(onFulfilled, handle, uid, !0), makeWrappedHandler(onRejected, handle, uid, !1));
    }
    __name(wrappedThen, "wrappedThen");
  }, "patchPromise");
});
var require_timers = __commonJSMin((exports, module) => {
  "use strict";

  var timers = require("timers");
  function TimeoutWrap() {}
  __name(TimeoutWrap, "TimeoutWrap");
  function IntervalWrap() {}
  __name(IntervalWrap, "IntervalWrap");
  function ImmediateWrap() {}
  __name(ImmediateWrap, "ImmediateWrap");
  var timeoutMap = new Map(),
    intervalMap = new Map(),
    ImmediateMap = new Map(),
    activeCallback = null,
    clearedInCallback = !1;
  module.exports = __name(function () {
    patchTimer(this._hooks, this._state, "setTimeout", "clearTimeout", TimeoutWrap, timeoutMap, !0), patchTimer(this._hooks, this._state, "setInterval", "clearInterval", IntervalWrap, intervalMap, !1), patchTimer(this._hooks, this._state, "setImmediate", "clearImmediate", ImmediateWrap, ImmediateMap, !0), global.setTimeout = timers.setTimeout, global.setInterval = timers.setInterval, global.setImmediate = timers.setImmediate, global.clearTimeout = timers.clearTimeout, global.clearInterval = timers.clearInterval, global.clearImmediate = timers.clearImmediate;
  }, "patch");
  function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
    let oldSetFn = timers[setFn],
      oldClearFn = timers[clearFn];
    timers[setFn] = function () {
      if (!state.enabled) return oldSetFn.apply(timers, arguments);
      let args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) args[i] = arguments[i];
      let callback = args[0];
      if (typeof callback != "function") throw new TypeError('"callback" argument must be a function');
      let handle = new Handle(),
        uid = --state.counter,
        timerId;
      return hooks.init.call(handle, uid, 0, null, null), args[0] = function () {
        activeCallback = timerId, hooks.pre.call(handle, uid);
        let didThrow = !0;
        try {
          callback.apply(this, arguments), didThrow = !1;
        } finally {
          didThrow && process.listenerCount("uncaughtException") > 0 && process.once("uncaughtException", function () {
            hooks.post.call(handle, uid, !0), timerMap.delete(timerId), hooks.destroy.call(null, uid);
          });
        }
        hooks.post.call(handle, uid, !1), activeCallback = null, (singleCall || clearedInCallback) && (clearedInCallback = !1, timerMap.delete(timerId), hooks.destroy.call(null, uid));
      }, timerId = oldSetFn.apply(timers, args), timerMap.set(timerId, uid), timerId;
    }, timers[clearFn] = function (timerId) {
      if (activeCallback === timerId && timerId !== null) clearedInCallback = !0;else if (timerMap.has(timerId)) {
        let uid = timerMap.get(timerId);
        timerMap.delete(timerId), hooks.destroy.call(null, uid);
      }
      oldClearFn.apply(timers, arguments);
    };
  }
  __name(patchTimer, "patchTimer");
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "async-hook-jl",
    description: "Inspect the life of handle objects in node",
    version: "1.7.6",
    author: "Andreas Madsen <amwebdk@gmail.com>",
    main: "./index.js",
    scripts: {
      test: "node ./test/runner.js && eslint ."
    },
    repository: {
      type: "git",
      url: "git://github.com/jeff-lewis/async-hook-jl.git"
    },
    keywords: ["async", "async hooks", "inspect", "async wrap"],
    license: "MIT",
    dependencies: {
      "stack-chain": "^1.3.7"
    },
    devDependencies: {
      async: "1.5.x",
      "cli-color": "1.1.x",
      eslint: "^3.4.0",
      endpoint: "0.4.x"
    },
    engines: {
      node: "^4.7 || >=6.9 || >=7.3"
    }
  };
});
var require_async_hook = __commonJSMin((exports, module) => {
  "use strict";

  var asyncWrap = process.binding("async_wrap"),
    TIMERWRAP = asyncWrap.Providers.TIMERWRAP,
    patchs = {
      nextTick: YW(),
      promise: ZW(),
      timers: eK()
    },
    ignoreUIDs = new Set();
  function State() {
    this.enabled = !1, this.counter = 0;
  }
  __name(State, "State");
  function Hooks() {
    let initFns = this.initFns = [],
      preFns = this.preFns = [],
      postFns = this.postFns = [],
      destroyFns = this.destroyFns = [];
    this.init = function (uid, provider, parentUid, parentHandle) {
      if (provider === TIMERWRAP) {
        ignoreUIDs.add(uid);
        return;
      }
      for (let hook of initFns) hook(uid, this, provider, parentUid, parentHandle);
    }, this.pre = function (uid) {
      if (!ignoreUIDs.has(uid)) for (let hook of preFns) hook(uid, this);
    }, this.post = function (uid, didThrow) {
      if (!ignoreUIDs.has(uid)) for (let hook of postFns) hook(uid, this, didThrow);
    }, this.destroy = function (uid) {
      if (ignoreUIDs.has(uid)) {
        ignoreUIDs.delete(uid);
        return;
      }
      for (let hook of destroyFns) hook(uid);
    };
  }
  __name(Hooks, "Hooks");
  Hooks.prototype.add = function (hooks) {
    hooks.init && this.initFns.push(hooks.init), hooks.pre && this.preFns.push(hooks.pre), hooks.post && this.postFns.push(hooks.post), hooks.destroy && this.destroyFns.push(hooks.destroy);
  };
  function removeElement(array, item) {
    let index = array.indexOf(item);
    index !== -1 && array.splice(index, 1);
  }
  __name(removeElement, "removeElement");
  Hooks.prototype.remove = function (hooks) {
    hooks.init && removeElement(this.initFns, hooks.init), hooks.pre && removeElement(this.preFns, hooks.pre), hooks.post && removeElement(this.postFns, hooks.post), hooks.destroy && removeElement(this.destroyFns, hooks.destroy);
  };
  function AsyncHook() {
    this._state = new State(), this._hooks = new Hooks(), this.version = pP().version, this.providers = asyncWrap.Providers;
    for (let key of Object.keys(patchs)) patchs[key].call(this);
    process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING") && console.warn("warning: you are using async-hook-jl which is unstable."), asyncWrap.setupHooks({
      init: this._hooks.init,
      pre: this._hooks.pre,
      post: this._hooks.post,
      destroy: this._hooks.destroy
    });
  }
  __name(AsyncHook, "AsyncHook");
  module.exports = AsyncHook;
  AsyncHook.prototype.addHooks = function (hooks) {
    this._hooks.add(hooks);
  };
  AsyncHook.prototype.removeHooks = function (hooks) {
    this._hooks.remove(hooks);
  };
  AsyncHook.prototype.enable = function () {
    this._state.enabled = !0, asyncWrap.enable();
  };
  AsyncHook.prototype.disable = function () {
    this._state.enabled = !1, asyncWrap.disable();
  };
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "stack-chain",
    description: "API for combining call site modifiers",
    version: "1.3.7",
    author: "Andreas Madsen <amwebdk@gmail.com>",
    scripts: {
      test: "tap ./test/simple"
    },
    repository: {
      type: "git",
      url: "git://github.com/AndreasMadsen/stack-chain.git"
    },
    keywords: ["stack", "chain", "trace", "call site", "concat", "format"],
    devDependencies: {
      tap: "2.x.x",
      "uglify-js": "2.5.x"
    },
    license: "MIT"
  };
});
var require_format = __commonJSMin((exports, module) => {
  function FormatErrorString(error) {
    try {
      return Error.prototype.toString.call(error);
    } catch (e) {
      try {
        return "<error: " + e + ">";
      } catch {
        return "<error>";
      }
    }
  }
  __name(FormatErrorString, "FormatErrorString");
  module.exports = __name(function (error, frames) {
    var lines = [];
    lines.push(FormatErrorString(error));
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i],
        line;
      try {
        line = frame.toString();
      } catch (e) {
        try {
          line = "<error: " + e + ">";
        } catch {
          line = "<error>";
        }
      }
      lines.push("    at " + line);
    }
    return lines.join(`
`);
  }, "FormatStackTrace");
});
var require_stack_chain = __commonJSMin((exports, module) => {
  var defaultFormater = sK();
  function stackChain() {
    this.extend = new TraceModifier(), this.filter = new TraceModifier(), this.format = new StackFormater(), this.version = hP().version;
  }
  __name(stackChain, "stackChain");
  var SHORTCIRCUIT_CALLSITE = !1;
  stackChain.prototype.callSite = __name(function collectCallSites(options) {
    options || (options = {}), SHORTCIRCUIT_CALLSITE = !0;
    var obj = {};
    Error.captureStackTrace(obj, collectCallSites);
    var callSites = obj.stack;
    return SHORTCIRCUIT_CALLSITE = !1, callSites = callSites.slice(options.slice || 0), options.extend && (callSites = this.extend._modify(obj, callSites)), options.filter && (callSites = this.filter._modify(obj, callSites)), callSites;
  }, "collectCallSites");
  var chain = new stackChain();
  function TraceModifier() {
    this._modifiers = [];
  }
  __name(TraceModifier, "TraceModifier");
  TraceModifier.prototype._modify = function (error, frames) {
    for (var i = 0, l = this._modifiers.length; i < l; i++) frames = this._modifiers[i](error, frames);
    return frames;
  };
  TraceModifier.prototype.attach = function (modifier) {
    this._modifiers.push(modifier);
  };
  TraceModifier.prototype.deattach = function (modifier) {
    var index = this._modifiers.indexOf(modifier);
    return index === -1 ? !1 : (this._modifiers.splice(index, 1), !0);
  };
  function StackFormater() {
    this._formater = defaultFormater, this._previous = void 0;
  }
  __name(StackFormater, "StackFormater");
  StackFormater.prototype.replace = function (formater) {
    formater ? this._formater = formater : this.restore();
  };
  StackFormater.prototype.restore = function () {
    this._formater = defaultFormater, this._previous = void 0;
  };
  StackFormater.prototype._backup = function () {
    this._previous = this._formater;
  };
  StackFormater.prototype._roolback = function () {
    this._previous === defaultFormater ? this.replace(void 0) : this.replace(this._previous), this._previous = void 0;
  };
  Error.prepareStackTrace && chain.format.replace(Error.prepareStackTrace);
  var SHORTCIRCUIT_FORMATER = !1;
  function prepareStackTrace(error, originalFrames) {
    if (SHORTCIRCUIT_CALLSITE) return originalFrames;
    if (SHORTCIRCUIT_FORMATER) return defaultFormater(error, originalFrames);
    var frames = originalFrames.concat();
    frames = chain.extend._modify(error, frames), frames = chain.filter._modify(error, frames), frames = frames.slice(0, Error.stackTraceLimit), Object.isExtensible(error) && Object.getOwnPropertyDescriptor(error, "callSite") === void 0 && (error.callSite = {
      original: originalFrames,
      mutated: frames
    }), SHORTCIRCUIT_FORMATER = !0;
    var format = chain.format._formater(error, frames);
    return SHORTCIRCUIT_FORMATER = !1, format;
  }
  __name(prepareStackTrace, "prepareStackTrace");
  Object.defineProperty(Error, "prepareStackTrace", {
    get: function () {
      return prepareStackTrace;
    },
    set: function (formater) {
      formater === prepareStackTrace ? chain.format._roolback() : (chain.format._backup(), chain.format.replace(formater));
    }
  });
  function callSiteGetter() {
    return this.stack, this.callSite;
  }
  __name(callSiteGetter, "callSiteGetter");
  Object.defineProperty(Error.prototype, "callSite", {
    get: callSiteGetter,
    set: function (frames) {
      Object.defineProperty(this, "callSite", {
        value: frames,
        writable: !0,
        configurable: !0
      });
    },
    configurable: !0
  });
  module.exports = chain;
});
var require_stack_chain = __commonJSMin((exports, module) => {
  if (global._stackChain) {
    if (global._stackChain.version === hP().version) module.exports = global._stackChain;else throw new Error("Conflicting version of stack-chain found");
  } else module.exports = global._stackChain = cK();
});
var require_async_hook_jl = __commonJSMin((exports, module) => {
  "use strict";

  var AsyncHook = nK();
  if (global._asyncHook) {
    if (global._asyncHook.version === pP().version) module.exports = global._asyncHook;else throw new Error("Conflicting version of async-hook-jl found");
  } else vP().filter.attach(function (error, frames) {
    return frames.filter(function (callSite) {
      let filename = callSite.getFileName();
      return !(filename && filename.slice(0, __dirname.length) === __dirname);
    });
  }), module.exports = global._asyncHook = new AsyncHook();
});
var require_context_legacy = __commonJSMin((exports, module) => {
  "use strict";

  var util = require("util"),
    assert = require("assert"),
    wrapEmitter = X9(),
    asyncHook = uK(),
    CONTEXTS_SYMBOL = "cls@contexts",
    ERROR_SYMBOL = "error@context",
    invertedProviders = [];
  for (let key in asyncHook.providers) invertedProviders[asyncHook.providers[key]] = key;
  var DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED,
    currentUid = -1;
  module.exports = {
    getNamespace: getNamespace,
    createNamespace: createNamespace,
    destroyNamespace: destroyNamespace,
    reset: reset,
    ERROR_SYMBOL: ERROR_SYMBOL
  };
  function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null, this._contexts = new Map();
  }
  __name(Namespace, "Namespace");
  Namespace.prototype.set = __name(function (key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    return DEBUG_CLS_HOOKED && debug2("    SETTING KEY:" + key + "=" + value + " in ns:" + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0)), this.active[key] = value, value;
  }, "set");
  Namespace.prototype.get = __name(function (key) {
    if (!this.active) {
      DEBUG_CLS_HOOKED && debug2("    GETTING KEY:" + key + "=undefined " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0));
      return;
    }
    return DEBUG_CLS_HOOKED && debug2("    GETTING KEY:" + key + "=" + this.active[key] + " " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, !0)), this.active[key];
  }, "get");
  Namespace.prototype.createContext = __name(function () {
    DEBUG_CLS_HOOKED && debug2("   CREATING Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  active:" + util.inspect(this.active, !0, 2, !0));
    let context = Object.create(this.active ? this.active : Object.prototype);
    return context._ns_name = this.name, context.id = currentUid, DEBUG_CLS_HOOKED && debug2("   CREATED Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  context:" + util.inspect(context, !0, 2, !0)), context;
  }, "createContext");
  Namespace.prototype.run = __name(function (fn) {
    let context = this.createContext();
    this.enter(context);
    try {
      return DEBUG_CLS_HOOKED && debug2(" BEFORE RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), fn(context), context;
    } catch (exception) {
      throw exception && (exception[ERROR_SYMBOL] = context), exception;
    } finally {
      DEBUG_CLS_HOOKED && debug2(" AFTER RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), this.exit(context);
    }
  }, "run");
  Namespace.prototype.runAndReturn = __name(function (fn) {
    var value;
    return this.run(function (context) {
      value = fn(context);
    }), value;
  }, "runAndReturn");
  Namespace.prototype.runPromise = __name(function (fn) {
    let context = this.createContext();
    this.enter(context);
    let promise = fn(context);
    if (!promise || !promise.then || !promise.catch) throw new Error("fn must return a promise.");
    return DEBUG_CLS_HOOKED && debug2(" BEFORE runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), promise.then(result => (DEBUG_CLS_HOOKED && debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), this.exit(context), result)).catch(err => {
      throw err[ERROR_SYMBOL] = context, DEBUG_CLS_HOOKED && debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context)), this.exit(context), err;
    });
  }, "runPromise");
  Namespace.prototype.bind = __name(function (fn, context) {
    context || (this.active ? context = this.active : context = this.createContext());
    let self = this;
    return __name(function () {
      self.enter(context);
      try {
        return fn.apply(this, arguments);
      } catch (exception) {
        throw exception && (exception[ERROR_SYMBOL] = context), exception;
      } finally {
        self.exit(context);
      }
    }, "clsBind");
  }, "bindFactory");
  Namespace.prototype.enter = __name(function (context) {
    assert.ok(context, "context must be provided for entering"), DEBUG_CLS_HOOKED && debug2("  ENTER " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context)), this._set.push(this.active), this.active = context;
  }, "enter");
  Namespace.prototype.exit = __name(function (context) {
    if (assert.ok(context, "context must be provided for exiting"), DEBUG_CLS_HOOKED && debug2("  EXIT " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context)), this.active === context) {
      assert.ok(this._set.length, "can't remove top context"), this.active = this._set.pop();
      return;
    }
    let index = this._set.lastIndexOf(context);
    index < 0 ? (DEBUG_CLS_HOOKED && debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context)), assert.ok(index >= 0, `context not currently entered; can't exit. 
` + util.inspect(this) + `
` + util.inspect(context))) : (assert.ok(index, "can't remove top context"), this._set.splice(index, 1));
  }, "exit");
  Namespace.prototype.bindEmitter = __name(function (emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    let namespace = this,
      thisSymbol = "context@" + this.name;
    function attach(listener) {
      listener && (listener[CONTEXTS_SYMBOL] || (listener[CONTEXTS_SYMBOL] = Object.create(null)), listener[CONTEXTS_SYMBOL][thisSymbol] = {
        namespace: namespace,
        context: namespace.active
      });
    }
    __name(attach, "attach");
    function bind(unwrapped) {
      if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;
      let wrapped = unwrapped,
        unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
      return Object.keys(unwrappedContexts).forEach(function (name) {
        let thunk = unwrappedContexts[name];
        wrapped = thunk.namespace.bind(wrapped, thunk.context);
      }), wrapped;
    }
    __name(bind, "bind"), wrapEmitter(emitter, attach, bind);
  }, "bindEmitter");
  Namespace.prototype.fromException = __name(function (exception) {
    return exception[ERROR_SYMBOL];
  }, "fromException");
  function getNamespace(name) {
    return process.namespaces[name];
  }
  __name(getNamespace, "getNamespace");
  function createNamespace(name) {
    assert.ok(name, "namespace must be given a name."), DEBUG_CLS_HOOKED && debug2("CREATING NAMESPACE " + name);
    let namespace = new Namespace(name);
    return namespace.id = currentUid, asyncHook.addHooks({
      init(uid, handle, provider, parentUid, parentHandle) {
        currentUid = uid, parentUid ? (namespace._contexts.set(uid, namespace._contexts.get(parentUid)), DEBUG_CLS_HOOKED && debug2("PARENTID: " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + provider)) : namespace._contexts.set(currentUid, namespace.active), DEBUG_CLS_HOOKED && debug2("INIT " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + invertedProviders[provider] + " active:" + util.inspect(namespace.active, !0));
      },
      pre(uid, handle) {
        currentUid = uid;
        let context = namespace._contexts.get(uid);
        context ? (DEBUG_CLS_HOOKED && debug2(" PRE " + name + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context)), namespace.enter(context)) : DEBUG_CLS_HOOKED && debug2(" PRE MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle));
      },
      post(uid, handle) {
        currentUid = uid;
        let context = namespace._contexts.get(uid);
        context ? (DEBUG_CLS_HOOKED && debug2(" POST " + name + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context)), namespace.exit(context)) : DEBUG_CLS_HOOKED && debug2(" POST MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle));
      },
      destroy(uid) {
        currentUid = uid, DEBUG_CLS_HOOKED && debug2("DESTROY " + name + " uid:" + uid + " context:" + util.inspect(namespace._contexts.get(currentUid)) + " active:" + util.inspect(namespace.active, !0)), namespace._contexts.delete(uid);
      }
    }), process.namespaces[name] = namespace, namespace;
  }
  __name(createNamespace, "createNamespace");
  function destroyNamespace(name) {
    let namespace = getNamespace(name);
    assert.ok(namespace, `can't delete nonexistent namespace! "` + name + '"'), assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace)), process.namespaces[name] = null;
  }
  __name(destroyNamespace, "destroyNamespace");
  function reset() {
    process.namespaces && Object.keys(process.namespaces).forEach(function (name) {
      destroyNamespace(name);
    }), process.namespaces = Object.create(null);
  }
  __name(reset, "reset");
  process.namespaces = {};
  asyncHook._state && !asyncHook._state.enabled && asyncHook.enable();
  function debug2(msg) {
    process.env.DEBUG && process._rawDebug(msg);
  }
  __name(debug2, "debug2");
  function getFunctionName(fn) {
    if (!fn) return fn;
    if (typeof fn == "function") return fn.name ? fn.name : (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
    if (fn.constructor && fn.constructor.name) return fn.constructor.name;
  }
  __name(getFunctionName, "getFunctionName");
  if (DEBUG_CLS_HOOKED) {
    stackChain = vP();
    for (modifier in stackChain.filter._modifiers) stackChain.filter.deattach(modifier);
  }
  var stackChain, modifier;
});
var require_cls_hooked = __commonJSMin((exports, module) => {
  "use strict";

  var semver = BW();
  process && semver.gte(process.versions.node, "8.0.0") ? module.exports = KW() : module.exports = gK();
});
var require_semver = __commonJSMin((exports, module) => {
  exports = module.exports = SemVer;
  var debug;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? debug = __name(function () {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
  }, "debug") : debug = __name(function () {}, "debug");
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256,
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH = 16,
    MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6,
    re = exports.re = [],
    safeRe = exports.safeRe = [],
    src = exports.src = [],
    R = 0,
    LETTERDASHNUMBER = "[a-zA-Z0-9-]",
    safeRegexReplacements = [["\\s", 1], ["\\d", MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];
  function makeSafeRe(value) {
    for (var i = 0; i < safeRegexReplacements.length; i++) {
      var token = safeRegexReplacements[i][0],
        max = safeRegexReplacements[i][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  __name(makeSafeRe, "makeSafeRe");
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "\\d+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++,
    FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?",
    LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
  re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
  var tildeTrimReplace = "$1~",
    TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
  re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
  var caretTrimReplace = "$1^",
    CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3",
    HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (i = 0; i < R; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]), safeRe[i] = new RegExp(makeSafeRe(src[i])));
  var i;
  exports.parse = parse;
  function parse(version, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) return version;
    if (typeof version != "string" || version.length > MAX_LENGTH) return null;
    var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
    if (!r.test(version)) return null;
    try {
      return new SemVer(version, options);
    } catch {
      return null;
    }
  }
  __name(parse, "parse");
  exports.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  __name(valid, "valid");
  exports.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  __name(clean, "clean");
  exports.SemVer = SemVer;
  function SemVer(version, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) {
      if (version.loose === options.loose) return version;
      version = version.version;
    } else if (typeof version != "string") throw new TypeError("Invalid Version: " + version);
    if (version.length > MAX_LENGTH) throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    if (!(this instanceof SemVer)) return new SemVer(version, options);
    debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
    if (!m) throw new TypeError("Invalid Version: " + version);
    if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
    }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
  }
  __name(SemVer, "SemVer");
  SemVer.prototype.format = function () {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  };
  SemVer.prototype.toString = function () {
    return this.version;
  };
  SemVer.prototype.compare = function (other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function (other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function (other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
    if (!this.prerelease.length && other.prerelease.length) return 1;
    if (!this.prerelease.length && !other.prerelease.length) return 0;
    var i = 0;
    do {
      var a = this.prerelease[i],
        b = other.prerelease[i];
      if (debug("prerelease compare", i, a, b), a === void 0 && b === void 0) return 0;
      if (b === void 0) return 1;
      if (a === void 0) return -1;
      if (a === b) continue;
      return compareIdentifiers(a, b);
    } while (++i);
  };
  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", identifier), this.inc("pre", identifier);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) this.prerelease = [0];else {
          for (var i = this.prerelease.length; --i >= 0;) typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          i === -1 && this.prerelease.push(0);
        }
        identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [identifier, 0]) : this.prerelease = [identifier, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    return this.format(), this.raw = this.version, this;
  };
  exports.inc = inc;
  function inc(version, release, loose, identifier) {
    typeof loose == "string" && (identifier = loose, loose = void 0);
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch {
      return null;
    }
  }
  __name(inc, "inc");
  exports.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) return null;
    var v1 = parse(version1),
      v2 = parse(version2),
      prefix = "";
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = "pre";
      var defaultResult = "prerelease";
    }
    for (var key in v1) if ((key === "major" || key === "minor" || key === "patch") && v1[key] !== v2[key]) return prefix + key;
    return defaultResult;
  }
  __name(diff, "diff");
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a),
      bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  __name(compareIdentifiers, "compareIdentifiers");
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  __name(rcompareIdentifiers, "rcompareIdentifiers");
  exports.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  __name(major, "major");
  exports.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  __name(minor, "minor");
  exports.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  __name(patch, "patch");
  exports.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  __name(compare, "compare");
  exports.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, !0);
  }
  __name(compareLoose, "compareLoose");
  exports.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  __name(rcompare, "rcompare");
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose);
    });
  }
  __name(sort, "sort");
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose);
    });
  }
  __name(rsort, "rsort");
  exports.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  __name(gt, "gt");
  exports.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  __name(lt, "lt");
  exports.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  __name(eq, "eq");
  exports.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  __name(neq, "neq");
  exports.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  __name(gte, "gte");
  exports.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  __name(lte, "lte");
  exports.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a === b;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof b == "object" && (b = b.version), a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  __name(cmp, "cmp");
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), comp instanceof Comparator) {
      if (comp.loose === !!options.loose) return comp;
      comp = comp.value;
    }
    if (!(this instanceof Comparator)) return new Comparator(comp, options);
    comp = comp.trim().split(/\s+/).join(" "), debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, debug("comp", this);
  }
  __name(Comparator, "Comparator");
  var ANY = {};
  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR],
      m = comp.match(r);
    if (!m) throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1], this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
  };
  Comparator.prototype.toString = function () {
    return this.value;
  };
  Comparator.prototype.test = function (version) {
    return debug("Comparator.test", version, this.options.loose), this.semver === ANY ? !0 : (typeof version == "string" && (version = new SemVer(version, this.options)), cmp(version, this.operator, this.semver, this.options));
  };
  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
    (!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    });
    var rangeTmp;
    if (this.operator === "") return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
    if (comp.operator === "") return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">"),
      sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<"),
      sameSemVer = this.semver.version === comp.semver.version,
      differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<="),
      oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"),
      oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range, options) {
    if ((!options || typeof options != "object") && (options = {
      loose: !!options,
      includePrerelease: !1
    }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator) return new Range(range.value, options);
    if (!(this instanceof Range)) return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, this.raw = range.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  __name(Range, "Range");
  Range.prototype.format = function () {
    return this.range = this.set.map(function (comps) {
      return comps.join(" ").trim();
    }).join("||").trim(), this.range;
  };
  Range.prototype.toString = function () {
    return this.range;
  };
  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose,
      hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace), debug("comparator trim", range, safeRe[COMPARATORTRIM]), range = range.replace(safeRe[TILDETRIM], tildeTrimReplace), range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
    var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR],
      set = range.split(" ").map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter(function (comp) {
      return !!comp.match(compRe);
    })), set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this), set;
  };
  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) throw new TypeError("a Range is required");
    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  __name(toComparators, "toComparators");
  function parseComparator(comp, options) {
    return debug("comp", comp, options), comp = replaceCarets(comp, options), debug("caret", comp), comp = replaceTildes(comp, options), debug("tildes", comp), comp = replaceXRanges(comp, options), debug("xrange", comp), comp = replaceStars(comp, options), debug("stars", comp), comp;
  }
  __name(parseComparator, "parseComparator");
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  __name(isX, "isX");
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(" ");
  }
  __name(replaceTildes, "replaceTildes");
  function replaceTilde(comp, options) {
    var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", debug("tilde return", ret), ret;
    });
  }
  __name(replaceTilde, "replaceTilde");
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(" ");
  }
  __name(replaceCarets, "replaceCarets");
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      return isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? M === "0" ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), M === "0" ? m === "0" ? ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), debug("caret return", ret), ret;
    });
  }
  __name(replaceCaret, "replaceCaret");
  function replaceXRanges(comp, options) {
    return debug("replaceXRanges", comp, options), comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(" ");
  }
  __name(replaceXRanges, "replaceXRanges");
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M),
        xm = xM || isX(m),
        xp = xm || isX(p),
        anyX = xp;
      return gtlt === "=" && anyX && (gtlt = ""), xM ? gtlt === ">" || gtlt === "<" ? ret = "<0.0.0" : ret = "*" : gtlt && anyX ? (xm && (m = 0), p = 0, gtlt === ">" ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, p = 0)) : gtlt === "<=" && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), debug("xRange return", ret), ret;
    });
  }
  __name(replaceXRange, "replaceXRange");
  function replaceStars(comp, options) {
    return debug("replaceStars", comp, options), comp.trim().replace(safeRe[STAR], "");
  }
  __name(replaceStars, "replaceStars");
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return isX(fM) ? from = "" : isX(fm) ? from = ">=" + fM + ".0.0" : isX(fp) ? from = ">=" + fM + "." + fm + ".0" : from = ">=" + from, isX(tM) ? to = "" : isX(tm) ? to = "<" + (+tM + 1) + ".0.0" : isX(tp) ? to = "<" + tM + "." + (+tm + 1) + ".0" : tpr ? to = "<=" + tM + "." + tm + "." + tp + "-" + tpr : to = "<=" + to, (from + " " + to).trim();
  }
  __name(hyphenReplace, "hyphenReplace");
  Range.prototype.test = function (version) {
    if (!version) return !1;
    typeof version == "string" && (version = new SemVer(version, this.options));
    for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
    return !1;
  };
  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
      }
      return !1;
    }
    return !0;
  }
  __name(testSet, "testSet");
  exports.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch {
      return !1;
    }
    return range.test(version);
  }
  __name(satisfies, "satisfies");
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null,
      maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch {
      return null;
    }
    return versions.forEach(function (v) {
      rangeObj.test(v) && (!max || maxSV.compare(v) === -1) && (max = v, maxSV = new SemVer(max, options));
    }), max;
  }
  __name(maxSatisfying, "maxSatisfying");
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null,
      minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch {
      return null;
    }
    return versions.forEach(function (v) {
      rangeObj.test(v) && (!min || minSV.compare(v) === 1) && (min = v, minSV = new SemVer(min, options));
    }), min;
  }
  __name(minSatisfying, "minSatisfying");
  exports.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver) || (minver = new SemVer("0.0.0-0"), range.test(minver))) return minver;
    minver = null;
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            compver.prerelease.length === 0 ? compver.patch++ : compver.prerelease.push(0), compver.raw = compver.format();
          case "":
          case ">=":
            (!minver || gt(minver, compver)) && (minver = compver);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    return minver && range.test(minver) ? minver : null;
  }
  __name(minVersion, "minVersion");
  exports.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch {
      return null;
    }
  }
  __name(validRange, "validRange");
  exports.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  __name(ltr, "ltr");
  exports.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  __name(gtr, "gtr");
  exports.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options), range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
        break;
      case "<":
        gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i],
        high = null,
        low = null;
      if (comparators.forEach(function (comparator) {
        comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
      }), high.operator === comp || high.operator === ecomp || (!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
      if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
  }
  __name(outside, "outside");
  exports.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  __name(prerelease, "prerelease");
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
  }
  __name(intersects, "intersects");
  exports.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) return version;
    if (typeof version != "string") return null;
    var match = version.match(safeRe[COERCE]);
    return match == null ? null : parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  }
  __name(coerce, "coerce");
});
var require_glue = __commonJSMin((exports, module) => {
  var wrap = z9().wrap,
    HAS_CREATE_AL = 1,
    HAS_BEFORE_AL = 2,
    HAS_AFTER_AL = 4,
    HAS_ERROR_AL = 8,
    listeners = [],
    uid = 0,
    inAsyncTick = !1,
    listenerStack = [],
    asyncCatcher,
    asyncWrap;
  function union(dest, added) {
    var destLength = dest.length,
      addedLength = added.length,
      returned = [];
    if (destLength === 0 && addedLength === 0) return returned;
    for (var j = 0; j < destLength; j++) returned[j] = dest[j];
    if (addedLength === 0) return returned;
    for (var i = 0; i < addedLength; i++) {
      var missing = !0;
      for (j = 0; j < destLength; j++) if (dest[j].uid === added[i].uid) {
        missing = !1;
        break;
      }
      missing && returned.push(added[i]);
    }
    return returned;
  }
  __name(union, "union");
  process._fatalException ? (inErrorTick = !1, asyncCatcher = __name(function (er) {
    var length = listeners.length;
    if (inErrorTick || length === 0) return !1;
    var handled = !1;
    inErrorTick = !0;
    for (var i = 0; i < length; ++i) {
      var listener = listeners[i];
      if (listener.flags & HAS_ERROR_AL) {
        var value = errorValues && errorValues[listener.uid];
        handled = listener.error(value, er) || handled;
      }
    }
    return inErrorTick = !1, listenerStack.length > 0 && (listeners = listenerStack.pop()), errorValues = void 0, handled && !inAsyncTick;
  }, "asyncCatcher"), asyncWrap = __name(function (original, list, length) {
    var values = [];
    inAsyncTick = !0;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      if (values[listener.uid] = listener.data, !!(listener.flags & HAS_CREATE_AL)) {
        var value = listener.create(listener.data);
        value !== void 0 && (values[listener.uid] = value);
      }
    }
    return inAsyncTick = !1, function () {
      errorValues = values, listenerStack.push(listeners), listeners = union(list, listeners), inAsyncTick = !0;
      for (var i = 0; i < length; ++i) (list[i].flags & HAS_BEFORE_AL) > 0 && list[i].before(this, values[list[i].uid]);
      inAsyncTick = !1;
      var returned = original.apply(this, arguments);
      for (inAsyncTick = !0, i = 0; i < length; ++i) (list[i].flags & HAS_AFTER_AL) > 0 && list[i].after(this, values[list[i].uid]);
      return inAsyncTick = !1, listeners = listenerStack.pop(), errorValues = void 0, returned;
    };
  }, "asyncWrap"), wrap(process, "_fatalException", function (_fatalException) {
    return __name(function (er) {
      return asyncCatcher(er) || _fatalException(er);
    }, "_asyncFatalException");
  })) : (errorThrew = !1, asyncCatcher = __name(function (er) {
    if (errorThrew) throw er;
    for (var handled = !1, length = listeners.length, i = 0; i < length; ++i) {
      var listener = listeners[i];
      listener.flags & HAS_ERROR_AL && (handled = listener.error(null, er) || handled);
    }
    if (!handled && inAsyncTick) throw er;
  }, "uncaughtCatcher"), asyncWrap = __name(function (original, list, length) {
    var values = [];
    inAsyncTick = !0;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      if (values[listener.uid] = listener.data, !!(listener.flags & HAS_CREATE_AL)) {
        var value = listener.create(listener.data);
        value !== void 0 && (values[listener.uid] = value);
      }
    }
    return inAsyncTick = !1, function () {
      var threw = !1,
        handled = !1;
      listenerStack.push(listeners), listeners = union(list, listeners), inAsyncTick = !0;
      for (var i = 0; i < length; ++i) (list[i].flags & HAS_BEFORE_AL) > 0 && list[i].before(this, values[list[i].uid]);
      inAsyncTick = !1;
      var returned;
      try {
        returned = original.apply(this, arguments);
      } catch (er) {
        threw = !0;
        for (var i = 0; i < length; ++i) if (listeners[i].flags & HAS_ERROR_AL) try {
          handled = listeners[i].error(values[list[i].uid], er) || handled;
        } catch (x) {
          throw errorThrew = !0, x;
        }
        if (!handled) throw process.removeListener("uncaughtException", asyncCatcher), process._originalNextTick(function () {
          process.addListener("uncaughtException", asyncCatcher);
        }), er;
      } finally {
        if (!threw || handled) {
          for (inAsyncTick = !0, i = 0; i < length; ++i) (list[i].flags & HAS_AFTER_AL) > 0 && list[i].after(this, values[list[i].uid]);
          inAsyncTick = !1;
        }
        listeners = listenerStack.pop();
      }
      return returned;
    };
  }, "asyncWrap"), process.addListener("uncaughtException", asyncCatcher));
  var inErrorTick, errorValues, errorThrew;
  function simpleWrap(original, list, length) {
    inAsyncTick = !0;
    for (var i = 0; i < length; ++i) {
      var listener = list[i];
      listener.create && listener.create(listener.data);
    }
    return inAsyncTick = !1, function () {
      listenerStack.push(listeners), listeners = union(list, listeners);
      var returned = original.apply(this, arguments);
      return listeners = listenerStack.pop(), returned;
    };
  }
  __name(simpleWrap, "simpleWrap");
  function wrapCallback(original) {
    var length = listeners.length;
    if (length === 0) return original;
    for (var list = listeners.slice(), i = 0; i < length; ++i) if (list[i].flags > 0) return asyncWrap(original, list, length);
    return simpleWrap(original, list, length);
  }
  __name(wrapCallback, "wrapCallback");
  function AsyncListener(callbacks, data) {
    typeof callbacks.create == "function" && (this.create = callbacks.create, this.flags |= HAS_CREATE_AL), typeof callbacks.before == "function" && (this.before = callbacks.before, this.flags |= HAS_BEFORE_AL), typeof callbacks.after == "function" && (this.after = callbacks.after, this.flags |= HAS_AFTER_AL), typeof callbacks.error == "function" && (this.error = callbacks.error, this.flags |= HAS_ERROR_AL), this.uid = ++uid, this.data = data === void 0 ? null : data;
  }
  __name(AsyncListener, "AsyncListener");
  AsyncListener.prototype.create = void 0;
  AsyncListener.prototype.before = void 0;
  AsyncListener.prototype.after = void 0;
  AsyncListener.prototype.error = void 0;
  AsyncListener.prototype.data = void 0;
  AsyncListener.prototype.uid = 0;
  AsyncListener.prototype.flags = 0;
  function createAsyncListener(callbacks, data) {
    if (typeof callbacks != "object" || !callbacks) throw new TypeError("callbacks argument must be an object");
    return callbacks instanceof AsyncListener ? callbacks : new AsyncListener(callbacks, data);
  }
  __name(createAsyncListener, "createAsyncListener");
  function addAsyncListener(callbacks, data) {
    var listener;
    callbacks instanceof AsyncListener ? listener = callbacks : listener = createAsyncListener(callbacks, data);
    for (var registered = !1, i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
      registered = !0;
      break;
    }
    return registered || listeners.push(listener), listener;
  }
  __name(addAsyncListener, "addAsyncListener");
  function removeAsyncListener(listener) {
    for (var i = 0; i < listeners.length; i++) if (listener === listeners[i]) {
      listeners.splice(i, 1);
      break;
    }
  }
  __name(removeAsyncListener, "removeAsyncListener");
  process.createAsyncListener = createAsyncListener;
  process.addAsyncListener = addAsyncListener;
  process.removeAsyncListener = removeAsyncListener;
  module.exports = wrapCallback;
});
var require_es6_wrapped_promise = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = (Promise, ensureAslWrapper) => class extends Promise {
    static {
      __name(this, "WrappedPromise");
    }
    constructor(executor) {
      var context, args;
      super(wrappedExecutor);
      var promise = this;
      try {
        executor.apply(context, args);
      } catch (err) {
        args[1](err);
      }
      return promise;
      function wrappedExecutor(resolve, reject) {
        context = this, args = [wrappedResolve, wrappedReject];
        function wrappedResolve(val) {
          return ensureAslWrapper(promise, !1), resolve(val);
        }
        __name(wrappedResolve, "wrappedResolve");
        function wrappedReject(val) {
          return ensureAslWrapper(promise, !1), reject(val);
        }
        __name(wrappedReject, "wrappedReject");
      }
    }
  };
});
var require_async_listener = __commonJSMin(() => {
  "use strict";

  if (process.addAsyncListener) throw new Error("Don't require polyfill unless needed");
  var shimmer = z9(),
    semver = kK(),
    wrap = shimmer.wrap,
    massWrap = shimmer.massWrap,
    wrapCallback = BK(),
    util = require("util"),
    v6plus = semver.gte(process.version, "6.0.0"),
    v7plus = semver.gte(process.version, "7.0.0"),
    v8plus = semver.gte(process.version, "8.0.0"),
    v11plus = semver.gte(process.version, "11.0.0"),
    net = require("net");
  v7plus && !net._normalizeArgs ? net._normalizeArgs = function (args) {
    if (args.length === 0) return [{}, null];
    var arg0 = args[0],
      options = {};
    typeof arg0 == "object" && arg0 !== null ? options = arg0 : isPipeName(arg0) ? options.path = arg0 : (options.port = arg0, args.length > 1 && typeof args[1] == "string" && (options.host = args[1]));
    var cb = args[args.length - 1];
    return typeof cb != "function" ? [options, null] : [options, cb];
  } : !v7plus && !net._normalizeConnectArgs && (net._normalizeConnectArgs = function (args) {
    var options = {};
    function toNumber(x) {
      return (x = Number(x)) >= 0 ? x : !1;
    }
    __name(toNumber, "toNumber"), typeof args[0] == "object" && args[0] !== null ? options = args[0] : typeof args[0] == "string" && toNumber(args[0]) === !1 ? options.path = args[0] : (options.port = args[0], typeof args[1] == "string" && (options.host = args[1]));
    var cb = args[args.length - 1];
    return typeof cb == "function" ? [options, cb] : [options];
  });
  "_setUpListenHandle" in net.Server.prototype ? wrap(net.Server.prototype, "_setUpListenHandle", wrapSetUpListenHandle) : wrap(net.Server.prototype, "_listen2", wrapSetUpListenHandle);
  function wrapSetUpListenHandle(original) {
    return function () {
      this.on("connection", function (socket) {
        socket._handle && (socket._handle.onread = wrapCallback(socket._handle.onread));
      });
      try {
        return original.apply(this, arguments);
      } finally {
        this._handle && this._handle.onconnection && (this._handle.onconnection = wrapCallback(this._handle.onconnection));
      }
    };
  }
  __name(wrapSetUpListenHandle, "wrapSetUpListenHandle");
  function patchOnRead(ctx) {
    if (ctx && ctx._handle) {
      var handle = ctx._handle;
      handle._originalOnread || (handle._originalOnread = handle.onread), handle.onread = wrapCallback(handle._originalOnread);
    }
  }
  __name(patchOnRead, "patchOnRead");
  wrap(net.Socket.prototype, "connect", function (original) {
    return function () {
      var args;
      v8plus && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0 ? args = arguments[0] : args = v7plus ? net._normalizeArgs(arguments) : net._normalizeConnectArgs(arguments), args[1] && (args[1] = wrapCallback(args[1]));
      var result = original.apply(this, args);
      return patchOnRead(this), result;
    };
  });
  var http = require("http");
  wrap(http.Agent.prototype, "addRequest", function (original) {
    return function (req) {
      var onSocket = req.onSocket;
      return req.onSocket = wrapCallback(function (socket) {
        return patchOnRead(socket), onSocket.apply(this, arguments);
      }), original.apply(this, arguments);
    };
  });
  var childProcess = require("child_process");
  function wrapChildProcess(child) {
    Array.isArray(child.stdio) && child.stdio.forEach(function (socket) {
      socket && socket._handle && (socket._handle.onread = wrapCallback(socket._handle.onread), wrap(socket._handle, "close", activatorFirst));
    }), child._handle && (child._handle.onexit = wrapCallback(child._handle.onexit));
  }
  __name(wrapChildProcess, "wrapChildProcess");
  childProcess.ChildProcess ? wrap(childProcess.ChildProcess.prototype, "spawn", function (original) {
    return function () {
      var result = original.apply(this, arguments);
      return wrapChildProcess(this), result;
    };
  }) : massWrap(childProcess, ["execFile", "fork", "spawn"], function (original) {
    return function () {
      var result = original.apply(this, arguments);
      return wrapChildProcess(result), result;
    };
  });
  process._fatalException || (process._originalNextTick = process.nextTick);
  var processors = [];
  process._nextDomainTick && processors.push("_nextDomainTick");
  process._tickDomainCallback && processors.push("_tickDomainCallback");
  massWrap(process, processors, activator);
  wrap(process, "nextTick", activatorFirst);
  var asynchronizers = ["setTimeout", "setInterval"];
  global.setImmediate && asynchronizers.push("setImmediate");
  var timers = require("timers"),
    patchGlobalTimers = global.setTimeout === timers.setTimeout;
  massWrap(timers, asynchronizers, activatorFirst);
  patchGlobalTimers && massWrap(global, asynchronizers, activatorFirst);
  var dns = require("dns");
  massWrap(dns, ["lookup", "resolve", "resolve4", "resolve6", "resolveCname", "resolveMx", "resolveNs", "resolveTxt", "resolveSrv", "reverse"], activator);
  dns.resolveNaptr && wrap(dns, "resolveNaptr", activator);
  var fs = require("fs");
  massWrap(fs, ["watch", "rename", "truncate", "chown", "fchown", "chmod", "fchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "watchFile", "unwatchFile", "exists"], activator);
  fs.lchown && wrap(fs, "lchown", activator);
  fs.lchmod && wrap(fs, "lchmod", activator);
  fs.ftruncate && wrap(fs, "ftruncate", activator);
  var zlib;
  try {
    zlib = require("zlib");
  } catch {}
  zlib && zlib.Deflate && zlib.Deflate.prototype && (proto = Object.getPrototypeOf(zlib.Deflate.prototype), proto._transform ? wrap(proto, "_transform", activator) : proto.write && proto.flush && proto.end && massWrap(proto, ["write", "flush", "end"], activator));
  var proto, crypto;
  try {
    crypto = require("crypto");
  } catch {}
  crypto && (toWrap = ["pbkdf2", "randomBytes"], v11plus || toWrap.push("pseudoRandomBytes"), massWrap(crypto, toWrap, activator));
  var toWrap,
    instrumentPromise = !!global.Promise && Promise.toString() === "function Promise() { [native code] }" && Promise.toString.toString() === "function toString() { [native code] }";
  instrumentPromise && (promiseListener = process.addAsyncListener({
    create: __name(function () {
      instrumentPromise = !1;
    }, "create")
  }), global.Promise.resolve(!0).then(__name(function () {
    instrumentPromise = !1;
  }, "notSync")), process.removeAsyncListener(promiseListener));
  var promiseListener;
  instrumentPromise && wrapPromise();
  function wrapPromise() {
    var Promise = global.Promise;
    function wrappedPromise(executor) {
      if (!(this instanceof wrappedPromise)) return Promise(executor);
      if (typeof executor != "function") return new Promise(executor);
      var context,
        args,
        promise = new Promise(wrappedExecutor);
      promise.__proto__ = wrappedPromise.prototype;
      try {
        executor.apply(context, args);
      } catch (err) {
        args[1](err);
      }
      return promise;
      function wrappedExecutor(resolve, reject) {
        context = this, args = [wrappedResolve, wrappedReject];
        function wrappedResolve(val) {
          return ensureAslWrapper(promise, !1), resolve(val);
        }
        __name(wrappedResolve, "wrappedResolve");
        function wrappedReject(val) {
          return ensureAslWrapper(promise, !1), reject(val);
        }
        __name(wrappedReject, "wrappedReject");
      }
    }
    if (__name(wrappedPromise, "wrappedPromise"), util.inherits(wrappedPromise, Promise), wrap(Promise.prototype, "then", wrapThen), Promise.prototype.chain && wrap(Promise.prototype, "chain", wrapThen), v6plus) global.Promise = UK()(Promise, ensureAslWrapper);else {
      var PromiseFunctions = ["all", "race", "reject", "resolve", "accept", "defer"];
      PromiseFunctions.forEach(function (key) {
        typeof Promise[key] == "function" && (wrappedPromise[key] = Promise[key]);
      }), global.Promise = wrappedPromise;
    }
    function ensureAslWrapper(promise, overwrite) {
      (!promise.__asl_wrapper || overwrite) && (promise.__asl_wrapper = wrapCallback(propagateAslWrapper));
    }
    __name(ensureAslWrapper, "ensureAslWrapper");
    function propagateAslWrapper(ctx, fn, result, next) {
      var nextResult;
      try {
        return nextResult = fn.call(ctx, result), {
          returnVal: nextResult,
          error: !1
        };
      } catch (err) {
        return {
          errorVal: err,
          error: !0
        };
      } finally {
        nextResult instanceof Promise ? next.__asl_wrapper = __name(function () {
          var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
          return aslWrapper.apply(this, arguments);
        }, "proxyWrapper") : ensureAslWrapper(next, !0);
      }
    }
    __name(propagateAslWrapper, "propagateAslWrapper");
    function wrapThen(original) {
      return __name(function () {
        var promise = this,
          next = original.apply(promise, Array.prototype.map.call(arguments, bind));
        return next.__asl_wrapper = __name(function (ctx, fn, val, last) {
          return promise.__asl_wrapper ? (promise.__asl_wrapper(ctx, function () {}, null, next), next.__asl_wrapper(ctx, fn, val, last)) : propagateAslWrapper(ctx, fn, val, last);
        }, "proxyWrapper"), next;
        function bind(fn) {
          return typeof fn != "function" ? fn : wrapCallback(function (val) {
            var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
            if (result.error) throw result.errorVal;
            return result.returnVal;
          });
        }
        __name(bind, "bind");
      }, "wrappedThen");
    }
    __name(wrapThen, "wrapThen");
  }
  __name(wrapPromise, "wrapPromise");
  function activator(fn) {
    var fallback = __name(function () {
      var args,
        cbIdx = arguments.length - 1;
      if (typeof arguments[cbIdx] == "function") {
        args = Array(arguments.length);
        for (var i = 0; i < arguments.length - 1; i++) args[i] = arguments[i];
        args[cbIdx] = wrapCallback(arguments[cbIdx]);
      }
      return fn.apply(this, args || arguments);
    }, "fallback");
    switch (fn.length) {
      case 1:
        return function (cb) {
          return arguments.length !== 1 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb));
        };
      case 2:
        return function (a, cb) {
          return arguments.length !== 2 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, a, cb));
        };
      case 3:
        return function (a, b, cb) {
          return arguments.length !== 3 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, a, b, cb));
        };
      case 4:
        return function (a, b, c, cb) {
          return arguments.length !== 4 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, a, b, c, cb));
        };
      case 5:
        return function (a, b, c, d, cb) {
          return arguments.length !== 5 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, a, b, c, d, cb));
        };
      case 6:
        return function (a, b, c, d, e, cb) {
          return arguments.length !== 6 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, a, b, c, d, e, cb));
        };
      default:
        return fallback;
    }
  }
  __name(activator, "activator");
  function activatorFirst(fn) {
    var fallback = __name(function () {
      var args;
      if (typeof arguments[0] == "function") {
        args = Array(arguments.length), args[0] = wrapCallback(arguments[0]);
        for (var i = 1; i < arguments.length; i++) args[i] = arguments[i];
      }
      return fn.apply(this, args || arguments);
    }, "fallback");
    switch (fn.length) {
      case 1:
        return function (cb) {
          return arguments.length !== 1 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb));
        };
      case 2:
        return function (cb, a) {
          return arguments.length !== 2 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb, a));
        };
      case 3:
        return function (cb, a, b) {
          return arguments.length !== 3 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb, a, b));
        };
      case 4:
        return function (cb, a, b, c) {
          return arguments.length !== 4 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb, a, b, c));
        };
      case 5:
        return function (cb, a, b, c, d) {
          return arguments.length !== 5 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb, a, b, c, d));
        };
      case 6:
        return function (cb, a, b, c, d, e) {
          return arguments.length !== 6 ? fallback.apply(this, arguments) : (typeof cb == "function" && (cb = wrapCallback(cb)), fn.call(this, cb, a, b, c, d, e));
        };
      default:
        return fallback;
    }
  }
  __name(activatorFirst, "activatorFirst");
  function toNumber(x) {
    return (x = Number(x)) >= 0 ? x : !1;
  }
  __name(toNumber, "toNumber");
  function isPipeName(s) {
    return typeof s == "string" && toNumber(s) === !1;
  }
  __name(isPipeName, "isPipeName");
});
var require_context = __commonJSMin((exports, module) => {
  "use strict";

  var assert = require("assert"),
    wrapEmitter = X9(),
    CONTEXTS_SYMBOL = "cls@contexts",
    ERROR_SYMBOL = "error@context";
  process.addAsyncListener || zK();
  function Namespace(name) {
    this.name = name, this.active = null, this._set = [], this.id = null;
  }
  __name(Namespace, "Namespace");
  Namespace.prototype.set = function (key, value) {
    if (!this.active) throw new Error("No context available. ns.run() or ns.bind() must be called first.");
    return this.active[key] = value, value;
  };
  Namespace.prototype.get = function (key) {
    if (this.active) return this.active[key];
  };
  Namespace.prototype.createContext = function () {
    return Object.create(this.active);
  };
  Namespace.prototype.run = function (fn) {
    var context = this.createContext();
    this.enter(context);
    try {
      return fn(context), context;
    } catch (exception) {
      throw exception && (exception[ERROR_SYMBOL] = context), exception;
    } finally {
      this.exit(context);
    }
  };
  Namespace.prototype.runAndReturn = function (fn) {
    var value;
    return this.run(function (context) {
      value = fn(context);
    }), value;
  };
  Namespace.prototype.bind = function (fn, context) {
    context || (this.active ? context = this.active : context = this.createContext());
    var self = this;
    return function () {
      self.enter(context);
      try {
        return fn.apply(this, arguments);
      } catch (exception) {
        throw exception && (exception[ERROR_SYMBOL] = context), exception;
      } finally {
        self.exit(context);
      }
    };
  };
  Namespace.prototype.enter = function (context) {
    assert.ok(context, "context must be provided for entering"), this._set.push(this.active), this.active = context;
  };
  Namespace.prototype.exit = function (context) {
    if (assert.ok(context, "context must be provided for exiting"), this.active === context) {
      assert.ok(this._set.length, "can't remove top context"), this.active = this._set.pop();
      return;
    }
    var index = this._set.lastIndexOf(context);
    assert.ok(index >= 0, "context not currently entered; can't exit"), assert.ok(index, "can't remove top context"), this._set.splice(index, 1);
  };
  Namespace.prototype.bindEmitter = function (emitter) {
    assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
    var namespace = this,
      thisSymbol = "context@" + this.name;
    function attach(listener) {
      listener && (listener[CONTEXTS_SYMBOL] || (listener[CONTEXTS_SYMBOL] = Object.create(null)), listener[CONTEXTS_SYMBOL][thisSymbol] = {
        namespace: namespace,
        context: namespace.active
      });
    }
    __name(attach, "attach");
    function bind(unwrapped) {
      if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) return unwrapped;
      var wrapped = unwrapped,
        contexts = unwrapped[CONTEXTS_SYMBOL];
      return Object.keys(contexts).forEach(function (name) {
        var thunk = contexts[name];
        wrapped = thunk.namespace.bind(wrapped, thunk.context);
      }), wrapped;
    }
    __name(bind, "bind"), wrapEmitter(emitter, attach, bind);
  };
  Namespace.prototype.fromException = function (exception) {
    return exception[ERROR_SYMBOL];
  };
  function get(name) {
    return process.namespaces[name];
  }
  __name(get, "get");
  function create(name) {
    assert.ok(name, "namespace must be given a name!");
    var namespace = new Namespace(name);
    return namespace.id = process.addAsyncListener({
      create: function () {
        return namespace.active;
      },
      before: function (context, storage) {
        storage && namespace.enter(storage);
      },
      after: function (context, storage) {
        storage && namespace.exit(storage);
      },
      error: function (storage) {
        storage && namespace.exit(storage);
      }
    }), process.namespaces[name] = namespace, namespace;
  }
  __name(create, "create");
  function destroy(name) {
    var namespace = get(name);
    assert.ok(namespace, "can't delete nonexistent namespace!"), assert.ok(namespace.id, "don't assign to process.namespaces directly!"), process.removeAsyncListener(namespace.id), process.namespaces[name] = null;
  }
  __name(destroy, "destroy");
  function reset() {
    process.namespaces && Object.keys(process.namespaces).forEach(function (name) {
      destroy(name);
    }), process.namespaces = Object.create(null);
  }
  __name(reset, "reset");
  process.namespaces || reset();
  module.exports = {
    getNamespace: get,
    createNamespace: create,
    destroyNamespace: destroy,
    reset: reset
  };
});
var Mp = T(m7 => {
  "use strict";

  Object.defineProperty(m7, "__esModule", {
    value: !0
  });
  m7.CorrelationContextManager = void 0;
  var Logging = x0(),
    DiagChannel = L9(),
    Traceparent = k9(),
    Tracestate = SA(),
    HttpRequestParser = VA(),
    Util = il(),
    CorrelationContextManager = function () {
      function CorrelationContextManager() {}
      return __name(CorrelationContextManager, "CorrelationContextManager"), CorrelationContextManager.getCurrentContext = function () {
        if (!CorrelationContextManager.enabled) return null;
        var context = CorrelationContextManager.session.get(CorrelationContextManager.CONTEXT_NAME);
        return context === void 0 ? null : context;
      }, CorrelationContextManager.generateContextObject = function (operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
        return parentId = parentId || operationId, this.enabled ? {
          operation: {
            name: operationName,
            id: operationId,
            parentId: parentId,
            traceparent: traceparent,
            tracestate: tracestate
          },
          customProperties: new CustomPropertiesImpl(correlationContextHeader)
        } : null;
      }, CorrelationContextManager.spanToContextObject = function (spanContext, parentId, name) {
        var traceContext = new Traceparent();
        return traceContext.traceId = spanContext.traceId, traceContext.spanId = spanContext.spanId, traceContext.traceFlag = Traceparent.formatOpenTelemetryTraceFlags(spanContext.traceFlags) || Traceparent.DEFAULT_TRACE_FLAG, traceContext.parentId = parentId, CorrelationContextManager.generateContextObject(traceContext.traceId, traceContext.parentId, name, null, traceContext);
      }, CorrelationContextManager.runWithContext = function (context, fn) {
        var n;
        if (CorrelationContextManager.enabled) try {
          return CorrelationContextManager.session.bind(fn, (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, _a))();
        } catch (error) {
          Logging.warn("Error binding to session context", Util.dumpObj(error));
        }
        return fn();
      }, CorrelationContextManager.wrapEmitter = function (emitter) {
        if (CorrelationContextManager.enabled) try {
          CorrelationContextManager.session.bindEmitter(emitter);
        } catch (error) {
          Logging.warn("Error binding to session context", Util.dumpObj(error));
        }
      }, CorrelationContextManager.wrapCallback = function (fn, context) {
        var n;
        if (CorrelationContextManager.enabled) try {
          return CorrelationContextManager.session.bind(fn, context ? (_a = {}, _a[CorrelationContextManager.CONTEXT_NAME] = context, n) : void 0);
        } catch (error) {
          Logging.warn("Error binding to session context", Util.dumpObj(error));
        }
        return fn;
      }, CorrelationContextManager.enable = function (forceClsHooked) {
        if (!this.enabled) {
          if (!this.isNodeVersionCompatible()) {
            this.enabled = !1;
            return;
          }
          CorrelationContextManager.hasEverEnabled || (this.forceClsHooked = forceClsHooked, this.hasEverEnabled = !0, typeof this.cls > "u" && (CorrelationContextManager.forceClsHooked === !0 || CorrelationContextManager.forceClsHooked === void 0 && CorrelationContextManager.shouldUseClsHooked() ? this.cls = _K() : this.cls = QK()), CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session"), DiagChannel.registerContextPreservation(function (cb) {
            try {
              return CorrelationContextManager.session.bind(cb);
            } catch (error) {
              Logging.warn("Error binding to session context", Util.dumpObj(error));
            }
          })), this.enabled = !0;
        }
      }, CorrelationContextManager.startOperation = function (input, request) {
        var traceContext = input && input.traceContext || null,
          span = input && input.spanContext ? input : null,
          spanContext = input && input.traceId ? input : null,
          headers = input && input.headers;
        if (span) return this.spanToContextObject(span.spanContext(), span.parentSpanId, span.name);
        if (spanContext) return this.spanToContextObject(spanContext, "|" + spanContext.traceId + "." + spanContext.spanId + ".", typeof request == "string" ? request : "");
        var operationName = typeof request == "string" ? request : "";
        if (traceContext) {
          var traceparent = null,
            tracestate = null;
          if (operationName = traceContext.attributes.OperationName || operationName, request) {
            var azureFnRequest = request;
            azureFnRequest.headers && (azureFnRequest.headers.traceparent ? traceparent = new Traceparent(azureFnRequest.headers.traceparent) : azureFnRequest.headers["request-id"] && (traceparent = new Traceparent(null, azureFnRequest.headers["request-id"])), azureFnRequest.headers.tracestate && (tracestate = new Tracestate(azureFnRequest.headers.tracestate)));
          }
          traceparent || (traceparent = new Traceparent(traceContext.traceparent)), tracestate || (tracestate = new Tracestate(traceContext.tracestate));
          var correlationContextHeader = void 0;
          if (typeof request == "object") {
            var parser = new HttpRequestParser(request);
            correlationContextHeader = parser.getCorrelationContextHeader(), operationName = parser.getOperationName({});
          }
          var correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, operationName, correlationContextHeader, traceparent, tracestate);
          return correlationContext;
        }
        if (headers) {
          var traceparent = new Traceparent(headers.traceparent ? headers.traceparent.toString() : null),
            tracestate = new Tracestate(headers.tracestate ? headers.tracestate.toString() : null),
            parser = new HttpRequestParser(input),
            correlationContext = CorrelationContextManager.generateContextObject(traceparent.traceId, traceparent.parentId, parser.getOperationName({}), parser.getCorrelationContextHeader(), traceparent, tracestate);
          return correlationContext;
        }
        return Logging.warn("startOperation was called with invalid arguments", arguments), null;
      }, CorrelationContextManager.disable = function () {
        this.enabled = !1;
      }, CorrelationContextManager.reset = function () {
        CorrelationContextManager.hasEverEnabled && (CorrelationContextManager.session = null, CorrelationContextManager.session = this.cls.createNamespace("AI-CLS-Session"));
      }, CorrelationContextManager.isNodeVersionCompatible = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 3 || parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2;
      }, CorrelationContextManager.shouldUseClsHooked = function () {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2;
      }, CorrelationContextManager.canUseClsHooked = function () {
        var nodeVer = process.versions.node.split("."),
          greater800 = parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0,
          less820 = parseInt(nodeVer[0]) < 8 || parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2,
          greater470 = parseInt(nodeVer[0]) > 4 || parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7;
        return !(greater800 && less820) && greater470;
      }, CorrelationContextManager.enabled = !1, CorrelationContextManager.hasEverEnabled = !1, CorrelationContextManager.forceClsHooked = void 0, CorrelationContextManager.CONTEXT_NAME = "ApplicationInsights-Context", CorrelationContextManager;
    }();
  exports.CorrelationContextManager = CorrelationContextManager;
  var CustomPropertiesImpl = function () {
    function CustomPropertiesImpl(header) {
      this.props = [], this.addHeaderData(header);
    }
    return __name(CustomPropertiesImpl, "CustomPropertiesImpl"), CustomPropertiesImpl.prototype.addHeaderData = function (header) {
      var keyvals = header ? header.split(", ") : [];
      this.props = keyvals.map(function (keyval) {
        var parts = keyval.split("=");
        return {
          key: parts[0],
          value: parts[1]
        };
      }).concat(this.props);
    }, CustomPropertiesImpl.prototype.serializeToHeader = function () {
      return this.props.map(function (keyval) {
        return keyval.key + "=" + keyval.value;
      }).join(", ");
    }, CustomPropertiesImpl.prototype.getProperty = function (prop) {
      for (var i = 0; i < this.props.length; ++i) {
        var keyval = this.props[i];
        if (keyval.key === prop) return keyval.value;
      }
    }, CustomPropertiesImpl.prototype.setProperty = function (prop, val) {
      if (CustomPropertiesImpl.bannedCharacters.test(prop) || CustomPropertiesImpl.bannedCharacters.test(val)) {
        Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val);
        return;
      }
      for (var i = 0; i < this.props.length; ++i) {
        var keyval = this.props[i];
        if (keyval.key === prop) {
          keyval.value = val;
          return;
        }
      }
      this.props.push({
        key: prop,
        value: val
      });
    }, CustomPropertiesImpl.bannedCharacters = /[,=]/, CustomPropertiesImpl;
  }();
});
var L0 = T($n => {
  "use strict";

  var rf;
  Object.defineProperty($n, "__esModule", {
    value: !0
  });
  $n.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = $n.WEB_INSTRUMENTATION_DEFAULT_SOURCE = $n.TIME_SINCE_ENQUEUED = $n.ENQUEUED_TIME = $n.MessageBusDestination = $n.MicrosoftEventHub = $n.AzNamespace = $n.StatsbeatNetworkCategory = $n.StatsbeatFeatureType = $n.StatsbeatInstrumentation = $n.StatsbeatFeature = $n.StatsbeatCounter = $n.StatsbeatAttach = $n.StatsbeatResourceProvider = $n.StatsbeatTelemetryName = $n.HeartBeatMetricName = $n.DependencyTypeName = $n.TelemetryTypeStringToQuickPulseDocumentType = $n.TelemetryTypeStringToQuickPulseType = $n.QuickPulseType = $n.QuickPulseDocumentType = $n.PerformanceToQuickPulseCounter = $n.MetricId = $n.PerformanceCounter = $n.QuickPulseCounter = $n.DEFAULT_LIVEMETRICS_HOST = $n.DEFAULT_LIVEMETRICS_ENDPOINT = $n.DEFAULT_BREEZE_ENDPOINT = $n.APPLICATION_INSIGHTS_SDK_VERSION = void 0;
  exports.APPLICATION_INSIGHTS_SDK_VERSION = "2.7.3";
  exports.DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
  exports.DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
  exports.DEFAULT_LIVEMETRICS_HOST = "rt.services.visualstudio.com";
  var QuickPulseCounter;
  (function (QuickPulseCounter) {
    QuickPulseCounter.COMMITTED_BYTES = "\\Memory\\Committed Bytes", QuickPulseCounter.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", QuickPulseCounter.REQUEST_RATE = "\\ApplicationInsights\\Requests/Sec", QuickPulseCounter.REQUEST_FAILURE_RATE = "\\ApplicationInsights\\Requests Failed/Sec", QuickPulseCounter.REQUEST_DURATION = "\\ApplicationInsights\\Request Duration", QuickPulseCounter.DEPENDENCY_RATE = "\\ApplicationInsights\\Dependency Calls/Sec", QuickPulseCounter.DEPENDENCY_FAILURE_RATE = "\\ApplicationInsights\\Dependency Calls Failed/Sec", QuickPulseCounter.DEPENDENCY_DURATION = "\\ApplicationInsights\\Dependency Call Duration", QuickPulseCounter.EXCEPTION_RATE = "\\ApplicationInsights\\Exceptions/Sec";
  })(QuickPulseCounter = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));
  var PerformanceCounter;
  (function (PerformanceCounter) {
    PerformanceCounter.PRIVATE_BYTES = "\\Process(??APP_WIN32_PROC??)\\Private Bytes", PerformanceCounter.AVAILABLE_BYTES = "\\Memory\\Available Bytes", PerformanceCounter.PROCESSOR_TIME = "\\Processor(_Total)\\% Processor Time", PerformanceCounter.PROCESS_TIME = "\\Process(??APP_WIN32_PROC??)\\% Processor Time", PerformanceCounter.REQUEST_RATE = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec", PerformanceCounter.REQUEST_DURATION = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
  })(PerformanceCounter = exports.PerformanceCounter || (exports.PerformanceCounter = {}));
  var MetricId;
  (function (MetricId) {
    MetricId.REQUESTS_DURATION = "requests/duration", MetricId.DEPENDENCIES_DURATION = "dependencies/duration", MetricId.EXCEPTIONS_COUNT = "exceptions/count", MetricId.TRACES_COUNT = "traces/count";
  })(MetricId = exports.MetricId || (exports.MetricId = {}));
  exports.PerformanceToQuickPulseCounter = (_a = {}, _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME, _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE, _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION, _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES, _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE, _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE, _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE, _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION, _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE, rf);
  exports.QuickPulseDocumentType = {
    Event: "Event",
    Exception: "Exception",
    Trace: "Trace",
    Metric: "Metric",
    Request: "Request",
    Dependency: "RemoteDependency",
    Availability: "Availability",
    PageView: "PageView"
  };
  exports.QuickPulseType = {
    Event: "EventTelemetryDocument",
    Exception: "ExceptionTelemetryDocument",
    Trace: "TraceTelemetryDocument",
    Metric: "MetricTelemetryDocument",
    Request: "RequestTelemetryDocument",
    Dependency: "DependencyTelemetryDocument",
    Availability: "AvailabilityTelemetryDocument",
    PageView: "PageViewTelemetryDocument"
  };
  exports.TelemetryTypeStringToQuickPulseType = {
    EventData: exports.QuickPulseType.Event,
    ExceptionData: exports.QuickPulseType.Exception,
    MessageData: exports.QuickPulseType.Trace,
    MetricData: exports.QuickPulseType.Metric,
    RequestData: exports.QuickPulseType.Request,
    RemoteDependencyData: exports.QuickPulseType.Dependency,
    AvailabilityData: exports.QuickPulseType.Availability,
    PageViewData: exports.QuickPulseType.PageView
  };
  exports.TelemetryTypeStringToQuickPulseDocumentType = {
    EventData: exports.QuickPulseDocumentType.Event,
    ExceptionData: exports.QuickPulseDocumentType.Exception,
    MessageData: exports.QuickPulseDocumentType.Trace,
    MetricData: exports.QuickPulseDocumentType.Metric,
    RequestData: exports.QuickPulseDocumentType.Request,
    RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,
    AvailabilityData: exports.QuickPulseDocumentType.Availability,
    PageViewData: exports.QuickPulseDocumentType.PageView
  };
  exports.DependencyTypeName = {
    Grpc: "GRPC",
    Http: "HTTP",
    InProc: "InProc",
    Sql: "SQL",
    QueueMessage: "Queue Message"
  };
  exports.HeartBeatMetricName = "HeartbeatState";
  exports.StatsbeatTelemetryName = "Statsbeat";
  exports.StatsbeatResourceProvider = {
    appsvc: "appsvc",
    functions: "functions",
    vm: "vm",
    unknown: "unknown"
  };
  exports.StatsbeatAttach = {
    codeless: "codeless",
    sdk: "sdk"
  };
  exports.StatsbeatCounter = {
    REQUEST_SUCCESS: "Request Success Count",
    REQUEST_FAILURE: "Request Failure Count",
    REQUEST_DURATION: "Request Duration",
    RETRY_COUNT: "Retry Count",
    THROTTLE_COUNT: "Throttle Count",
    EXCEPTION_COUNT: "Exception Count",
    ATTACH: "Attach",
    FEATURE: "Feature"
  };
  var StatsbeatFeature;
  (function (StatsbeatFeature) {
    StatsbeatFeature[StatsbeatFeature.NONE = 0] = "NONE", StatsbeatFeature[StatsbeatFeature.DISK_RETRY = 1] = "DISK_RETRY", StatsbeatFeature[StatsbeatFeature.AAD_HANDLING = 2] = "AAD_HANDLING", StatsbeatFeature[StatsbeatFeature.WEB_SNIPPET = 4] = "WEB_SNIPPET";
  })(StatsbeatFeature = exports.StatsbeatFeature || (exports.StatsbeatFeature = {}));
  var StatsbeatInstrumentation;
  (function (StatsbeatInstrumentation) {
    StatsbeatInstrumentation[StatsbeatInstrumentation.NONE = 0] = "NONE", StatsbeatInstrumentation[StatsbeatInstrumentation.AZURE_CORE_TRACING = 1] = "AZURE_CORE_TRACING", StatsbeatInstrumentation[StatsbeatInstrumentation.MONGODB = 2] = "MONGODB", StatsbeatInstrumentation[StatsbeatInstrumentation.MYSQL = 4] = "MYSQL", StatsbeatInstrumentation[StatsbeatInstrumentation.REDIS = 8] = "REDIS", StatsbeatInstrumentation[StatsbeatInstrumentation.POSTGRES = 16] = "POSTGRES", StatsbeatInstrumentation[StatsbeatInstrumentation.BUNYAN = 32] = "BUNYAN", StatsbeatInstrumentation[StatsbeatInstrumentation.WINSTON = 64] = "WINSTON", StatsbeatInstrumentation[StatsbeatInstrumentation.CONSOLE = 128] = "CONSOLE";
  })(StatsbeatInstrumentation = exports.StatsbeatInstrumentation || (exports.StatsbeatInstrumentation = {}));
  var StatsbeatFeatureType;
  (function (StatsbeatFeatureType) {
    StatsbeatFeatureType[StatsbeatFeatureType.Feature = 0] = "Feature", StatsbeatFeatureType[StatsbeatFeatureType.Instrumentation = 1] = "Instrumentation";
  })(StatsbeatFeatureType = exports.StatsbeatFeatureType || (exports.StatsbeatFeatureType = {}));
  var StatsbeatNetworkCategory;
  (function (StatsbeatNetworkCategory) {
    StatsbeatNetworkCategory[StatsbeatNetworkCategory.Breeze = 0] = "Breeze", StatsbeatNetworkCategory[StatsbeatNetworkCategory.Quickpulse = 1] = "Quickpulse";
  })(StatsbeatNetworkCategory = exports.StatsbeatNetworkCategory || (exports.StatsbeatNetworkCategory = {}));
  exports.AzNamespace = "az.namespace";
  exports.MicrosoftEventHub = "Microsoft.EventHub";
  exports.MessageBusDestination = "message_bus.destination";
  exports.ENQUEUED_TIME = "enqueuedTime";
  exports.TIME_SINCE_ENQUEUED = "timeSinceEnqueued";
  exports.WEB_INSTRUMENTATION_DEFAULT_SOURCE = "https://js.monitor.azure.com/scripts/b/ai";
  exports.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = "https://az416426.vo.msecnd.net/scripts/b/ai";
});
var JK = T(Kg => {
  "use strict";

  Object.defineProperty(Kg, "__esModule", {
    value: !0
  });
  Kg.dispose = Kg.enable = void 0;
  var Contracts_1 = Gl(),
    Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    subscriber = __name(function (event) {
      var message = event.data.message;
      clients.forEach(function (client) {
        message instanceof Error && !client.config.enableLoggerErrorToTrace ? client.trackException({
          exception: message
        }) : message instanceof Error ? client.trackTrace({
          message: message.toString(),
          severity: event.data.stderr ? Contracts_1.SeverityLevel.Error : Contracts_1.SeverityLevel.Information
        }) : (message.lastIndexOf(`
`) == message.length - 1 && (message = message.substring(0, message.length - 1)), client.trackTrace({
          message: message,
          severity: event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information
        }));
      });
    }, "subscriber");
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("console", subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.CONSOLE);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("console", subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
  function dispose() {
    diagnostic_channel_1.channel.unsubscribe("console", subscriber), clients = [];
  }
  __name(dispose, "dispose");
  exports.dispose = dispose;
});
var eX = T(Yg => {
  "use strict";

  Object.defineProperty(Yg, "__esModule", {
    value: !0
  });
  Yg.dispose = Yg.enable = void 0;
  var Contracts_1 = Gl(),
    Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    bunyanToAILevelMap = {
      10: Contracts_1.SeverityLevel.Verbose,
      20: Contracts_1.SeverityLevel.Verbose,
      30: Contracts_1.SeverityLevel.Information,
      40: Contracts_1.SeverityLevel.Warning,
      50: Contracts_1.SeverityLevel.Error,
      60: Contracts_1.SeverityLevel.Critical
    },
    subscriber = __name(function (event) {
      var message = event.data.result,
        AIlevel = bunyanToAILevelMap[event.data.level];
      clients.forEach(function (client) {
        try {
          var log = JSON.parse(message);
          if (log.err) {
            var bunyanError = new Error(log.err.message);
            if (bunyanError.name = log.err.name, bunyanError.stack = log.err.stack, client.config.enableLoggerErrorToTrace) {
              client.trackTrace({
                message: message,
                severity: AIlevel
              });
              return;
            }
            client.trackException({
              exception: bunyanError
            });
            return;
          }
        } catch {}
        client.trackTrace({
          message: message,
          severity: AIlevel
        });
      });
    }, "subscriber");
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("bunyan", subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.BUNYAN);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
  function dispose() {
    diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber), clients = [];
  }
  __name(dispose, "dispose");
  exports.dispose = dispose;
});
var tX = T(Qg => {
  "use strict";

  Object.defineProperty(Qg, "__esModule", {
    value: !0
  });
  Qg.dispose = Qg.enable = void 0;
  var Constants_1 = L0(),
    Contracts_1 = Gl(),
    diagnostic_channel_1 = N0(),
    clients = [],
    winstonToAILevelMap = {
      syslog: function (og) {
        var map = {
          emerg: Contracts_1.SeverityLevel.Critical,
          alert: Contracts_1.SeverityLevel.Critical,
          crit: Contracts_1.SeverityLevel.Critical,
          error: Contracts_1.SeverityLevel.Error,
          warning: Contracts_1.SeverityLevel.Warning,
          notice: Contracts_1.SeverityLevel.Information,
          info: Contracts_1.SeverityLevel.Information,
          debug: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      npm: function (og) {
        var map = {
          error: Contracts_1.SeverityLevel.Error,
          warn: Contracts_1.SeverityLevel.Warning,
          info: Contracts_1.SeverityLevel.Information,
          verbose: Contracts_1.SeverityLevel.Verbose,
          debug: Contracts_1.SeverityLevel.Verbose,
          silly: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      unknown: function (og) {
        return Contracts_1.SeverityLevel.Information;
      }
    },
    subscriber = __name(function (event) {
      var message = event.data.message,
        AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
      clients.forEach(function (client) {
        message instanceof Error && !client.config.enableLoggerErrorToTrace ? client.trackException({
          exception: message,
          properties: event.data.meta
        }) : message instanceof Error ? client.trackTrace({
          message: message.toString(),
          severity: AIlevel,
          properties: event.data.meta
        }) : client.trackTrace({
          message: message,
          severity: AIlevel,
          properties: event.data.meta
        });
      });
    }, "subscriber");
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("winston", subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.WINSTON);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
  function dispose() {
    diagnostic_channel_1.channel.unsubscribe("winston", subscriber), clients = [];
  }
  __name(dispose, "dispose");
  exports.dispose = dispose;
});
var nX = T((EQe, rX) => {
  "use strict";

  var DiagChannel = L9(),
    AutoCollectConsole = function () {
      function AutoCollectConsole(client) {
        if (AutoCollectConsole.INSTANCE) throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
        this._client = client, AutoCollectConsole.INSTANCE = this;
      }
      return __name(AutoCollectConsole, "AutoCollectConsole"), AutoCollectConsole.prototype.enable = function (isEnabled, collectConsoleLog) {
        DiagChannel.IsInitialized && (JK().enable(isEnabled && collectConsoleLog, this._client), eX().enable(isEnabled, this._client), tX().enable(isEnabled, this._client));
      }, AutoCollectConsole.prototype.isInitialized = function () {
        return this._isInitialized;
      }, AutoCollectConsole.prototype.dispose = function () {
        AutoCollectConsole.INSTANCE = null, this.enable(!1, !1);
      }, AutoCollectConsole._methodNames = ["debug", "info", "log", "warn", "error"], AutoCollectConsole;
    }();
  module.exports = AutoCollectConsole;
});
var sX = T((TQe, iX) => {
  "use strict";

  var AutoCollectExceptions = function () {
    function AutoCollectExceptions(client) {
      if (AutoCollectExceptions.INSTANCE) throw new Error("Exception tracking should be configured from the applicationInsights object");
      AutoCollectExceptions.INSTANCE = this, this._client = client;
      var nodeVer = process.versions.node.split(".");
      AutoCollectExceptions._canUseUncaughtExceptionMonitor = parseInt(nodeVer[0]) > 13 || parseInt(nodeVer[0]) === 13 && parseInt(nodeVer[1]) >= 7;
    }
    return __name(AutoCollectExceptions, "AutoCollectExceptions"), AutoCollectExceptions.prototype.isInitialized = function () {
      return this._isInitialized;
    }, AutoCollectExceptions.prototype.enable = function (isEnabled) {
      var _this = this;
      if (isEnabled) {
        if (this._isInitialized = !0, !this._exceptionListenerHandle) {
          var handle = __name(function (reThrow, name, error) {
            error === void 0 && (error = new Error(AutoCollectExceptions._FALLBACK_ERROR_MESSAGE));
            var exceptionTelemetry = {
              exception: error
            };
            exceptionTelemetry.contextObjects = {}, exceptionTelemetry.contextObjects.Error = error, _this._client.trackException(exceptionTelemetry), _this._client.flush({
              isAppCrashing: !0
            }), reThrow && name && process.listeners(name).length === 1 && (console.error(error), process.exit(1));
          }, "handle");
          AutoCollectExceptions._canUseUncaughtExceptionMonitor ? (this._exceptionListenerHandle = handle.bind(this, !1, void 0), process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle)) : (this._exceptionListenerHandle = handle.bind(this, !0, AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME), this._rejectionListenerHandle = handle.bind(this, !1, void 0), process.on(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.on(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle));
        }
      } else this._exceptionListenerHandle && (AutoCollectExceptions._canUseUncaughtExceptionMonitor ? process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle) : (process.removeListener(AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.removeListener(AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle)), this._exceptionListenerHandle = void 0, this._rejectionListenerHandle = void 0, delete this._exceptionListenerHandle, delete this._rejectionListenerHandle);
    }, AutoCollectExceptions.prototype.dispose = function () {
      AutoCollectExceptions.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
    }, AutoCollectExceptions.INSTANCE = null, AutoCollectExceptions.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = "uncaughtExceptionMonitor", AutoCollectExceptions.UNCAUGHT_EXCEPTION_HANDLER_NAME = "uncaughtException", AutoCollectExceptions.UNHANDLED_REJECTION_HANDLER_NAME = "unhandledRejection", AutoCollectExceptions._RETHROW_EXIT_MESSAGE = "Application Insights Rethrow Exception Handler", AutoCollectExceptions._FALLBACK_ERROR_MESSAGE = "A promise was rejected without providing an error. Application Insights generated this error stack for you.", AutoCollectExceptions._canUseUncaughtExceptionMonitor = !1, AutoCollectExceptions;
  }();
  module.exports = AutoCollectExceptions;
});
var b7 = T((wQe, oX) => {
  "use strict";

  var os = require("os"),
    Constants = L0(),
    AutoCollectPerformance = function () {
      function AutoCollectPerformance(client, collectionInterval, enableLiveMetricsCounters) {
        collectionInterval === void 0 && (collectionInterval = 6e4), enableLiveMetricsCounters === void 0 && (enableLiveMetricsCounters = !1), this._lastIntervalRequestExecutionTime = 0, this._lastIntervalDependencyExecutionTime = 0, AutoCollectPerformance.INSTANCE || (AutoCollectPerformance.INSTANCE = this), this._lastRequests = {
          totalRequestCount: 0,
          totalFailedRequestCount: 0,
          time: 0
        }, this._lastDependencies = {
          totalDependencyCount: 0,
          totalFailedDependencyCount: 0,
          time: 0
        }, this._lastExceptions = {
          totalExceptionCount: 0,
          time: 0
        }, this._isInitialized = !1, this._client = client, this._collectionInterval = collectionInterval, this._enableLiveMetricsCounters = enableLiveMetricsCounters;
      }
      return __name(AutoCollectPerformance, "AutoCollectPerformance"), AutoCollectPerformance.prototype.enable = function (isEnabled, collectionInterval) {
        var _this = this;
        this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), isEnabled ? this._handle || (this._lastCpus = os.cpus(), this._lastRequests = {
          totalRequestCount: AutoCollectPerformance._totalRequestCount,
          totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
          time: +new Date()
        }, this._lastDependencies = {
          totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
          totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
          time: +new Date()
        }, this._lastExceptions = {
          totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
          time: +new Date()
        }, typeof process.cpuUsage == "function" && (this._lastAppCpuUsage = process.cpuUsage()), this._lastHrtime = process.hrtime(), this._collectionInterval = collectionInterval || this._collectionInterval, this._handle = setInterval(function () {
          return _this.trackPerformance();
        }, this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), this._handle = void 0);
      }, AutoCollectPerformance.countRequest = function (duration, success) {
        var durationMs;
        if (AutoCollectPerformance.isEnabled()) {
          if (typeof duration == "string") durationMs = +new Date("1970-01-01T" + duration + "Z");else if (typeof duration == "number") durationMs = duration;else return;
          AutoCollectPerformance._intervalRequestExecutionTime += durationMs, success === !1 && AutoCollectPerformance._totalFailedRequestCount++, AutoCollectPerformance._totalRequestCount++;
        }
      }, AutoCollectPerformance.countException = function () {
        AutoCollectPerformance._totalExceptionCount++;
      }, AutoCollectPerformance.countDependency = function (duration, success) {
        var durationMs;
        if (AutoCollectPerformance.isEnabled()) {
          if (typeof duration == "string") durationMs = +new Date("1970-01-01T" + duration + "Z");else if (typeof duration == "number") durationMs = duration;else return;
          AutoCollectPerformance._intervalDependencyExecutionTime += durationMs, success === !1 && AutoCollectPerformance._totalFailedDependencyCount++, AutoCollectPerformance._totalDependencyCount++;
        }
      }, AutoCollectPerformance.prototype.isInitialized = function () {
        return this._isInitialized;
      }, AutoCollectPerformance.isEnabled = function () {
        return AutoCollectPerformance.INSTANCE && AutoCollectPerformance.INSTANCE._isEnabled;
      }, AutoCollectPerformance.prototype.trackPerformance = function () {
        this._trackCpu(), this._trackMemory(), this._trackNetwork(), this._trackDependencyRate(), this._trackExceptionRate();
      }, AutoCollectPerformance.prototype._trackCpu = function () {
        var cpus = os.cpus();
        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
          for (var totalUser = 0, totalSys = 0, totalNice = 0, totalIdle = 0, totalIrq = 0, i = 0; cpus && i < cpus.length; i++) {
            var cpu = cpus[i],
              lastCpu = this._lastCpus[i],
              name = "% cpu(" + i + ") ",
              model = cpu.model,
              speed = cpu.speed,
              times = cpu.times,
              lastTimes = lastCpu.times,
              user = times.user - lastTimes.user || 0;
            totalUser += user;
            var sys = times.sys - lastTimes.sys || 0;
            totalSys += sys;
            var nice = times.nice - lastTimes.nice || 0;
            totalNice += nice;
            var idle = times.idle - lastTimes.idle || 0;
            totalIdle += idle;
            var irq = times.irq - lastTimes.irq || 0;
            totalIrq += irq;
          }
          var appCpuPercent = void 0;
          if (typeof process.cpuUsage == "function") {
            var appCpuUsage = process.cpuUsage(),
              hrtime = process.hrtime(),
              totalApp = appCpuUsage.user - this._lastAppCpuUsage.user + (appCpuUsage.system - this._lastAppCpuUsage.system) || 0;
            if (typeof this._lastHrtime < "u" && this._lastHrtime.length === 2) {
              var elapsedTime = (hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3 || 0;
              appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);
            }
            this._lastAppCpuUsage = appCpuUsage, this._lastHrtime = hrtime;
          }
          var combinedTotal = totalUser + totalSys + totalNice + totalIdle + totalIrq || 1;
          this._client.trackMetric({
            name: Constants.PerformanceCounter.PROCESSOR_TIME,
            value: (combinedTotal - totalIdle) / combinedTotal * 100
          }), this._client.trackMetric({
            name: Constants.PerformanceCounter.PROCESS_TIME,
            value: appCpuPercent || totalUser / combinedTotal * 100
          });
        }
        this._lastCpus = cpus;
      }, AutoCollectPerformance.prototype._trackMemory = function () {
        var freeMem = os.freemem(),
          usedMem = process.memoryUsage().rss,
          committedMemory = os.totalmem() - freeMem;
        this._client.trackMetric({
          name: Constants.PerformanceCounter.PRIVATE_BYTES,
          value: usedMem
        }), this._client.trackMetric({
          name: Constants.PerformanceCounter.AVAILABLE_BYTES,
          value: freeMem
        }), this._enableLiveMetricsCounters && this._client.trackMetric({
          name: Constants.QuickPulseCounter.COMMITTED_BYTES,
          value: committedMemory
        });
      }, AutoCollectPerformance.prototype._trackNetwork = function () {
        var lastRequests = this._lastRequests,
          requests = {
            totalRequestCount: AutoCollectPerformance._totalRequestCount,
            totalFailedRequestCount: AutoCollectPerformance._totalFailedRequestCount,
            time: +new Date()
          },
          intervalRequests = requests.totalRequestCount - lastRequests.totalRequestCount || 0,
          intervalFailedRequests = requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount || 0,
          elapsedMs = requests.time - lastRequests.time,
          elapsedSeconds = elapsedMs / 1e3,
          averageRequestExecutionTime = (AutoCollectPerformance._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests || 0;
        if (this._lastIntervalRequestExecutionTime = AutoCollectPerformance._intervalRequestExecutionTime, elapsedMs > 0) {
          var requestsPerSec = intervalRequests / elapsedSeconds,
            failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
          this._client.trackMetric({
            name: Constants.PerformanceCounter.REQUEST_RATE,
            value: requestsPerSec
          }), (!this._enableLiveMetricsCounters || intervalRequests > 0) && this._client.trackMetric({
            name: Constants.PerformanceCounter.REQUEST_DURATION,
            value: averageRequestExecutionTime
          }), this._enableLiveMetricsCounters && this._client.trackMetric({
            name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE,
            value: failedRequestsPerSec
          });
        }
        this._lastRequests = requests;
      }, AutoCollectPerformance.prototype._trackDependencyRate = function () {
        if (this._enableLiveMetricsCounters) {
          var lastDependencies = this._lastDependencies,
            dependencies = {
              totalDependencyCount: AutoCollectPerformance._totalDependencyCount,
              totalFailedDependencyCount: AutoCollectPerformance._totalFailedDependencyCount,
              time: +new Date()
            },
            intervalDependencies = dependencies.totalDependencyCount - lastDependencies.totalDependencyCount || 0,
            intervalFailedDependencies = dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount || 0,
            elapsedMs = dependencies.time - lastDependencies.time,
            elapsedSeconds = elapsedMs / 1e3,
            averageDependencyExecutionTime = (AutoCollectPerformance._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies || 0;
          if (this._lastIntervalDependencyExecutionTime = AutoCollectPerformance._intervalDependencyExecutionTime, elapsedMs > 0) {
            var dependenciesPerSec = intervalDependencies / elapsedSeconds,
              failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
            this._client.trackMetric({
              name: Constants.QuickPulseCounter.DEPENDENCY_RATE,
              value: dependenciesPerSec
            }), this._client.trackMetric({
              name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
              value: failedDependenciesPerSec
            }), (!this._enableLiveMetricsCounters || intervalDependencies > 0) && this._client.trackMetric({
              name: Constants.QuickPulseCounter.DEPENDENCY_DURATION,
              value: averageDependencyExecutionTime
            });
          }
          this._lastDependencies = dependencies;
        }
      }, AutoCollectPerformance.prototype._trackExceptionRate = function () {
        if (this._enableLiveMetricsCounters) {
          var lastExceptions = this._lastExceptions,
            exceptions = {
              totalExceptionCount: AutoCollectPerformance._totalExceptionCount,
              time: +new Date()
            },
            intervalExceptions = exceptions.totalExceptionCount - lastExceptions.totalExceptionCount || 0,
            elapsedMs = exceptions.time - lastExceptions.time,
            elapsedSeconds = elapsedMs / 1e3;
          if (elapsedMs > 0) {
            var exceptionsPerSec = intervalExceptions / elapsedSeconds;
            this._client.trackMetric({
              name: Constants.QuickPulseCounter.EXCEPTION_RATE,
              value: exceptionsPerSec
            });
          }
          this._lastExceptions = exceptions;
        }
      }, AutoCollectPerformance.prototype.dispose = function () {
        AutoCollectPerformance.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
      }, AutoCollectPerformance._totalRequestCount = 0, AutoCollectPerformance._totalFailedRequestCount = 0, AutoCollectPerformance._totalDependencyCount = 0, AutoCollectPerformance._totalFailedDependencyCount = 0, AutoCollectPerformance._totalExceptionCount = 0, AutoCollectPerformance._intervalDependencyExecutionTime = 0, AutoCollectPerformance._intervalRequestExecutionTime = 0, AutoCollectPerformance;
    }();
  module.exports = AutoCollectPerformance;
});
var aX = T(E7 => {
  "use strict";

  Object.defineProperty(E7, "__esModule", {
    value: !0
  });
  E7.AggregatedMetricCounter = void 0;
  var AggregatedMetricCounter = function () {
    function AggregatedMetricCounter(dimensions) {
      this.dimensions = dimensions, this.totalCount = 0, this.lastTotalCount = 0, this.intervalExecutionTime = 0, this.lastTime = +new Date(), this.lastIntervalExecutionTime = 0;
    }
    return __name(AggregatedMetricCounter, "AggregatedMetricCounter"), AggregatedMetricCounter;
  }();
  exports.AggregatedMetricCounter = AggregatedMetricCounter;
});
var lX = T(C7 => {
  "use strict";

  Object.defineProperty(C7, "__esModule", {
    value: !0
  });
  C7.PreaggregatedMetricPropertyNames = void 0;
  exports.PreaggregatedMetricPropertyNames = {
    cloudRoleInstance: "cloud/roleInstance",
    cloudRoleName: "cloud/roleName",
    operationSynthetic: "operation/synthetic",
    requestSuccess: "Request.Success",
    requestResultCode: "request/resultCode",
    dependencyType: "Dependency.Type",
    dependencyTarget: "dependency/target",
    dependencySuccess: "Dependency.Success",
    dependencyResultCode: "dependency/resultCode",
    traceSeverityLevel: "trace/severityLevel"
  };
});
var oR = T((sR, cX) => {
  "use strict";

  var S7 = sR && sR.__assign || function () {
      return S7 = Object.assign || function (e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
          t = arguments[r];
          for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }, S7.apply(this, arguments);
    },
    Constants = L0(),
    AggregatedMetricCounters_1 = aX(),
    AggregatedMetricDimensions_1 = lX(),
    AutoCollectPreAggregatedMetrics = function () {
      function AutoCollectPreAggregatedMetrics(client, collectionInterval) {
        collectionInterval === void 0 && (collectionInterval = 6e4), AutoCollectPreAggregatedMetrics.INSTANCE || (AutoCollectPreAggregatedMetrics.INSTANCE = this), this._isInitialized = !1, AutoCollectPreAggregatedMetrics._dependencyCountersCollection = [], AutoCollectPreAggregatedMetrics._requestCountersCollection = [], AutoCollectPreAggregatedMetrics._exceptionCountersCollection = [], AutoCollectPreAggregatedMetrics._traceCountersCollection = [], this._client = client, this._collectionInterval = collectionInterval;
      }
      return __name(AutoCollectPreAggregatedMetrics, "AutoCollectPreAggregatedMetrics"), AutoCollectPreAggregatedMetrics.prototype.enable = function (isEnabled, collectionInterval) {
        var _this = this;
        this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), isEnabled ? this._handle || (this._collectionInterval = collectionInterval || this._collectionInterval, this._handle = setInterval(function () {
          return _this.trackPreAggregatedMetrics();
        }, this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), this._handle = void 0);
      }, AutoCollectPreAggregatedMetrics.countException = function (dimensions) {
        if (AutoCollectPreAggregatedMetrics.isEnabled()) {
          var counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._exceptionCountersCollection);
          counter.totalCount++;
        }
      }, AutoCollectPreAggregatedMetrics.countTrace = function (dimensions) {
        if (AutoCollectPreAggregatedMetrics.isEnabled()) {
          var counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._traceCountersCollection);
          counter.totalCount++;
        }
      }, AutoCollectPreAggregatedMetrics.countRequest = function (duration, dimensions) {
        if (AutoCollectPreAggregatedMetrics.isEnabled()) {
          var durationMs,
            counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._requestCountersCollection);
          if (typeof duration == "string") durationMs = +new Date("1970-01-01T" + duration + "Z");else if (typeof duration == "number") durationMs = duration;else return;
          counter.intervalExecutionTime += durationMs, counter.totalCount++;
        }
      }, AutoCollectPreAggregatedMetrics.countDependency = function (duration, dimensions) {
        if (AutoCollectPreAggregatedMetrics.isEnabled()) {
          var counter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._dependencyCountersCollection),
            durationMs;
          if (typeof duration == "string") durationMs = +new Date("1970-01-01T" + duration + "Z");else if (typeof duration == "number") durationMs = duration;else return;
          counter.intervalExecutionTime += durationMs, counter.totalCount++;
        }
      }, AutoCollectPreAggregatedMetrics.prototype.isInitialized = function () {
        return this._isInitialized;
      }, AutoCollectPreAggregatedMetrics.isEnabled = function () {
        return AutoCollectPreAggregatedMetrics.INSTANCE && AutoCollectPreAggregatedMetrics.INSTANCE._isEnabled;
      }, AutoCollectPreAggregatedMetrics.prototype.trackPreAggregatedMetrics = function () {
        this._trackRequestMetrics(), this._trackDependencyMetrics(), this._trackExceptionMetrics(), this._trackTraceMetrics();
      }, AutoCollectPreAggregatedMetrics._getAggregatedCounter = function (dimensions, counterCollection) {
        for (var notMatch = !1, i = 0; i < counterCollection.length; i++) {
          if (dimensions === counterCollection[i].dimensions) return counterCollection[i];
          if (Object.keys(dimensions).length === Object.keys(counterCollection[i].dimensions).length) {
            for (var dim in dimensions) if (dimensions[dim] != counterCollection[i].dimensions[dim]) {
              notMatch = !0;
              break;
            }
            if (!notMatch) return counterCollection[i];
            notMatch = !1;
          }
        }
        var newCounter = new AggregatedMetricCounters_1.AggregatedMetricCounter(dimensions);
        return counterCollection.push(newCounter), newCounter;
      }, AutoCollectPreAggregatedMetrics.prototype._trackRequestMetrics = function () {
        for (var i = 0; i < AutoCollectPreAggregatedMetrics._requestCountersCollection.length; i++) {
          var currentCounter = AutoCollectPreAggregatedMetrics._requestCountersCollection[i];
          currentCounter.time = +new Date();
          var intervalRequests = currentCounter.totalCount - currentCounter.lastTotalCount || 0,
            elapsedMs = currentCounter.time - currentCounter.lastTime,
            averageRequestExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalRequests || 0;
          currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime, elapsedMs > 0 && intervalRequests > 0 && this._trackPreAggregatedMetric({
            name: "Server response time",
            dimensions: currentCounter.dimensions,
            value: averageRequestExecutionTime,
            count: intervalRequests,
            aggregationInterval: elapsedMs,
            metricType: Constants.MetricId.REQUESTS_DURATION
          }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
        }
      }, AutoCollectPreAggregatedMetrics.prototype._trackDependencyMetrics = function () {
        for (var i = 0; i < AutoCollectPreAggregatedMetrics._dependencyCountersCollection.length; i++) {
          var currentCounter = AutoCollectPreAggregatedMetrics._dependencyCountersCollection[i];
          currentCounter.time = +new Date();
          var intervalDependencies = currentCounter.totalCount - currentCounter.lastTotalCount || 0,
            elapsedMs = currentCounter.time - currentCounter.lastTime,
            averageDependencyExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalDependencies || 0;
          currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime, elapsedMs > 0 && intervalDependencies > 0 && this._trackPreAggregatedMetric({
            name: "Dependency duration",
            dimensions: currentCounter.dimensions,
            value: averageDependencyExecutionTime,
            count: intervalDependencies,
            aggregationInterval: elapsedMs,
            metricType: Constants.MetricId.DEPENDENCIES_DURATION
          }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
        }
      }, AutoCollectPreAggregatedMetrics.prototype._trackExceptionMetrics = function () {
        for (var i = 0; i < AutoCollectPreAggregatedMetrics._exceptionCountersCollection.length; i++) {
          var currentCounter = AutoCollectPreAggregatedMetrics._exceptionCountersCollection[i];
          currentCounter.time = +new Date();
          var intervalExceptions = currentCounter.totalCount - currentCounter.lastTotalCount || 0,
            elapsedMs = currentCounter.time - currentCounter.lastTime;
          elapsedMs > 0 && intervalExceptions > 0 && this._trackPreAggregatedMetric({
            name: "Exceptions",
            dimensions: currentCounter.dimensions,
            value: intervalExceptions,
            count: intervalExceptions,
            aggregationInterval: elapsedMs,
            metricType: Constants.MetricId.EXCEPTIONS_COUNT
          }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
        }
      }, AutoCollectPreAggregatedMetrics.prototype._trackTraceMetrics = function () {
        for (var i = 0; i < AutoCollectPreAggregatedMetrics._traceCountersCollection.length; i++) {
          var currentCounter = AutoCollectPreAggregatedMetrics._traceCountersCollection[i];
          currentCounter.time = +new Date();
          var intervalTraces = currentCounter.totalCount - currentCounter.lastTotalCount || 0,
            elapsedMs = currentCounter.time - currentCounter.lastTime;
          elapsedMs > 0 && intervalTraces > 0 && this._trackPreAggregatedMetric({
            name: "Traces",
            dimensions: currentCounter.dimensions,
            value: intervalTraces,
            count: intervalTraces,
            aggregationInterval: elapsedMs,
            metricType: Constants.MetricId.TRACES_COUNT
          }), currentCounter.lastTotalCount = currentCounter.totalCount, currentCounter.lastTime = currentCounter.time;
        }
      }, AutoCollectPreAggregatedMetrics.prototype._trackPreAggregatedMetric = function (metric) {
        var metricProperties = {};
        for (var dim in metric.dimensions) metricProperties[AggregatedMetricDimensions_1.PreaggregatedMetricPropertyNames[dim]] = metric.dimensions[dim];
        metricProperties = __assign(__assign({}, metricProperties), {
          "_MS.MetricId": metric.metricType,
          "_MS.AggregationIntervalMs": String(metric.aggregationInterval),
          "_MS.IsAutocollected": "True"
        });
        var telemetry = {
          name: metric.name,
          value: metric.value,
          count: metric.count,
          properties: metricProperties,
          kind: "Aggregation"
        };
        this._client.trackMetric(telemetry);
      }, AutoCollectPreAggregatedMetrics.prototype.dispose = function () {
        AutoCollectPreAggregatedMetrics.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
      }, AutoCollectPreAggregatedMetrics;
    }();
  module.exports = AutoCollectPreAggregatedMetrics;
});
var Zg = T((OQe, uX) => {
  "use strict";

  var os = require("os"),
    fs = require("fs"),
    path = require("path"),
    Contracts = Gl(),
    Constants_1 = L0(),
    Logging = x0(),
    Context = function () {
      function Context(packageJsonPath) {
        this.keys = new Contracts.ContextTagKeys(), this.tags = {}, this._loadApplicationContext(packageJsonPath), this._loadDeviceContext(), this._loadInternalContext();
      }
      return __name(Context, "Context"), Context.prototype._loadApplicationContext = function (packageJsonPath) {
        try {
          if (packageJsonPath = packageJsonPath || path.resolve(__dirname, "../../../../package.json"), !Context.appVersion[packageJsonPath]) {
            Context.appVersion[packageJsonPath] = "unknown";
            var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
            packageJson && typeof packageJson.version == "string" && (Context.appVersion[packageJsonPath] = packageJson.version);
          }
          this.tags[this.keys.applicationVersion] = Context.appVersion[packageJsonPath];
        } catch (exception) {
          Logging.info("Failed to read app version: ", exception);
        }
      }, Context.prototype._loadDeviceContext = function () {
        var cloudRoleInstance = os && os.hostname(),
          cloudRole = Context.DefaultRoleName;
        process.env.WEBSITE_SITE_NAME && (cloudRole = process.env.WEBSITE_SITE_NAME), process.env.WEBSITE_INSTANCE_ID && (cloudRoleInstance = process.env.WEBSITE_INSTANCE_ID), this.tags[this.keys.deviceId] = "", this.tags[this.keys.cloudRoleInstance] = cloudRoleInstance, this.tags[this.keys.deviceOSVersion] = os && os.type() + " " + os.release(), this.tags[this.keys.cloudRole] = cloudRole, this.tags["ai.device.osArchitecture"] = os && os.arch(), this.tags["ai.device.osPlatform"] = os && os.platform();
      }, Context.prototype._loadInternalContext = function () {
        Context.sdkVersion = Constants_1.APPLICATION_INSIGHTS_SDK_VERSION, this.tags[this.keys.internalSdkVersion] = "node:" + Context.sdkVersion;
      }, Context.DefaultRoleName = "Web", Context.appVersion = {}, Context.sdkVersion = null, Context;
    }();
  module.exports = Context;
});
var pX = T((kQe, dX) => {
  "use strict";

  var crypto = require("crypto"),
    os = require("os"),
    Constants = L0(),
    Context = Zg(),
    HeartBeat = function () {
      function HeartBeat(client) {
        this._collectionInterval = 9e5, HeartBeat.INSTANCE || (HeartBeat.INSTANCE = this), this._isInitialized = !1, this._client = client;
      }
      return __name(HeartBeat, "HeartBeat"), HeartBeat.prototype.enable = function (isEnabled) {
        var _this = this;
        this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), isEnabled ? this._handle || (this._handle = setInterval(function () {
          return _this.trackHeartBeat(_this._client.config, function () {});
        }, this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), this._handle = null);
      }, HeartBeat.prototype.isInitialized = function () {
        return this._isInitialized;
      }, HeartBeat.isEnabled = function () {
        return HeartBeat.INSTANCE && HeartBeat.INSTANCE._isEnabled;
      }, HeartBeat.prototype.trackHeartBeat = function (config, callback) {
        var properties = {},
          sdkVersion = Context.sdkVersion;
        properties.sdkVersion = sdkVersion, properties.osType = os.type(), properties.osVersion = os.release(), this._uniqueProcessId || (this._uniqueProcessId = crypto.randomBytes(16).toString("hex")), properties.processSessionId = this._uniqueProcessId, process.env.WEBSITE_SITE_NAME && (properties.appSrv_SiteName = process.env.WEBSITE_SITE_NAME), process.env.WEBSITE_HOME_STAMPNAME && (properties.appSrv_wsStamp = process.env.WEBSITE_HOME_STAMPNAME), process.env.WEBSITE_HOSTNAME && (properties.appSrv_wsHost = process.env.WEBSITE_HOSTNAME), process.env.WEBSITE_OWNER_NAME && (properties.appSrv_wsOwner = process.env.WEBSITE_OWNER_NAME), process.env.WEBSITE_RESOURCE_GROUP && (properties.appSrv_ResourceGroup = process.env.WEBSITE_RESOURCE_GROUP), process.env.WEBSITE_SLOT_NAME && (properties.appSrv_SlotName = process.env.WEBSITE_SLOT_NAME), this._client.trackMetric({
          name: Constants.HeartBeatMetricName,
          value: 0,
          properties: properties
        }), callback();
      }, HeartBeat.prototype.dispose = function () {
        HeartBeat.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
      }, HeartBeat;
    }();
  module.exports = HeartBeat;
});
var mX = T(zs => {
  "use strict";

  Object.defineProperty(zs, "__esModule", {
    value: !0
  });
  zs.isContentTypeHeaderHtml = zs.insertSnippetByIndex = zs.getContentEncodingFromHeaders = zs.isSupportedContentEncoding = zs.findBufferEncodingType = zs.isBufferType = zs.getBrotliDecompressSync = zs.getBrotliDecompressAsync = zs.getBrotliCompressSync = zs.getBrotliCompressAsync = zs.inflateAsync = zs.deflateAsync = zs.gunzipAsync = zs.gzipAsync = zs.isBrotliSupperted = zs.bufferEncodingTypes = zs.contentEncodingMethod = void 0;
  var zlib = require("zlib"),
    util_1 = require("util"),
    contentEncodingMethod;
  (function (contentEncodingMethod) {
    contentEncodingMethod.GZIP = "gzip", contentEncodingMethod.DEFLATE = "deflate", contentEncodingMethod.BR = "br";
  })(contentEncodingMethod = exports.contentEncodingMethod || (exports.contentEncodingMethod = {}));
  exports.bufferEncodingTypes = ["utf8", "utf16le", "latin1", "base64", "hex", "ascii", "binary", "ucs2"];
  var isBrotliSupperted = __name(function () {
    var majVer = process.versions.node.split(".")[0];
    return parseInt(majVer) >= 10;
  }, "isBrotliSupperted");
  exports.isBrotliSupperted = isBrotliSupperted;
  exports.gzipAsync = util_1.promisify(zlib.gzip);
  exports.gunzipAsync = util_1.promisify(zlib.gunzip);
  exports.deflateAsync = util_1.promisify(zlib.deflate);
  exports.inflateAsync = util_1.promisify(zlib.inflate);
  var getBrotliCompressAsync = __name(function (zlibObject) {
    var isMajorVer = exports.isBrotliSupperted();
    return isMajorVer && typeof zlibObject.brotliCompress == "function" ? util_1.promisify(zlibObject.brotliCompress) : null;
  }, "getBrotliCompressAsync");
  exports.getBrotliCompressAsync = getBrotliCompressAsync;
  var getBrotliCompressSync = __name(function (zlibObject) {
    var isMajorVer = exports.isBrotliSupperted();
    return isMajorVer && typeof zlibObject.brotliCompressSync == "function" ? zlibObject.brotliCompressSync : null;
  }, "getBrotliCompressSync");
  exports.getBrotliCompressSync = getBrotliCompressSync;
  var getBrotliDecompressAsync = __name(function (zlibObject) {
    var isMajorVer = exports.isBrotliSupperted();
    return isMajorVer && typeof zlibObject.brotliDecompress == "function" ? util_1.promisify(zlibObject.brotliDecompress) : null;
  }, "getBrotliDecompressAsync");
  exports.getBrotliDecompressAsync = getBrotliDecompressAsync;
  var getBrotliDecompressSync = __name(function (zlibObject) {
    var isMajorVer = exports.isBrotliSupperted();
    return isMajorVer && typeof zlibObject.brotliDecompressSync == "function" ? zlibObject.brotliDecompressSync : null;
  }, "getBrotliDecompressSync");
  exports.getBrotliDecompressSync = getBrotliDecompressSync;
  var isBufferType = __name(function (buffer, type) {
    var encodingType = type || "utf8",
      result = !1;
    if (Buffer.isEncoding(encodingType)) {
      var newBuffer = Buffer.from(buffer.toString(encodingType), encodingType);
      result = newBuffer.toJSON().data.toString() === buffer.toJSON().data.toString();
    }
    return result;
  }, "isBufferType");
  exports.isBufferType = isBufferType;
  var findBufferEncodingType = __name(function (buffer) {
    var bufferType = null;
    for (var key in exports.bufferEncodingTypes) {
      var type = exports.bufferEncodingTypes[key];
      if (Buffer.isEncoding(type) && exports.isBufferType(buffer, type)) {
        bufferType = type;
        break;
      }
    }
    return bufferType;
  }, "findBufferEncodingType");
  exports.findBufferEncodingType = findBufferEncodingType;
  var isSupportedContentEncoding = __name(function (encodingMethod) {
    var encodingType = null;
    switch (encodingMethod) {
      case "gzip":
        encodingType = contentEncodingMethod.GZIP;
        break;
      case "br":
        encodingType = contentEncodingMethod.BR;
        break;
      case "deflate":
        encodingType = contentEncodingMethod.DEFLATE;
        break;
      default:
    }
    return encodingType;
  }, "isSupportedContentEncoding");
  exports.isSupportedContentEncoding = isSupportedContentEncoding;
  var getContentEncodingFromHeaders = __name(function (response) {
    var headers = [],
      contentEncodingHeaders = response.getHeader("Content-Encoding");
    if (!contentEncodingHeaders) return null;
    if (typeof contentEncodingHeaders == "string") {
      var supportedContentEncoding = exports.isSupportedContentEncoding(contentEncodingHeaders);
      supportedContentEncoding && headers.push(supportedContentEncoding);
    }
    return headers;
  }, "getContentEncodingFromHeaders");
  exports.getContentEncodingFromHeaders = getContentEncodingFromHeaders;
  var insertSnippetByIndex = __name(function (index, html, snippet) {
    if (index < 0) return null;
    var newHtml = null,
      subStart = html.substring(0, index),
      subEnd = html.substring(index);
    return newHtml = subStart + '<script type="text/javascript">' + snippet + "</script>" + subEnd, newHtml;
  }, "insertSnippetByIndex");
  exports.insertSnippetByIndex = insertSnippetByIndex;
  var isContentTypeHeaderHtml = __name(function (response) {
    var isHtml = !1,
      contentType = response.getHeader("Content-Type");
    return contentType && (typeof contentType == "string" ? isHtml = contentType.indexOf("html") >= 0 : isHtml = contentType.toString().indexOf("html") >= 0), isHtml;
  }, "isContentTypeHeaderHtml");
  exports.isContentTypeHeaderHtml = isContentTypeHeaderHtml;
});
var hX = T(sl => {
  "use strict";

  Object.defineProperty(sl, "__esModule", {
    value: !0
  });
  sl.getResourceProvider = sl.getOsPrefix = sl.isFunctionApp = sl.isWebApp = sl.isLinux = sl.isWindows = void 0;
  var isWindows = __name(function () {
    return process.platform === "win32";
  }, "isWindows");
  exports.isWindows = isWindows;
  var isLinux = __name(function () {
    return process.platform === "linux";
  }, "isLinux");
  exports.isLinux = isLinux;
  var isWebApp = __name(function () {
    return !!process.env.WEBSITE_SITE_NAME;
  }, "isWebApp");
  exports.isWebApp = isWebApp;
  var isFunctionApp = __name(function () {
    return !!process.env.FUNCTIONS_WORKER_RUNTIME;
  }, "isFunctionApp");
  exports.isFunctionApp = isFunctionApp;
  var getOsPrefix = __name(function () {
    return exports.isWindows() ? "w" : exports.isLinux() ? "l" : "u";
  }, "getOsPrefix");
  exports.getOsPrefix = getOsPrefix;
  var getResourceProvider = __name(function () {
    return exports.isWebApp() ? "a" : exports.isFunctionApp() ? "f" : "u";
  }, "getResourceProvider");
  exports.getResourceProvider = getResourceProvider;
});
var aR = T((qQe, _X) => {
  "use strict";

  var Constants = L0(),
    ConnectionStringParser = function () {
      function ConnectionStringParser() {}
      return __name(ConnectionStringParser, "ConnectionStringParser"), ConnectionStringParser.parse = function (connectionString) {
        if (!connectionString) return {};
        var kvPairs = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR),
          result = kvPairs.reduce(function (fields, kv) {
            var kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
              var key = kvParts[0].toLowerCase(),
                value = kvParts[1];
              fields[key] = value;
            }
            return fields;
          }, {});
        if (Object.keys(result).length > 0) {
          if (result.endpointsuffix) {
            var locationPrefix = result.location ? result.location + "." : "";
            result.ingestionendpoint = result.ingestionendpoint || "https://" + locationPrefix + "dc." + result.endpointsuffix, result.liveendpoint = result.liveendpoint || "https://" + locationPrefix + "live." + result.endpointsuffix;
          }
          result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT, result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;
        }
        return result;
      }, ConnectionStringParser.isIkeyValid = function (iKey) {
        if (!iKey || iKey == "") return !1;
        var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
          regexp = new RegExp(UUID_Regex);
        return regexp.test(iKey);
      }, ConnectionStringParser._FIELDS_SEPARATOR = ";", ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR = "=", ConnectionStringParser;
    }();
  module.exports = ConnectionStringParser;
});
var require_applicationinsights_web_snippet = __commonJSMin((exports, module) => {
  (function (global, factory) {
    typeof exports == "object" && typeof module < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis < "u" ? globalThis : global || self, factory((global.Microsoft = global.Microsoft || {}, global.Microsoft["ApplicationInsights-Web-Snippet"] = global.Microsoft["ApplicationInsights-Web-Snippet"] || {})));
  })(exports, function (exports) {
    "use strict";

    var webSnippet = `!function(T,l,y){var S=T.location,k="script",D="instrumentationKey",C="ingestionendpoint",I="disableExceptionTracking",E="ai.device.",b="toLowerCase",w="crossOrigin",N="POST",e="appInsightsSDK",t=y.name||"appInsights";(y.name||T[e])&&(T[e]=t);var n=T[t]||function(d){var g=!1,f=!1,m={initialize:!0,queue:[],sv:"5",version:2,config:d};function v(e,t){var n={},a="Browser";return n[E+"id"]=a[b](),n[E+"type"]=a,n["ai.operation.name"]=S&&S.pathname||"_unknown_",n["ai.internal.sdkVersion"]="javascript:snippet_"+(m.sv||m.version),{time:function(){var e=new Date;function t(e){var t=""+e;return 1===t.length&&(t="0"+t),t}return e.getUTCFullYear()+"-"+t(1+e.getUTCMonth())+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+((e.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),iKey:e,name:"Microsoft.ApplicationInsights."+e.replace(/-/g,"")+"."+t,sampleRate:100,tags:n,data:{baseData:{ver:2}}}}var h=d.url||y.src;if(h){function a(e){var t,n,a,i,r,o,s,c,u,p,l;g=!0,m.queue=[],f||(f=!0,t=h,s=function(){var e={},t=d.connectionString;if(t)for(var n=t.split(";"),a=0;a<n.length;a++){var i=n[a].split("=");2===i.length&&(e[i[0][b]()]=i[1])}if(!e[C]){var r=e.endpointsuffix,o=r?e.location:null;e[C]="https://"+(o?o+".":"")+"dc."+(r||"services.visualstudio.com")}return e}(),c=s[D]||d[D]||"",u=s[C],p=u?u+"/v2/track":d.endpointUrl,(l=[]).push((n="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",a=t,i=p,(o=(r=v(c,"Exception")).data).baseType="ExceptionData",o.baseData.exceptions=[{typeName:"SDKLoadFailed",message:n.replace(/\\./g,"-"),hasFullStack:!1,stack:n+"\\nSnippet failed to load ["+a+"] -- Telemetry is disabled\\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\\nHost: "+(S&&S.pathname||"_unknown_")+"\\nEndpoint: "+i,parsedStack:[]}],r)),l.push(function(e,t,n,a){var i=v(c,"Message"),r=i.data;r.baseType="MessageData";var o=r.baseData;return o.message='AI (Internal): 99 message:"'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+n+")").replace(/\\"/g,"")+'"',o.properties={endpoint:a},i}(0,0,t,p)),function(e,t){if(JSON){var n=T.fetch;if(n&&!y.useXhr)n(t,{method:N,body:JSON.stringify(e),mode:"cors"});else if(XMLHttpRequest){var a=new XMLHttpRequest;a.open(N,t),a.setRequestHeader("Content-type","application/json"),a.send(JSON.stringify(e))}}}(l,p))}function i(e,t){f||setTimeout(function(){!t&&m.core||a()},500)}var e=function(){var n=l.createElement(k);n.src=h;var e=y[w];return!e&&""!==e||"undefined"==n[w]||(n[w]=e),n.onload=i,n.onerror=a,n.onreadystatechange=function(e,t){"loaded"!==n.readyState&&"complete"!==n.readyState||i(0,t)},n}();y.ld<0?l.getElementsByTagName("head")[0].appendChild(e):setTimeout(function(){l.getElementsByTagName(k)[0].parentNode.appendChild(e)},y.ld||0)}try{m.cookie=l.cookie}catch(p){}function t(e){for(;e.length;)!function(t){m[t]=function(){var e=arguments;g||m.queue.push(function(){m[t].apply(m,e)})}}(e.pop())}var n="track",r="TrackPage",o="TrackEvent";t([n+"Event",n+"PageView",n+"Exception",n+"Trace",n+"DependencyData",n+"Metric",n+"PageViewPerformance","start"+r,"stop"+r,"start"+o,"stop"+o,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),m.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4};var s=(d.extensionConfig||{}).ApplicationInsightsAnalytics||{};if(!0!==d[I]&&!0!==s[I]){var c="onerror";t(["_"+c]);var u=T[c];T[c]=function(e,t,n,a,i){var r=u&&u(e,t,n,a,i);return!0!==r&&m["_"+c]({message:e,url:t,lineNumber:n,columnNumber:a,error:i}),r},d.autoExceptionInstrumented=!0}return m}(y.cfg);function a(){y.onInit&&y.onInit(n)}(T[t]=n).queue&&0===n.queue.length?(n.queue.push(a),n.trackPageView({})):a()}(window,document,{\r
src: "https://js.monitor.azure.com/scripts/b/ai.2.min.js", // The SDK URL Source\r
// name: "appInsights", // Global SDK Instance name defaults to "appInsights" when not supplied\r
// ld: 0, // Defines the load delay (in ms) before attempting to load the sdk. -1 = block page load and add to head. (default) = 0ms load after timeout,\r
// useXhr: 1, // Use XHR instead of fetch to report failures (if available),\r
// crossOrigin: "anonymous", // When supplied this will add the provided value as the cross origin attribute on the script tag\r
// onInit: null, // Once the application insights instance has loaded and initialized this callback function will be called with 1 argument -- the sdk instance (DO NOT ADD anything to the sdk.queue -- As they won't get called)\r
cfg: { // Application Insights Configuration\r
    instrumentationKey: "INSTRUMENTATION_KEY"\r
}});`;
    exports.webSnippet = webSnippet, Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  });
});
var SX = T((HQe, TX) => {
  "use strict";

  var http = require("http"),
    https = require("https"),
    zlib = require("zlib"),
    Logging = x0(),
    snippetInjectionHelper = mX(),
    prefixHelper = hX(),
    Constants = L0(),
    ConnectionStringParser = aR(),
    applicationinsights_web_snippet_1 = vX(),
    WebSnippet = function () {
      function WebSnippet(client) {
        var r;
        if (this._isIkeyValid = !0, WebSnippet.INSTANCE) throw new Error("Web snippet injection should be configured from the applicationInsights object");
        WebSnippet.INSTANCE = this, WebSnippet._aiUrl = Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE, WebSnippet._aiDeprecatedUrl = Constants.WEB_INSTRUMENTATION_DEPRECATED_SOURCE;
        var clientWebIkey = this._getWebSnippetIkey((_a = client.config) === null || _a === void 0 ? void 0 : _a.webInstrumentationConnectionString);
        this._webInstrumentationIkey = clientWebIkey || client.config.instrumentationKey, this._clientWebInstrumentationConfig = client.config.webInstrumentationConfig, this._clientWebInstrumentationSrc = client.config.webInstrumentationSrc, this._statsbeat = client.getStatsbeat();
      }
      return __name(WebSnippet, "WebSnippet"), WebSnippet.prototype.enable = function (isEnabled, webInstrumentationConnectionString) {
        this._isEnabled = isEnabled, this._webInstrumentationIkey = this._getWebSnippetIkey(webInstrumentationConnectionString) || this._webInstrumentationIkey, WebSnippet._snippet = this._getWebInstrumentationReplacedStr(), this._isEnabled && !this._isInitialized && this._isIkeyValid ? (this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.WEB_SNIPPET), this._initialize()) : this._isEnabled || this._statsbeat && this._statsbeat.removeFeature(Constants.StatsbeatFeature.WEB_SNIPPET);
      }, WebSnippet.prototype.isInitialized = function () {
        return this._isInitialized;
      }, WebSnippet.prototype._getWebSnippetIkey = function (connectionString) {
        var iKey = null;
        try {
          var csCode = ConnectionStringParser.parse(connectionString),
            iKeyCode = csCode.instrumentationkey || "";
          ConnectionStringParser.isIkeyValid(iKeyCode) ? (this._isIkeyValid = !0, iKey = iKeyCode) : (this._isIkeyValid = !1, Logging.info("Invalid web Instrumentation connection string, web Instrumentation is not enabled."));
        } catch (err) {
          Logging.info("get web snippet ikey error: " + err);
        }
        return iKey;
      }, WebSnippet.prototype._getWebInstrumentationReplacedStr = function () {
        var configStr = this._getClientWebInstrumentationConfigStr(this._clientWebInstrumentationConfig),
          osStr = prefixHelper.getOsPrefix(),
          rpStr = prefixHelper.getResourceProvider(),
          snippetReplacedStr = this._webInstrumentationIkey + `",\r
` + configStr + ` disableIkeyDeprecationMessage: true,\r
 sdkExtension: "` + rpStr + osStr + "d_n_",
          replacedSnippet = applicationinsights_web_snippet_1.webSnippet.replace("INSTRUMENTATION_KEY", snippetReplacedStr);
        return this._clientWebInstrumentationSrc ? replacedSnippet.replace(Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE + ".2.min.js", this._clientWebInstrumentationSrc) : replacedSnippet;
      }, WebSnippet.prototype._getClientWebInstrumentationConfigStr = function (config) {
        var configStr = "";
        try {
          config != null && config.length > 0 && config.forEach(function (item) {
            var key = item.name;
            if (key !== void 0) {
              var val = item.value,
                entry = "";
              switch (typeof val) {
                case "function":
                  break;
                case "object":
                  break;
                case "string":
                  entry = " " + key + ': "' + val + `",\r
`, configStr += entry;
                  break;
                default:
                  entry = " " + key + ": " + val + `,\r
`, configStr += entry;
                  break;
              }
            }
          });
        } catch {
          this._isEnabled = !1, Logging.info("Parse client web instrumentation error. Web Instrumentation is disabled");
        }
        return configStr;
      }, WebSnippet.prototype._initialize = function () {
        this._isInitialized = !0;
        var originalHttpServer = http.createServer,
          originalHttpsServer = https.createServer,
          isEnabled = this._isEnabled;
        http.createServer = function (requestListener) {
          var originalRequestListener = requestListener;
          return originalRequestListener && (requestListener = __name(function (request, response) {
            var originalResponseWrite = response.write,
              isGetRequest = request.method == "GET";
            response.write = __name(function (a, b, c) {
              try {
                if (isEnabled && isGetRequest) {
                  var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response),
                    writeBufferType = void 0;
                  if (typeof b == "string" && (writeBufferType = b), headers == null) WebSnippet.INSTANCE.ValidateInjection(response, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, void 0, writeBufferType));else if (headers.length) {
                    var encodeType = headers[0];
                    arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, encodeType);
                  }
                }
              } catch (err) {
                Logging.warn("Inject snippet error: " + err);
              }
              return originalResponseWrite.apply(response, arguments);
            }, "wrap");
            var originalResponseEnd = response.end;
            return response.end = __name(function (a, b, c) {
              if (isEnabled && isGetRequest) try {
                if (isEnabled && isGetRequest) {
                  var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response),
                    endBufferType = void 0;
                  if (typeof b == "string" && (endBufferType = b), headers == null) WebSnippet.INSTANCE.ValidateInjection(response, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, void 0, endBufferType));else if (headers.length) {
                    var encodeType = headers[0];
                    arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(response, a, encodeType);
                  }
                }
              } catch (err) {
                Logging.warn("Inject snipet error: " + err);
              }
              return originalResponseEnd.apply(response, arguments);
            }, "wrap"), originalRequestListener(request, response);
          }, "requestListener")), originalHttpServer(requestListener);
        }, https.createServer = function (options, httpsRequestListener) {
          var originalHttpsRequestListener = httpsRequestListener;
          if (originalHttpsRequestListener) return httpsRequestListener = __name(function (req, res) {
            var isGetHttpsRequest = req.method == "GET",
              originalHttpsResponseWrite = res.write,
              originalHttpsResponseEnd = res.end;
            return res.write = __name(function (a, b, c) {
              try {
                if (isEnabled && isGetHttpsRequest) {
                  var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res),
                    writeBufferType = void 0;
                  if (typeof b == "string" && (writeBufferType = b), headers == null) WebSnippet.INSTANCE.ValidateInjection(res, a) && (arguments[0] = this.InjectWebSnippet(res, a, void 0, writeBufferType));else if (headers.length) {
                    var encodeType = headers[0];
                    arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, encodeType);
                  }
                }
              } catch (err) {
                Logging.warn("Inject snippet error: " + err);
              }
              return originalHttpsResponseWrite.apply(res, arguments);
            }, "wrap"), res.end = __name(function (a, b, c) {
              try {
                if (isEnabled && isGetHttpsRequest) {
                  var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res),
                    endBufferType = void 0;
                  if (typeof b == "string" && (endBufferType = b), headers == null) WebSnippet.INSTANCE.ValidateInjection(res, a) && (arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, void 0, endBufferType));else if (headers.length) {
                    var encodeType = headers[0];
                    arguments[0] = WebSnippet.INSTANCE.InjectWebSnippet(res, a, encodeType);
                  }
                }
              } catch (err) {
                Logging.warn("Inject snippet error: " + err);
              }
              return originalHttpsResponseEnd.apply(res, arguments);
            }, "wrap"), originalHttpsRequestListener(req, res);
          }, "httpsRequestListener"), originalHttpsServer(options, httpsRequestListener);
        };
      }, WebSnippet.prototype.ValidateInjection = function (response, input) {
        try {
          if (!response || !input || response.statusCode != 200) return !1;
          var isContentHtml = snippetInjectionHelper.isContentTypeHeaderHtml(response);
          if (!isContentHtml) return !1;
          var inputStr = input.slice().toString();
          if (inputStr.indexOf("<head>") >= 0 && inputStr.indexOf("</head>") >= 0 && inputStr.indexOf(WebSnippet._aiUrl) < 0 && inputStr.indexOf(WebSnippet._aiDeprecatedUrl) < 0) return !0;
        } catch (err) {
          Logging.info("validate injections error: " + err);
        }
        return !1;
      }, WebSnippet.prototype.InjectWebSnippet = function (response, input, encodeType, bufferEncodeType) {
        try {
          var isCompressedBuffer = !!encodeType;
          if (isCompressedBuffer) response.removeHeader("Content-Length"), input = this._getInjectedCompressBuffer(response, input, encodeType), response.setHeader("Content-Length", input.length);else {
            var html = input.toString(),
              index = html.indexOf("</head>");
            if (index < 0) return input;
            var newHtml = snippetInjectionHelper.insertSnippetByIndex(index, html, WebSnippet._snippet);
            if (typeof input == "string") response.removeHeader("Content-Length"), input = newHtml, response.setHeader("Content-Length", Buffer.byteLength(input));else if (Buffer.isBuffer(input)) {
              var bufferType = bufferEncodeType || "utf8",
                isValidBufferType = snippetInjectionHelper.isBufferType(input, bufferType);
              if (isValidBufferType) {
                response.removeHeader("Content-Length");
                var encodedString = Buffer.from(newHtml).toString(bufferType);
                input = Buffer.from(encodedString, bufferType), response.setHeader("Content-Length", input.length);
              }
            }
          }
        } catch (ex) {
          Logging.warn("Failed to inject web snippet and change content-lenght headers. Exception:" + ex);
        }
        return input;
      }, WebSnippet.prototype._getInjectedCompressBuffer = function (response, input, encodeType) {
        try {
          switch (encodeType) {
            case snippetInjectionHelper.contentEncodingMethod.GZIP:
              var gunzipBuffer = zlib.gunzipSync(input);
              if (this.ValidateInjection(response, gunzipBuffer)) {
                var injectedGunzipBuffer = this.InjectWebSnippet(response, gunzipBuffer);
                input = zlib.gzipSync(injectedGunzipBuffer);
              }
              break;
            case snippetInjectionHelper.contentEncodingMethod.DEFLATE:
              var inflateBuffer = zlib.inflateSync(input);
              if (this.ValidateInjection(response, inflateBuffer)) {
                var injectedInflateBuffer = this.InjectWebSnippet(response, inflateBuffer);
                input = zlib.deflateSync(injectedInflateBuffer);
              }
              break;
            case snippetInjectionHelper.contentEncodingMethod.BR:
              var BrotliDecompressSync = snippetInjectionHelper.getBrotliDecompressSync(zlib),
                BrotliCompressSync = snippetInjectionHelper.getBrotliCompressSync(zlib);
              if (BrotliDecompressSync && BrotliCompressSync) {
                var decompressBuffer = BrotliDecompressSync(input);
                if (this.ValidateInjection(response, decompressBuffer)) {
                  var injectedDecompressBuffer = this.InjectWebSnippet(response, decompressBuffer);
                  input = BrotliCompressSync(injectedDecompressBuffer);
                }
                break;
              }
          }
        } catch (err) {
          Logging.info("get web injection compress buffer error: " + err);
        }
        return input;
      }, WebSnippet.prototype.dispose = function () {
        WebSnippet.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
      }, WebSnippet;
    }();
  module.exports = WebSnippet;
});
var IX = T((cR, wX) => {
  "use strict";

  var Uve = cR && cR.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    url = require("url"),
    Contracts = Gl(),
    Util = il(),
    RequestResponseHeaders = wg(),
    RequestParser = jA(),
    CorrelationIdManager = wm(),
    HttpDependencyParser = function (_super) {
      __extends(HttpDependencyParser, _super);
      function HttpDependencyParser(requestOptions, request) {
        var _this = _super.call(this) || this;
        return request && request.method && requestOptions && (_this.method = request.method, _this.url = HttpDependencyParser._getUrlFromRequestOptions(requestOptions, request), _this.startTime = +new Date()), i;
      }
      return __name(HttpDependencyParser, "HttpDependencyParser"), HttpDependencyParser.prototype.onError = function (error) {
        this._setStatus(void 0, error);
      }, HttpDependencyParser.prototype.onResponse = function (response) {
        this._setStatus(response.statusCode, void 0), this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
      }, HttpDependencyParser.prototype.getDependencyTelemetry = function (baseTelemetry, dependencyId) {
        var dependencyName = this.method.toUpperCase(),
          remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP,
          remoteDependencyTarget = "";
        try {
          var urlObject = new url.URL(this.url);
          urlObject.search = void 0, urlObject.hash = void 0, dependencyName += " " + urlObject.pathname, remoteDependencyTarget = urlObject.hostname, urlObject.port && (remoteDependencyTarget += ":" + urlObject.port);
        } catch {}
        this.correlationId ? (remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI, this.correlationId !== CorrelationIdManager.correlationIdPrefix && (remoteDependencyTarget += " | " + this.correlationId)) : remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        var dependencyTelemetry = {
          id: dependencyId,
          name: dependencyName,
          data: this.url,
          duration: this.duration,
          success: this._isSuccess(),
          resultCode: this.statusCode ? this.statusCode.toString() : null,
          properties: this.properties || {},
          dependencyTypeName: remoteDependencyType,
          target: remoteDependencyTarget
        };
        if (baseTelemetry && baseTelemetry.time ? dependencyTelemetry.time = baseTelemetry.time : this.startTime && (dependencyTelemetry.time = new Date(this.startTime)), baseTelemetry) {
          for (var key in baseTelemetry) dependencyTelemetry[key] || (dependencyTelemetry[key] = baseTelemetry[key]);
          if (baseTelemetry.properties) for (var key in baseTelemetry.properties) dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
        }
        return dependencyTelemetry;
      }, HttpDependencyParser._getUrlFromRequestOptions = function (options, request) {
        if (typeof options == "string") {
          if (options.indexOf("http://") === 0 || options.indexOf("https://") === 0) try {
            options = new url.URL(options);
          } catch {} else try {
            var parsed = new url.URL("http://" + options);
            parsed.port === "443" ? options = new url.URL("https://" + options) : options = new url.URL("http://" + options);
          } catch {}
        } else {
          if (options && typeof url.URL == "function" && options instanceof url.URL) return url.format(options);
          var originalOptions_1 = options;
          options = {}, originalOptions_1 && Object.keys(originalOptions_1).forEach(function (key) {
            options[key] = originalOptions_1[key];
          });
        }
        if (options.path && options.host) try {
          var parsedQuery = new url.URL(options.path, "http://" + options.host + options.path);
          options.pathname = parsedQuery.pathname, options.search = parsedQuery.search;
        } catch {}
        if (options.path && options.hostname && !options.host) try {
          var parsedQuery = new url.URL(options.path, "http://" + options.hostname + options.path);
          options.pathname = parsedQuery.pathname, options.search = parsedQuery.search;
        } catch {}
        if (options.host && options.port) try {
          var parsedHost = new url.URL("http://" + options.host);
          !parsedHost.port && options.port && (options.hostname = options.host, delete options.host);
        } catch {}
        return options.protocol = options.protocol || request.agent && request.agent.protocol || request.protocol || void 0, options.hostname = options.hostname || "localhost", url.format(options);
      }, HttpDependencyParser;
    }(RequestParser);
  module.exports = HttpDependencyParser;
});
var AX = T(t5 => {
  "use strict";

  var P7 = t5 && t5.__assign || function () {
    return P7 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) {
        t = arguments[r];
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      }
      return e;
    }, P7.apply(this, arguments);
  };
  Object.defineProperty(t5, "__esModule", {
    value: !0
  });
  t5.parseEventHubSpan = void 0;
  var api_1 = ha(),
    core_1 = tc(),
    semantic_conventions_1 = Qu(),
    Constants_1 = L0(),
    getTimeSinceEnqueued = __name(function (span) {
      var countEnqueueDiffs = 0,
        sumEnqueueDiffs = 0,
        startTimeMs = core_1.hrTimeToMilliseconds(span.startTime);
      return span.links.forEach(function (_a) {
        var attributes = _a.attributes,
          enqueuedTime = attributes?.[Constants_1.ENQUEUED_TIME];
        enqueuedTime && (countEnqueueDiffs += 1, sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0));
      }), Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
    }, "getTimeSinceEnqueued"),
    parseEventHubSpan = __name(function (span, telemetry) {
      var r,
        namespace = span.attributes[Constants_1.AzNamespace],
        peerAddress = (span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME] || span.attributes["peer.address"] || "unknown").replace(/\/$/g, ""),
        messageBusDestination = span.attributes[Constants_1.MessageBusDestination] || "unknown";
      switch (span.kind) {
        case api_1.SpanKind.CLIENT:
          telemetry.dependencyTypeName = namespace, telemetry.target = peerAddress + "/" + messageBusDestination;
          break;
        case api_1.SpanKind.PRODUCER:
          telemetry.dependencyTypeName = Constants_1.DependencyTypeName.QueueMessage + " | " + namespace, telemetry.target = peerAddress + "/" + messageBusDestination;
          break;
        case api_1.SpanKind.CONSUMER:
          telemetry.source = peerAddress + "/" + messageBusDestination, telemetry.measurements = __assign(__assign({}, telemetry.measurements), (_a = {}, _a[Constants_1.TIME_SINCE_ENQUEUED] = getTimeSinceEnqueued(span), _a));
          break;
        default:
      }
    }, "parseEventHubSpan");
  exports.parseEventHubSpan = parseEventHubSpan;
});
var NX = T(R7 => {
  "use strict";

  Object.defineProperty(R7, "__esModule", {
    value: !0
  });
  R7.spanToTelemetryContract = void 0;
  var url_1 = require("url"),
    api_1 = ha(),
    semantic_conventions_1 = Qu(),
    Constants = L0(),
    EventHub_1 = AX(),
    Util = il();
  function createPropertiesFromSpan(span) {
    for (var properties = {}, _i = 0, _a = Object.keys(span.attributes); _i < _a.length; _i++) {
      var key = _a[_i];
      key.startsWith("http.") || key.startsWith("rpc.") || key.startsWith("db.") || key.startsWith("peer.") || key.startsWith("net.") || (properties[key] = span.attributes[key]);
    }
    var links = span.links.map(function (link) {
      return {
        operation_Id: link.context.traceId,
        id: link.context.spanId
      };
    });
    return links.length > 0 && (properties["_MS.links"] = Util.stringify(links)), properties;
  }
  __name(createPropertiesFromSpan, "createPropertiesFromSpan");
  function isSqlDB(dbSystem) {
    return dbSystem === semantic_conventions_1.DbSystemValues.DB2 || dbSystem === semantic_conventions_1.DbSystemValues.DERBY || dbSystem === semantic_conventions_1.DbSystemValues.MARIADB || dbSystem === semantic_conventions_1.DbSystemValues.MSSQL || dbSystem === semantic_conventions_1.DbSystemValues.ORACLE || dbSystem === semantic_conventions_1.DbSystemValues.SQLITE || dbSystem === semantic_conventions_1.DbSystemValues.OTHER_SQL || dbSystem === semantic_conventions_1.DbSystemValues.HSQLDB || dbSystem === semantic_conventions_1.DbSystemValues.H2;
  }
  __name(isSqlDB, "isSqlDB");
  function getUrl(span) {
    var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD];
    if (httpMethod) {
      var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
      if (httpUrl) return String(httpUrl);
      var httpScheme = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_SCHEME],
        httpTarget = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_TARGET];
      if (httpScheme && httpTarget) {
        var httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST];
        if (httpHost) return httpScheme + "://" + httpHost + httpTarget;
        var netPeerPort = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_PORT];
        if (netPeerPort) {
          var netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME];
          if (netPeerName) return httpScheme + "://" + netPeerName + ":" + netPeerPort + httpTarget;
          var netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
          if (netPeerIp) return httpScheme + "://" + netPeerIp + ":" + netPeerPort + httpTarget;
        }
      }
    }
    return "";
  }
  __name(getUrl, "getUrl");
  function getDependencyTarget(span) {
    var peerService = span.attributes[semantic_conventions_1.SemanticAttributes.PEER_SERVICE],
      httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST],
      httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL],
      netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME],
      netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
    return peerService ? String(peerService) : httpHost ? String(httpHost) : httpUrl ? String(httpUrl) : netPeerName ? String(netPeerName) : netPeerIp ? String(netPeerIp) : "";
  }
  __name(getDependencyTarget, "getDependencyTarget");
  function createDependencyData(span) {
    var remoteDependency = {
      name: span.name,
      success: span.status.code != api_1.SpanStatusCode.ERROR,
      resultCode: "0",
      duration: 0,
      data: "",
      dependencyTypeName: ""
    };
    span.kind === api_1.SpanKind.PRODUCER && (remoteDependency.dependencyTypeName = Constants.DependencyTypeName.QueueMessage), span.kind === api_1.SpanKind.INTERNAL && span.parentSpanId && (remoteDependency.dependencyTypeName = Constants.DependencyTypeName.InProc);
    var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD],
      dbSystem = span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM],
      rpcSystem = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_SYSTEM];
    if (httpMethod) {
      remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Http;
      var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
      if (httpUrl) {
        var pathName = "";
        try {
          var dependencyUrl = new url_1.URL(String(httpUrl));
          pathName = dependencyUrl.pathname;
        } catch {}
        remoteDependency.name = httpMethod + " " + pathName;
      }
      remoteDependency.data = getUrl(span);
      var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
      httpStatusCode && (remoteDependency.resultCode = String(httpStatusCode));
      var target = getDependencyTarget(span);
      if (target) {
        try {
          var portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/),
            res = portRegex.exec(target);
          if (res != null) {
            var protocol = res[1],
              port = res[3];
            (protocol == "https" && port == ":443" || protocol == "http" && port == ":80") && (target = res[1] + res[2] + res[4]);
          }
        } catch {}
        remoteDependency.target = "" + target;
      }
    } else if (dbSystem) {
      String(dbSystem) === semantic_conventions_1.DbSystemValues.MYSQL ? remoteDependency.dependencyTypeName = "mysql" : String(dbSystem) === semantic_conventions_1.DbSystemValues.POSTGRESQL ? remoteDependency.dependencyTypeName = "postgresql" : String(dbSystem) === semantic_conventions_1.DbSystemValues.MONGODB ? remoteDependency.dependencyTypeName = "mongodb" : String(dbSystem) === semantic_conventions_1.DbSystemValues.REDIS ? remoteDependency.dependencyTypeName = "redis" : isSqlDB(String(dbSystem)) ? remoteDependency.dependencyTypeName = "SQL" : remoteDependency.dependencyTypeName = String(dbSystem);
      var dbStatement = span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT],
        dbOperation = span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION];
      dbStatement ? remoteDependency.data = String(dbStatement) : dbOperation && (remoteDependency.data = String(dbOperation));
      var target = getDependencyTarget(span),
        dbName = span.attributes[semantic_conventions_1.SemanticAttributes.DB_NAME];
      target ? remoteDependency.target = dbName ? target + "|" + dbName : "" + target : remoteDependency.target = dbName ? "" + dbName : "" + dbSystem;
    } else if (rpcSystem) {
      remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Grpc;
      var grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
      grpcStatusCode && (remoteDependency.resultCode = String(grpcStatusCode));
      var target = getDependencyTarget(span);
      target ? remoteDependency.target = "" + target : rpcSystem && (remoteDependency.target = String(rpcSystem));
    }
    return remoteDependency;
  }
  __name(createDependencyData, "createDependencyData");
  function createRequestData(span) {
    var requestData = {
        name: span.name,
        success: span.status.code != api_1.SpanStatusCode.ERROR,
        resultCode: "0",
        duration: 0,
        url: "",
        source: void 0
      },
      httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD],
      grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
    if (httpMethod) {
      if (span.kind == api_1.SpanKind.SERVER) {
        var httpRoute = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_ROUTE],
          httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
        if (httpRoute) requestData.name = httpMethod + " " + httpRoute;else if (httpUrl) try {
          var url = new url_1.URL(String(httpUrl));
          requestData.name = httpMethod + " " + url.pathname;
        } catch {}
      }
      requestData.url = getUrl(span);
      var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
      httpStatusCode && (requestData.resultCode = String(httpStatusCode));
    } else grpcStatusCode && (requestData.resultCode = String(grpcStatusCode));
    return requestData;
  }
  __name(createRequestData, "createRequestData");
  function spanToTelemetryContract(span) {
    var telemetry;
    switch (span.kind) {
      case api_1.SpanKind.CLIENT:
      case api_1.SpanKind.PRODUCER:
      case api_1.SpanKind.INTERNAL:
        telemetry = createDependencyData(span);
        break;
      case api_1.SpanKind.SERVER:
      case api_1.SpanKind.CONSUMER:
        telemetry = createRequestData(span);
        break;
    }
    var spanContext = span.spanContext ? span.spanContext() : span.context(),
      id = "" + spanContext.spanId,
      duration = Math.round(span.duration[0] * 1e3 + span.duration[1] / 1e6);
    return telemetry.id = id, telemetry.duration = duration, telemetry.properties = createPropertiesFromSpan(span), span.attributes[Constants.AzNamespace] && (span.kind === api_1.SpanKind.INTERNAL && (telemetry.dependencyTypeName = Constants.DependencyTypeName.InProc + " | " + span.attributes[Constants.AzNamespace]), span.attributes[Constants.AzNamespace] === Constants.MicrosoftEventHub && EventHub_1.parseEventHubSpan(span, telemetry)), telemetry;
  }
  __name(spanToTelemetryContract, "spanToTelemetryContract");
  exports.spanToTelemetryContract = spanToTelemetryContract;
});
var LX = T(jp => {
  "use strict";

  var r5 = jp && jp.__assign || function () {
    return r5 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) {
        t = arguments[r];
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      }
      return e;
    }, r5.apply(this, arguments);
  };
  Object.defineProperty(jp, "__esModule", {
    value: !0
  });
  jp.AsyncScopeManager = jp.OpenTelemetryScopeManagerWrapper = void 0;
  var CorrelationContextManager_1 = Mp(),
    events_1 = require("events"),
    OpenTelemetryScopeManagerWrapper = function () {
      function OpenTelemetryScopeManagerWrapper() {}
      return __name(OpenTelemetryScopeManagerWrapper, "OpenTelemetryScopeManagerWrapper"), OpenTelemetryScopeManagerWrapper.prototype.active = function () {
        var _this = this,
          context = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        return __assign(__assign({}, context), {
          getValue: function (key) {
            return _this._activeSymbol ? key === _this._activeSymbol ? context : !1 : (_this._activeSymbol = key, context);
          },
          setValue: function () {}
        });
      }, OpenTelemetryScopeManagerWrapper.prototype.with = function (span, fn) {
        var parentSpanId = span.parentSpanId,
          name = span.name,
          correlationContext = OpenTelemetryScopeManagerWrapper._spanToContext(span, parentSpanId, name);
        return CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, fn)();
      }, OpenTelemetryScopeManagerWrapper.prototype.bind = function (target) {
        return typeof target == "function" ? CorrelationContextManager_1.CorrelationContextManager.wrapCallback(target) : (target instanceof events_1.EventEmitter && CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(target), target);
      }, OpenTelemetryScopeManagerWrapper.prototype.enable = function () {
        return CorrelationContextManager_1.CorrelationContextManager.enable(), this;
      }, OpenTelemetryScopeManagerWrapper.prototype.disable = function () {
        return CorrelationContextManager_1.CorrelationContextManager.disable(), this;
      }, OpenTelemetryScopeManagerWrapper._spanToContext = function (span, parentSpanId, name) {
        var spanContext = span.spanContext ? span.spanContext() : span.context(),
          context = __assign(__assign({}, span.spanContext()), {
            traceFlags: span.spanContext().traceFlags
          }),
          parentId = parentSpanId ? "|" + spanContext.traceId + "." + parentSpanId + "." : spanContext.traceId,
          aiContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        aiContext && (context.traceId = aiContext.operation.id, parentSpanId || (parentId = aiContext.operation.parentId));
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.spanToContextObject(context, parentId, name);
        return correlationContext;
      }, OpenTelemetryScopeManagerWrapper;
    }();
  exports.OpenTelemetryScopeManagerWrapper = OpenTelemetryScopeManagerWrapper;
  exports.AsyncScopeManager = new OpenTelemetryScopeManagerWrapper();
});
var kX = T(Hp => {
  "use strict";

  Object.defineProperty(Hp, "__esModule", {
    value: !0
  });
  Hp.enable = Hp.subscriber = void 0;
  var api_1 = ha(),
    Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    SpanParser = NX(),
    AsyncHooksScopeManager_1 = LX(),
    clients = [],
    subscriber = __name(function (event) {
      try {
        var span_1 = event.data,
          telemetry_1 = SpanParser.spanToTelemetryContract(span_1);
        AsyncHooksScopeManager_1.AsyncScopeManager.with(span_1, function () {
          clients.forEach(function (client) {
            span_1.kind === api_1.SpanKind.SERVER || span_1.kind === api_1.SpanKind.CONSUMER ? client.trackRequest(telemetry_1) : (span_1.kind === api_1.SpanKind.CLIENT || span_1.kind === api_1.SpanKind.INTERNAL || span_1.kind === api_1.SpanKind.PRODUCER) && client.trackDependency(telemetry_1);
          });
        });
      } catch {}
    }, "subscriber");
  exports.subscriber = subscriber;
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("azure-coretracing", exports.subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.AZURE_CORE_TRACING);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("azure-coretracing", exports.subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var DX = T($p => {
  "use strict";

  Object.defineProperty($p, "__esModule", {
    value: !0
  });
  $p.enable = $p.subscriber = void 0;
  var Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    subscriber = __name(function (event) {
      event.data.event.commandName !== "ismaster" && clients.forEach(function (client) {
        var dbName = event.data.startedData && event.data.startedData.databaseName || "Unknown database";
        client.trackDependency({
          target: dbName,
          data: event.data.event.commandName,
          name: event.data.event.commandName,
          duration: event.data.event.duration,
          success: event.data.succeeded,
          resultCode: event.data.succeeded ? "0" : "1",
          time: event.data.startedData.time,
          dependencyTypeName: "mongodb"
        });
      });
    }, "subscriber");
  exports.subscriber = subscriber;
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("mongodb", exports.subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MONGODB);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("mongodb", exports.subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var MX = T(Vp => {
  "use strict";

  Object.defineProperty(Vp, "__esModule", {
    value: !0
  });
  Vp.enable = Vp.subscriber = void 0;
  var Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    subscriber = __name(function (event) {
      clients.forEach(function (client) {
        var queryObj = event.data.query || {},
          sqlString = queryObj.sql || "Unknown query",
          success = !event.data.err,
          connection = queryObj._connection || {},
          connectionConfig = connection.config || {},
          dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
        client.trackDependency({
          target: dbName,
          data: sqlString,
          name: sqlString,
          duration: event.data.duration,
          success: success,
          resultCode: success ? "0" : "1",
          time: event.data.time,
          dependencyTypeName: "mysql"
        });
      });
    }, "subscriber");
  exports.subscriber = subscriber;
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("mysql", exports.subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MYSQL);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("mysql", exports.subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var BX = T(Gp => {
  "use strict";

  Object.defineProperty(Gp, "__esModule", {
    value: !0
  });
  Gp.enable = Gp.subscriber = void 0;
  var Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    subscriber = __name(function (event) {
      clients.forEach(function (client) {
        event.data.commandObj.command !== "info" && client.trackDependency({
          target: event.data.address,
          name: event.data.commandObj.command,
          data: event.data.commandObj.command,
          duration: event.data.duration,
          success: !event.data.err,
          resultCode: event.data.err ? "1" : "0",
          time: event.data.time,
          dependencyTypeName: "redis"
        });
      });
    }, "subscriber");
  exports.subscriber = subscriber;
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("redis", exports.subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.REDIS);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("redis", exports.subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var FX = T(zp => {
  "use strict";

  Object.defineProperty(zp, "__esModule", {
    value: !0
  });
  zp.enable = zp.subscriber = void 0;
  var Constants_1 = L0(),
    diagnostic_channel_1 = N0(),
    clients = [],
    subscriber = __name(function (event) {
      clients.forEach(function (client) {
        var q = event.data.query,
          sql = q.preparable && q.preparable.text || q.plan || q.text || "unknown query",
          success = !event.data.error,
          conn = event.data.database.host + ":" + event.data.database.port;
        client.trackDependency({
          target: conn,
          data: sql,
          name: sql,
          duration: event.data.duration,
          success: success,
          resultCode: success ? "0" : "1",
          time: event.data.time,
          dependencyTypeName: "postgres"
        });
      });
    }, "subscriber");
  exports.subscriber = subscriber;
  function enable(enabled, client) {
    if (enabled) {
      var clientFound = clients.find(function (c) {
        return c == client;
      });
      if (clientFound) return;
      clients.length === 0 && diagnostic_channel_1.channel.subscribe("postgres", exports.subscriber, diagnostic_channel_1.trueFilter, function (module, version) {
        var statsbeat = client.getStatsbeat();
        statsbeat && statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.POSTGRES);
      }), clients.push(client);
    } else clients = clients.filter(function (c) {
      return c != client;
    }), clients.length === 0 && diagnostic_channel_1.channel.unsubscribe("postgres", exports.subscriber);
  }
  __name(enable, "enable");
  exports.enable = enable;
});
var s5 = T((yR, UX) => {
  "use strict";

  var N7 = yR && yR.__spreadArrays || function () {
      for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
      for (var n = Array(e), i = 0, t = 0; t < r; t++) for (var s = arguments[t], o = 0, c = s.length; o < c; o++, i++) n[i] = s[o];
      return n;
    },
    http = require("http"),
    https = require("https"),
    Logging = x0(),
    Util = il(),
    RequestResponseHeaders = wg(),
    HttpDependencyParser = IX(),
    CorrelationContextManager_1 = Mp(),
    Traceparent = k9(),
    DiagChannel = L9(),
    CorrelationIdManager = wm(),
    AutoCollectHttpDependencies = function () {
      function AutoCollectHttpDependencies(client) {
        if (AutoCollectHttpDependencies.INSTANCE) throw new Error("Client request tracking should be configured from the applicationInsights object");
        AutoCollectHttpDependencies.INSTANCE = this, this._client = client;
      }
      return __name(AutoCollectHttpDependencies, "AutoCollectHttpDependencies"), AutoCollectHttpDependencies.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && this._initialize(), DiagChannel.IsInitialized && (kX().enable(isEnabled, this._client), DX().enable(isEnabled, this._client), MX().enable(isEnabled, this._client), BX().enable(isEnabled, this._client), FX().enable(isEnabled, this._client));
      }, AutoCollectHttpDependencies.prototype.isInitialized = function () {
        return this._isInitialized;
      }, AutoCollectHttpDependencies.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = !0;
        var originalRequest = http.request,
          originalHttpsRequest = https.request,
          clientRequestPatch = __name(function (request, options) {
            try {
              var shouldCollect = !options[AutoCollectHttpDependencies.disableCollectionRequestOption] && !request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag],
                userAgentHeader = null;
              if (options.headers && (userAgentHeader = options.headers["User-Agent"] || options.headers["user-agent"], userAgentHeader && userAgentHeader.toString().indexOf("azsdk-js") !== -1 && (shouldCollect = !1)), request && options && shouldCollect && (CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request), _this._isEnabled)) if (request[AutoCollectHttpDependencies.alreadyAutoCollectedFlag] = !0, CorrelationContextManager_1.CorrelationContextManager.getCurrentContext()) AutoCollectHttpDependencies.trackRequest(_this._client, {
                options: options,
                request: request
              });else {
                var operationId = null;
                if (CorrelationIdManager.w3cEnabled) {
                  var traceparent = new Traceparent();
                  operationId = traceparent.traceId;
                } else {
                  var requestId = CorrelationIdManager.generateRequestId(null);
                  operationId = CorrelationIdManager.getRootId(requestId);
                }
                var correlationContext = CorrelationContextManager_1.CorrelationContextManager.generateContextObject(operationId);
                CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {
                  AutoCollectHttpDependencies.trackRequest(_this._client, {
                    options: options,
                    request: request
                  });
                });
              }
            } catch (err) {
              Logging.warn("Failed to generate dependency telemetry.", Util.dumpObj(err));
            }
          }, "clientRequestPatch");
        http.request = function (options) {
          for (var requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
          var request = originalRequest.call.apply(originalRequest, __spreadArrays([http, options], requestArgs));
          return clientRequestPatch(request, options), request;
        }, https.request = function (options) {
          for (var requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
          var request = originalHttpsRequest.call.apply(originalHttpsRequest, __spreadArrays([https, options], requestArgs));
          return clientRequestPatch(request, options), request;
        }, http.get = function (options) {
          for (var o, requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
          var request = (_a = http.request).call.apply(_a, __spreadArrays([http, options], requestArgs));
          return request.end(), request;
        }, https.get = function (options) {
          for (var o, requestArgs = [], _i = 1; _i < arguments.length; _i++) requestArgs[_i - 1] = arguments[_i];
          var request = (_a = https.request).call.apply(_a, __spreadArrays([https, options], requestArgs));
          return request.end(), request;
        };
      }, AutoCollectHttpDependencies.trackRequest = function (client, telemetry) {
        if (!telemetry.options || !telemetry.request || !client) {
          Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
          return;
        }
        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request),
          currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(),
          uniqueRequestId,
          uniqueTraceparent;
        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) currentContext.operation.traceparent.updateSpanId(), uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();else if (CorrelationIdManager.w3cEnabled) {
          var traceparent = new Traceparent();
          uniqueTraceparent = traceparent.toString(), uniqueRequestId = traceparent.getBackCompatRequestId();
        } else uniqueRequestId = currentContext && currentContext.operation && currentContext.operation.parentId + AutoCollectHttpDependencies.requestNumber++ + ".";
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader && client.config && client.config.correlationId) {
          var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
          try {
            Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
          } catch (err) {
            Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
          }
          if (currentContext && currentContext.operation) try {
            if (telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId), client.config.ignoreLegacyHeaders || (telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id), telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId)), uniqueTraceparent || currentContext.operation.traceparent) telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());else if (CorrelationIdManager.w3cEnabled) {
              var traceparent = new Traceparent().toString();
              telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
            }
            if (currentContext.operation.tracestate) {
              var tracestate = currentContext.operation.tracestate.toString();
              tracestate && telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
            }
            var correlationContextHeader = currentContext.customProperties.serializeToHeader();
            correlationContextHeader && telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
          } catch (err) {
            Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
          }
        }
        telemetry.request.on && (telemetry.request.on("response", function (response) {
          if (!telemetry.isProcessed) {
            telemetry.isProcessed = !0, requestParser.onResponse(response);
            var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
            dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, dependencyTelemetry.contextObjects["http.ClientResponse"] = response, client.trackDependency(dependencyTelemetry);
          }
        }), telemetry.request.on("error", function (error) {
          if (!telemetry.isProcessed) {
            telemetry.isProcessed = !0, requestParser.onError(error);
            var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
            dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, dependencyTelemetry.contextObjects.Error = error, client.trackDependency(dependencyTelemetry);
          }
        }), telemetry.request.on("abort", function () {
          if (!telemetry.isProcessed) {
            telemetry.isProcessed = !0, requestParser.onError(new Error("The request has been aborted and the network socket has closed."));
            var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
            dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {}, dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options, dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request, client.trackDependency(dependencyTelemetry);
          }
        }));
      }, AutoCollectHttpDependencies.prototype.dispose = function () {
        AutoCollectHttpDependencies.INSTANCE = null, this.enable(!1), this._isInitialized = !1;
      }, AutoCollectHttpDependencies.disableCollectionRequestOption = "disableAppInsightsAutoCollection", AutoCollectHttpDependencies.requestNumber = 1, AutoCollectHttpDependencies.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", AutoCollectHttpDependencies;
    }();
  module.exports = AutoCollectHttpDependencies;
});
var xR = T((lZe, VX) => {
  "use strict";

  var http = require("http"),
    https = require("https"),
    Logging = x0(),
    Util = il(),
    RequestResponseHeaders = wg(),
    HttpRequestParser = VA(),
    CorrelationContextManager_1 = Mp(),
    AutoCollectPerformance = b7(),
    AutoCollectHttpRequests = function () {
      function AutoCollectHttpRequests(client) {
        if (AutoCollectHttpRequests.INSTANCE) throw new Error("Server request tracking should be configured from the applicationInsights object");
        AutoCollectHttpRequests.INSTANCE = this, this._client = client;
      }
      return __name(AutoCollectHttpRequests, "AutoCollectHttpRequests"), AutoCollectHttpRequests.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled, (this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized && (this.useAutoCorrelation(this._isAutoCorrelating), this._initialize());
      }, AutoCollectHttpRequests.prototype.useAutoCorrelation = function (isEnabled, forceClsHooked) {
        isEnabled && !this._isAutoCorrelating ? CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked) : !isEnabled && this._isAutoCorrelating && CorrelationContextManager_1.CorrelationContextManager.disable(), this._isAutoCorrelating = isEnabled;
      }, AutoCollectHttpRequests.prototype.isInitialized = function () {
        return this._isInitialized;
      }, AutoCollectHttpRequests.prototype.isAutoCorrelating = function () {
        return this._isAutoCorrelating;
      }, AutoCollectHttpRequests.prototype._generateCorrelationContext = function (requestParser) {
        if (this._isAutoCorrelating) return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
      }, AutoCollectHttpRequests.prototype._registerRequest = function (request, response, onRequest) {
        var _this = this,
          requestParser = new HttpRequestParser(request),
          correlationContext = this._generateCorrelationContext(requestParser);
        CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function () {
          _this._isEnabled && (request[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = !0, AutoCollectHttpRequests.trackRequest(_this._client, {
            request: request,
            response: response
          }, requestParser)), typeof onRequest == "function" && onRequest(request, response);
        });
      }, AutoCollectHttpRequests.prototype._initialize = function () {
        if (this._isInitialized = !0, !AutoCollectHttpRequests.HANDLER_READY) {
          AutoCollectHttpRequests.HANDLER_READY = !0;
          var wrapOnRequestHandler = __name(function (onRequest) {
              if (onRequest) {
                if (typeof onRequest != "function") throw new Error("onRequest handler must be a function");
                return function (request, response) {
                  var u;
                  CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request), CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
                  var shouldCollect = request && !request[AutoCollectHttpRequests.alreadyAutoCollectedFlag];
                  request && shouldCollect ? (_a = AutoCollectHttpRequests.INSTANCE) === null || _a === void 0 || _a._registerRequest(request, response, onRequest) : typeof onRequest == "function" && onRequest(request, response);
                };
              }
            }, "wrapOnRequestHandler"),
            wrapServerEventHandler = __name(function (server) {
              var originalAddListener = server.addListener.bind(server);
              server.addListener = function (eventType, eventHandler) {
                switch (eventType) {
                  case "request":
                  case "checkContinue":
                    return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));
                  default:
                    return originalAddListener(eventType, eventHandler);
                }
              }, server.on = server.addListener;
            }, "wrapServerEventHandler"),
            originalHttpServer = http.createServer;
          http.createServer = function (param1, param2) {
            if (param2 && typeof param2 == "function") {
              var server = originalHttpServer(param1, wrapOnRequestHandler(param2));
              return wrapServerEventHandler(server), server;
            } else {
              var server = originalHttpServer(wrapOnRequestHandler(param1));
              return wrapServerEventHandler(server), server;
            }
          };
          var originalHttpsServer = https.createServer;
          https.createServer = function (options, onRequest) {
            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));
            return wrapServerEventHandler(server), server;
          };
        }
      }, AutoCollectHttpRequests.trackRequestSync = function (client, telemetry) {
        if (!telemetry.request || !telemetry.response || !client) {
          Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
          return;
        }
        telemetry.isProcessed = !1, AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(),
          requestParser = new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        correlationContext && (correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id, correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name, correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId, correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader())), AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
      }, AutoCollectHttpRequests.trackRequest = function (client, telemetry, _requestParser) {
        if (!telemetry.request || !telemetry.response || !client) {
          Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
          return;
        }
        telemetry.isProcessed = !1;
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(),
          requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response), correlationContext && !_requestParser && (correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id, correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name, correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId, correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader())), telemetry.response.once && telemetry.response.once("finish", function () {
          AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);
        }), telemetry.request.on && telemetry.request.on("error", function (error) {
          AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);
        }), telemetry.request.on && telemetry.request.on("aborted", function () {
          var errorMessage = "The request has been aborted and the network socket has closed.";
          AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, errorMessage);
        });
      }, AutoCollectHttpRequests.addResponseCorrelationIdHeader = function (client, response) {
        if (client.config && client.config.correlationId && response.getHeader && response.setHeader && !response.headersSent) {
          var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
          Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
        }
      }, AutoCollectHttpRequests.endRequest = function (client, requestParser, telemetry, ellapsedMilliseconds, error) {
        if (!telemetry.isProcessed) {
          telemetry.isProcessed = !0, error ? requestParser.onError(error, ellapsedMilliseconds) : requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
          var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
          if (requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags), telemetry.tagOverrides) for (var key in telemetry.tagOverrides) requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
          var legacyRootId = requestParser.getLegacyRootId();
          legacyRootId && (requestTelemetry.properties.ai_legacyRootId = legacyRootId), requestTelemetry.contextObjects = requestTelemetry.contextObjects || {}, requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request, requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response, client.trackRequest(requestTelemetry);
        }
      }, AutoCollectHttpRequests.prototype.dispose = function () {
        AutoCollectHttpRequests.INSTANCE = null, this.enable(!1), this._isInitialized = !1, CorrelationContextManager_1.CorrelationContextManager.disable(), this._isAutoCorrelating = !1;
      }, AutoCollectHttpRequests.HANDLER_READY = !1, AutoCollectHttpRequests.alreadyAutoCollectedFlag = "_appInsightsAutoCollected", AutoCollectHttpRequests;
    }();
  module.exports = AutoCollectHttpRequests;
});
var WX = T((ER, zX) => {
  "use strict";

  var Su = ER && ER.__assign || function () {
      return Su = Object.assign || function (e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
          t = arguments[r];
          for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }, Su.apply(this, arguments);
    },
    os = require("os"),
    Contracts = Gl(),
    Constants = L0(),
    Util = il(),
    Logging = x0(),
    StreamId = Util.w3cTraceId(),
    QuickPulseEnvelopeFactory = function () {
      function QuickPulseEnvelopeFactory() {}
      return __name(QuickPulseEnvelopeFactory, "QuickPulseEnvelopeFactory"), QuickPulseEnvelopeFactory.createQuickPulseEnvelope = function (metrics, documents, config, context) {
        var machineName = os && typeof os.hostname == "function" && os.hostname() || "Unknown",
          instance = context.tags && context.keys && context.keys.cloudRoleInstance && context.tags[context.keys.cloudRoleInstance] || machineName,
          roleName = context.tags && context.keys && context.keys.cloudRole && context.tags[context.keys.cloudRole] || null,
          envelope = {
            Documents: documents.length > 0 ? documents : null,
            InstrumentationKey: config.instrumentationKey || "",
            Metrics: metrics.length > 0 ? metrics : null,
            InvariantVersion: 1,
            Timestamp: "/Date(" + Date.now() + ")/",
            Version: context.tags[context.keys.internalSdkVersion],
            StreamId: StreamId,
            MachineName: machineName,
            Instance: instance,
            RoleName: roleName
          };
        return envelope;
      }, QuickPulseEnvelopeFactory.createQuickPulseMetric = function (telemetry) {
        var data;
        return data = {
          Name: telemetry.name,
          Value: telemetry.value,
          Weight: telemetry.count || 1
        }, data;
      }, QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument = function (envelope) {
        switch (envelope.data.baseType) {
          case Contracts.TelemetryTypeString.Event:
            return QuickPulseEnvelopeFactory.createQuickPulseEventDocument(envelope);
          case Contracts.TelemetryTypeString.Exception:
            return QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument(envelope);
          case Contracts.TelemetryTypeString.Trace:
            return QuickPulseEnvelopeFactory.createQuickPulseTraceDocument(envelope);
          case Contracts.TelemetryTypeString.Dependency:
            return QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument(envelope);
          case Contracts.TelemetryTypeString.Request:
            return QuickPulseEnvelopeFactory.createQuickPulseRequestDocument(envelope);
        }
        return null;
      }, QuickPulseEnvelopeFactory.createQuickPulseEventDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope),
          name = envelope.data.baseData.name,
          eventDocument = __assign(__assign({}, document), {
            Name: name
          });
        return eventDocument;
      }, QuickPulseEnvelopeFactory.createQuickPulseTraceDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope),
          severityLevel = envelope.data.baseData.severityLevel || 0,
          traceDocument = __assign(__assign({}, document), {
            Message: envelope.data.baseData.message,
            SeverityLevel: Contracts.SeverityLevel[severityLevel]
          });
        return traceDocument;
      }, QuickPulseEnvelopeFactory.createQuickPulseExceptionDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope),
          exceptionDetails = envelope.data.baseData.exceptions,
          exception = "",
          exceptionMessage = "",
          exceptionType = "";
        exceptionDetails && exceptionDetails.length > 0 && (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0 ? exceptionDetails[0].parsedStack.forEach(function (err) {
          exception += err.assembly + `
`;
        }) : exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0 && (exception = exceptionDetails[0].stack), exceptionMessage = exceptionDetails[0].message, exceptionType = exceptionDetails[0].typeName);
        var exceptionDocument = __assign(__assign({}, document), {
          Exception: exception,
          ExceptionMessage: exceptionMessage,
          ExceptionType: exceptionType
        });
        return exceptionDocument;
      }, QuickPulseEnvelopeFactory.createQuickPulseRequestDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope),
          baseData = envelope.data.baseData,
          requestDocument = __assign(__assign({}, document), {
            Name: baseData.name,
            Success: baseData.success,
            Duration: baseData.duration,
            ResponseCode: baseData.responseCode,
            OperationName: baseData.name
          });
        return requestDocument;
      }, QuickPulseEnvelopeFactory.createQuickPulseDependencyDocument = function (envelope) {
        var document = QuickPulseEnvelopeFactory.createQuickPulseDocument(envelope),
          baseData = envelope.data.baseData,
          dependencyDocument = __assign(__assign({}, document), {
            Name: baseData.name,
            Target: baseData.target,
            Success: baseData.success,
            Duration: baseData.duration,
            ResultCode: baseData.resultCode,
            CommandName: baseData.data,
            OperationName: document.OperationId,
            DependencyTypeName: baseData.type
          });
        return dependencyDocument;
      }, QuickPulseEnvelopeFactory.createQuickPulseDocument = function (envelope) {
        var documentType, __type, operationId, properties;
        envelope.data.baseType ? (__type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType], documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType]) : Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType), operationId = envelope.tags[QuickPulseEnvelopeFactory.keys.operationId], properties = QuickPulseEnvelopeFactory.aggregateProperties(envelope);
        var document = {
          DocumentType: documentType,
          __type: __type,
          OperationId: operationId,
          Version: "1.0",
          Properties: properties
        };
        return document;
      }, QuickPulseEnvelopeFactory.aggregateProperties = function (envelope) {
        var properties = [],
          meas = envelope.data.baseData.measurements || {};
        for (var key in meas) if (meas.hasOwnProperty(key)) {
          var value = meas[key],
            property = {
              key: key,
              value: value
            };
          properties.push(property);
        }
        var props = envelope.data.baseData.properties || {};
        for (var key in props) if (props.hasOwnProperty(key)) {
          var value = props[key],
            property = {
              key: key,
              value: value
            };
          properties.push(property);
        }
        return properties;
      }, QuickPulseEnvelopeFactory.keys = new Contracts.ContextTagKeys(), QuickPulseEnvelopeFactory;
    }();
  module.exports = QuickPulseEnvelopeFactory;
});
var XX = T((fZe, KX) => {
  "use strict";

  var getTransmissionTime = __name(function () {
    return (Date.now() + 621355968e5) * 1e4;
  }, "getTransmissionTime");
  module.exports = {
    getTransmissionTime: getTransmissionTime
  };
});
var JX = T((a4, ZX) => {
  "use strict";

  var YX = a4 && a4.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    QX = a4 && a4.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    https = require("https"),
    AutoCollectHttpDependencies = s5(),
    Logging = x0(),
    QuickPulseUtil = XX(),
    Util = il(),
    url = require("url"),
    QuickPulseConfig = {
      method: "POST",
      time: "x-ms-qps-transmission-time",
      pollingIntervalHint: "x-ms-qps-service-polling-interval-hint",
      endpointRedirect: "x-ms-qps-service-endpoint-redirect-v2",
      instanceName: "x-ms-qps-instance-name",
      streamId: "x-ms-qps-stream-id",
      machineName: "x-ms-qps-machine-name",
      roleName: "x-ms-qps-role-name",
      streamid: "x-ms-qps-stream-id",
      invariantVersion: "x-ms-qps-invariant-version",
      subscribed: "x-ms-qps-subscribed"
    },
    QuickPulseSender = function () {
      function QuickPulseSender(config, getAuthorizationHandler) {
        this._config = config, this._consecutiveErrors = 0, this._getAuthorizationHandler = getAuthorizationHandler;
      }
      return __name(QuickPulseSender, "QuickPulseSender"), QuickPulseSender.prototype.ping = function (envelope, redirectedHostEndpoint, done) {
        var pingHeaders = [{
          name: QuickPulseConfig.streamId,
          value: envelope.StreamId
        }, {
          name: QuickPulseConfig.machineName,
          value: envelope.MachineName
        }, {
          name: QuickPulseConfig.roleName,
          value: envelope.RoleName
        }, {
          name: QuickPulseConfig.instanceName,
          value: envelope.Instance
        }, {
          name: QuickPulseConfig.invariantVersion,
          value: envelope.InvariantVersion.toString()
        }];
        this._submitData(envelope, redirectedHostEndpoint, done, "ping", pingHeaders);
      }, QuickPulseSender.prototype.post = function (envelope, redirectedHostEndpoint, done) {
        return YX(this, void 0, void 0, function () {
          return QX(this, function (i) {
            switch (i.label) {
              case 0:
                return [4, this._submitData([envelope], redirectedHostEndpoint, done, "post")];
              case 1:
                return _a.sent(), [2];
            }
          });
        });
      }, QuickPulseSender.prototype._submitData = function (envelope, redirectedHostEndpoint, done, postOrPing, additionalHeaders) {
        return YX(this, void 0, void 0, function () {
          var o,
            c,
            u,
            f,
            d,
            p,
            m,
            h,
            g = this;
          return QX(this, function (_) {
            switch (_.label) {
              case 0:
                if (payload = Util.stringify(envelope), options = (_a = {}, _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0, _a.host = redirectedHostEndpoint && redirectedHostEndpoint.length > 0 ? redirectedHostEndpoint : this._config.quickPulseHost, _a.method = QuickPulseConfig.method, _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey, _a.headers = (_b = {
                  Expect: "100-continue"
                }, _b[QuickPulseConfig.time] = QuickPulseUtil.getTransmissionTime(), _b["Content-Type"] = "application/json", _b["Content-Length"] = Buffer.byteLength(payload), h), m), additionalHeaders && additionalHeaders.length > 0 && additionalHeaders.forEach(function (header) {
                  return options.headers[header.name] = header.value;
                }), postOrPing !== "post") return [3, 4];
                if (authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null, !authHandler) return [3, 4];
                _.label = 1;
              case 1:
                return _.trys.push([1, 3,, 4]), [4, authHandler.addAuthorizationHeader(options)];
              case 2:
                return _c.sent(), [3, 4];
              case 3:
                return f = _.sent(), notice = "Failed to get AAD bearer token for the Application. Error:", Logging.info(QuickPulseSender.TAG, notice, authError_1), [2];
              case 4:
                return this._config.httpsAgent ? options.agent = this._config.httpsAgent : options.agent = Util.tlsRestrictedAgent, req = https.request(options, function (res) {
                  if (res.statusCode == 200) {
                    var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true",
                      redirectHeader = null;
                    try {
                      redirectHeader = res.headers[QuickPulseConfig.endpointRedirect] ? new url.URL(res.headers[QuickPulseConfig.endpointRedirect].toString()).host : null;
                    } catch (error) {
                      _this._onError("Failed to parse redirect header from QuickPulse: " + Util.dumpObj(error));
                    }
                    var pollingIntervalHint = res.headers[QuickPulseConfig.pollingIntervalHint] ? parseInt(res.headers[QuickPulseConfig.pollingIntervalHint].toString()) : null;
                    _this._consecutiveErrors = 0, done(shouldPOSTData, res, redirectHeader, pollingIntervalHint);
                  } else _this._onError("StatusCode:" + res.statusCode + " StatusMessage:" + res.statusMessage), done();
                }), req.on("error", function (error) {
                  _this._onError(error), done();
                }), req.write(payload), req.end(), [2];
            }
          });
        });
      }, QuickPulseSender.prototype._onError = function (error) {
        this._consecutiveErrors++;
        var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
        this._consecutiveErrors % QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN === 0 ? (notice = "Live Metrics endpoint could not be reached " + this._consecutiveErrors + " consecutive times. Most recent error:", Logging.warn(QuickPulseSender.TAG, notice, error)) : Logging.info(QuickPulseSender.TAG, notice, error);
      }, QuickPulseSender.TAG = "QuickPulseSender", QuickPulseSender.MAX_QPS_FAILURES_BEFORE_WARN = 25, QuickPulseSender;
    }();
  module.exports = QuickPulseSender;
});
var iY = T((l4, nY) => {
  "use strict";

  var eY = l4 && l4.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    tY = l4 && l4.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    Logging = x0(),
    QuickPulseEnvelopeFactory = WX(),
    QuickPulseSender = JX(),
    Constants = L0(),
    Context = Zg(),
    QuickPulseStateManager = function () {
      function QuickPulseStateManager(config, context, getAuthorizationHandler) {
        this._isCollectingData = !1, this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0, this._metrics = {}, this._documents = [], this._collectors = [], this._redirectedHost = null, this._pollingIntervalHint = -1, this.config = config, this.context = context || new Context(), this._sender = new QuickPulseSender(this.config, getAuthorizationHandler), this._isEnabled = !1;
      }
      return __name(QuickPulseStateManager, "QuickPulseStateManager"), QuickPulseStateManager.prototype.addCollector = function (collector) {
        this._collectors.push(collector);
      }, QuickPulseStateManager.prototype.trackMetric = function (telemetry) {
        this._addMetric(telemetry);
      }, QuickPulseStateManager.prototype.addDocument = function (envelope) {
        if (this._isCollectingData) {
          var document_1 = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
          document_1 && this._documents.push(document_1);
        }
      }, QuickPulseStateManager.prototype.enable = function (isEnabled) {
        isEnabled && !this._isEnabled ? (this._isEnabled = !0, this._goQuickPulse()) : !isEnabled && this._isEnabled && (this._isEnabled = !1, clearTimeout(this._handle), this._handle = void 0);
      }, QuickPulseStateManager.prototype.enableCollectors = function (enable) {
        this._collectors.forEach(function (collector) {
          collector.enable(enable);
        });
      }, QuickPulseStateManager.prototype._addMetric = function (telemetry) {
        var value = telemetry.value,
          count = telemetry.count || 1,
          name = Constants.PerformanceToQuickPulseCounter[telemetry.name];
        name && (this._metrics[name] ? (this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count), this._metrics[name].Weight += count) : (this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry), this._metrics[name].Name = name, this._metrics[name].Weight = 1));
      }, QuickPulseStateManager.prototype._resetQuickPulseBuffer = function () {
        delete this._metrics, this._metrics = {}, this._documents.length = 0;
      }, QuickPulseStateManager.prototype._goQuickPulse = function () {
        return eY(this, void 0, void 0, function () {
          var t,
            r,
            n,
            i,
            s = this;
          return tY(this, function (o) {
            switch (o.label) {
              case 0:
                return metrics = Object.keys(this._metrics).map(function (k) {
                  return _this._metrics[k];
                }), envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context), this._resetQuickPulseBuffer(), this._isCollectingData ? [4, this._post(envelope)] : [3, 2];
              case 1:
                return _a.sent(), [3, 3];
              case 2:
                this._ping(envelope), o.label = 3;
              case 3:
                return pingInterval = this._pollingIntervalHint > 0 ? this._pollingIntervalHint : QuickPulseStateManager.PING_INTERVAL, currentTimeout = this._isCollectingData ? QuickPulseStateManager.POST_INTERVAL : pingInterval, this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_POST_WAIT_TIME && !this._lastSendSucceeded ? (this._isCollectingData = !1, currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL) : !this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager.MAX_PING_WAIT_TIME && !this._lastSendSucceeded && (currentTimeout = QuickPulseStateManager.FALLBACK_INTERVAL), this._lastSendSucceeded = null, this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout), this._handle.unref(), [2];
            }
          });
        });
      }, QuickPulseStateManager.prototype._ping = function (envelope) {
        this._sender.ping(envelope, this._redirectedHost, this._quickPulseDone.bind(this));
      }, QuickPulseStateManager.prototype._post = function (envelope) {
        return eY(this, void 0, void 0, function () {
          return tY(this, function (r) {
            switch (r.label) {
              case 0:
                return [4, this._sender.post(envelope, this._redirectedHost, this._quickPulseDone.bind(this))];
              case 1:
                return _a.sent(), [2];
            }
          });
        });
      }, QuickPulseStateManager.prototype._quickPulseDone = function (shouldPOST, res, redirectedHost, pollingIntervalHint) {
        shouldPOST != null ? (this._isCollectingData !== shouldPOST && (Logging.info("Live Metrics sending data", shouldPOST), this.enableCollectors(shouldPOST)), this._isCollectingData = shouldPOST, redirectedHost && redirectedHost.length > 0 && (this._redirectedHost = redirectedHost, Logging.info("Redirecting endpoint to: ", redirectedHost)), pollingIntervalHint && pollingIntervalHint > 0 && (this._pollingIntervalHint = pollingIntervalHint), res && res.statusCode < 300 && res.statusCode >= 200 ? (this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0) : this._lastSendSucceeded = !1) : this._lastSendSucceeded = !1;
      }, QuickPulseStateManager.MAX_POST_WAIT_TIME = 2e4, QuickPulseStateManager.MAX_PING_WAIT_TIME = 6e4, QuickPulseStateManager.FALLBACK_INTERVAL = 6e4, QuickPulseStateManager.PING_INTERVAL = 5e3, QuickPulseStateManager.POST_INTERVAL = 1e3, QuickPulseStateManager;
    }();
  module.exports = QuickPulseStateManager;
});
var sY = T(o5 => {
  "use strict";

  var k7 = o5 && o5.__assign || function () {
    return k7 = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) {
        t = arguments[r];
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      }
      return e;
    }, k7.apply(this, arguments);
  };
  Object.defineProperty(o5, "__esModule", {
    value: !0
  });
  o5.AutoCollectNativePerformance = void 0;
  var Context = Zg(),
    Logging = x0(),
    AutoCollectNativePerformance = function () {
      function AutoCollectNativePerformance(client) {
        this._disabledMetrics = {}, AutoCollectNativePerformance.INSTANCE && AutoCollectNativePerformance.INSTANCE.dispose(), AutoCollectNativePerformance.INSTANCE = this, this._client = client;
      }
      return __name(AutoCollectNativePerformance, "AutoCollectNativePerformance"), AutoCollectNativePerformance.prototype.enable = function (isEnabled, disabledMetrics, collectionInterval) {
        var _this = this;
        if (disabledMetrics === void 0 && (disabledMetrics = {}), collectionInterval === void 0 && (collectionInterval = 6e4), AutoCollectNativePerformance._metricsAvailable == null && isEnabled && !this._isInitialized) try {
          var NativeMetricsEmitters = require("applicationinsights-native-metrics");
          AutoCollectNativePerformance._emitter = new NativeMetricsEmitters(), AutoCollectNativePerformance._metricsAvailable = !0, Logging.info("Native metrics module successfully loaded!");
        } catch {
          AutoCollectNativePerformance._metricsAvailable = !1;
          return;
        }
        this._isEnabled = isEnabled, this._disabledMetrics = disabledMetrics, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), this._isEnabled && AutoCollectNativePerformance._emitter ? (AutoCollectNativePerformance._emitter.enable(!0, collectionInterval), this._handle || (this._handle = setInterval(function () {
          return _this._trackNativeMetrics();
        }, collectionInterval), this._handle.unref())) : AutoCollectNativePerformance._emitter && (AutoCollectNativePerformance._emitter.enable(!1), this._handle && (clearInterval(this._handle), this._handle = void 0));
      }, AutoCollectNativePerformance.prototype.dispose = function () {
        this.enable(!1);
      }, AutoCollectNativePerformance.parseEnabled = function (collectExtendedMetrics, customConfig) {
        var disableAll = customConfig.disableAllExtendedMetrics,
          individualOptOuts = customConfig.extendedMetricDisablers;
        if (disableAll) return {
          isEnabled: !1,
          disabledMetrics: {}
        };
        if (individualOptOuts) {
          var optOutsArr = individualOptOuts.split(","),
            disabledMetrics = {};
          if (optOutsArr.length > 0) for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
            var opt = optOutsArr_1[_i];
            disabledMetrics[opt] = !0;
          }
          return typeof collectExtendedMetrics == "object" ? {
            isEnabled: !0,
            disabledMetrics: __assign(__assign({}, collectExtendedMetrics), disabledMetrics)
          } : {
            isEnabled: collectExtendedMetrics,
            disabledMetrics: disabledMetrics
          };
        }
        return typeof collectExtendedMetrics == "boolean" ? {
          isEnabled: collectExtendedMetrics,
          disabledMetrics: {}
        } : {
          isEnabled: !0,
          disabledMetrics: collectExtendedMetrics
        };
      }, AutoCollectNativePerformance.prototype._trackNativeMetrics = function () {
        var shouldSendAll = !0;
        typeof this._isEnabled != "object" && (shouldSendAll = this._isEnabled), shouldSendAll && (this._trackGarbageCollection(), this._trackEventLoop(), this._trackHeapUsage());
      }, AutoCollectNativePerformance.prototype._trackGarbageCollection = function () {
        var t;
        if (!this._disabledMetrics.gc) {
          var gcData = AutoCollectNativePerformance._emitter.getGCData();
          for (var gc in gcData) {
            var metrics = gcData[gc].metrics,
              name_1 = gc + " Garbage Collection Duration",
              stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
            this._client.trackMetric({
              name: name_1,
              value: metrics.total,
              count: metrics.count,
              max: metrics.max,
              min: metrics.min,
              stdDev: stdDev,
              tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, t)
            });
          }
        }
      }, AutoCollectNativePerformance.prototype._trackEventLoop = function () {
        var t;
        if (!this._disabledMetrics.loop) {
          var loopData = AutoCollectNativePerformance._emitter.getLoopData(),
            metrics = loopData.loopUsage;
          if (metrics.count != 0) {
            var name = "Event Loop CPU Time",
              stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
            this._client.trackMetric({
              name: name,
              value: metrics.total,
              count: metrics.count,
              min: metrics.min,
              max: metrics.max,
              stdDev: stdDev,
              tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, t)
            });
          }
        }
      }, AutoCollectNativePerformance.prototype._trackHeapUsage = function () {
        var t, r, n;
        if (!this._disabledMetrics.heap) {
          var memoryUsage = process.memoryUsage(),
            heapUsed = memoryUsage.heapUsed,
            heapTotal = memoryUsage.heapTotal,
            rss = memoryUsage.rss;
          this._client.trackMetric({
            name: "Memory Usage (Heap)",
            value: heapUsed,
            count: 1,
            tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, t)
          }), this._client.trackMetric({
            name: "Memory Total (Heap)",
            value: heapTotal,
            count: 1,
            tagOverrides: (_b = {}, _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, r)
          }), this._client.trackMetric({
            name: "Memory Usage (Non-Heap)",
            value: rss - heapTotal,
            count: 1,
            tagOverrides: (_c = {}, _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, n)
          });
        }
      }, AutoCollectNativePerformance;
    }();
  exports.AutoCollectNativePerformance = AutoCollectNativePerformance;
});
var lY = T(Kp => {
  "use strict";

  var oY = Kp && Kp.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    aY = Kp && Kp.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    };
  Object.defineProperty(Kp, "__esModule", {
    value: !0
  });
  Kp.AzureFunctionsHook = void 0;
  var Logging = x0(),
    CorrelationContextManager_1 = Mp(),
    AzureFunctionsHook = function () {
      function AzureFunctionsHook(client) {
        this._client = client, this._autoGenerateIncomingRequests = !1;
        try {
          this._functionsCoreModule = require("@azure/functions-core");
          var funcProgModel = this._functionsCoreModule.getProgrammingModel();
          funcProgModel.name === "@azure/functions" && funcProgModel.version.startsWith("3.") ? (this._addPreInvocationHook(), this._addPostInvocationHook()) : Logging.warn('AzureFunctionsHook does not support model "' + funcProgModel.name + '" version "' + funcProgModel.version + '"');
        } catch {
          Logging.info("AzureFunctionsHook failed to load, not running in Azure Functions");
        }
      }
      return __name(AzureFunctionsHook, "AzureFunctionsHook"), AzureFunctionsHook.prototype.enable = function (isEnabled) {
        this._autoGenerateIncomingRequests = isEnabled;
      }, AzureFunctionsHook.prototype.dispose = function () {
        this.enable(!1), this._removeInvocationHooks(), this._functionsCoreModule = void 0;
      }, AzureFunctionsHook.prototype._addPreInvocationHook = function () {
        var _this = this;
        this._preInvocationHook || (this._preInvocationHook = this._functionsCoreModule.registerHook("preInvocation", function (preInvocationContext) {
          return __awaiter(_this, void 0, void 0, function () {
            var n, i;
            return aY(this, function (s) {
              ctx = preInvocationContext.invocationContext;
              try {
                extractedContext = CorrelationContextManager_1.CorrelationContextManager.startOperation(ctx), extractedContext && (extractedContext.customProperties.setProperty("InvocationId", ctx.invocationId), ctx.traceContext.attributes && (extractedContext.customProperties.setProperty("ProcessId", ctx.traceContext.attributes.ProcessId), extractedContext.customProperties.setProperty("LogLevel", ctx.traceContext.attributes.LogLevel), extractedContext.customProperties.setProperty("Category", ctx.traceContext.attributes.Category), extractedContext.customProperties.setProperty("HostInstanceId", ctx.traceContext.attributes.HostInstanceId), extractedContext.customProperties.setProperty("AzFuncLiveLogsSessionId", ctx.traceContext.attributes["#AzFuncLiveLogsSessionId"])), preInvocationContext.functionCallback = CorrelationContextManager_1.CorrelationContextManager.wrapCallback(preInvocationContext.functionCallback, extractedContext), this._isHttpTrigger(ctx) && this._autoGenerateIncomingRequests && (preInvocationContext.hookData.appInsightsExtractedContext = extractedContext, preInvocationContext.hookData.appInsightsStartTime = Date.now()));
              } catch (err) {
                return Logging.warn("Failed to propagate context in Azure Functions", err), [2];
              }
              return [2];
            });
          });
        }));
      }, AzureFunctionsHook.prototype._addPostInvocationHook = function () {
        var _this = this;
        this._postInvocationHook || (this._postInvocationHook = this._functionsCoreModule.registerHook("postInvocation", function (postInvocationContext) {
          return __awaiter(_this, void 0, void 0, function () {
            var n,
              i,
              s,
              o,
              c,
              u = this;
            return aY(this, function (f) {
              try {
                this._autoGenerateIncomingRequests && (ctx = postInvocationContext.invocationContext, this._isHttpTrigger(ctx) && (request_1 = postInvocationContext.inputs[0], request_1 && (startTime_1 = postInvocationContext.hookData.appInsightsStartTime || Date.now(), response_1 = this._getAzureFunctionResponse(postInvocationContext, ctx), extractedContext_1 = postInvocationContext.hookData.appInsightsExtractedContext, extractedContext_1 ? CorrelationContextManager_1.CorrelationContextManager.runWithContext(extractedContext_1, function () {
                  _this._createIncomingRequestTelemetry(request_1, response_1, startTime_1, extractedContext_1.operation.parentId);
                }) : this._createIncomingRequestTelemetry(request_1, response_1, startTime_1, null))));
              } catch (err) {
                Logging.warn("Error creating automatic incoming request in Azure Functions", err);
              }
              return [2];
            });
          });
        }));
      }, AzureFunctionsHook.prototype._createIncomingRequestTelemetry = function (request, response, startTime, parentId) {
        var statusCode = 200;
        if (response) for (var _i = 0, _a = [response.statusCode, response.status]; _i < _a.length; _i++) {
          var value = _a[_i];
          if (typeof value == "number" && Number.isInteger(value)) {
            statusCode = value;
            break;
          } else if (typeof value == "string") {
            var parsedVal = parseInt(value);
            if (!isNaN(parsedVal)) {
              statusCode = parsedVal;
              break;
            }
          }
        } else statusCode = void 0;
        this._client.trackRequest({
          name: request.method + " " + request.url,
          resultCode: statusCode,
          success: typeof statusCode == "number" ? 0 < statusCode && statusCode < 400 : void 0,
          url: request.url,
          time: new Date(startTime),
          duration: Date.now() - startTime,
          id: parentId
        }), this._client.flush();
      }, AzureFunctionsHook.prototype._getAzureFunctionResponse = function (postInvocationContext, ctx) {
        var httpOutputBinding = ctx.bindingDefinitions.find(function (b) {
          return b.direction === "out" && b.type.toLowerCase() === "http";
        });
        return httpOutputBinding?.name === "$return" ? postInvocationContext.result : httpOutputBinding && ctx.bindings && ctx.bindings[httpOutputBinding.name] !== void 0 ? ctx.bindings[httpOutputBinding.name] : ctx.res;
      }, AzureFunctionsHook.prototype._isHttpTrigger = function (ctx) {
        return ctx.bindingDefinitions.find(function (b) {
          var _a;
          return ((_a = b.type) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "httptrigger";
        });
      }, AzureFunctionsHook.prototype._removeInvocationHooks = function () {
        this._preInvocationHook && (this._preInvocationHook.dispose(), this._preInvocationHook = void 0), this._postInvocationHook && (this._postInvocationHook.dispose(), this._postInvocationHook = void 0);
      }, AzureFunctionsHook;
    }();
  exports.AzureFunctionsHook = AzureFunctionsHook;
});
var IR = T((vZe, fY) => {
  "use strict";

  var CorrelationIdManager = wm(),
    ConnectionStringParser = aR(),
    Logging = x0(),
    Constants = L0(),
    url = require("url"),
    JsonConfig_1 = o6(),
    Config = function () {
      function Config(setupString) {
        this._endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT, this._mergeConfig();
        var connectionStringEnv = this._connectionString,
          csCode = ConnectionStringParser.parse(setupString),
          csEnv = ConnectionStringParser.parse(connectionStringEnv),
          iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0 ? null : setupString,
          instrumentationKeyEnv = this._instrumentationKey;
        this.instrumentationKey = csCode.instrumentationkey || iKeyCode || csEnv.instrumentationkey || instrumentationKeyEnv;
        var endpoint = "" + (this.endpointUrl || csCode.ingestionendpoint || csEnv.ingestionendpoint || this._endpointBase);
        endpoint.endsWith("/") && (endpoint = endpoint.slice(0, -1)), this.endpointUrl = endpoint + "/v2.1/track", this.maxBatchSize = this.maxBatchSize || 250, this.maxBatchIntervalMs = this.maxBatchIntervalMs || 15e3, this.disableAppInsights = this.disableAppInsights || !1, this.samplingPercentage = this.samplingPercentage || 100, this.correlationIdRetryIntervalMs = this.correlationIdRetryIntervalMs || 30 * 1e3, this.enableWebInstrumentation = this.enableWebInstrumentation || this.enableAutoWebSnippetInjection || !1, this.webInstrumentationConfig = this.webInstrumentationConfig || null, this.enableAutoWebSnippetInjection = this.enableWebInstrumentation, this.correlationHeaderExcludedDomains = this.correlationHeaderExcludedDomains || ["*.core.windows.net", "*.core.chinacloudapi.cn", "*.core.cloudapi.de", "*.core.usgovcloudapi.net", "*.core.microsoft.scloud", "*.core.eaglex.ic.gov"], this.ignoreLegacyHeaders = this.ignoreLegacyHeaders || !1, this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config.ENV_profileQueryEndpoint] || this._endpointBase, this.quickPulseHost = this.quickPulseHost || csCode.liveendpoint || csEnv.liveendpoint || process.env[Config.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST, this.webInstrumentationConnectionString = this.webInstrumentationConnectionString || this._webInstrumentationConnectionString || "", this.webSnippetConnectionString = this.webInstrumentationConnectionString, this.quickPulseHost.match(/^https?:\/\//) && (this.quickPulseHost = new url.URL(this.quickPulseHost).host);
      }
      return __name(Config, "Config"), Object.defineProperty(Config.prototype, "profileQueryEndpoint", {
        get: function () {
          return this._profileQueryEndpoint;
        },
        set: function (endpoint) {
          this._profileQueryEndpoint = endpoint, this.correlationId = CorrelationIdManager.correlationIdPrefix;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(Config.prototype, "instrumentationKey", {
        get: function () {
          return this._instrumentationKey;
        },
        set: function (iKey) {
          Config._validateInstrumentationKey(iKey) || Logging.warn("An invalid instrumentation key was provided. There may be resulting telemetry loss", this.instrumentationKey), this._instrumentationKey = iKey;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(Config.prototype, "webSnippetConnectionString", {
        get: function () {
          return this._webInstrumentationConnectionString;
        },
        set: function (connectionString) {
          this._webInstrumentationConnectionString = connectionString;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(Config.prototype, "webInstrumentationConnectionString", {
        get: function () {
          return this._webInstrumentationConnectionString;
        },
        set: function (connectionString) {
          this._webInstrumentationConnectionString = connectionString;
        },
        enumerable: !1,
        configurable: !0
      }), Config.prototype._mergeConfig = function () {
        var jsonConfig = JsonConfig_1.JsonConfig.getInstance();
        this._connectionString = jsonConfig.connectionString, this._instrumentationKey = jsonConfig.instrumentationKey, this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains, this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs, this.disableAllExtendedMetrics = jsonConfig.disableAllExtendedMetrics, this.disableAppInsights = jsonConfig.disableAppInsights, this.disableStatsbeat = jsonConfig.disableStatsbeat, this.distributedTracingMode = jsonConfig.distributedTracingMode, this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole, this.enableLoggerErrorToTrace = jsonConfig.enableLoggerErrorToTrace, this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies, this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions, this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions, this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics, this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers, this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat, this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance, this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics, this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests, this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation, this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging, this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging, this.enableResendInterval = jsonConfig.enableResendInterval, this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk, this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics, this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks, this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching, this.endpointUrl = jsonConfig.endpointUrl, this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers, this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders, this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs, this.maxBatchSize = jsonConfig.maxBatchSize, this.proxyHttpUrl = jsonConfig.proxyHttpUrl, this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl, this.quickPulseHost = jsonConfig.quickPulseHost, this.samplingPercentage = jsonConfig.samplingPercentage, this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation, this._webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString, this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig, this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc;
      }, Config._validateInstrumentationKey = function (iKey) {
        var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
          regexp = new RegExp(UUID_Regex);
        return regexp.test(iKey);
      }, Config.ENV_azurePrefix = "APPSETTING_", Config.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY", Config.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY", Config.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT", Config.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST", Config;
    }();
  module.exports = Config;
});
var bY = T(l5 => {
  "use strict";

  Object.defineProperty(l5, "__esModule", {
    value: !0
  });
  function K9e(e) {
    return e && typeof e == "object" && "default" in e ? e.default : e;
  }
  l(K9e, "_interopDefault");
  var X9e = K9e(require("util")),
    Y9e = require("os");
  function log(message, ...args) {
    process.stderr.write(`${util.format(message, ...args)}${EOL.EOL}`);
  }
  __name(log, "log");
  var debugEnvVariable = typeof process < "u" && process.env && process.env.DEBUG || void 0,
    enabledString,
    enabledNamespaces = [],
    skippedNamespaces = [],
    debuggers = [];
  debugEnvVariable && enable(debugEnvVariable);
  var debugObj = Object.assign(namespace => createDebugger(namespace), {
    enable: enable,
    enabled: enabled,
    disable: disable,
    log: log
  });
  function enable(namespaces) {
    enabledString = namespaces, enabledNamespaces = [], skippedNamespaces = [];
    let wildcard = /\*/g,
      namespaceList = namespaces.split(",").map(ns => ns.trim().replace(wildcard, ".*?"));
    for (let ns of namespaceList) ns.startsWith("-") ? skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`)) : enabledNamespaces.push(new RegExp(`^${ns}$`));
    for (let instance of debuggers) instance.enabled = enabled(instance.namespace);
  }
  __name(enable, "enable");
  function enabled(namespace) {
    if (namespace.endsWith("*")) return !0;
    for (let skipped of skippedNamespaces) if (skipped.test(namespace)) return !1;
    for (let enabledNamespace of enabledNamespaces) if (enabledNamespace.test(namespace)) return !0;
    return !1;
  }
  __name(enabled, "enabled");
  function disable() {
    let result = enabledString || "";
    return enable(""), result;
  }
  __name(disable, "disable");
  function createDebugger(namespace) {
    let newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy: destroy,
      log: debugObj.log,
      namespace: namespace,
      extend: extend
    });
    function debug(...args) {
      newDebugger.enabled && (args.length > 0 && (args[0] = `${namespace} ${args[0]}`), newDebugger.log(...args));
    }
    return __name(debug, "debug"), debuggers.push(newDebugger), newDebugger;
  }
  __name(createDebugger, "createDebugger");
  function destroy() {
    let index = debuggers.indexOf(this);
    return index >= 0 ? (debuggers.splice(index, 1), !0) : !1;
  }
  __name(destroy, "destroy");
  function extend(namespace) {
    let newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    return newDebugger.log = this.log, newDebugger;
  }
  __name(extend, "extend");
  var registeredLoggers = new Set(),
    logLevelFromEnv = typeof process < "u" && process.env && process.env.AZURE_LOG_LEVEL || void 0,
    azureLogLevel,
    AzureLogger = debug("azure");
  AzureLogger.log = (...args) => {
    debug.log(...args);
  };
  var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  logLevelFromEnv && (isAzureLogLevel(logLevelFromEnv) ? setLogLevel(logLevelFromEnv) : console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`));
  function setLogLevel(level) {
    if (level && !isAzureLogLevel(level)) throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    azureLogLevel = level;
    let enabledNamespaces = [];
    for (let logger of registeredLoggers) shouldEnable(logger) && enabledNamespaces.push(logger.namespace);
    debug.enable(enabledNamespaces.join(","));
  }
  __name(setLogLevel, "setLogLevel");
  function getLogLevel() {
    return azureLogLevel;
  }
  __name(getLogLevel, "getLogLevel");
  var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function createClientLogger(namespace) {
    let clientRootLogger = AzureLogger.extend(namespace);
    return patchLogMethod(AzureLogger, clientRootLogger), {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  __name(createClientLogger, "createClientLogger");
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  __name(patchLogMethod, "patchLogMethod");
  function createLogger(parent, level) {
    let logger = Object.assign(parent.extend(level), {
      level: level
    });
    if (patchLogMethod(parent, logger), shouldEnable(logger)) {
      let enabledNamespaces = debug.disable();
      debug.enable(enabledNamespaces + "," + logger.namespace);
    }
    return registeredLoggers.add(logger), logger;
  }
  __name(createLogger, "createLogger");
  function shouldEnable(logger) {
    return !!(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
  }
  __name(shouldEnable, "shouldEnable");
  function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
  }
  __name(isAzureLogLevel, "isAzureLogLevel");
  l5.AzureLogger = q7;
  l5.createClientLogger = r7e;
  l5.getLogLevel = t7e;
  l5.setLogLevel = _Y;
});
var DR = T(f4 => {
  "use strict";

  Object.defineProperty(f4, "__esModule", {
    value: !0
  });
  var listenersMap = new WeakMap(),
    abortedMap = new WeakMap(),
    AbortSignal = class _AbortSignal {
      static {
        __name(this, "AbortSignal");
      }
      constructor() {
        this.onabort = null, listenersMap.set(this, []), abortedMap.set(this, !1);
      }
      get aborted() {
        if (!abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        return abortedMap.get(this);
      }
      static get none() {
        return new _AbortSignal();
      }
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        listenersMap.get(this).push(listener);
      }
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        let listeners = listenersMap.get(this),
          index = listeners.indexOf(listener);
        index > -1 && listeners.splice(index, 1);
      }
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
  function abortSignal(signal) {
    if (signal.aborted) return;
    signal.onabort && signal.onabort.call(signal);
    let listeners = listenersMap.get(signal);
    listeners && listeners.slice().forEach(listener => {
      listener.call(signal, {
        type: "abort"
      });
    }), abortedMap.set(signal, !0);
  }
  __name(abortSignal, "abortSignal");
  var AbortError = class extends Error {
      static {
        __name(this, "AbortError");
      }
      constructor(message) {
        super(message), this.name = "AbortError";
      }
    },
    AbortController = class {
      static {
        __name(this, "AbortController");
      }
      constructor(parentSignals) {
        if (this._signal = new AbortSignal(), !!parentSignals) {
          Array.isArray(parentSignals) || (parentSignals = arguments);
          for (let parentSignal of parentSignals) parentSignal.aborted ? this.abort() : parentSignal.addEventListener("abort", () => {
            this.abort();
          });
        }
      }
      get signal() {
        return this._signal;
      }
      abort() {
        abortSignal(this._signal);
      }
      static timeout(ms) {
        let signal = new AbortSignal(),
          timer = setTimeout(abortSignal, ms, signal);
        return typeof timer.unref == "function" && timer.unref(), signal;
      }
    };
  f4.AbortController = kR;
  f4.AbortError = LR;
  f4.AbortSignal = u4;
});
var AY = T(bc => {
  "use strict";

  Object.defineProperty(bc, "__esModule", {
    value: !0
  });
  var n7e = DR(),
    CY = require("crypto"),
    MR,
    isNode = typeof process < "u" && !!process.version && !!(!((_a = process.versions) === null || _a === void 0) && _a.node);
  function createAbortablePromise(buildPromise, options) {
    let {
      cleanupBeforeAbort: cleanupBeforeAbort,
      abortSignal: abortSignal,
      abortErrorMsg: abortErrorMsg
    } = options ?? {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new AbortError.AbortError(abortErrorMsg ?? "The operation was aborted."));
      }
      __name(rejectOnAbort, "rejectOnAbort");
      function removeListeners() {
        abortSignal?.removeEventListener("abort", onAbort);
      }
      __name(removeListeners, "removeListeners");
      function onAbort() {
        cleanupBeforeAbort?.(), removeListeners(), rejectOnAbort();
      }
      if (__name(onAbort, "onAbort"), abortSignal?.aborted) return rejectOnAbort();
      try {
        buildPromise(x => {
          removeListeners(), resolve(x);
        }, x => {
          removeListeners(), reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal?.addEventListener("abort", onAbort);
    });
  }
  __name(createAbortablePromise, "createAbortablePromise");
  var StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token,
      {
        abortSignal: abortSignal,
        abortErrorMsg: abortErrorMsg
      } = options ?? {};
    return createAbortablePromise(resolve => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal: abortSignal,
      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
    });
  }
  __name(delay, "delay");
  function getRandomIntegerInclusive(min, max) {
    return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
  }
  __name(getRandomIntegerInclusive, "getRandomIntegerInclusive");
  function isObject(input) {
    return typeof input == "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
  __name(isObject, "isObject");
  function isError(e) {
    if (isObject(e)) {
      let hasName = typeof e.name == "string",
        hasMessage = typeof e.message == "string";
      return hasName && hasMessage;
    }
    return !1;
  }
  __name(isError, "isError");
  function getErrorMessage(e) {
    if (isError(e)) return e.message;
    {
      let stringified;
      try {
        typeof e == "object" && e ? stringified = JSON.stringify(e) : stringified = String(e);
      } catch {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
  __name(getErrorMessage, "getErrorMessage");
  async function computeSha256Hmac(key, stringToSign, encoding) {
    let decodedKey = Buffer.from(key, "base64");
    return createHmac.createHmac("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  __name(computeSha256Hmac, "computeSha256Hmac");
  async function computeSha256Hash(content, encoding) {
    return createHash.createHash("sha256").update(content).digest(encoding);
  }
  __name(computeSha256Hash, "computeSha256Hash");
  function isDefined(thing) {
    return typeof thing < "u" && thing !== null;
  }
  __name(isDefined, "isDefined");
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing != "object") return !1;
    for (let property of properties) if (!objectHasProperty(thing, property)) return !1;
    return !0;
  }
  __name(isObjectWithProperties, "isObjectWithProperties");
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing == "object" && property in thing;
  }
  __name(objectHasProperty, "objectHasProperty");
  bc.computeSha256Hash = u7e;
  bc.computeSha256Hmac = c7e;
  bc.createAbortablePromise = TY;
  bc.delay = o7e;
  bc.getErrorMessage = l7e;
  bc.getRandomIntegerInclusive = a7e;
  bc.isDefined = BR;
  bc.isError = wY;
  bc.isNode = i7e;
  bc.isObject = SY;
  bc.isObjectWithProperties = f7e;
  bc.objectHasProperty = IY;
});
var require_delayed_stream = __commonJSMin((exports, module) => {
  var Stream = require("stream").Stream,
    util = require("util");
  module.exports = DelayedStream;
  function DelayedStream() {
    this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
  }
  __name(DelayedStream, "DelayedStream");
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function (source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) delayedStream[option] = options[option];
    delayedStream.source = source;
    var realEmit = source.emit;
    return source.emit = function () {
      return delayedStream._handleEmit(arguments), realEmit.apply(source, arguments);
    }, source.on("error", function () {}), delayedStream.pauseStream && source.pause(), delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: !0,
    enumerable: !0,
    get: function () {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function () {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function () {
    this._released || this.release(), this.source.resume();
  };
  DelayedStream.prototype.pause = function () {
    this.source.pause();
  };
  DelayedStream.prototype.release = function () {
    this._released = !0, this._bufferedEvents.forEach(function (args) {
      this.emit.apply(this, args);
    }.bind(this)), this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function () {
    var r = Stream.prototype.pipe.apply(this, arguments);
    return this.resume(), r;
  };
  DelayedStream.prototype._handleEmit = function (args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    args[0] === "data" && (this.dataSize += args[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
    if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
      this._maxDataSizeExceeded = !0;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    }
  };
});
var require_combined_stream = __commonJSMin((exports, module) => {
  var util = require("util"),
    Stream = require("stream").Stream,
    DelayedStream = NY();
  module.exports = CombinedStream;
  function CombinedStream() {
    this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
  }
  __name(CombinedStream, "CombinedStream");
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function (options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) combinedStream[option] = options[option];
    return combinedStream;
  };
  CombinedStream.isStreamLike = function (stream) {
    return typeof stream != "function" && typeof stream != "string" && typeof stream != "boolean" && typeof stream != "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function (stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: 1 / 0,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this)), stream = newStream;
      }
      this._handleErrors(stream), this.pauseStreams && stream.pause();
    }
    return this._streams.push(stream), this;
  };
  CombinedStream.prototype.pipe = function (dest, options) {
    return Stream.prototype.pipe.call(this, dest, options), this.resume(), dest;
  };
  CombinedStream.prototype._getNext = function () {
    if (this._currentStream = null, this._insideLoop) {
      this._pendingNext = !0;
      return;
    }
    this._insideLoop = !0;
    try {
      do this._pendingNext = !1, this._realGetNext(); while (this._pendingNext);
    } finally {
      this._insideLoop = !1;
    }
  };
  CombinedStream.prototype._realGetNext = function () {
    var stream = this._streams.shift();
    if (typeof stream > "u") {
      this.end();
      return;
    }
    if (typeof stream != "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function (stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      isStreamLike && (stream.on("data", this._checkDataSize.bind(this)), this._handleErrors(stream)), this._pipeNext(stream);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function (stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this)), stream.pipe(this, {
        end: !1
      });
      return;
    }
    var value = stream;
    this.write(value), this._getNext();
  };
  CombinedStream.prototype._handleErrors = function (stream) {
    var self = this;
    stream.on("error", function (err) {
      self._emitError(err);
    });
  };
  CombinedStream.prototype.write = function (data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function () {
    this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
  };
  CombinedStream.prototype.resume = function () {
    this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
  };
  CombinedStream.prototype.end = function () {
    this._reset(), this.emit("end");
  };
  CombinedStream.prototype.destroy = function () {
    this._reset(), this.emit("close");
  };
  CombinedStream.prototype._reset = function () {
    this.writable = !1, this._streams = [], this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function () {
    if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    }
  };
  CombinedStream.prototype._updateDataSize = function () {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function (stream) {
      stream.dataSize && (self.dataSize += stream.dataSize);
    }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
  };
  CombinedStream.prototype._emitError = function (err) {
    this._reset(), this.emit("error", err);
  };
});
var require_db = __commonJSMin((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: !0
    },
    "application/a2l": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: !0
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: !0
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: !0
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: !0
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: !1
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: !1,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/calendar+json": {
      source: "iana",
      compressible: !0
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: !0
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cfw": {
      source: "iana"
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: !0
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: !0
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: !0
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/csvm+json": {
      source: "iana",
      compressible: !0
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: !0
    },
    "application/dash+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpd"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: !0
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: !0
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: !0,
      extensions: ["ecma", "es"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: !1
    },
    "application/edifact": {
      source: "iana",
      compressible: !1
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/elm+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: !0
    },
    "application/emma+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/epub+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: !0
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/fido.trusted-apps+json": {
      compressible: !0
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: !1
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/geo+json": {
      source: "iana",
      compressible: !0,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: !1,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: !0
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: !1,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: !1,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: !0
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: !0
    },
    "application/jrd+json": {
      source: "iana",
      compressible: !0
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: !0
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: !0,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: !0
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: !0
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/ld+json": {
      source: "iana",
      compressible: !0,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/lost+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: !0
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: !1
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      charset: "UTF-8",
      compressible: !0,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: !0
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/msword": {
      source: "iana",
      compressible: !1,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: !0
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: !1,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: !0
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: !1,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: !1,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana"
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/postscript": {
      source: "iana",
      compressible: !0,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: !0
    },
    "application/problem+json": {
      source: "iana",
      compressible: !0
    },
    "application/problem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: !1
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: !0
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: !0,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: !0
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: !0
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: !0
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: !0,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: !0
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sarif+json": {
      source: "iana",
      compressible: !0
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: !0
    },
    "application/scim+json": {
      source: "iana",
      compressible: !0
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: !0
    },
    "application/senml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: !0
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: !0
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: !0
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["srx"]
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: !0
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: !0
    },
    "application/swid+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: !0
    },
    "application/taxii+json": {
      source: "iana",
      compressible: !0
    },
    "application/td+json": {
      source: "iana",
      compressible: !0
    },
    "application/tei+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: !0
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/toml": {
      compressible: !0,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana"
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: !1,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vcard+json": {
      source: "iana",
      compressible: !0
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: !1,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: !1,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: !1,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: !0,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: !1,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: !1,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: !1,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: !1,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: !1
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana"
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: !1,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: !0,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: !0
    },
    "application/vnd.ms-outlook": {
      compressible: !1,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: !1,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: !0
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: !1,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: !1,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: !1,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: !1,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: !1,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osm"]
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: !1,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: !1,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: !1,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: !0
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: !0
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      compressible: !0,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: !0
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: !0
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: !1,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: !1,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: !1,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: !1,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: !1
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: !1,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: !0,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: !1,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: !0
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: !1,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: !1
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: !0,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: !1,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: !1,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: !0,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: !1,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: !1,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: !0,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: !0,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: !0,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: !0,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: !0,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: !1,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: !0,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: !0,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: !0,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: !0,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: !0
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: !1,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xer"]
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: !0
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: !0,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: !0
    },
    "application/xop+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: !0,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: !0
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: !0
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: !0
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: !0
    },
    "application/yin+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: !1,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: !1,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: !1,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: !1
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: !1,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: !1
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: !1
    },
    "audio/vorbis": {
      source: "iana",
      compressible: !1
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: !1,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: !1,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: !1,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: !1,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: !1,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: !0,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: !0,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: !1,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana"
    },
    "image/avcs": {
      source: "iana"
    },
    "image/avif": {
      source: "iana",
      compressible: !1,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: !0,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: !1,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: !1,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: !1,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: !1,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: !1
    },
    "image/png": {
      source: "iana",
      compressible: !1,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: !1,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: !0,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: !0,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: !0,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: !1
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: ["disposition-notification"]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: !1
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: !0
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: !1
    },
    "message/rfc822": {
      source: "iana",
      compressible: !0,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: !0,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: !0,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: !1,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: !1,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: !0
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: !1,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: !1,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: !1,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: !1,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: !0,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: !1
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: !1
    },
    "multipart/form-data": {
      source: "iana",
      compressible: !1
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: !1
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: !1
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: !0,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: !0
    },
    "text/cmd": {
      compressible: !0
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: !0,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: !0,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: !0
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: !0,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: !0,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: !0,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: !0,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: !0,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: !0,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: !0,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: !0,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: !0,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: !0,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: !0,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: !0
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: !0
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: !0,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: !0,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: !0,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: !0,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: !0,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: !1,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: !1,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: !1,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: !1,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: !1,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: !1,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: !1,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: !1,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: !0
    },
    "x-shader/x-vertex": {
      compressible: !0
    }
  };
});
var require_mime_db = __commonJSMin((exports, module) => {
  module.exports = MY();
});
var require_mime_types = __commonJSMin(exports => {
  "use strict";

  var db = FY(),
    extname = require("path").extname,
    EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/,
    TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = {
    lookup: charset
  };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type != "string") return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type),
      mime = match && db[match[1].toLowerCase()];
    return mime && mime.charset ? mime.charset : match && TEXT_TYPE_REGEXP.test(match[1]) ? "UTF-8" : !1;
  }
  __name(charset, "charset");
  function contentType(str) {
    if (!str || typeof str != "string") return !1;
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) return !1;
    if (mime.indexOf("charset") === -1) {
      var charset = exports.charset(mime);
      charset && (mime += "; charset=" + charset.toLowerCase());
    }
    return mime;
  }
  __name(contentType, "contentType");
  function extension(type) {
    if (!type || typeof type != "string") return !1;
    var match = EXTRACT_TYPE_REGEXP.exec(type),
      exts = match && exports.extensions[match[1].toLowerCase()];
    return !exts || !exts.length ? !1 : exts[0];
  }
  __name(extension, "extension");
  function lookup(path) {
    if (!path || typeof path != "string") return !1;
    var extension = extname("x." + path).toLowerCase().substr(1);
    return extension && exports.types[extension] || !1;
  }
  __name(lookup, "lookup");
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(__name(function (type) {
      var mime = db[type],
        exts = mime.extensions;
      if (!(!exts || !exts.length)) {
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i];
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source),
              to = preference.indexOf(mime.source);
            if (types[extension] !== "application/octet-stream" && (from > to || from === to && types[extension].substr(0, 12) === "application/")) continue;
          }
          types[extension] = type;
        }
      }
    }, "forEachMimeType"));
  }
  __name(populateMaps, "populateMaps");
});
var require_defer = __commonJSMin((exports, module) => {
  module.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    nextTick ? nextTick(fn) : setTimeout(fn, 0);
  }
  __name(defer, "defer");
});
var require_async = __commonJSMin((exports, module) => {
  var defer = $Y();
  module.exports = async;
  function async(callback) {
    var isAsync = !1;
    return defer(function () {
      isAsync = !0;
    }), __name(function (err, result) {
      isAsync ? callback(err, result) : defer(__name(function () {
        callback(err, result);
      }, "nextTick_callback"));
    }, "async_callback");
  }
  __name(async, "async");
});
var require_abort = __commonJSMin((exports, module) => {
  module.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state)), state.jobs = {};
  }
  __name(abort, "abort");
  function clean(key) {
    typeof this.jobs[key] == "function" && this.jobs[key]();
  }
  __name(clean, "clean");
});
var require_iterate = __commonJSMin((exports, module) => {
  var async = FR(),
    abort = UR();
  module.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state.keyedList ? state.keyedList[state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function (error, output) {
      key in state.jobs && (delete state.jobs[key], error ? abort(state) : state.results[key] = output, callback(error, state.results));
    });
  }
  __name(iterate, "iterate");
  function runJob(iterator, key, item, callback) {
    var aborter;
    return iterator.length == 2 ? aborter = iterator(item, async(callback)) : aborter = iterator(item, key, async(callback)), aborter;
  }
  __name(runJob, "runJob");
});
var require_state = __commonJSMin((exports, module) => {
  module.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list),
      initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
    return sortMethod && initState.keyedList.sort(isNamedList ? sortMethod : function (a, b) {
      return sortMethod(list[a], list[b]);
    }), initState;
  }
  __name(state, "state");
});
var require_terminator = __commonJSMin((exports, module) => {
  var abort = UR(),
    async = FR();
  module.exports = terminator;
  function terminator(callback) {
    Object.keys(this.jobs).length && (this.index = this.size, abort(this), async(callback)(null, this.results));
  }
  __name(terminator, "terminator");
});
var require_parallel = __commonJSMin((exports, module) => {
  var iterate = qR(),
    initState = jR(),
    terminator = HR();
  module.exports = parallel;
  function parallel(list, iterator, callback) {
    for (var state = initState(list); state.index < (state.keyedList || list).length;) iterate(list, iterator, state, function (error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      if (Object.keys(state.jobs).length === 0) {
        callback(null, state.results);
        return;
      }
    }), state.index++;
    return terminator.bind(state, callback);
  }
  __name(parallel, "parallel");
});
var require_serialOrdered = __commonJSMin((exports, module) => {
  var iterate = qR(),
    initState = jR(),
    terminator = HR();
  module.exports = serialOrdered;
  module.exports.ascending = ascending;
  module.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    return iterate(list, iterator, state, __name(function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      if (state.index++, state.index < (state.keyedList || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    }, "iteratorHandler")), terminator.bind(state, callback);
  }
  __name(serialOrdered, "serialOrdered");
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  __name(ascending, "ascending");
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  __name(descending, "descending");
});
var require_serial = __commonJSMin((exports, module) => {
  var serialOrdered = $R();
  module.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
  __name(serial, "serial");
});
var require_asynckit = __commonJSMin((exports, module) => {
  module.exports = {
    parallel: ZY(),
    serial: rQ(),
    serialOrdered: $R()
  };
});
var require_populate = __commonJSMin((exports, module) => {
  module.exports = function (dst, src) {
    return Object.keys(src).forEach(function (prop) {
      dst[prop] = dst[prop] || src[prop];
    }), dst;
  };
});
var require_form_data = __commonJSMin((exports, module) => {
  var CombinedStream = DY(),
    util = require("util"),
    path = require("path"),
    http = require("http"),
    https = require("https"),
    parseUrl = require("url").parse,
    fs = require("fs"),
    Stream = require("stream").Stream,
    mime = jY(),
    asynckit = iQ(),
    populate = oQ();
  module.exports = FormData;
  util.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) return new FormData(options);
    this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], CombinedStream.call(this), options = options || {};
    for (var option in options) this[option] = options[option];
  }
  __name(FormData, "FormData");
  FormData.LINE_BREAK = `\r
`;
  FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData.prototype.append = function (field, value, options) {
    options = options || {}, typeof options == "string" && (options = {
      filename: options
    });
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number" && (value = "" + value), util.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options),
      footer = this._multiPartFooter();
    append(header), append(value), append(footer), this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function (header, value, options) {
    var valueLength = 0;
    options.knownLength != null ? valueLength += +options.knownLength : Buffer.isBuffer(value) ? valueLength = value.length : typeof value == "string" && (valueLength = Buffer.byteLength(value)), this._valueLength += valueLength, this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length, !(!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) && (options.knownLength || this._valuesToMeasure.push(value));
  };
  FormData.prototype._lengthRetriever = function (value, callback) {
    value.hasOwnProperty("fd") ? value.end != null && value.end != 1 / 0 && value.start != null ? callback(null, value.end + 1 - (value.start ? value.start : 0)) : fs.stat(value.path, function (err, stat) {
      var fileSize;
      if (err) {
        callback(err);
        return;
      }
      fileSize = stat.size - (value.start ? value.start : 0), callback(null, fileSize);
    }) : value.hasOwnProperty("httpVersion") ? callback(null, +value.headers["content-length"]) : value.hasOwnProperty("httpModule") ? (value.on("response", function (response) {
      value.pause(), callback(null, +response.headers["content-length"]);
    }), value.resume()) : callback("Unknown stream");
  };
  FormData.prototype._multiPartHeader = function (field, value, options) {
    if (typeof options.header == "string") return options.header;
    var contentDisposition = this._getContentDisposition(value, options),
      contentType = this._getContentType(value, options),
      contents = "",
      headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
    typeof options.header == "object" && populate(headers, options.header);
    var header;
    for (var prop in headers) headers.hasOwnProperty(prop) && (header = headers[prop], header != null && (Array.isArray(header) || (header = [header]), header.length && (contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK)));
    return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
  };
  FormData.prototype._getContentDisposition = function (value, options) {
    var filename, contentDisposition;
    return typeof options.filepath == "string" ? filename = path.normalize(options.filepath).replace(/\\/g, "/") : options.filename || value.name || value.path ? filename = path.basename(options.filename || value.name || value.path) : value.readable && value.hasOwnProperty("httpVersion") && (filename = path.basename(value.client._httpMessage.path || "")), filename && (contentDisposition = 'filename="' + filename + '"'), contentDisposition;
  };
  FormData.prototype._getContentType = function (value, options) {
    var contentType = options.contentType;
    return !contentType && value.name && (contentType = mime.lookup(value.name)), !contentType && value.path && (contentType = mime.lookup(value.path)), !contentType && value.readable && value.hasOwnProperty("httpVersion") && (contentType = value.headers["content-type"]), !contentType && (options.filepath || options.filename) && (contentType = mime.lookup(options.filepath || options.filename)), !contentType && typeof value == "object" && (contentType = FormData.DEFAULT_CONTENT_TYPE), contentType;
  };
  FormData.prototype._multiPartFooter = function () {
    return function (next) {
      var footer = FormData.LINE_BREAK,
        lastPart = this._streams.length === 0;
      lastPart && (footer += this._lastBoundary()), next(footer);
    }.bind(this);
  };
  FormData.prototype._lastBoundary = function () {
    return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function (userHeaders) {
    var header,
      formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
    for (header in userHeaders) userHeaders.hasOwnProperty(header) && (formHeaders[header.toLowerCase()] = userHeaders[header]);
    return formHeaders;
  };
  FormData.prototype.setBoundary = function (boundary) {
    this._boundary = boundary;
  };
  FormData.prototype.getBoundary = function () {
    return this._boundary || this._generateBoundary(), this._boundary;
  };
  FormData.prototype.getBuffer = function () {
    for (var dataBuffer = new Buffer.alloc(0), boundary = this.getBoundary(), i = 0, len = this._streams.length; i < len; i++) typeof this._streams[i] != "function" && (Buffer.isBuffer(this._streams[i]) ? dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]) : dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]), (typeof this._streams[i] != "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) && (dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)])));
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData.prototype._generateBoundary = function () {
    for (var boundary = "--------------------------", i = 0; i < 24; i++) boundary += Math.floor(Math.random() * 10).toString(16);
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function () {
    var knownLength = this._overheadLength + this._valueLength;
    return this._streams.length && (knownLength += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), knownLength;
  };
  FormData.prototype.hasKnownLength = function () {
    var hasKnownLength = !0;
    return this._valuesToMeasure.length && (hasKnownLength = !1), hasKnownLength;
  };
  FormData.prototype.getLength = function (cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length && (knownLength += this._lastBoundary().length), !this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function (length) {
        knownLength += length;
      }), cb(null, knownLength);
    });
  };
  FormData.prototype.submit = function (params, cb) {
    var request,
      options,
      defaults = {
        method: "post"
      };
    return typeof params == "string" ? (params = parseUrl(params), options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults)) : (options = populate(params, defaults), options.port || (options.port = options.protocol == "https:" ? 443 : 80)), options.headers = this.getHeaders(params.headers), options.protocol == "https:" ? request = https.request(options) : request = http.request(options), this.getLength(function (err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length && request.setHeader("Content-Length", length), this.pipe(request), cb) {
        var onResponse,
          callback = __name(function (error, responce) {
            return request.removeListener("error", callback), request.removeListener("response", onResponse), cb.call(this, error, responce);
          }, "callback");
        onResponse = callback.bind(this, null), request.on("error", callback), request.on("response", onResponse);
      }
    }.bind(this)), request;
  };
  FormData.prototype._error = function (err) {
    this.error || (this.error = err, this.pause(), this.emit("error", err));
  };
  FormData.prototype.toString = function () {
    return "[object FormData]";
  };
});
var uQ = T(KR => {
  "use strict";

  Object.defineProperty(KR, "__esModule", {
    value: !0
  });
  function promisify(fn) {
    return function (req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          err ? reject(err) : resolve(rtn);
        });
      });
    };
  }
  __name(promisify, "promisify");
  exports.default = promisify;
});
var QR = T((YR, dQ) => {
  "use strict";

  var fQ = YR && YR.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      };
    },
    events_1 = require("events"),
    debug_1 = __importDefault(Gu()),
    promisify_1 = __importDefault(uQ()),
    debug = debug_1.default("agent-base");
  function isAgent(v) {
    return !!v && typeof v.addRequest == "function";
  }
  __name(isAgent, "isAgent");
  function isSecureEndpoint() {
    let {
      stack: stack
    } = new Error();
    return typeof stack != "string" ? !1 : stack.split(`
`).some(l => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  __name(isSecureEndpoint, "isSecureEndpoint");
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  __name(createAgent, "createAgent");
  (function (createAgent) {
    class Agent extends events_1.EventEmitter {
      static {
        __name(this, "Agent");
      }
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        typeof callback == "function" ? this.callback = callback : callback && (opts = callback), this.timeout = null, opts && typeof opts.timeout == "number" && (this.timeout = opts.timeout), this.maxFreeSockets = 1, this.maxSockets = 1, this.maxTotalSockets = 1 / 0, this.sockets = {}, this.freeSockets = {}, this.requests = {}, this.options = {};
      }
      get defaultPort() {
        return typeof this.explicitDefaultPort == "number" ? this.explicitDefaultPort : isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        return typeof this.explicitProtocol == "string" ? this.explicitProtocol : isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        let opts = Object.assign({}, _opts);
        typeof opts.secureEndpoint != "boolean" && (opts.secureEndpoint = isSecureEndpoint()), opts.host == null && (opts.host = "localhost"), opts.port == null && (opts.port = opts.secureEndpoint ? 443 : 80), opts.protocol == null && (opts.protocol = opts.secureEndpoint ? "https:" : "http:"), opts.host && opts.path && delete opts.path, delete opts.agent, delete opts.hostname, delete opts._defaultAgent, delete opts.defaultPort, delete opts.createConnection, req._last = !0, req.shouldKeepAlive = !1;
        let timedOut = !1,
          timeoutId = null,
          timeoutMs = opts.timeout || this.timeout,
          onerror = __name(err => {
            req._hadError || (req.emit("error", err), req._hadError = !0);
          }, "onerror"),
          ontimeout = __name(() => {
            timeoutId = null, timedOut = !0;
            let err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT", onerror(err);
          }, "ontimeout"),
          callbackError = __name(err => {
            timedOut || (timeoutId !== null && (clearTimeout(timeoutId), timeoutId = null), onerror(err));
          }, "callbackError"),
          onsocket = __name(socket => {
            if (timedOut) return;
            if (timeoutId != null && (clearTimeout(timeoutId), timeoutId = null), isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name), socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              }), req.onSocket(socket);
              return;
            }
            let err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          }, "onsocket");
        if (typeof this.callback != "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        this.promisifiedCallback || (this.callback.length >= 3 ? (debug("Converting legacy callback function to promise"), this.promisifiedCallback = promisify_1.default(this.callback)) : this.promisifiedCallback = this.callback), typeof timeoutMs == "number" && timeoutMs > 0 && (timeoutId = setTimeout(ontimeout, timeoutMs)), "port" in opts && typeof opts.port != "number" && (opts.port = Number(opts.port));
        try {
          debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`), Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug("Freeing socket %o %o", socket.constructor.name, opts), socket.destroy();
      }
      destroy() {
        debug("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent.Agent = Agent, createAgent.prototype = createAgent.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module.exports = createAgent;
});
var pQ = T(m4 => {
  "use strict";

  var J7e = m4 && m4.__importDefault || function (e) {
    return e && e.__esModule ? e : {
      default: e
    };
  };
  Object.defineProperty(m4, "__esModule", {
    value: !0
  });
  var debug_1 = __importDefault(Gu()),
    debug = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0,
        buffers = [];
      function read() {
        let b = socket.read();
        b ? ondata(b) : socket.once("readable", read);
      }
      __name(read, "read");
      function cleanup() {
        socket.removeListener("end", onend), socket.removeListener("error", onerror), socket.removeListener("close", onclose), socket.removeListener("readable", read);
      }
      __name(cleanup, "cleanup");
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      __name(onclose, "onclose");
      function onend() {
        debug("onend");
      }
      __name(onend, "onend");
      function onerror(err) {
        cleanup(), debug("onerror %o", err), reject(err);
      }
      __name(onerror, "onerror");
      function ondata(b) {
        buffers.push(b), buffersLength += b.length;
        let buffered = Buffer.concat(buffers, buffersLength);
        if (buffered.indexOf(`\r
\r
`) === -1) {
          debug("have not received end of HTTP headers yet..."), read();
          return;
        }
        let firstLine = buffered.toString("ascii", 0, buffered.indexOf(`\r
`)),
          statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine), resolve({
          statusCode: statusCode,
          buffered: buffered
        });
      }
      __name(ondata, "ondata"), socket.on("error", onerror), socket.on("close", onclose), socket.on("end", onend), read();
    });
  }
  __name(parseProxyResponse, "parseProxyResponse");
  exports.default = parseProxyResponse;
});
var gQ = T($m => {
  "use strict";

  var rxe = $m && $m.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    u5 = $m && $m.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      };
    };
  Object.defineProperty($m, "__esModule", {
    value: !0
  });
  var net_1 = __importDefault(require("net")),
    tls_1 = __importDefault(require("tls")),
    url_1 = __importDefault(require("url")),
    assert_1 = __importDefault(require("assert")),
    debug_1 = __importDefault(Gu()),
    agent_base_1 = QR(),
    parse_proxy_response_1 = __importDefault(pQ()),
    debug = debug_1.default("https-proxy-agent:agent"),
    HttpsProxyAgent = class extends agent_base_1.Agent {
      static {
        __name(this, "HttpsProxyAgent");
      }
      constructor(_opts) {
        let opts;
        if (typeof _opts == "string" ? opts = url_1.default.parse(_opts) : opts = _opts, !opts) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        debug("creating new HttpsProxyAgent instance: %o", opts), super(opts);
        let proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol), proxy.host = proxy.hostname || proxy.host, typeof proxy.port == "string" && (proxy.port = parseInt(proxy.port, 10)), !proxy.port && proxy.host && (proxy.port = this.secureProxy ? 443 : 80), this.secureProxy && !("ALPNProtocols" in proxy) && (proxy.ALPNProtocols = ["http 1.1"]), proxy.host && proxy.path && (delete proxy.path, delete proxy.pathname), this.proxy = proxy;
      }
      callback(req, opts) {
        return rxe(this, void 0, void 0, function* () {
          let {
              proxy: proxy,
              secureProxy: secureProxy
            } = this,
            socket;
          secureProxy ? (debug("Creating `tls.Socket`: %o", proxy), socket = tls_1.default.connect(proxy)) : (debug("Creating `net.Socket`: %o", proxy), socket = net_1.default.connect(proxy));
          let headers = Object.assign({}, proxy.headers),
            payload = `CONNECT ${`${opts.host}:${opts.port}`} HTTP/1.1\r
`;
          proxy.auth && (headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          let {
            host: host,
            port: port,
            secureEndpoint: secureEndpoint
          } = opts;
          isDefaultPort(port, secureEndpoint) || (host += `:${port}`), headers.Host = host, headers.Connection = "close";
          for (let name of Object.keys(headers)) payload += `${name}: ${headers[name]}\r
`;
          let proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          let {
            statusCode: statusCode,
            buffered: buffered
          } = yield proxyResponsePromise;
          if (statusCode === 200) {
            if (req.once("socket", resume), opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              let servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket: socket,
                servername: servername
              }));
            }
            return socket;
          }
          socket.destroy();
          let fakeSocket = new net_1.default.Socket({
            writable: !1
          });
          return fakeSocket.readable = !0, req.once("socket", s => {
            debug("replaying proxy buffer for failed request"), assert_1.default(s.listenerCount("data") > 0), s.push(buffered), s.push(null);
          }), fakeSocket;
        });
      }
    };
  exports.default = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  __name(resume, "resume");
  function isDefaultPort(port, secure) {
    return !!(!secure && port === 80 || secure && port === 443);
  }
  __name(isDefaultPort, "isDefaultPort");
  function isHTTPS(protocol) {
    return typeof protocol == "string" ? /^https:?$/i.test(protocol) : !1;
  }
  __name(isHTTPS, "isHTTPS");
  function omit(obj, ...keys) {
    let ret = {},
      key;
    for (key in obj) keys.includes(key) || (ret[key] = obj[key]);
    return ret;
  }
  __name(omit, "omit");
});
var yQ = T((tN, _Q) => {
  "use strict";

  var dxe = tN && tN.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      };
    },
    agent_1 = __importDefault(gQ());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  __name(createHttpsProxyAgent, "createHttpsProxyAgent");
  (function (createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default, createHttpsProxyAgent.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module.exports = createHttpsProxyAgent;
});
var vQ = T(rN => {
  "use strict";

  Object.defineProperty(rN, "__esModule", {
    value: !0
  });
  function once(emitter, name, {
    signal: signal
  } = {}) {
    return new Promise((resolve, reject) => {
      function cleanup() {
        signal?.removeEventListener("abort", cleanup), emitter.removeListener(name, onEvent), emitter.removeListener("error", onError);
      }
      __name(cleanup, "cleanup");
      function onEvent(...args) {
        cleanup(), resolve(args);
      }
      __name(onEvent, "onEvent");
      function onError(err) {
        cleanup(), reject(err);
      }
      __name(onError, "onError"), signal?.addEventListener("abort", cleanup), emitter.on(name, onEvent), emitter.on("error", onError);
    });
  }
  __name(once, "once");
  exports.default = once;
});
var xQ = T(Vm => {
  "use strict";

  var mxe = Vm && Vm.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    g4 = Vm && Vm.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      };
    };
  Object.defineProperty(Vm, "__esModule", {
    value: !0
  });
  var net_1 = __importDefault(require("net")),
    tls_1 = __importDefault(require("tls")),
    url_1 = __importDefault(require("url")),
    debug_1 = __importDefault(Gu()),
    once_1 = __importDefault(vQ()),
    agent_base_1 = QR(),
    debug = (0, debug_1.default)("http-proxy-agent");
  function isHTTPS(protocol) {
    return typeof protocol == "string" ? /^https:?$/i.test(protocol) : !1;
  }
  __name(isHTTPS, "isHTTPS");
  var HttpProxyAgent = class extends agent_base_1.Agent {
    static {
      __name(this, "HttpProxyAgent");
    }
    constructor(_opts) {
      let opts;
      if (typeof _opts == "string" ? opts = url_1.default.parse(_opts) : opts = _opts, !opts) throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      debug("Creating new HttpProxyAgent instance: %o", opts), super(opts);
      let proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol), proxy.host = proxy.hostname || proxy.host, typeof proxy.port == "string" && (proxy.port = parseInt(proxy.port, 10)), !proxy.port && proxy.host && (proxy.port = this.secureProxy ? 443 : 80), proxy.host && proxy.path && (delete proxy.path, delete proxy.pathname), this.proxy = proxy;
    }
    callback(req, opts) {
      return mxe(this, void 0, void 0, function* () {
        let {
            proxy: proxy,
            secureProxy: secureProxy
          } = this,
          parsed = url_1.default.parse(req.path);
        parsed.protocol || (parsed.protocol = "http:"), parsed.hostname || (parsed.hostname = opts.hostname || opts.host || null), parsed.port == null && typeof opts.port && (parsed.port = String(opts.port)), parsed.port === "80" && (parsed.port = ""), req.path = url_1.default.format(parsed), proxy.auth && req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
        let socket;
        if (secureProxy ? (debug("Creating `tls.Socket`: %o", proxy), socket = tls_1.default.connect(proxy)) : (debug("Creating `net.Socket`: %o", proxy), socket = net_1.default.connect(proxy)), req._header) {
          let first, endOfHeaders;
          debug("Regenerating stored HTTP header string for request"), req._header = null, req._implicitHeader(), req.output && req.output.length > 0 ? (debug("Patching connection write() output buffer with updated header"), first = req.output[0], endOfHeaders = first.indexOf(`\r
\r
`) + 4, req.output[0] = req._header + first.substring(endOfHeaders), debug("Output buffer: %o", req.output)) : req.outputData && req.outputData.length > 0 && (debug("Patching connection write() output buffer with updated header"), first = req.outputData[0].data, endOfHeaders = first.indexOf(`\r
\r
`) + 4, req.outputData[0].data = req._header + first.substring(endOfHeaders), debug("Output buffer: %o", req.outputData[0].data));
        }
        return yield (0, once_1.default)(socket, "connect"), socket;
      });
    }
  };
  exports.default = HttpProxyAgent;
});
var EQ = T((aN, bQ) => {
  "use strict";

  var bxe = aN && aN.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      };
    },
    agent_1 = __importDefault(xQ());
  function createHttpProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  __name(createHttpProxyAgent, "createHttpProxyAgent");
  (function (createHttpProxyAgent) {
    createHttpProxyAgent.HttpProxyAgent = agent_1.default, createHttpProxyAgent.prototype = agent_1.default.prototype;
  })(createHttpProxyAgent || (createHttpProxyAgent = {}));
  module.exports = createHttpProxyAgent;
});
var CQ = T(W7 => {
  "use strict";

  Object.defineProperty(W7, "__esModule", {
    value: !0
  });
  var knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    return options.span && (context = context.setValue(knownContextKeys.span, options.span)), options.namespace && (context = context.setValue(knownContextKeys.namespace, options.namespace)), context;
  }
  __name(createTracingContext, "createTracingContext");
  var TracingContextImpl = class _TracingContextImpl {
    static {
      __name(this, "TracingContextImpl");
    }
    constructor(initialContext) {
      this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : new Map();
    }
    setValue(key, value) {
      let newContext = new _TracingContextImpl(this);
      return newContext._contextMap.set(key, value), newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      let newContext = new _TracingContextImpl(this);
      return newContext._contextMap.delete(key), newContext;
    }
  };
  function createDefaultTracingSpan() {
    return {
      end: () => {},
      isRecording: () => !1,
      recordException: () => {},
      setAttribute: () => {},
      setStatus: () => {}
    };
  }
  __name(createDefaultTracingSpan, "createDefaultTracingSpan");
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => ({}),
      parseTraceparentHeader: () => {},
      startSpan: (_name, spanOptions) => ({
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({
          parentContext: spanOptions.tracingContext
        })
      }),
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  __name(createDefaultInstrumenter, "createDefaultInstrumenter");
  var instrumenterImplementation;
  function useInstrumenter(instrumenter) {
    instrumenterImplementation = instrumenter;
  }
  __name(useInstrumenter, "useInstrumenter");
  function getInstrumenter() {
    return instrumenterImplementation || (instrumenterImplementation = createDefaultInstrumenter()), instrumenterImplementation;
  }
  __name(getInstrumenter, "getInstrumenter");
  function createTracingClient(options) {
    let {
      namespace: namespace,
      packageName: packageName,
      packageVersion: packageVersion
    } = options;
    function startSpan(name, operationOptions, spanOptions) {
      var m;
      let startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), {
          packageName: packageName,
          packageVersion: packageVersion,
          tracingContext: (_a = operationOptions?.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext
        })),
        tracingContext = startSpanResult.tracingContext,
        span = startSpanResult.span;
      tracingContext.getValue(knownContextKeys.namespace) || (tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace)), span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
      let updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: Object.assign(Object.assign({}, operationOptions?.tracingOptions), {
          tracingContext: tracingContext
        })
      });
      return {
        span: span,
        updatedOptions: updatedOptions
      };
    }
    __name(startSpan, "startSpan");
    async function withSpan(name, operationOptions, callback, spanOptions) {
      let {
        span: span,
        updatedOptions: updatedOptions
      } = startSpan(name, operationOptions, spanOptions);
      try {
        let result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        return span.setStatus({
          status: "success"
        }), result;
      } catch (err) {
        throw span.setStatus({
          status: "error",
          error: err
        }), err;
      } finally {
        span.end();
      }
    }
    __name(withSpan, "withSpan");
    function withContext(context, callback, ...callbackArgs) {
      return getInstrumenter().withContext(context, callback, ...callbackArgs);
    }
    __name(withContext, "withContext");
    function parseTraceparentHeader(traceparentHeader) {
      return getInstrumenter().parseTraceparentHeader(traceparentHeader);
    }
    __name(parseTraceparentHeader, "parseTraceparentHeader");
    function createRequestHeaders(tracingContext) {
      return getInstrumenter().createRequestHeaders(tracingContext);
    }
    return __name(createRequestHeaders, "createRequestHeaders"), {
      startSpan: startSpan,
      withSpan: withSpan,
      withContext: withContext,
      parseTraceparentHeader: parseTraceparentHeader,
      createRequestHeaders: createRequestHeaders
    };
  }
  __name(createTracingClient, "createTracingClient");
  W7.createTracingClient = wxe;
  W7.useInstrumenter = Sxe;
});
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (TQ.crypto.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto,
  rnds8Pool,
  poolPtr,
  init_rng = __esmMin(() => {
    import_crypto = Ns(require("crypto")), rnds8Pool = new Uint8Array(256), poolPtr = rnds8Pool.length;
    __name(rng, "rng");
  });
var regex_default,
  init_regex = __esmMin(() => {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  });
function validate(uuid) {
  return typeof uuid == "string" && regex_default.test(uuid);
}
var validate_default,
  init_validate = __esmMin(() => {
    init_regex();
    __name(validate, "validate");
    validate_default = validate;
  });
function stringify(arr, offset = 0) {
  let uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) throw TypeError("Stringified UUID is invalid");
  return uuid;
}
var byteToHex,
  stringify_default,
  init_stringify = __esmMin(() => {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
    __name(stringify, "stringify");
    stringify_default = stringify;
  });
function v1(options, buf, offset) {
  let i = buf && offset || 0,
    b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId,
    clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    let seedBytes = options.random || (options.rng || rng)();
    node == null && (node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]]), clockseq == null && (clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383);
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now(),
    nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1,
    dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0 && (clockseq = clockseq + 1 & 16383), (dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0 && (nsecs = 0), nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = msecs, _lastNSecs = nsecs, _clockseq = clockseq, msecs += 122192928e5;
  let tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255, b[i++] = tl >>> 16 & 255, b[i++] = tl >>> 8 & 255, b[i++] = tl & 255;
  let tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255, b[i++] = tmh & 255, b[i++] = tmh >>> 24 & 15 | 16, b[i++] = tmh >>> 16 & 255, b[i++] = clockseq >>> 8 | 128, b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) b[i + n] = node[n];
  return buf || stringify_default(b);
}
var _nodeId,
  _clockseq,
  _lastMSecs,
  _lastNSecs,
  v1_default,
  init_v1 = __esmMin(() => {
    init_rng();
    init_stringify();
    _lastMSecs = 0, _lastNSecs = 0;
    __name(v1, "v1");
    v1_default = v1;
  });
function parse(uuid) {
  if (!validate_default(uuid)) throw TypeError("Invalid UUID");
  let v,
    arr = new Uint8Array(16);
  return arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24, arr[1] = v >>> 16 & 255, arr[2] = v >>> 8 & 255, arr[3] = v & 255, arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, arr[5] = v & 255, arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, arr[7] = v & 255, arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, arr[9] = v & 255, arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, arr[11] = v / 4294967296 & 255, arr[12] = v >>> 24 & 255, arr[13] = v >>> 16 & 255, arr[14] = v >>> 8 & 255, arr[15] = v & 255, arr;
}
var parse_default,
  init_parse = __esmMin(() => {
    init_validate();
    __name(parse, "parse");
    parse_default = parse;
  });
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  let bytes = [];
  for (let i = 0; i < str.length; ++i) bytes.push(str.charCodeAt(i));
  return bytes;
}
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value == "string" && (value = stringToBytes(value)), typeof namespace == "string" && (namespace = parse_default(namespace)), namespace.length !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let bytes = new Uint8Array(16 + value.length);
    if (bytes.set(namespace), bytes.set(value, namespace.length), bytes = hashfunc(bytes), bytes[6] = bytes[6] & 15 | version, bytes[8] = bytes[8] & 63 | 128, buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) buf[offset + i] = bytes[i];
      return buf;
    }
    return stringify_default(bytes);
  }
  __name(generateUUID, "generateUUID");
  try {
    generateUUID.name = name;
  } catch {}
  return generateUUID.DNS = DNS, generateUUID.URL = URL, generateUUID;
}
var DNS,
  URL,
  init_v35 = __esmMin(() => {
    init_stringify();
    init_parse();
    __name(stringToBytes, "stringToBytes");
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    __name(v35_default, "default");
  });
function md5(bytes) {
  return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : typeof bytes == "string" && (bytes = Buffer.from(bytes, "utf8")), RQ.crypto.createHash("md5").update(bytes).digest();
}
var import_crypto,
  md5_default,
  init_md5 = __esmMin(() => {
    import_crypto = Ns(require("crypto"));
    __name(md5, "md5");
    md5_default = md5;
  });
var v3,
  v3_default,
  init_v3 = __esmMin(() => {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default), v3_default = v3;
  });
function v4(options, buf, offset) {
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default,
  init_v4 = __esmMin(() => {
    init_rng();
    init_stringify();
    __name(v4, "v4");
    v4_default = v4;
  });
function sha1(bytes) {
  return Array.isArray(bytes) ? bytes = Buffer.from(bytes) : typeof bytes == "string" && (bytes = Buffer.from(bytes, "utf8")), BQ.crypto.createHash("sha1").update(bytes).digest();
}
var import_crypto,
  sha1_default,
  init_sha1 = __esmMin(() => {
    import_crypto = Ns(require("crypto"));
    __name(sha1, "sha1");
    sha1_default = sha1;
  });
var v5,
  v5_default,
  init_v5 = __esmMin(() => {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default), v5_default = v5;
  });
var nil_default,
  init_nil = __esmMin(() => {
    nil_default = "00000000-0000-0000-0000-000000000000";
  });
function version(uuid) {
  if (!validate_default(uuid)) throw TypeError("Invalid UUID");
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default,
  init_version = __esmMin(() => {
    init_validate();
    __name(version, "version");
    version_default = version;
  });
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esmMin(() => {
  init_v1();
  init_v3();
  init_v4();
  init_v5();
  init_nil();
  init_version();
  init_validate();
  init_stringify();
  init_parse();
});
var BZ = T(ea => {
  "use strict";

  Object.defineProperty(ea, "__esModule", {
    value: !0
  });
  var rZ = bY(),
    Lf = AY(),
    qxe = require("os"),
    C4 = DR(),
    jxe = cQ(),
    Hxe = yQ(),
    $xe = EQ(),
    Vxe = CQ(),
    Gxe = require("util"),
    zxe = require("http"),
    Wxe = require("https"),
    Kxe = require("zlib"),
    Xxe = require("stream"),
    Yxe = (WQ(), nT(zQ));
  function Qxe(e) {
    return e && typeof e == "object" && "default" in e ? e : {
      default: e
    };
  }
  l(Qxe, "_interopDefaultLegacy");
  function tx(e) {
    if (e && e.__esModule) return e;
    var t = Object.create(null);
    return e && Object.keys(e).forEach(function (r) {
      if (r !== "default") {
        var n = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, n.get ? n : {
          enumerable: !0,
          get: function () {
            return e[r];
          }
        });
      }
    }), t.default = e, Object.freeze(t);
  }
  l(tx, "_interopNamespace");
  var hN = tx(qxe),
    Zxe = Qxe(jxe),
    gN = tx(zxe),
    _N = tx(Wxe),
    KQ = tx(Kxe),
    ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]),
    HttpPipeline = class _HttpPipeline {
      static {
        __name(this, "HttpPipeline");
      }
      constructor(policies) {
        var r;
        this._policies = [], this._policies = (_a = policies?.slice(0)) !== null && _a !== void 0 ? _a : [], this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) throw new Error("Policies inside a phase cannot specify afterPhase.");
        if (options.phase && !ValidPhaseNames.has(options.phase)) throw new Error(`Invalid phase name: ${options.phase}`);
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        this._policies.push({
          policy: policy,
          options: options
        }), this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        let removedPolicies = [];
        return this._policies = this._policies.filter(policyDescriptor => options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase ? (removedPolicies.push(policyDescriptor.policy), !1) : !0), this._orderedPolicies = void 0, removedPolicies;
      }
      sendRequest(httpClient, request) {
        return this.getOrderedPolicies().reduceRight((next, policy) => req => policy.sendRequest(req, next), req => httpClient.sendRequest(req))(request);
      }
      getOrderedPolicies() {
        return this._orderedPolicies || (this._orderedPolicies = this.orderPolicies()), this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        let result = [],
          policyMap = new Map();
        function createPhase(name) {
          return {
            name: name,
            policies: new Set(),
            hasRun: !1,
            hasAfterPolicies: !1
          };
        }
        __name(createPhase, "createPhase");
        let serializePhase = createPhase("Serialize"),
          noPhase = createPhase("None"),
          deserializePhase = createPhase("Deserialize"),
          retryPhase = createPhase("Retry"),
          signPhase = createPhase("Sign"),
          orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          return phase === "Retry" ? retryPhase : phase === "Serialize" ? serializePhase : phase === "Deserialize" ? deserializePhase : phase === "Sign" ? signPhase : noPhase;
        }
        __name(getPhase, "getPhase");
        for (let descriptor of this._policies) {
          let policy = descriptor.policy,
            options = descriptor.options,
            policyName = policy.name;
          if (policyMap.has(policyName)) throw new Error("Duplicate policy names not allowed in pipeline");
          let node = {
            policy: policy,
            dependsOn: new Set(),
            dependants: new Set()
          };
          options.afterPhase && (node.afterPhase = getPhase(options.afterPhase), node.afterPhase.hasAfterPolicies = !0), policyMap.set(policyName, node), getPhase(options.phase).policies.add(node);
        }
        for (let descriptor of this._policies) {
          let {
              policy: policy,
              options: options
            } = descriptor,
            policyName = policy.name,
            node = policyMap.get(policyName);
          if (!node) throw new Error(`Missing node for policy ${policyName}`);
          if (options.afterPolicies) for (let afterPolicyName of options.afterPolicies) {
            let afterNode = policyMap.get(afterPolicyName);
            afterNode && (node.dependsOn.add(afterNode), afterNode.dependants.add(node));
          }
          if (options.beforePolicies) for (let beforePolicyName of options.beforePolicies) {
            let beforeNode = policyMap.get(beforePolicyName);
            beforeNode && (beforeNode.dependsOn.add(node), node.dependants.add(beforeNode));
          }
        }
        function walkPhase(phase) {
          phase.hasRun = !0;
          for (let node of phase.policies) if (!(node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) && node.dependsOn.size === 0) {
            result.push(node.policy);
            for (let dependant of node.dependants) dependant.dependsOn.delete(node);
            policyMap.delete(node.policy.name), phase.policies.delete(node);
          }
        }
        __name(walkPhase, "walkPhase");
        function walkPhases() {
          for (let phase of orderedPhases) {
            if (walkPhase(phase), phase.policies.size > 0 && phase !== noPhase) {
              noPhase.hasRun || walkPhase(noPhase);
              return;
            }
            phase.hasAfterPolicies && walkPhase(noPhase);
          }
        }
        __name(walkPhases, "walkPhases");
        let iteration = 0;
        for (; policyMap.size > 0;) {
          iteration++;
          let initialResultLength = result.length;
          if (walkPhases(), result.length <= initialResultLength && iteration > 1) throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
        return result;
      }
    };
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
  __name(createEmptyPipeline, "createEmptyPipeline");
  var logger = createClientLogger.createClientLogger("core-rest-pipeline"),
    RedactedString = "REDACTED",
    defaultAllowedHeaderNames = ["x-ms-client-request-id", "x-ms-return-client-request-id", "x-ms-useragent", "x-ms-correlation-request-id", "x-ms-request-id", "client-request-id", "ms-cv", "return-client-request-id", "traceparent", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Origin", "Accept", "Accept-Encoding", "Cache-Control", "Connection", "Content-Length", "Content-Type", "Date", "ETag", "Expires", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "Last-Modified", "Pragma", "Request-Id", "Retry-After", "Server", "Transfer-Encoding", "User-Agent", "WWW-Authenticate"],
    defaultAllowedQueryParameters = ["api-version"],
    Sanitizer = class {
      static {
        __name(this, "Sanitizer");
      }
      constructor({
        additionalAllowedHeaderNames: allowedHeaderNames = [],
        additionalAllowedQueryParameters: allowedQueryParameters = []
      } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames), allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters), this.allowedHeaderNames = new Set(allowedHeaderNames.map(n => n.toLowerCase())), this.allowedQueryParameters = new Set(allowedQueryParameters.map(p => p.toLowerCase()));
      }
      sanitize(obj) {
        let seen = new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) return Object.assign(Object.assign({}, value), {
            name: value.name,
            message: value.message
          });
          if (key === "headers") return this.sanitizeHeaders(value);
          if (key === "url") return this.sanitizeUrl(value);
          if (key === "query") return this.sanitizeQuery(value);
          if (key === "body") return;
          if (key === "response") return;
          if (key === "operationSpec") return;
          if (Array.isArray(value) || isObject.isObject(value)) {
            if (seen.has(value)) return "[Circular]";
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(obj) {
        let sanitized = {};
        for (let key of Object.keys(obj)) this.allowedHeaderNames.has(key.toLowerCase()) ? sanitized[key] = obj[key] : sanitized[key] = RedactedString;
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value != "object" || value === null) return value;
        let sanitized = {};
        for (let k of Object.keys(value)) this.allowedQueryParameters.has(k.toLowerCase()) ? sanitized[k] = value[k] : sanitized[k] = RedactedString;
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value != "string" || value === null) return value;
        let url = new URL(value);
        if (!url.search) return value;
        for (let [key] of url.searchParams) this.allowedQueryParameters.has(key.toLowerCase()) || url.searchParams.set(key, RedactedString);
        return url.toString();
      }
    },
    logPolicyName = "logPolicy";
  function logPolicy(options = {}) {
    var t;
    let logger = (_a = options.logger) !== null && _a !== void 0 ? _a : coreLogger.info,
      sanitizer = new Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
    return {
      name: logPolicyName,
      async sendRequest(request, next) {
        if (!logger.enabled) return next(request);
        logger(`Request: ${sanitizer.sanitize(request)}`);
        let response = await next(request);
        return logger(`Response status code: ${response.status}`), logger(`Headers: ${sanitizer.sanitize(response.headers)}`), response;
      }
    };
  }
  __name(logPolicy, "logPolicy");
  var redirectPolicyName = "redirectPolicy",
    allowedRedirect = ["GET", "HEAD"];
  function redirectPolicy(options = {}) {
    let {
      maxRetries = 20
    } = options;
    return {
      name: redirectPolicyName,
      async sendRequest(request, next) {
        let response = await next(request);
        return handleRedirect(next, response, maxRetries);
      }
    };
  }
  __name(redirectPolicy, "redirectPolicy");
  async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    let {
        request: request,
        status: status,
        headers: headers
      } = response,
      locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
      let url = new URL(locationHeader, request.url);
      request.url = url.toString(), status === 303 && (request.method = "GET", request.headers.delete("Content-Length"), delete request.body), request.headers.delete("Authorization");
      let res = await next(request);
      return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
  __name(handleRedirect, "handleRedirect");
  function getHeaderName() {
    return "User-Agent";
  }
  __name(getHeaderName, "getHeaderName");
  function setPlatformSpecificData(map) {
    map.set("Node", process.version), map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
  }
  __name(setPlatformSpecificData, "setPlatformSpecificData");
  var SDK_VERSION = "1.10.1",
    DEFAULT_RETRY_POLICY_COUNT = 3;
  function getUserAgentString(telemetryInfo) {
    let parts = [];
    for (let [key, value] of telemetryInfo) {
      let token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  __name(getUserAgentString, "getUserAgentString");
  function getUserAgentHeaderName() {
    return getHeaderName();
  }
  __name(getUserAgentHeaderName, "getUserAgentHeaderName");
  function getUserAgentValue(prefix) {
    let runtimeInfo = new Map();
    runtimeInfo.set("core-rest-pipeline", SDK_VERSION), setPlatformSpecificData(runtimeInfo);
    let defaultAgent = getUserAgentString(runtimeInfo);
    return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  }
  __name(getUserAgentValue, "getUserAgentValue");
  var UserAgentHeaderName = getUserAgentHeaderName(),
    userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    let userAgentValue = getUserAgentValue(options.userAgentPrefix);
    return {
      name: userAgentPolicyName,
      async sendRequest(request, next) {
        return request.headers.has(UserAgentHeaderName) || request.headers.set(UserAgentHeaderName, userAgentValue), next(request);
      }
    };
  }
  __name(userAgentPolicy, "userAgentPolicy");
  var decompressResponsePolicyName = "decompressResponsePolicy";
  function decompressResponsePolicy() {
    return {
      name: decompressResponsePolicyName,
      async sendRequest(request, next) {
        return request.method !== "HEAD" && request.headers.set("Accept-Encoding", "gzip,deflate"), next(request);
      }
    };
  }
  __name(decompressResponsePolicy, "decompressResponsePolicy");
  var StandardAbortMessage = "The operation was aborted.";
  function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
      let timer,
        onAborted,
        rejectOnAbort = __name(() => reject(new AbortError.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage)), "rejectOnAbort"),
        removeListeners = __name(() => {
          options?.abortSignal && onAborted && options.abortSignal.removeEventListener("abort", onAborted);
        }, "removeListeners");
      if (onAborted = __name(() => (timer && clearTimeout(timer), removeListeners(), rejectOnAbort()), "onAborted"), options?.abortSignal && options.abortSignal.aborted) return rejectOnAbort();
      timer = setTimeout(() => {
        removeListeners(), resolve(value);
      }, delayInMs), options?.abortSignal && options.abortSignal.addEventListener("abort", onAborted);
    });
  }
  __name(delay, "delay");
  function parseHeaderValueAsNumber(response, headerName) {
    let value = response.headers.get(headerName);
    if (!value) return;
    let valueAsNum = Number(value);
    if (!Number.isNaN(valueAsNum)) return valueAsNum;
  }
  __name(parseHeaderValueAsNumber, "parseHeaderValueAsNumber");
  var RetryAfterHeader = "Retry-After",
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  function getRetryAfterInMs(response) {
    if (response && [429, 503].includes(response.status)) try {
      for (let header of AllRetryAfterHeaders) {
        let retryAfterValue = parseHeaderValueAsNumber(response, header);
        if (retryAfterValue === 0 || retryAfterValue) return retryAfterValue * (header === RetryAfterHeader ? 1e3 : 1);
      }
      let retryAfterHeader = response.headers.get(RetryAfterHeader);
      if (!retryAfterHeader) return;
      let diff = Date.parse(retryAfterHeader) - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
    } catch {
      return;
    }
  }
  __name(getRetryAfterInMs, "getRetryAfterInMs");
  function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
  }
  __name(isThrottlingRetryResponse, "isThrottlingRetryResponse");
  function throttlingRetryStrategy() {
    return {
      name: "throttlingRetryStrategy",
      retry({
        response: response
      }) {
        let retryAfterInMs = getRetryAfterInMs(response);
        return Number.isFinite(retryAfterInMs) ? {
          retryAfterInMs: retryAfterInMs
        } : {
          skipStrategy: !0
        };
      }
    };
  }
  __name(throttlingRetryStrategy, "throttlingRetryStrategy");
  var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3,
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  function exponentialRetryStrategy(options = {}) {
    var t, r;
    let retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL,
      maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL,
      retryAfterInMs = retryInterval;
    return {
      name: "exponentialRetryStrategy",
      retry({
        retryCount: retryCount,
        response: response,
        responseError: responseError
      }) {
        let matchedSystemError = isSystemError(responseError),
          ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors,
          isExponential = isExponentialRetryResponse(response),
          ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
        if (response && (isThrottlingRetryResponse(response) || !isExponential) || ignoreExponentialResponse || ignoreSystemErrors) return {
          skipStrategy: !0
        };
        if (responseError && !matchedSystemError && !isExponential) return {
          errorToThrow: responseError
        };
        let exponentialDelay = retryAfterInMs * Math.pow(2, retryCount),
          clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
        return retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive.getRandomIntegerInclusive(0, clampedExponentialDelay / 2), {
          retryAfterInMs: retryAfterInMs
        };
      }
    };
  }
  __name(exponentialRetryStrategy, "exponentialRetryStrategy");
  function isExponentialRetryResponse(response) {
    return !!(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  __name(isExponentialRetryResponse, "isExponentialRetryResponse");
  function isSystemError(err) {
    return err ? err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" : !1;
  }
  __name(isSystemError, "isSystemError");
  var retryPolicyLogger = createClientLogger.createClientLogger("core-rest-pipeline retryPolicy"),
    retryPolicyName = "retryPolicy";
  function retryPolicy(strategies, options = {
    maxRetries: DEFAULT_RETRY_POLICY_COUNT
  }) {
    let logger = options.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request, next) {
        var s, o;
        let response,
          responseError,
          retryCount = -1;
        retryRequest: for (;;) {
          retryCount += 1, response = void 0, responseError = void 0;
          try {
            logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId), response = await next(request), logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
          } catch (e) {
            if (logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId), responseError = e, !e || responseError.name !== "RestError") throw e;
            response = responseError.response;
          }
          if (!((_a = request.abortSignal) === null || _a === void 0) && _a.aborted) throw logger.error(`Retry ${retryCount}: Request aborted.`), new AbortError.AbortError();
          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
            if (logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`), responseError) throw responseError;
            if (response) return response;
            throw new Error("Maximum retries reached with no response or error to throw");
          }
          logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop: for (let strategy of strategies) {
            let strategyLogger = strategy.logger || retryPolicyLogger;
            strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
            let modifiers = strategy.retry({
              retryCount: retryCount,
              response: response,
              responseError: responseError
            });
            if (modifiers.skipStrategy) {
              strategyLogger.info(`Retry ${retryCount}: Skipped.`);
              continue strategiesLoop;
            }
            let {
              errorToThrow: errorToThrow,
              retryAfterInMs: retryAfterInMs,
              redirectTo: redirectTo
            } = modifiers;
            if (errorToThrow) throw strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow), errorToThrow;
            if (retryAfterInMs || retryAfterInMs === 0) {
              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`), await delay(retryAfterInMs, void 0, {
                abortSignal: request.abortSignal
              });
              continue retryRequest;
            }
            if (redirectTo) {
              strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`), request.url = redirectTo;
              continue retryRequest;
            }
          }
          if (responseError) throw logger.info("None of the retry strategies could work with the received error. Throwing it."), responseError;
          if (response) return logger.info("None of the retry strategies could work with the received response. Returning it."), response;
        }
      }
    };
  }
  __name(retryPolicy, "retryPolicy");
  var defaultRetryPolicyName = "defaultRetryPolicy";
  function defaultRetryPolicy(options = {}) {
    var t;
    return {
      name: defaultRetryPolicyName,
      sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  __name(defaultRetryPolicy, "defaultRetryPolicy");
  var formDataPolicyName = "formDataPolicy";
  function formDataPolicy() {
    return {
      name: formDataPolicyName,
      async sendRequest(request, next) {
        if (request.formData) {
          let contentType = request.headers.get("Content-Type");
          contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1 ? (request.body = wwwFormUrlEncode(request.formData), request.formData = void 0) : await prepareFormData(request.formData, request);
        }
        return next(request);
      }
    };
  }
  __name(formDataPolicy, "formDataPolicy");
  function wwwFormUrlEncode(formData) {
    let urlSearchParams = new URLSearchParams();
    for (let [key, value] of Object.entries(formData)) if (Array.isArray(value)) for (let subValue of value) urlSearchParams.append(key, subValue.toString());else urlSearchParams.append(key, value.toString());
    return urlSearchParams.toString();
  }
  __name(wwwFormUrlEncode, "wwwFormUrlEncode");
  async function prepareFormData(formData, request) {
    let requestForm = new FormData.FormData();
    for (let formKey of Object.keys(formData)) {
      let formValue = formData[formKey];
      if (Array.isArray(formValue)) for (let subValue of formValue) requestForm.append(formKey, subValue);else requestForm.append(formKey, formValue);
    }
    request.body = requestForm, request.formData = void 0;
    let contentType = request.headers.get("Content-Type");
    contentType && contentType.indexOf("multipart/form-data") !== -1 && request.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
    try {
      let contentLength = await new Promise((resolve, reject) => {
        requestForm.getLength((err, length) => {
          err ? reject(err) : resolve(length);
        });
      });
      request.headers.set("Content-Length", contentLength);
    } catch {}
  }
  __name(prepareFormData, "prepareFormData");
  var HTTPS_PROXY = "HTTPS_PROXY",
    HTTP_PROXY = "HTTP_PROXY",
    ALL_PROXY = "ALL_PROXY",
    NO_PROXY = "NO_PROXY",
    proxyPolicyName = "proxyPolicy",
    globalNoProxyList = [],
    noProxyListLoaded = !1,
    globalBypassedMap = new Map();
  function getEnvironmentValue(name) {
    if (process.env[name]) return process.env[name];
    if (process.env[name.toLowerCase()]) return process.env[name.toLowerCase()];
  }
  __name(getEnvironmentValue, "getEnvironmentValue");
  function loadEnvironmentProxyValue() {
    if (!process) return;
    let httpsProxy = getEnvironmentValue(HTTPS_PROXY),
      allProxy = getEnvironmentValue(ALL_PROXY),
      httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
  __name(loadEnvironmentProxyValue, "loadEnvironmentProxyValue");
  function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) return !1;
    let host = new URL(uri).hostname;
    if (bypassedMap?.has(host)) return bypassedMap.get(host);
    let isBypassedFlag = !1;
    for (let pattern of noProxyList) pattern[0] === "." ? (host.endsWith(pattern) || host.length === pattern.length - 1 && host === pattern.slice(1)) && (isBypassedFlag = !0) : host === pattern && (isBypassedFlag = !0);
    return bypassedMap?.set(host, isBypassedFlag), isBypassedFlag;
  }
  __name(isBypassed, "isBypassed");
  function loadNoProxy() {
    let noProxy = getEnvironmentValue(NO_PROXY);
    return noProxyListLoaded = !0, noProxy ? noProxy.split(",").map(item => item.trim()).filter(item => item.length) : [];
  }
  __name(loadNoProxy, "loadNoProxy");
  function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl && (proxyUrl = loadEnvironmentProxyValue(), !proxyUrl)) return;
    let parsedUrl = new URL(proxyUrl);
    return {
      host: (parsedUrl.protocol ? parsedUrl.protocol + "//" : "") + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  __name(getDefaultProxySettings, "getDefaultProxySettings");
  function getProxyAgentOptions(proxySettings, {
    headers: headers,
    tlsSettings: tlsSettings
  }) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(proxySettings.host);
    } catch {
      throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
    }
    tlsSettings && logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    let proxyAgentOptions = {
      hostname: parsedProxyUrl.hostname,
      port: proxySettings.port,
      protocol: parsedProxyUrl.protocol,
      headers: headers.toJSON()
    };
    return proxySettings.username && proxySettings.password ? proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}` : proxySettings.username && (proxyAgentOptions.auth = `${proxySettings.username}`), proxyAgentOptions;
  }
  __name(getProxyAgentOptions, "getProxyAgentOptions");
  function setProxyAgentOnRequest(request, cachedAgents) {
    if (request.agent) return;
    let isInsecure = new URL(request.url).protocol !== "https:",
      proxySettings = request.proxySettings;
    if (proxySettings) if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        let proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
        cachedAgents.httpProxyAgent = new HttpProxyAgent.HttpProxyAgent(proxyAgentOptions);
      }
      request.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        let proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
        cachedAgents.httpsProxyAgent = new HttpsProxyAgent.HttpsProxyAgent(proxyAgentOptions);
      }
      request.agent = cachedAgents.httpsProxyAgent;
    }
  }
  __name(setProxyAgentOnRequest, "setProxyAgentOnRequest");
  function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
    noProxyListLoaded || globalNoProxyList.push(...loadNoProxy());
    let cachedAgents = {};
    return {
      name: proxyPolicyName,
      async sendRequest(request, next) {
        var s;
        return !request.proxySettings && !isBypassed(request.url, (_a = options?.customNoProxyList) !== null && _a !== void 0 ? _a : globalNoProxyList, options?.customNoProxyList ? void 0 : globalBypassedMap) && (request.proxySettings = proxySettings), request.proxySettings && setProxyAgentOnRequest(request, cachedAgents), next(request);
      }
    };
  }
  __name(proxyPolicy, "proxyPolicy");
  var setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: setClientRequestIdPolicyName,
      async sendRequest(request, next) {
        return request.headers.has(requestIdHeaderName) || request.headers.set(requestIdHeaderName, request.requestId), next(request);
      }
    };
  }
  __name(setClientRequestIdPolicy, "setClientRequestIdPolicy");
  var tlsPolicyName = "tlsPolicy";
  function tlsPolicy(tlsSettings) {
    return {
      name: tlsPolicyName,
      sendRequest: async (req, next) => (req.tlsSettings || (req.tlsSettings = tlsSettings), next(req))
    };
  }
  __name(tlsPolicy, "tlsPolicy");
  var custom = inspect.inspect.custom,
    errorSanitizer = new Sanitizer(),
    RestError = class _RestError extends Error {
      static {
        __name(this, "RestError");
      }
      constructor(message, options = {}) {
        super(message), this.name = "RestError", this.code = options.code, this.statusCode = options.statusCode, this.request = options.request, this.response = options.response, Object.setPrototypeOf(this, _RestError.prototype);
      }
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
  RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError.PARSE_ERROR = "PARSE_ERROR";
  function isRestError(e) {
    return e instanceof RestError ? !0 : isError.isError(e) && e.name === "RestError";
  }
  __name(isRestError, "isRestError");
  var tracingPolicyName = "tracingPolicy";
  function tracingPolicy(options = {}) {
    let userAgent = getUserAgentValue(options.userAgentPrefix),
      tracingClient = tryCreateTracingClient();
    return {
      name: tracingPolicyName,
      async sendRequest(request, next) {
        var s, o;
        if (!tracingClient || !(!((_a = request.tracingOptions) === null || _a === void 0) && _a.tracingContext)) return next(request);
        let {
          span: span,
          tracingContext: tracingContext
        } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
        if (!span || !tracingContext) return next(request);
        try {
          let response = await tracingClient.withContext(tracingContext, next, request);
          return tryProcessResponse(span, response), response;
        } catch (err) {
          throw tryProcessError(span, err), err;
        }
      }
    };
  }
  __name(tracingPolicy, "tracingPolicy");
  function tryCreateTracingClient() {
    try {
      return createTracingClient.createTracingClient({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: SDK_VERSION
      });
    } catch (e) {
      logger.warning(`Error when creating the TracingClient: ${getErrorMessage.getErrorMessage(e)}`);
      return;
    }
  }
  __name(tryCreateTracingClient, "tryCreateTracingClient");
  function tryCreateSpan(tracingClient, request, userAgent) {
    try {
      let {
        span: span,
        updatedOptions: updatedOptions
      } = tracingClient.startSpan(`HTTP ${request.method}`, {
        tracingOptions: request.tracingOptions
      }, {
        spanKind: "client",
        spanAttributes: {
          "http.method": request.method,
          "http.url": request.url,
          requestId: request.requestId
        }
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      userAgent && span.setAttribute("http.user_agent", userAgent);
      let headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (let [key, value] of Object.entries(headers)) request.headers.set(key, value);
      return {
        span: span,
        tracingContext: updatedOptions.tracingOptions.tracingContext
      };
    } catch (e) {
      logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage.getErrorMessage(e)}`);
      return;
    }
  }
  __name(tryCreateSpan, "tryCreateSpan");
  function tryProcessError(span, error) {
    try {
      span.setStatus({
        status: "error",
        error: isError.isError(error) ? error : void 0
      }), isRestError(error) && error.statusCode && span.setAttribute("http.status_code", error.statusCode), span.end();
    } catch (e) {
      logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage.getErrorMessage(e)}`);
    }
  }
  __name(tryProcessError, "tryProcessError");
  function tryProcessResponse(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      let serviceRequestId = response.headers.get("x-ms-request-id");
      serviceRequestId && span.setAttribute("serviceRequestId", serviceRequestId), span.setStatus({
        status: "success"
      }), span.end();
    } catch (e) {
      logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage.getErrorMessage(e)}`);
    }
  }
  __name(tryProcessResponse, "tryProcessResponse");
  function createPipelineFromOptions(options) {
    let pipeline = createEmptyPipeline();
    return isNode.isNode && (options.tlsOptions && pipeline.addPolicy(tlsPolicy(options.tlsOptions)), pipeline.addPolicy(proxyPolicy(options.proxyOptions)), pipeline.addPolicy(decompressResponsePolicy())), pipeline.addPolicy(formDataPolicy()), pipeline.addPolicy(userAgentPolicy(options.userAgentOptions)), pipeline.addPolicy(setClientRequestIdPolicy()), pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), {
      phase: "Retry"
    }), pipeline.addPolicy(tracingPolicy(options.userAgentOptions), {
      afterPhase: "Retry"
    }), isNode.isNode && pipeline.addPolicy(redirectPolicy(options.redirectOptions), {
      afterPhase: "Retry"
    }), pipeline.addPolicy(logPolicy(options.loggingOptions), {
      afterPhase: "Sign"
    }), pipeline;
  }
  __name(createPipelineFromOptions, "createPipelineFromOptions");
  function normalizeName(name) {
    return name.toLowerCase();
  }
  __name(normalizeName, "normalizeName");
  function* headerIterator(map) {
    for (let entry of map.values()) yield [entry.name, entry.value];
  }
  __name(headerIterator, "headerIterator");
  var HttpHeadersImpl = class {
    static {
      __name(this, "HttpHeadersImpl");
    }
    constructor(rawHeaders) {
      if (this._headersMap = new Map(), rawHeaders) for (let headerName of Object.keys(rawHeaders)) this.set(headerName, rawHeaders[headerName]);
    }
    set(name, value) {
      this._headersMap.set(normalizeName(name), {
        name: name,
        value: String(value)
      });
    }
    get(name) {
      var r;
      return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    toJSON(options = {}) {
      let result = {};
      if (options.preserveCase) for (let entry of this._headersMap.values()) result[entry.name] = entry.value;else for (let [normalizedName, entry] of this._headersMap) result[normalizedName] = entry.value;
      return result;
    }
    toString() {
      return JSON.stringify(this.toJSON({
        preserveCase: !0
      }));
    }
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  };
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
  __name(createHttpHeaders, "createHttpHeaders");
  var DEFAULT_TLS_SETTINGS = {};
  function isReadableStream(body) {
    return body && typeof body.pipe == "function";
  }
  __name(isReadableStream, "isReadableStream");
  function isStreamComplete(stream) {
    return new Promise(resolve => {
      stream.on("close", resolve), stream.on("end", resolve), stream.on("error", resolve);
    });
  }
  __name(isStreamComplete, "isStreamComplete");
  function isArrayBuffer(body) {
    return body && typeof body.byteLength == "number";
  }
  __name(isArrayBuffer, "isArrayBuffer");
  var ReportTransform = class extends Transform.Transform {
      static {
        __name(this, "ReportTransform");
      }
      constructor(progressCallback) {
        super(), this.loadedBytes = 0, this.progressCallback = progressCallback;
      }
      _transform(chunk, _encoding, callback) {
        this.push(chunk), this.loadedBytes += chunk.length;
        try {
          this.progressCallback({
            loadedBytes: this.loadedBytes
          }), callback();
        } catch (e) {
          callback(e);
        }
      }
    },
    NodeHttpClient = class {
      static {
        __name(this, "NodeHttpClient");
      }
      constructor() {
        this.cachedHttpsAgents = new WeakMap();
      }
      async sendRequest(request) {
        var r, n, i;
        let abortController = new AbortController.AbortController(),
          abortListener;
        if (request.abortSignal) {
          if (request.abortSignal.aborted) throw new AbortError.AbortError("The operation was aborted.");
          abortListener = __name(event => {
            event.type === "abort" && abortController.abort();
          }, "abortListener"), request.abortSignal.addEventListener("abort", abortListener);
        }
        request.timeout > 0 && setTimeout(() => {
          abortController.abort();
        }, request.timeout);
        let acceptEncoding = request.headers.get("Accept-Encoding"),
          shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate"),
          body = typeof request.body == "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
          let bodyLength = getBodyLength(body);
          bodyLength !== null && request.headers.set("Content-Length", bodyLength);
        }
        let responseStream;
        try {
          if (body && request.onUploadProgress) {
            let onUploadProgress = request.onUploadProgress,
              uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", e => {
              logger.error("Error in upload progress", e);
            }), isReadableStream(body) ? body.pipe(uploadReportStream) : uploadReportStream.end(body), body = uploadReportStream;
          }
          let res = await this.makeRequest(request, abortController, body),
            headers = getResponseHeaders(res),
            response = {
              status: (_a = res.statusCode) !== null && _a !== void 0 ? _a : 0,
              headers: headers,
              request: request
            };
          if (request.method === "HEAD") return res.resume(), response;
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          let onDownloadProgress = request.onDownloadProgress;
          if (onDownloadProgress) {
            let downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", e => {
              logger.error("Error in download progress", e);
            }), responseStream.pipe(downloadReportStream), responseStream = downloadReportStream;
          }
          return !((_b = request.streamResponseStatusCodes) === null || _b === void 0) && _b.has(Number.POSITIVE_INFINITY) || !((_c = request.streamResponseStatusCodes) === null || _c === void 0) && _c.has(response.status) ? response.readableStreamBody = responseStream : response.bodyAsText = await streamToText(responseStream), response;
        } finally {
          if (request.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            isReadableStream(body) && (uploadStreamDone = isStreamComplete(body));
            let downloadStreamDone = Promise.resolve();
            isReadableStream(responseStream) && (downloadStreamDone = isStreamComplete(responseStream)), Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              var h;
              abortListener && ((_a = request.abortSignal) === null || _a === void 0 || _a.removeEventListener("abort", abortListener));
            }).catch(e => {
              logger.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request, abortController, body) {
        var i;
        let url = new URL(request.url),
          isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        let options = {
          agent: (_a = request.agent) !== null && _a !== void 0 ? _a : this.getOrCreateAgent(request, isInsecure),
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request.method,
          headers: request.headers.toJSON({
            preserveCase: !0
          })
        };
        return new Promise((resolve, reject) => {
          let req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);
          req.once("error", err => {
            var h;
            reject(new RestError(err.message, {
              code: (_a = err.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,
              request: request
            }));
          }), abortController.signal.addEventListener("abort", () => {
            let abortError = new AbortError.AbortError("The operation was aborted.");
            req.destroy(abortError), reject(abortError);
          }), body && isReadableStream(body) ? body.pipe(req) : body ? typeof body == "string" || Buffer.isBuffer(body) ? req.end(body) : isArrayBuffer(body) ? req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body)) : (logger.error("Unrecognized body type", body), reject(new RestError("Unrecognized body type"))) : req.end();
        });
      }
      getOrCreateAgent(request, isInsecure) {
        var n;
        let disableKeepAlive = request.disableKeepAlive;
        if (isInsecure) return disableKeepAlive ? http.globalAgent : (this.cachedHttpAgent || (this.cachedHttpAgent = new http.Agent({
          keepAlive: !0
        })), this.cachedHttpAgent);
        {
          if (disableKeepAlive && !request.tlsSettings) return https.globalAgent;
          let tlsSettings = (_a = request.tlsSettings) !== null && _a !== void 0 ? _a : DEFAULT_TLS_SETTINGS,
            agent = this.cachedHttpsAgents.get(tlsSettings);
          return agent && agent.options.keepAlive === !disableKeepAlive || (logger.info("No cached TLS Agent exist, creating a new Agent"), agent = new https.Agent(Object.assign({
            keepAlive: !disableKeepAlive
          }, tlsSettings)), this.cachedHttpsAgents.set(tlsSettings, agent)), agent;
        }
      }
    };
  function getResponseHeaders(res) {
    let headers = createHttpHeaders();
    for (let header of Object.keys(res.headers)) {
      let value = res.headers[header];
      Array.isArray(value) ? value.length > 0 && headers.set(header, value[0]) : value && headers.set(header, value);
    }
    return headers;
  }
  __name(getResponseHeaders, "getResponseHeaders");
  function getDecodedResponseStream(stream, headers) {
    let contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      let unzip = zlib.createGunzip();
      return stream.pipe(unzip), unzip;
    } else if (contentEncoding === "deflate") {
      let inflate = zlib.createInflate();
      return stream.pipe(inflate), inflate;
    }
    return stream;
  }
  __name(getDecodedResponseStream, "getDecodedResponseStream");
  function streamToText(stream) {
    return new Promise((resolve, reject) => {
      let buffer = [];
      stream.on("data", chunk => {
        Buffer.isBuffer(chunk) ? buffer.push(chunk) : buffer.push(Buffer.from(chunk));
      }), stream.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      }), stream.on("error", e => {
        e && e?.name === "AbortError" ? reject(e) : reject(new RestError(`Error reading response as text: ${e.message}`, {
          code: RestError.PARSE_ERROR
        }));
      });
    });
  }
  __name(streamToText, "streamToText");
  function getBodyLength(body) {
    return body ? Buffer.isBuffer(body) ? body.length : isReadableStream(body) ? null : isArrayBuffer(body) ? body.byteLength : typeof body == "string" ? Buffer.from(body).length : null : 0;
  }
  __name(getBodyLength, "getBodyLength");
  function createNodeHttpClient() {
    return new NodeHttpClient();
  }
  __name(createNodeHttpClient, "createNodeHttpClient");
  function createDefaultHttpClient() {
    return createNodeHttpClient();
  }
  __name(createDefaultHttpClient, "createDefaultHttpClient");
  function generateUuid() {
    return uuidv4.uuidv4();
  }
  __name(generateUuid, "generateUuid");
  var PipelineRequestImpl = class {
    static {
      __name(this, "PipelineRequestImpl");
    }
    constructor(options) {
      var r, n, i, s, o, c, u;
      this.url = options.url, this.body = options.body, this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : createHttpHeaders(), this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET", this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0, this.formData = options.formData, this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : !1, this.proxySettings = options.proxySettings, this.streamResponseStatusCodes = options.streamResponseStatusCodes, this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : !1, this.abortSignal = options.abortSignal, this.tracingOptions = options.tracingOptions, this.onUploadProgress = options.onUploadProgress, this.onDownloadProgress = options.onDownloadProgress, this.requestId = options.requestId || generateUuid(), this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : !1, this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : !1;
    }
  };
  function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
  }
  __name(createPipelineRequest, "createPipelineRequest");
  var exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy(options = {}) {
    var t;
    return retryPolicy([exponentialRetryStrategy(Object.assign(Object.assign({}, options), {
      ignoreSystemErrors: !0
    }))], {
      maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
    });
  }
  __name(exponentialRetryPolicy, "exponentialRetryPolicy");
  var systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function systemErrorRetryPolicy(options = {}) {
    var t;
    return {
      name: systemErrorRetryPolicyName,
      sendRequest: retryPolicy([exponentialRetryStrategy(Object.assign(Object.assign({}, options), {
        ignoreHttpStatusCodes: !0
      }))], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  __name(systemErrorRetryPolicy, "systemErrorRetryPolicy");
  var throttlingRetryPolicyName = "throttlingRetryPolicy";
  function throttlingRetryPolicy(options = {}) {
    var t;
    return {
      name: throttlingRetryPolicyName,
      sendRequest: retryPolicy([throttlingRetryStrategy()], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
  __name(throttlingRetryPolicy, "throttlingRetryPolicy");
  var DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1e3,
    retryIntervalInMs: 3e3,
    refreshWindowInMs: 1e3 * 60 * 2
  };
  async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout) try {
        return await getAccessToken();
      } catch {
        return null;
      } else {
        let finalToken = await getAccessToken();
        if (finalToken === null) throw new Error("Failed to refresh access token.");
        return finalToken;
      }
    }
    __name(tryGetAccessToken, "tryGetAccessToken");
    let token = await tryGetAccessToken();
    for (; token === null;) await delay(retryIntervalInMs), token = await tryGetAccessToken();
    return token;
  }
  __name(beginRefresh, "beginRefresh");
  function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null,
      token = null,
      tenantId,
      options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions),
      cycler = {
        get isRefreshing() {
          return refreshWorker !== null;
        },
        get shouldRefresh() {
          var u;
          return !cycler.isRefreshing && ((_a = token?.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();
        },
        get mustRefresh() {
          return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
      };
    function refresh(scopes, getTokenOptions) {
      var d;
      return cycler.isRefreshing || (refreshWorker = beginRefresh(__name(() => credential.getToken(scopes, getTokenOptions), "tryGetAccessToken"), options.retryIntervalInMs, (_a = token?.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now()).then(_token => (refreshWorker = null, token = _token, tenantId = getTokenOptions.tenantId, token)).catch(reason => {
        throw refreshWorker = null, token = null, tenantId = void 0, reason;
      })), refreshWorker;
    }
    return __name(refresh, "refresh"), async (scopes, tokenOptions) => tenantId !== tokenOptions.tenantId || !!tokenOptions.claims || cycler.mustRefresh ? refresh(scopes, tokenOptions) : (cycler.shouldRefresh && refresh(scopes, tokenOptions), token);
  }
  __name(createTokenCycler, "createTokenCycler");
  var bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function defaultAuthorizeRequest(options) {
    let {
        scopes: scopes,
        getAccessToken: getAccessToken,
        request: request
      } = options,
      getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
      },
      accessToken = await getAccessToken(scopes, getTokenOptions);
    accessToken && options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
  __name(defaultAuthorizeRequest, "defaultAuthorizeRequest");
  function getChallenge(response) {
    let challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) return challenge;
  }
  __name(getChallenge, "getChallenge");
  function bearerTokenAuthenticationPolicy(options) {
    var t;
    let {
        credential: credential,
        scopes: scopes,
        challengeCallbacks: challengeCallbacks
      } = options,
      logger = options.logger || coreLogger,
      callbacks = Object.assign({
        authorizeRequest: (_a = challengeCallbacks?.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,
        authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge
      }, challengeCallbacks),
      getAccessToken = credential ? createTokenCycler(credential) : () => Promise.resolve(null);
    return {
      name: bearerTokenAuthenticationPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://")) throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request: request,
          getAccessToken: getAccessToken,
          logger: logger
        });
        let response, error;
        try {
          response = await next(request);
        } catch (err) {
          error = err, response = err.response;
        }
        if (callbacks.authorizeRequestOnChallenge && response?.status === 401 && getChallenge(response) && (await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request: request,
          response: response,
          getAccessToken: getAccessToken,
          logger: logger
        }))) return next(request);
        if (error) throw error;
        return response;
      }
    };
  }
  __name(bearerTokenAuthenticationPolicy, "bearerTokenAuthenticationPolicy");
  var ndJsonPolicyName = "ndJsonPolicy";
  function ndJsonPolicy() {
    return {
      name: ndJsonPolicyName,
      async sendRequest(request, next) {
        if (typeof request.body == "string" && request.body.startsWith("[")) {
          let body = JSON.parse(request.body);
          Array.isArray(body) && (request.body = body.map(item => JSON.stringify(item) + `
`).join(""));
        }
        return next(request);
      }
    };
  }
  __name(ndJsonPolicy, "ndJsonPolicy");
  ea.RestError = of;
  ea.bearerTokenAuthenticationPolicy = Zbe;
  ea.bearerTokenAuthenticationPolicyName = DZ;
  ea.createDefaultHttpClient = qbe;
  ea.createEmptyPipeline = nZ;
  ea.createHttpHeaders = SN;
  ea.createPipelineFromOptions = Obe;
  ea.createPipelineRequest = Hbe;
  ea.decompressResponsePolicy = mZ;
  ea.decompressResponsePolicyName = pZ;
  ea.defaultRetryPolicy = yZ;
  ea.exponentialRetryPolicy = Vbe;
  ea.exponentialRetryPolicyName = $be;
  ea.formDataPolicy = xZ;
  ea.formDataPolicyName = vZ;
  ea.getDefaultProxySettings = CZ;
  ea.isRestError = PZ;
  ea.logPolicy = sZ;
  ea.logPolicyName = iZ;
  ea.ndJsonPolicy = Jbe;
  ea.ndJsonPolicyName = MZ;
  ea.proxyPolicy = TZ;
  ea.proxyPolicyName = bZ;
  ea.redirectPolicy = aZ;
  ea.redirectPolicyName = oZ;
  ea.retryPolicy = T4;
  ea.setClientRequestIdPolicy = wZ;
  ea.setClientRequestIdPolicyName = SZ;
  ea.systemErrorRetryPolicy = Gbe;
  ea.systemErrorRetryPolicyName = LZ;
  ea.throttlingRetryPolicy = zbe;
  ea.throttlingRetryPolicyName = kZ;
  ea.tlsPolicy = AZ;
  ea.tlsPolicyName = IZ;
  ea.tracingPolicy = NZ;
  ea.tracingPolicyName = RZ;
  ea.userAgentPolicy = dZ;
  ea.userAgentPolicyName = fZ;
});
var qZ = T((S4, UZ) => {
  "use strict";

  var eEe = S4 && S4.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    tEe = S4 && S4.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    azureCore = BZ(),
    applicationInsightsResource = "https://monitor.azure.com//.default";
  function emptySendRequest(_request) {
    return null;
  }
  __name(emptySendRequest, "emptySendRequest");
  var AuthorizationHandler = function () {
    function AuthorizationHandler(credential) {
      var scopes = [applicationInsightsResource];
      this._azureTokenPolicy = azureCore.bearerTokenAuthenticationPolicy({
        credential: credential,
        scopes: scopes
      });
    }
    return __name(AuthorizationHandler, "AuthorizationHandler"), AuthorizationHandler.prototype.addAuthorizationHeader = function (requestOptions) {
      return eEe(this, void 0, void 0, function () {
        var r, n;
        return tEe(this, function (i) {
          switch (i.label) {
            case 0:
              return authHeaderName = "authorization", webResource = azureCore.createPipelineRequest({
                url: "https://"
              }), [4, this._azureTokenPolicy.sendRequest(webResource, emptySendRequest)];
            case 1:
              return _a.sent(), requestOptions.headers[authHeaderName] = webResource.headers.get(authHeaderName), [2];
          }
        });
      });
    }, AuthorizationHandler;
  }();
  module.exports = AuthorizationHandler;
});
var HZ = T((het, jZ) => {
  "use strict";

  var Logging = x0(),
    Util = il(),
    Channel = function () {
      function Channel(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
        this._buffer = [], this._lastSend = 0, this._isDisabled = isDisabled, this._getBatchSize = getBatchSize, this._getBatchIntervalMs = getBatchIntervalMs, this._sender = sender;
      }
      return __name(Channel, "Channel"), Channel.prototype.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
      }, Channel.prototype.send = function (envelope) {
        var _this = this;
        if (!this._isDisabled()) {
          if (!envelope) {
            Logging.warn("Cannot send null/undefined telemetry");
            return;
          }
          if (this._buffer.push(envelope), this._buffer.length >= this._getBatchSize()) {
            this.triggerSend(!1);
            return;
          }
          !this._timeoutHandle && this._buffer.length > 0 && (this._timeoutHandle = setTimeout(function () {
            _this._timeoutHandle = null, _this.triggerSend(!1);
          }, this._getBatchIntervalMs()));
        }
      }, Channel.prototype.triggerSend = function (isNodeCrashing, callback) {
        var bufferIsEmpty = this._buffer.length < 1;
        bufferIsEmpty || (isNodeCrashing || Util.isNodeExit ? (this._sender.saveOnCrash(this._buffer), typeof callback == "function" && callback("data saved on crash")) : this._sender.send(this._buffer, callback)), this._lastSend = +new Date(), this._buffer = [], clearTimeout(this._timeoutHandle), this._timeoutHandle = null, bufferIsEmpty && typeof callback == "function" && callback("no data to send");
      }, Channel;
    }();
  module.exports = Channel;
});
var $Z = T(rx => {
  "use strict";

  Object.defineProperty(rx, "__esModule", {
    value: !0
  });
  rx.azureRoleEnvironmentTelemetryProcessor = void 0;
  function azureRoleEnvironmentTelemetryProcessor(envelope, context) {}
  __name(azureRoleEnvironmentTelemetryProcessor, "azureRoleEnvironmentTelemetryProcessor");
  exports.azureRoleEnvironmentTelemetryProcessor = azureRoleEnvironmentTelemetryProcessor;
});
var zZ = T(d5 => {
  "use strict";

  Object.defineProperty(d5, "__esModule", {
    value: !0
  });
  d5.getSamplingHashCode = d5.samplingTelemetryProcessor = void 0;
  var Contracts = Gl();
  function samplingTelemetryProcessor(envelope, contextObjects) {
    var samplingPercentage = envelope.sampleRate,
      isSampledIn = !1;
    return samplingPercentage == null || samplingPercentage >= 100 || envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType) ? !0 : (contextObjects.correlationContext && contextObjects.correlationContext.operation ? isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage : isSampledIn = Math.random() * 100 < samplingPercentage, isSampledIn);
  }
  __name(samplingTelemetryProcessor, "samplingTelemetryProcessor");
  exports.samplingTelemetryProcessor = samplingTelemetryProcessor;
  function getSamplingHashCode(input) {
    var csharpMin = -2147483648,
      csharpMax = 2147483647,
      hash = 5381;
    if (!input) return 0;
    for (; input.length < 8;) input = input + input;
    for (var i = 0; i < input.length; i++) hash = ((hash << 5) + hash | 0) + input.charCodeAt(i) | 0;
    return hash = hash <= csharpMin ? csharpMax : Math.abs(hash), hash / csharpMax * 100;
  }
  __name(getSamplingHashCode, "getSamplingHashCode");
  exports.getSamplingHashCode = getSamplingHashCode;
});
var WZ = T(nx => {
  "use strict";

  Object.defineProperty(nx, "__esModule", {
    value: !0
  });
  nx.performanceMetricsTelemetryProcessor = void 0;
  var AutoCollectPerformance = b7(),
    TelemetryType = Gl();
  function performanceMetricsTelemetryProcessor(envelope, client) {
    switch (client && client.addDocument(envelope), envelope.data.baseType) {
      case TelemetryType.TelemetryTypeString.Exception:
        AutoCollectPerformance.countException();
        break;
      case TelemetryType.TelemetryTypeString.Request:
        var requestData = envelope.data.baseData;
        AutoCollectPerformance.countRequest(requestData.duration, requestData.success);
        break;
      case TelemetryType.TelemetryTypeString.Dependency:
        var remoteDependencyData = envelope.data.baseData;
        AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);
        break;
    }
    return !0;
  }
  __name(performanceMetricsTelemetryProcessor, "performanceMetricsTelemetryProcessor");
  exports.performanceMetricsTelemetryProcessor = performanceMetricsTelemetryProcessor;
});
var KZ = T(p5 => {
  "use strict";

  var kf = p5 && p5.__assign || function () {
    return kf = Object.assign || function (e) {
      for (var t, r = 1, n = arguments.length; r < n; r++) {
        t = arguments[r];
        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
      }
      return e;
    }, kf.apply(this, arguments);
  };
  Object.defineProperty(p5, "__esModule", {
    value: !0
  });
  p5.preAggregatedMetricsTelemetryProcessor = void 0;
  var Contracts = Gl(),
    AutoCollecPreAggregatedMetrics = oR(),
    TelemetryType = Gl();
  function preAggregatedMetricsTelemetryProcessor(envelope, context) {
    if (AutoCollecPreAggregatedMetrics.isEnabled()) switch (envelope.data.baseType) {
      case TelemetryType.TelemetryTypeString.Exception:
        var exceptionData = envelope.data.baseData;
        exceptionData.properties = __assign(__assign({}, exceptionData.properties), {
          "_MS.ProcessedByMetricExtractors": "(Name:'Exceptions', Ver:'1.1')"
        });
        var exceptionDimensions = {
          cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
          cloudRoleName: envelope.tags[context.keys.cloudRole]
        };
        AutoCollecPreAggregatedMetrics.countException(exceptionDimensions);
        break;
      case TelemetryType.TelemetryTypeString.Trace:
        var traceData = envelope.data.baseData;
        traceData.properties = __assign(__assign({}, traceData.properties), {
          "_MS.ProcessedByMetricExtractors": "(Name:'Traces', Ver:'1.1')"
        });
        var traceDimensions = {
          cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
          cloudRoleName: envelope.tags[context.keys.cloudRole],
          traceSeverityLevel: Contracts.SeverityLevel[traceData.severity]
        };
        AutoCollecPreAggregatedMetrics.countTrace(traceDimensions);
        break;
      case TelemetryType.TelemetryTypeString.Request:
        var requestData = envelope.data.baseData;
        requestData.properties = __assign(__assign({}, requestData.properties), {
          "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')"
        });
        var requestDimensions = {
          cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
          cloudRoleName: envelope.tags[context.keys.cloudRole],
          operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
          requestSuccess: requestData.success,
          requestResultCode: requestData.responseCode
        };
        AutoCollecPreAggregatedMetrics.countRequest(requestData.duration, requestDimensions);
        break;
      case TelemetryType.TelemetryTypeString.Dependency:
        var remoteDependencyData = envelope.data.baseData;
        remoteDependencyData.properties = __assign(__assign({}, remoteDependencyData.properties), {
          "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')"
        });
        var dependencyDimensions = {
          cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
          cloudRoleName: envelope.tags[context.keys.cloudRole],
          operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
          dependencySuccess: remoteDependencyData.success,
          dependencyType: remoteDependencyData.type,
          dependencyTarget: remoteDependencyData.target,
          dependencyResultCode: remoteDependencyData.resultCode
        };
        AutoCollecPreAggregatedMetrics.countDependency(remoteDependencyData.duration, dependencyDimensions);
        break;
    }
    return !0;
  }
  __name(preAggregatedMetricsTelemetryProcessor, "preAggregatedMetricsTelemetryProcessor");
  exports.preAggregatedMetricsTelemetryProcessor = preAggregatedMetricsTelemetryProcessor;
});
var XZ = T(Df => {
  "use strict";

  var pEe = Df && Df.__createBinding || (Object.create ? function (e, t, r, n) {
      n === void 0 && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function () {
          return t[r];
        }
      });
    } : function (e, t, r, n) {
      n === void 0 && (n = r), e[n] = t[r];
    }),
    sx = Df && Df.__exportStar || function (e, t) {
      for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && pEe(t, e, r);
    };
  Object.defineProperty(Df, "__esModule", {
    value: !0
  });
  __exportStar($Z(), exports);
  __exportStar(zZ(), exports);
  __exportStar(WZ(), exports);
  __exportStar(KZ(), exports);
});
var AN = T((Iet, ZZ) => {
  "use strict";

  var Contracts = Gl(),
    Util = il(),
    CorrelationContextManager_1 = Mp(),
    Logging = x0(),
    EnvelopeFactory = function () {
      function EnvelopeFactory() {}
      return __name(EnvelopeFactory, "EnvelopeFactory"), EnvelopeFactory.createEnvelope = function (telemetry, telemetryType, commonProperties, context, config) {
        var data = null;
        switch (telemetryType) {
          case Contracts.TelemetryType.Trace:
            data = EnvelopeFactory.createTraceData(telemetry);
            break;
          case Contracts.TelemetryType.Dependency:
            data = EnvelopeFactory.createDependencyData(telemetry);
            break;
          case Contracts.TelemetryType.Event:
            data = EnvelopeFactory.createEventData(telemetry);
            break;
          case Contracts.TelemetryType.Exception:
            data = EnvelopeFactory.createExceptionData(telemetry);
            break;
          case Contracts.TelemetryType.Request:
            data = EnvelopeFactory.createRequestData(telemetry);
            break;
          case Contracts.TelemetryType.Metric:
            data = EnvelopeFactory.createMetricData(telemetry);
            break;
          case Contracts.TelemetryType.Availability:
            data = EnvelopeFactory.createAvailabilityData(telemetry);
            break;
          case Contracts.TelemetryType.PageView:
            data = EnvelopeFactory.createPageViewData(telemetry);
            break;
        }
        if (data && data.baseData && Contracts.domainSupportsProperties(data.baseData)) {
          if (commonProperties) if (!data.baseData.properties) data.baseData.properties = commonProperties;else for (var name in commonProperties) data.baseData.properties[name] || (data.baseData.properties[name] = commonProperties[name]);
          EnvelopeFactory.addAzureFunctionsCorrelationProperties(data.baseData.properties), data.baseData.properties && (data.baseData.properties = Util.validateStringMap(data.baseData.properties));
        }
        var iKey = config && config.instrumentationKey || "",
          envelope = new Contracts.Envelope();
        return envelope.data = data, envelope.iKey = iKey, envelope.name = "Microsoft.ApplicationInsights." + iKey.replace(/-/g, "") + "." + data.baseType.substr(0, data.baseType.length - 4), envelope.tags = this.getTags(context, telemetry.tagOverrides), envelope.time = new Date().toISOString(), envelope.ver = 1, envelope.sampleRate = config ? config.samplingPercentage : 100, telemetryType === Contracts.TelemetryType.Metric && (envelope.sampleRate = 100), envelope;
      }, EnvelopeFactory.addAzureFunctionsCorrelationProperties = function (properties) {
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        if (correlationContext && correlationContext.customProperties && correlationContext.customProperties.getProperty instanceof Function) {
          properties = properties || {};
          var property = correlationContext.customProperties.getProperty("InvocationId");
          property && (properties.InvocationId = property), property = correlationContext.customProperties.getProperty("ProcessId"), property && (properties.ProcessId = property), property = correlationContext.customProperties.getProperty("LogLevel"), property && (properties.LogLevel = property), property = correlationContext.customProperties.getProperty("Category"), property && (properties.Category = property), property = correlationContext.customProperties.getProperty("HostInstanceId"), property && (properties.HostInstanceId = property), property = correlationContext.customProperties.getProperty("AzFuncLiveLogsSessionId"), property && (properties.AzFuncLiveLogsSessionId = property);
        }
      }, EnvelopeFactory.truncateProperties = function (telemetry) {
        if (telemetry.properties) try {
          for (var properties = {}, propertiesKeys = Object.keys(telemetry.properties), propertiesValues = Object.values(telemetry.properties), i = 0; i < propertiesKeys.length; i++) propertiesKeys[i].length <= 150 && (Util.isDate(propertiesValues[i]) || (propertiesValues[i] == null && (propertiesValues[i] = ""), typeof propertiesValues[i] == "object" && (propertiesValues[i] = Util.stringify(propertiesValues[i])), properties[propertiesKeys[i]] = String(propertiesValues[i]).substring(0, 8192)), properties[propertiesKeys[i]] = propertiesValues[i]);
          return properties;
        } catch (error) {
          Logging.warn("Failed to properly truncate telemetry properties: ", error);
        }
      }, EnvelopeFactory.createTraceData = function (telemetry) {
        var r,
          trace = new Contracts.MessageData();
        trace.message = (_a = telemetry.message) === null || _a === void 0 ? void 0 : _a.substring(0, 32768), trace.properties = this.truncateProperties(telemetry), isNaN(telemetry.severity) ? trace.severityLevel = Contracts.SeverityLevel.Information : trace.severityLevel = telemetry.severity;
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace), data.baseData = trace, data;
      }, EnvelopeFactory.createDependencyData = function (telemetry) {
        var r,
          n,
          i,
          remoteDependency = new Contracts.RemoteDependencyData();
        remoteDependency.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 1024), remoteDependency.data = (_b = telemetry.data) === null || _b === void 0 ? void 0 : _b.substring(0, 8192), remoteDependency.target = (_c = telemetry.target) === null || _c === void 0 ? void 0 : _c.substring(0, 1024), remoteDependency.duration = Util.msToTimeSpan(telemetry.duration), remoteDependency.success = telemetry.success, remoteDependency.type = telemetry.dependencyTypeName, remoteDependency.properties = this.truncateProperties(telemetry), remoteDependency.resultCode = telemetry.resultCode ? telemetry.resultCode.toString() : "0", telemetry.id ? remoteDependency.id = telemetry.id : remoteDependency.id = Util.w3cTraceId();
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency), data.baseData = remoteDependency, data;
      }, EnvelopeFactory.createEventData = function (telemetry) {
        var r,
          event = new Contracts.EventData();
        event.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 512), event.properties = this.truncateProperties(telemetry), event.measurements = telemetry.measurements;
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event), data.baseData = event, data;
      }, EnvelopeFactory.createExceptionData = function (telemetry) {
        var r,
          n,
          exception = new Contracts.ExceptionData();
        exception.properties = this.truncateProperties(telemetry), isNaN(telemetry.severity) ? exception.severityLevel = Contracts.SeverityLevel.Error : exception.severityLevel = telemetry.severity, exception.measurements = telemetry.measurements, exception.exceptions = [];
        var stack = telemetry.exception.stack,
          exceptionDetails = new Contracts.ExceptionDetails();
        exceptionDetails.message = (_a = telemetry.exception.message) === null || _a === void 0 ? void 0 : _a.substring(0, 32768), exceptionDetails.typeName = (_b = telemetry.exception.name) === null || _b === void 0 ? void 0 : _b.substring(0, 1024), exceptionDetails.parsedStack = this.parseStack(stack), exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0, exception.exceptions.push(exceptionDetails);
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception), data.baseData = exception, data;
      }, EnvelopeFactory.createRequestData = function (telemetry) {
        var r,
          n,
          i,
          s,
          requestData = new Contracts.RequestData();
        telemetry.id ? requestData.id = telemetry.id : requestData.id = Util.w3cTraceId(), requestData.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 1024), requestData.url = (_b = telemetry.url) === null || _b === void 0 ? void 0 : _b.substring(0, 2048), requestData.source = (_c = telemetry.source) === null || _c === void 0 ? void 0 : _c.substring(0, 1024), requestData.duration = Util.msToTimeSpan(telemetry.duration), requestData.responseCode = (_d = telemetry.resultCode ? telemetry.resultCode.toString() : "0") === null || _d === void 0 ? void 0 : _d.substring(0, 1024), requestData.success = telemetry.success, requestData.properties = this.truncateProperties(telemetry), requestData.measurements = telemetry.measurements;
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request), data.baseData = requestData, data;
      }, EnvelopeFactory.createMetricData = function (telemetry) {
        var r,
          metrics = new Contracts.MetricData();
        metrics.metrics = [];
        var metric = new Contracts.DataPoint();
        metric.count = isNaN(telemetry.count) ? 1 : telemetry.count, metric.kind = Contracts.DataPointType.Aggregation, metric.max = isNaN(telemetry.max) ? telemetry.value : telemetry.max, metric.min = isNaN(telemetry.min) ? telemetry.value : telemetry.min, metric.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 1024), metric.stdDev = isNaN(telemetry.stdDev) ? 0 : telemetry.stdDev, metric.value = telemetry.value, metric.ns = telemetry.namespace, metrics.metrics.push(metric), metrics.properties = this.truncateProperties(telemetry);
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric), data.baseData = metrics, data;
      }, EnvelopeFactory.createAvailabilityData = function (telemetry) {
        var r,
          n,
          availabilityData = new Contracts.AvailabilityData();
        telemetry.id ? availabilityData.id = telemetry.id : availabilityData.id = Util.w3cTraceId(), availabilityData.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 1024), availabilityData.duration = Util.msToTimeSpan(telemetry.duration), availabilityData.success = telemetry.success, availabilityData.runLocation = telemetry.runLocation, availabilityData.message = (_b = telemetry.message) === null || _b === void 0 ? void 0 : _b.substring(0, 8192), availabilityData.measurements = telemetry.measurements, availabilityData.properties = this.truncateProperties(telemetry);
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability), data.baseData = availabilityData, data;
      }, EnvelopeFactory.createPageViewData = function (telemetry) {
        var r,
          n,
          pageViewData = new Contracts.PageViewData();
        pageViewData.name = (_a = telemetry.name) === null || _a === void 0 ? void 0 : _a.substring(0, 1024), pageViewData.duration = Util.msToTimeSpan(telemetry.duration), pageViewData.url = (_b = telemetry.url) === null || _b === void 0 ? void 0 : _b.substring(0, 2048), pageViewData.measurements = telemetry.measurements, pageViewData.properties = this.truncateProperties(telemetry);
        var data = new Contracts.Data();
        return data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.PageView), data.baseData = pageViewData, data;
      }, EnvelopeFactory.getTags = function (context, tagOverrides) {
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext(),
          newTags = {};
        if (context && context.tags) for (var key in context.tags) newTags[key] = context.tags[key];
        if (tagOverrides) for (var key in tagOverrides) newTags[key] = tagOverrides[key];
        return correlationContext && (newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id, newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name, newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId), newTags;
      }, EnvelopeFactory.parseStack = function (stack) {
        var parsedStack = void 0;
        if (typeof stack == "string") {
          var frames = stack.split(`
`);
          parsedStack = [];
          for (var level = 0, totalSizeInBytes = 0, i = 0; i <= frames.length; i++) {
            var frame = frames[i];
            if (_StackFrame.regex.test(frame)) {
              var parsedFrame = new _StackFrame(frames[i], level++);
              totalSizeInBytes += parsedFrame.sizeInBytes, parsedStack.push(parsedFrame);
            }
          }
          var exceptionParsedStackThreshold = 32 * 1024;
          if (totalSizeInBytes > exceptionParsedStackThreshold) for (var left = 0, right = parsedStack.length - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right;) {
            var lSize = parsedStack[left].sizeInBytes,
              rSize = parsedStack[right].sizeInBytes;
            if (size += lSize + rSize, size > exceptionParsedStackThreshold) {
              var howMany = acceptedRight - acceptedLeft + 1;
              parsedStack.splice(acceptedLeft, howMany);
              break;
            }
            acceptedLeft = left, acceptedRight = right, left++, right--;
          }
        }
        return parsedStack;
      }, EnvelopeFactory;
    }(),
    _StackFrame = function () {
      function _StackFrame(frame, level) {
        this.sizeInBytes = 0, this.level = level, this.method = "<no_method>", this.assembly = Util.trim(frame);
        var matches = frame.match(_StackFrame.regex);
        matches && matches.length >= 5 && (this.method = Util.trim(matches[2]) || this.method, this.fileName = Util.trim(matches[4]) || "<no_filename>", this.line = parseInt(matches[5]) || 0), this.sizeInBytes += this.method.length, this.sizeInBytes += this.fileName.length, this.sizeInBytes += this.assembly.length, this.sizeInBytes += _StackFrame.baseSize, this.sizeInBytes += this.level.toString().length, this.sizeInBytes += this.line.toString().length;
      }
      return __name(_StackFrame, "_StackFrame"), _StackFrame.regex = /^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/, _StackFrame.baseSize = 58, _StackFrame;
    }();
  module.exports = EnvelopeFactory;
});
var JZ = T(Zp => {
  "use strict";

  var gEe = Zp && Zp.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    _Ee = Zp && Zp.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    };
  Object.defineProperty(Zp, "__esModule", {
    value: !0
  });
  Zp.FileAccessControl = void 0;
  var fs = require("fs"),
    os = require("os"),
    child_process = require("child_process"),
    Logging = x0(),
    FileAccessControl = function () {
      function FileAccessControl() {}
      return __name(FileAccessControl, "FileAccessControl"), FileAccessControl.checkFileProtection = function () {
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION && !FileAccessControl.OS_FILE_PROTECTION_CHECKED) if (FileAccessControl.OS_FILE_PROTECTION_CHECKED = !0, FileAccessControl.USE_ICACLS) {
          try {
            FileAccessControl.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(FileAccessControl.ICACLS_PATH);
          } catch {}
          FileAccessControl.OS_PROVIDES_FILE_PROTECTION || Logging.warn(FileAccessControl.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
        } else FileAccessControl.OS_PROVIDES_FILE_PROTECTION = !0;
      }, FileAccessControl.applyACLRules = function (directory) {
        return gEe(this, void 0, void 0, function () {
          var r, n;
          return _Ee(this, function (i) {
            switch (i.label) {
              case 0:
                if (!FileAccessControl.USE_ICACLS) return [3, 7];
                if (FileAccessControl.ACLED_DIRECTORIES[directory] !== void 0) return [3, 6];
                FileAccessControl.ACLED_DIRECTORIES[directory] = !1, i.label = 1;
              case 1:
                return i.trys.push([1, 4,, 5]), [4, this._getACLIdentity()];
              case 2:
                return identity = _a.sent(), [4, this._runICACLS(this._getACLArguments(directory, identity))];
              case 3:
                return _a.sent(), FileAccessControl.ACLED_DIRECTORIES[directory] = !0, [3, 5];
              case 4:
                throw n = i.sent(), FileAccessControl.ACLED_DIRECTORIES[directory] = !1, ex_1;
              case 5:
                return [3, 7];
              case 6:
                if (!FileAccessControl.ACLED_DIRECTORIES[directory]) throw new Error("Setting ACL restrictions did not succeed (cached result)");
                i.label = 7;
              case 7:
                return [2];
            }
          });
        });
      }, FileAccessControl.applyACLRulesSync = function (directory) {
        if (FileAccessControl.USE_ICACLS) {
          if (FileAccessControl.ACLED_DIRECTORIES[directory] === void 0) {
            this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync())), FileAccessControl.ACLED_DIRECTORIES[directory] = !0;
            return;
          } else if (!FileAccessControl.ACLED_DIRECTORIES[directory]) throw new Error("Setting ACL restrictions did not succeed (cached result)");
        }
      }, FileAccessControl._runICACLS = function (args) {
        return new Promise(function (resolve, reject) {
          var aclProc = child_process.spawn(FileAccessControl.ICACLS_PATH, args, {
            windowsHide: !0
          });
          aclProc.on("error", function (e) {
            return reject(e);
          }), aclProc.on("close", function (code, signal) {
            code === 0 ? resolve() : reject(new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
          });
        });
      }, FileAccessControl._runICACLSSync = function (args) {
        if (child_process.spawnSync) {
          var aclProc = child_process.spawnSync(FileAccessControl.ICACLS_PATH, args, {
            windowsHide: !0
          });
          if (aclProc.error) throw aclProc.error;
          if (aclProc.status !== 0) throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
        } else throw new Error("Could not synchronously call ICACLS under current version of Node.js");
      }, FileAccessControl._getACLIdentity = function () {
        return new Promise(function (resolve, reject) {
          FileAccessControl.ACL_IDENTITY && resolve(FileAccessControl.ACL_IDENTITY);
          var psProc = child_process.spawn(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
              windowsHide: !0,
              stdio: ["ignore", "pipe", "pipe"]
            }),
            data = "";
          psProc.stdout.on("data", function (d) {
            return data += d;
          }), psProc.on("error", function (e) {
            return reject(e);
          }), psProc.on("close", function (code, signal) {
            FileAccessControl.ACL_IDENTITY = data && data.trim(), code === 0 ? resolve(FileAccessControl.ACL_IDENTITY) : reject(new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"));
          });
        });
      }, FileAccessControl._getACLIdentitySync = function () {
        if (FileAccessControl.ACL_IDENTITY) return FileAccessControl.ACL_IDENTITY;
        if (child_process.spawnSync) {
          var psProc = child_process.spawnSync(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
            windowsHide: !0,
            stdio: ["ignore", "pipe", "pipe"]
          });
          if (psProc.error) throw psProc.error;
          if (psProc.status !== 0) throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
          return FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim(), FileAccessControl.ACL_IDENTITY;
        } else throw new Error("Could not synchronously get ACL identity under current version of Node.js");
      }, FileAccessControl._getACLArguments = function (directory, identity) {
        return [directory, "/grant", "*S-1-5-32-544:(OI)(CI)F", "/grant", identity + ":(OI)(CI)F", "/inheritance:r"];
      }, FileAccessControl.TAG = "FileAccessControl", FileAccessControl.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe", FileAccessControl.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe", FileAccessControl.ACLED_DIRECTORIES = {}, FileAccessControl.ACL_IDENTITY = null, FileAccessControl.OS_FILE_PROTECTION_CHECKED = !1, FileAccessControl.OS_PROVIDES_FILE_PROTECTION = !1, FileAccessControl.USE_ICACLS = os.type() === "Windows_NT", FileAccessControl;
    }();
  exports.FileAccessControl = FileAccessControl;
});
var RN = T((A4, tJ) => {
  "use strict";

  var ox = A4 && A4.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    ax = A4 && A4.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    fs = require("fs"),
    os = require("os"),
    path = require("path"),
    zlib = require("zlib"),
    Constants = L0(),
    AutoCollectHttpDependencies = s5(),
    FileSystemHelper = CS(),
    Util = il(),
    url_1 = require("url"),
    Logging = x0(),
    FileAccessControl_1 = JZ(),
    legacyThrottleStatusCode = 439,
    throttleStatusCode = 402,
    RESPONSE_CODES_INDICATING_REACHED_BREEZE = [200, 206, 402, 408, 429, 439, 500],
    Sender = function () {
      function Sender(config, getAuthorizationHandler, onSuccess, onError, statsbeat, isStatsbeatSender, shutdownStatsbeat) {
        this._redirectedHost = null, this._config = config, this._onSuccess = onSuccess, this._onError = onError, this._statsbeat = statsbeat, this._enableDiskRetryMode = !1, this._resendInterval = Sender.WAIT_BETWEEN_RESEND, this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK, this._numConsecutiveFailures = 0, this._numConsecutiveRedirects = 0, this._resendTimer = null, this._getAuthorizationHandler = getAuthorizationHandler, this._fileCleanupTimer = null, this._tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey), this._isStatsbeatSender = isStatsbeatSender || !1, this._shutdownStatsbeat = shutdownStatsbeat, this._failedToIngestCounter = 0, this._statsbeatHasReachedIngestionAtLeastOnce = !1;
      }
      return __name(Sender, "Sender"), Sender.prototype.setDiskRetryMode = function (value, resendInterval, maxBytesOnDisk) {
        var _this = this;
        value && FileAccessControl_1.FileAccessControl.checkFileProtection(), this._enableDiskRetryMode = FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && value, typeof resendInterval == "number" && resendInterval >= 0 && (this._resendInterval = Math.floor(resendInterval)), typeof maxBytesOnDisk == "number" && maxBytesOnDisk >= 0 && (this._maxBytesOnDisk = Math.floor(maxBytesOnDisk)), value && !FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && (this._enableDiskRetryMode = !1, this._logWarn("Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.")), this._enableDiskRetryMode ? (this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.DISK_RETRY), this._fileCleanupTimer || (this._fileCleanupTimer = setTimeout(function () {
          _this._fileCleanupTask();
        }, Sender.CLEANUP_TIMEOUT), this._fileCleanupTimer.unref())) : (this._statsbeat && this._statsbeat.removeFeature(Constants.StatsbeatFeature.DISK_RETRY), this._fileCleanupTimer && clearTimeout(this._fileCleanupTimer));
      }, Sender.prototype.send = function (envelopes, callback) {
        return ox(this, void 0, void 0, function () {
          var n,
            i,
            s,
            o,
            c,
            u,
            f,
            d,
            p = this;
          return ax(this, function (m) {
            switch (m.label) {
              case 0:
                if (!envelopes) return [3, 5];
                if (endpointUrl = this._redirectedHost || this._config.endpointUrl, endpointHost = new url_1.URL(endpointUrl).hostname, options = {
                  method: "POST",
                  withCredentials: !1,
                  headers: {
                    "Content-Type": "application/x-json-stream"
                  }
                }, authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null, !authHandler) return [3, 4];
                this._statsbeat && this._statsbeat.addFeature(Constants.StatsbeatFeature.AAD_HANDLING), m.label = 1;
              case 1:
                return m.trys.push([1, 3,, 4]), [4, authHandler.addAuthorizationHeader(options)];
              case 2:
                return _a.sent(), [3, 4];
              case 3:
                return c = m.sent(), errorMsg = "Failed to get AAD bearer token for the Application.", this._enableDiskRetryMode && (errorMsg += "This batch of telemetry items will be retried. ", this._storeToDisk(envelopes)), errorMsg += "Error:" + authError_1.toString(), this._logWarn(errorMsg), typeof callback == "function" && callback(errorMsg), [2];
              case 4:
                batch_1 = "", envelopes.forEach(function (envelope) {
                  var payload = Util.stringify(envelope);
                  typeof payload == "string" && (batch_1 += payload + `
`);
                }), batch_1.length > 0 && (batch_1 = batch_1.substring(0, batch_1.length - 1)), payload_1 = Buffer.from ? Buffer.from(batch_1) : new Buffer(batch_1), zlib.gzip(payload_1, function (err, buffer) {
                  var dataToSend = buffer;
                  err ? (_this._logWarn(Util.dumpObj(err)), dataToSend = payload_1, options.headers["Content-Length"] = payload_1.length.toString()) : (options.headers["Content-Encoding"] = "gzip", options.headers["Content-Length"] = buffer.length.toString()), _this._logInfo(Util.dumpObj(options)), options[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0;
                  var startTime = +new Date(),
                    requestCallback = __name(function (res) {
                      res.setEncoding("utf-8");
                      var responseString = "";
                      res.on("data", function (data) {
                        responseString += data;
                      }), res.on("end", function () {
                        var endTime = +new Date(),
                          duration = endTime - startTime;
                        if (_this._numConsecutiveFailures = 0, _this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce && (RESPONSE_CODES_INDICATING_REACHED_BREEZE.includes(res.statusCode) ? _this._statsbeatHasReachedIngestionAtLeastOnce = !0 : _this._statsbeatFailedToIngest()), _this._statsbeat && (res.statusCode == throttleStatusCode || res.statusCode == legacyThrottleStatusCode ? _this._statsbeat.countThrottle(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode) : _this._statsbeat.countRequest(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, duration, res.statusCode === 200, res.statusCode)), _this._enableDiskRetryMode) {
                          if (res.statusCode === 200) _this._resendTimer || (_this._resendTimer = setTimeout(function () {
                            _this._resendTimer = null, _this._sendFirstFileOnDisk();
                          }, _this._resendInterval), _this._resendTimer.unref());else if (_this._isRetriable(res.statusCode)) try {
                            _this._statsbeat && _this._statsbeat.countRetry(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);
                            var breezeResponse = JSON.parse(responseString),
                              filteredEnvelopes_1 = [];
                            breezeResponse.errors && (breezeResponse.errors.forEach(function (error) {
                              (error.statusCode == 429 || error.statusCode == 500 || error.statusCode == 503) && filteredEnvelopes_1.push(envelopes[error.index]);
                            }), filteredEnvelopes_1.length > 0 && _this._storeToDisk(filteredEnvelopes_1));
                          } catch {
                            _this._storeToDisk(envelopes);
                          }
                        }
                        if (res.statusCode === 307 || res.statusCode === 308) {
                          if (_this._numConsecutiveRedirects++, _this._numConsecutiveRedirects < 10) {
                            var locationHeader = res.headers.location ? res.headers.location.toString() : null;
                            locationHeader && (_this._redirectedHost = locationHeader, _this.send(envelopes, callback));
                          } else {
                            var circularRedirectError = {
                              name: "Circular Redirect",
                              message: "Error sending telemetry because of circular redirects."
                            };
                            _this._statsbeat && _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, circularRedirectError), typeof callback == "function" && callback("Error sending telemetry because of circular redirects.");
                          }
                        } else _this._numConsecutiveRedirects = 0, typeof callback == "function" && callback(responseString), _this._logInfo(responseString), typeof _this._onSuccess == "function" && _this._onSuccess(responseString);
                      });
                    }, "requestCallback"),
                    req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);
                  req.setTimeout(Sender.HTTP_TIMEOUT, function () {
                    _this._requestTimedOut = !0, req.abort();
                  }), req.on("error", function (error) {
                    if (_this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce && _this._statsbeatFailedToIngest(), _this._numConsecutiveFailures++, _this._statsbeat && _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, error), !_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {
                      var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
                      _this._enableDiskRetryMode && (notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:"), _this._logWarn(notice, Util.dumpObj(error));
                    } else {
                      var notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
                      _this._logInfo(notice, Util.dumpObj(error));
                    }
                    _this._onErrorHelper(error), typeof callback == "function" && (error ? (_this._requestTimedOut && (error.name = "telemetry timeout", error.message = "telemetry request timed out"), callback(Util.dumpObj(error))) : callback("Error sending telemetry")), _this._enableDiskRetryMode && _this._storeToDisk(envelopes);
                  }), req.write(dataToSend), req.end();
                }), m.label = 5;
              case 5:
                return [2];
            }
          });
        });
      }, Sender.prototype.saveOnCrash = function (envelopes) {
        this._enableDiskRetryMode && this._storeToDiskSync(Util.stringify(envelopes));
      }, Sender.prototype._isRetriable = function (statusCode) {
        return statusCode === 206 || statusCode === 401 || statusCode === 403 || statusCode === 408 || statusCode === 429 || statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504;
      }, Sender.prototype._logInfo = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        this._isStatsbeatSender || Logging.info(Sender.TAG, message, optionalParams);
      }, Sender.prototype._logWarn = function (message) {
        for (var optionalParams = [], _i = 1; _i < arguments.length; _i++) optionalParams[_i - 1] = arguments[_i];
        this._isStatsbeatSender || Logging.warn(Sender.TAG, message, optionalParams);
      }, Sender.prototype._statsbeatFailedToIngest = function () {
        this._shutdownStatsbeat && (this._failedToIngestCounter++, this._failedToIngestCounter >= 3 && this._shutdownStatsbeat());
      }, Sender.prototype._storeToDisk = function (envelopes) {
        return ox(this, void 0, void 0, function () {
          var r, n, i, s, o, c, u;
          return ax(this, function (f) {
            switch (f.label) {
              case 0:
                return f.trys.push([0, 2,, 3]), this._logInfo("Checking existence of data storage directory: " + this._tempDir), [4, FileSystemHelper.confirmDirExists(this._tempDir)];
              case 1:
                return _a.sent(), [3, 3];
              case 2:
                return r = f.sent(), this._logWarn("Failed to create folder to put telemetry: " + Util.dumpObj(ex_1)), this._onErrorHelper(ex_1), [2];
              case 3:
                return f.trys.push([3, 5,, 6]), [4, FileAccessControl_1.FileAccessControl.applyACLRules(this._tempDir)];
              case 4:
                return _a.sent(), [3, 6];
              case 5:
                return n = f.sent(), this._logWarn("Failed to apply file access control to folder: " + Util.dumpObj(ex_2)), this._onErrorHelper(ex_2), [2];
              case 6:
                return f.trys.push([6, 8,, 9]), [4, FileSystemHelper.getShallowDirectorySize(this._tempDir)];
              case 7:
                return size = _a.sent(), size > this._maxBytesOnDisk ? (this._logWarn("Not saving data due to max size limit being met. Directory size in bytes is: " + size), [2]) : [3, 9];
              case 8:
                return s = f.sent(), this._logWarn("Failed to read directory for retriable telemetry: " + Util.dumpObj(ex_3)), this._onErrorHelper(ex_3), [2];
              case 9:
                return f.trys.push([9, 11,, 12]), fileName = new Date().getTime() + ".ai.json", fileFullPath = path.join(this._tempDir, fileName), this._logInfo("saving data to disk at: " + fileFullPath), [4, FileSystemHelper.writeFileAsync(fileFullPath, Util.stringify(envelopes), {
                  mode: 384
                })];
              case 10:
                return _a.sent(), [3, 12];
              case 11:
                return u = f.sent(), this._logWarn("Failed to persist telemetry to disk: " + Util.dumpObj(ex_4)), this._onErrorHelper(ex_4), [2];
              case 12:
                return [2];
            }
          });
        });
      }, Sender.prototype._storeToDiskSync = function (payload) {
        try {
          this._logInfo("Checking existence of data storage directory: " + this._tempDir), fs.existsSync(this._tempDir) || fs.mkdirSync(this._tempDir), FileAccessControl_1.FileAccessControl.applyACLRulesSync(this._tempDir);
          var dirSize = FileSystemHelper.getShallowDirectorySizeSync(this._tempDir);
          if (dirSize > this._maxBytesOnDisk) {
            this._logInfo("Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
            return;
          }
          var fileName = new Date().getTime() + ".ai.json",
            fileFullPath = path.join(this._tempDir, fileName);
          this._logInfo("saving data before crash to disk at: " + fileFullPath), fs.writeFileSync(fileFullPath, payload, {
            mode: 384
          });
        } catch (error) {
          this._logWarn("Error while saving data to disk: " + Util.dumpObj(error)), this._onErrorHelper(error);
        }
      }, Sender.prototype._sendFirstFileOnDisk = function () {
        return ox(this, void 0, void 0, function () {
          var t, r, n, i, s, o;
          return ax(this, function (c) {
            switch (c.label) {
              case 0:
                return c.trys.push([0, 6,, 7]), [4, FileSystemHelper.readdirAsync(this._tempDir)];
              case 1:
                return files = _a.sent(), files = files.filter(function (f) {
                  return path.basename(f).indexOf(".ai.json") > -1;
                }), files.length > 0 ? (firstFile = files[0], filePath = path.join(this._tempDir, firstFile), [4, FileSystemHelper.readFileAsync(filePath)]) : [3, 5];
              case 2:
                return buffer = _a.sent(), [4, FileSystemHelper.unlinkAsync(filePath)];
              case 3:
                return _a.sent(), envelopes = JSON.parse(buffer.toString()), [4, this.send(envelopes)];
              case 4:
                _a.sent(), c.label = 5;
              case 5:
                return [3, 7];
              case 6:
                return o = c.sent(), this._onErrorHelper(err_1), [3, 7];
              case 7:
                return [2];
            }
          });
        });
      }, Sender.prototype._onErrorHelper = function (error) {
        typeof this._onError == "function" && this._onError(error);
      }, Sender.prototype._fileCleanupTask = function () {
        return ox(this, void 0, void 0, function () {
          var t,
            r,
            n,
            i,
            s,
            o,
            c = this;
          return ax(this, function (u) {
            switch (u.label) {
              case 0:
                return u.trys.push([0, 6,, 7]), [4, FileSystemHelper.readdirAsync(this._tempDir)];
              case 1:
                if (files = _a.sent(), files = files.filter(function (f) {
                  return path.basename(f).indexOf(".ai.json") > -1;
                }), !(files.length > 0)) return [3, 5];
                i = 0, u.label = 2;
              case 2:
                return i < files.length ? (fileCreationDate = new Date(parseInt(files[i].split(".ai.json")[0])), expired = new Date(+new Date() - Sender.FILE_RETEMPTION_PERIOD) > fileCreationDate, expired ? (filePath = path.join(this._tempDir, files[i]), [4, FileSystemHelper.unlinkAsync(filePath).catch(function (err) {
                  _this._onErrorHelper(err);
                })]) : [3, 4]) : [3, 5];
              case 3:
                _a.sent(), u.label = 4;
              case 4:
                return i++, [3, 2];
              case 5:
                return [3, 7];
              case 6:
                return o = u.sent(), err_2.code != "ENOENT" && this._onErrorHelper(err_2), [3, 7];
              case 7:
                return [2];
            }
          });
        });
      }, Sender.TAG = "Sender", Sender.WAIT_BETWEEN_RESEND = 60 * 1e3, Sender.MAX_BYTES_ON_DISK = 50 * 1024 * 1024, Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5, Sender.CLEANUP_TIMEOUT = 60 * 60 * 1e3, Sender.FILE_RETEMPTION_PERIOD = 7 * 24 * 60 * 60 * 1e3, Sender.TEMPDIR_PREFIX = "appInsights-node", Sender.HTTP_TIMEOUT = 2e4, Sender;
    }();
  module.exports = Sender;
});
var nJ = T(lx => {
  "use strict";

  Object.defineProperty(lx, "__esModule", {
    value: !0
  });
  lx.AzureVirtualMachine = void 0;
  var Logging = x0(),
    Util = il(),
    AutoCollectHttpDependencies = s5(),
    AIMS_URI = "http://169.254.169.254/metadata/instance/compute",
    AIMS_API_VERSION = "api-version=2017-12-01",
    AIMS_FORMAT = "format=json",
    ConnectionErrorMessage = "UNREACH",
    AzureVirtualMachine = function () {
      function AzureVirtualMachine() {}
      return __name(AzureVirtualMachine, "AzureVirtualMachine"), AzureVirtualMachine.getAzureComputeMetadata = function (config, callback) {
        var n,
          _this = this,
          vmInfo = {},
          metadataRequestUrl = AIMS_URI + "?" + AIMS_API_VERSION + "&" + AIMS_FORMAT,
          requestOptions = (_a = {
            method: "GET"
          }, _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = !0, _a.headers = {
            Metadata: "True"
          }, n),
          req = Util.makeRequest(config, metadataRequestUrl, requestOptions, function (res) {
            if (res.statusCode === 200) {
              vmInfo.isVM = !0;
              var virtualMachineData_1 = "";
              res.on("data", function (data) {
                virtualMachineData_1 += data;
              }), res.on("end", function () {
                try {
                  var data = JSON.parse(virtualMachineData_1);
                  vmInfo.id = data.vmId || "", vmInfo.subscriptionId = data.subscriptionId || "", vmInfo.osType = data.osType || "";
                } catch (error) {
                  Logging.info(AzureVirtualMachine.TAG, error);
                }
                callback(vmInfo);
              });
            } else callback(vmInfo);
          }, !1, !1);
        req && (setTimeout(function () {
          _this._requestTimedOut = !0, req.abort();
        }, AzureVirtualMachine.HTTP_TIMEOUT), req.on("error", function (error) {
          _this._requestTimedOut && error && (error.name = "telemetry timeout", error.message = "telemetry request timed out"), error && error.message && error.message.indexOf(ConnectionErrorMessage) > -1 ? vmInfo.isVM = !1 : Logging.info(AzureVirtualMachine.TAG, error), callback(vmInfo);
        }), req.end());
      }, AzureVirtualMachine.HTTP_TIMEOUT = 2500, AzureVirtualMachine.TAG = "AzureVirtualMachine", AzureVirtualMachine;
    }();
  exports.AzureVirtualMachine = AzureVirtualMachine;
});
var iJ = T(cx => {
  "use strict";

  Object.defineProperty(cx, "__esModule", {
    value: !0
  });
  cx.NetworkStatsbeat = void 0;
  var NetworkStatsbeat = function () {
    function NetworkStatsbeat(endpoint, host) {
      this.endpoint = endpoint, this.host = host, this.totalRequestCount = 0, this.totalSuccesfulRequestCount = 0, this.totalFailedRequestCount = [], this.retryCount = [], this.exceptionCount = [], this.throttleCount = [], this.intervalRequestExecutionTime = 0, this.lastIntervalRequestExecutionTime = 0, this.lastTime = +new Date(), this.lastRequestCount = 0;
    }
    return __name(NetworkStatsbeat, "NetworkStatsbeat"), NetworkStatsbeat;
  }();
  exports.NetworkStatsbeat = NetworkStatsbeat;
});
var cJ = T((zm, lJ) => {
  "use strict";

  var Mf = zm && zm.__assign || function () {
      return Mf = Object.assign || function (e) {
        for (var t, r = 1, n = arguments.length; r < n; r++) {
          t = arguments[r];
          for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        }
        return e;
      }, Mf.apply(this, arguments);
    },
    NN = zm && zm.__awaiter || function (e, t, r, n) {
      function i(s) {
        return s instanceof r ? s : new r(function (o) {
          o(s);
        });
      }
      return l(i, "adopt"), new (r || (r = Promise))(function (s, o) {
        function c(d) {
          try {
            f(n.next(d));
          } catch (p) {
            o(p);
          }
        }
        l(c, "fulfilled");
        function u(d) {
          try {
            f(n.throw(d));
          } catch (p) {
            o(p);
          }
        }
        l(u, "rejected");
        function f(d) {
          d.done ? s(d.value) : i(d.value).then(c, u);
        }
        l(f, "step"), f((n = n.apply(e, t || [])).next());
      });
    },
    ON = zm && zm.__generator || function (e, t) {
      var r = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1];
            return s[1];
          },
          trys: [],
          ops: []
        },
        n,
        i,
        s,
        o;
      return o = {
        next: c(0),
        throw: c(1),
        return: c(2)
      }, typeof Symbol == "function" && (o[Symbol.iterator] = function () {
        return this;
      }), o;
      function c(f) {
        return function (d) {
          return u([f, d]);
        };
      }
      function u(f) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; r;) try {
          if (n = 1, i && (s = f[0] & 2 ? i.return : f[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, f[1])).done) return s;
          switch (i = 0, s && (f = [f[0] & 2, s.value]), f[0]) {
            case 0:
            case 1:
              s = f;
              break;
            case 4:
              return r.label++, {
                value: f[1],
                done: !1
              };
            case 5:
              r.label++, i = f[1], f = [0];
              continue;
            case 7:
              f = r.ops.pop(), r.trys.pop();
              continue;
            default:
              if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (f[0] === 6 || f[0] === 2)) {
                r = 0;
                continue;
              }
              if (f[0] === 3 && (!s || f[1] > s[0] && f[1] < s[3])) {
                r.label = f[1];
                break;
              }
              if (f[0] === 6 && r.label < s[1]) {
                r.label = s[1], s = f;
                break;
              }
              if (s && r.label < s[2]) {
                r.label = s[2], r.ops.push(f);
                break;
              }
              s[2] && r.ops.pop(), r.trys.pop();
              continue;
          }
          f = t.call(e, r);
        } catch (d) {
          f = [6, d], i = 0;
        } finally {
          n = s = 0;
        }
        if (f[0] & 5) throw f[1];
        return {
          value: f[0] ? f[1] : void 0,
          done: !0
        };
      }
    },
    os = require("os"),
    EnvelopeFactory = AN(),
    Logging = x0(),
    Sender = RN(),
    Constants = L0(),
    Contracts = Gl(),
    Vm = nJ(),
    Config = IR(),
    Context = Zg(),
    Network = iJ(),
    Util = il(),
    STATSBEAT_LANGUAGE = "node",
    Statsbeat = function () {
      function Statsbeat(config, context) {
        this._attach = Constants.StatsbeatAttach.sdk, this._feature = Constants.StatsbeatFeature.NONE, this._instrumentation = Constants.StatsbeatInstrumentation.NONE, this._isInitialized = !1, this._statbeatMetrics = [], this._networkStatsbeatCollection = [], this._config = config, this._context = context || new Context();
        var statsbeatConnectionString = this._getConnectionString(config);
        this._statsbeatConfig = new Config(statsbeatConnectionString), this._statsbeatConfig.samplingPercentage = 100, this._sender = new Sender(this._statsbeatConfig, null, null, null, null, !0, this._shutdownStatsbeat.bind(this));
      }
      return __name(Statsbeat, "Statsbeat"), Statsbeat.prototype.enable = function (isEnabled) {
        var _this = this;
        this._isEnabled = isEnabled, this._isEnabled && !this._isInitialized && (this._getCustomProperties(), this._isInitialized = !0), isEnabled ? (this._handle || (this._handle = setInterval(function () {
          _this.trackShortIntervalStatsbeats();
        }, Statsbeat.STATS_COLLECTION_SHORT_INTERVAL), this._handle.unref()), this._longHandle || (this.trackLongIntervalStatsbeats(), this._longHandle = setInterval(function () {
          _this.trackLongIntervalStatsbeats();
        }, Statsbeat.STATS_COLLECTION_LONG_INTERVAL), this._longHandle.unref())) : (this._handle && (clearInterval(this._handle), this._handle = null), this._longHandle && (clearInterval(this._longHandle), this._longHandle = null));
      }, Statsbeat.prototype.isInitialized = function () {
        return this._isInitialized;
      }, Statsbeat.prototype.isEnabled = function () {
        return this._isEnabled;
      }, Statsbeat.prototype.setCodelessAttach = function () {
        this._attach = Constants.StatsbeatAttach.codeless;
      }, Statsbeat.prototype.addFeature = function (feature) {
        this._feature |= feature;
      }, Statsbeat.prototype.removeFeature = function (feature) {
        this._feature &= ~feature;
      }, Statsbeat.prototype.addInstrumentation = function (instrumentation) {
        this._instrumentation |= instrumentation;
      }, Statsbeat.prototype.removeInstrumentation = function (instrumentation) {
        this._instrumentation &= ~instrumentation;
      }, Statsbeat.prototype.countRequest = function (endpoint, host, duration, success, statusCode) {
        if (this.isEnabled()) {
          var counter = this._getNetworkStatsbeatCounter(endpoint, host);
          if (counter.totalRequestCount++, counter.intervalRequestExecutionTime += duration, success === !1) {
            if (!statusCode) return;
            var currentStatusCounter = counter.totalFailedRequestCount.find(function (statusCounter) {
              return statusCode === statusCounter.statusCode;
            });
            currentStatusCounter ? currentStatusCounter.count++ : counter.totalFailedRequestCount.push({
              statusCode: statusCode,
              count: 1
            });
          } else counter.totalSuccesfulRequestCount++;
        }
      }, Statsbeat.prototype.countException = function (endpoint, host, exceptionType) {
        if (this.isEnabled()) {
          var counter = this._getNetworkStatsbeatCounter(endpoint, host),
            currentErrorCounter = counter.exceptionCount.find(function (exceptionCounter) {
              return exceptionType.name === exceptionCounter.exceptionType;
            });
          currentErrorCounter ? currentErrorCounter.count++ : counter.exceptionCount.push({
            exceptionType: exceptionType.name,
            count: 1
          });
        }
      }, Statsbeat.prototype.countThrottle = function (endpoint, host, statusCode) {
        if (this.isEnabled()) {
          var counter = this._getNetworkStatsbeatCounter(endpoint, host),
            currentStatusCounter = counter.throttleCount.find(function (statusCounter) {
              return statusCode === statusCounter.statusCode;
            });
          currentStatusCounter ? currentStatusCounter.count++ : counter.throttleCount.push({
            statusCode: statusCode,
            count: 1
          });
        }
      }, Statsbeat.prototype.countRetry = function (endpoint, host, statusCode) {
        if (this.isEnabled()) {
          var counter = this._getNetworkStatsbeatCounter(endpoint, host),
            currentStatusCounter = counter.retryCount.find(function (statusCounter) {
              return statusCode === statusCounter.statusCode;
            });
          currentStatusCounter ? currentStatusCounter.count++ : counter.retryCount.push({
            statusCode: statusCode,
            count: 1
          });
        }
      }, Statsbeat.prototype.trackShortIntervalStatsbeats = function () {
        return NN(this, void 0, void 0, function () {
          var t, r;
          return ON(this, function (n) {
            switch (n.label) {
              case 0:
                return n.trys.push([0, 3,, 4]), [4, this._getResourceProvider()];
              case 1:
                return _a.sent(), networkProperties = {
                  os: this._os,
                  rp: this._resourceProvider,
                  cikey: this._cikey,
                  runtimeVersion: this._runtimeVersion,
                  language: this._language,
                  version: this._sdkVersion,
                  attach: this._attach
                }, this._trackRequestDuration(networkProperties), this._trackRequestsCount(networkProperties), [4, this._sendStatsbeats()];
              case 2:
                return _a.sent(), [3, 4];
              case 3:
                return r = n.sent(), Logging.info(Statsbeat.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_1)), [3, 4];
              case 4:
                return [2];
            }
          });
        });
      }, Statsbeat.prototype.trackLongIntervalStatsbeats = function () {
        return NN(this, void 0, void 0, function () {
          var t, r, n, i, s;
          return ON(this, function (o) {
            switch (o.label) {
              case 0:
                return o.trys.push([0, 3,, 4]), [4, this._getResourceProvider()];
              case 1:
                return _a.sent(), commonProperties = {
                  os: this._os,
                  rp: this._resourceProvider,
                  cikey: this._cikey,
                  runtimeVersion: this._runtimeVersion,
                  language: this._language,
                  version: this._sdkVersion,
                  attach: this._attach
                }, attachProperties = Object.assign({
                  rpId: this._resourceIdentifier
                }, commonProperties), this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.ATTACH,
                  value: 1,
                  properties: attachProperties
                }), this._instrumentation != Constants.StatsbeatInstrumentation.NONE && (instrumentationProperties = Object.assign({
                  feature: this._instrumentation,
                  type: Constants.StatsbeatFeatureType.Instrumentation
                }, commonProperties), this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.FEATURE,
                  value: 1,
                  properties: instrumentationProperties
                })), this._feature != Constants.StatsbeatFeature.NONE && (featureProperties = Object.assign({
                  feature: this._feature,
                  type: Constants.StatsbeatFeatureType.Feature
                }, commonProperties), this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.FEATURE,
                  value: 1,
                  properties: featureProperties
                })), [4, this._sendStatsbeats()];
              case 2:
                return _a.sent(), [3, 4];
              case 3:
                return s = o.sent(), Logging.info(Statsbeat.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_2)), [3, 4];
              case 4:
                return [2];
            }
          });
        });
      }, Statsbeat.prototype._getNetworkStatsbeatCounter = function (endpoint, host) {
        for (var shortHost = this._getShortHost(host), i = 0; i < this._networkStatsbeatCollection.length; i++) if (endpoint === this._networkStatsbeatCollection[i].endpoint && shortHost === this._networkStatsbeatCollection[i].host) return this._networkStatsbeatCollection[i];
        var newCounter = new Network.NetworkStatsbeat(endpoint, shortHost);
        return this._networkStatsbeatCollection.push(newCounter), newCounter;
      }, Statsbeat.prototype._trackRequestDuration = function (commonProperties) {
        for (var i = 0; i < this._networkStatsbeatCollection.length; i++) {
          var currentCounter = this._networkStatsbeatCollection[i];
          currentCounter.time = +new Date();
          var intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0,
            totalRequestExecutionTime = currentCounter.intervalRequestExecutionTime - currentCounter.lastIntervalRequestExecutionTime,
            averageRequestExecutionTime = totalRequestExecutionTime > 0 && totalRequestExecutionTime / intervalRequests || 0;
          if (currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime, intervalRequests > 0) {
            var properties = Object.assign({
              endpoint: this._networkStatsbeatCollection[i].endpoint,
              host: this._networkStatsbeatCollection[i].host
            }, commonProperties);
            this._statbeatMetrics.push({
              name: Constants.StatsbeatCounter.REQUEST_DURATION,
              value: averageRequestExecutionTime,
              properties: properties
            });
          }
          currentCounter.lastRequestCount = currentCounter.totalRequestCount, currentCounter.lastTime = currentCounter.time;
        }
      }, Statsbeat.prototype._getShortHost = function (originalHost) {
        var shortHost = originalHost;
        try {
          var hostRegex = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/),
            res = hostRegex.exec(originalHost);
          res != null && res.length > 1 && (shortHost = res[1]), shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
        } catch {}
        return shortHost;
      }, Statsbeat.prototype._trackRequestsCount = function (commonProperties) {
        for (var _this = this, n = l(function (i) {
            currentCounter = this_1._networkStatsbeatCollection[i];
            var properties = Object.assign({
              endpoint: currentCounter.endpoint,
              host: currentCounter.host
            }, commonProperties);
            currentCounter.totalSuccesfulRequestCount > 0 && (this_1._statbeatMetrics.push({
              name: Constants.StatsbeatCounter.REQUEST_SUCCESS,
              value: currentCounter.totalSuccesfulRequestCount,
              properties: properties
            }), currentCounter.totalSuccesfulRequestCount = 0), currentCounter.totalFailedRequestCount.length > 0 && (currentCounter.totalFailedRequestCount.forEach(function (currentCounter) {
              properties = Object.assign(__assign(__assign({}, properties), {
                statusCode: currentCounter.statusCode
              })), _this._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.REQUEST_FAILURE,
                value: currentCounter.count,
                properties: properties
              });
            }), currentCounter.totalFailedRequestCount = []), currentCounter.retryCount.length > 0 && (currentCounter.retryCount.forEach(function (currentCounter) {
              properties = Object.assign(__assign(__assign({}, properties), {
                statusCode: currentCounter.statusCode
              })), _this._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.RETRY_COUNT,
                value: currentCounter.count,
                properties: properties
              });
            }), currentCounter.retryCount = []), currentCounter.throttleCount.length > 0 && (currentCounter.throttleCount.forEach(function (currentCounter) {
              properties = Object.assign(__assign(__assign({}, properties), {
                statusCode: currentCounter.statusCode
              })), _this._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.THROTTLE_COUNT,
                value: currentCounter.count,
                properties: properties
              });
            }), currentCounter.throttleCount = []), currentCounter.exceptionCount.length > 0 && (currentCounter.exceptionCount.forEach(function (currentCounter) {
              properties = Object.assign(__assign(__assign({}, properties), {
                exceptionType: currentCounter.exceptionType
              })), _this._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.EXCEPTION_COUNT,
                value: currentCounter.count,
                properties: properties
              });
            }), currentCounter.exceptionCount = []);
          }, "_loop_1"), i = this, currentCounter, i = 0; i < this._networkStatsbeatCollection.length; i++) n(i);
      }, Statsbeat.prototype._sendStatsbeats = function () {
        return NN(this, void 0, void 0, function () {
          var t, r, n, i;
          return ON(this, function (s) {
            switch (s.label) {
              case 0:
                for (envelopes = [], i = 0; i < this._statbeatMetrics.length; i++) statsbeat = {
                  name: this._statbeatMetrics[i].name,
                  value: this._statbeatMetrics[i].value,
                  properties: this._statbeatMetrics[i].properties
                }, envelope = EnvelopeFactory.createEnvelope(statsbeat, Contracts.TelemetryType.Metric, null, this._context, this._statsbeatConfig), envelope.name = Constants.StatsbeatTelemetryName, envelopes.push(envelope);
                return this._statbeatMetrics = [], [4, this._sender.send(envelopes)];
              case 1:
                return _a.sent(), [2];
            }
          });
        });
      }, Statsbeat.prototype._getCustomProperties = function () {
        this._language = STATSBEAT_LANGUAGE, this._cikey = this._config.instrumentationKey, this._sdkVersion = Context.sdkVersion, this._os = os.type(), this._runtimeVersion = process.version;
      }, Statsbeat.prototype._getResourceProvider = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
          var waiting = !1;
          _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown, _this._resourceIdentifier = Constants.StatsbeatResourceProvider.unknown, process.env.WEBSITE_SITE_NAME ? (_this._resourceProvider = Constants.StatsbeatResourceProvider.appsvc, _this._resourceIdentifier = process.env.WEBSITE_SITE_NAME, process.env.WEBSITE_HOME_STAMPNAME && (_this._resourceIdentifier += "/" + process.env.WEBSITE_HOME_STAMPNAME)) : process.env.FUNCTIONS_WORKER_RUNTIME ? (_this._resourceProvider = Constants.StatsbeatResourceProvider.functions, process.env.WEBSITE_HOSTNAME && (_this._resourceIdentifier = process.env.WEBSITE_HOSTNAME)) : _this._config && (_this._isVM === void 0 || _this._isVM == !0 ? (waiting = !0, Vm.AzureVirtualMachine.getAzureComputeMetadata(_this._config, function (vmInfo) {
            _this._isVM = vmInfo.isVM, _this._isVM && (_this._resourceProvider = Constants.StatsbeatResourceProvider.vm, _this._resourceIdentifier = vmInfo.id + "/" + vmInfo.subscriptionId, vmInfo.osType && (_this._os = vmInfo.osType)), resolve();
          })) : _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown), waiting || resolve();
        });
      }, Statsbeat.prototype._shutdownStatsbeat = function () {
        this.enable(!1);
      }, Statsbeat.prototype._getConnectionString = function (config) {
        for (var currentEndpoint = config.endpointUrl, euEndpoints = ["westeurope", "northeurope", "francecentral", "francesouth", "germanywestcentral", "norwayeast", "norwaywest", "swedencentral", "switzerlandnorth", "switzerlandwest", "uksouth", "ukwest"], i = 0; i < euEndpoints.length; i++) if (currentEndpoint.indexOf(euEndpoints[i]) > -1) return Statsbeat.EU_CONNECTION_STRING;
        return Statsbeat.NON_EU_CONNECTION_STRING;
      }, Statsbeat.NON_EU_CONNECTION_STRING = "InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com", Statsbeat.EU_CONNECTION_STRING = "InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com", Statsbeat.STATS_COLLECTION_SHORT_INTERVAL = 9e5, Statsbeat.STATS_COLLECTION_LONG_INTERVAL = 864e5, Statsbeat.TAG = "Statsbeat", Statsbeat;
    }();
  module.exports = Statsbeat;
});
var dJ = T((Bet, fJ) => {
  "use strict";

  var url = require("url"),
    Config = IR(),
    AuthorizationHandler = qZ(),
    Context = Zg(),
    Contracts = Gl(),
    Channel = HZ(),
    TelemetryProcessors = XZ(),
    CorrelationContextManager_1 = Mp(),
    Statsbeat = cJ(),
    Sender = RN(),
    Util = il(),
    Logging = x0(),
    EnvelopeFactory = AN(),
    TelemetryClient = function () {
      function TelemetryClient(setupString) {
        this._telemetryProcessors = [];
        var config = new Config(setupString);
        if (this.config = config, !this.config.instrumentationKey || this.config.instrumentationKey == "") throw new Error("Instrumentation key not found, please provide a connection string before starting Application Insights SDK.");
        this.context = new Context(), this.commonProperties = {}, this.authorizationHandler = null, this.config.disableStatsbeat || (this._statsbeat = new Statsbeat(this.config, this.context), this._statsbeat.enable(!0));
        var sender = new Sender(this.config, this.getAuthorizationHandler, null, null, this._statsbeat);
        this.channel = new Channel(function () {
          return config.disableAppInsights;
        }, function () {
          return config.maxBatchSize;
        }, function () {
          return config.maxBatchIntervalMs;
        }, sender);
      }
      return __name(TelemetryClient, "TelemetryClient"), TelemetryClient.prototype.trackAvailability = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Availability);
      }, TelemetryClient.prototype.trackPageView = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.PageView);
      }, TelemetryClient.prototype.trackTrace = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Trace);
      }, TelemetryClient.prototype.trackMetric = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Metric);
      }, TelemetryClient.prototype.trackException = function (telemetry) {
        telemetry && telemetry.exception && !Util.isError(telemetry.exception) && (telemetry.exception = new Error(telemetry.exception.toString())), this.track(telemetry, Contracts.TelemetryType.Exception);
      }, TelemetryClient.prototype.trackEvent = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Event);
      }, TelemetryClient.prototype.trackRequest = function (telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Request);
      }, TelemetryClient.prototype.trackDependency = function (telemetry) {
        if (telemetry && !telemetry.target && telemetry.data) try {
          telemetry.target = new url.URL(telemetry.data).host;
        } catch (error) {
          telemetry.target = null, Logging.warn(TelemetryClient.TAG, "The URL object is failed to create.", error);
        }
        this.track(telemetry, Contracts.TelemetryType.Dependency);
      }, TelemetryClient.prototype.flush = function (options) {
        this.channel.triggerSend(options ? !!options.isAppCrashing : !1, options ? options.callback : void 0);
      }, TelemetryClient.prototype.track = function (telemetry, telemetryType) {
        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
          var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
          telemetry.time && (envelope.time = telemetry.time.toISOString());
          var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
          accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, {
            correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext()
          }), TelemetryProcessors.preAggregatedMetricsTelemetryProcessor(envelope, this.context), accepted && (TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient), this.channel.send(envelope));
        } else Logging.warn(TelemetryClient.TAG, "track() requires telemetry object and telemetryType to be specified.");
      }, TelemetryClient.prototype.setAutoPopulateAzureProperties = function (value) {}, TelemetryClient.prototype.getAuthorizationHandler = function (config) {
        return config && config.aadTokenCredential ? (this.authorizationHandler || (Logging.info(TelemetryClient.TAG, "Adding authorization handler"), this.authorizationHandler = new AuthorizationHandler(config.aadTokenCredential)), this.authorizationHandler) : null;
      }, TelemetryClient.prototype.addTelemetryProcessor = function (telemetryProcessor) {
        this._telemetryProcessors.push(telemetryProcessor);
      }, TelemetryClient.prototype.clearTelemetryProcessors = function () {
        this._telemetryProcessors = [];
      }, TelemetryClient.prototype.runTelemetryProcessors = function (envelope, contextObjects) {
        var accepted = !0,
          telemetryProcessorsCount = this._telemetryProcessors.length;
        if (telemetryProcessorsCount === 0) return accepted;
        contextObjects = contextObjects || {}, contextObjects.correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        for (var i = 0; i < telemetryProcessorsCount; ++i) try {
          var processor = this._telemetryProcessors[i];
          if (processor && processor.apply(null, [envelope, contextObjects]) === !1) {
            accepted = !1;
            break;
          }
        } catch (error) {
          accepted = !0, Logging.warn(TelemetryClient.TAG, "One of telemetry processors failed, telemetry item will be sent.", error, envelope);
        }
        return accepted && (envelope && envelope.tags && (envelope.tags = Util.validateStringMap(envelope.tags)), envelope && envelope.data && envelope.data.baseData && envelope.data.baseData.properties && (envelope.data.baseData.properties = Util.validateStringMap(envelope.data.baseData.properties))), accepted;
      }, TelemetryClient.prototype.getStatsbeat = function () {
        return this._statsbeat;
      }, TelemetryClient.TAG = "TelemetryClient", TelemetryClient;
    }();
  module.exports = TelemetryClient;
});
var hJ = T((DN, mJ) => {
  "use strict";

  var rCe = DN && DN.__extends || function () {
      var e = l(function (t, r) {
        return e = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (n, i) {
          n.__proto__ = i;
        } || function (n, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (n[s] = i[s]);
        }, e(t, r);
      }, "extendStatics");
      return function (t, r) {
        e(t, r);
        function n() {
          this.constructor = t;
        }
        l(n, "__"), t.prototype = r === null ? Object.create(r) : (n.prototype = r.prototype, new n());
      };
    }(),
    TelemetryClient = dJ(),
    ServerRequestTracking = xR(),
    ClientRequestTracking = s5(),
    Logging = x0(),
    NodeClient = function (_super) {
      __extends(NodeClient, _super);
      function NodeClient() {
        return e !== null && e.apply(this, arguments) || this;
      }
      return __name(NodeClient, "NodeClient"), NodeClient.prototype.trackNodeHttpRequestSync = function (telemetry) {
        telemetry && telemetry.request && telemetry.response && telemetry.duration ? ServerRequestTracking.trackRequestSync(this, telemetry) : Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
      }, NodeClient.prototype.trackNodeHttpRequest = function (telemetry) {
        (telemetry.duration || telemetry.error) && Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects."), telemetry && telemetry.request && telemetry.response ? ServerRequestTracking.trackRequest(this, telemetry) : Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
      }, NodeClient.prototype.trackNodeHttpDependency = function (telemetry) {
        telemetry && telemetry.request ? ClientRequestTracking.trackRequest(this, telemetry) : Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
      }, NodeClient;
    }(TelemetryClient);
  module.exports = NodeClient;
});
var require_Functions = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
});
var TJ = T(qn => {
  "use strict";

  Object.defineProperty(qn, "__esModule", {
    value: !0
  });
  qn.dispose = qn.Configuration = qn.wrapWithCorrelationContext = qn.startOperation = qn.getCorrelationContext = qn.start = qn.setup = qn.liveMetricsClient = qn.defaultClient = qn.DistributedTracingModes = void 0;
  var CorrelationContextManager = Mp(),
    AutoCollectConsole = nX(),
    AutoCollectExceptions = sX(),
    AutoCollectPerformance = b7(),
    AutoCollecPreAggregatedMetrics = oR(),
    HeartBeat = pX(),
    WebSnippet = SX(),
    AutoCollectHttpDependencies = s5(),
    AutoCollectHttpRequests = xR(),
    CorrelationIdManager = wm(),
    Logging = x0(),
    QuickPulseClient = iY(),
    NativePerformance_1 = sY(),
    AzureFunctionsHook_1 = lY();
  exports.TelemetryClient = hJ();
  exports.Contracts = Gl();
  exports.azureFunctionsTypes = _J();
  var DistributedTracingModes;
  (function (DistributedTracingModes) {
    DistributedTracingModes[DistributedTracingModes.AI = 0] = "AI", DistributedTracingModes[DistributedTracingModes.AI_AND_W3C = 1] = "AI_AND_W3C";
  })(DistributedTracingModes = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));
  var defaultConfig = _getDefaultAutoCollectConfig(),
    _isConsole = defaultConfig.isConsole(),
    _isConsoleLog = defaultConfig.isConsoleLog(),
    _isLoggerErrorToTrace = defaultConfig.isLoggerErrorToTrace(),
    _isExceptions = defaultConfig.isExceptions(),
    _isPerformance = defaultConfig.isPerformance(),
    _isPreAggregatedMetrics = defaultConfig.isPreAggregatedMetrics(),
    _isHeartBeat = defaultConfig.isHeartBeat(),
    _isRequests = defaultConfig.isRequests(),
    _isDependencies = defaultConfig.isDependencies(),
    _isDiskRetry = defaultConfig.isDiskRetry(),
    _isCorrelating = defaultConfig.isCorrelating(),
    _forceClsHooked,
    _isSendingLiveMetrics = defaultConfig.isSendingLiveMetrics(),
    _isNativePerformance = defaultConfig.isNativePerformance(),
    _disabledExtendedMetrics,
    _isSnippetInjection = defaultConfig.isSnippetInjection(),
    _isAzureFunctions = defaultConfig.isAzureFunctions();
  function _getDefaultAutoCollectConfig() {
    return {
      isConsole: function () {
        return !0;
      },
      isConsoleLog: function () {
        return !1;
      },
      isExceptions: function () {
        return !0;
      },
      isPerformance: function () {
        return !0;
      },
      isPreAggregatedMetrics: function () {
        return !0;
      },
      isHeartBeat: function () {
        return !1;
      },
      isRequests: function () {
        return !0;
      },
      isDependencies: function () {
        return !0;
      },
      isDiskRetry: function () {
        return !0;
      },
      isCorrelating: function () {
        return !0;
      },
      isSendingLiveMetrics: function () {
        return !1;
      },
      isNativePerformance: function () {
        return !0;
      },
      isSnippetInjection: function () {
        return !1;
      },
      isAzureFunctions: function () {
        return !1;
      },
      isLoggerErrorToTrace: function () {
        return !1;
      }
    };
  }
  __name(_getDefaultAutoCollectConfig, "_getDefaultAutoCollectConfig");
  var _diskRetryInterval = void 0,
    _diskRetryMaxBytes = void 0,
    _webSnippetConnectionString = void 0,
    _console,
    _exceptions,
    _performance,
    _preAggregatedMetrics,
    _heartbeat,
    _webSnippet,
    _nativePerformance,
    _serverRequests,
    _clientRequests,
    _azureFunctions,
    _isStarted = !1,
    _performanceLiveMetrics;
  function setup(setupString) {
    return exports.defaultClient ? Logging.info("The default client is already setup") : (exports.defaultClient = new exports.TelemetryClient(setupString), _initializeConfig(), _console = new AutoCollectConsole(exports.defaultClient), _exceptions = new AutoCollectExceptions(exports.defaultClient), _performance = new AutoCollectPerformance(exports.defaultClient), _preAggregatedMetrics = new AutoCollecPreAggregatedMetrics(exports.defaultClient), _heartbeat = new HeartBeat(exports.defaultClient), _webSnippet = new WebSnippet(exports.defaultClient), _serverRequests = new AutoCollectHttpRequests(exports.defaultClient), _clientRequests = new AutoCollectHttpDependencies(exports.defaultClient), _nativePerformance || (_nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports.defaultClient)), _azureFunctions = new AzureFunctionsHook_1.AzureFunctionsHook(exports.defaultClient)), exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes), Configuration;
  }
  __name(setup, "setup");
  exports.setup = setup;
  function start() {
    return exports.defaultClient ? (_isStarted = !0, _console.enable(_isConsole, _isConsoleLog), _exceptions.enable(_isExceptions), _performance.enable(_isPerformance), _preAggregatedMetrics.enable(_isPreAggregatedMetrics), _heartbeat.enable(_isHeartBeat), _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics), _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked), _serverRequests.enable(_isRequests), _clientRequests.enable(_isDependencies), _webSnippet.enable(_isSnippetInjection, _webSnippetConnectionString), exports.liveMetricsClient && _isSendingLiveMetrics && exports.liveMetricsClient.enable(_isSendingLiveMetrics), _azureFunctions.enable(_isAzureFunctions)) : Logging.warn("Start cannot be called before setup"), Configuration;
  }
  __name(start, "start");
  exports.start = start;
  function _initializeConfig() {
    _isConsole = exports.defaultClient.config.enableAutoCollectExternalLoggers !== void 0 ? exports.defaultClient.config.enableAutoCollectExternalLoggers : _isConsole, _isConsoleLog = exports.defaultClient.config.enableAutoCollectConsole !== void 0 ? exports.defaultClient.config.enableAutoCollectConsole : _isConsoleLog, _isLoggerErrorToTrace = exports.defaultClient.config.enableLoggerErrorToTrace !== void 0 ? exports.defaultClient.config.enableLoggerErrorToTrace : _isLoggerErrorToTrace, _isExceptions = exports.defaultClient.config.enableAutoCollectExceptions !== void 0 ? exports.defaultClient.config.enableAutoCollectExceptions : _isExceptions, _isPerformance = exports.defaultClient.config.enableAutoCollectPerformance !== void 0 ? exports.defaultClient.config.enableAutoCollectPerformance : _isPerformance, _isPreAggregatedMetrics = exports.defaultClient.config.enableAutoCollectPreAggregatedMetrics !== void 0 ? exports.defaultClient.config.enableAutoCollectPreAggregatedMetrics : _isPreAggregatedMetrics, _isHeartBeat = exports.defaultClient.config.enableAutoCollectHeartbeat !== void 0 ? exports.defaultClient.config.enableAutoCollectHeartbeat : _isHeartBeat, _isRequests = exports.defaultClient.config.enableAutoCollectRequests !== void 0 ? exports.defaultClient.config.enableAutoCollectRequests : _isRequests, _isDependencies = exports.defaultClient.config.enableAutoDependencyCorrelation !== void 0 ? exports.defaultClient.config.enableAutoDependencyCorrelation : _isDependencies, _isDiskRetry = exports.defaultClient.config.enableUseDiskRetryCaching !== void 0 ? exports.defaultClient.config.enableUseDiskRetryCaching : _isDiskRetry, _isCorrelating = exports.defaultClient.config.enableAutoDependencyCorrelation !== void 0 ? exports.defaultClient.config.enableAutoDependencyCorrelation : _isCorrelating, _forceClsHooked = exports.defaultClient.config.enableUseAsyncHooks !== void 0 ? exports.defaultClient.config.enableUseAsyncHooks : _forceClsHooked, _isSendingLiveMetrics = exports.defaultClient.config.enableSendLiveMetrics !== void 0 ? exports.defaultClient.config.enableSendLiveMetrics : _isSendingLiveMetrics, _isSnippetInjection = exports.defaultClient.config.enableAutoWebSnippetInjection === !0 ? !0 : _isSnippetInjection, _isAzureFunctions = exports.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions !== void 0 ? exports.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions : _isAzureFunctions;
    var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(exports.defaultClient.config.enableAutoCollectExtendedMetrics, exports.defaultClient.config);
    _isNativePerformance = extendedMetricsConfig.isEnabled, _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
  }
  __name(_initializeConfig, "_initializeConfig");
  function getCorrelationContext() {
    return _isCorrelating ? CorrelationContextManager.CorrelationContextManager.getCurrentContext() : null;
  }
  __name(getCorrelationContext, "getCorrelationContext");
  exports.getCorrelationContext = getCorrelationContext;
  function startOperation(context, request) {
    return CorrelationContextManager.CorrelationContextManager.startOperation(context, request);
  }
  __name(startOperation, "startOperation");
  exports.startOperation = startOperation;
  function wrapWithCorrelationContext(fn, context) {
    return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn, context);
  }
  __name(wrapWithCorrelationContext, "wrapWithCorrelationContext");
  exports.wrapWithCorrelationContext = wrapWithCorrelationContext;
  var Configuration = function () {
    function Configuration() {}
    return __name(Configuration, "Configuration"), Configuration.setDistributedTracingMode = function (value) {
      return CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C, Configuration;
    }, Configuration.setAutoCollectConsole = function (value, collectConsoleLog) {
      return collectConsoleLog === void 0 && (collectConsoleLog = !1), _isConsole = value, _isConsoleLog = collectConsoleLog, _isStarted && _console.enable(value, collectConsoleLog), Configuration;
    }, Configuration.setAutoCollectExceptions = function (value) {
      return _isExceptions = value, _isStarted && _exceptions.enable(value), Configuration;
    }, Configuration.setAutoCollectPerformance = function (value, collectExtendedMetrics) {
      collectExtendedMetrics === void 0 && (collectExtendedMetrics = !0), _isPerformance = value;
      var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics, exports.defaultClient.config);
      return _isNativePerformance = extendedMetricsConfig.isEnabled, _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics, _isStarted && (_performance.enable(value), _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics)), Configuration;
    }, Configuration.setAutoCollectPreAggregatedMetrics = function (value) {
      return _isPreAggregatedMetrics = value, _isStarted && _preAggregatedMetrics.enable(value), Configuration;
    }, Configuration.setAutoCollectHeartbeat = function (value) {
      return _isHeartBeat = value, _isStarted && _heartbeat.enable(value), Configuration;
    }, Configuration.enableAutoWebSnippetInjection = function (value, WebSnippetConnectionString) {
      return _isSnippetInjection = value, _webSnippetConnectionString = WebSnippetConnectionString, _isStarted && _webSnippet.enable(value, _webSnippetConnectionString), Configuration;
    }, Configuration.enableWebInstrumentation = function (value, WebSnippetConnectionString) {
      return _isSnippetInjection = value, _webSnippetConnectionString = WebSnippetConnectionString, _isStarted && _webSnippet.enable(value, _webSnippetConnectionString), Configuration;
    }, Configuration.setAutoCollectRequests = function (value) {
      return _isRequests = value, _isStarted && _serverRequests.enable(value), Configuration;
    }, Configuration.setAutoCollectDependencies = function (value) {
      return _isDependencies = value, _isStarted && _clientRequests.enable(value), Configuration;
    }, Configuration.setAutoDependencyCorrelation = function (value, useAsyncHooks) {
      return _isCorrelating = value, _forceClsHooked = useAsyncHooks, _isStarted && _serverRequests.useAutoCorrelation(value, useAsyncHooks), Configuration;
    }, Configuration.setUseDiskRetryCaching = function (value, resendInterval, maxBytesOnDisk) {
      return _isDiskRetry = value, _diskRetryInterval = resendInterval, _diskRetryMaxBytes = maxBytesOnDisk, exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes), Configuration;
    }, Configuration.setInternalLogging = function (enableDebugLogging, enableWarningLogging) {
      return enableDebugLogging === void 0 && (enableDebugLogging = !1), enableWarningLogging === void 0 && (enableWarningLogging = !0), Logging.enableDebug = enableDebugLogging, Logging.disableWarnings = !enableWarningLogging, Configuration;
    }, Configuration.setAutoCollectIncomingRequestAzureFunctions = function (value) {
      return _isAzureFunctions = value, _isStarted && _azureFunctions.enable(value), Configuration;
    }, Configuration.setSendLiveMetrics = function (enable) {
      return enable === void 0 && (enable = !1), exports.defaultClient ? (!exports.liveMetricsClient && enable ? (exports.liveMetricsClient = new QuickPulseClient(exports.defaultClient.config, exports.defaultClient.context, exports.defaultClient.getAuthorizationHandler), _performanceLiveMetrics = new AutoCollectPerformance(exports.liveMetricsClient, 1e3, !0), exports.liveMetricsClient.addCollector(_performanceLiveMetrics), exports.defaultClient.quickPulseClient = exports.liveMetricsClient) : exports.liveMetricsClient && exports.liveMetricsClient.enable(enable), _isSendingLiveMetrics = enable, Configuration) : (Logging.warn("Live metrics client cannot be setup without the default client"), Configuration);
    }, Configuration.start = start, Configuration;
  }();
  exports.Configuration = Configuration;
  function dispose() {
    CorrelationIdManager.w3cEnabled = !0, exports.defaultClient = null, _isStarted = !1, _console && _console.dispose(), _exceptions && _exceptions.dispose(), _performance && _performance.dispose(), _preAggregatedMetrics && _preAggregatedMetrics.dispose(), _heartbeat && _heartbeat.dispose(), _webSnippet && _webSnippet.dispose(), _nativePerformance && _nativePerformance.dispose(), _serverRequests && _serverRequests.dispose(), _clientRequests && _clientRequests.dispose(), exports.liveMetricsClient && (exports.liveMetricsClient.enable(!1), _isSendingLiveMetrics = !1, exports.liveMetricsClient = void 0), _azureFunctions && _azureFunctions.dispose();
  }
  __name(dispose, "dispose");
  exports.dispose = dispose;
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "copilot",
    displayName: "GitHub Copilot",
    description: "Your AI pair programmer",
    version: "1.134.0",
    build: "535",
    buildType: "prod",
    publisher: "GitHub",
    preview: !1,
    homepage: "https://github.com/features/copilot",
    bugs: {
      url: "https://github.com/community/community/discussions/categories/copilot"
    },
    qna: "https://github.com/github-community/community/discussions/categories/copilot",
    icon: "assets/Copilot-App-Icon.png",
    pricing: "Trial",
    extensionPack: ["GitHub.copilot-chat"],
    engines: {
      vscode: "^1.75.0",
      node: ">=16.14.0",
      npm: ">=8.0.0"
    },
    categories: ["Programming Languages", "Machine Learning", "Education", "Snippets"],
    keywords: ["ai", "openai", "codex", "pilot", "snippets", "documentation", "autocomplete", "intellisense", "refactor", "javascript", "python", "typescript", "php", "go", "golang", "ruby", "c++", "c#", "java", "kotlin", "co-pilot"],
    badges: [{
      url: "https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange",
      href: "https://github.com/github-copilot/signup",
      description: "Sign up for GitHub Copilot"
    }, {
      url: "https://img.shields.io/github/stars/github/copilot-docs?style=social",
      href: "https://github.com/github/copilot-docs",
      description: "Star Copilot on GitHub"
    }, {
      url: "https://img.shields.io/youtube/channel/views/UC7c3Kb6jYCRj4JOHHZTxKsQ?style=social",
      href: "https://www.youtube.com/@GitHub/search?query=copilot",
      description: "Check out GitHub on Youtube"
    }, {
      url: "https://img.shields.io/twitter/follow/github?style=social",
      href: "https://twitter.com/github",
      description: "Follow GitHub on Twitter"
    }],
    activationEvents: ["onStartupFinished"],
    main: "./dist/extension",
    enabledApiProposals: ["inlineCompletionsAdditions"],
    contributes: {
      walkthroughs: [{
        id: "copilotWelcome",
        title: "GitHub Copilot",
        description: "Your AI pair programmer to write code faster and with less work",
        when: "!isWeb",
        steps: [{
          id: "copilot.signin",
          title: "Sign in with GitHub",
          description: `To get started with Copilot, sign in with your GitHub account.
Double-check to use the right GitHub account. You can also sign in later using the account menu.
 
[Sign In](command:github.copilot.signIn)`,
          when: "!github.copilot.activated",
          completionEvents: ["onContext:github.copilot.activated"],
          media: {
            image: "assets/walkthrough/sign-in.svg",
            altText: "Sign in to GitHub via Copilot's notification or VS Code's account menu"
          }
        }, {
          id: "copilot.firstsuggest",
          title: "AI-powered suggestions",
          description: `Copilot suggests lines of code **as you type** and multiple lines for **function signatures**.
  
**Prompts in comments** make suggestions specific to your desired outcome, logic and steps.`,
          media: {
            svg: "assets/walkthrough/ai-powered-suggestions.svg",
            altText: "Different types of suggestions visualized"
          }
        }, {
          id: "copilot.chat",
          title: "Chat with Copilot",
          description: "Ask Copilot general programming questions in the chat view. Copilot can also fix problems, scaffold tests, or refactor your code. Type ``/`` to view all available chat commands.\n[Chat with Copilot](command:workbench.panel.chat.view.copilot.focus)",
          when: "!github.copilot.interactiveSession.disabled",
          media: {
            svg: "assets/walkthrough/copilot-chat.svg",
            altText: "Copilot Chat view in the sidebar"
          }
        }, {
          id: "copilot.realfiles.openrecent",
          title: "Code as context",
          description: `The **more specific context** you provide Copilot, the **better** suggestions get! Context is not just current code and comments, but other open files.
  
[Try Copilot in Your Code](command:workbench.action.openRecent)`,
          when: "workspaceFolderCount == 0",
          media: {
            svg: "assets/walkthrough/code-as-context.svg",
            altText: "An editor with code being suggested by Copilot in gray text"
          }
        }, {
          id: "copilot.realfiles.quickopen",
          title: "Code as context",
          description: `The **more context** you give Copilot, the **better** suggestions get! Context is not just the current code, but other open files.
  
[Try Copilot in Your Code](command:workbench.action.quickOpen)`,
          when: "workspaceFolderCount != 0",
          media: {
            svg: "assets/walkthrough/code-as-context.svg",
            altText: "An editor with code being suggested by Copilot in gray text"
          }
        }, {
          id: "copilot.iterate",
          title: "You are in control",
          description: `Just as you would review a colleague's code, you should always assess, analyze, and validate AI-generated code.
  
If the first suggestion doesn't work, Copilot can generate more options. You can edit the Copilot settings and keyboard shortcuts to personalize your experience.
  
[Edit keyboard shortcuts](command:workbench.action.openGlobalKeybindings?%5B%22copilot%22%5D)
  
[Personalize settings](command:workbench.action.openSettings?%5B%22copilot%22%5D)`,
          media: {
            image: "assets/walkthrough/you-are-in-control.svg",
            altText: "An editor with a toolbar widget overlay showing arrows for navigating multiple suggestions from Copilot"
          }
        }, {
          id: "copilot.creativity",
          title: "Powered by your creativity",
          description: `Pair up with AI to outline your idea in a comment, then generate the implementation, and then test suites. Or, work backwards from example output!
Copilot will keep surprising you as you challenge it.
  
[Prompts, tips, and use cases](https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/)`,
          media: {
            svg: "assets/walkthrough/powered-by-your-creativity.svg",
            altText: "Metrics showing how much Copilot increases productivity for developers. The metrics read: 74% focus on more satisfying work. 88% feel more productive. 96% are faster with more repetitive tasks."
          }
        }]
      }],
      commands: [{
        command: "github.copilot.acceptCursorPanelSolution",
        title: "Accept panel suggestion at the cursor",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.signIn",
        title: "Sign In",
        category: "GitHub Copilot",
        enablement: "!github.copilot.activated"
      }, {
        command: "github.copilot.previousPanelSolution",
        title: "Navigate to the previous panel suggestion",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.nextPanelSolution",
        title: "Navigate to the next panel suggestion",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.generate",
        title: "Open Completions Panel",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.toggleCopilot",
        title: "Enable/Disable Copilot completions",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.sendFeedback",
        title: "Send Feedback",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.collectDiagnostics",
        title: "Collect Diagnostics",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.openLogs",
        title: "Open Logs",
        category: "GitHub Copilot"
      }],
      keybindings: [{
        command: "github.copilot.generate",
        key: "ctrl+enter",
        mac: "ctrl+enter",
        when: "editorTextFocus && github.copilot.activated && !inInteractiveInput && !interactiveEditorFocused"
      }, {
        command: "github.copilot.acceptCursorPanelSolution",
        key: "ctrl+/",
        mac: "ctrl+/",
        when: "github.copilot.activated && github.copilot.panelVisible"
      }, {
        command: "github.copilot.previousPanelSolution",
        key: "alt+[",
        mac: "alt+[",
        when: "github.copilot.activated && github.copilot.panelVisible"
      }, {
        command: "github.copilot.nextPanelSolution",
        key: "alt+]",
        mac: "alt+]",
        when: "github.copilot.activated && github.copilot.panelVisible"
      }, {
        command: "editor.action.inlineSuggest.trigger",
        key: "alt+\\",
        when: "editorTextFocus && !editorHasSelection && config.github.copilot.inlineSuggest.enable && !inlineSuggestionsVisible"
      }],
      menus: {
        "editor/inlineCompletions/actions": [{
          command: "github.copilot.generate",
          when: "github.copilot.activated"
        }],
        commandPalette: [{
          command: "github.copilot.generate",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.toggleCopilot",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.sendFeedback",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.collectDiagnostics"
        }]
      },
      configuration: [{
        title: "Copilot",
        properties: {
          "github.copilot.advanced": {
            type: "object",
            title: "Advanced Settings",
            properties: {
              secret_key: {
                type: "string",
                default: "",
                description: "Secret API key"
              },
              length: {
                type: "integer",
                default: 500,
                description: "Length of code to generate in tokens"
              },
              temperature: {
                type: "string",
                default: "",
                description: "Override sampling temperature (range 0.0 - 1.0)"
              },
              top_p: {
                type: "number",
                default: 1,
                description: "Top probability mass to consider"
              },
              stops: {
                type: "object",
                default: {
                  "*": [`


`],
                  python: [`
def `, `
class `, `
if `, `

#`]
                },
                description: "Configure per-language stop sequences"
              },
              indentationMode: {
                type: "object",
                default: {
                  python: !1,
                  javascript: !1,
                  javascriptreact: !1,
                  jsx: !1,
                  typescript: !1,
                  typescriptreact: !1,
                  go: !1,
                  ruby: !1,
                  "*": !0
                },
                markdownDescription: "Enable or disable indentation block termination for specified [languages](https://code.visualstudio.com/docs/languages/identifiers). Set to 'clientandserver' to run both parser-based and indent-based termination."
              },
              inlineSuggestCount: {
                type: "integer",
                default: 3,
                description: "Number of inline suggestions to fetch"
              },
              listCount: {
                type: "integer",
                default: 10,
                description: "Number of solutions to list in Open GitHub Copilot"
              },
              authProvider: {
                type: "string",
                enum: ["github", "github-enterprise"],
                enumDescriptions: ["GitHub.com", "GitHub Enterprise"],
                default: "github",
                description: "The GitHub identity to use for Copilot"
              },
              "debug.showScores": {
                type: "boolean",
                default: !1,
                description: "Show scores in sorted solutions"
              },
              "debug.overrideEngine": {
                type: "string",
                default: "",
                description: "Override engine name"
              },
              "debug.overrideProxyUrl": {
                type: "string",
                default: "",
                description: "Override GitHub authentication proxy full URL"
              },
              "debug.testOverrideProxyUrl": {
                type: "string",
                default: "",
                description: "Override GitHub authentication proxy URL when running tests"
              },
              "debug.overrideCapiUrl": {
                type: "string",
                default: "",
                description: "Override GitHub Copilot API full URL"
              },
              "debug.testOverrideCapiUrl": {
                type: "string",
                default: "",
                description: "Override GitHub Copilot API URL when running tests"
              },
              "debug.filterLogCategories": {
                type: "array",
                default: [],
                description: "Show only log categories listed in this setting. If an array is empty, show all loggers"
              }
            }
          },
          "github.copilot.enable": {
            type: "object",
            default: {
              "*": !0,
              plaintext: !1,
              markdown: !1,
              scminput: !1
            },
            additionalProperties: "boolean",
            markdownDescription: "Enable or disable Copilot completions for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)"
          },
          "github.copilot.inlineSuggest.enable": {
            type: "boolean",
            default: !0,
            deprecationMessage: "Deprecated: Please use github.copilot.editor.enableAutoCompletions instead.",
            description: "Show inline suggestions"
          },
          "github.copilot.editor.enableAutoCompletions": {
            type: "boolean",
            scope: "language-overridable",
            default: !0,
            description: "Automatically show inline completions"
          }
        }
      }],
      configurationDefaults: {
        "editor.tokenColorCustomizations": {
          "[*Light*]": {
            textMateRules: [{
              scope: "ref.matchtext",
              settings: {
                foreground: "#000"
              }
            }]
          },
          "[*Dark*]": {
            textMateRules: [{
              scope: "ref.matchtext",
              settings: {
                foreground: "#fff"
              }
            }]
          }
        }
      },
      languages: [{
        id: "code-referencing"
      }],
      grammars: [{
        language: "code-referencing",
        scopeName: "text.ref",
        path: "./syntaxes/ref.tmGrammar.json"
      }],
      icons: {
        "copilot-logo": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0041"
          }
        },
        "copilot-warning": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0042"
          }
        },
        "copilot-notconnected": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0043"
          }
        },
        "copilot-chat": {
          description: "GitHub Copilot chat icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\F101"
          }
        }
      },
      iconFonts: [{
        id: "copilot-font",
        src: [{
          path: "assets/copilot.woff",
          format: "woff"
        }]
      }]
    },
    scripts: {
      build: "run-s build:prompt build:root",
      "build:prompt": "npm -C prompt run build",
      "build:root": "tsx .esbuild.ts",
      clean: "./script/build/clean.sh",
      "forbid-sources-content:extension": "node script/forbid-sources-content.js --extension",
      generate_languages: "ts-node script/generateLanguages.ts && prettier --write lib/src/language/generatedLanguages.ts",
      get_token: "ts-node script/getToken.ts",
      lint: "npm-run-all lint:*",
      "lint:deps": "depcruise -c .dependency-cruiser.js .",
      "lint:eslint": "eslint . --cache",
      "lint:prettier": "prettier --check .",
      "lint:types": "tsc --noEmit",
      prebuild: "./script/build/clean-deprecated-modules.sh && npm install",
      pretest: "npm run build",
      "pretest:extension": "npm run build",
      "pretest:lsp-client": "npm run build",
      prewatch: "npm run build",
      start: "npm run watch",
      test: 'npm-run-all "test:* --ignore-scripts" lint',
      "test:agent": 'mocha "agent/src/**/*.test.ts"',
      "test:extension": "tsx extension/test/runTest.ts",
      "test:lib": 'mocha "lib/src/**/*.test.ts"',
      "test:lib-e2e": 'mocha "lib/e2e/src/**/*.test.ts"',
      "test:lsp-client": "npm -C lsp-client run test",
      "test:prompt": "npm -C prompt run test",
      "vscode-dts": "vscode-dts dev && mv vscode.proposed.*.ts extension/src",
      "vscode:prepublish": 'run-s "build --ignore-scripts" forbid-sources-content:extension',
      "vscode:uninstall": "node dist/extensionUninstalled.js",
      vsix: "vsce package",
      watch: "run-p watch:*",
      "watch:prompt": "npm -C prompt run watch",
      "watch:root": "tsx .esbuild.ts --watch",
      "watch:types": "tsc --noEmit --watch --preserveWatchOutput"
    },
    workspaces: ["prompt"],
    devDependencies: {
      "@datadog/datadog-ci": "^2.23.0",
      "@github/prettier-config": "0.0.6",
      "@types/crypto-js": "^4.1.1",
      "@types/git-url-parse": "^9.0.1",
      "@types/js-yaml": "^4.0.6",
      "@types/kerberos": "^1.1.2",
      "@types/mocha": "^10.0.1",
      "@types/node": "^16.18.24",
      "@types/sinon": "^10.0.13",
      "@types/tunnel": "^0.0.3",
      "@types/uuid": "^9.0.1",
      "@types/vscode": "^1.75.0",
      "@types/yargs": "^17.0.24",
      "@typescript-eslint/eslint-plugin": "^5.59.5",
      "@typescript-eslint/parser": "^5.62.0",
      "@vscode/test-electron": "^2.3.4",
      "@vscode/vsce": "^2.21.0",
      boxen: "^5.1.2",
      chalk: "^4.1.2",
      "dependency-cruiser": "^13.0.2",
      esbuild: "^0.19.4",
      "esbuild-plugin-copy": "^2.1.1",
      "esbuild-plugin-summary": "^0.0.2",
      eslint: "^8.50.0",
      "eslint-plugin-no-only-tests": "^3.1.0",
      fantasticon: "^2.0.0",
      glob: "^10.3.4",
      "js-yaml": "^4.1.0",
      mocha: "^10.2.0",
      "mocha-junit-reporter": "^2.2.1",
      "mocha-multi-reporters": "^1.5.1",
      "npm-run-all": "^4.1.5",
      pkg: "^5.8.1",
      prettier: "3.0.1",
      "prettier-plugin-organize-imports": "^3.2.3",
      proxy: "^2.1.1",
      sinon: "^16.0.0",
      "ts-dedent": "^2.2.0",
      "ts-mocha": "^10.0.0",
      "ts-node": "^10.9.1",
      tsx: "^3.14.0",
      "typed-emitter": "^2.1.0",
      typescript: "^5.1.6",
      "vscode-dts": "^0.3.3",
      "vscode-languageserver-protocol": "^3.16",
      zlib: "^1.0.5"
    },
    dependencies: {
      "@adobe/helix-fetch": "github:devm33/helix-fetch#1088e599270f36632703f138d88c2100cbe468db",
      "@github/copilot-promptlib": "file:prompt",
      "@github/memoize": "1.1.4",
      "@roamhq/mac-ca": "^1.0.7",
      "@sinclair/typebox": "^0.30.0",
      applicationinsights: "^2.7.3",
      "crypto-js": "^4.2.0",
      diff: "^5.1.0",
      dldr: "^0.0.10",
      "git-url-parse": "^13.1.0",
      ignore: "^5.2.4",
      kerberos: "^2.0.1",
      minimatch: "^9.0.3",
      open: "^8.4.2",
      semver: "^7.5.4",
      "source-map-support": "^0.5.21",
      uuid: "^9.0.0",
      "vscode-languageserver": "^8.1.0",
      "vscode-languageserver-textdocument": "~1.0.11",
      "vscode-uri": "^3.0.7",
      "windows-ca-certs": "^0.0.3",
      yargs: "^17.7.2"
    },
    overrides: {
      bindings: "github:devm33/node-bindings#6b57e6883b34dbb6942467a7e49afce99d9d6832"
    }
  };
});
var require_is_docker = __commonJSMin((exports, module) => {
  "use strict";

  var fs = require("fs"),
    isDocker;
  function hasDockerEnv() {
    try {
      return fs.statSync("/.dockerenv"), !0;
    } catch {
      return !1;
    }
  }
  __name(hasDockerEnv, "hasDockerEnv");
  function hasDockerCGroup() {
    try {
      return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
    } catch {
      return !1;
    }
  }
  __name(hasDockerCGroup, "hasDockerCGroup");
  module.exports = () => (isDocker === void 0 && (isDocker = hasDockerEnv() || hasDockerCGroup()), isDocker);
});
var require_is_wsl = __commonJSMin((exports, module) => {
  "use strict";

  var os = require("os"),
    fs = require("fs"),
    isDocker = sO(),
    isWsl = __name(() => {
      if (process.platform !== "linux") return !1;
      if (os.release().toLowerCase().includes("microsoft")) return !isDocker();
      try {
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : !1;
      } catch {
        return !1;
      }
    }, "isWsl");
  process.env.__IS_WSL_TEST__ ? module.exports = isWsl : module.exports = isWsl();
});
var require_define_lazy_prop = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = (object, propertyName, fn) => {
    let define = __name(value => Object.defineProperty(object, propertyName, {
      value: value,
      enumerable: !0,
      writable: !0
    }), "define");
    return Object.defineProperty(object, propertyName, {
      configurable: !0,
      enumerable: !0,
      get() {
        let result = fn();
        return define(result), result;
      },
      set(value) {
        define(value);
      }
    }), object;
  };
});
var require_open = __commonJSMin((exports, module) => {
  var path = require("path"),
    childProcess = require("child_process"),
    {
      promises: fs,
      constants: fsConstants
    } = require("fs"),
    isWsl = cee(),
    isDocker = sO(),
    defineLazyProperty = fee(),
    localXdgOpenPath = path.join(__dirname, "xdg-open"),
    {
      platform: platform,
      arch: arch
    } = process,
    hasContainerEnv = __name(() => {
      try {
        return fs.statSync("/run/.containerenv"), !0;
      } catch {
        return !1;
      }
    }, "hasContainerEnv"),
    cachedResult;
  function isInsideContainer() {
    return cachedResult === void 0 && (cachedResult = hasContainerEnv() || isDocker()), cachedResult;
  }
  __name(isInsideContainer, "isInsideContainer");
  var getWslDrivesMountPoint = (() => {
      let defaultMountPoint = "/mnt/",
        mountPoint;
      return async function () {
        if (mountPoint) return mountPoint;
        let configFilePath = "/etc/wsl.conf",
          isConfigFileExists = !1;
        try {
          await fs.access(configFilePath, fsConstants.F_OK), isConfigFileExists = !0;
        } catch {}
        if (!isConfigFileExists) return defaultMountPoint;
        let configContent = await fs.readFile(configFilePath, {
            encoding: "utf8"
          }),
          configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        return configMountPoint ? (mountPoint = configMountPoint.groups.mountPoint.trim(), mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`, mountPoint) : defaultMountPoint;
      };
    })(),
    pTryEach = __name(async (array, mapper) => {
      let latestError;
      for (let item of array) try {
        return await mapper(item);
      } catch (error) {
        latestError = error;
      }
      throw latestError;
    }, "pTryEach"),
    baseOpen = __name(async options => {
      if (options = {
        wait: !1,
        background: !1,
        newInstance: !1,
        allowNonzeroExitCode: !1,
        ...options
      }, Array.isArray(options.app)) return pTryEach(options.app, singleApp => baseOpen({
        ...options,
        app: singleApp
      }));
      let {
        name: app,
        arguments: appArguments = []
      } = options.app || {};
      if (appArguments = [...appArguments], Array.isArray(app)) return pTryEach(app, appName => baseOpen({
        ...options,
        app: {
          name: appName,
          arguments: appArguments
        }
      }));
      let command,
        cliArguments = [],
        childProcessOptions = {};
      if (platform === "darwin") command = "open", options.wait && cliArguments.push("--wait-apps"), options.background && cliArguments.push("--background"), options.newInstance && cliArguments.push("--new"), app && cliArguments.push("-a", app);else if (platform === "win32" || isWsl && !isInsideContainer() && !app) {
        let mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand"), isWsl || (childProcessOptions.windowsVerbatimArguments = !0);
        let encodedArguments = ["Start"];
        options.wait && encodedArguments.push("-Wait"), app ? (encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList"), options.target && appArguments.unshift(options.target)) : options.target && encodedArguments.push(`"${options.target}"`), appArguments.length > 0 && (appArguments = appArguments.map(arg => `"\`"${arg}\`""`), encodedArguments.push(appArguments.join(","))), options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) command = app;else {
          let isBundled = !__dirname || __dirname === "/",
            exeLocalXdgOpen = !1;
          try {
            await fs.access(localXdgOpenPath, fsConstants.X_OK), exeLocalXdgOpen = !0;
          } catch {}
          command = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        appArguments.length > 0 && cliArguments.push(...appArguments), options.wait || (childProcessOptions.stdio = "ignore", childProcessOptions.detached = !0);
      }
      options.target && cliArguments.push(options.target), platform === "darwin" && appArguments.length > 0 && cliArguments.push("--args", ...appArguments);
      let subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      return options.wait ? new Promise((resolve, reject) => {
        subprocess.once("error", reject), subprocess.once("close", exitCode => {
          if (!options.allowNonzeroExitCode && exitCode > 0) {
            reject(new Error(`Exited with code ${exitCode}`));
            return;
          }
          resolve(subprocess);
        });
      }) : (subprocess.unref(), subprocess);
    }, "baseOpen"),
    open = __name((target, options) => {
      if (typeof target != "string") throw new TypeError("Expected a `target`");
      return baseOpen({
        ...options,
        target: target
      });
    }, "open"),
    openApp = __name((name, options) => {
      if (typeof name != "string") throw new TypeError("Expected a `name`");
      let {
        arguments: appArguments = []
      } = options || {};
      if (appArguments != null && !Array.isArray(appArguments)) throw new TypeError("Expected `appArguments` as Array type");
      return baseOpen({
        ...options,
        app: {
          name: name,
          arguments: appArguments
        }
      });
    }, "openApp");
  function detectArchBinary(binary) {
    if (typeof binary == "string" || Array.isArray(binary)) return binary;
    let {
      [arch]: archBinary
    } = binary;
    if (!archBinary) throw new Error(`${arch} is not supported`);
    return archBinary;
  }
  __name(detectArchBinary, "detectArchBinary");
  function detectPlatformBinary({
    [platform]: platformBinary
  }, {
    wsl: wsl
  }) {
    if (wsl && isWsl) return detectArchBinary(wsl);
    if (!platformBinary) throw new Error(`${platform} is not supported`);
    return detectArchBinary(platformBinary);
  }
  __name(detectPlatformBinary, "detectPlatformBinary");
  var apps = {};
  defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
    darwin: "google chrome",
    win32: "chrome",
    linux: ["google-chrome", "google-chrome-stable", "chromium"]
  }, {
    wsl: {
      ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
      x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
    }
  }));
  defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
    darwin: "firefox",
    win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
    linux: "firefox"
  }, {
    wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
  }));
  defineLazyProperty(apps, "edge", () => detectPlatformBinary({
    darwin: "microsoft edge",
    win32: "msedge",
    linux: ["microsoft-edge", "microsoft-edge-dev"]
  }, {
    wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
  }));
  open.apps = apps;
  open.openApp = openApp;
  module.exports = open;
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = __name(function (input, first) {
    first === !0 && (first = 0);
    var prots = "";
    if (typeof input == "string") try {
      prots = new URL(input).protocol;
    } catch {} else input && input.constructor === URL && (prots = input.protocol);
    var splits = prots.split(/\:|\+/).filter(Boolean);
    return typeof first == "number" ? splits[first] : splits;
  }, "protocols");
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var protocols = gO();
  function parsePath(url) {
    var output = {
      protocols: [],
      protocol: null,
      port: null,
      resource: "",
      host: "",
      user: "",
      password: "",
      pathname: "",
      hash: "",
      search: "",
      href: url,
      query: {},
      parse_failed: !1
    };
    try {
      var parsed = new URL(url);
      output.protocols = protocols(parsed), output.protocol = output.protocols[0], output.port = parsed.port, output.resource = parsed.hostname, output.host = parsed.host, output.user = parsed.username || "", output.password = parsed.password || "", output.pathname = parsed.pathname, output.hash = parsed.hash.slice(1), output.search = parsed.search.slice(1), output.href = parsed.href, output.query = Object.fromEntries(parsed.searchParams);
    } catch {
      output.protocols = ["file"], output.protocol = output.protocols[0], output.port = "", output.resource = "", output.user = "", output.pathname = "", output.hash = "", output.search = "", output.href = url, output.query = {}, output.parse_failed = !0;
    }
    return output;
  }
  __name(parsePath, "parsePath");
  module.exports = parsePath;
});
var require_dist = __commonJSMin((exports, module) => {
  "use strict";

  var parsePath = Bee();
  function _interopDefaultLegacy(e) {
    return e && typeof e == "object" && "default" in e ? e : {
      default: e
    };
  }
  __name(_interopDefaultLegacy, "_interopDefaultLegacy");
  var parsePath__default = _interopDefaultLegacy(parsePath),
    DATA_URL_DEFAULT_MIME_TYPE = "text/plain",
    DATA_URL_DEFAULT_CHARSET = "us-ascii",
    testParameter = __name((name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name), "testParameter"),
    normalizeDataURL = __name((urlString, {
      stripHash: stripHash
    }) => {
      let match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) throw new Error(`Invalid URL: ${urlString}`);
      let {
          type: type,
          data: data,
          hash: hash
        } = match.groups,
        mediaType = type.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = !1;
      mediaType[mediaType.length - 1] === "base64" && (mediaType.pop(), isBase64 = !0);
      let mimeType = (mediaType.shift() || "").toLowerCase(),
        normalizedMediaType = [...mediaType.map(attribute => {
          let [key, value = ""] = attribute.split("=").map(string => string.trim());
          return key === "charset" && (value = value.toLowerCase(), value === DATA_URL_DEFAULT_CHARSET) ? "" : `${key}${value ? `=${value}` : ""}`;
        }).filter(Boolean)];
      return isBase64 && normalizedMediaType.push("base64"), (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) && normalizedMediaType.unshift(mimeType), `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
    }, "normalizeDataURL");
  function normalizeUrl(urlString, options) {
    if (options = {
      defaultProtocol: "http:",
      normalizeProtocol: !0,
      forceHttp: !1,
      forceHttps: !1,
      stripAuthentication: !0,
      stripHash: !1,
      stripTextFragment: !0,
      stripWWW: !0,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: !0,
      removeSingleSlash: !0,
      removeDirectoryIndex: !1,
      sortQueryParameters: !0,
      ...options
    }, urlString = urlString.trim(), /^data:/i.test(urlString)) return normalizeDataURL(urlString, options);
    if (/^view-source:/i.test(urlString)) throw new Error("`view-source:` is not supported as it is a non-standard protocol");
    let hasRelativeProtocol = urlString.startsWith("//");
    !hasRelativeProtocol && /^\.*\//.test(urlString) || (urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol));
    let urlObject = new URL(urlString);
    if (options.forceHttp && options.forceHttps) throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (options.forceHttp && urlObject.protocol === "https:" && (urlObject.protocol = "http:"), options.forceHttps && urlObject.protocol === "http:" && (urlObject.protocol = "https:"), options.stripAuthentication && (urlObject.username = "", urlObject.password = ""), options.stripHash ? urlObject.hash = "" : options.stripTextFragment && (urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "")), urlObject.pathname) {
      let protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g,
        lastIndex = 0,
        result = "";
      for (;;) {
        let match = protocolRegex.exec(urlObject.pathname);
        if (!match) break;
        let protocol = match[0],
          protocolAtIndex = match.index,
          intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
        result += intermediate.replace(/\/{2,}/g, "/"), result += protocol, lastIndex = protocolAtIndex + protocol.length;
      }
      let remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
      result += remnant.replace(/\/{2,}/g, "/"), urlObject.pathname = result;
    }
    if (urlObject.pathname) try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {}
    if (options.removeDirectoryIndex === !0 && (options.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
      let pathComponents = urlObject.pathname.split("/"),
        lastComponent = pathComponents[pathComponents.length - 1];
      testParameter(lastComponent, options.removeDirectoryIndex) && (pathComponents = pathComponents.slice(0, -1), urlObject.pathname = pathComponents.slice(1).join("/") + "/");
    }
    if (urlObject.hostname && (urlObject.hostname = urlObject.hostname.replace(/\.$/, ""), options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname) && (urlObject.hostname = urlObject.hostname.replace(/^www\./, ""))), Array.isArray(options.removeQueryParameters)) for (let key of [...urlObject.searchParams.keys()]) testParameter(key, options.removeQueryParameters) && urlObject.searchParams.delete(key);
    if (options.removeQueryParameters === !0 && (urlObject.search = ""), options.sortQueryParameters) {
      urlObject.searchParams.sort();
      try {
        urlObject.search = decodeURIComponent(urlObject.search);
      } catch {}
    }
    options.removeTrailingSlash && (urlObject.pathname = urlObject.pathname.replace(/\/$/, ""));
    let oldUrlString = urlString;
    return urlString = urlObject.toString(), !options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "" && (urlString = urlString.replace(/\/$/, "")), (options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash && (urlString = urlString.replace(/\/$/, "")), hasRelativeProtocol && !options.normalizeProtocol && (urlString = urlString.replace(/^http:\/\//, "//")), options.stripProtocol && (urlString = urlString.replace(/^(?:https?:)?\/\//, "")), urlString;
  }
  __name(normalizeUrl, "normalizeUrl");
  var parseUrl = __name((url, normalize = !1) => {
    let GIT_RE = /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\/\/)([\w\.\-@]+)[\/:]([\~,\.\w,\-,\_,\/]+?(?:\.git|\/)?)$/,
      throwErr = __name(msg => {
        let err = new Error(msg);
        throw err.subject_url = url, err;
      }, "throwErr");
    (typeof url != "string" || !url.trim()) && throwErr("Invalid url."), url.length > parseUrl.MAX_INPUT_LENGTH && throwErr("Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH."), normalize && (typeof normalize != "object" && (normalize = {
      stripHash: !1
    }), url = normalizeUrl(url, normalize));
    let parsed = parsePath__default.default(url);
    if (parsed.parse_failed) {
      let matched = parsed.href.match(GIT_RE);
      matched ? (parsed.protocols = ["ssh"], parsed.protocol = "ssh", parsed.resource = matched[2], parsed.host = matched[2], parsed.user = matched[1], parsed.pathname = `/${matched[3]}`, parsed.parse_failed = !1) : throwErr("URL parsing failed.");
    }
    return parsed;
  }, "parseUrl");
  parseUrl.MAX_INPUT_LENGTH = 2048;
  module.exports = parseUrl;
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var protocols = gO();
  function isSsh(input) {
    if (Array.isArray(input)) return input.indexOf("ssh") !== -1 || input.indexOf("rsync") !== -1;
    if (typeof input != "string") return !1;
    var prots = protocols(input);
    if (input = input.substring(input.indexOf("://") + 3), isSsh(prots)) return !0;
    var urlPortPattern = new RegExp(".([a-zA-Z\\d]+):(\\d+)/");
    return !input.match(urlPortPattern) && input.indexOf("@") < input.indexOf(":");
  }
  __name(isSsh, "isSsh");
  module.exports = isSsh;
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var parseUrl = qee(),
    isSsh = $ee();
  function gitUp(input) {
    var output = parseUrl(input);
    return output.token = "", output.password === "x-oauth-basic" ? output.token = output.user : output.user === "x-token-auth" && (output.token = output.password), isSsh(output.protocols) || output.protocols.length === 0 && isSsh(input) ? output.protocol = "ssh" : output.protocols.length ? output.protocol = output.protocols[0] : (output.protocol = "file", output.protocols = ["file"]), output.href = output.href.replace(/\/$/, ""), output;
  }
  __name(gitUp, "gitUp");
  module.exports = gitUp;
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var gitUp = zee();
  function gitUrlParse(url) {
    if (typeof url != "string") throw new Error("The url must be a string.");
    var shorthandRe = /^([a-z\d-]{1,39})\/([-\.\w]{1,100})$/i;
    shorthandRe.test(url) && (url = "https://github.com/" + url);
    var urlInfo = gitUp(url),
      sourceParts = urlInfo.resource.split("."),
      splits = null;
    switch (urlInfo.toString = function (type) {
      return gitUrlParse.stringify(this, type);
    }, urlInfo.source = sourceParts.length > 2 ? sourceParts.slice(1 - sourceParts.length).join(".") : urlInfo.source = urlInfo.resource, urlInfo.git_suffix = /\.git$/.test(urlInfo.pathname), urlInfo.name = decodeURIComponent((urlInfo.pathname || urlInfo.href).replace(/(^\/)|(\/$)/g, "").replace(/\.git$/, "")), urlInfo.owner = decodeURIComponent(urlInfo.user), urlInfo.source) {
      case "git.cloudforge.com":
        urlInfo.owner = urlInfo.user, urlInfo.organization = sourceParts[0], urlInfo.source = "cloudforge.com";
        break;
      case "visualstudio.com":
        if (urlInfo.resource === "vs-ssh.visualstudio.com") {
          splits = urlInfo.name.split("/"), splits.length === 4 && (urlInfo.organization = splits[1], urlInfo.owner = splits[2], urlInfo.name = splits[3], urlInfo.full_name = splits[2] + "/" + splits[3]);
          break;
        } else {
          splits = urlInfo.name.split("/"), splits.length === 2 ? (urlInfo.owner = splits[1], urlInfo.name = splits[1], urlInfo.full_name = "_git/" + urlInfo.name) : splits.length === 3 ? (urlInfo.name = splits[2], splits[0] === "DefaultCollection" ? (urlInfo.owner = splits[2], urlInfo.organization = splits[0], urlInfo.full_name = urlInfo.organization + "/_git/" + urlInfo.name) : (urlInfo.owner = splits[0], urlInfo.full_name = urlInfo.owner + "/_git/" + urlInfo.name)) : splits.length === 4 && (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[3], urlInfo.full_name = urlInfo.organization + "/" + urlInfo.owner + "/_git/" + urlInfo.name);
          break;
        }
      case "dev.azure.com":
      case "azure.com":
        if (urlInfo.resource === "ssh.dev.azure.com") {
          splits = urlInfo.name.split("/"), splits.length === 4 && (urlInfo.organization = splits[1], urlInfo.owner = splits[2], urlInfo.name = splits[3]);
          break;
        } else {
          splits = urlInfo.name.split("/"), splits.length === 5 ? (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[4], urlInfo.full_name = "_git/" + urlInfo.name) : splits.length === 3 ? (urlInfo.name = splits[2], splits[0] === "DefaultCollection" ? (urlInfo.owner = splits[2], urlInfo.organization = splits[0], urlInfo.full_name = urlInfo.organization + "/_git/" + urlInfo.name) : (urlInfo.owner = splits[0], urlInfo.full_name = urlInfo.owner + "/_git/" + urlInfo.name)) : splits.length === 4 && (urlInfo.organization = splits[0], urlInfo.owner = splits[1], urlInfo.name = splits[3], urlInfo.full_name = urlInfo.organization + "/" + urlInfo.owner + "/_git/" + urlInfo.name), urlInfo.query && urlInfo.query.path && (urlInfo.filepath = urlInfo.query.path.replace(/^\/+/g, "")), urlInfo.query && urlInfo.query.version && (urlInfo.ref = urlInfo.query.version.replace(/^GB/, ""));
          break;
        }
      default:
        splits = urlInfo.name.split("/");
        var nameIndex = splits.length - 1;
        if (splits.length >= 2) {
          var dashIndex = splits.indexOf("-", 2),
            blobIndex = splits.indexOf("blob", 2),
            treeIndex = splits.indexOf("tree", 2),
            commitIndex = splits.indexOf("commit", 2),
            srcIndex = splits.indexOf("src", 2),
            rawIndex = splits.indexOf("raw", 2),
            editIndex = splits.indexOf("edit", 2);
          nameIndex = dashIndex > 0 ? dashIndex - 1 : blobIndex > 0 ? blobIndex - 1 : treeIndex > 0 ? treeIndex - 1 : commitIndex > 0 ? commitIndex - 1 : srcIndex > 0 ? srcIndex - 1 : rawIndex > 0 ? rawIndex - 1 : editIndex > 0 ? editIndex - 1 : nameIndex, urlInfo.owner = splits.slice(0, nameIndex).join("/"), urlInfo.name = splits[nameIndex], commitIndex && (urlInfo.commit = splits[nameIndex + 2]);
        }
        urlInfo.ref = "", urlInfo.filepathtype = "", urlInfo.filepath = "";
        var offsetNameIndex = splits.length > nameIndex && splits[nameIndex + 1] === "-" ? nameIndex + 1 : nameIndex;
        splits.length > offsetNameIndex + 2 && ["raw", "src", "blob", "tree", "edit"].indexOf(splits[offsetNameIndex + 1]) >= 0 && (urlInfo.filepathtype = splits[offsetNameIndex + 1], urlInfo.ref = splits[offsetNameIndex + 2], splits.length > offsetNameIndex + 3 && (urlInfo.filepath = splits.slice(offsetNameIndex + 3).join("/"))), urlInfo.organization = urlInfo.owner;
        break;
    }
    urlInfo.full_name || (urlInfo.full_name = urlInfo.owner, urlInfo.name && (urlInfo.full_name && (urlInfo.full_name += "/"), urlInfo.full_name += urlInfo.name)), urlInfo.owner.startsWith("scm/") && (urlInfo.source = "bitbucket-server", urlInfo.owner = urlInfo.owner.replace("scm/", ""), urlInfo.organization = urlInfo.owner, urlInfo.full_name = urlInfo.owner + "/" + urlInfo.name);
    var bitbucket = /(projects|users)\/(.*?)\/repos\/(.*?)((\/.*$)|$)/,
      matches = bitbucket.exec(urlInfo.pathname);
    return matches != null && (urlInfo.source = "bitbucket-server", matches[1] === "users" ? urlInfo.owner = "~" + matches[2] : urlInfo.owner = matches[2], urlInfo.organization = urlInfo.owner, urlInfo.name = matches[3], splits = matches[4].split("/"), splits.length > 1 && (["raw", "browse"].indexOf(splits[1]) >= 0 ? (urlInfo.filepathtype = splits[1], splits.length > 2 && (urlInfo.filepath = splits.slice(2).join("/"))) : splits[1] === "commits" && splits.length > 2 && (urlInfo.commit = splits[2])), urlInfo.full_name = urlInfo.owner + "/" + urlInfo.name, urlInfo.query.at ? urlInfo.ref = urlInfo.query.at : urlInfo.ref = ""), urlInfo;
  }
  __name(gitUrlParse, "gitUrlParse");
  gitUrlParse.stringify = function (obj, type) {
    type = type || (obj.protocols && obj.protocols.length ? obj.protocols.join("+") : obj.protocol);
    var port = obj.port ? ":" + obj.port : "",
      user = obj.user || "git",
      maybeGitSuffix = obj.git_suffix ? ".git" : "";
    switch (type) {
      case "ssh":
        return port ? "ssh://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix : user + "@" + obj.resource + ":" + obj.full_name + maybeGitSuffix;
      case "git+ssh":
      case "ssh+git":
      case "ftp":
      case "ftps":
        return type + "://" + user + "@" + obj.resource + port + "/" + obj.full_name + maybeGitSuffix;
      case "http":
      case "https":
        var auth = obj.token ? buildToken(obj) : obj.user && (obj.protocols.includes("http") || obj.protocols.includes("https")) ? obj.user + "@" : "";
        return type + "://" + auth + obj.resource + port + "/" + buildPath(obj) + maybeGitSuffix;
      default:
        return obj.href;
    }
  };
  function buildToken(obj) {
    switch (obj.source) {
      case "bitbucket.org":
        return "x-token-auth:" + obj.token + "@";
      default:
        return obj.token + "@";
    }
  }
  __name(buildToken, "buildToken");
  function buildPath(obj) {
    switch (obj.source) {
      case "bitbucket-server":
        return "scm/" + obj.full_name;
      default:
        return "" + obj.full_name;
    }
  }
  __name(buildPath, "buildPath");
  module.exports = gitUrlParse;
});
function bytes_to_unicode(map) {
  let bs = range(ord("!"), ord("~") + 1).concat(range(ord("\xA1"), ord("\xAC") + 1), range(ord("\xAE"), ord("\xFF") + 1)),
    cs = bs.slice(),
    n = 0;
  for (let b = 0; b < 2 ** 8; b++) bs.includes(b) || (bs.push(b), cs.push(2 ** 8 + n), n = n + 1);
  let cs_ = cs.map(x => chr(x));
  for (let i = 0; i < bs.length; i++) map.set(bs[i], cs_[i]);
}
function get_char_pairs(word) {
  let pairs = new Set(),
    prev_char = word[0];
  for (let i = 1; i < word.length; i++) {
    let char = word[i];
    pairs.add([prev_char, char]), prev_char = char;
  }
  return pairs;
}
function getTokenizer(name = "cl100k") {
  let tokenizer = tokenizers.get(name);
  return tokenizer !== void 0 || (name === "mock" ? tokenizer = new MockTokenizer() : tokenizer = new BPETokenizer(name), tokenizers.set(name, tokenizer)), tokenizer;
}
var fs,
  path,
  import_util,
  range,
  ord,
  chr,
  textDecoder,
  decodeStr,
  dictZip,
  TokenizerName,
  tokenizers,
  BPETokenizer,
  MockTokenizer,
  init_tokenizer = __esmMin(() => {
    "use strict";

    fs = Ns(require("fs")), path = Ns(require("path")), import_util = require("util"), range = __name((x, y) => Array.from(Array(y).keys()).slice(x), "range"), ord = __name(x => x.charCodeAt(0), "ord"), chr = __name(x => String.fromCharCode(x), "chr"), textDecoder = new eb.TextDecoder("utf-8"), decodeStr = __name(arr => textDecoder.decode(new Uint8Array(arr)), "decodeStr"), dictZip = __name((x, y) => {
      let result = new Map();
      return x.forEach((_, i) => {
        result.set(x[i], y[i]);
      }), result;
    }, "dictZip");
    __name(bytes_to_unicode, "bytes_to_unicode");
    __name(get_char_pairs, "get_char_pairs");
    TokenizerName = (r => (TokenizerName.cl100k = "cl100k", TokenizerName.mock = "mock", TokenizerName))(tb || {}), tokenizers = new Map();
    __name(getTokenizer, "getTokenizer");
    BPETokenizer = class {
      constructor(name = "cl100k") {
        this.decoder = new Map();
        this.byte_encoder = new Map();
        this.byte_decoder = new Map();
        this.cache = new Map();
        this.textEncoder = new eb.TextEncoder();
        this.encodeStr = str => Array.from(this.textEncoder.encode(str));
        let VOCAB = "",
          ENCODER = "";
        if (name === "cl100k") VOCAB = "vocab_cushman002.bpe", ENCODER = "tokenizer_cushman002.json", this.pat = /'s|'t|'re|'ve|'m|'ll|'d|[^\r\n\p{L}\p{N}]?\p{L}+|\p{N}{1,3}| ?[^\s\p{L}\p{N}]+[\r\n]*|\s*[\r\n]+|\s+(?!\S)|\s+/giu;else throw new Error(`Unknown tokenizer name: ${name}`);
        let encoder_json, bpe_file;
        try {
          let encoder_text = SO.readFileSync(wO.resolve(__dirname, "resources", name, ENCODER));
          encoder_json = JSON.parse(encoder_text.toString()), bpe_file = SO.readFileSync(wO.resolve(__dirname, "resources", name, VOCAB), "utf-8");
        } catch (e) {
          if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code === "EPERM") && e instanceof Error || e instanceof SyntaxError) {
            let error = new Error(`Could not load tokenizer: ${name}`);
            throw error.code = "CopilotPromptLoadFailure", error;
          }
          throw e;
        }
        this.encoder = new Map(Object.entries(encoder_json));
        for (let [key, value] of this.encoder) this.decoder.set(value, key);
        let bpe_merges = bpe_file.split(`
`).slice(1).filter(l => l.trim().length > 0);
        this.bpe_ranks = dictZip(bpe_merges, range(0, bpe_merges.length)), bytes_to_unicode(this.byte_encoder), this.byte_encoder.forEach((value, key, _) => {
          this.byte_decoder.set(value, key);
        });
      }
      static {
        __name(this, "BPETokenizer");
      }
      byteEncodeStr(s) {
        return this.encodeStr(s).map(x => this.byte_encoder.get(x));
      }
      mutatingConcat(dest, src) {
        for (let i = 0; i < src.length; i++) dest.push(src[i]);
        return dest;
      }
      bpe(chunk) {
        if (this.cache.has(chunk)) return this.cache.get(chunk);
        let bytes = this.byteEncodeStr(chunk),
          pairs = get_char_pairs(bytes);
        if (!pairs) return bytes.map(x => this.encoder.get(x));
        for (;;) {
          let minPairs = new Map();
          pairs.forEach(pair => {
            let joined_pair = pair.join(" "),
              rank = this.bpe_ranks.get(joined_pair);
            minPairs.set(rank === void 0 || isNaN(rank) ? 1e11 : rank, pair);
          });
          let minPairsKeys = Array.from(minPairs.keys()).map(x => Number(x)),
            bigram = minPairs.get(Math.min(...minPairsKeys));
          if (!bigram || !this.bpe_ranks.has(bigram.join(" "))) break;
          let first = bigram[0],
            second = bigram[1],
            new_bytes = [],
            i = 0;
          for (; i < bytes.length;) {
            let j = bytes.indexOf(first, i);
            if (j === -1) {
              this.mutatingConcat(new_bytes, bytes.slice(i));
              break;
            }
            this.mutatingConcat(new_bytes, bytes.slice(i, j)), i = j, bytes[i] === first && i < bytes.length - 1 && bytes[i + 1] === second ? (new_bytes.push(first + second), i = i + 2) : (new_bytes.push(bytes[i]), i = i + 1);
          }
          if (bytes = new_bytes, bytes.length === 1) break;
          pairs = get_char_pairs(bytes);
        }
        let tokens = bytes.map(x => this.encoder.get(x));
        return this.cache.set(chunk, tokens), tokens;
      }
      tokenize(text) {
        let tokens = [],
          matches = Array.from(text.matchAll(this.pat)).map(x => x[0]);
        for (let chunk of matches) {
          let chunk_tokens = this.bpe(chunk);
          this.mutatingConcat(tokens, chunk_tokens);
        }
        return tokens;
      }
      tokenLength(text) {
        return this.tokenize(text).length;
      }
      takeLastTokens(text, n) {
        if (n <= 0) return "";
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          suffix = text.slice(-chars),
          suffixT = this.tokenize(suffix);
        for (; suffixT.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), suffix = text.slice(-chars), suffixT = this.tokenize(suffix);
        return suffixT.length < n ? text : (suffixT = suffixT.slice(-n), this.detokenize(suffixT));
      }
      takeFirstTokens(text, n) {
        if (n <= 0) return {
          text: "",
          tokens: []
        };
        let CHARS_PER_TOKENS_START = 4,
          CHARS_PER_TOKENS_ADD = 1,
          chars = Math.min(text.length, n * CHARS_PER_TOKENS_START),
          prefix = text.slice(0, chars),
          prefix_t = this.tokenize(prefix);
        for (; prefix_t.length < n + 2 && chars < text.length;) chars = Math.min(text.length, chars + n * CHARS_PER_TOKENS_ADD), prefix = text.slice(0, chars), prefix_t = this.tokenize(prefix);
        return prefix_t.length < n ? {
          text: text,
          tokens: prefix_t
        } : (prefix_t = prefix_t.slice(0, n), {
          text: this.detokenize(prefix_t),
          tokens: prefix_t
        });
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
      detokenize(tokens) {
        let text = tokens.map(x => this.decoder.get(x)).join("");
        return text = decodeStr(text.split("").map(x => this.byte_decoder.get(x))), text;
      }
      tokenizeStrings(text) {
        return this.tokenize(text).map(token => decodeStr(this.decoder.get(token).split("").map(char => this.byte_decoder.get(char))));
      }
    }, MockTokenizer = class {
      constructor() {
        this.hash = str => {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            let char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char, hash &= hash & 65535;
          }
          return hash;
        };
      }
      static {
        __name(this, "MockTokenizer");
      }
      tokenize(text) {
        return this.tokenizeStrings(text).map(this.hash);
      }
      detokenize(tokens) {
        return tokens.map(token => token.toString()).join(" ");
      }
      tokenizeStrings(text) {
        return text.split(/\b/);
      }
      tokenLength(text) {
        return this.tokenizeStrings(text).length;
      }
      takeLastTokens(text, n) {
        return this.tokenizeStrings(text).slice(-n).join("");
      }
      takeFirstTokens(text, n) {
        let tokens = this.tokenizeStrings(text).slice(0, n);
        return {
          text: tokens.join(""),
          tokens: tokens.map(this.hash)
        };
      }
      takeLastLinesTokens(text, n) {
        let suffix = this.takeLastTokens(text, n);
        if (suffix.length === text.length || text[text.length - suffix.length - 1] === `
`) return suffix;
        let newline = suffix.indexOf(`
`);
        return suffix.substring(newline + 1);
      }
    };
  });
var init_tokenization = __esmMin(() => {
  "use strict";

  init_tokenizer();
});
function virtualNode(indentation, subs, label) {
  return {
    type: "virtual",
    indentation: indentation,
    subs: subs,
    label: label
  };
}
function lineNode(indentation, lineNumber, sourceLine, subs, label) {
  if (sourceLine === "") throw new Error("Cannot create a line node with an empty source line");
  return {
    type: "line",
    indentation: indentation,
    lineNumber: lineNumber,
    sourceLine: sourceLine,
    subs: subs,
    label: label
  };
}
function blankNode(line) {
  return {
    type: "blank",
    lineNumber: line,
    subs: []
  };
}
function topNode(subs) {
  return {
    type: "top",
    indentation: -1,
    subs: subs ?? []
  };
}
function isBlank(tree) {
  return tree.type === "blank";
}
function isLine(tree) {
  return tree.type === "line";
}
function isVirtual(tree) {
  return tree.type === "virtual";
}
function isTop(tree) {
  return tree.type === "top";
}
function cutTreeAfterLine(tree, lineNumber) {
  function cut(tree) {
    if (!isVirtual(tree) && !isTop(tree) && tree.lineNumber === lineNumber) return tree.subs = [], !0;
    for (let i = 0; i < tree.subs.length; i++) if (cut(tree.subs[i])) return tree.subs = tree.subs.slice(0, i + 1), !0;
    return !1;
  }
  __name(cut, "cut"), cut(tree);
}
function duplicateTree(tree) {
  return JSON.parse(JSON.stringify(tree));
}
var init_classes = __esmMin(() => {
  "use strict";

  __name(virtualNode, "virtualNode");
  __name(lineNode, "lineNode");
  __name(blankNode, "blankNode");
  __name(topNode, "topNode");
  __name(isBlank, "isBlank");
  __name(isLine, "isLine");
  __name(isVirtual, "isVirtual");
  __name(isTop, "isTop");
  __name(cutTreeAfterLine, "cutTreeAfterLine");
  __name(duplicateTree, "duplicateTree");
});
function clearLabels(tree) {
  return visitTree(tree, tree => {
    tree.label = void 0;
  }, "bottomUp"), tree;
}
function clearLabelsIf(tree, condition) {
  return visitTree(tree, tree => {
    tree.label = tree.label ? condition(tree.label) ? void 0 : tree.label : void 0;
  }, "bottomUp"), tree;
}
function mapLabels(tree, map) {
  switch (tree.type) {
    case "line":
    case "virtual":
      let newSubs = tree.subs.map(sub => mapLabels(sub, map));
      return {
        ...tree,
        subs: newSubs,
        label: tree.label ? map(tree.label) : void 0
      };
    case "blank":
      return {
        ...tree,
        label: tree.label ? map(tree.label) : void 0
      };
    case "top":
      return {
        ...tree,
        subs: tree.subs.map(sub => mapLabels(sub, map)),
        label: tree.label ? map(tree.label) : void 0
      };
  }
}
function resetLineNumbers(tree) {
  let lineNumber = 0;
  function visitor(tree) {
    !isVirtual(tree) && !isTop(tree) && (tree.lineNumber = lineNumber, lineNumber++);
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "topDown");
}
function visitTree(tree, visitor, direction) {
  function _visit(tree) {
    direction === "topDown" && visitor(tree), tree.subs.forEach(subtree => {
      _visit(subtree);
    }), direction === "bottomUp" && visitor(tree);
  }
  __name(_visit, "_visit"), _visit(tree);
}
function visitTreeConditionally(tree, visitor, direction) {
  function _visit(tree) {
    if (direction === "topDown" && !visitor(tree)) return !1;
    let shouldContinue = !0;
    return tree.subs.forEach(subtree => {
      shouldContinue = shouldContinue && _visit(subtree);
    }), direction === "bottomUp" && (shouldContinue = shouldContinue && visitor(tree)), shouldContinue;
  }
  __name(_visit, "_visit"), _visit(tree);
}
function foldTree(tree, init, accumulator, direction) {
  let acc = init;
  function visitor(tree) {
    acc = accumulator(tree, acc);
  }
  return __name(visitor, "visitor"), visitTree(tree, visitor, direction), acc;
}
function rebuildTree(tree, visitor, skip) {
  let rebuild = __name(tree => {
      if (skip !== void 0 && skip(tree)) return tree;
      {
        let newSubs = tree.subs.map(rebuild).filter(sub => sub !== void 0);
        return tree.subs = newSubs, visitor(tree);
      }
    }, "rebuild"),
    rebuilt = rebuild(tree);
  return rebuilt !== void 0 ? rebuilt : topNode();
}
var init_manipulation = __esmMin(() => {
  "use strict";

  init_classes();
  __name(clearLabels, "clearLabels");
  __name(clearLabelsIf, "clearLabelsIf");
  __name(mapLabels, "mapLabels");
  __name(resetLineNumbers, "resetLineNumbers");
  __name(visitTree, "visitTree");
  __name(visitTreeConditionally, "visitTreeConditionally");
  __name(foldTree, "foldTree");
  __name(rebuildTree, "rebuildTree");
});
function parseRaw(source) {
  let rawLines = source.split(`
`),
    indentations = rawLines.map(line => line.match(/^\s*/)[0].length),
    lines = rawLines.map(line => line.trimLeft());
  function parseNode(line) {
    let [subs, nextLine] = parseSubs(line + 1, indentations[line]);
    return [lineNode(indentations[line], line, lines[line], subs), nextLine];
  }
  __name(parseNode, "parseNode");
  function parseSubs(initialLine, parentIndentation) {
    let sub,
      subs = [],
      line = initialLine,
      lastBlank;
    for (; line < lines.length && (lines[line] === "" || indentations[line] > parentIndentation);) if (lines[line] === "") lastBlank === void 0 && (lastBlank = line), line += 1;else {
      if (lastBlank !== void 0) {
        for (let i = lastBlank; i < line; i++) subs.push(blankNode(i));
        lastBlank = void 0;
      }
      [sub, line] = parseNode(line), subs.push(sub);
    }
    return lastBlank !== void 0 && (line = lastBlank), [subs, line];
  }
  __name(parseSubs, "parseSubs");
  let [subs, parsedLine] = parseSubs(0, -1),
    line = parsedLine;
  for (; line < lines.length && lines[line] === "";) subs.push(blankNode(line)), line += 1;
  if (line < lines.length) throw new Error(`Parsing did not go to end of file. Ended at ${line} out of ${lines.length}`);
  return topNode(subs);
}
function labelLines(tree, labelRules) {
  function visitor(tree) {
    if (isLine(tree)) {
      let rule = labelRules.find(rule => rule.matches(tree.sourceLine));
      rule && (tree.label = rule.label);
    }
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
}
function labelVirtualInherited(tree) {
  function visitor(tree) {
    if (isVirtual(tree) && tree.label === void 0) {
      let subs = tree.subs.filter(sub => !isBlank(sub));
      subs.length === 1 && (tree.label = subs[0].label);
    }
  }
  __name(visitor, "visitor"), visitTree(tree, visitor, "bottomUp");
}
function buildLabelRules(ruleMap) {
  return Object.keys(ruleMap).map(key => {
    let matches;
    return ruleMap[key].test ? matches = __name(sourceLine => ruleMap[key].test(sourceLine), "matches") : matches = ruleMap[key], {
      matches: matches,
      label: key
    };
  });
}
function combineClosersAndOpeners(tree) {
  let returnTree = rebuildTree(tree, __name(function (tree) {
    if (tree.subs.length === 0 || tree.subs.findIndex(sub => sub.label === "closer" || sub.label === "opener") === -1) return tree;
    let newSubs = [],
      lastNew;
    for (let i = 0; i < tree.subs.length; i++) {
      let sub = tree.subs[i],
        directOlderSibling = tree.subs[i - 1];
      if (sub.label === "opener" && directOlderSibling !== void 0 && isLine(directOlderSibling)) directOlderSibling.subs.push(sub), sub.subs.forEach(sub => directOlderSibling.subs.push(sub)), sub.subs = [];else if (sub.label === "closer" && lastNew !== void 0 && (isLine(sub) || isVirtual(sub)) && sub.indentation >= lastNew.indentation) {
        let j = newSubs.length - 1;
        for (; j > 0 && isBlank(newSubs[j]);) j -= 1;
        if (lastNew.subs.push(...newSubs.splice(j + 1)), sub.subs.length > 0) {
          let firstNonVirtual = lastNew.subs.findIndex(sub => sub.label !== "newVirtual"),
            subsToKeep = lastNew.subs.slice(0, firstNonVirtual),
            subsToWrap = lastNew.subs.slice(firstNonVirtual),
            wrappedSubs = subsToWrap.length > 0 ? [virtualNode(sub.indentation, subsToWrap, "newVirtual")] : [];
          lastNew.subs = [...subsToKeep, ...wrappedSubs, sub];
        } else lastNew.subs.push(sub);
      } else newSubs.push(sub), isBlank(sub) || (lastNew = sub);
    }
    return tree.subs = newSubs, tree;
  }, "rebuilder"));
  return clearLabelsIf(tree, arg => arg === "newVirtual"), returnTree;
}
function groupBlocks(tree, isDelimiter = isBlank, label) {
  return rebuildTree(tree, __name(function (tree) {
    if (tree.subs.length <= 1) return tree;
    let newSubs = [],
      nodesSinceLastFlush = [],
      currentBlockIndentation,
      lastNodeWasDelimiter = !1;
    function flushBlockIntoNewSubs(final = !1) {
      if (currentBlockIndentation !== void 0 && (newSubs.length > 0 || !final)) {
        let virtual = virtualNode(currentBlockIndentation, nodesSinceLastFlush, label);
        newSubs.push(virtual);
      } else nodesSinceLastFlush.forEach(node => newSubs.push(node));
    }
    __name(flushBlockIntoNewSubs, "flushBlockIntoNewSubs");
    for (let i = 0; i < tree.subs.length; i++) {
      let sub = tree.subs[i],
        subIsDelimiter = isDelimiter(sub);
      !subIsDelimiter && lastNodeWasDelimiter && (flushBlockIntoNewSubs(), nodesSinceLastFlush = []), lastNodeWasDelimiter = subIsDelimiter, nodesSinceLastFlush.push(sub), isBlank(sub) || (currentBlockIndentation = currentBlockIndentation ?? sub.indentation);
    }
    return flushBlockIntoNewSubs(!0), tree.subs = newSubs, tree;
  }, "rebuilder"));
}
function flattenVirtual(tree) {
  return rebuildTree(tree, __name(function (tree) {
    return isVirtual(tree) && tree.label === void 0 && tree.subs.length <= 1 ? tree.subs.length === 0 ? void 0 : tree.subs[0] : (tree.subs.length === 1 && isVirtual(tree.subs[0]) && tree.subs[0].label === void 0 && (tree.subs = tree.subs[0].subs), tree);
  }, "rebuilder"));
}
function registerLanguageSpecificParser(language, parser) {
  LANGUAGE_SPECIFIC_PARSERS[language] = parser;
}
function parseTree(source, languageId) {
  let raw = parseRaw(source),
    languageSpecificParser = LANGUAGE_SPECIFIC_PARSERS[languageId ?? ""];
  return languageSpecificParser ? languageSpecificParser(raw) : (labelLines(raw, genericLabelRules), combineClosersAndOpeners(raw));
}
var _genericLabelRules,
  genericLabelRules,
  LANGUAGE_SPECIFIC_PARSERS,
  init_parsing = __esmMin(() => {
    "use strict";

    init_classes();
    init_manipulation();
    __name(parseRaw, "parseRaw");
    __name(labelLines, "labelLines");
    __name(labelVirtualInherited, "labelVirtualInherited");
    __name(buildLabelRules, "buildLabelRules");
    __name(combineClosersAndOpeners, "combineClosersAndOpeners");
    __name(groupBlocks, "groupBlocks");
    __name(flattenVirtual, "flattenVirtual");
    _genericLabelRules = {
      opener: /^[\[({]/,
      closer: /^[\])}]/
    }, genericLabelRules = buildLabelRules(_genericLabelRules), LANGUAGE_SPECIFIC_PARSERS = {};
    __name(registerLanguageSpecificParser, "registerLanguageSpecificParser");
    __name(parseTree, "parseTree");
  });
function processJava(originalTree) {
  let tree = originalTree;
  return labelLines(tree, javaLabelRules), tree = combineClosersAndOpeners(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), visitTree(tree, tree => {
    if (tree.label === "class" || tree.label === "interface") for (let sub of tree.subs) !isBlank(sub) && (sub.label === void 0 || sub.label === "annotation") && (sub.label = "member");
  }, "bottomUp"), tree;
}
var _javaLabelRules,
  javaLabelRules,
  init_java = __esmMin(() => {
    "use strict";

    init_classes();
    init_manipulation();
    init_parsing();
    _javaLabelRules = {
      package: /^package /,
      import: /^import /,
      class: /\bclass /,
      interface: /\binterface /,
      javadoc: /^\/\*\*/,
      comment_multi: /^\/\*[^*]/,
      comment_single: /^\/\//,
      annotation: /^@/,
      opener: /^[\[({]/,
      closer: /^[\])}]/
    }, javaLabelRules = buildLabelRules(_javaLabelRules);
    __name(processJava, "processJava");
  });
function processMarkdown(originalTree) {
  let tree = originalTree;
  if (labelLines(tree, MarkdownLabelRules), isBlank(tree)) return tree;
  function headingLevel(sub) {
    if (sub.label === "heading") return 1;
    if (sub.label === "subheading") return 2;
    if (sub.label === "subsubheading") return 3;
  }
  __name(headingLevel, "headingLevel");
  let currentHierarchy = [tree],
    oldTreeSubs = [...tree.subs];
  tree.subs = [];
  for (let sub of oldTreeSubs) {
    let level = headingLevel(sub);
    if (level === void 0 || isBlank(sub)) currentHierarchy[currentHierarchy.length - 1].subs.push(sub);else {
      for (; currentHierarchy.length < level;) currentHierarchy.push(currentHierarchy[currentHierarchy.length - 1]);
      for (currentHierarchy[level - 1].subs.push(sub), currentHierarchy[level] = sub; currentHierarchy.length > level + 1;) currentHierarchy.pop();
    }
  }
  return tree = groupBlocks(tree), tree = flattenVirtual(tree), labelVirtualInherited(tree), tree;
}
var _MarkdownLabelRules,
  MarkdownLabelRules,
  init_markdown = __esmMin(() => {
    "use strict";

    init_classes();
    init_parsing();
    _MarkdownLabelRules = {
      heading: /^# /,
      subheading: /^## /,
      subsubheading: /### /
    }, MarkdownLabelRules = buildLabelRules(_MarkdownLabelRules);
    __name(processMarkdown, "processMarkdown");
  });
function deparseLine(node) {
  return " ".repeat(node.indentation) + node.sourceLine + `
`;
}
function deparseTree(tree) {
  function accumulator(tree, accum) {
    let str = "";
    return isLine(tree) ? str = deparseLine(tree) : isBlank(tree) && (str = `
`), accum + str;
  }
  return __name(accumulator, "accumulator"), foldTree(tree, "", accumulator, "topDown");
}
function deparseAndCutTree(tree, cutAt) {
  let cutAtSet = new Set(cutAt),
    cuts = [],
    curUndef = "";
  function visit(tree) {
    tree.label !== void 0 && cutAtSet.has(tree.label) ? (curUndef !== "" && cuts.push({
      label: void 0,
      source: curUndef
    }), cuts.push({
      label: tree.label,
      source: deparseTree(tree)
    }), curUndef = "") : (isLine(tree) && (curUndef += deparseLine(tree)), tree.subs.forEach(visit));
  }
  return __name(visit, "visit"), visit(tree), curUndef !== "" && cuts.push({
    label: void 0,
    source: curUndef
  }), cuts;
}
function describeTree(tree, indent = 0) {
  let ind = " ".repeat(indent);
  if (tree === void 0) return "UNDEFINED NODE";
  let children;
  tree.subs === void 0 ? children = "UNDEFINED SUBS" : children = tree.subs.map(child => describeTree(child, indent + 2)).join(`,
`), children === "" ? children = "[]" : children = `[
${children}
      ${ind}]`;
  let prefix = (isVirtual(tree) || isTop(tree) ? "   " : String(tree.lineNumber).padStart(3, " ")) + `:  ${ind}`,
    labelString = tree.label === void 0 ? "" : JSON.stringify(tree.label);
  return isVirtual(tree) || isTop(tree) ? `${prefix}vnode(${tree.indentation}, ${labelString}, ${children})` : isBlank(tree) ? `${prefix}blank(${labelString ?? ""})` : `${prefix}lnode(${tree.indentation}, ${labelString}, ${JSON.stringify(tree.sourceLine)}, ${children})`;
}
function encodeTree(tree, indent = "") {
  let labelString = tree.label === void 0 ? "" : `, ${JSON.stringify(tree.label)}`,
    subString = !isBlank(tree) && tree.subs.length > 0 ? `[
${tree.subs.map(node => encodeTree(node, indent + "  ")).join(`, 
`)}
${indent}]` : "[]";
  switch (tree.type) {
    case "blank":
      return `${indent}blankNode(${tree.lineNumber}${labelString})`;
    case "top":
      return `topNode(${subString}${labelString})`;
    case "virtual":
      return `${indent}virtualNode(${tree.indentation}, ${subString}${labelString})`;
    case "line":
      return `${indent}lineNode(${tree.indentation}, ${tree.lineNumber}, "${tree.sourceLine}", ${subString}${labelString})`;
  }
}
function firstLineOf(tree) {
  if (isLine(tree) || isBlank(tree)) return tree.lineNumber;
  for (let sub of tree.subs) {
    let firstLine = firstLineOf(sub);
    if (firstLine !== void 0) return firstLine;
  }
}
function lastLineOf(tree) {
  let lastLine,
    i = tree.subs.length - 1;
  for (; i >= 0 && lastLine === void 0;) lastLine = lastLineOf(tree.subs[i]), i--;
  return lastLine === void 0 && !isVirtual(tree) && !isTop(tree) ? tree.lineNumber : lastLine;
}
var init_description = __esmMin(() => {
  "use strict";

  init_classes();
  init_manipulation();
  __name(deparseLine, "deparseLine");
  __name(deparseTree, "deparseTree");
  __name(deparseAndCutTree, "deparseAndCutTree");
  __name(describeTree, "describeTree");
  __name(encodeTree, "encodeTree");
  __name(firstLineOf, "firstLineOf");
  __name(lastLineOf, "lastLineOf");
});
var init_indentation = __esmMin(() => {
  "use strict";

  init_java();
  init_markdown();
  init_parsing();
  init_classes();
  init_description();
  init_manipulation();
  init_parsing();
  registerLanguageSpecificParser("markdown", processMarkdown);
  registerLanguageSpecificParser("java", processJava);
});
function fromTreeWithFocussedLines(tree, config = DEFAULT_TREE_TRAVERSAL_CONFIG) {
  let treeWithDistances = mapLabels(tree, x => x ? 1 : void 0);
  return visitTree(treeWithDistances, node => {
    if (isBlank(node)) return;
    let maxChildLabel = Math.max(...node.subs.map(child => child.label ?? 0));
    node.label = Math.max(node.label ?? 0, maxChildLabel * config.worthUp);
  }, "bottomUp"), visitTree(treeWithDistances, node => {
    if (isBlank(node)) return;
    let values = node.subs.map(sub => sub.label ?? 0),
      new_values = [...values];
    for (let i = 0; i < values.length; i++) values[i] !== 0 && (new_values = new_values.map((v, j) => Math.max(v, Math.pow(config.worthSibling, Math.abs(i - j)) * values[i])));
    let nodeLabel = node.label;
    nodeLabel !== void 0 && (new_values = new_values.map(v => Math.max(v, config.worthDown * nodeLabel))), node.subs.forEach((sub, i) => sub.label = new_values[i]);
  }, "topDown"), fromTreeWithValuedLines(treeWithDistances);
}
function fromTreeWithValuedLines(tree) {
  let valuedLines = foldTree(tree, [], (node, acc) => ((node.type === "line" || node.type === "blank") && acc.push(node.type === "line" ? [deparseLine(node).trimEnd(), node.label ?? 0] : ["", node.label ?? 0]), acc), "topDown");
  return new ElidableText(...valuedLines);
}
var DEFAULT_TREE_TRAVERSAL_CONFIG,
  init_fromIndentationTrees = __esmMin(() => {
    "use strict";

    init_indentation();
    init_elidableText();
    DEFAULT_TREE_TRAVERSAL_CONFIG = {
      worthUp: .9,
      worthSibling: .88,
      worthDown: .8
    };
    __name(fromTreeWithFocussedLines, "fromTreeWithFocussedLines");
    __name(fromTreeWithValuedLines, "fromTreeWithValuedLines");
  });
function elidableTextForSourceCode(contents, focusOnLastLeaf = !0, focusOnFirstLine = !0) {
  let tree = typeof contents == "string" ? parseTree(contents) : parseTree(contents.source, contents.languageId);
  flattenVirtual(tree);
  let treeWithFocussedLines = mapLabels(tree, label => focusOnLastLeaf && label !== "closer");
  return visitTree(treeWithFocussedLines, node => {
    node.label === void 0 && (node.label = focusOnLastLeaf && node.label !== !1);
  }, "topDown"), focusOnLastLeaf && visitTree(treeWithFocussedLines, node => {
    if (node.label) {
      let foundLastTrue = !1;
      for (let subnode of [...node.subs].reverse()) subnode.label && !foundLastTrue ? foundLastTrue = !0 : subnode.label = !1;
    } else for (let subnode of node.subs) subnode.label = !1;
    node.subs.length > 0 && (node.label = !1);
  }, "topDown"), focusOnFirstLine && visitTree(treeWithFocussedLines, node => {
    node.label ||= (isLine(node) || isBlank(node)) && node.lineNumber == 0;
  }, "topDown"), fromTreeWithFocussedLines(treeWithFocussedLines);
}
var init_fromSourceCode = __esmMin(() => {
  "use strict";

  init_indentation();
  init_fromIndentationTrees();
  __name(elidableTextForSourceCode, "elidableTextForSourceCode");
});
var LineWithValueAndCost,
  init_lineWithValueAndCost = __esmMin(() => {
    "use strict";

    init_tokenization();
    LineWithValueAndCost = class _LineWithValueAndCost {
      constructor(text, _value, _cost = getTokenizer().tokenLength(text + `
`), validate = "strict") {
        this.text = text;
        this._value = _value;
        this._cost = _cost;
        if (text.includes(`
`) && validate !== "none") throw new Error("LineWithValueAndCost: text contains newline");
        if (_value < 0 && validate !== "none") throw new Error("LineWithValueAndCost: value is negative");
        if (_cost < 0 && validate !== "none") throw new Error("LineWithValueAndCost: cost is negative");
        if (validate == "strict" && _value > 1) throw new Error("Value should normally be between 0 and 1 -- set validation to `loose` to ignore this error");
      }
      static {
        __name(this, "LineWithValueAndCost");
      }
      get value() {
        return this._value;
      }
      get cost() {
        return this._cost;
      }
      adjustValue(multiplier) {
        return this._value *= multiplier, this;
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        return this._cost = coster(this.text), this;
      }
      copy() {
        return new _LineWithValueAndCost(this.text, this.value, this.cost, "none");
      }
    };
  });
function makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer) {
  if (tokenizer.tokenLength(ellipsis + `
`) > maxTokens) throw new Error("maxTokens must be larger than the ellipsis length");
  strategy === "removeLeastBangForBuck" && lines.forEach(line => line.adjustValue(1 / line.cost));
  let infiniteWorth = lines.reduce((a, b) => Math.max(a, b.value), 0) + 1,
    infiniteIndentation = lines.reduce((a, b) => Math.max(a, b.text.length), 0) + 1,
    trimmedEllipsis = ellipsis.trim(),
    totalCost = lines.reduce((sum, line) => sum + line.cost, 0),
    defensiveCounter = lines.length + 1;
  for (; totalCost > maxTokens && defensiveCounter-- >= -1;) {
    let leastDesirable = lines.reduce((least, line) => line.value < least.value ? line : least),
      index = lines.indexOf(leastDesirable),
      mostRecentNonBlankLine = lines.slice(0, index + 1).reverse().find(line => line.text.trim() !== "") ?? {
        text: ""
      },
      indentation = indentEllipses ? Math.min(mostRecentNonBlankLine.text.match(/^\s*/)?.[0].length ?? 0, lines[index - 1]?.text.trim() === trimmedEllipsis ? lines[index - 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation, lines[index + 1]?.text.trim() === trimmedEllipsis ? lines[index + 1]?.text.match(/^\s*/)?.[0].length ?? 0 : infiniteIndentation) : 0,
      insert = " ".repeat(indentation) + ellipsis,
      newEllipis = new LineWithValueAndCost(insert, infiniteWorth, tokenizer.tokenLength(insert + `
`), "loose");
    lines.splice(index, 1, newEllipis), lines[index + 1]?.text.trim() === trimmedEllipsis && lines.splice(index + 1, 1), lines[index - 1]?.text.trim() === trimmedEllipsis && lines.splice(index - 1, 1);
    let newTotalCost = lines.reduce((sum, line) => sum + line.cost, 0);
    newTotalCost >= totalCost && lines.every(line => line.value === infiniteWorth) && (indentEllipses = !1), totalCost = newTotalCost;
  }
  if (defensiveCounter < 0) throw new Error("Infinite loop in ElidableText.makePrompt: Defensive counter < 0 in ElidableText.makePrompt with end text");
  return lines.map(line => line.text).join(`
`);
}
var ElidableText,
  init_elidableText = __esmMin(() => {
    "use strict";

    init_tokenization();
    init_fromSourceCode();
    init_lineWithValueAndCost();
    ElidableText = class _ElidableText {
      constructor(...chunks) {
        this.lines = [];
        let lines = [];
        for (let chunk of chunks) {
          let value = Array.isArray(chunk) ? chunk[1] : 1,
            input = Array.isArray(chunk) ? chunk[0] : chunk;
          typeof input == "string" ? input.split(`
`).forEach(line => lines.push(new LineWithValueAndCost(line, value))) : input instanceof _ElidableText ? lines.push(...input.lines.map(line => line.copy().adjustValue(value))) : "source" in input && "languageId" in input && lines.push(...elidableTextForSourceCode(input).lines.map(line => line.copy().adjustValue(value)));
        }
        this.lines = lines;
      }
      static {
        __name(this, "ElidableText");
      }
      adjust(multiplier) {
        this.lines.forEach(line => line.adjustValue(multiplier));
      }
      recost(coster = x => getTokenizer().tokenLength(x + `
`)) {
        this.lines.forEach(line => line.recost(coster));
      }
      makePrompt(maxTokens, ellipsis = "[...]", indentEllipses = !0, strategy = "removeLeastDesirable", tokenizer = getTokenizer()) {
        let lines = this.lines.map(line => line.copy());
        return makePrompt(lines, maxTokens, ellipsis, indentEllipses, strategy, tokenizer);
      }
    };
    __name(makePrompt, "makePrompt");
  });
function Diff() {}
function buildValues(diff, components, newString, oldString, useLongestToken) {
  for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (component.removed) {
      if (component.value = diff.join(oldString.slice(oldPos, oldPos + component.count)), oldPos += component.count, componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos], components[componentPos] = tmp;
      }
    } else {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        }), component.value = diff.join(value);
      } else component.value = diff.join(newString.slice(newPos, newPos + component.count));
      newPos += component.count, component.added || (oldPos += component.count);
    }
  }
  var lastComponent = components[componentLen - 1];
  return componentLen > 1 && typeof lastComponent.value == "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, components.pop()), components;
}
function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice(0)
  };
}
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = __name(function (obj) {
    return typeof obj;
  }, "_typeof") : _typeof = __name(function (obj) {
    return obj && typeof Symbol == "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, "_typeof"), _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if (typeof o == "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
}
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [], replacementStack = replacementStack || [], replacer && (obj = replacer(key, obj));
  var i;
  for (i = 0; i < stack.length; i += 1) if (stack[i] === obj) return replacementStack[i];
  var canonicalizedObj;
  if (objectPrototypeToString.call(obj) === "[object Array]") {
    for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    return stack.pop(), replacementStack.pop(), canonicalizedObj;
  }
  if (obj && obj.toJSON && (obj = obj.toJSON()), _typeof(obj) === "object" && obj !== null) {
    stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
      _key;
    for (_key in obj) obj.hasOwnProperty(_key) && sortedKeys.push(_key);
    for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) _key = sortedKeys[i], canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    stack.pop(), replacementStack.pop();
  } else canonicalizedObj = obj;
  return canonicalizedObj;
}
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  options || (options = {}), typeof options.context > "u" && (options.context = 4);
  var diff = diffLines(oldStr, newStr, options);
  if (!diff) return;
  diff.push({
    value: "",
    lines: []
  });
  function contextLines(lines) {
    return lines.map(function (entry) {
      return " " + entry;
    });
  }
  __name(contextLines, "contextLines");
  for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = __name(function (i) {
      var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, "").split(`
`);
      if (current.lines = lines, current.added || current.removed) {
        var _curRange;
        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length);
        }
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
          return (current.added ? "+" : "-") + entry;
        }))), current.added ? newLine += lines.length : oldLine += lines.length;
      } else {
        if (oldRangeStart) if (lines.length <= options.context * 2 && i < diff.length - 2) {
          var _curRange2;
          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange3,
            contextSize = Math.min(lines.length, options.context);
          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i >= diff.length - 2 && lines.length <= options.context) {
            var oldEOFNewline = /\n$/.test(oldStr),
              newEOFNewline = /\n$/.test(newStr),
              noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
            !oldEOFNewline && noNlBeforeAdds && oldStr.length > 0 && curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file"), (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) && curRange.push("\\ No newline at end of file");
          }
          hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = [];
        }
        oldLine += lines.length, newLine += lines.length;
      }
    }, "_loop"), i = 0; i < diff.length; i++) _loop(i);
  return {
    oldFileName: oldFileName,
    newFileName: newFileName,
    oldHeader: oldHeader,
    newHeader: newHeader,
    hunks: hunks
  };
}
var characterDiff,
  extendedWordChars,
  reWhitespace,
  wordDiff,
  lineDiff,
  sentenceDiff,
  cssDiff,
  objectPrototypeToString,
  jsonDiff,
  arrayDiff,
  init_lib = __esmMin(() => {
    __name(Diff, "Diff");
    Diff.prototype = {
      diff: __name(function (oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
          callback = options.callback;
        typeof options == "function" && (callback = options, options = {}), this.options = options;
        var self = this;
        function done(value) {
          return callback ? (setTimeout(function () {
            callback(void 0, value);
          }, 0), !0) : value;
        }
        __name(done, "done"), oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString)), newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
          oldLen = oldString.length,
          editLength = 1,
          maxEditLength = newLen + oldLen;
        options.maxEditLength && (maxEditLength = Math.min(maxEditLength, options.maxEditLength));
        var bestPath = [{
            newPos: -1,
            components: []
          }],
          oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) return done([{
          value: this.join(newString),
          count: newString.length
        }]);
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0,
              addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            addPath && (bestPath[diagonalPath - 1] = void 0);
            var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), self.pushComponent(basePath.components, void 0, !0)) : (basePath = addPath, basePath.newPos++, self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            bestPath[diagonalPath] = basePath;
          }
          editLength++;
        }
        if (__name(execEditLength, "execEditLength"), callback) __name(function exec() {
          setTimeout(function () {
            if (editLength > maxEditLength) return callback();
            execEditLength() || exec();
          }, 0);
        }, "exec")();else for (; editLength <= maxEditLength;) {
          var ret = execEditLength();
          if (ret) return ret;
        }
      }, "diff"),
      pushComponent: __name(function (components, added, removed) {
        var last = components[components.length - 1];
        last && last.added === added && last.removed === removed ? components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        } : components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }, "pushComponent"),
      extractCommon: __name(function (basePath, newString, oldString, diagonalPath) {
        for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1]);) newPos++, oldPos++, commonCount++;
        return commonCount && basePath.components.push({
          count: commonCount
        }), basePath.newPos = newPos, oldPos;
      }, "extractCommon"),
      equals: __name(function (left, right) {
        return this.options.comparator ? this.options.comparator(left, right) : left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }, "equals"),
      removeEmpty: __name(function (array) {
        for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
        return ret;
      }, "removeEmpty"),
      castInput: __name(function (value) {
        return value;
      }, "castInput"),
      tokenize: __name(function (value) {
        return value.split("");
      }, "tokenize"),
      join: __name(function (chars) {
        return chars.join("");
      }, "join")
    };
    __name(buildValues, "buildValues");
    __name(clonePath, "clonePath");
    characterDiff = new Diff(), extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, reWhitespace = /\S/, wordDiff = new Diff();
    wordDiff.equals = function (left, right) {
      return this.options.ignoreCase && (left = left.toLowerCase(), right = right.toLowerCase()), left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function (value) {
      for (var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), i = 0; i < tokens.length - 1; i++) !tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2]) && (tokens[i] += tokens[i + 2], tokens.splice(i + 1, 2), i--);
      return tokens;
    };
    lineDiff = new Diff();
    lineDiff.tokenize = function (value) {
      var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/);
      linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        i % 2 && !this.options.newlineIsToken ? retLines[retLines.length - 1] += line : (this.options.ignoreWhitespace && (line = line.trim()), retLines.push(line));
      }
      return retLines;
    };
    __name(diffLines, "diffLines");
    sentenceDiff = new Diff();
    sentenceDiff.tokenize = function (value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    cssDiff = new Diff();
    cssDiff.tokenize = function (value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    __name(_typeof, "_typeof");
    __name(_toConsumableArray, "_toConsumableArray");
    __name(_arrayWithoutHoles, "_arrayWithoutHoles");
    __name(_iterableToArray, "_iterableToArray");
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    __name(_nonIterableSpread, "_nonIterableSpread");
    objectPrototypeToString = Object.prototype.toString, jsonDiff = new Diff();
    jsonDiff.useLongestToken = !0;
    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function (value) {
      var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
          return typeof v > "u" ? undefinedReplacement : v;
        } : _this$options$stringi;
      return typeof value == "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function (left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
    };
    __name(canonicalize, "canonicalize");
    arrayDiff = new Diff();
    arrayDiff.tokenize = function (value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function (value) {
      return value;
    };
    __name(structuredPatch, "structuredPatch");
  });
function elidableTextForDiff(oldContent, newContent) {
  let languageId = typeof oldContent == "string" ? typeof newContent == "string" ? void 0 : newContent.languageId : typeof newContent == "string" || oldContent.languageId === newContent.languageId ? oldContent.languageId : void 0;
  oldContent = typeof oldContent == "string" ? oldContent : oldContent.source, newContent = typeof newContent == "string" ? newContent : newContent.source;
  let patch = structuredPatch("", "", oldContent, newContent),
    changedLinesOld = new Set(),
    changedLinesNew = new Set();
  for (let hunk of patch.hunks) {
    for (let i = hunk.oldStart; i < hunk.oldStart + hunk.oldLines; i++) changedLinesOld.add(i);
    for (let i = hunk.newStart; i < hunk.newStart + hunk.newLines; i++) changedLinesNew.add(i);
  }
  let oldTree = mapLabels(flattenVirtual(parseTree(oldContent, languageId)), () => !1),
    newTree = mapLabels(flattenVirtual(parseTree(newContent, languageId)), () => !1);
  return visitTree(oldTree, node => {
    (node.type === "line" || node.type === "blank") && changedLinesOld.has(node.lineNumber) && (node.label = !0);
  }, "topDown"), visitTree(newTree, node => {
    (node.type === "line" || node.type === "blank") && changedLinesNew.has(node.lineNumber) && (node.label = !0);
  }, "topDown"), [fromTreeWithFocussedLines(oldTree), fromTreeWithFocussedLines(newTree)];
}
var init_fromDiff = __esmMin(() => {
  "use strict";

  init_lib();
  init_indentation();
  init_fromIndentationTrees();
  __name(elidableTextForDiff, "elidableTextForDiff");
});
var init_elidableText = __esmMin(() => {
  "use strict";

  init_elidableText();
  init_fromDiff();
  init_fromIndentationTrees();
  init_fromSourceCode();
  init_lineWithValueAndCost();
});
var import_fs,
  FileSystem,
  defaultFileSystem,
  init_fileSystem = __esmMin(() => {
    "use strict";

    import_fs = require("fs"), FileSystem = class {
      static {
        __name(this, "FileSystem");
      }
    }, defaultFileSystem = {
      readFile(uri) {
        return jO.fsp.readFile(uri);
      },
      async stat(uri) {
        let stat = await jO.fsp.stat(uri);
        return {
          ctime: stat.ctimeMs,
          mtime: stat.mtimeMs,
          size: stat.size
        };
      }
    };
  });
function hasLanguageMarker({
  source: source
}) {
  return source.startsWith("#!") || source.startsWith("<!DOCTYPE");
}
function comment(text, languageId) {
  let markers = languageCommentMarkers[languageId];
  if (markers) {
    let end = markers.end == "" ? "" : " " + markers.end;
    return `${markers.start} ${text}${end}`;
  }
  return "";
}
function commentBlockAsSingles(text, languageId) {
  if (!languageCommentMarkers[languageId] || text === "") return "";
  let trailingNewline = text.endsWith(`
`),
    commented = (trailingNewline ? text.slice(0, -1) : text).split(`
`).map(line => comment(line, languageId)).join(`
`);
  return trailingNewline ? commented + `
` : commented;
}
function getLanguageMarker(doc) {
  let {
    languageId: languageId
  } = doc;
  return dontAddLanguageMarker.indexOf(languageId) === -1 && !hasLanguageMarker(doc) ? languageId in shebangLines ? shebangLines[languageId] : comment(`Language: ${languageId}`, languageId) : "";
}
function getPathMarker(doc) {
  return doc.relativePath ? comment(`Path: ${doc.relativePath}`, doc.languageId) : "";
}
function newLineEnded(str) {
  return str === "" || str.endsWith(`
`) ? str : str + `
`;
}
var languageCommentMarkers,
  dontAddLanguageMarker,
  shebangLines,
  init_languageMarker = __esmMin(() => {
    "use strict";

    languageCommentMarkers = {
      abap: {
        start: '"',
        end: ""
      },
      bat: {
        start: "REM",
        end: ""
      },
      bibtex: {
        start: "%",
        end: ""
      },
      blade: {
        start: "#",
        end: ""
      },
      c: {
        start: "//",
        end: ""
      },
      clojure: {
        start: ";",
        end: ""
      },
      coffeescript: {
        start: "//",
        end: ""
      },
      cpp: {
        start: "//",
        end: ""
      },
      csharp: {
        start: "//",
        end: ""
      },
      css: {
        start: "/*",
        end: "*/"
      },
      dart: {
        start: "//",
        end: ""
      },
      dockerfile: {
        start: "#",
        end: ""
      },
      elixir: {
        start: "#",
        end: ""
      },
      erb: {
        start: "<%#",
        end: "%>"
      },
      erlang: {
        start: "%",
        end: ""
      },
      fsharp: {
        start: "//",
        end: ""
      },
      go: {
        start: "//",
        end: ""
      },
      groovy: {
        start: "//",
        end: ""
      },
      haml: {
        start: "-#",
        end: ""
      },
      handlebars: {
        start: "{{!",
        end: "}}"
      },
      haskell: {
        start: "--",
        end: ""
      },
      html: {
        start: "<!--",
        end: "-->"
      },
      ini: {
        start: ";",
        end: ""
      },
      java: {
        start: "//",
        end: ""
      },
      javascript: {
        start: "//",
        end: ""
      },
      javascriptreact: {
        start: "//",
        end: ""
      },
      jsonc: {
        start: "//",
        end: ""
      },
      jsx: {
        start: "//",
        end: ""
      },
      julia: {
        start: "#",
        end: ""
      },
      kotlin: {
        start: "//",
        end: ""
      },
      latex: {
        start: "%",
        end: ""
      },
      less: {
        start: "//",
        end: ""
      },
      lua: {
        start: "--",
        end: ""
      },
      makefile: {
        start: "#",
        end: ""
      },
      markdown: {
        start: "[]: #",
        end: ""
      },
      "objective-c": {
        start: "//",
        end: ""
      },
      "objective-cpp": {
        start: "//",
        end: ""
      },
      perl: {
        start: "#",
        end: ""
      },
      php: {
        start: "//",
        end: ""
      },
      powershell: {
        start: "#",
        end: ""
      },
      pug: {
        start: "//",
        end: ""
      },
      python: {
        start: "#",
        end: ""
      },
      ql: {
        start: "//",
        end: ""
      },
      r: {
        start: "#",
        end: ""
      },
      razor: {
        start: "<!--",
        end: "-->"
      },
      ruby: {
        start: "#",
        end: ""
      },
      rust: {
        start: "//",
        end: ""
      },
      sass: {
        start: "//",
        end: ""
      },
      scala: {
        start: "//",
        end: ""
      },
      scss: {
        start: "//",
        end: ""
      },
      shellscript: {
        start: "#",
        end: ""
      },
      slim: {
        start: "/",
        end: ""
      },
      solidity: {
        start: "//",
        end: ""
      },
      sql: {
        start: "--",
        end: ""
      },
      stylus: {
        start: "//",
        end: ""
      },
      svelte: {
        start: "<!--",
        end: "-->"
      },
      swift: {
        start: "//",
        end: ""
      },
      terraform: {
        start: "#",
        end: ""
      },
      tex: {
        start: "%",
        end: ""
      },
      typescript: {
        start: "//",
        end: ""
      },
      typescriptreact: {
        start: "//",
        end: ""
      },
      vb: {
        start: "'",
        end: ""
      },
      verilog: {
        start: "//",
        end: ""
      },
      "vue-html": {
        start: "<!--",
        end: "-->"
      },
      vue: {
        start: "//",
        end: ""
      },
      xml: {
        start: "<!--",
        end: "-->"
      },
      xsl: {
        start: "<!--",
        end: "-->"
      },
      yaml: {
        start: "#",
        end: ""
      }
    }, dontAddLanguageMarker = ["php", "plaintext"], shebangLines = {
      html: "<!DOCTYPE html>",
      python: "#!/usr/bin/env python3",
      ruby: "#!/usr/bin/env ruby",
      shellscript: "#!/bin/sh",
      yaml: "# YAML data"
    };
    __name(hasLanguageMarker, "hasLanguageMarker");
    __name(comment, "comment");
    __name(commentBlockAsSingles, "commentBlockAsSingles");
    __name(getLanguageMarker, "getLanguageMarker");
    __name(getPathMarker, "getPathMarker");
    __name(newLineEnded, "newLineEnded");
  });
var require_tree_sitter = __commonJSMin((exports, module) => {
  var Module = Module !== void 0 ? Module : {},
    TreeSitter = function () {
      var initPromise,
        document = typeof window == "object" ? {
          currentScript: window.document.currentScript
        } : null;
      class Parser {
        static {
          __name(this, "Parser");
        }
        constructor() {
          this.initialize();
        }
        initialize() {
          throw new Error("cannot construct a Parser before calling `init()`");
        }
        static init(moduleOptions) {
          return initPromise || (Module = Object.assign({}, Module, moduleOptions), initPromise = new Promise(resolveInitPromise => {
            var moduleOverrides = Object.assign({}, Module),
              arguments_ = [],
              thisProgram = "./this.program",
              quit_ = __name((e, t) => {
                throw t;
              }, "quit_"),
              ENVIRONMENT_IS_WEB = typeof window == "object",
              ENVIRONMENT_IS_WORKER = typeof importScripts == "function",
              ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string",
              scriptDirectory = "",
              read_,
              readAsync,
              readBinary,
              setWindowTitle;
            function locateFile(e) {
              return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
            }
            __name(locateFile, "locateFile");
            function logExceptionOnExit(e) {
              e instanceof ExitStatus || err("exiting due to exception: " + e);
            }
            if (__name(logExceptionOnExit, "logExceptionOnExit"), ENVIRONMENT_IS_NODE) {
              var fs = require("fs"),
                nodePath = require("path");
              scriptDirectory = ENVIRONMENT_IS_WORKER ? nodePath.dirname(scriptDirectory) + "/" : __dirname + "/", read_ = __name((e, t) => (e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFileSync(e, t ? void 0 : "utf8")), "read_"), readBinary = __name(e => {
                var t = read_(e, !0);
                return t.buffer || (t = new Uint8Array(t)), t;
              }, "readBinary"), readAsync = __name((e, t, r) => {
                e = isFileURI(e) ? new URL(e) : nodePath.normalize(e), fs.readFile(e, function (e, _) {
                  e ? r(e) : t(_.buffer);
                });
              }, "readAsync"), process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), typeof module < "u" && (module.exports = Module), quit_ = __name((e, t) => {
                if (keepRuntimeAlive()) throw process.exitCode = e, t;
                logExceptionOnExit(t), process.exit(e);
              }, "quit_"), Module.inspect = function () {
                return "[Emscripten Module object]";
              };
            } else (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : document !== void 0 && document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = scriptDirectory.indexOf("blob:") !== 0 ? scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", read_ = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.send(null), t.responseText;
            }, "read_"), ENVIRONMENT_IS_WORKER && (readBinary = __name(e => {
              var t = new XMLHttpRequest();
              return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
            }, "readBinary")), readAsync = __name((e, t, r) => {
              var _ = new XMLHttpRequest();
              _.open("GET", e, !0), _.responseType = "arraybuffer", _.onload = () => {
                _.status == 200 || _.status == 0 && _.response ? t(_.response) : r();
              }, _.onerror = r, _.send(null);
            }, "readAsync"), setWindowTitle = __name(e => document.title = e, "setWindowTitle"));
            var out = Module.print || console.log.bind(console),
              err = Module.printErr || console.warn.bind(console);
            Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram), Module.quit && (quit_ = Module.quit);
            var STACK_ALIGN = 16,
              dynamicLibraries = Module.dynamicLibraries || [],
              wasmBinary;
            Module.wasmBinary && (wasmBinary = Module.wasmBinary);
            var noExitRuntime = Module.noExitRuntime || !0,
              wasmMemory;
            typeof WebAssembly != "object" && abort("no native wasm support detected");
            var ABORT = !1,
              EXITSTATUS,
              UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
              buffer,
              HEAP8,
              HEAPU8,
              HEAP16,
              HEAPU16,
              HEAP32,
              HEAPU32,
              HEAPF32,
              HEAPF64;
            function UTF8ArrayToString(e, t, r) {
              for (var _ = t + r, n = t; e[n] && !(n >= _);) ++n;
              if (n - t > 16 && e.buffer && UTF8Decoder) return UTF8Decoder.decode(e.subarray(t, n));
              for (var s = ""; t < n;) {
                var a = e[t++];
                if (128 & a) {
                  var o = 63 & e[t++];
                  if ((224 & a) != 192) {
                    var i = 63 & e[t++];
                    if ((a = (240 & a) == 224 ? (15 & a) << 12 | o << 6 | i : (7 & a) << 18 | o << 12 | i << 6 | 63 & e[t++]) < 65536) s += String.fromCharCode(a);else {
                      var l = a - 65536;
                      s += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);
                    }
                  } else s += String.fromCharCode((31 & a) << 6 | o);
                } else s += String.fromCharCode(a);
              }
              return s;
            }
            __name(UTF8ArrayToString, "UTF8ArrayToString");
            function UTF8ToString(e, t) {
              return e ? UTF8ArrayToString(HEAPU8, e, t) : "";
            }
            __name(UTF8ToString, "UTF8ToString");
            function stringToUTF8Array(e, t, r, _) {
              if (!(_ > 0)) return 0;
              for (var n = r, s = r + _ - 1, a = 0; a < e.length; ++a) {
                var o = e.charCodeAt(a);
                if (o >= 55296 && o <= 57343 && (o = 65536 + ((1023 & o) << 10) | 1023 & e.charCodeAt(++a)), o <= 127) {
                  if (r >= s) break;
                  t[r++] = o;
                } else if (o <= 2047) {
                  if (r + 1 >= s) break;
                  t[r++] = 192 | o >> 6, t[r++] = 128 | 63 & o;
                } else if (o <= 65535) {
                  if (r + 2 >= s) break;
                  t[r++] = 224 | o >> 12, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                } else {
                  if (r + 3 >= s) break;
                  t[r++] = 240 | o >> 18, t[r++] = 128 | o >> 12 & 63, t[r++] = 128 | o >> 6 & 63, t[r++] = 128 | 63 & o;
                }
              }
              return t[r] = 0, r - n;
            }
            __name(stringToUTF8Array, "stringToUTF8Array");
            function stringToUTF8(e, t, r) {
              return stringToUTF8Array(e, HEAPU8, t, r);
            }
            __name(stringToUTF8, "stringToUTF8");
            function lengthBytesUTF8(e) {
              for (var t = 0, r = 0; r < e.length; ++r) {
                var _ = e.charCodeAt(r);
                _ <= 127 ? t++ : _ <= 2047 ? t += 2 : _ >= 55296 && _ <= 57343 ? (t += 4, ++r) : t += 3;
              }
              return t;
            }
            __name(lengthBytesUTF8, "lengthBytesUTF8");
            function updateGlobalBufferAndViews(e) {
              buffer = e, Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e);
            }
            __name(updateGlobalBufferAndViews, "updateGlobalBufferAndViews");
            var INITIAL_MEMORY = Module.INITIAL_MEMORY || 33554432;
            wasmMemory = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({
              initial: INITIAL_MEMORY / 65536,
              maximum: 32768
            }), wasmMemory && (buffer = wasmMemory.buffer), INITIAL_MEMORY = buffer.byteLength, updateGlobalBufferAndViews(buffer);
            var wasmTable = new WebAssembly.Table({
                initial: 20,
                element: "anyfunc"
              }),
              __ATPRERUN__ = [],
              __ATINIT__ = [],
              __ATMAIN__ = [],
              __ATPOSTRUN__ = [],
              __RELOC_FUNCS__ = [],
              runtimeInitialized = !1;
            function keepRuntimeAlive() {
              return noExitRuntime;
            }
            __name(keepRuntimeAlive, "keepRuntimeAlive");
            function preRun() {
              if (Module.preRun) for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length;) addOnPreRun(Module.preRun.shift());
              callRuntimeCallbacks(__ATPRERUN__);
            }
            __name(preRun, "preRun");
            function initRuntime() {
              runtimeInitialized = !0, callRuntimeCallbacks(__RELOC_FUNCS__), callRuntimeCallbacks(__ATINIT__);
            }
            __name(initRuntime, "initRuntime");
            function preMain() {
              callRuntimeCallbacks(__ATMAIN__);
            }
            __name(preMain, "preMain");
            function postRun() {
              if (Module.postRun) for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length;) addOnPostRun(Module.postRun.shift());
              callRuntimeCallbacks(__ATPOSTRUN__);
            }
            __name(postRun, "postRun");
            function addOnPreRun(e) {
              __ATPRERUN__.unshift(e);
            }
            __name(addOnPreRun, "addOnPreRun");
            function addOnInit(e) {
              __ATINIT__.unshift(e);
            }
            __name(addOnInit, "addOnInit");
            function addOnPostRun(e) {
              __ATPOSTRUN__.unshift(e);
            }
            __name(addOnPostRun, "addOnPostRun");
            var runDependencies = 0,
              runDependencyWatcher = null,
              dependenciesFulfilled = null;
            function addRunDependency(e) {
              runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies);
            }
            __name(addRunDependency, "addRunDependency");
            function removeRunDependency(e) {
              if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), runDependencies == 0 && (runDependencyWatcher !== null && (clearInterval(runDependencyWatcher), runDependencyWatcher = null), dependenciesFulfilled)) {
                var t = dependenciesFulfilled;
                dependenciesFulfilled = null, t();
              }
            }
            __name(removeRunDependency, "removeRunDependency");
            function abort(e) {
              throw Module.onAbort && Module.onAbort(e), err(e = "Aborted(" + e + ")"), ABORT = !0, EXITSTATUS = 1, e += ". Build with -sASSERTIONS for more info.", new WebAssembly.RuntimeError(e);
            }
            __name(abort, "abort");
            var dataURIPrefix = "data:application/octet-stream;base64,",
              wasmBinaryFile,
              tempDouble,
              tempI64;
            function isDataURI(e) {
              return e.startsWith(dataURIPrefix);
            }
            __name(isDataURI, "isDataURI");
            function isFileURI(e) {
              return e.startsWith("file://");
            }
            __name(isFileURI, "isFileURI");
            function getBinary(e) {
              try {
                if (e == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                if (readBinary) return readBinary(e);
                throw "both async and sync fetching of the wasm failed";
              } catch (e) {
                abort(e);
              }
            }
            __name(getBinary, "getBinary");
            function getBinaryPromise() {
              if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch == "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                  credentials: "same-origin"
                }).then(function (e) {
                  if (!e.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                  return e.arrayBuffer();
                }).catch(function () {
                  return getBinary(wasmBinaryFile);
                });
                if (readAsync) return new Promise(function (e, t) {
                  readAsync(wasmBinaryFile, function (t) {
                    e(new Uint8Array(t));
                  }, t);
                });
              }
              return Promise.resolve().then(function () {
                return getBinary(wasmBinaryFile);
              });
            }
            __name(getBinaryPromise, "getBinaryPromise");
            function createWasm() {
              var e = {
                env: asmLibraryArg,
                wasi_snapshot_preview1: asmLibraryArg,
                "GOT.mem": new Proxy(asmLibraryArg, GOTHandler),
                "GOT.func": new Proxy(asmLibraryArg, GOTHandler)
              };
              function t(e, t) {
                var r = e.exports;
                r = relocateExports(r, 1024);
                var _ = getDylinkMetadata(t);
                _.neededDynlibs && (dynamicLibraries = _.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(r, "main"), Module.asm = r, addOnInit(Module.asm.__wasm_call_ctors), __RELOC_FUNCS__.push(Module.asm.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate");
              }
              __name(t, "t");
              function r(e) {
                t(e.instance, e.module);
              }
              __name(r, "r");
              function _(t) {
                return getBinaryPromise().then(function (t) {
                  return WebAssembly.instantiate(t, e);
                }).then(function (e) {
                  return e;
                }).then(t, function (e) {
                  err("failed to asynchronously prepare wasm: " + e), abort(e);
                });
              }
              if (__name(_, "_"), addRunDependency("wasm-instantiate"), Module.instantiateWasm) try {
                return Module.instantiateWasm(e, t);
              } catch (e) {
                return err("Module.instantiateWasm callback failed with error: " + e), !1;
              }
              return wasmBinary || typeof WebAssembly.instantiateStreaming != "function" || isDataURI(wasmBinaryFile) || isFileURI(wasmBinaryFile) || ENVIRONMENT_IS_NODE || typeof fetch != "function" ? _(r) : fetch(wasmBinaryFile, {
                credentials: "same-origin"
              }).then(function (t) {
                return WebAssembly.instantiateStreaming(t, e).then(r, function (e) {
                  return err("wasm streaming compile failed: " + e), err("falling back to ArrayBuffer instantiation"), _(r);
                });
              }), {};
            }
            __name(createWasm, "createWasm"), wasmBinaryFile = "tree-sitter.wasm", isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile));
            var ASM_CONSTS = {};
            function ExitStatus(e) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e;
            }
            __name(ExitStatus, "ExitStatus");
            var GOT = {},
              CurrentModuleWeakSymbols = new Set([]),
              GOTHandler = {
                get: function (e, t) {
                  var r = GOT[t];
                  return r || (r = GOT[t] = new WebAssembly.Global({
                    value: "i32",
                    mutable: !0
                  })), CurrentModuleWeakSymbols.has(t) || (r.required = !0), r;
                }
              };
            function callRuntimeCallbacks(e) {
              for (; e.length > 0;) e.shift()(Module);
            }
            __name(callRuntimeCallbacks, "callRuntimeCallbacks");
            function getDylinkMetadata(e) {
              var t = 0,
                r = 0;
              function _() {
                for (var r = 0, _ = 1;;) {
                  var n = e[t++];
                  if (r += (127 & n) * _, _ *= 128, !(128 & n)) break;
                }
                return r;
              }
              __name(_, "_");
              function n() {
                var r = _();
                return UTF8ArrayToString(e, (t += r) - r, r);
              }
              __name(n, "n");
              function s(e, t) {
                if (e) throw new Error(t);
              }
              __name(s, "s");
              var a = "dylink.0";
              if (e instanceof WebAssembly.Module) {
                var o = WebAssembly.Module.customSections(e, a);
                o.length === 0 && (a = "dylink", o = WebAssembly.Module.customSections(e, a)), s(o.length === 0, "need dylink section"), r = (e = new Uint8Array(o[0])).length;
              } else {
                s(new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0] != 1836278016, "need to see wasm magic number"), s(e[8] !== 0, "need the dylink section to be first"), t = 9;
                var i = _();
                r = t + i, a = n();
              }
              var l = {
                neededDynlibs: [],
                tlsExports: new Set(),
                weakImports: new Set()
              };
              if (a == "dylink") {
                l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();
                for (var u = _(), d = 0; d < u; ++d) {
                  var c = n();
                  l.neededDynlibs.push(c);
                }
              } else for (s(a !== "dylink.0"); t < r;) {
                var m = e[t++],
                  p = _();
                if (m === 1) l.memorySize = _(), l.memoryAlign = _(), l.tableSize = _(), l.tableAlign = _();else if (m === 2) for (u = _(), d = 0; d < u; ++d) c = n(), l.neededDynlibs.push(c);else if (m === 3) for (var f = _(); f--;) {
                  var h = n();
                  256 & _() && l.tlsExports.add(h);
                } else if (m === 4) for (f = _(); f--;) n(), h = n(), (3 & _()) == 1 && l.weakImports.add(h);else t += p;
              }
              return l;
            }
            __name(getDylinkMetadata, "getDylinkMetadata");
            function getValue(e, t = "i8") {
              switch (t.endsWith("*") && (t = "*"), t) {
                case "i1":
                case "i8":
                  return HEAP8[e >> 0];
                case "i16":
                  return HEAP16[e >> 1];
                case "i32":
                case "i64":
                  return HEAP32[e >> 2];
                case "float":
                  return HEAPF32[e >> 2];
                case "double":
                  return HEAPF64[e >> 3];
                case "*":
                  return HEAPU32[e >> 2];
                default:
                  abort("invalid type for getValue: " + t);
              }
              return null;
            }
            __name(getValue, "getValue");
            function asmjsMangle(e) {
              return e.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore", "getTempRet0", "setTempRet0"].includes(e) ? e : "_" + e;
            }
            __name(asmjsMangle, "asmjsMangle");
            function mergeLibSymbols(e, t) {
              for (var r in e) if (e.hasOwnProperty(r)) {
                asmLibraryArg.hasOwnProperty(r) || (asmLibraryArg[r] = e[r]);
                var _ = asmjsMangle(r);
                Module.hasOwnProperty(_) || (Module[_] = e[r]), r == "__main_argc_argv" && (Module._main = e[r]);
              }
            }
            __name(mergeLibSymbols, "mergeLibSymbols");
            var LDSO = {
              loadedLibsByName: {},
              loadedLibsByHandle: {}
            };
            function dynCallLegacy(e, t, r) {
              var _ = Module["dynCall_" + e];
              return r && r.length ? _.apply(null, [t].concat(r)) : _.call(null, t);
            }
            __name(dynCallLegacy, "dynCallLegacy");
            var wasmTableMirror = [];
            function getWasmTableEntry(e) {
              var t = wasmTableMirror[e];
              return t || (e >= wasmTableMirror.length && (wasmTableMirror.length = e + 1), wasmTableMirror[e] = t = wasmTable.get(e)), t;
            }
            __name(getWasmTableEntry, "getWasmTableEntry");
            function dynCall(e, t, r) {
              return e.includes("j") ? dynCallLegacy(e, t, r) : getWasmTableEntry(t).apply(null, r);
            }
            __name(dynCall, "dynCall");
            function createInvokeFunction(e) {
              return function () {
                var t = stackSave();
                try {
                  return dynCall(e, arguments[0], Array.prototype.slice.call(arguments, 1));
                } catch (e) {
                  if (stackRestore(t), e !== e + 0) throw e;
                  _setThrew(1, 0);
                }
              };
            }
            __name(createInvokeFunction, "createInvokeFunction");
            var ___heap_base = 78144;
            function zeroMemory(e, t) {
              return HEAPU8.fill(0, e, e + t), e;
            }
            __name(zeroMemory, "zeroMemory");
            function getMemory(e) {
              if (runtimeInitialized) return zeroMemory(_malloc(e), e);
              var t = ___heap_base,
                r = t + e + 15 & -16;
              return ___heap_base = r, GOT.__heap_base.value = r, t;
            }
            __name(getMemory, "getMemory");
            function isInternalSym(e) {
              return ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm"].includes(e);
            }
            __name(isInternalSym, "isInternalSym");
            function uleb128Encode(e, t) {
              e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
            }
            __name(uleb128Encode, "uleb128Encode");
            function sigToWasmTypes(e) {
              for (var t = {
                  i: "i32",
                  j: "i32",
                  f: "f32",
                  d: "f64",
                  p: "i32"
                }, r = {
                  parameters: [],
                  results: e[0] == "v" ? [] : [t[e[0]]]
                }, _ = 1; _ < e.length; ++_) r.parameters.push(t[e[_]]), e[_] === "j" && r.parameters.push("i32");
              return r;
            }
            __name(sigToWasmTypes, "sigToWasmTypes");
            function generateFuncType(e, t) {
              var r = e.slice(0, 1),
                _ = e.slice(1),
                n = {
                  i: 127,
                  p: 127,
                  j: 126,
                  f: 125,
                  d: 124
                };
              t.push(96), uleb128Encode(_.length, t);
              for (var s = 0; s < _.length; ++s) t.push(n[_[s]]);
              r == "v" ? t.push(0) : t.push(1, n[r]);
            }
            __name(generateFuncType, "generateFuncType");
            function convertJsFunctionToWasm(e, t) {
              if (typeof WebAssembly.Function == "function") return new WebAssembly.Function(sigToWasmTypes(t), e);
              var r = [1];
              generateFuncType(t, r);
              var _ = [0, 97, 115, 109, 1, 0, 0, 0, 1];
              uleb128Encode(r.length, _), _.push.apply(_, r), _.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
              var n = new WebAssembly.Module(new Uint8Array(_));
              return new WebAssembly.Instance(n, {
                e: {
                  f: e
                }
              }).exports.f;
            }
            __name(convertJsFunctionToWasm, "convertJsFunctionToWasm");
            function updateTableMap(e, t) {
              if (functionsInTableMap) for (var r = e; r < e + t; r++) {
                var _ = getWasmTableEntry(r);
                _ && functionsInTableMap.set(_, r);
              }
            }
            __name(updateTableMap, "updateTableMap");
            var functionsInTableMap = void 0,
              freeTableIndexes = [];
            function getEmptyTableSlot() {
              if (freeTableIndexes.length) return freeTableIndexes.pop();
              try {
                wasmTable.grow(1);
              } catch (e) {
                throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
              }
              return wasmTable.length - 1;
            }
            __name(getEmptyTableSlot, "getEmptyTableSlot");
            function setWasmTableEntry(e, t) {
              wasmTable.set(e, t), wasmTableMirror[e] = wasmTable.get(e);
            }
            __name(setWasmTableEntry, "setWasmTableEntry");
            function addFunction(e, t) {
              if (functionsInTableMap || (functionsInTableMap = new WeakMap(), updateTableMap(0, wasmTable.length)), functionsInTableMap.has(e)) return functionsInTableMap.get(e);
              var r = getEmptyTableSlot();
              try {
                setWasmTableEntry(r, e);
              } catch (_) {
                if (!(_ instanceof TypeError)) throw _;
                setWasmTableEntry(r, convertJsFunctionToWasm(e, t));
              }
              return functionsInTableMap.set(e, r), r;
            }
            __name(addFunction, "addFunction");
            function updateGOT(e, t) {
              for (var r in e) if (!isInternalSym(r)) {
                var _ = e[r];
                r.startsWith("orig$") && (r = r.split("$")[1], t = !0), GOT[r] || (GOT[r] = new WebAssembly.Global({
                  value: "i32",
                  mutable: !0
                })), (t || GOT[r].value == 0) && (typeof _ == "function" ? GOT[r].value = addFunction(_) : typeof _ == "number" ? GOT[r].value = _ : err("unhandled export type for `" + r + "`: " + typeof _));
              }
            }
            __name(updateGOT, "updateGOT");
            function relocateExports(e, t, r) {
              var _ = {};
              for (var n in e) {
                var s = e[n];
                typeof s == "object" && (s = s.value), typeof s == "number" && (s += t), _[n] = s;
              }
              return updateGOT(_, r), _;
            }
            __name(relocateExports, "relocateExports");
            function resolveGlobalSymbol(e, t) {
              var r;
              return t && (r = asmLibraryArg["orig$" + e]), r || (r = asmLibraryArg[e]) && r.stub && (r = void 0), r || (r = Module[asmjsMangle(e)]), !r && e.startsWith("invoke_") && (r = createInvokeFunction(e.split("_")[1])), r;
            }
            __name(resolveGlobalSymbol, "resolveGlobalSymbol");
            function alignMemory(e, t) {
              return Math.ceil(e / t) * t;
            }
            __name(alignMemory, "alignMemory");
            function loadWebAssemblyModule(binary, flags, handle) {
              var metadata = getDylinkMetadata(binary);
              function loadModule() {
                var firstLoad = !handle || !HEAP8[handle + 12 >> 0];
                if (firstLoad) {
                  var memAlign = Math.pow(2, metadata.memoryAlign);
                  memAlign = Math.max(memAlign, STACK_ALIGN);
                  var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0,
                    tableBase = metadata.tableSize ? wasmTable.length : 0;
                  handle && (HEAP8[handle + 12 >> 0] = 1, HEAPU32[handle + 16 >> 2] = memoryBase, HEAP32[handle + 20 >> 2] = metadata.memorySize, HEAPU32[handle + 24 >> 2] = tableBase, HEAP32[handle + 28 >> 2] = metadata.tableSize);
                } else memoryBase = HEAPU32[handle + 16 >> 2], tableBase = HEAPU32[handle + 24 >> 2];
                var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length,
                  moduleExports;
                function resolveSymbol(e) {
                  var t = resolveGlobalSymbol(e, !1);
                  return t || (t = moduleExports[e]), t;
                }
                __name(resolveSymbol, "resolveSymbol"), tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
                var proxyHandler = {
                    get: function (e, t) {
                      switch (t) {
                        case "__memory_base":
                          return memoryBase;
                        case "__table_base":
                          return tableBase;
                      }
                      if (t in asmLibraryArg) return asmLibraryArg[t];
                      var r;
                      return t in e || (e[t] = function () {
                        return r || (r = resolveSymbol(t)), r.apply(null, arguments);
                      }), e[t];
                    }
                  },
                  proxy = new Proxy({}, proxyHandler),
                  info = {
                    "GOT.mem": new Proxy({}, GOTHandler),
                    "GOT.func": new Proxy({}, GOTHandler),
                    env: proxy,
                    wasi_snapshot_preview1: proxy
                  };
                function postInstantiation(instance) {
                  function addEmAsm(addr, body) {
                    for (var args = [], arity = 0; arity < 16 && body.indexOf("$" + arity) != -1; arity++) args.push("$" + arity);
                    args = args.join(",");
                    var func = "(" + args + " ) => { " + body + "};";
                    ASM_CONSTS[start] = eval(func);
                  }
                  if (__name(addEmAsm, "addEmAsm"), updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols(), "__start_em_asm" in moduleExports) for (var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start < stop;) {
                    var jsString = UTF8ToString(start);
                    addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
                  }
                  var applyRelocs = moduleExports.__wasm_apply_data_relocs;
                  applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
                  var init = moduleExports.__wasm_call_ctors;
                  return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
                }
                if (__name(postInstantiation, "postInstantiation"), flags.loadAsync) {
                  if (binary instanceof WebAssembly.Module) {
                    var instance = new WebAssembly.Instance(binary, info);
                    return Promise.resolve(postInstantiation(instance));
                  }
                  return WebAssembly.instantiate(binary, info).then(function (e) {
                    return postInstantiation(e.instance);
                  });
                }
                var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary),
                  instance = new WebAssembly.Instance(module, info);
                return postInstantiation(instance);
              }
              return __name(loadModule, "loadModule"), CurrentModuleWeakSymbols = metadata.weakImports, flags.loadAsync ? metadata.neededDynlibs.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, flags);
                });
              }, Promise.resolve()).then(function () {
                return loadModule();
              }) : (metadata.neededDynlibs.forEach(function (e) {
                loadDynamicLibrary(e, flags);
              }), loadModule());
            }
            __name(loadWebAssemblyModule, "loadWebAssemblyModule");
            function loadDynamicLibrary(e, t, r) {
              t = t || {
                global: !0,
                nodelete: !0
              };
              var _ = LDSO.loadedLibsByName[e];
              if (_) return t.global && !_.global && (_.global = !0, _.module !== "loading" && mergeLibSymbols(_.module, e)), t.nodelete && _.refcount !== 1 / 0 && (_.refcount = 1 / 0), _.refcount++, r && (LDSO.loadedLibsByHandle[r] = _), !t.loadAsync || Promise.resolve(!0);
              function n(e) {
                if (t.fs && t.fs.findObject(e)) {
                  var r = t.fs.readFile(e, {
                    encoding: "binary"
                  });
                  return r instanceof Uint8Array || (r = new Uint8Array(r)), t.loadAsync ? Promise.resolve(r) : r;
                }
                if (e = locateFile(e), t.loadAsync) return new Promise(function (t, r) {
                  readAsync(e, e => t(new Uint8Array(e)), r);
                });
                if (!readBinary) throw new Error(e + ": file not found, and synchronous loading of external files is not available");
                return readBinary(e);
              }
              __name(n, "n");
              function s() {
                if (typeof preloadedWasm < "u" && preloadedWasm[e]) {
                  var _ = preloadedWasm[e];
                  return t.loadAsync ? Promise.resolve(_) : _;
                }
                return t.loadAsync ? n(e).then(function (e) {
                  return loadWebAssemblyModule(e, t, r);
                }) : loadWebAssemblyModule(n(e), t, r);
              }
              __name(s, "s");
              function a(t) {
                _.global && mergeLibSymbols(t, e), _.module = t;
              }
              return __name(a, "a"), _ = {
                refcount: t.nodelete ? 1 / 0 : 1,
                name: e,
                module: "loading",
                global: t.global
              }, LDSO.loadedLibsByName[e] = _, r && (LDSO.loadedLibsByHandle[r] = _), t.loadAsync ? s().then(function (e) {
                return a(e), !0;
              }) : (a(s()), !0);
            }
            __name(loadDynamicLibrary, "loadDynamicLibrary");
            function reportUndefinedSymbols() {
              for (var e in GOT) if (GOT[e].value == 0) {
                var t = resolveGlobalSymbol(e, !0);
                if (!t && !GOT[e].required) continue;
                if (typeof t == "function") GOT[e].value = addFunction(t, t.sig);else {
                  if (typeof t != "number") throw new Error("bad export type for `" + e + "`: " + typeof t);
                  GOT[e].value = t;
                }
              }
            }
            __name(reportUndefinedSymbols, "reportUndefinedSymbols");
            function preloadDylibs() {
              dynamicLibraries.length ? (addRunDependency("preloadDylibs"), dynamicLibraries.reduce(function (e, t) {
                return e.then(function () {
                  return loadDynamicLibrary(t, {
                    loadAsync: !0,
                    global: !0,
                    nodelete: !0,
                    allowUndefined: !0
                  });
                });
              }, Promise.resolve()).then(function () {
                reportUndefinedSymbols(), removeRunDependency("preloadDylibs");
              })) : reportUndefinedSymbols();
            }
            __name(preloadDylibs, "preloadDylibs");
            function setValue(e, t, r = "i8") {
              switch (r.endsWith("*") && (r = "*"), r) {
                case "i1":
                case "i8":
                  HEAP8[e >> 0] = t;
                  break;
                case "i16":
                  HEAP16[e >> 1] = t;
                  break;
                case "i32":
                  HEAP32[e >> 2] = t;
                  break;
                case "i64":
                  tempI64 = [t >>> 0, (tempDouble = t, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[e >> 2] = tempI64[0], HEAP32[e + 4 >> 2] = tempI64[1];
                  break;
                case "float":
                  HEAPF32[e >> 2] = t;
                  break;
                case "double":
                  HEAPF64[e >> 3] = t;
                  break;
                case "*":
                  HEAPU32[e >> 2] = t;
                  break;
                default:
                  abort("invalid type for setValue: " + r);
              }
            }
            __name(setValue, "setValue");
            var ___memory_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1024),
              ___stack_pointer = new WebAssembly.Global({
                value: "i32",
                mutable: !0
              }, 78144),
              ___table_base = new WebAssembly.Global({
                value: "i32",
                mutable: !1
              }, 1),
              nowIsMonotonic = !0,
              _emscripten_get_now;
            function __emscripten_get_now_is_monotonic() {
              return nowIsMonotonic;
            }
            __name(__emscripten_get_now_is_monotonic, "__emscripten_get_now_is_monotonic");
            function _abort() {
              abort("");
            }
            __name(_abort, "_abort");
            function _emscripten_date_now() {
              return Date.now();
            }
            __name(_emscripten_date_now, "_emscripten_date_now");
            function _emscripten_memcpy_big(e, t, r) {
              HEAPU8.copyWithin(e, t, t + r);
            }
            __name(_emscripten_memcpy_big, "_emscripten_memcpy_big");
            function getHeapMax() {
              return 2147483648;
            }
            __name(getHeapMax, "getHeapMax");
            function emscripten_realloc_buffer(e) {
              try {
                return wasmMemory.grow(e - buffer.byteLength + 65535 >>> 16), updateGlobalBufferAndViews(wasmMemory.buffer), 1;
              } catch {}
            }
            __name(emscripten_realloc_buffer, "emscripten_realloc_buffer");
            function _emscripten_resize_heap(e) {
              var t = HEAPU8.length;
              e >>>= 0;
              var r = getHeapMax();
              if (e > r) return !1;
              for (var _ = 1; _ <= 4; _ *= 2) {
                var n = t * (1 + .2 / _);
                if (n = Math.min(n, e + 100663296), emscripten_realloc_buffer(Math.min(r, (s = Math.max(e, n)) + ((a = 65536) - s % a) % a))) return !0;
              }
              var s, a;
              return !1;
            }
            __name(_emscripten_resize_heap, "_emscripten_resize_heap"), __emscripten_get_now_is_monotonic.sig = "i", Module._abort = _abort, _abort.sig = "v", _emscripten_date_now.sig = "d", _emscripten_get_now = ENVIRONMENT_IS_NODE ? () => {
              var e = process.hrtime();
              return 1e3 * e[0] + e[1] / 1e6;
            } : () => performance.now(), _emscripten_get_now.sig = "d", _emscripten_memcpy_big.sig = "vppp", _emscripten_resize_heap.sig = "ip";
            var SYSCALLS = {
              DEFAULT_POLLMASK: 5,
              calculateAt: function (e, t, r) {
                if (PATH.isAbs(t)) return t;
                var _;
                if (e === -100 ? _ = FS.cwd() : _ = SYSCALLS.getStreamFromFD(e).path, t.length == 0) {
                  if (!r) throw new FS.ErrnoError(44);
                  return _;
                }
                return PATH.join2(_, t);
              },
              doStat: function (e, t, r) {
                try {
                  var _ = e(t);
                } catch (e) {
                  if (e && e.node && PATH.normalize(t) !== PATH.normalize(FS.getPath(e.node))) return -54;
                  throw e;
                }
                HEAP32[r >> 2] = _.dev, HEAP32[r + 8 >> 2] = _.ino, HEAP32[r + 12 >> 2] = _.mode, HEAPU32[r + 16 >> 2] = _.nlink, HEAP32[r + 20 >> 2] = _.uid, HEAP32[r + 24 >> 2] = _.gid, HEAP32[r + 28 >> 2] = _.rdev, tempI64 = [_.size >>> 0, (tempDouble = _.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 40 >> 2] = tempI64[0], HEAP32[r + 44 >> 2] = tempI64[1], HEAP32[r + 48 >> 2] = 4096, HEAP32[r + 52 >> 2] = _.blocks;
                var n = _.atime.getTime(),
                  s = _.mtime.getTime(),
                  a = _.ctime.getTime();
                return tempI64 = [Math.floor(n / 1e3) >>> 0, (tempDouble = Math.floor(n / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 56 >> 2] = tempI64[0], HEAP32[r + 60 >> 2] = tempI64[1], HEAPU32[r + 64 >> 2] = n % 1e3 * 1e3, tempI64 = [Math.floor(s / 1e3) >>> 0, (tempDouble = Math.floor(s / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 72 >> 2] = tempI64[0], HEAP32[r + 76 >> 2] = tempI64[1], HEAPU32[r + 80 >> 2] = s % 1e3 * 1e3, tempI64 = [Math.floor(a / 1e3) >>> 0, (tempDouble = Math.floor(a / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 88 >> 2] = tempI64[0], HEAP32[r + 92 >> 2] = tempI64[1], HEAPU32[r + 96 >> 2] = a % 1e3 * 1e3, tempI64 = [_.ino >>> 0, (tempDouble = _.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[r + 104 >> 2] = tempI64[0], HEAP32[r + 108 >> 2] = tempI64[1], 0;
              },
              doMsync: function (e, t, r, _, n) {
                if (!FS.isFile(t.node.mode)) throw new FS.ErrnoError(43);
                if (2 & _) return 0;
                var s = HEAPU8.slice(e, e + r);
                FS.msync(t, s, n, r, _);
              },
              varargs: void 0,
              get: function () {
                return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2];
              },
              getStr: function (e) {
                return UTF8ToString(e);
              },
              getStreamFromFD: function (e) {
                var t = FS.getStream(e);
                if (!t) throw new FS.ErrnoError(8);
                return t;
              }
            };
            function _proc_exit(e) {
              EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit && Module.onExit(e), ABORT = !0), quit_(e, new ExitStatus(e));
            }
            __name(_proc_exit, "_proc_exit");
            function exitJS(e, t) {
              EXITSTATUS = e, _proc_exit(e);
            }
            __name(exitJS, "exitJS"), _proc_exit.sig = "vi";
            var _exit = exitJS;
            function _fd_close(e) {
              try {
                var t = SYSCALLS.getStreamFromFD(e);
                return FS.close(t), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_close, "_fd_close");
            function convertI32PairToI53Checked(e, t) {
              return t + 2097152 >>> 0 < 4194305 - !!e ? (e >>> 0) + 4294967296 * t : NaN;
            }
            __name(convertI32PairToI53Checked, "convertI32PairToI53Checked");
            function _fd_seek(e, t, r, _, n) {
              try {
                var s = convertI32PairToI53Checked(t, r);
                if (isNaN(s)) return 61;
                var a = SYSCALLS.getStreamFromFD(e);
                return FS.llseek(a, s, _), tempI64 = [a.position >>> 0, (tempDouble = a.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math.min(+Math.floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[n >> 2] = tempI64[0], HEAP32[n + 4 >> 2] = tempI64[1], a.getdents && s === 0 && _ === 0 && (a.getdents = null), 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_seek, "_fd_seek");
            function doWritev(e, t, r, _) {
              for (var n = 0, s = 0; s < r; s++) {
                var a = HEAPU32[t >> 2],
                  o = HEAPU32[t + 4 >> 2];
                t += 8;
                var i = FS.write(e, HEAP8, a, o, _);
                if (i < 0) return -1;
                n += i, _ !== void 0 && (_ += i);
              }
              return n;
            }
            __name(doWritev, "doWritev");
            function _fd_write(e, t, r, _) {
              try {
                var n = doWritev(SYSCALLS.getStreamFromFD(e), t, r);
                return HEAPU32[_ >> 2] = n, 0;
              } catch (e) {
                if (typeof FS > "u" || !(e instanceof FS.ErrnoError)) throw e;
                return e.errno;
              }
            }
            __name(_fd_write, "_fd_write");
            function _tree_sitter_log_callback(e, t) {
              if (currentLogCallback) {
                let r = UTF8ToString(t);
                currentLogCallback(r, e !== 0);
              }
            }
            __name(_tree_sitter_log_callback, "_tree_sitter_log_callback");
            function _tree_sitter_parse_callback(e, t, r, _, n) {
              var s = currentParseCallback(t, {
                row: r,
                column: _
              });
              typeof s == "string" ? (setValue(n, s.length, "i32"), stringToUTF16(s, e, 10240)) : setValue(n, 0, "i32");
            }
            __name(_tree_sitter_parse_callback, "_tree_sitter_parse_callback");
            function handleException(e) {
              if (e instanceof ExitStatus || e == "unwind") return EXITSTATUS;
              quit_(1, e);
            }
            __name(handleException, "handleException");
            function allocateUTF8OnStack(e) {
              var t = lengthBytesUTF8(e) + 1,
                r = stackAlloc(t);
              return stringToUTF8Array(e, HEAP8, r, t), r;
            }
            __name(allocateUTF8OnStack, "allocateUTF8OnStack");
            function stringToUTF16(e, t, r) {
              if (r === void 0 && (r = 2147483647), r < 2) return 0;
              for (var _ = t, n = (r -= 2) < 2 * e.length ? r / 2 : e.length, s = 0; s < n; ++s) {
                var a = e.charCodeAt(s);
                HEAP16[t >> 1] = a, t += 2;
              }
              return HEAP16[t >> 1] = 0, t - _;
            }
            __name(stringToUTF16, "stringToUTF16");
            function AsciiToString(e) {
              for (var t = "";;) {
                var r = HEAPU8[e++ >> 0];
                if (!r) return t;
                t += String.fromCharCode(r);
              }
            }
            __name(AsciiToString, "AsciiToString"), _exit.sig = "vi", _fd_close.sig = "ii", _fd_seek.sig = "iijip", _fd_write.sig = "iippp";
            var asmLibraryArg = {
                __heap_base: ___heap_base,
                __indirect_function_table: wasmTable,
                __memory_base: ___memory_base,
                __stack_pointer: ___stack_pointer,
                __table_base: ___table_base,
                _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
                abort: _abort,
                emscripten_get_now: _emscripten_get_now,
                emscripten_memcpy_big: _emscripten_memcpy_big,
                emscripten_resize_heap: _emscripten_resize_heap,
                exit: _exit,
                fd_close: _fd_close,
                fd_seek: _fd_seek,
                fd_write: _fd_write,
                memory: wasmMemory,
                tree_sitter_log_callback: _tree_sitter_log_callback,
                tree_sitter_parse_callback: _tree_sitter_parse_callback
              },
              asm = createWasm(),
              ___wasm_call_ctors = Module.___wasm_call_ctors = function () {
                return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
              },
              ___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = function () {
                return (___wasm_apply_data_relocs = Module.___wasm_apply_data_relocs = Module.asm.__wasm_apply_data_relocs).apply(null, arguments);
              },
              _malloc = Module._malloc = function () {
                return (_malloc = Module._malloc = Module.asm.malloc).apply(null, arguments);
              },
              _calloc = Module._calloc = function () {
                return (_calloc = Module._calloc = Module.asm.calloc).apply(null, arguments);
              },
              _realloc = Module._realloc = function () {
                return (_realloc = Module._realloc = Module.asm.realloc).apply(null, arguments);
              },
              _free = Module._free = function () {
                return (_free = Module._free = Module.asm.free).apply(null, arguments);
              },
              _ts_language_symbol_count = Module._ts_language_symbol_count = function () {
                return (_ts_language_symbol_count = Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
              },
              _ts_language_version = Module._ts_language_version = function () {
                return (_ts_language_version = Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
              },
              _ts_language_field_count = Module._ts_language_field_count = function () {
                return (_ts_language_field_count = Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
              },
              _ts_language_symbol_name = Module._ts_language_symbol_name = function () {
                return (_ts_language_symbol_name = Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
              },
              _ts_language_symbol_for_name = Module._ts_language_symbol_for_name = function () {
                return (_ts_language_symbol_for_name = Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
              },
              _ts_language_symbol_type = Module._ts_language_symbol_type = function () {
                return (_ts_language_symbol_type = Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
              },
              _ts_language_field_name_for_id = Module._ts_language_field_name_for_id = function () {
                return (_ts_language_field_name_for_id = Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
              },
              _memset = Module._memset = function () {
                return (_memset = Module._memset = Module.asm.memset).apply(null, arguments);
              },
              _memcpy = Module._memcpy = function () {
                return (_memcpy = Module._memcpy = Module.asm.memcpy).apply(null, arguments);
              },
              _ts_parser_delete = Module._ts_parser_delete = function () {
                return (_ts_parser_delete = Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
              },
              _ts_parser_reset = Module._ts_parser_reset = function () {
                return (_ts_parser_reset = Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
              },
              _ts_parser_set_language = Module._ts_parser_set_language = function () {
                return (_ts_parser_set_language = Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
              },
              _ts_parser_timeout_micros = Module._ts_parser_timeout_micros = function () {
                return (_ts_parser_timeout_micros = Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
              },
              _ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = function () {
                return (_ts_parser_set_timeout_micros = Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
              },
              _memmove = Module._memmove = function () {
                return (_memmove = Module._memmove = Module.asm.memmove).apply(null, arguments);
              },
              _memcmp = Module._memcmp = function () {
                return (_memcmp = Module._memcmp = Module.asm.memcmp).apply(null, arguments);
              },
              _ts_query_new = Module._ts_query_new = function () {
                return (_ts_query_new = Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
              },
              _ts_query_delete = Module._ts_query_delete = function () {
                return (_ts_query_delete = Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
              },
              _iswspace = Module._iswspace = function () {
                return (_iswspace = Module._iswspace = Module.asm.iswspace).apply(null, arguments);
              },
              _iswalnum = Module._iswalnum = function () {
                return (_iswalnum = Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
              },
              _ts_query_pattern_count = Module._ts_query_pattern_count = function () {
                return (_ts_query_pattern_count = Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
              },
              _ts_query_capture_count = Module._ts_query_capture_count = function () {
                return (_ts_query_capture_count = Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
              },
              _ts_query_string_count = Module._ts_query_string_count = function () {
                return (_ts_query_string_count = Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
              },
              _ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = function () {
                return (_ts_query_capture_name_for_id = Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
              },
              _ts_query_string_value_for_id = Module._ts_query_string_value_for_id = function () {
                return (_ts_query_string_value_for_id = Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
              },
              _ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = function () {
                return (_ts_query_predicates_for_pattern = Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
              },
              _ts_tree_copy = Module._ts_tree_copy = function () {
                return (_ts_tree_copy = Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
              },
              _ts_tree_delete = Module._ts_tree_delete = function () {
                return (_ts_tree_delete = Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
              },
              _ts_init = Module._ts_init = function () {
                return (_ts_init = Module._ts_init = Module.asm.ts_init).apply(null, arguments);
              },
              _ts_parser_new_wasm = Module._ts_parser_new_wasm = function () {
                return (_ts_parser_new_wasm = Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
              },
              _ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = function () {
                return (_ts_parser_enable_logger_wasm = Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
              },
              _ts_parser_parse_wasm = Module._ts_parser_parse_wasm = function () {
                return (_ts_parser_parse_wasm = Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
              },
              _ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = function () {
                return (_ts_language_type_is_named_wasm = Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
              },
              _ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = function () {
                return (_ts_language_type_is_visible_wasm = Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
              },
              _ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = function () {
                return (_ts_tree_root_node_wasm = Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
              },
              _ts_tree_edit_wasm = Module._ts_tree_edit_wasm = function () {
                return (_ts_tree_edit_wasm = Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
              },
              _ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = function () {
                return (_ts_tree_get_changed_ranges_wasm = Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = function () {
                return (_ts_tree_cursor_new_wasm = Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = function () {
                return (_ts_tree_cursor_delete_wasm = Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = function () {
                return (_ts_tree_cursor_reset_wasm = Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = function () {
                return (_ts_tree_cursor_goto_first_child_wasm = Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = function () {
                return (_ts_tree_cursor_goto_next_sibling_wasm = Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = function () {
                return (_ts_tree_cursor_goto_parent_wasm = Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = function () {
                return (_ts_tree_cursor_current_node_type_id_wasm = Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = function () {
                return (_ts_tree_cursor_current_node_is_named_wasm = Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = function () {
                return (_ts_tree_cursor_current_node_is_missing_wasm = Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = function () {
                return (_ts_tree_cursor_current_node_id_wasm = Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = function () {
                return (_ts_tree_cursor_start_position_wasm = Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = function () {
                return (_ts_tree_cursor_end_position_wasm = Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = function () {
                return (_ts_tree_cursor_start_index_wasm = Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = function () {
                return (_ts_tree_cursor_end_index_wasm = Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = function () {
                return (_ts_tree_cursor_current_field_id_wasm = Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
              },
              _ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = function () {
                return (_ts_tree_cursor_current_node_wasm = Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
              },
              _ts_node_symbol_wasm = Module._ts_node_symbol_wasm = function () {
                return (_ts_node_symbol_wasm = Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
              },
              _ts_node_child_count_wasm = Module._ts_node_child_count_wasm = function () {
                return (_ts_node_child_count_wasm = Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
              },
              _ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = function () {
                return (_ts_node_named_child_count_wasm = Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
              },
              _ts_node_child_wasm = Module._ts_node_child_wasm = function () {
                return (_ts_node_child_wasm = Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
              },
              _ts_node_named_child_wasm = Module._ts_node_named_child_wasm = function () {
                return (_ts_node_named_child_wasm = Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
              },
              _ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = function () {
                return (_ts_node_child_by_field_id_wasm = Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
              },
              _ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = function () {
                return (_ts_node_next_sibling_wasm = Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = function () {
                return (_ts_node_prev_sibling_wasm = Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
              },
              _ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = function () {
                return (_ts_node_next_named_sibling_wasm = Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = function () {
                return (_ts_node_prev_named_sibling_wasm = Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
              },
              _ts_node_parent_wasm = Module._ts_node_parent_wasm = function () {
                return (_ts_node_parent_wasm = Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = function () {
                return (_ts_node_descendant_for_index_wasm = Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = function () {
                return (_ts_node_named_descendant_for_index_wasm = Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
              },
              _ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = function () {
                return (_ts_node_descendant_for_position_wasm = Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = function () {
                return (_ts_node_named_descendant_for_position_wasm = Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
              },
              _ts_node_start_point_wasm = Module._ts_node_start_point_wasm = function () {
                return (_ts_node_start_point_wasm = Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
              },
              _ts_node_end_point_wasm = Module._ts_node_end_point_wasm = function () {
                return (_ts_node_end_point_wasm = Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
              },
              _ts_node_start_index_wasm = Module._ts_node_start_index_wasm = function () {
                return (_ts_node_start_index_wasm = Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
              },
              _ts_node_end_index_wasm = Module._ts_node_end_index_wasm = function () {
                return (_ts_node_end_index_wasm = Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
              },
              _ts_node_to_string_wasm = Module._ts_node_to_string_wasm = function () {
                return (_ts_node_to_string_wasm = Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
              },
              _ts_node_children_wasm = Module._ts_node_children_wasm = function () {
                return (_ts_node_children_wasm = Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
              },
              _ts_node_named_children_wasm = Module._ts_node_named_children_wasm = function () {
                return (_ts_node_named_children_wasm = Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
              },
              _ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = function () {
                return (_ts_node_descendants_of_type_wasm = Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
              },
              _ts_node_is_named_wasm = Module._ts_node_is_named_wasm = function () {
                return (_ts_node_is_named_wasm = Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
              },
              _ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = function () {
                return (_ts_node_has_changes_wasm = Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
              },
              _ts_node_has_error_wasm = Module._ts_node_has_error_wasm = function () {
                return (_ts_node_has_error_wasm = Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
              },
              _ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = function () {
                return (_ts_node_is_missing_wasm = Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
              },
              _ts_query_matches_wasm = Module._ts_query_matches_wasm = function () {
                return (_ts_query_matches_wasm = Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
              },
              _ts_query_captures_wasm = Module._ts_query_captures_wasm = function () {
                return (_ts_query_captures_wasm = Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
              },
              ___cxa_atexit = Module.___cxa_atexit = function () {
                return (___cxa_atexit = Module.___cxa_atexit = Module.asm.__cxa_atexit).apply(null, arguments);
              },
              _iswdigit = Module._iswdigit = function () {
                return (_iswdigit = Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
              },
              _iswalpha = Module._iswalpha = function () {
                return (_iswalpha = Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
              },
              _iswlower = Module._iswlower = function () {
                return (_iswlower = Module._iswlower = Module.asm.iswlower).apply(null, arguments);
              },
              _memchr = Module._memchr = function () {
                return (_memchr = Module._memchr = Module.asm.memchr).apply(null, arguments);
              },
              _strlen = Module._strlen = function () {
                return (_strlen = Module._strlen = Module.asm.strlen).apply(null, arguments);
              },
              _towupper = Module._towupper = function () {
                return (_towupper = Module._towupper = Module.asm.towupper).apply(null, arguments);
              },
              _setThrew = Module._setThrew = function () {
                return (_setThrew = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
              },
              stackSave = Module.stackSave = function () {
                return (stackSave = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
              },
              stackRestore = Module.stackRestore = function () {
                return (stackRestore = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
              },
              stackAlloc = Module.stackAlloc = function () {
                return (stackAlloc = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
              },
              __Znwm = Module.__Znwm = function () {
                return (__Znwm = Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
              },
              __ZdlPv = Module.__ZdlPv = function () {
                return (__ZdlPv = Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
              },
              __ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {
                return (__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {
                return (__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
              },
              __ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = function () {
                return (__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE6resizeEmw).apply(null, arguments);
              },
              dynCall_jiji = Module.dynCall_jiji = function () {
                return (dynCall_jiji = Module.dynCall_jiji = Module.asm.dynCall_jiji).apply(null, arguments);
              },
              _orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = function () {
                return (_orig$ts_parser_timeout_micros = Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
              },
              _orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = function () {
                return (_orig$ts_parser_set_timeout_micros = Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
              },
              calledRun;
            function callMain(e) {
              var t = Module._main;
              if (t) {
                (e = e || []).unshift(thisProgram);
                var r = e.length,
                  _ = stackAlloc(4 * (r + 1)),
                  n = _ >> 2;
                e.forEach(e => {
                  HEAP32[n++] = allocateUTF8OnStack(e);
                }), HEAP32[n] = 0;
                try {
                  var s = t(r, _);
                  return exitJS(s, !0), s;
                } catch (e) {
                  return handleException(e);
                }
              }
            }
            __name(callMain, "callMain"), Module.AsciiToString = AsciiToString, Module.stringToUTF16 = stringToUTF16, dependenciesFulfilled = __name(function e() {
              calledRun || run(), calledRun || (dependenciesFulfilled = e);
            }, "e");
            var dylibsLoaded = !1;
            function run(e) {
              function t() {
                calledRun || (calledRun = !0, Module.calledRun = !0, ABORT || (initRuntime(), preMain(), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), shouldRunNow && callMain(e), postRun()));
              }
              __name(t, "t"), e = e || arguments_, runDependencies > 0 || !dylibsLoaded && (preloadDylibs(), dylibsLoaded = !0, runDependencies > 0) || (preRun(), runDependencies > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function () {
                setTimeout(function () {
                  Module.setStatus("");
                }, 1), t();
              }, 1)) : t()));
            }
            if (__name(run, "run"), Module.preInit) for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;) Module.preInit.pop()();
            var shouldRunNow = !0;
            Module.noInitialRun && (shouldRunNow = !1), run();
            let C = Module,
              INTERNAL = {},
              SIZE_OF_INT = 4,
              SIZE_OF_NODE = 5 * SIZE_OF_INT,
              SIZE_OF_POINT = 2 * SIZE_OF_INT,
              SIZE_OF_RANGE = 2 * SIZE_OF_INT + 2 * SIZE_OF_POINT,
              ZERO_POINT = {
                row: 0,
                column: 0
              },
              QUERY_WORD_REGEX = /[\w-.]*/g,
              PREDICATE_STEP_TYPE_CAPTURE = 1,
              PREDICATE_STEP_TYPE_STRING = 2,
              LANGUAGE_FUNCTION_REGEX = /^_?tree_sitter_\w+/;
            var VERSION, MIN_COMPATIBLE_VERSION, TRANSFER_BUFFER, currentParseCallback, currentLogCallback;
            class ParserImpl {
              static {
                __name(this, "ParserImpl");
              }
              static init() {
                TRANSFER_BUFFER = C._ts_init(), VERSION = getValue(TRANSFER_BUFFER, "i32"), MIN_COMPATIBLE_VERSION = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              initialize() {
                C._ts_parser_new_wasm(), this[0] = getValue(TRANSFER_BUFFER, "i32"), this[1] = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
              }
              delete() {
                C._ts_parser_delete(this[0]), C._free(this[1]), this[0] = 0, this[1] = 0;
              }
              setLanguage(e) {
                let t;
                if (e) {
                  if (e.constructor !== Language) throw new Error("Argument must be a Language");
                  {
                    t = e[0];
                    let r = C._ts_language_version(t);
                    if (r < MIN_COMPATIBLE_VERSION || VERSION < r) throw new Error(`Incompatible language version ${r}. Compatibility range ${MIN_COMPATIBLE_VERSION} through ${VERSION}.`);
                  }
                } else t = 0, e = null;
                return this.language = e, C._ts_parser_set_language(this[0], t), this;
              }
              getLanguage() {
                return this.language;
              }
              parse(e, t, r) {
                if (typeof e == "string") currentParseCallback = __name((t, r, _) => e.slice(t, _), "currentParseCallback");else {
                  if (typeof e != "function") throw new Error("Argument must be a string or a function");
                  currentParseCallback = e;
                }
                this.logCallback ? (currentLogCallback = this.logCallback, C._ts_parser_enable_logger_wasm(this[0], 1)) : (currentLogCallback = null, C._ts_parser_enable_logger_wasm(this[0], 0));
                let _ = 0,
                  n = 0;
                if (r && r.includedRanges) {
                  _ = r.includedRanges.length, n = C._calloc(_, SIZE_OF_RANGE);
                  let e = n;
                  for (let t = 0; t < _; t++) marshalRange(e, r.includedRanges[t]), e += SIZE_OF_RANGE;
                }
                let s = C._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, n, _);
                if (!s) throw currentParseCallback = null, currentLogCallback = null, new Error("Parsing failed");
                let a = new Tree(INTERNAL, s, this.language, currentParseCallback);
                return currentParseCallback = null, currentLogCallback = null, a;
              }
              reset() {
                C._ts_parser_reset(this[0]);
              }
              setTimeoutMicros(e) {
                C._ts_parser_set_timeout_micros(this[0], e);
              }
              getTimeoutMicros() {
                return C._ts_parser_timeout_micros(this[0]);
              }
              setLogger(e) {
                if (e) {
                  if (typeof e != "function") throw new Error("Logger callback must be a function");
                } else e = null;
                return this.logCallback = e, this;
              }
              getLogger() {
                return this.logCallback;
              }
            }
            class Tree {
              static {
                __name(this, "Tree");
              }
              constructor(e, t, r, _) {
                assertInternal(e), this[0] = t, this.language = r, this.textCallback = _;
              }
              copy() {
                let e = C._ts_tree_copy(this[0]);
                return new Tree(INTERNAL, e, this.language, this.textCallback);
              }
              delete() {
                C._ts_tree_delete(this[0]), this[0] = 0;
              }
              edit(e) {
                marshalEdit(e), C._ts_tree_edit_wasm(this[0]);
              }
              get rootNode() {
                return C._ts_tree_root_node_wasm(this[0]), unmarshalNode(this);
              }
              getLanguage() {
                return this.language;
              }
              walk() {
                return this.rootNode.walk();
              }
              getChangedRanges(e) {
                if (e.constructor !== Tree) throw new TypeError("Argument must be a Tree");
                C._ts_tree_get_changed_ranges_wasm(this[0], e[0]);
                let t = getValue(TRANSFER_BUFFER, "i32"),
                  r = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  _ = new Array(t);
                if (t > 0) {
                  let e = r;
                  for (let r = 0; r < t; r++) _[r] = unmarshalRange(e), e += SIZE_OF_RANGE;
                  C._free(r);
                }
                return _;
              }
            }
            class Node {
              static {
                __name(this, "Node");
              }
              constructor(e, t) {
                assertInternal(e), this.tree = t;
              }
              get typeId() {
                return marshalNode(this), C._ts_node_symbol_wasm(this.tree[0]);
              }
              get type() {
                return this.tree.language.types[this.typeId] || "ERROR";
              }
              get endPosition() {
                return marshalNode(this), C._ts_node_end_point_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get endIndex() {
                return marshalNode(this), C._ts_node_end_index_wasm(this.tree[0]);
              }
              get text() {
                return getText(this.tree, this.startIndex, this.endIndex);
              }
              isNamed() {
                return marshalNode(this), C._ts_node_is_named_wasm(this.tree[0]) === 1;
              }
              hasError() {
                return marshalNode(this), C._ts_node_has_error_wasm(this.tree[0]) === 1;
              }
              hasChanges() {
                return marshalNode(this), C._ts_node_has_changes_wasm(this.tree[0]) === 1;
              }
              isMissing() {
                return marshalNode(this), C._ts_node_is_missing_wasm(this.tree[0]) === 1;
              }
              equals(e) {
                return this.id === e.id;
              }
              child(e) {
                return marshalNode(this), C._ts_node_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              namedChild(e) {
                return marshalNode(this), C._ts_node_named_child_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              childForFieldId(e) {
                return marshalNode(this), C._ts_node_child_by_field_id_wasm(this.tree[0], e), unmarshalNode(this.tree);
              }
              childForFieldName(e) {
                let t = this.tree.language.fields.indexOf(e);
                if (t !== -1) return this.childForFieldId(t);
              }
              get childCount() {
                return marshalNode(this), C._ts_node_child_count_wasm(this.tree[0]);
              }
              get namedChildCount() {
                return marshalNode(this), C._ts_node_named_child_count_wasm(this.tree[0]);
              }
              get firstChild() {
                return this.child(0);
              }
              get firstNamedChild() {
                return this.namedChild(0);
              }
              get lastChild() {
                return this.child(this.childCount - 1);
              }
              get lastNamedChild() {
                return this.namedChild(this.namedChildCount - 1);
              }
              get children() {
                if (!this._children) {
                  marshalNode(this), C._ts_node_children_wasm(this.tree[0]);
                  let e = getValue(TRANSFER_BUFFER, "i32"),
                    t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  if (this._children = new Array(e), e > 0) {
                    let r = t;
                    for (let t = 0; t < e; t++) this._children[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                    C._free(t);
                  }
                }
                return this._children;
              }
              get namedChildren() {
                if (!this._namedChildren) {
                  marshalNode(this), C._ts_node_named_children_wasm(this.tree[0]);
                  let e = getValue(TRANSFER_BUFFER, "i32"),
                    t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32");
                  if (this._namedChildren = new Array(e), e > 0) {
                    let r = t;
                    for (let t = 0; t < e; t++) this._namedChildren[t] = unmarshalNode(this.tree, r), r += SIZE_OF_NODE;
                    C._free(t);
                  }
                }
                return this._namedChildren;
              }
              descendantsOfType(e, t, r) {
                Array.isArray(e) || (e = [e]), t || (t = ZERO_POINT), r || (r = ZERO_POINT);
                let _ = [],
                  n = this.tree.language.types;
                for (let t = 0, r = n.length; t < r; t++) e.includes(n[t]) && _.push(t);
                let s = C._malloc(SIZE_OF_INT * _.length);
                for (let e = 0, t = _.length; e < t; e++) setValue(s + e * SIZE_OF_INT, _[e], "i32");
                marshalNode(this), C._ts_node_descendants_of_type_wasm(this.tree[0], s, _.length, t.row, t.column, r.row, r.column);
                let a = getValue(TRANSFER_BUFFER, "i32"),
                  o = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  i = new Array(a);
                if (a > 0) {
                  let e = o;
                  for (let t = 0; t < a; t++) i[t] = unmarshalNode(this.tree, e), e += SIZE_OF_NODE;
                }
                return C._free(o), C._free(s), i;
              }
              get nextSibling() {
                return marshalNode(this), C._ts_node_next_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get previousSibling() {
                return marshalNode(this), C._ts_node_prev_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get nextNamedSibling() {
                return marshalNode(this), C._ts_node_next_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get previousNamedSibling() {
                return marshalNode(this), C._ts_node_prev_named_sibling_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              get parent() {
                return marshalNode(this), C._ts_node_parent_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              descendantForIndex(e, t = e) {
                if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              namedDescendantForIndex(e, t = e) {
                if (typeof e != "number" || typeof t != "number") throw new Error("Arguments must be numbers");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return setValue(r, e, "i32"), setValue(r + SIZE_OF_INT, t, "i32"), C._ts_node_named_descendant_for_index_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              descendantForPosition(e, t = e) {
                if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              namedDescendantForPosition(e, t = e) {
                if (!isPoint(e) || !isPoint(t)) throw new Error("Arguments must be {row, column} objects");
                marshalNode(this);
                let r = TRANSFER_BUFFER + SIZE_OF_NODE;
                return marshalPoint(r, e), marshalPoint(r + SIZE_OF_POINT, t), C._ts_node_named_descendant_for_position_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              walk() {
                return marshalNode(this), C._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(INTERNAL, this.tree);
              }
              toString() {
                marshalNode(this);
                let e = C._ts_node_to_string_wasm(this.tree[0]),
                  t = AsciiToString(e);
                return C._free(e), t;
              }
            }
            class TreeCursor {
              static {
                __name(this, "TreeCursor");
              }
              constructor(e, t) {
                assertInternal(e), this.tree = t, unmarshalTreeCursor(this);
              }
              delete() {
                marshalTreeCursor(this), C._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
              }
              reset(e) {
                marshalNode(e), marshalTreeCursor(this, TRANSFER_BUFFER + SIZE_OF_NODE), C._ts_tree_cursor_reset_wasm(this.tree[0]), unmarshalTreeCursor(this);
              }
              get nodeType() {
                return this.tree.language.types[this.nodeTypeId] || "ERROR";
              }
              get nodeTypeId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
              }
              get nodeId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
              }
              get nodeIsNamed() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
              }
              get nodeIsMissing() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
              }
              get nodeText() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_start_index_wasm(this.tree[0]),
                  t = C._ts_tree_cursor_end_index_wasm(this.tree[0]);
                return getText(this.tree, e, t);
              }
              get startPosition() {
                return marshalTreeCursor(this), C._ts_tree_cursor_start_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get endPosition() {
                return marshalTreeCursor(this), C._ts_tree_cursor_end_position_wasm(this.tree[0]), unmarshalPoint(TRANSFER_BUFFER);
              }
              get startIndex() {
                return marshalTreeCursor(this), C._ts_tree_cursor_start_index_wasm(this.tree[0]);
              }
              get endIndex() {
                return marshalTreeCursor(this), C._ts_tree_cursor_end_index_wasm(this.tree[0]);
              }
              currentNode() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_node_wasm(this.tree[0]), unmarshalNode(this.tree);
              }
              currentFieldId() {
                return marshalTreeCursor(this), C._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
              }
              currentFieldName() {
                return this.tree.language.fields[this.currentFieldId()];
              }
              gotoFirstChild() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
              gotoNextSibling() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
              gotoParent() {
                marshalTreeCursor(this);
                let e = C._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                return unmarshalTreeCursor(this), e === 1;
              }
            }
            class Language {
              static {
                __name(this, "Language");
              }
              constructor(e, t) {
                assertInternal(e), this[0] = t, this.types = new Array(C._ts_language_symbol_count(this[0]));
                for (let e = 0, t = this.types.length; e < t; e++) C._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = UTF8ToString(C._ts_language_symbol_name(this[0], e)));
                this.fields = new Array(C._ts_language_field_count(this[0]) + 1);
                for (let e = 0, t = this.fields.length; e < t; e++) {
                  let t = C._ts_language_field_name_for_id(this[0], e);
                  this.fields[e] = t !== 0 ? UTF8ToString(t) : null;
                }
              }
              get version() {
                return C._ts_language_version(this[0]);
              }
              get fieldCount() {
                return this.fields.length - 1;
              }
              fieldIdForName(e) {
                let t = this.fields.indexOf(e);
                return t !== -1 ? t : null;
              }
              fieldNameForId(e) {
                return this.fields[e] || null;
              }
              idForNodeType(e, t) {
                let r = lengthBytesUTF8(e),
                  _ = C._malloc(r + 1);
                stringToUTF8(e, _, r + 1);
                let n = C._ts_language_symbol_for_name(this[0], _, r, t);
                return C._free(_), n || null;
              }
              get nodeTypeCount() {
                return C._ts_language_symbol_count(this[0]);
              }
              nodeTypeForId(e) {
                let t = C._ts_language_symbol_name(this[0], e);
                return t ? UTF8ToString(t) : null;
              }
              nodeTypeIsNamed(e) {
                return !!C._ts_language_type_is_named_wasm(this[0], e);
              }
              nodeTypeIsVisible(e) {
                return !!C._ts_language_type_is_visible_wasm(this[0], e);
              }
              query(e) {
                let t = lengthBytesUTF8(e),
                  r = C._malloc(t + 1);
                stringToUTF8(e, r, t + 1);
                let _ = C._ts_query_new(this[0], r, t, TRANSFER_BUFFER, TRANSFER_BUFFER + SIZE_OF_INT);
                if (!_) {
                  let t = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                    _ = UTF8ToString(r, getValue(TRANSFER_BUFFER, "i32")).length,
                    n = e.substr(_, 100).split(`
`)[0],
                    s,
                    a = n.match(QUERY_WORD_REGEX)[0];
                  switch (t) {
                    case 2:
                      s = new RangeError(`Bad node name '${a}'`);
                      break;
                    case 3:
                      s = new RangeError(`Bad field name '${a}'`);
                      break;
                    case 4:
                      s = new RangeError(`Bad capture name @${a}`);
                      break;
                    case 5:
                      s = new TypeError(`Bad pattern structure at offset ${_}: '${n}'...`), a = "";
                      break;
                    default:
                      s = new SyntaxError(`Bad syntax at offset ${_}: '${n}'...`), a = "";
                  }
                  throw s.index = _, s.length = a.length, C._free(r), s;
                }
                let n = C._ts_query_string_count(_),
                  s = C._ts_query_capture_count(_),
                  a = C._ts_query_pattern_count(_),
                  o = new Array(s),
                  i = new Array(n);
                for (let e = 0; e < s; e++) {
                  let t = C._ts_query_capture_name_for_id(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  o[e] = UTF8ToString(t, r);
                }
                for (let e = 0; e < n; e++) {
                  let t = C._ts_query_string_value_for_id(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  i[e] = UTF8ToString(t, r);
                }
                let l = new Array(a),
                  u = new Array(a),
                  d = new Array(a),
                  c = new Array(a),
                  m = new Array(a);
                for (let e = 0; e < a; e++) {
                  let t = C._ts_query_predicates_for_pattern(_, e, TRANSFER_BUFFER),
                    r = getValue(TRANSFER_BUFFER, "i32");
                  c[e] = [], m[e] = [];
                  let n = [],
                    s = t;
                  for (let t = 0; t < r; t++) {
                    let t = getValue(s, "i32");
                    s += SIZE_OF_INT;
                    let r = getValue(s, "i32");
                    if (s += SIZE_OF_INT, t === PREDICATE_STEP_TYPE_CAPTURE) n.push({
                      type: "capture",
                      name: o[r]
                    });else if (t === PREDICATE_STEP_TYPE_STRING) n.push({
                      type: "string",
                      value: i[r]
                    });else if (n.length > 0) {
                      if (n[0].type !== "string") throw new Error("Predicates must begin with a literal value");
                      let t = n[0].value,
                        r = !0;
                      switch (t) {
                        case "not-eq?":
                          r = !1;
                        case "eq?":
                          if (n.length !== 3) throw new Error("Wrong number of arguments to `#eq?` predicate. Expected 2, got " + (n.length - 1));
                          if (n[1].type !== "capture") throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${n[1].value}"`);
                          if (n[2].type === "capture") {
                            let t = n[1].name,
                              _ = n[2].name;
                            m[e].push(function (e) {
                              let n, s;
                              for (let r of e) r.name === t && (n = r.node), r.name === _ && (s = r.node);
                              return n === void 0 || s === void 0 || n.text === s.text === r;
                            });
                          } else {
                            let t = n[1].name,
                              _ = n[2].value;
                            m[e].push(function (e) {
                              for (let n of e) if (n.name === t) return n.node.text === _ === r;
                              return !0;
                            });
                          }
                          break;
                        case "not-match?":
                          r = !1;
                        case "match?":
                          if (n.length !== 3) throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${n.length - 1}.`);
                          if (n[1].type !== "capture") throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${n[1].value}".`);
                          if (n[2].type !== "string") throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${n[2].value}.`);
                          let _ = n[1].name,
                            s = new RegExp(n[2].value);
                          m[e].push(function (e) {
                            for (let t of e) if (t.name === _) return s.test(t.node.text) === r;
                            return !0;
                          });
                          break;
                        case "set!":
                          if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                          if (n.some(e => e.type !== "string")) throw new Error('Arguments to `#set!` predicate must be a strings.".');
                          l[e] || (l[e] = {}), l[e][n[1].value] = n[2] ? n[2].value : null;
                          break;
                        case "is?":
                        case "is-not?":
                          if (n.length < 2 || n.length > 3) throw new Error(`Wrong number of arguments to \`#${t}\` predicate. Expected 1 or 2. Got ${n.length - 1}.`);
                          if (n.some(e => e.type !== "string")) throw new Error(`Arguments to \`#${t}\` predicate must be a strings.".`);
                          let a = t === "is?" ? u : d;
                          a[e] || (a[e] = {}), a[e][n[1].value] = n[2] ? n[2].value : null;
                          break;
                        default:
                          c[e].push({
                            operator: t,
                            operands: n.slice(1)
                          });
                      }
                      n.length = 0;
                    }
                  }
                  Object.freeze(l[e]), Object.freeze(u[e]), Object.freeze(d[e]);
                }
                return C._free(r), new Query(INTERNAL, _, o, m, c, Object.freeze(l), Object.freeze(u), Object.freeze(d));
              }
              static load(e) {
                let t;
                if (e instanceof Uint8Array) t = Promise.resolve(e);else {
                  let r = e;
                  if (typeof process < "u" && process.versions && process.versions.node) {
                    let e = require("fs");
                    t = Promise.resolve(e.readFileSync(r));
                  } else t = fetch(r).then(e => e.arrayBuffer().then(t => {
                    if (e.ok) return new Uint8Array(t);
                    {
                      let r = new TextDecoder("utf-8").decode(t);
                      throw new Error(`Language.load failed with status ${e.status}.

${r}`);
                    }
                  }));
                }
                let r = typeof loadSideModule == "function" ? loadSideModule : loadWebAssemblyModule;
                return t.then(e => r(e, {
                  loadAsync: !0
                })).then(e => {
                  let t = Object.keys(e),
                    r = t.find(e => LANGUAGE_FUNCTION_REGEX.test(e) && !e.includes("external_scanner_"));
                  r || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t, null, 2)}`);
                  let _ = e[r]();
                  return new Language(INTERNAL, _);
                });
              }
            }
            class Query {
              static {
                __name(this, "Query");
              }
              constructor(e, t, r, _, n, s, a, o) {
                assertInternal(e), this[0] = t, this.captureNames = r, this.textPredicates = _, this.predicates = n, this.setProperties = s, this.assertedProperties = a, this.refutedProperties = o, this.exceededMatchLimit = !1;
              }
              delete() {
                C._ts_query_delete(this[0]), this[0] = 0;
              }
              matches(e, t, r, _) {
                t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                let n = _.matchLimit;
                if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                marshalNode(e), C._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                let s = getValue(TRANSFER_BUFFER, "i32"),
                  a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                  i = new Array(s);
                this.exceededMatchLimit = !!o;
                let l = 0,
                  u = a;
                for (let t = 0; t < s; t++) {
                  let r = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let _ = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let n = new Array(_);
                  if (u = unmarshalCaptures(this, e.tree, u, n), this.textPredicates[r].every(e => e(n))) {
                    i[l++] = {
                      pattern: r,
                      captures: n
                    };
                    let e = this.setProperties[r];
                    e && (i[t].setProperties = e);
                    let _ = this.assertedProperties[r];
                    _ && (i[t].assertedProperties = _);
                    let s = this.refutedProperties[r];
                    s && (i[t].refutedProperties = s);
                  }
                }
                return i.length = l, C._free(a), i;
              }
              captures(e, t, r, _) {
                t || (t = ZERO_POINT), r || (r = ZERO_POINT), _ || (_ = {});
                let n = _.matchLimit;
                if (n === void 0) n = 0;else if (typeof n != "number") throw new Error("Arguments must be numbers");
                marshalNode(e), C._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, r.row, r.column, n);
                let s = getValue(TRANSFER_BUFFER, "i32"),
                  a = getValue(TRANSFER_BUFFER + SIZE_OF_INT, "i32"),
                  o = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32"),
                  i = [];
                this.exceededMatchLimit = !!o;
                let l = [],
                  u = a;
                for (let t = 0; t < s; t++) {
                  let t = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let r = getValue(u, "i32");
                  u += SIZE_OF_INT;
                  let _ = getValue(u, "i32");
                  if (u += SIZE_OF_INT, l.length = r, u = unmarshalCaptures(this, e.tree, u, l), this.textPredicates[t].every(e => e(l))) {
                    let e = l[_],
                      r = this.setProperties[t];
                    r && (e.setProperties = r);
                    let n = this.assertedProperties[t];
                    n && (e.assertedProperties = n);
                    let s = this.refutedProperties[t];
                    s && (e.refutedProperties = s), i.push(e);
                  }
                }
                return C._free(a), i;
              }
              predicatesForPattern(e) {
                return this.predicates[e];
              }
              didExceedMatchLimit() {
                return this.exceededMatchLimit;
              }
            }
            function getText(e, t, r) {
              let _ = r - t,
                n = e.textCallback(t, null, r);
              for (t += n.length; t < r;) {
                let _ = e.textCallback(t, null, r);
                if (!(_ && _.length > 0)) break;
                t += _.length, n += _;
              }
              return t > r && (n = n.slice(0, _)), n;
            }
            __name(getText, "getText");
            function unmarshalCaptures(e, t, r, _) {
              for (let n = 0, s = _.length; n < s; n++) {
                let s = getValue(r, "i32"),
                  a = unmarshalNode(t, r += SIZE_OF_INT);
                r += SIZE_OF_NODE, _[n] = {
                  name: e.captureNames[s],
                  node: a
                };
              }
              return r;
            }
            __name(unmarshalCaptures, "unmarshalCaptures");
            function assertInternal(e) {
              if (e !== INTERNAL) throw new Error("Illegal constructor");
            }
            __name(assertInternal, "assertInternal");
            function isPoint(e) {
              return e && typeof e.row == "number" && typeof e.column == "number";
            }
            __name(isPoint, "isPoint");
            function marshalNode(e) {
              let t = TRANSFER_BUFFER;
              setValue(t, e.id, "i32"), t += SIZE_OF_INT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.row, "i32"), t += SIZE_OF_INT, setValue(t, e.startPosition.column, "i32"), t += SIZE_OF_INT, setValue(t, e[0], "i32");
            }
            __name(marshalNode, "marshalNode");
            function unmarshalNode(e, t = TRANSFER_BUFFER) {
              let r = getValue(t, "i32");
              if (r === 0) return null;
              let _ = getValue(t += SIZE_OF_INT, "i32"),
                n = getValue(t += SIZE_OF_INT, "i32"),
                s = getValue(t += SIZE_OF_INT, "i32"),
                a = getValue(t += SIZE_OF_INT, "i32"),
                o = new Node(INTERNAL, e);
              return o.id = r, o.startIndex = _, o.startPosition = {
                row: n,
                column: s
              }, o[0] = a, o;
            }
            __name(unmarshalNode, "unmarshalNode");
            function marshalTreeCursor(e, t = TRANSFER_BUFFER) {
              setValue(t + 0 * SIZE_OF_INT, e[0], "i32"), setValue(t + 1 * SIZE_OF_INT, e[1], "i32"), setValue(t + 2 * SIZE_OF_INT, e[2], "i32");
            }
            __name(marshalTreeCursor, "marshalTreeCursor");
            function unmarshalTreeCursor(e) {
              e[0] = getValue(TRANSFER_BUFFER + 0 * SIZE_OF_INT, "i32"), e[1] = getValue(TRANSFER_BUFFER + 1 * SIZE_OF_INT, "i32"), e[2] = getValue(TRANSFER_BUFFER + 2 * SIZE_OF_INT, "i32");
            }
            __name(unmarshalTreeCursor, "unmarshalTreeCursor");
            function marshalPoint(e, t) {
              setValue(e, t.row, "i32"), setValue(e + SIZE_OF_INT, t.column, "i32");
            }
            __name(marshalPoint, "marshalPoint");
            function unmarshalPoint(e) {
              return {
                row: getValue(e, "i32"),
                column: getValue(e + SIZE_OF_INT, "i32")
              };
            }
            __name(unmarshalPoint, "unmarshalPoint");
            function marshalRange(e, t) {
              marshalPoint(e, t.startPosition), marshalPoint(e += SIZE_OF_POINT, t.endPosition), setValue(e += SIZE_OF_POINT, t.startIndex, "i32"), setValue(e += SIZE_OF_INT, t.endIndex, "i32"), e += SIZE_OF_INT;
            }
            __name(marshalRange, "marshalRange");
            function unmarshalRange(e) {
              let t = {};
              return t.startPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.endPosition = unmarshalPoint(e), e += SIZE_OF_POINT, t.startIndex = getValue(e, "i32"), e += SIZE_OF_INT, t.endIndex = getValue(e, "i32"), t;
            }
            __name(unmarshalRange, "unmarshalRange");
            function marshalEdit(e) {
              let t = TRANSFER_BUFFER;
              marshalPoint(t, e.startPosition), t += SIZE_OF_POINT, marshalPoint(t, e.oldEndPosition), t += SIZE_OF_POINT, marshalPoint(t, e.newEndPosition), t += SIZE_OF_POINT, setValue(t, e.startIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.oldEndIndex, "i32"), t += SIZE_OF_INT, setValue(t, e.newEndIndex, "i32"), t += SIZE_OF_INT;
            }
            __name(marshalEdit, "marshalEdit");
            for (let e of Object.getOwnPropertyNames(ParserImpl.prototype)) Object.defineProperty(Parser.prototype, e, {
              value: ParserImpl.prototype[e],
              enumerable: !1,
              writable: !1
            });
            Parser.Language = Language, Module.onRuntimeInitialized = () => {
              ParserImpl.init(), resolveInitPromise();
            };
          }));
        }
      }
      return Parser;
    }();
  typeof exports == "object" && (module.exports = TreeSitter);
});
function isSupportedLanguageId(languageId) {
  return languageId in languageIdToWasmLanguageMapping;
}
function languageIdToWasmLanguage(languageId) {
  if (!(languageId in languageIdToWasmLanguageMapping)) throw new Error(`Unrecognized language: ${languageId}`);
  return languageIdToWasmLanguageMapping[languageId];
}
async function loadWasmLanguage(language) {
  await db.Parser.init();
  let wasmFile = (0, Mte.resolve)(__dirname, "..", "dist", `tree-sitter-${language}.wasm`);
  try {
    return db.Parser.Language.load(wasmFile);
  } catch (e) {
    if ((e.code === "ENOENT" || e.code === "EIO" || e.code === "EACCES" || e.code == "EPERM") && e instanceof Error) {
      let error = new Error(`Could not load tree-sitter-${language}.wasm`);
      throw error.code = "CopilotPromptLoadFailure", error;
    }
    throw e;
  }
}
async function getLanguage(language) {
  let wasmLanguage = languageIdToWasmLanguage(language);
  if (!loadedLanguages.has(wasmLanguage)) {
    let loadedLang = await loadWasmLanguage(wasmLanguage);
    loadedLanguages.set(wasmLanguage, loadedLang);
  }
  return loadedLanguages.get(wasmLanguage);
}
async function parseTreeSitter(language, source) {
  let treeSitterLanguage = await getLanguage(language),
    parser = new db.Parser();
  parser.setLanguage(treeSitterLanguage);
  let parsedTree = parser.parse(source);
  return parser.delete(), parsedTree;
}
async function parsesWithoutError(language, source) {
  let tree = await parseTreeSitter(language, source),
    result = !tree.rootNode.hasError();
  return tree.delete(), result;
}
function getBlockCloseToken(language) {
  switch (languageIdToWasmLanguage(language)) {
    case "python":
      return null;
    case "javascript":
    case "typescript":
    case "tsx":
    case "go":
      return "}";
    case "ruby":
      return "end";
  }
}
function innerQuery(queries, root) {
  let matches = [];
  for (let query of queries) {
    if (!query[1]) {
      let lang = root.tree.getLanguage();
      query[1] = lang.query(query[0]);
    }
    matches.push(...query[1].matches(root));
  }
  return matches;
}
function queryFunctions(language, root) {
  let queries = functionQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryImports(language, root) {
  let queries = importsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryExports(language, root) {
  let queries = exportsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryGlobalVars(language, root) {
  let queries = globalVarsQuery[languageIdToWasmLanguage(language)];
  return innerQuery(queries, root);
}
function queryPythonIsDocstring(blockNode) {
  return innerQuery([docstringQuery], blockNode).length == 1;
}
function getAncestorWithSiblingFunctions(language, nd) {
  let check = isFunctionParent[languageIdToWasmLanguage(language)];
  for (; nd.parent;) {
    if (check(nd.parent)) return nd;
    nd = nd.parent;
  }
  return nd.parent ? nd : null;
}
function isFunction(language, nd) {
  return functionTypes[languageIdToWasmLanguage(language)].has(nd.type);
}
function isFunctionDefinition(language, nd) {
  switch (languageIdToWasmLanguage(language)) {
    case "python":
    case "go":
    case "ruby":
      return isFunction(language, nd);
    case "javascript":
    case "typescript":
    case "tsx":
      if (nd.type === "function_declaration" || nd.type === "generator_function_declaration" || nd.type === "method_definition") return !0;
      if (nd.type === "lexical_declaration" || nd.type === "variable_declaration") {
        if (nd.namedChildCount > 1) return !1;
        let declarator = nd.namedChild(0);
        if (declarator == null) return !1;
        let init = declarator.namedChild(1);
        return init !== null && isFunction(language, init);
      }
      if (nd.type === "expression_statement") {
        let expr = nd.namedChild(0);
        if (expr?.type === "assignment_expression") {
          let rhs = expr.namedChild(1);
          return rhs !== null && isFunction(language, rhs);
        }
      }
      return !1;
  }
}
function getFirstPrecedingComment(nd) {
  let cur = nd;
  for (; cur.previousSibling?.type === "comment";) {
    let prev = cur.previousSibling;
    if (prev.endPosition.row < cur.startPosition.row - 1) break;
    cur = prev;
  }
  return cur?.type === "comment" ? cur : null;
}
async function getFunctionPositions(language, source) {
  let tree = await parseTreeSitter(language, source),
    positions = queryFunctions(language, tree.rootNode).map(res => {
      let fn = res.captures.find(c => c.name === "function").node;
      return {
        startIndex: fn.startIndex,
        endIndex: fn.endIndex
      };
    });
  return tree.delete(), positions;
}
async function getCallSites(docInfo) {
  if (!(docInfo.languageId in callSiteQuery)) return [];
  let offset = docInfo.offset,
    source = docInfo.source.substring(0, offset),
    pretruncateOffset = Math.max(source.length - 5e3, 0),
    linesBeforeTruncation = source.substring(0, pretruncateOffset).split(`
`).length - 1;
  offset -= pretruncateOffset, source = source.substring(pretruncateOffset), source = source + ")))))";
  let callers = [],
    tree = await parseTreeSitter(docInfo.languageId, source),
    queries = callSiteQuery[languageIdToWasmLanguageMapping[docInfo.languageId]];
  return innerQuery(queries, tree.rootNode).forEach((res, resIndex) => {
    let callerName = "",
      callerLineNo = 0,
      callerStartChar = 0,
      argsStartIndex = 0,
      argsEndIndex = 0;
    if (res.captures.forEach((cap, capIndex) => {
      let node = cap.node;
      cap.name == "caller" ? (callerName = source.substring(node.startIndex, node.endIndex), callerLineNo = node.startPosition.row + linesBeforeTruncation, callerStartChar = node.startPosition.column) : cap.name == "args" && (argsStartIndex = node.startIndex, argsEndIndex = node.endIndex);
    }), offset >= argsStartIndex && offset <= argsEndIndex) {
      let callerLineCol = {
        line: callerLineNo,
        character: callerStartChar
      };
      callers.push([callerName, callerLineCol]);
    }
  }), tree.delete(), callers.map(([name, position]) => ({
    name: name,
    position: position
  }));
}
var import_path,
  import_web_tree_sitter,
  WASMLanguage,
  languageIdToWasmLanguageMapping,
  jsFunctionQuery,
  functionQuery,
  requireCall,
  declaratorWithRequire,
  commonJsImport,
  tsImportQueries,
  importsQuery,
  jsExportQueries,
  exportsQuery,
  globalVarsQuery,
  jsFunctionTypes,
  functionTypes,
  isFunctionParent,
  loadedLanguages,
  docstringQuery,
  callSiteQuery,
  init_parse = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_web_tree_sitter = Ns(Ote()), WASMLanguage = (o => (WASMLanguage.Python = "python", WASMLanguage.JavaScript = "javascript", WASMLanguage.TypeScript = "typescript", WASMLanguage.TSX = "tsx", WASMLanguage.Go = "go", WASMLanguage.Ruby = "ruby", WASMLanguage))(Bte || {}), languageIdToWasmLanguageMapping = {
      python: "python",
      javascript: "javascript",
      javascriptreact: "javascript",
      jsx: "javascript",
      typescript: "typescript",
      typescriptreact: "tsx",
      go: "go",
      ruby: "ruby"
    };
    __name(isSupportedLanguageId, "isSupportedLanguageId");
    __name(languageIdToWasmLanguage, "languageIdToWasmLanguage");
    jsFunctionQuery = `[
    (function body: (statement_block) @body)
    (function_declaration body: (statement_block) @body)
    (generator_function body: (statement_block) @body)
    (generator_function_declaration body: (statement_block) @body)
    (method_definition body: (statement_block) @body)
    (arrow_function body: (statement_block) @body)
  ] @function`, functionQuery = {
      python: [[`(function_definition body: (block
             (expression_statement (string))? @docstring) @body) @function`], ['(ERROR ("def" (identifier) (parameters))) @function']],
      javascript: [[jsFunctionQuery]],
      typescript: [[jsFunctionQuery]],
      tsx: [[jsFunctionQuery]],
      go: [[`[
            (function_declaration body: (block) @body)
            (method_declaration body: (block) @body)
          ] @function`]],
      ruby: [[`[
            (method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ "end"] @body)
          ] @function`]]
    }, requireCall = '(call_expression function: ((identifier) @req (#eq? @req "require")))', declaratorWithRequire = `(variable_declarator value: ${requireCall})`, commonJsImport = `
    (lexical_declaration ${declaratorWithRequire}+)
    (variable_declaration ${declaratorWithRequire}+)
`, tsImportQueries = [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) (import_alias) ] @import)"]], importsQuery = {
      python: [["(module (future_import_statement) @import)"], ["(module (import_statement) @import)"], ["(module (import_from_statement) @import)"]],
      javascript: [[`(program [ ${commonJsImport} ] @import)`], ["(program [ (import_statement) ] @import)"]],
      typescript: tsImportQueries,
      tsx: tsImportQueries,
      go: [],
      ruby: []
    }, jsExportQueries = [["(program (export_statement) @export)"]], exportsQuery = {
      python: [],
      javascript: jsExportQueries,
      typescript: jsExportQueries,
      tsx: jsExportQueries,
      go: [],
      ruby: []
    }, globalVarsQuery = {
      python: [["(module (global_statement) @globalVar)"], ["(module (expression_statement) @globalVar)"]],
      javascript: [],
      typescript: [],
      tsx: [],
      go: [],
      ruby: []
    }, jsFunctionTypes = ["function", "function_declaration", "generator_function", "generator_function_declaration", "method_definition", "arrow_function"], functionTypes = {
      python: new Set(["function_definition"]),
      javascript: new Set(jsFunctionTypes),
      typescript: new Set(jsFunctionTypes),
      tsx: new Set(jsFunctionTypes),
      go: new Set(["function_declaration", "method_declaration"]),
      ruby: new Set(["method", "singleton_method"])
    }, isFunctionParent = {
      python: nd => nd.type === "module" || nd.type === "block" && nd.parent?.type === "class_definition",
      javascript: nd => nd.type === "program" || nd.type === "class_body",
      typescript: nd => nd.type === "program" || nd.type === "class_body",
      tsx: nd => nd.type === "program" || nd.type === "class_body",
      go: nd => nd.type === "source_file",
      ruby: nd => nd.type === "program" || nd.type === "class"
    }, loadedLanguages = new Map();
    __name(loadWasmLanguage, "loadWasmLanguage");
    __name(getLanguage, "getLanguage");
    __name(parseTreeSitter, "parseTreeSitter");
    __name(parsesWithoutError, "parsesWithoutError");
    __name(getBlockCloseToken, "getBlockCloseToken");
    __name(innerQuery, "innerQuery");
    __name(queryFunctions, "queryFunctions");
    __name(queryImports, "queryImports");
    __name(queryExports, "queryExports");
    __name(queryGlobalVars, "queryGlobalVars");
    docstringQuery = [`[
    (class_definition (block (expression_statement (string))))
    (function_definition (block (expression_statement (string))))
]`];
    __name(queryPythonIsDocstring, "queryPythonIsDocstring");
    __name(getAncestorWithSiblingFunctions, "getAncestorWithSiblingFunctions");
    __name(isFunction, "isFunction");
    __name(isFunctionDefinition, "isFunctionDefinition");
    __name(getFirstPrecedingComment, "getFirstPrecedingComment");
    __name(getFunctionPositions, "getFunctionPositions");
    callSiteQuery = {
      python: [[`(call
            function:  [
                (identifier) @caller
                (attribute attribute:(identifier) @caller)
            ]
            arguments: (argument_list) @args
        )`]],
      javascript: [],
      tsx: [],
      typescript: [],
      go: [],
      ruby: []
    };
    __name(getCallSites, "getCallSites");
  });
async function getSiblingFunctionStart({
  source: source,
  offset: offset,
  languageId: languageId
}) {
  if (isSupportedLanguageId(languageId)) {
    let tree = await parseTreeSitter(languageId, source);
    try {
      let startingOffset = offset;
      for (; startingOffset >= 0 && /\s/.test(source[startingOffset]);) startingOffset--;
      let nd = tree.rootNode.descendantForIndex(startingOffset),
        anc = getAncestorWithSiblingFunctions(languageId, nd);
      if (anc) {
        for (let sibling = anc.nextSibling; sibling; sibling = sibling.nextSibling) if (isFunctionDefinition(languageId, sibling)) {
          let startIndex = getFirstPrecedingComment(sibling)?.startIndex ?? sibling.startIndex;
          if (startIndex < offset) continue;
          return startIndex;
        }
        if (anc.endIndex >= offset) return anc.endIndex;
      }
    } finally {
      tree.delete();
    }
  }
  return offset;
}
var init_siblingFunctions = __esmMin(() => {
  "use strict";

  init_parse();
  __name(getSiblingFunctionStart, "getSiblingFunctionStart");
});
function cursorContextOptions(options) {
  return {
    ...defaultCursorContextOptions,
    ...options
  };
}
function getCursorContext(doc, options = {}) {
  let completeOptions = cursorContextOptions(options),
    tokenizer = getTokenizer(completeOptions.tokenizerName);
  if (completeOptions.maxLineCount !== void 0 && completeOptions.maxLineCount < 0) throw new Error("maxLineCount must be non-negative if defined");
  if (completeOptions.maxTokenLength !== void 0 && completeOptions.maxTokenLength < 0) throw new Error("maxTokenLength must be non-negative if defined");
  if (completeOptions.maxLineCount === 0 || completeOptions.maxTokenLength === 0) return {
    context: "",
    lineCount: 0,
    tokenLength: 0,
    tokenizerName: completeOptions.tokenizerName
  };
  let context = doc.source.slice(0, doc.offset);
  return completeOptions.maxLineCount !== void 0 && (context = context.split(`
`).slice(-completeOptions.maxLineCount).join(`
`)), completeOptions.maxTokenLength !== void 0 && (context = tokenizer.takeLastLinesTokens(context, completeOptions.maxTokenLength)), {
    context: context,
    lineCount: context.split(`
`).length,
    tokenLength: tokenizer.tokenLength(context),
    tokenizerName: completeOptions.tokenizerName
  };
}
var defaultCursorContextOptions,
  init_cursorContext = __esmMin(() => {
    "use strict";

    init_tokenization();
    defaultCursorContextOptions = {
      tokenizerName: "cl100k"
    };
    __name(cursorContextOptions, "cursorContextOptions");
    __name(getCursorContext, "getCursorContext");
  });
function announceSnippet(snippet, targetDocLanguageId) {
  let semantics = snippetSemanticsToString[snippet.semantics],
    headlinedSnippet = (snippet.relativePath ? `Compare this ${semantics} from ${snippet.relativePath}:` : `Compare this ${semantics}:`) + `
` + snippet.snippet;
  return headlinedSnippet.endsWith(`
`) || (headlinedSnippet += `
`), commentBlockAsSingles(headlinedSnippet, targetDocLanguageId);
}
function normalizeSnippetScore(snippet, providerOptions) {
  let options = providerOptions[snippet.provider];
  if (!options) throw new Error("Unknown snippet provider: " + snippet.provider);
  let {
      score: providerScore,
      ...snippetRem
    } = snippet,
    normalizedScore = providerScore;
  if (options.normalizationFunction === "affine") {
    let [a, b] = options.normalizationParams;
    normalizedScore = a * providerScore + b;
  } else throw new Error(`Unknown normalization function ${options.normalizationFunction} for snippet provider ${snippet.provider}`);
  return {
    ...snippetRem,
    providerScore: providerScore,
    normalizedScore: normalizedScore
  };
}
function sortSnippetsDescending(snippets) {
  snippets.sort((a, b) => b.normalizedScore - a.normalizedScore);
}
function selectSnippets(snippets, numberOfSnippets, providerOptions) {
  if (numberOfSnippets == 0) return {
    reserved: [],
    candidates: []
  };
  let normalizedSnippets = snippets.map(snippet => normalizeSnippetScore(snippet, providerOptions)),
    snippetsByProvider = new Map(),
    provider;
  for (provider in providerOptions) snippetsByProvider.set(provider, []);
  for (let snippet of normalizedSnippets) {
    let snippets = snippetsByProvider.get(snippet.provider);
    if (!snippets) throw new Error("Unknown snippet provider: " + snippet.provider);
    snippets.push(snippet);
  }
  for (let [_provider, snippets] of snippetsByProvider) sortSnippetsDescending(snippets);
  let reserved = [];
  for (provider in providerOptions) {
    let count = providerOptions[provider].reservedSnippetCount || 0;
    if (count > 0) {
      let snippets = snippetsByProvider.get(provider) || [];
      reserved = reserved.concat(snippets.slice(0, count)), snippetsByProvider.set(provider, snippets.slice(count));
    }
  }
  sortSnippetsDescending(reserved);
  let candidates = [];
  if (reserved.length > numberOfSnippets) throw new Error("Reserved snippet count exceeds number of snippets");
  if (reserved.length < numberOfSnippets) {
    let remaining = Array.from(snippetsByProvider.values()).flat();
    sortSnippetsDescending(remaining), candidates = remaining.slice(0, numberOfSnippets - reserved.length);
  }
  return {
    reserved: reserved,
    candidates: candidates
  };
}
function processSnippetsForWishlist(snippets, targetDocLanguageId, tokenizer, providerOptions, priorities, totalPrioritized, highPriorityBudget) {
  let {
      reserved: reserved,
      candidates: candidates
    } = selectSnippets(snippets, totalPrioritized, providerOptions),
    usedBudget = 0,
    processedSnippets = [],
    nextHighPriority = priorities.high,
    nextLowPriority = priorities.low;
  function process(snippet, usedBudget) {
    let announced = announceSnippet(snippet, targetDocLanguageId),
      tokens = tokenizer.tokenLength(announced),
      priority;
    return usedBudget + tokens <= highPriorityBudget ? (priority = nextHighPriority, nextHighPriority = priorities.priorities.justBelow(priority)) : (priority = nextLowPriority, nextLowPriority = priorities.priorities.justBelow(priority)), processedSnippets.push({
      announcedSnippet: announced,
      provider: snippet.provider,
      providerScore: snippet.providerScore,
      normalizedScore: snippet.normalizedScore,
      priority: priority,
      tokens: tokens,
      relativePath: snippet.relativePath
    }), usedBudget + tokens;
  }
  __name(process, "process");
  for (let snippet of [...reserved, ...candidates]) {
    if (processedSnippets.length >= totalPrioritized) break;
    usedBudget = process(snippet, usedBudget);
  }
  return sortSnippetsDescending(processedSnippets), processedSnippets.reverse(), processedSnippets;
}
var SnippetProviderType,
  SnippetSemantics,
  snippetSemanticsToString,
  init_snippets = __esmMin(() => {
    "use strict";

    init_languageMarker();
    SnippetProviderType = (o => (SnippetProviderType.NeighboringTabs = "neighboring-tabs", SnippetProviderType.Retrieval = "retrieval", SnippetProviderType.SymbolDef = "symbol-def", SnippetProviderType.Language = "language", SnippetProviderType.Path = "path", SnippetProviderType.LocalImportContext = "local-import-context", SnippetProviderType))(zf || {}), SnippetSemantics = (d => (SnippetSemantics.Function = "function", SnippetSemantics.Snippet = "snippet", SnippetSemantics.Variable = "variable", SnippetSemantics.Parameter = "parameter", SnippetSemantics.Method = "method", SnippetSemantics.Class = "class", SnippetSemantics.Module = "module", SnippetSemantics.Alias = "alias", SnippetSemantics.Enum = "enum member", SnippetSemantics.Interface = "interface", SnippetSemantics))(s1 || {}), snippetSemanticsToString = {
      function: "function",
      snippet: "snippet",
      variable: "variable",
      parameter: "parameter",
      method: "method",
      class: "class",
      module: "module",
      alias: "alias",
      "enum member": "enum member",
      interface: "interface"
    };
    __name(announceSnippet, "announceSnippet");
    __name(normalizeSnippetScore, "normalizeSnippetScore");
    __name(sortSnippetsDescending, "sortSnippetsDescending");
    __name(selectSnippets, "selectSnippets");
    __name(processSnippetsForWishlist, "processSnippetsForWishlist");
  });
async function getNeighboringFunctions(neighbor) {
  let neighborFuncs = [];
  if (isSupportedLanguageId(neighbor.languageId)) {
    let funcPositions = await getFunctionPositions(neighbor.languageId, neighbor.source);
    for (let i = 0; i < funcPositions.length; i++) {
      let {
          startIndex: startIndex,
          endIndex: endIndex
        } = funcPositions[i],
        func_source = neighbor.source.substring(startIndex, endIndex);
      neighborFuncs.push({
        source: func_source,
        relativePath: neighbor.relativePath,
        languageId: neighbor.languageId,
        uri: neighbor.uri
      });
    }
  }
  return neighborFuncs;
}
function splitIntoWords(a) {
  return a.split(/[^a-zA-Z0-9]/).filter(x => x.length > 0);
}
var FifoCache,
  Tokenizer,
  WINDOWED_TOKEN_SET_CACHE,
  WindowedMatcher,
  FunctionalMatcher,
  ENGLISH_STOPS,
  GENERIC_STOPS,
  SPECIFIC_STOPS,
  init_selectRelevance = __esmMin(() => {
    "use strict";

    init_parse();
    init_prompt();
    init_snippets();
    FifoCache = class {
      constructor(size) {
        this.keys = [];
        this.cache = {};
        this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    }, Tokenizer = class {
      static {
        __name(this, "Tokenizer");
      }
      constructor(doc) {
        this.stopsForLanguage = SPECIFIC_STOPS.get(doc.languageId) ?? GENERIC_STOPS;
      }
      tokenize(a) {
        return new Set(splitIntoWords(a).filter(x => !this.stopsForLanguage.has(x)));
      }
    }, WINDOWED_TOKEN_SET_CACHE = new FifoCache(20), WindowedMatcher = class {
      static {
        __name(this, "WindowedMatcher");
      }
      constructor(referenceDoc) {
        this.referenceDoc = referenceDoc, this.tokenizer = new Tokenizer(referenceDoc);
      }
      get referenceTokens() {
        return this.tokenizer.tokenize(this._getCursorContextInfo(this.referenceDoc).context);
      }
      sortScoredSnippets(snippets, sortOption = "descending") {
        return sortOption == "ascending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "descending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      retrieveAllSnippets(objectDoc, sortOption = "descending") {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
      async findMatches(objectDoc, snippetSelectionOption = "bestMatch", snippetSelectionK) {
        if (snippetSelectionOption == "bestMatch") {
          let snippet = await this.findBestMatch(objectDoc);
          return snippet ? [snippet] : [];
        }
        return snippetSelectionOption == "topK" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        return snippets.length === 0 || snippets[0].score === 0 ? void 0 : {
          snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippets[0]
        };
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippets = this.retrieveAllSnippets(objectDoc, "descending");
        if (snippets.length === 0 || snippets[0].score === 0) return;
        let nonOverlappingSnippets = [snippets[0]];
        for (let currentIndex = 1; currentIndex < snippets.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippets[currentIndex].startLine < snippet.endLine && snippets[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippets[currentIndex]);
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          semantics: "snippet",
          provider: "neighboring-tabs",
          ...snippetMarker
        }));
      }
    };
    __name(getNeighboringFunctions, "getNeighboringFunctions");
    FunctionalMatcher = class extends WindowedMatcher {
      static {
        __name(this, "FunctionalMatcher");
      }
      constructor(referenceDoc) {
        super(referenceDoc);
      }
      getMatchingScore(neighborDoc) {
        let neighborDocTokens = this.tokenizer.tokenize(neighborDoc.source),
          score = this.similarityScore(neighborDocTokens, this.referenceTokens);
        return {
          snippet: neighborDoc.source,
          score: score,
          startLine: 0,
          endLine: 0
        };
      }
      async findBestMatch(objectDoc) {
        let snippets = await this.findMatches(objectDoc);
        if (snippets.length !== 0 && snippets[0].score !== 0) return snippets[0];
      }
      async findMatches(objectDoc, snippetSelectionOption, snippetSelectionK) {
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return [];
        let neighborFuncs = await getNeighboringFunctions(objectDoc);
        if (neighborFuncs.length == 0) {
          let lines = objectDoc.source.split(`
`),
            snippets = this.retrieveAllSnippets(objectDoc, "descending");
          return snippets.length === 0 ? [] : snippets[0].score === 0 ? [] : [{
            snippet: lines.slice(snippets[0].startLine, snippets[0].endLine).join(`
`),
            semantics: "snippet",
            provider: "neighboring-tabs",
            ...snippets[0]
          }];
        }
        let snippets = [];
        for (let func of neighborFuncs) {
          let snippet = this.getMatchingScore(func);
          snippets.push({
            semantics: "function",
            provider: "neighboring-tabs",
            ...snippet
          });
        }
        return snippets;
      }
    };
    __name(splitIntoWords, "splitIntoWords");
    ENGLISH_STOPS = new Set(["we", "our", "you", "it", "its", "they", "them", "their", "this", "that", "these", "those", "is", "are", "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "can", "don", "t", "s", "will", "would", "should", "what", "which", "who", "when", "where", "why", "how", "a", "an", "the", "and", "or", "not", "no", "but", "because", "as", "until", "again", "further", "then", "once", "here", "there", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "above", "below", "to", "during", "before", "after", "of", "at", "by", "about", "between", "into", "through", "from", "up", "down", "in", "out", "on", "off", "over", "under", "only", "own", "same", "so", "than", "too", "very", "just", "now"]), GENERIC_STOPS = new Set(["if", "then", "else", "for", "while", "with", "def", "function", "return", "TODO", "import", "try", "catch", "raise", "finally", "repeat", "switch", "case", "match", "assert", "continue", "break", "const", "class", "enum", "struct", "static", "new", "super", "this", "var", ...ENGLISH_STOPS]), SPECIFIC_STOPS = new Map([]);
  });
function getBasicWindowDelineations(windowLength, lines) {
  let windows = [],
    length = lines.length;
  if (length == 0) return [];
  if (length < windowLength) return [[0, length]];
  for (let startLine = 0; startLine < length - windowLength + 1; startLine++) windows.push([startLine, startLine + windowLength]);
  return windows;
}
var init_windowDelineations = __esmMin(() => {
  "use strict";

  init_manipulation();
  init_parsing();
  __name(getBasicWindowDelineations, "getBasicWindowDelineations");
});
function computeScore(a, b) {
  let intersection = new Set();
  return a.forEach(x => {
    b.has(x) && intersection.add(x);
  }), intersection.size / (a.size + b.size - intersection.size);
}
var FixedWindowSizeJaccardMatcher,
  FunctionJaccardMatcher,
  init_jaccardMatching = __esmMin(() => {
    "use strict";

    init_cursorContext();
    init_selectRelevance();
    init_windowDelineations();
    FixedWindowSizeJaccardMatcher = class _FixedWindowSizeJaccardMatcher extends WindowedMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "FixedWindowSizeJaccardMatcher");
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FixedWindowSizeJaccardMatcher(referenceDoc, windowLength)
        });
      }
      id() {
        return "fixed:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    }, FunctionJaccardMatcher = class _FunctionJaccardMatcher extends FunctionalMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "FunctionJaccardMatcher");
      }
      id() {
        return "function:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      static {
        this.FACTORY = windowLength => ({
          to: referenceDoc => new _FunctionJaccardMatcher(referenceDoc, windowLength)
        });
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
    };
    __name(computeScore, "computeScore");
  });
var CursorSnippetsPickingStrategy,
  FifoCache,
  WINDOWED_TOKEN_SET_CACHE,
  CustomizedFixedWindowSizeJaccardMatcher,
  CursorHistoryMatcher,
  init_cursorMatching = __esmMin(() => {
    "use strict";

    init_prompt();
    init_cursorContext();
    init_jaccardMatching();
    init_selectRelevance();
    init_snippets();
    init_windowDelineations();
    CursorSnippetsPickingStrategy = (n => (CursorSnippetsPickingStrategy.CursorOnly = "cursoronly", CursorSnippetsPickingStrategy.CursorJaccard = "cursorjaccard", CursorSnippetsPickingStrategy.JaccardCursor = "jaccardcursor", CursorSnippetsPickingStrategy))(bb || {}), FifoCache = class {
      constructor(size) {
        this.keys = [];
        this.cache = {};
        this.size = size;
      }
      static {
        __name(this, "FifoCache");
      }
      put(key, value) {
        if (this.cache[key] = value, this.keys.length > this.size) {
          this.keys.push(key);
          let leavingKey = this.keys.shift() ?? "";
          delete this.cache[leavingKey];
        }
      }
      get(key) {
        return this.cache[key];
      }
    }, WINDOWED_TOKEN_SET_CACHE = new FifoCache(20), CustomizedFixedWindowSizeJaccardMatcher = class extends WindowedMatcher {
      constructor(referenceDoc, windowLength) {
        super(referenceDoc);
        this.windowLength = windowLength;
      }
      static {
        __name(this, "CustomizedFixedWindowSizeJaccardMatcher");
      }
      id() {
        return "CustomizedFixedWindowSizeJaccardMatcher:" + this.windowLength;
      }
      getWindowsDelineations(lines) {
        return getBasicWindowDelineations(this.windowLength, lines);
      }
      _getCursorContextInfo(referenceDoc) {
        return getCursorContext(referenceDoc, {
          maxLineCount: this.windowLength
        });
      }
      similarityScore(a, b) {
        return computeScore(a, b);
      }
      retrieveAllSnippets(objectDoc, sortOption = "descending", candidates) {
        let snippets = [];
        if (objectDoc.source.length === 0 || this.referenceTokens.size === 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          key = this.id() + ":" + objectDoc.source,
          tokensInWindows = WINDOWED_TOKEN_SET_CACHE.get(key) ?? [],
          needToComputeTokens = tokensInWindows.length == 0,
          tokenizedLines = needToComputeTokens ? lines.map(this.tokenizer.tokenize, this.tokenizer) : [];
        for (let [index, [startLine, endLine]] of this.getWindowsDelineations(lines).entries()) {
          if (needToComputeTokens) {
            let tokensInWindow = new Set();
            tokenizedLines.slice(startLine, endLine).forEach(x => x.forEach(tokensInWindow.add, tokensInWindow)), tokensInWindows.push(tokensInWindow);
          }
          if (candidates !== void 0 && candidates.get(startLine) !== endLine) continue;
          let tokensInWindow = tokensInWindows[index],
            score = this.similarityScore(tokensInWindow, this.referenceTokens);
          snippets.push({
            score: score,
            startLine: startLine,
            endLine: endLine
          });
        }
        return needToComputeTokens && WINDOWED_TOKEN_SET_CACHE.put(key, tokensInWindows), this.sortScoredSnippets(snippets, sortOption);
      }
    }, CursorHistoryMatcher = class _CursorHistoryMatcher {
      static {
        __name(this, "CursorHistoryMatcher");
      }
      constructor(referenceDoc, windowLength, lineCursorHistory, strategy) {
        this.windowLength = windowLength, this.lineCursorHistory = lineCursorHistory, this.jaccardMatcher = new CustomizedFixedWindowSizeJaccardMatcher(referenceDoc, windowLength), this.strategy = strategy;
      }
      static {
        this.FACTORY = (windowLength, lineCursorHistory, strategy) => ({
          to: referenceDoc => new _CursorHistoryMatcher(referenceDoc, windowLength, lineCursorHistory, strategy)
        });
      }
      sortScoredSnippets(snippets, sortOption = "descending") {
        return sortOption == "ascending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? 1 : -1) : sortOption == "descending" ? snippets.sort((snippetA, snippetB) => snippetA.score > snippetB.score ? -1 : 1) : snippets;
      }
      markerToSnippet(nonOverlappingSnippets, lines) {
        return nonOverlappingSnippets.map(snippetMarker => ({
          snippet: lines.slice(snippetMarker.startLine, snippetMarker.endLine).join(`
`),
          provider: "neighboring-tabs",
          semantics: "snippet",
          ...snippetMarker
        }));
      }
      async findMatches(objectDoc, snippetSelectionOption = "bestMatch", snippetSelectionK) {
        if (snippetSelectionOption == "bestMatch") {
          let bestMatch = await this.findBestMatch(objectDoc);
          return bestMatch === void 0 ? [] : [bestMatch];
        }
        return snippetSelectionOption == "topK" ? (await this.findTopKMatches(objectDoc, snippetSelectionK)) || [] : [];
      }
      async findBestMatch(objectDoc) {
        if (objectDoc.source.length !== 0) {
          if (this.strategy === "cursoronly") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippets = snippetsByCursor.filter(s => s.score === bestCursorScore),
              bestInMiddle = bestSnippets.sort((a, b) => a.startLine - b.startLine)[Math.floor(bestSnippets.length / 2)];
            return {
              snippet: objectDoc.source.split(`
`).slice(bestInMiddle.startLine, bestInMiddle.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestInMiddle
            };
          } else if (this.strategy === "cursorjaccard") {
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            let bestCursorScore = Math.max(...snippetsByCursor.map(s => s.score)),
              bestSnippetsByCursor = [],
              bestSnippetsBoundaryByCursor = new Map();
            for (let snippet of snippetsByCursor) snippet.score === bestCursorScore && (bestSnippetsByCursor.push(snippet), bestSnippetsBoundaryByCursor.set(snippet.startLine, snippet.endLine));
            let bestSnippets = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "descending", bestSnippetsBoundaryByCursor);
            if (bestSnippets.length === 0) return;
            let bestSnippet = bestSnippets[0];
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return {
              snippet: objectDoc.source.split(`
`).slice(bestSnippet.startLine, bestSnippet.endLine).join(`
`),
              provider: "neighboring-tabs",
              semantics: "snippet",
              ...bestSnippet
            };
          } else if (this.strategy === "jaccardcursor") {
            let bestSnippet = await this.jaccardMatcher.findBestMatch(objectDoc);
            if (bestSnippet === void 0) return;
            let snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
            if (snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending"), snippetsByCursor.length === 0) return;
            for (let snippet of snippetsByCursor) if (snippet.startLine === bestSnippet.startLine && snippet.endLine === bestSnippet.endLine) {
              bestSnippet.score += snippet.score;
              break;
            }
            return bestSnippet;
          }
        }
      }
      async findTopKMatches(objectDoc, snippetSelectionK = 1) {
        if (objectDoc.source.length === 0 || snippetSelectionK < 1) return;
        let lines = objectDoc.source.split(`
`),
          snippetsByCursor = this.retrieveCursorSnippets(objectDoc);
        if (snippetsByCursor.length !== 0) {
          if (this.strategy === "cursoronly") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "cursorjaccard") {
            snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let snippetCandidates = new Map(snippetsByCursor.map(s => [s.startLine, s.endLine])),
              jaccardMap = this.jaccardMatcher.retrieveAllSnippets(objectDoc, "descending", snippetCandidates).reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            snippetsByCursor.forEach(v => v.score += jaccardMap.get([v.startLine, v.endLine].join(",")) ?? 0), snippetsByCursor = this.sortScoredSnippets(snippetsByCursor, "descending");
            let nonOverlappingSnippets = this.gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK);
            return this.markerToSnippet(nonOverlappingSnippets, lines);
          } else if (this.strategy === "jaccardcursor") {
            let topKByJaccard = await this.jaccardMatcher.findTopKMatches(objectDoc, snippetSelectionK);
            if (topKByJaccard === void 0) return;
            let cursorMap = snippetsByCursor.reduce((m, s) => m.set([s.startLine, s.endLine].join(","), s.score), new Map());
            topKByJaccard.forEach(v => v.score += cursorMap.get([v.startLine, v.endLine].join(",")) ?? 0);
            let resortedTopKByJaccard = this.sortScoredSnippets(topKByJaccard, "descending");
            return this.markerToSnippet(resortedTopKByJaccard, lines);
          }
        }
      }
      gatherNonOverlappingSnippets(snippetsByCursor, snippetSelectionK) {
        let nonOverlappingSnippets = [snippetsByCursor[0]];
        for (let currentIndex = 1; currentIndex < snippetsByCursor.length && nonOverlappingSnippets.length < snippetSelectionK; currentIndex++) nonOverlappingSnippets.findIndex(snippet => snippetsByCursor[currentIndex].startLine < snippet.endLine && snippetsByCursor[currentIndex].endLine > snippet.startLine) == -1 && nonOverlappingSnippets.push(snippetsByCursor[currentIndex]);
        return nonOverlappingSnippets;
      }
      retrieveCursorSnippets(objectDoc) {
        let snippets = [];
        if (objectDoc.source.length === 0) return snippets;
        let cursors = this.lineCursorHistory.get(objectDoc.uri);
        if (cursors === void 0) return snippets;
        let lines = objectDoc.source.split(`
`),
          pointType;
        (p => (pointType[p.leftBoundary = 0] = "leftBoundary", pointType[p.rightBoundary = 1] = "rightBoundary"))(pointType ||= {});
        let sparsePoints = [];
        for (let [line, num] of cursors.entries()) line >= lines.length || (sparsePoints.push([Math.max(0, line - this.windowLength + 1), 0, num]), sparsePoints.push([line + 1, 1, num]));
        sparsePoints.push([lines.length, 0, 0]), sparsePoints = sparsePoints.sort((a, b) => a[0] - b[0]);
        let numCursors = 0,
          previousLine = 0;
        for (let [line, type, num] of sparsePoints) {
          if (numCursors > 0) for (let index = previousLine; index < line && (index == 0 || index + this.windowLength <= lines.length); index++) snippets.push({
            score: numCursors,
            startLine: index,
            endLine: Math.min(lines.length, index + this.windowLength)
          });
          type === 0 ? numCursors += num : numCursors -= num, previousLine = line;
        }
        return snippets;
      }
    };
  });
function getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy = "cursorjaccard") {
  let matcherFactory;
  return neighboringSnippetTypes === "neighboringSnippet" ? matcherFactory = FixedWindowSizeJaccardMatcher.FACTORY(selection.snippetLength) : neighboringSnippetTypes === "neighboringFunction" ? matcherFactory = FunctionJaccardMatcher.FACTORY(selection.snippetLength) : ((0, zte.ok)(lineCursorHistory !== void 0, "lineCursorHistory should not be undefined"), matcherFactory = CursorHistoryMatcher.FACTORY(selection.snippetLength, lineCursorHistory, cursorSnippetsPickingStrategy)), matcherFactory.to(doc);
}
async function getNeighborSnippets(doc, neighbors, neighboringSnippetTypes, options, snippetSelectionOption, snippetSelectionK, lineCursorHistory, cursorSnippetsPickingStrategy) {
  let selection = {
      ...neighborOptionToSelection[options]
    },
    matcher = getMatcher(doc, neighboringSnippetTypes, selection, lineCursorHistory, cursorSnippetsPickingStrategy);
  return selection.numberOfSnippets === 0 ? [] : (await neighbors.filter(neighbor => neighbor.source.length < MAX_CHARACTERS_PER_FILE && neighbor.source.length > 0).slice(0, MAX_NUMBER_OF_FILES).reduce(async (acc, neighbor) => (await acc).concat((await matcher.findMatches(neighbor, snippetSelectionOption, snippetSelectionK)).map(snippet => ({
    relativePath: neighbor.relativePath,
    ...snippet
  }))), Promise.resolve([]))).filter(neighbor => neighbor.score && neighbor.snippet && neighbor.score > selection.threshold).sort((a, b) => a.score - b.score).slice(-selection.numberOfSnippets);
}
var import_assert,
  NeighboringTabsOption,
  NeighboringSnippetType,
  neighborOptionToSelection,
  MAX_CHARACTERS_PER_FILE,
  MAX_NUMBER_OF_FILES,
  init_neighboringFiles = __esmMin(() => {
    "use strict";

    import_assert = require("assert");
    init_cursorMatching();
    init_jaccardMatching();
    NeighboringTabsOption = (u => (NeighboringTabsOption.None = "none", NeighboringTabsOption.Conservative = "conservative", NeighboringTabsOption.Medium = "medium", NeighboringTabsOption.Eager = "eager", NeighboringTabsOption.EagerButLittle = "eagerButLittle", NeighboringTabsOption.EagerButMedium = "eagerButMedium", NeighboringTabsOption.EagerButMuch = "eagerButMuch", NeighboringTabsOption.RetrievalComparable = "retrievalComparable", NeighboringTabsOption))(p_ || {}), NeighboringSnippetType = (n => (NeighboringSnippetType.NeighboringFunctions = "neighboringFunction", NeighboringSnippetType.NeighboringSnippets = "neighboringSnippet", NeighboringSnippetType.CursorHistoryMatcher = "cursorhistorymatcher", NeighboringSnippetType))(Cb || {}), neighborOptionToSelection = {
      none: {
        snippetLength: 1,
        threshold: -1,
        numberOfSnippets: 0
      },
      conservative: {
        snippetLength: 10,
        threshold: .3,
        numberOfSnippets: 1
      },
      medium: {
        snippetLength: 20,
        threshold: .1,
        numberOfSnippets: 2
      },
      eager: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButLittle: {
        snippetLength: 10,
        threshold: 0,
        numberOfSnippets: 1
      },
      eagerButMedium: {
        snippetLength: 20,
        threshold: 0,
        numberOfSnippets: 4
      },
      eagerButMuch: {
        snippetLength: 60,
        threshold: 0,
        numberOfSnippets: 6
      },
      retrievalComparable: {
        snippetLength: 30,
        threshold: 0,
        numberOfSnippets: 4
      }
    }, MAX_CHARACTERS_PER_FILE = 1e4, MAX_NUMBER_OF_FILES = 20;
    __name(getMatcher, "getMatcher");
    __name(getNeighborSnippets, "getNeighborSnippets");
  });
function findEditDistanceScore(a, b) {
  if (a.length === 0 || b.length === 0) return {
    score: a.length + b.length
  };
  let matrix = Array.from({
    length: a.length
  }).map(() => Array.from({
    length: b.length
  }).map(() => 0));
  for (let i = 0; i < a.length; i++) matrix[i][0] = i;
  for (let i = 0; i < b.length; i++) matrix[0][i] = i;
  for (let j = 0; j < b.length; j++) for (let i = 0; i < a.length; i++) matrix[i][j] = Math.min((i == 0 ? j : matrix[i - 1][j]) + 1, (j == 0 ? i : matrix[i][j - 1]) + 1, (i == 0 || j == 0 ? Math.max(i, j) : matrix[i - 1][j - 1]) + (a[i] == b[j] ? 0 : 1));
  return {
    score: matrix[a.length - 1][b.length - 1]
  };
}
var init_suffixMatchCriteria = __esmMin(() => {
  "use strict";

  __name(findEditDistanceScore, "findEditDistanceScore");
});
var PromptBackground,
  PromptChoices,
  PromptElementRanges,
  PromptWishlist,
  Priorities,
  init_wishlist = __esmMin(() => {
    "use strict";

    init_prompt();
    PromptBackground = class {
      constructor() {
        this.used = new Map();
        this.unused = new Map();
      }
      static {
        __name(this, "PromptBackground");
      }
      markUsed(element) {
        this.IsSnippet(element) && this.used.set(element.id, this.convert(element));
      }
      undoMarkUsed(element) {
        this.IsSnippet(element) && this.used.delete(element.id);
      }
      markUnused(element) {
        this.IsSnippet(element) && this.unused.set(element.id, this.convert(element));
      }
      convert(element) {
        return {
          score: element.score.toFixed(4),
          length: element.text.length
        };
      }
      IsSnippet(element) {
        return element.kind == "SimilarFile" || element.kind == "RetrievalSnippet";
      }
    }, PromptChoices = class {
      constructor() {
        this.used = new Map();
        this.unused = new Map();
        this.usedCounts = new Map();
        this.unusedCounts = new Map();
      }
      static {
        __name(this, "PromptChoices");
      }
      markUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) + element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) + 1);
      }
      undoMarkUsed(element) {
        this.used.set(element.kind, (this.used.get(element.kind) || 0) - element.tokens), this.usedCounts.set(element.kind, (this.usedCounts.get(element.kind) || 0) - 1);
      }
      markUnused(element) {
        this.unused.set(element.kind, (this.unused.get(element.kind) || 0) + element.tokens), this.unusedCounts.set(element.kind, (this.unusedCounts.get(element.kind) || 0) + 1);
      }
    }, PromptElementRanges = class {
      constructor(usedElements) {
        this.ranges = new Array();
        let nextRangeStart = 0,
          previousKind;
        for (let {
          element: element
        } of usedElements) element.text.length !== 0 && (previousKind === "BeforeCursor" && element.kind === "BeforeCursor" ? this.ranges[this.ranges.length - 1].end += element.text.length : this.ranges.push({
          kind: element.kind,
          start: nextRangeStart,
          end: nextRangeStart + element.text.length
        }), previousKind = element.kind, nextRangeStart += element.text.length);
      }
      static {
        __name(this, "PromptElementRanges");
      }
    }, PromptWishlist = class {
      constructor(tokenizer, lineEndingOption) {
        this.tokenizer = tokenizer;
        this.content = [];
        this.tokenizer = tokenizer, this.lineEndingOption = lineEndingOption;
      }
      static {
        __name(this, "PromptWishlist");
      }
      getContent() {
        return [...this.content];
      }
      convertLineEndings(text) {
        return this.lineEndingOption === "unix" && (text = text.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), text;
      }
      append(text, kind, priority, tokens = this.tokenizer.tokenLength(text), score = NaN) {
        text = this.convertLineEndings(text);
        let id = this.content.length;
        return this.content.push({
          id: id,
          text: text,
          kind: kind,
          priority: priority,
          tokens: tokens,
          requires: [],
          excludes: [],
          score: score
        }), id;
      }
      appendLineForLine(text, kind, priority) {
        text = this.convertLineEndings(text);
        let rawLines = text.split(`
`);
        for (let i = 0; i < rawLines.length - 1; i++) rawLines[i] += `
`;
        let lines = [];
        rawLines.forEach((line, i) => {
          line === `
` && lines.length > 0 && !lines[lines.length - 1].endsWith(`

`) ? lines[lines.length - 1] += `
` : lines.push(line);
        });
        let returns = [];
        return lines.forEach((line, i) => {
          line !== "" && (returns.push(this.append(line, kind, priority)), i > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]));
        }), returns;
      }
      require(dependentId, dependeeId) {
        let dependent = this.content.find(e => e.id === dependentId),
          dependee = this.content.find(e => e.id === dependeeId);
        dependent && dependee && dependent.requires.push(dependee);
      }
      exclude(excludingId, excludedId) {
        let excluding = this.content.find(e => e.id === excludingId),
          excluded = this.content.find(e => e.id === excludedId);
        excluding && excluded && excluding.excludes.push(excluded);
      }
      fulfill(maxPromptLength) {
        let tallyOfChoices = new PromptChoices(),
          promptBackground = new PromptBackground(),
          indexedContent = this.content.map((e, i) => ({
            element: e,
            index: i
          }));
        indexedContent.sort((a, b) => a.element.priority === b.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
        let idsThatHaveAlreadyBeenAdded = new Set(),
          idsConflictingWithAlreadyAddedIds = new Set(),
          budgetBreakingElement,
          remainingContent = [],
          remainingBudget = maxPromptLength;
        indexedContent.forEach(e => {
          let element = e.element;
          if (remainingBudget >= 0 && (remainingBudget > 0 || budgetBreakingElement === void 0) && element.requires.every(r => idsThatHaveAlreadyBeenAdded.has(r.id)) && !idsConflictingWithAlreadyAddedIds.has(element.id)) {
            let budgetUse = element.tokens;
            remainingBudget >= budgetUse ? (remainingBudget -= budgetUse, idsThatHaveAlreadyBeenAdded.add(element.id), element.excludes.forEach(e => idsConflictingWithAlreadyAddedIds.add(e.id)), tallyOfChoices.markUsed(element), promptBackground.markUsed(element), remainingContent.push(e)) : budgetBreakingElement === void 0 ? budgetBreakingElement = e : (tallyOfChoices.markUnused(e.element), promptBackground.markUnused(e.element));
          } else tallyOfChoices.markUnused(element), promptBackground.markUnused(element);
        }), remainingContent.sort((a, b) => a.index - b.index);
        let prompt = remainingContent.reduce((a, b) => a + b.element.text, ""),
          promptLength = this.tokenizer.tokenLength(prompt);
        for (; promptLength > maxPromptLength;) {
          remainingContent.sort((a, b) => b.element.priority === a.element.priority ? b.index - a.index : b.element.priority - a.element.priority);
          let removeAfterAll = remainingContent.pop();
          removeAfterAll && (tallyOfChoices.undoMarkUsed(removeAfterAll.element), tallyOfChoices.markUnused(removeAfterAll.element), promptBackground.undoMarkUsed(removeAfterAll.element), promptBackground.markUnused(removeAfterAll.element), budgetBreakingElement !== void 0 && (tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element)), budgetBreakingElement = void 0), remainingContent.sort((a, b) => a.index - b.index), prompt = remainingContent.reduce((a, b) => a + b.element.text, ""), promptLength = this.tokenizer.tokenLength(prompt);
        }
        let extendedContent = [...remainingContent];
        if (budgetBreakingElement !== void 0) {
          extendedContent.push(budgetBreakingElement), extendedContent.sort((a, b) => a.index - b.index);
          let prompt = extendedContent.reduce((a, b) => a + b.element.text, ""),
            promptLength = this.tokenizer.tokenLength(prompt);
          if (promptLength <= maxPromptLength) {
            tallyOfChoices.markUsed(budgetBreakingElement.element), promptBackground.markUsed(budgetBreakingElement.element);
            let promptElementRanges = new PromptElementRanges(extendedContent);
            return {
              prefix: prompt,
              suffix: "",
              prefixLength: promptLength,
              suffixLength: 0,
              promptChoices: tallyOfChoices,
              promptBackground: promptBackground,
              promptElementRanges: promptElementRanges
            };
          } else tallyOfChoices.markUnused(budgetBreakingElement.element), promptBackground.markUnused(budgetBreakingElement.element);
        }
        let promptElementRanges = new PromptElementRanges(remainingContent);
        return {
          prefix: prompt,
          suffix: "",
          prefixLength: promptLength,
          suffixLength: 0,
          promptChoices: tallyOfChoices,
          promptBackground: promptBackground,
          promptElementRanges: promptElementRanges
        };
      }
    }, Priorities = class _Priorities {
      constructor() {
        this.registeredPriorities = [0, 1];
      }
      static {
        __name(this, "Priorities");
      }
      static {
        this.TOP = 1;
      }
      static {
        this.BOTTOM = 0;
      }
      register(priority) {
        if (priority > _Priorities.TOP || priority < _Priorities.BOTTOM) throw new Error("Priority must be between 0 and 1");
        return this.registeredPriorities.push(priority), priority;
      }
      justAbove(...priorities) {
        let priority = Math.max(...priorities),
          nearestNeighbor = Math.min(...this.registeredPriorities.filter(p => p > priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      justBelow(...priorities) {
        let priority = Math.min(...priorities),
          nearestNeighbor = Math.max(...this.registeredPriorities.filter(p => p < priority));
        return this.register((nearestNeighbor + priority) / 2);
      }
      between(lower, higher) {
        if (this.registeredPriorities.some(p => p > lower && p < higher) || !(this.registeredPriorities.includes(lower) && this.registeredPriorities.includes(higher))) throw new Error("Priorities must be adjacent in the list of priorities");
        return this.register((lower + higher) / 2);
      }
    };
  });
function normalizeLanguageId(languageId) {
  return languageId = languageId.toLowerCase(), languageNormalizationMap[languageId] ?? languageId;
}
async function getPrompt(fileSystem, doc, options = {}, snippets = []) {
  let completeOptions = new PromptOptions(fileSystem, options),
    tokenizer = getTokenizer(completeOptions.tokenizerName),
    useCachedSuffix = !1,
    {
      source: source,
      offset: offset
    } = doc;
  if (offset < 0 || offset > source.length) throw new Error(`Offset ${offset} is out of range.`);
  doc.languageId = normalizeLanguageId(doc.languageId);
  let priorities = new Priorities(),
    directContextPriority = priorities.justBelow(Priorities.TOP),
    languageMarkerPriority = completeOptions.languageMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
    pathMarkerPriority = completeOptions.pathMarker === "always" ? priorities.justBelow(Priorities.TOP) : priorities.justBelow(directContextPriority),
    localImportContextPriority = priorities.justBelow(directContextPriority),
    lowSnippetPriority = priorities.justBelow(localImportContextPriority),
    highSnippetPriority = priorities.justAbove(directContextPriority),
    promptWishlist = new PromptWishlist(tokenizer, completeOptions.lineEnding),
    languageSnippet = snippets.find(s => s.provider === "language"),
    languageMarkerLine;
  completeOptions.languageMarker !== "nomarker" && languageSnippet && (languageMarkerLine = promptWishlist.append(languageSnippet.snippet, "LanguageMarker", languageMarkerPriority));
  let pathSnippet = snippets.find(s => s.provider === "path"),
    pathMarkerLine;
  completeOptions.pathMarker !== "nomarker" && pathSnippet !== void 0 && pathSnippet.snippet.length > 0 && (pathMarkerLine = promptWishlist.append(pathSnippet.snippet, "PathMarker", pathMarkerPriority));
  let localImportSnippet = snippets.filter(s => s.provider === "local-import-context");
  if (completeOptions.localImportContext !== "nocontext") for (let localImportContext of localImportSnippet) promptWishlist.append(newLineEnded(localImportContext.snippet), "ImportedFile", localImportContextPriority);
  snippets = snippets.filter(s => s.provider !== "language" && s.provider !== "path" && s.provider !== "local-import-context");
  function addSnippetsNow() {
    let budget = Math.round(completeOptions.snippetPercent / 100 * completeOptions.maxPromptLength);
    processSnippetsForWishlist(snippets, doc.languageId, tokenizer, completeOptions.snippetProviderOptions, {
      priorities: priorities,
      low: lowSnippetPriority,
      high: highSnippetPriority
    }, completeOptions.numberOfSnippets, budget).forEach(snippet => {
      let kind = "SimilarFile";
      snippet.provider === "retrieval" ? kind = "RetrievalSnippet" : snippet.provider == "symbol-def" && (kind = "SymbolDefinition"), promptWishlist.append(snippet.announcedSnippet, kind, snippet.priority, snippet.tokens, snippet.normalizedScore);
    });
  }
  __name(addSnippetsNow, "addSnippetsNow"), completeOptions.snippetPosition === "top" && addSnippetsNow();
  let source_lines = [],
    directContext;
  if (directContext = source.substring(0, offset), completeOptions.snippetPosition === "aboveCursor") {
    let lastLineStart = directContext.lastIndexOf(`
`) + 1,
      directContextBeforePartialLastLine = directContext.substring(0, lastLineStart),
      partialLastLine = directContext.substring(lastLineStart);
    promptWishlist.appendLineForLine(directContextBeforePartialLastLine, "BeforeCursor", directContextPriority).forEach(id => source_lines.push(id)), addSnippetsNow(), partialLastLine.length > 0 && (source_lines.push(promptWishlist.append(partialLastLine, "AfterCursor", directContextPriority)), source_lines.length > 1 && promptWishlist.require(source_lines[source_lines.length - 2], source_lines[source_lines.length - 1]));
  } else promptWishlist.appendLineForLine(directContext, "BeforeCursor", directContextPriority).forEach(id => source_lines.push(id));
  completeOptions.languageMarker === "top" && source_lines.length > 0 && languageMarkerLine !== void 0 && promptWishlist.require(languageMarkerLine, source_lines[0]), completeOptions.pathMarker === "top" && source_lines.length > 0 && pathMarkerLine !== void 0 && (languageMarkerLine ? promptWishlist.require(pathMarkerLine, languageMarkerLine) : promptWishlist.require(pathMarkerLine, source_lines[0])), languageMarkerLine !== void 0 && pathMarkerLine !== void 0 && promptWishlist.exclude(pathMarkerLine, languageMarkerLine);
  let actualSuffix = source.slice(offset);
  if (completeOptions.suffixPercent === 0 || actualSuffix.length <= completeOptions.fimSuffixLengthThreshold) return promptWishlist.fulfill(completeOptions.maxPromptLength);
  {
    let offset = doc.offset;
    completeOptions.suffixStartMode !== "cursor" && completeOptions.suffixStartMode !== "cursortrimstart" && (offset = await getSiblingFunctionStart(doc));
    let availableTokens = completeOptions.maxPromptLength - TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
      prefixTargetTokens = Math.floor(availableTokens * (100 - completeOptions.suffixPercent) / 100),
      promptInfo = promptWishlist.fulfill(prefixTargetTokens),
      suffixTargetTokens = availableTokens - promptInfo.prefixLength,
      suffixText = source.slice(offset);
    (completeOptions.suffixStartMode === "siblingblocktrimstart" || completeOptions.suffixStartMode === "cursortrimstart") && (suffixText = suffixText.trimStart());
    let suffix = tokenizer.takeFirstTokens(suffixText, suffixTargetTokens);
    return suffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - suffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), completeOptions.suffixMatchCriteria === "equal" ? suffix.tokens.length === cachedSuffix.tokens.length && suffix.tokens.every((v, i) => v === cachedSuffix.tokens[i]) && (useCachedSuffix = !0) : completeOptions.suffixMatchCriteria === "levenshteineditdistance" && suffix.tokens.length > 0 && completeOptions.suffixMatchThreshold > 0 && 100 * findEditDistanceScore(suffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH), cachedSuffix.tokens.slice(0, MAX_EDIT_DISTANCE_LENGTH))?.score < completeOptions.suffixMatchThreshold * Math.min(MAX_EDIT_DISTANCE_LENGTH, suffix.tokens.length) && (useCachedSuffix = !0), useCachedSuffix === !0 && cachedSuffix.tokens.length <= suffixTargetTokens ? (cachedSuffix.tokens.length <= suffixTargetTokens - 3 && (prefixTargetTokens = availableTokens - cachedSuffix.tokens.length, promptInfo = promptWishlist.fulfill(prefixTargetTokens)), promptInfo.suffix = cachedSuffix.text, promptInfo.suffixLength = cachedSuffix.tokens.length) : (promptInfo.suffix = suffix.text, promptInfo.suffixLength = suffix.tokens.length, cachedSuffix = suffix), promptInfo;
  }
}
var cachedSuffix,
  MAX_PROMPT_LENGTH,
  MAX_EDIT_DISTANCE_LENGTH,
  TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
  DEFAULT_NUM_OF_SNIPPETS,
  LanguageMarkerOption,
  PathMarkerOption,
  SnippetPositionOption,
  SnippetSelectionOption,
  LocalImportContextOption,
  LineEndingOptions,
  SuffixOption,
  SuffixMatchOption,
  SuffixStartMode,
  PromptOptions,
  languageNormalizationMap,
  init_prompt = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_siblingFunctions();
    init_cursorMatching();
    init_neighboringFiles();
    init_snippets();
    init_suffixMatchCriteria();
    init_tokenization();
    init_wishlist();
    cachedSuffix = {
      text: "",
      tokens: []
    }, MAX_PROMPT_LENGTH = 1500, MAX_EDIT_DISTANCE_LENGTH = 50, TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5, DEFAULT_NUM_OF_SNIPPETS = 4, LanguageMarkerOption = (n => (LanguageMarkerOption.NoMarker = "nomarker", LanguageMarkerOption.Top = "top", LanguageMarkerOption.Always = "always", LanguageMarkerOption))(ere || {}), PathMarkerOption = (n => (PathMarkerOption.NoMarker = "nomarker", PathMarkerOption.Top = "top", PathMarkerOption.Always = "always", PathMarkerOption))(tre || {}), SnippetPositionOption = (n => (SnippetPositionOption.TopOfText = "top", SnippetPositionOption.DirectlyAboveCursor = "aboveCursor", SnippetPositionOption.AfterSiblings = "afterSiblings", SnippetPositionOption))(rre || {}), SnippetSelectionOption = (r => (SnippetSelectionOption.BestMatch = "bestMatch", SnippetSelectionOption.TopK = "topK", SnippetSelectionOption))(u_ || {}), LocalImportContextOption = (r => (LocalImportContextOption.NoContext = "nocontext", LocalImportContextOption.Declarations = "declarations", LocalImportContextOption))(aL || {}), LineEndingOptions = (r => (LineEndingOptions.ConvertToUnix = "unix", LineEndingOptions.KeepOriginal = "keep", LineEndingOptions))(oL || {}), SuffixOption = (r => (SuffixOption.None = "none", SuffixOption.FifteenPercent = "fifteenPercent", SuffixOption))(nre || {}), SuffixMatchOption = (r => (SuffixMatchOption.Equal = "equal", SuffixMatchOption.Levenshtein = "levenshteineditdistance", SuffixMatchOption))(ire || {}), SuffixStartMode = (i => (SuffixStartMode.Cursor = "cursor", SuffixStartMode.CursorTrimStart = "cursortrimstart", SuffixStartMode.SiblingBlock = "siblingblock", SuffixStartMode.SiblingBlockTrimStart = "siblingblocktrimstart", SuffixStartMode))(sre || {}), PromptOptions = class {
      constructor(fs, options) {
        this.fs = fs;
        this.maxPromptLength = MAX_PROMPT_LENGTH;
        this.languageMarker = "top";
        this.pathMarker = "top";
        this.localImportContext = "nocontext";
        this.snippetPosition = "top";
        this.numberOfSnippets = DEFAULT_NUM_OF_SNIPPETS;
        this.snippetProviderOptions = {
          "neighboring-tabs": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          retrieval: {
            normalizationFunction: "affine",
            normalizationParams: [-1, 0]
          },
          "symbol-def": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0],
            reservedSnippetCount: 2
          },
          language: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          path: {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          },
          "local-import-context": {
            normalizationFunction: "affine",
            normalizationParams: [1, 0]
          }
        };
        this.neighboringTabs = "eager";
        this.neighboringSnippetTypes = "neighboringSnippet";
        this.lineEnding = "unix";
        this.suffixPercent = 0;
        this.snippetPercent = 0;
        this.suffixStartMode = "cursor";
        this.tokenizerName = "cl100k";
        this.suffixMatchThreshold = 0;
        this.suffixMatchCriteria = "levenshteineditdistance";
        this.fimSuffixLengthThreshold = 0;
        this.cursorSnippetsPickingStrategy = "cursorjaccard";
        if (options) {
          let selectionValue = options?.snippetSelection;
          if (selectionValue && !Object.values(SnippetSelectionOption).includes(selectionValue)) throw new Error(`Invalid value for snippetSelection: ${selectionValue}`);
          for (let key in options) if (key !== "snippetProviderOptions") this[key] = options[key];else {
            let newOptions = options.snippetProviderOptions || {},
              provider;
            for (provider in newOptions) {
              let providerOptions = newOptions[provider];
              providerOptions && (this.snippetProviderOptions[provider] = {
                ...this.snippetProviderOptions[provider],
                ...providerOptions
              });
            }
          }
        }
        if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);
        if (this.snippetPercent < 0 || this.snippetPercent > 100) throw new Error(`snippetPercent must be between 0 and 100, but was ${this.snippetPercent}`);
        if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100) throw new Error(`suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`);
        if (this.fimSuffixLengthThreshold < -1) throw new Error(`fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`);
        if (this.snippetSelection === "topK" && this.snippetSelectionK === void 0) throw new Error("snippetSelectionK must be defined.");
        if (this.snippetSelection === "topK" && this.snippetSelectionK && this.snippetSelectionK <= 0) throw new Error(`snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`);
      }
      static {
        __name(this, "PromptOptions");
      }
    }, languageNormalizationMap = {
      javascriptreact: "javascript",
      jsx: "javascript",
      typescriptreact: "typescript",
      jade: "pug",
      cshtml: "razor"
    };
    __name(normalizeLanguageId, "normalizeLanguageId");
    __name(getPrompt, "getPrompt");
  });
var ProviderTimeoutError,
  SnippetProvider,
  init_snippetProvider = __esmMin(() => {
    "use strict";

    init_orchestrator();
    ProviderTimeoutError = class extends Error {
      static {
        __name(this, "ProviderTimeoutError");
      }
      constructor(message) {
        super(message), this.name = "ProviderTimeoutError";
      }
    }, SnippetProvider = class {
      static {
        __name(this, "SnippetProvider");
      }
      constructor(workerProxy) {
        this.api = workerProxy;
      }
      getSnippets(context, signal) {
        return new Promise((resolve, reject) => {
          signal.aborted && reject({
            error: new ProviderTimeoutError("provider aborted"),
            providerType: this.type
          }), signal.addEventListener("abort", () => {
            reject({
              error: new ProviderTimeoutError(`max runtime exceeded: ${TIMEOUT_MS} ms`),
              providerType: this.type
            });
          }, {
            once: !0
          });
          let startTime = performance.now();
          this.buildSnippets(context).then(snippets => {
            let endTime = performance.now();
            resolve({
              snippets: snippets,
              providerType: this.type,
              runtime: endTime - startTime
            });
          }).catch(error => {
            reject({
              error: error,
              providerType: this.type
            });
          });
        });
      }
    };
  });
var LanguageSnippetProvider,
  init_language = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    LanguageSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "language";
      }
      static {
        __name(this, "LanguageSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getLanguageMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    };
  });
var LocalImportContextSnippetProvider,
  init_localImportContext = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    LocalImportContextSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "local-import-context";
      }
      static {
        __name(this, "LocalImportContextSnippetProvider");
      }
      formSnippets(imports, currentFile) {
        return imports.map(importPath => ({
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(importPath),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 1
        }));
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          options: options,
          fileSystem: fileSystem
        } = context;
        if (options.localImportContext == "nocontext") return [];
        let localImportContext = await this.api.extractLocalImportContext(currentFile, fileSystem);
        return this.formSnippets(localImportContext, currentFile);
      }
    };
  });
var NeighborFilesProvider,
  init_neighborFiles = __esmMin(() => {
    "use strict";

    init_lib();
    init_neighboringFiles();
    init_snippetProvider();
    NeighborFilesProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "neighboring-tabs";
      }
      static {
        __name(this, "NeighborFilesProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile,
          neighborFiles: neighborFiles,
          options: options,
          lineCursorHistory: lineCursorHistory
        } = context;
        return options && neighborFiles && neighborFiles.length && options.neighboringTabs !== "none" ? await this.api.getNeighborSnippets(currentFile, neighborFiles, options.neighboringSnippetTypes, options.neighboringTabs, options.snippetSelection, options.snippetSelectionK, lineCursorHistory, options.cursorSnippetsPickingStrategy) : [];
      }
    };
  });
var PathSnippetProvider,
  init_path = __esmMin(() => {
    "use strict";

    init_languageMarker();
    init_prompt();
    init_snippets();
    init_snippetProvider();
    PathSnippetProvider = class extends SnippetProvider {
      constructor() {
        super(...arguments);
        this.type = "path";
      }
      static {
        __name(this, "PathSnippetProvider");
      }
      async buildSnippets(context) {
        let {
          currentFile: currentFile
        } = context;
        return currentFile.languageId = normalizeLanguageId(currentFile.languageId), [{
          provider: this.type,
          semantics: "snippet",
          snippet: newLineEnded(getPathMarker(currentFile)),
          relativePath: currentFile.relativePath,
          startLine: 0,
          endLine: 0,
          score: 0
        }];
      }
    };
  });
function resolveLocalTypeScriptImport(importerPath, imp) {
  let src = imp.namedChild(1)?.text.slice(1, -1);
  if (!src || !src.startsWith(".")) return null;
  if ((0, sh.extname)(src) === "") src = src + ".ts";else if ((0, sh.extname)(src) !== ".ts") return null;
  return (0, sh.join)((0, sh.dirname)(importerPath), src);
}
function getTypescriptImportedNames(imp) {
  let names = [];
  if (imp.namedChild(0)?.type === "import_clause") {
    let importClause = imp.namedChild(0);
    if (importClause?.namedChild(0)?.type === "named_imports") {
      let namedImports = importClause.namedChild(0);
      for (let namedImport of namedImports?.namedChildren ?? []) if (namedImport.type === "import_specifier") {
        let name = namedImport.childForFieldName("name")?.text;
        if (name) {
          let alias = namedImport.childForFieldName("alias")?.text;
          names.push({
            name: name,
            alias: alias
          });
        }
      }
    }
  }
  return names;
}
function extractTypeScriptDeclaration(srcString, defn) {
  let name = defn?.childForFieldName("name")?.text ?? "";
  switch (defn?.type) {
    case "ambient_declaration":
      return extractTypeScriptDeclaration(srcString, defn.namedChild(0));
    case "interface_declaration":
    case "enum_declaration":
    case "type_alias_declaration":
      return {
        name: name,
        decl: defn.text
      };
    case "function_declaration":
    case "function_signature":
      return {
        name: name,
        decl: extractTypeScriptFunctionDeclaration(srcString, defn)
      };
    case "class_declaration":
      {
        let memberDecls = extractTypeScriptBodyDecls(srcString, defn),
          decl = "";
        if (memberDecls) {
          let body = defn.childForFieldName("body");
          decl = `declare ${srcString.substring(defn.startIndex, body.startIndex + 1)}`, decl += memberDecls.map(d => `
` + d).join(""), decl += `
}`;
        }
        return {
          name: name,
          decl: decl
        };
      }
  }
  return {
    name: name,
    decl: ""
  };
}
function extractTypeScriptFunctionDeclaration(srcString, defn) {
  let endIndex = defn.childForFieldName("return_type")?.endIndex ?? defn.childForFieldName("parameters")?.endIndex;
  if (endIndex !== void 0) {
    let signature = srcString.substring(defn.startIndex, endIndex) + ";";
    return defn.type === "function_declaration" || defn.type === "function_signature" ? "declare " + signature : signature;
  }
  return "";
}
function getIndentation(srcString, node) {
  let i = node.startIndex - 1;
  for (; i >= 0 && (srcString[i] === " " || srcString[i] === "	");) i--;
  if (i < 0 || srcString[i] === `
`) return srcString.substring(i + 1, node.startIndex);
}
function getDocComment(srcString, node) {
  let docCommentNode = getFirstPrecedingComment(node);
  return docCommentNode ? srcString.substring(docCommentNode.startIndex, node.startIndex) : "";
}
function extractTypeScriptMemberDeclaration(srcString, defn) {
  if (defn?.firstChild?.type === "accessibility_modifier" && defn.firstChild.text === "private") return "";
  let commentNode = getFirstPrecedingComment(defn),
    indentation = getIndentation(srcString, commentNode ?? defn) ?? "  ",
    docComment = getDocComment(srcString, defn);
  switch (defn.type) {
    case "ambient_declaration":
      let inner = defn.namedChild(0);
      return inner ? indentation + docComment + extractTypeScriptMemberDeclaration(srcString, inner) : "";
    case "method_definition":
    case "method_signature":
      return indentation + docComment + extractTypeScriptFunctionDeclaration(srcString, defn);
    case "public_field_definition":
      {
        let endIndex = defn.childForFieldName("type")?.endIndex ?? defn.childForFieldName("name")?.endIndex;
        if (endIndex !== void 0) return indentation + docComment + srcString.substring(defn.startIndex, endIndex) + ";";
      }
  }
  return "";
}
function extractTypeScriptBodyDecls(srcString, defn) {
  let body = defn.childForFieldName("body");
  return body ? body.namedChildren.map(member => extractTypeScriptMemberDeclaration(srcString, member)).filter(decl => decl) : void 0;
}
async function getExportedDeclarations(uri, lang, fs) {
  let exports = new Map(),
    mtime = -1;
  try {
    mtime = (await fs.stat(uri)).mtime;
  } catch {
    return exports;
  }
  let entry = exportsCache.get(uri);
  if (entry && entry.mtime === mtime) return entry.exports;
  if (lang === "typescript") {
    let tree = null;
    try {
      let srcString = (await fs.readFile(uri)).toString();
      tree = await parseTreeSitter(lang, srcString);
      for (let em of queryExports(lang, tree.rootNode)) for (let ec of em.captures) {
        let exp = ec.node;
        if (exp.type === "export_statement") {
          let decl = exp.childForFieldName("declaration");
          if (decl?.hasError()) continue;
          let {
            name: name,
            decl: exportedDecl
          } = extractTypeScriptDeclaration(srcString, decl);
          if (name) {
            exportedDecl = getDocComment(srcString, exp) + exportedDecl;
            let exportedDecls = exports.get(name);
            exportedDecls || (exportedDecls = [], exports.set(name, exportedDecls)), exportedDecls.push(exportedDecl);
          }
        }
      }
    } catch {} finally {
      tree && tree.delete();
    }
  }
  if (exportsCache.size > EXPORTS_CACHE_HIGH_WATER_MARK) {
    for (let key of exportsCache.keys()) if (exportsCache.delete(key), exports.size <= EXPORTS_CACHE_LOW_WATER_MARK) break;
  }
  return exportsCache.set(uri, {
    mtime: mtime,
    exports: exports
  }), exports;
}
function getTypeScriptImports(root) {
  let imports = [];
  for (let toplevelStmt of root.namedChildren) toplevelStmt.type === "import_statement" && imports.push(toplevelStmt);
  return imports;
}
function lastTypeScriptLocalImportOffset(source) {
  let lastImport = -1;
  localImportRegex.lastIndex = -1;
  let m;
  do m = localImportRegex.exec(source), m && (lastImport = localImportRegex.lastIndex + m.length); while (m);
  if (lastImport === -1) return -1;
  let newlineAfterLastImport = source.indexOf(`
`, lastImport);
  return newlineAfterLastImport !== -1 ? newlineAfterLastImport : source.length;
}
async function extractTypeScriptLocalImportContext(source, uri, fs) {
  let languageId = "typescript",
    localImportContext = [],
    lastImportOffset = lastTypeScriptLocalImportOffset(source);
  if (lastImportOffset === -1) return localImportContext;
  source = source.substring(0, lastImportOffset);
  let tree = await parseTreeSitter(languageId, source);
  try {
    for (let imp of getTypeScriptImports(tree.rootNode)) {
      let srcUri = resolveLocalTypeScriptImport(uri, imp);
      if (!srcUri) continue;
      let importedNames = getTypescriptImportedNames(imp);
      if (importedNames.length === 0) continue;
      let exports = await getExportedDeclarations(srcUri, languageId, fs);
      for (let importedName of importedNames) exports.has(importedName.name) && localImportContext.push(...exports.get(importedName.name));
    }
  } finally {
    tree.delete();
  }
  return localImportContext;
}
async function extractLocalImportContext(doc, fs) {
  let {
      source: source,
      languageId: languageId
    } = doc,
    uri = ure.URI.parse(doc.uri);
  return languageId === "typescript" && uri.scheme === "file" ? extractTypeScriptLocalImportContext(source, uri.fsPath, fs ?? defaultFileSystem) : [];
}
var import_path,
  import_vscode_uri,
  exportsCache,
  EXPORTS_CACHE_LOW_WATER_MARK,
  EXPORTS_CACHE_HIGH_WATER_MARK,
  localImportRegex,
  init_localImportContext = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_vscode_uri = Ns(B1());
    init_fileSystem();
    init_parse();
    __name(resolveLocalTypeScriptImport, "resolveLocalTypeScriptImport");
    __name(getTypescriptImportedNames, "getTypescriptImportedNames");
    exportsCache = new Map(), EXPORTS_CACHE_LOW_WATER_MARK = 1e3, EXPORTS_CACHE_HIGH_WATER_MARK = 2e3;
    __name(extractTypeScriptDeclaration, "extractTypeScriptDeclaration");
    __name(extractTypeScriptFunctionDeclaration, "extractTypeScriptFunctionDeclaration");
    __name(getIndentation, "getIndentation");
    __name(getDocComment, "getDocComment");
    __name(extractTypeScriptMemberDeclaration, "extractTypeScriptMemberDeclaration");
    __name(extractTypeScriptBodyDecls, "extractTypeScriptBodyDecls");
    __name(getExportedDeclarations, "getExportedDeclarations");
    __name(getTypeScriptImports, "getTypeScriptImports");
    localImportRegex = /^\s*import\s*(type|)\s*\{[^}]*\}\s*from\s*['"]\./gm;
    __name(lastTypeScriptLocalImportOffset, "lastTypeScriptLocalImportOffset");
    __name(extractTypeScriptLocalImportContext, "extractTypeScriptLocalImportContext");
    __name(extractLocalImportContext, "extractLocalImportContext");
  });
function sleep(delay) {
  return new Promise(resolve => {
    setTimeout(() => resolve(`delay: ${delay}`), delay);
  });
}
var import_path,
  import_worker_threads,
  workerFns,
  WorkerProxy,
  workerProxy,
  init_workerProxy = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_worker_threads = require("worker_threads");
    init_localImportContext();
    init_neighboringFiles();
    __name(sleep, "sleep");
    workerFns = ["getNeighborSnippets", "extractLocalImportContext", "sleep"], WorkerProxy = class {
      constructor() {
        this.nextHandlerId = 0;
        this.handlers = new Map();
        this.fns = new Map();
        this.extractLocalImportContext = extractLocalImportContext;
        this.getNeighborSnippets = getNeighborSnippets;
        this.sleep = sleep;
        !Kf.isMainThread && Kf.workerData?.port && (wT(), process.cwd = () => Kf.workerData.cwd, this.configureWorkerResponse(Kf.workerData.port));
      }
      static {
        __name(this, "WorkerProxy");
      }
      initWorker() {
        let {
          port1: port1,
          port2: port2
        } = new Kf.MessageChannel();
        this.port = port1, this.worker = new Kf.Worker((0, yre.resolve)(__dirname, "..", "dist", "workerProxy.js"), {
          workerData: {
            port: port2,
            cwd: process.cwd()
          },
          transferList: [port2]
        }), this.port.on("message", m => this.handleMessage(m)), this.port.on("error", e => this.handleError(e));
      }
      startThreading() {
        if (this.worker) throw new Error("Worker thread already initialized.");
        this.proxyFunctions(), this.initWorker();
      }
      stopThreading() {
        this.worker && (this.worker.terminate(), this.worker.removeAllListeners(), this.worker = void 0, this.unproxyFunctions(), this.handlers.clear());
      }
      proxyFunctions() {
        for (let fn of workerFns) this.fns.set(fn, this[fn]), this.proxy(fn);
      }
      unproxyFunctions() {
        for (let fn of workerFns) {
          let originalFn = this.fns.get(fn);
          if (originalFn) this[fn] = originalFn;else throw new Error(`Unproxy function not found: ${fn}`);
        }
      }
      configureWorkerResponse(port) {
        this.port = port, this.port.on("message", async ({
          id: id,
          fn: fn,
          args: args
        }) => {
          let proxiedFunction = this[fn];
          if (!proxiedFunction) throw new Error(`Function not found: ${fn}`);
          try {
            let res = await proxiedFunction.apply(this, args);
            this.port.postMessage({
              id: id,
              res: res
            });
          } catch (err) {
            if (!(err instanceof Error)) throw err;
            typeof err.code == "string" ? this.port.postMessage({
              id: id,
              err: err,
              code: err.code
            }) : this.port.postMessage({
              id: id,
              err: err
            });
          }
        });
      }
      handleMessage({
        id: id,
        err: err,
        code: code,
        res: res
      }) {
        let handler = this.handlers.get(id);
        handler && (this.handlers.delete(id), err ? (err.code = code, handler.reject(err)) : handler.resolve(res));
      }
      handleError(maybeError) {
        console.log(maybeError);
        let err;
        if (maybeError instanceof Error) {
          err = maybeError, err.code === "MODULE_NOT_FOUND" && err.message?.endsWith("workerProxy.js'") && (err = new Error("Failed to load workerProxy.js"), err.code = "CopilotPromptLoadFailure");
          let ourStack = new Error().stack;
          err.stack && ourStack?.match(/^Error\n/) && (err.stack += ourStack.replace(/^Error/, ""));
        } else maybeError?.name === "ExitStatus" && typeof maybeError.status == "number" ? (err = new Error(`workerProxy.js exited with status ${maybeError.status}`), err.code = `CopilotPromptWorkerExit${maybeError.status}`) : err = new Error(`Non-error thrown: ${maybeError}`);
        for (let handler of this.handlers.values()) handler.reject(err);
        throw err;
      }
      proxy(fn) {
        this[fn] = function (...args) {
          let id = this.nextHandlerId++;
          return new Promise((resolve, reject) => {
            this.handlers.set(id, {
              resolve: resolve,
              reject: reject
            }), this.port?.postMessage({
              id: id,
              fn: fn,
              args: args
            });
          });
        };
      }
    }, workerProxy = new WorkerProxy();
  });
function isFulfilledResult(result) {
  return result.status === "fulfilled";
}
function isRejectedResult(result) {
  return result.status === "rejected";
}
function providersSnippets(results) {
  return results.filter(isFulfilledResult).flatMap(r => r.value.snippets);
}
function providersErrors(results) {
  return results.filter(isRejectedResult).flatMap(r => r.reason);
}
function providersPerformance(results) {
  let runtimes = {},
    timeouts = {};
  return results.forEach(result => {
    isFulfilledResult(result) ? runtimes[result.value.providerType] = Math.round(result.value.runtime) : result.reason.error instanceof ProviderTimeoutError && (timeouts[result.reason.providerType] = !0);
  }), {
    runtimes: runtimes,
    timeouts: timeouts
  };
}
var TIMEOUT_MS,
  defaultProviders,
  SnippetOrchestrator,
  init_orchestrator = __esmMin(() => {
    "use strict";

    init_language();
    init_localImportContext();
    init_neighborFiles();
    init_path();
    init_snippetProvider();
    init_workerProxy();
    TIMEOUT_MS = 300, defaultProviders = [LanguageSnippetProvider, PathSnippetProvider, NeighborFilesProvider, LocalImportContextSnippetProvider];
    __name(isFulfilledResult, "isFulfilledResult");
    __name(isRejectedResult, "isRejectedResult");
    __name(providersSnippets, "providersSnippets");
    __name(providersErrors, "providersErrors");
    __name(providersPerformance, "providersPerformance");
    SnippetOrchestrator = class {
      constructor(providers = defaultProviders) {
        this.startThreading = () => workerProxy.startThreading();
        this.stopThreading = () => workerProxy.stopThreading();
        this.providers = providers.map(provider => new provider(workerProxy));
      }
      static {
        __name(this, "SnippetOrchestrator");
      }
      async getSnippets(context) {
        let signal = AbortSignal.timeout(TIMEOUT_MS);
        return Promise.allSettled(this.providers.map(provider => provider.getSnippets(context, signal)));
      }
    };
  });
function getLineAtOffset(text, offset) {
  let prevNewline = text.lastIndexOf(`
`, offset - 1),
    nextNewline = text.indexOf(`
`, offset);
  return nextNewline < 0 && (nextNewline = text.length), text.slice(prevNewline + 1, nextNewline);
}
function rewindToNearestNonWs(text, offset) {
  let result = offset;
  for (; result > 0 && /\s/.test(text.charAt(result - 1));) result--;
  return result;
}
function indent(nd, source) {
  let startIndex = nd.startIndex,
    lineStart = nd.startIndex - nd.startPosition.column,
    prefix = source.substring(lineStart, startIndex);
  if (/^\s*$/.test(prefix)) return prefix;
}
function outdented(fst, snd, source) {
  if (snd.startPosition.row <= fst.startPosition.row) return !1;
  let fstIndent = indent(fst, source),
    sndIndent = indent(snd, source);
  return fstIndent !== void 0 && sndIndent !== void 0 && fstIndent.startsWith(sndIndent);
}
function getBlockParser(languageId) {
  return wasmLanguageToBlockParser[languageIdToWasmLanguage(languageId)];
}
async function isEmptyBlockStart(languageId, text, offset) {
  return isSupportedLanguageId(languageId) ? getBlockParser(languageId).isEmptyBlockStart(text, offset) : !1;
}
async function isBlockBodyFinished(languageId, prefix, completion, offset) {
  if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).isBlockBodyFinished(prefix, completion, offset);
}
async function getNodeStart(languageId, text, offset) {
  if (isSupportedLanguageId(languageId)) return getBlockParser(languageId).getNodeStart(text, offset);
}
var BaseBlockParser,
  RegexBasedBlockParser,
  TreeSitterBasedBlockParser,
  wasmLanguageToBlockParser,
  init_parseBlock = __esmMin(() => {
    "use strict";

    init_parse();
    BaseBlockParser = class {
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        this.languageId = languageId;
        this.nodeMatch = nodeMatch;
        this.nodeTypesWithBlockOrStmtChild = nodeTypesWithBlockOrStmtChild;
      }
      static {
        __name(this, "BaseBlockParser");
      }
      async getNodeMatchAtPosition(text, offset, cb) {
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeToComplete = tree.rootNode.descendantForIndex(offset);
          for (; nodeToComplete;) {
            let blockNodeType = this.nodeMatch[nodeToComplete.type];
            if (blockNodeType) {
              if (!this.nodeTypesWithBlockOrStmtChild.has(nodeToComplete.type)) break;
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(nodeToComplete.type);
              if ((fieldLabel == "" ? nodeToComplete.namedChildren[0] : nodeToComplete.childForFieldName(fieldLabel))?.type == blockNodeType) break;
            }
            nodeToComplete = nodeToComplete.parent;
          }
          return nodeToComplete ? cb(nodeToComplete) : void 0;
        } finally {
          tree.delete();
        }
      }
      getNextBlockAtPosition(text, offset, cb) {
        return this.getNodeMatchAtPosition(text, offset, nodeToComplete => {
          let block = nodeToComplete.children.reverse().find(x => x.type == this.nodeMatch[nodeToComplete.type]);
          if (block) {
            if (this.languageId == "python" && block.parent) {
              let parent = block.parent.type == ":" ? block.parent.parent : block.parent,
                nextComment = parent?.nextSibling;
              for (; nextComment && nextComment.type == "comment";) {
                let commentInline = nextComment.startPosition.row == block.endPosition.row && nextComment.startPosition.column >= block.endPosition.column,
                  commentAtEnd = nextComment.startPosition.row > parent.endPosition.row && nextComment.startPosition.column > parent.startPosition.column;
                if (commentInline || commentAtEnd) block = nextComment, nextComment = nextComment.nextSibling;else break;
              }
            }
            if (!(block.endIndex >= block.tree.rootNode.endIndex - 1 && (block.hasError() || block.parent.hasError()))) return cb(block);
          }
        });
      }
      async isBlockBodyFinished(prefix, completion, offset) {
        let solution = (prefix + completion).trimEnd(),
          endIndex = await this.getNextBlockAtPosition(solution, offset, block => block.endIndex);
        if (endIndex !== void 0 && endIndex < solution.length) {
          let lengthOfBlock = endIndex - prefix.length;
          return lengthOfBlock > 0 ? lengthOfBlock : void 0;
        }
      }
      getNodeStart(text, offset) {
        let solution = text.trimEnd();
        return this.getNodeMatchAtPosition(solution, offset, block => block.startIndex);
      }
    }, RegexBasedBlockParser = class extends BaseBlockParser {
      constructor(languageId, blockEmptyMatch, lineMatch, nodeMatch, nodeTypesWithBlockOrStmtChild) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild);
        this.blockEmptyMatch = blockEmptyMatch;
        this.lineMatch = lineMatch;
      }
      static {
        __name(this, "RegexBasedBlockParser");
      }
      isBlockStart(line) {
        return this.lineMatch.test(line.trimStart());
      }
      async isBlockBodyEmpty(text, offset) {
        let res = await this.getNextBlockAtPosition(text, offset, block => {
          block.startIndex < offset && (offset = block.startIndex);
          let blockText = text.substring(offset, block.endIndex).trim();
          return blockText == "" || blockText.replace(/\s/g, "") == this.blockEmptyMatch;
        });
        return res === void 0 || res;
      }
      async isEmptyBlockStart(text, offset) {
        return offset = rewindToNearestNonWs(text, offset), this.isBlockStart(getLineAtOffset(text, offset)) && this.isBlockBodyEmpty(text, offset);
      }
    };
    __name(getLineAtOffset, "getLineAtOffset");
    __name(rewindToNearestNonWs, "rewindToNearestNonWs");
    __name(indent, "indent");
    __name(outdented, "outdented");
    TreeSitterBasedBlockParser = class extends BaseBlockParser {
      constructor(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild, startKeywords, blockNodeType, emptyStatementType, curlyBraceLanguage) {
        super(languageId, nodeMatch, nodeTypesWithBlockOrStmtChild);
        this.startKeywords = startKeywords;
        this.blockNodeType = blockNodeType;
        this.emptyStatementType = emptyStatementType;
        this.curlyBraceLanguage = curlyBraceLanguage;
      }
      static {
        __name(this, "TreeSitterBasedBlockParser");
      }
      isBlockEmpty(block, offset) {
        let trimmed = block.text.trim();
        return this.curlyBraceLanguage && (trimmed.startsWith("{") && (trimmed = trimmed.slice(1)), trimmed.endsWith("}") && (trimmed = trimmed.slice(0, -1)), trimmed = trimmed.trim()), !!(trimmed.length == 0 || this.languageId == "python" && (block.parent?.type == "class_definition" || block.parent?.type == "function_definition") && block.children.length == 1 && queryPythonIsDocstring(block.parent));
      }
      async isEmptyBlockStart(text, offset) {
        if (offset > text.length) throw new RangeError("Invalid offset");
        for (let i = offset; i < text.length && text.charAt(i) != `
`; i++) if (/\S/.test(text.charAt(i))) return !1;
        offset = rewindToNearestNonWs(text, offset);
        let tree = await parseTreeSitter(this.languageId, text);
        try {
          let nodeAtPos = tree.rootNode.descendantForIndex(offset - 1);
          if (nodeAtPos == null || this.curlyBraceLanguage && nodeAtPos.type == "}") return !1;
          if ((this.languageId == "javascript" || this.languageId == "typescript") && nodeAtPos.parent && nodeAtPos.parent.type == "object" && nodeAtPos.parent.text.trim() == "{") return !0;
          if (this.languageId == "typescript") {
            let currNode = nodeAtPos;
            for (; currNode.parent;) {
              if (currNode.type == "function_signature" || currNode.type == "method_signature") {
                let next = nodeAtPos.nextSibling;
                return next && currNode.hasError() && outdented(currNode, next, text) ? !0 : !currNode.children.find(c => c.type == ";") && currNode.endIndex <= offset;
              }
              currNode = currNode.parent;
            }
          }
          let errorNode = null,
            blockNode = null,
            blockParentNode = null,
            currNode = nodeAtPos;
          for (; currNode != null;) {
            if (currNode.type == this.blockNodeType) {
              blockNode = currNode;
              break;
            }
            if (this.nodeMatch[currNode.type]) {
              blockParentNode = currNode;
              break;
            }
            if (currNode.type == "ERROR") {
              errorNode = currNode;
              break;
            }
            currNode = currNode.parent;
          }
          if (blockNode != null) {
            if (!blockNode.parent || !this.nodeMatch[blockNode.parent.type]) return !1;
            if (this.languageId == "python") {
              let prevSibling = blockNode.previousSibling;
              if (prevSibling != null && prevSibling.hasError() && (prevSibling.text.startsWith('"""') || prevSibling.text.startsWith("'''"))) return !0;
            }
            return this.isBlockEmpty(blockNode, offset);
          }
          if (errorNode != null) {
            if (errorNode.previousSibling?.type == "module" || errorNode.previousSibling?.type == "internal_module" || errorNode.previousSibling?.type == "def") return !0;
            let children = [...errorNode.children].reverse(),
              keyword = children.find(child => this.startKeywords.includes(child.type)),
              block = children.find(child => child.type == this.blockNodeType);
            if (keyword) {
              switch (this.languageId) {
                case "python":
                  {
                    keyword.type == "try" && nodeAtPos.type == "identifier" && nodeAtPos.text.length > 4 && (block = children.find(child => child.hasError())?.children.find(child => child.type == "block"));
                    let colonNode,
                      parenCount = 0;
                    for (let child of errorNode.children) {
                      if (child.type == ":" && parenCount == 0) {
                        colonNode = child;
                        break;
                      }
                      child.type == "(" && (parenCount += 1), child.type == ")" && (parenCount -= 1);
                    }
                    if (colonNode && keyword.endIndex <= colonNode.startIndex && colonNode.nextSibling) {
                      if (keyword.type == "def") {
                        let sibling = colonNode.nextSibling;
                        if (sibling.type == '"' || sibling.type == "'" || sibling.type == "ERROR" && (sibling.text == '"""' || sibling.text == "'''")) return !0;
                      }
                      return !1;
                    }
                    break;
                  }
                case "javascript":
                  {
                    let formalParameters = children.find(child => child.type == "formal_parameters");
                    if (keyword.type == "class" && formalParameters) return !0;
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
                case "typescript":
                  {
                    let leftCurlyBrace = children.find(child => child.type == "{");
                    if (leftCurlyBrace && leftCurlyBrace.startIndex > keyword.endIndex && leftCurlyBrace.nextSibling != null || children.find(child => child.type == "do") && keyword.type == "while" || keyword.type == "=>" && keyword.nextSibling && keyword.nextSibling.type != "{") return !1;
                    break;
                  }
              }
              return block && block.startIndex > keyword.endIndex ? this.isBlockEmpty(block, offset) : !0;
            }
          }
          if (blockParentNode != null) {
            let expectedType = this.nodeMatch[blockParentNode.type],
              block = blockParentNode.children.slice().reverse().find(x => x.type == expectedType);
            if (block) return this.isBlockEmpty(block, offset);
            if (this.nodeTypesWithBlockOrStmtChild.has(blockParentNode.type)) {
              let fieldLabel = this.nodeTypesWithBlockOrStmtChild.get(blockParentNode.type),
                child = fieldLabel == "" ? blockParentNode.children[0] : blockParentNode.childForFieldName(fieldLabel);
              if (child && child.type != this.blockNodeType && child.type != this.emptyStatementType) return !1;
            }
            return !0;
          }
          return !1;
        } finally {
          tree.delete();
        }
      }
    }, wasmLanguageToBlockParser = {
      python: new TreeSitterBasedBlockParser("python", {
        class_definition: "block",
        elif_clause: "block",
        else_clause: "block",
        except_clause: "block",
        finally_clause: "block",
        for_statement: "block",
        function_definition: "block",
        if_statement: "block",
        try_statement: "block",
        while_statement: "block",
        with_statement: "block"
      }, new Map(), ["def", "class", "if", "elif", "else", "for", "while", "try", "except", "finally", "with"], "block", null, !1),
      javascript: new TreeSitterBasedBlockParser("javascript", {
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        method_definition: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        with_statement: "statement_block",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      typescript: new TreeSitterBasedBlockParser("typescript", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      tsx: new TreeSitterBasedBlockParser("typescriptreact", {
        ambient_declaration: "statement_block",
        arrow_function: "statement_block",
        catch_clause: "statement_block",
        do_statement: "statement_block",
        else_clause: "statement_block",
        finally_clause: "statement_block",
        for_in_statement: "statement_block",
        for_statement: "statement_block",
        function: "statement_block",
        function_declaration: "statement_block",
        generator_function: "statement_block",
        generator_function_declaration: "statement_block",
        if_statement: "statement_block",
        internal_module: "statement_block",
        method_definition: "statement_block",
        module: "statement_block",
        try_statement: "statement_block",
        while_statement: "statement_block",
        abstract_class_declaration: "class_body",
        class: "class_body",
        class_declaration: "class_body"
      }, new Map([["arrow_function", "body"], ["do_statement", "body"], ["else_clause", ""], ["for_in_statement", "body"], ["for_statement", "body"], ["if_statement", "consequence"], ["while_statement", "body"], ["with_statement", "body"]]), ["declare", "=>", "try", "catch", "finally", "do", "for", "if", "else", "while", "with", "function", "function*", "class"], "statement_block", "empty_statement", !0),
      go: new RegexBasedBlockParser("go", "{}", /\b(func|if|else|for)\b/, {
        communication_case: "block",
        default_case: "block",
        expression_case: "block",
        for_statement: "block",
        func_literal: "block",
        function_declaration: "block",
        if_statement: "block",
        labeled_statement: "block",
        method_declaration: "block",
        type_case: "block"
      }, new Map()),
      ruby: new RegexBasedBlockParser("ruby", "end", /\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\b|->/, {
        begin_block: "}",
        block: "}",
        end_block: "}",
        lambda: "block",
        for: "do",
        until: "do",
        while: "do",
        case: "end",
        do: "end",
        if: "end",
        method: "end",
        module: "end",
        unless: "end",
        do_block: "end"
      }, new Map())
    };
    __name(getBlockParser, "getBlockParser");
    __name(isEmptyBlockStart, "isEmptyBlockStart");
    __name(isBlockBodyFinished, "isBlockBodyFinished");
    __name(getNodeStart, "getNodeStart");
  });
var lib_exports = {};
__export(lib_exports, {
  CursorHistoryMatcher: () => CursorHistoryMatcher,
  CursorSnippetsPickingStrategy: () => CursorSnippetsPickingStrategy,
  DEFAULT_NUM_OF_SNIPPETS: () => DEFAULT_NUM_OF_SNIPPETS,
  DEFAULT_TREE_TRAVERSAL_CONFIG: () => DEFAULT_TREE_TRAVERSAL_CONFIG,
  ElidableText: () => ElidableText,
  FileSystem: () => FileSystem,
  LanguageMarkerOption: () => LanguageMarkerOption,
  LineEndingOptions: () => LineEndingOptions,
  LineWithValueAndCost: () => LineWithValueAndCost,
  LocalImportContextOption: () => LocalImportContextOption,
  MAX_EDIT_DISTANCE_LENGTH: () => MAX_EDIT_DISTANCE_LENGTH,
  MAX_PROMPT_LENGTH: () => MAX_PROMPT_LENGTH,
  NeighboringSnippetType: () => NeighboringSnippetType,
  NeighboringTabsOption: () => NeighboringTabsOption,
  PathMarkerOption: () => PathMarkerOption,
  PromptOptions: () => PromptOptions,
  ProviderTimeoutError: () => ProviderTimeoutError,
  SnippetOrchestrator: () => SnippetOrchestrator,
  SnippetPositionOption: () => SnippetPositionOption,
  SnippetProviderType: () => SnippetProviderType,
  SnippetSelectionOption: () => SnippetSelectionOption,
  SnippetSemantics: () => SnippetSemantics,
  SuffixMatchOption: () => SuffixMatchOption,
  SuffixOption: () => SuffixOption,
  SuffixStartMode: () => SuffixStartMode,
  TOKENS_RESERVED_FOR_SUFFIX_ENCODING: () => TOKENS_RESERVED_FOR_SUFFIX_ENCODING,
  TokenizerName: () => TokenizerName,
  WASMLanguage: () => WASMLanguage,
  blankNode: () => blankNode,
  buildLabelRules: () => buildLabelRules,
  clearLabels: () => clearLabels,
  clearLabelsIf: () => clearLabelsIf,
  combineClosersAndOpeners: () => combineClosersAndOpeners,
  comment: () => comment,
  commentBlockAsSingles: () => commentBlockAsSingles,
  createWorker: () => createWorker,
  cutTreeAfterLine: () => cutTreeAfterLine,
  deparseAndCutTree: () => deparseAndCutTree,
  deparseLine: () => deparseLine,
  deparseTree: () => deparseTree,
  describeTree: () => describeTree,
  duplicateTree: () => duplicateTree,
  elidableTextForDiff: () => elidableTextForDiff,
  elidableTextForSourceCode: () => elidableTextForSourceCode,
  encodeTree: () => encodeTree,
  firstLineOf: () => firstLineOf,
  flattenVirtual: () => flattenVirtual,
  foldTree: () => foldTree,
  fromTreeWithFocussedLines: () => fromTreeWithFocussedLines,
  fromTreeWithValuedLines: () => fromTreeWithValuedLines,
  getAncestorWithSiblingFunctions: () => getAncestorWithSiblingFunctions,
  getBlockCloseToken: () => getBlockCloseToken,
  getBlockParser: () => getBlockParser,
  getCallSites: () => getCallSites,
  getCursorContext: () => getCursorContext,
  getFirstPrecedingComment: () => getFirstPrecedingComment,
  getFunctionPositions: () => getFunctionPositions,
  getLanguage: () => getLanguage,
  getNodeStart: () => getNodeStart,
  getPrompt: () => getPrompt,
  getTokenizer: () => getTokenizer,
  groupBlocks: () => groupBlocks,
  isBlank: () => isBlank,
  isBlockBodyFinished: () => isBlockBodyFinished,
  isEmptyBlockStart: () => isEmptyBlockStart,
  isFunction: () => isFunction,
  isFunctionDefinition: () => isFunctionDefinition,
  isLine: () => isLine,
  isSupportedLanguageId: () => isSupportedLanguageId,
  isTop: () => isTop,
  isVirtual: () => isVirtual,
  labelLines: () => labelLines,
  labelVirtualInherited: () => labelVirtualInherited,
  languageCommentMarkers: () => languageCommentMarkers,
  languageIdToWasmLanguage: () => languageIdToWasmLanguage,
  lastLineOf: () => lastLineOf,
  lineNode: () => lineNode,
  mapLabels: () => mapLabels,
  normalizeLanguageId: () => normalizeLanguageId,
  parseRaw: () => parseRaw,
  parseTree: () => parseTree,
  parseTreeSitter: () => parseTreeSitter,
  parsesWithoutError: () => parsesWithoutError,
  providersErrors: () => providersErrors,
  providersPerformance: () => providersPerformance,
  providersSnippets: () => providersSnippets,
  queryExports: () => queryExports,
  queryFunctions: () => queryFunctions,
  queryGlobalVars: () => queryGlobalVars,
  queryImports: () => queryImports,
  queryPythonIsDocstring: () => queryPythonIsDocstring,
  rebuildTree: () => rebuildTree,
  registerLanguageSpecificParser: () => registerLanguageSpecificParser,
  resetLineNumbers: () => resetLineNumbers,
  topNode: () => topNode,
  virtualNode: () => virtualNode,
  visitTree: () => visitTree,
  visitTreeConditionally: () => visitTreeConditionally
});
function createWorker() {
  return new Are.Worker((0, Ire.resolve)(__dirname, "..", "dist", "worker.js"), {
    workerData: {
      cwd: process.cwd()
    }
  });
}
var import_path,
  import_worker_threads,
  init_lib = __esmMin(() => {
    "use strict";

    import_path = require("path"), import_worker_threads = require("worker_threads");
    init_elidableText();
    init_fileSystem();
    init_indentation();
    init_languageMarker();
    init_orchestrator();
    init_parse();
    init_parseBlock();
    init_prompt();
    init_cursorContext();
    init_cursorMatching();
    init_neighboringFiles();
    init_selectRelevance();
    init_snippets();
    init_snippetProvider();
    init_tokenization();
    __name(createWorker, "createWorker");
  });
var require_balanced_match = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = balanced;
  function balanced(a, b, str) {
    a instanceof RegExp && (a = maybeMatch(a, str)), b instanceof RegExp && (b = maybeMatch(b, str));
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  __name(balanced, "balanced");
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  __name(maybeMatch, "maybeMatch");
  balanced.range = range;
  function range(a, b, str) {
    var begs,
      beg,
      left,
      right,
      result,
      ai = str.indexOf(a),
      bi = str.indexOf(b, ai + 1),
      i = ai;
    if (ai >= 0 && bi > 0) {
      for (begs = [], left = str.length; i >= 0 && !result;) i == ai ? (begs.push(i), ai = str.indexOf(a, i + 1)) : begs.length == 1 ? result = [begs.pop(), bi] : (beg = begs.pop(), beg < left && (left = beg, right = bi), bi = str.indexOf(b, i + 1)), i = ai < bi && ai >= 0 ? ai : bi;
      begs.length && (result = [left, right]);
    }
    return result;
  }
  __name(range, "range");
});
var require_brace_expansion = __commonJSMin((exports, module) => {
  var balanced = Xre();
  module.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0",
    escOpen = "\0OPEN" + Math.random() + "\0",
    escClose = "\0CLOSE" + Math.random() + "\0",
    escComma = "\0COMMA" + Math.random() + "\0",
    escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  __name(numeric, "numeric");
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  __name(escapeBraces, "escapeBraces");
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  __name(unescapeBraces, "unescapeBraces");
  function parseCommaParts(str) {
    if (!str) return [""];
    var parts = [],
      m = balanced("{", "}", str);
    if (!m) return str.split(",");
    var pre = m.pre,
      body = m.body,
      post = m.post,
      p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    return post.length && (p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts)), parts.push.apply(parts, p), parts;
  }
  __name(parseCommaParts, "parseCommaParts");
  function expandTop(str) {
    return str ? (str.substr(0, 2) === "{}" && (str = "\\{\\}" + str.substr(2)), expand(escapeBraces(str), !0).map(unescapeBraces)) : [];
  }
  __name(expandTop, "expandTop");
  function embrace(str) {
    return "{" + str + "}";
  }
  __name(embrace, "embrace");
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  __name(isPadded, "isPadded");
  function lte(i, y) {
    return i <= y;
  }
  __name(lte, "lte");
  function gte(i, y) {
    return i >= y;
  }
  __name(gte, "gte");
  function expand(str, isTop) {
    var expansions = [],
      m = balanced("{", "}", str);
    if (!m) return [str];
    var pre = m.pre,
      post = m.post.length ? expand(m.post, !1) : [""];
    if (/\$$/.test(m.pre)) for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body),
        isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body),
        isSequence = isNumericSequence || isAlphaSequence,
        isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) return m.post.match(/,.*\}/) ? (str = m.pre + "{" + m.body + escClose + m.post, expand(str)) : [str];
      var n;
      if (isSequence) n = m.body.split(/\.\./);else if (n = parseCommaParts(m.body), n.length === 1 && (n = expand(n[0], !1).map(embrace), n.length === 1)) return post.map(function (p) {
        return m.pre + n[0] + p;
      });
      var N;
      if (isSequence) {
        var x = numeric(n[0]),
          y = numeric(n[1]),
          width = Math.max(n[0].length, n[1].length),
          incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1,
          test = lte,
          reverse = y < x;
        reverse && (incr *= -1, test = gte);
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) c = String.fromCharCode(i), c === "\\" && (c = "");else if (c = String(i), pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              i < 0 ? c = "-" + z + c.slice(1) : c = z + c;
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0; j < n.length; j++) N.push.apply(N, expand(n[j], !1));
      }
      for (var j = 0; j < N.length; j++) for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        (!isTop || isSequence || expansion) && expansions.push(expansion);
      }
    }
    return expansions;
  }
  __name(expand, "expand");
});
var require_pointer = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;
  var ValuePointerRootSetError = class extends Error {
    static {
      __name(this, "ValuePointerRootSetError");
    }
    constructor(value, path, update) {
      super("ValuePointer: Cannot set root value"), this.value = value, this.path = path, this.update = update;
    }
  };
  exports.ValuePointerRootSetError = ValuePointerRootSetError;
  var ValuePointerRootDeleteError = class extends Error {
    static {
      __name(this, "ValuePointerRootDeleteError");
    }
    constructor(value, path) {
      super("ValuePointer: Cannot delete root value"), this.value = value, this.path = path;
    }
  };
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  var ValuePointer;
  (function (ValuePointer) {
    function Escape(component) {
      return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    __name(Escape, "Escape");
    function* Format(pointer) {
      if (pointer === "") return;
      let [start, end] = [0, 0];
      for (let i = 0; i < pointer.length; i++) pointer.charAt(i) === "/" ? (i === 0 || (end = i, yield Escape(pointer.slice(start, end))), start = i + 1) : end = i;
      yield Escape(pointer.slice(start));
    }
    __name(Format, "Format"), ValuePointer.Format = Format;
    function Set(value, pointer, update) {
      if (pointer === "") throw new ValuePointerRootSetError(value, pointer, update);
      let [owner, next, key] = [null, value, ""];
      for (let component of Format(pointer)) next[component] === void 0 && (next[component] = {}), owner = next, next = next[component], key = component;
      owner[key] = update;
    }
    __name(Set, "Set"), ValuePointer.Set = Set;
    function Delete(value, pointer) {
      if (pointer === "") throw new ValuePointerRootDeleteError(value, pointer);
      let [owner, next, key] = [null, value, ""];
      for (let component of Format(pointer)) {
        if (next[component] === void 0 || next[component] === null) return;
        owner = next, next = next[component], key = component;
      }
      if (Array.isArray(owner)) {
        let index = parseInt(key);
        owner.splice(index, 1);
      } else delete owner[key];
    }
    __name(Delete, "Delete"), ValuePointer.Delete = Delete;
    function Has(value, pointer) {
      if (pointer === "") return !0;
      let [owner, next, key] = [null, value, ""];
      for (let component of Format(pointer)) {
        if (next[component] === void 0) return !1;
        owner = next, next = next[component], key = component;
      }
      return Object.getOwnPropertyNames(owner).includes(key);
    }
    __name(Has, "Has"), ValuePointer.Has = Has;
    function Get(value, pointer) {
      if (pointer === "") return value;
      let current = value;
      for (let component of Format(pointer)) {
        if (current[component] === void 0) return;
        current = current[component];
      }
      return current;
    }
    __name(Get, "Get"), ValuePointer.Get = Get;
  })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
});
var require_clone = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Clone = void 0;
  var ValueGuard = au();
  function ObjectType(value) {
    return [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)].reduce((acc, key) => ({
      ...acc,
      [key]: Clone(value[key])
    }), {});
  }
  __name(ObjectType, "ObjectType");
  function ArrayType(value) {
    return value.map(element => Clone(element));
  }
  __name(ArrayType, "ArrayType");
  function TypedArrayType(value) {
    return value.slice();
  }
  __name(TypedArrayType, "TypedArrayType");
  function DateType(value) {
    return new Date(value.toISOString());
  }
  __name(DateType, "DateType");
  function Clone(value) {
    if (ValueGuard.IsArray(value)) return ArrayType(value);
    if (ValueGuard.IsAsyncIterator(value)) return value;
    if (ValueGuard.IsFunction(value)) return value;
    if (ValueGuard.IsIterator(value)) return value;
    if (ValueGuard.IsPromise(value)) return value;
    if (ValueGuard.IsDate(value)) return DateType(value);
    if (ValueGuard.IsPlainObject(value)) return ObjectType(value);
    if (ValueGuard.IsTypedArray(value)) return TypedArrayType(value);
    if (ValueGuard.IsValueType(value)) return value;
    throw new Error("ValueClone: Unable to clone value");
  }
  __name(Clone, "Clone");
  exports.Clone = Clone;
});
var require_delta = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
  var typebox_1 = ou(),
    pointer_1 = zb(),
    ValueGuard = au(),
    ValueClone = $5();
  exports.Insert = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("insert"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Update = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("update"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Delete = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("delete"),
    path: typebox_1.Type.String()
  });
  exports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);
  var ValueDeltaObjectWithSymbolKeyError = class extends Error {
    static {
      __name(this, "ValueDeltaObjectWithSymbolKeyError");
    }
    constructor(key) {
      super("ValueDelta: Cannot diff objects with symbol keys"), this.key = key;
    }
  };
  exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;
  var ValueDeltaUnableToDiffUnknownValue = class extends Error {
    static {
      __name(this, "ValueDeltaUnableToDiffUnknownValue");
    }
    constructor(value) {
      super("ValueDelta: Unable to create diff edits for unknown value"), this.value = value;
    }
  };
  exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
  function CreateUpdate(path, value) {
    return {
      type: "update",
      path: path,
      value: value
    };
  }
  __name(CreateUpdate, "CreateUpdate");
  function CreateInsert(path, value) {
    return {
      type: "insert",
      path: path,
      value: value
    };
  }
  __name(CreateInsert, "CreateInsert");
  function CreateDelete(path) {
    return {
      type: "delete",
      path: path
    };
  }
  __name(CreateDelete, "CreateDelete");
  function* ObjectType(path, current, next) {
    if (!ValueGuard.IsPlainObject(next)) return yield CreateUpdate(path, next);
    let currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)],
      nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
    for (let key of currentKeys) {
      if (ValueGuard.IsSymbol(key)) throw new ValueDeltaObjectWithSymbolKeyError(key);
      ValueGuard.IsUndefined(next[key]) && nextKeys.includes(key) && (yield CreateUpdate(`${path}/${String(key)}`, void 0));
    }
    for (let key of nextKeys) if (!(ValueGuard.IsUndefined(current[key]) || ValueGuard.IsUndefined(next[key]))) {
      if (ValueGuard.IsSymbol(key)) throw new ValueDeltaObjectWithSymbolKeyError(key);
      yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
    }
    for (let key of nextKeys) {
      if (ValueGuard.IsSymbol(key)) throw new ValueDeltaObjectWithSymbolKeyError(key);
      ValueGuard.IsUndefined(current[key]) && (yield CreateInsert(`${path}/${String(key)}`, next[key]));
    }
    for (let key of currentKeys.reverse()) {
      if (ValueGuard.IsSymbol(key)) throw new ValueDeltaObjectWithSymbolKeyError(key);
      ValueGuard.IsUndefined(next[key]) && !nextKeys.includes(key) && (yield CreateDelete(`${path}/${String(key)}`));
    }
  }
  __name(ObjectType, "ObjectType");
  function* ArrayType(path, current, next) {
    if (!ValueGuard.IsArray(next)) return yield CreateUpdate(path, next);
    for (let i = 0; i < Math.min(current.length, next.length); i++) yield* Visit(`${path}/${i}`, current[i], next[i]);
    for (let i = 0; i < next.length; i++) i < current.length || (yield CreateInsert(`${path}/${i}`, next[i]));
    for (let i = current.length - 1; i >= 0; i--) i < next.length || (yield CreateDelete(`${path}/${i}`));
  }
  __name(ArrayType, "ArrayType");
  function* TypedArrayType(path, current, next) {
    if (!ValueGuard.IsTypedArray(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name) return yield CreateUpdate(path, next);
    for (let i = 0; i < Math.min(current.length, next.length); i++) yield* Visit(`${path}/${i}`, current[i], next[i]);
  }
  __name(TypedArrayType, "TypedArrayType");
  function* ValueType(path, current, next) {
    current !== next && (yield CreateUpdate(path, next));
  }
  __name(ValueType, "ValueType");
  function* Visit(path, current, next) {
    if (ValueGuard.IsPlainObject(current)) return yield* ObjectType(path, current, next);
    if (ValueGuard.IsArray(current)) return yield* ArrayType(path, current, next);
    if (ValueGuard.IsTypedArray(current)) return yield* TypedArrayType(path, current, next);
    if (ValueGuard.IsValueType(current)) return yield* ValueType(path, current, next);
    throw new ValueDeltaUnableToDiffUnknownValue(current);
  }
  __name(Visit, "Visit");
  function Diff(current, next) {
    return [...Visit("", current, next)];
  }
  __name(Diff, "Diff");
  exports.Diff = Diff;
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  __name(IsRootUpdate, "IsRootUpdate");
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  __name(IsIdentity, "IsIdentity");
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) return ValueClone.Clone(edits[0].value);
    if (IsIdentity(edits)) return ValueClone.Clone(current);
    let clone = ValueClone.Clone(current);
    for (let edit of edits) switch (edit.type) {
      case "insert":
        {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
      case "update":
        {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
      case "delete":
        {
          pointer_1.ValuePointer.Delete(clone, edit.path);
          break;
        }
    }
    return clone;
  }
  __name(Patch, "Patch");
  exports.Patch = Patch;
});
var require_mutate = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = void 0;
  var pointer_1 = zb(),
    ValueClone = $5(),
    ValueGuard = au(),
    ValueMutateTypeMismatchError = class extends Error {
      static {
        __name(this, "ValueMutateTypeMismatchError");
      }
      constructor() {
        super("ValueMutate: Cannot assign due type mismatch of assignable values");
      }
    };
  exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
  var ValueMutateInvalidRootMutationError = class extends Error {
    static {
      __name(this, "ValueMutateInvalidRootMutationError");
    }
    constructor() {
      super("ValueMutate: Only object and array types can be mutated at the root level");
    }
  };
  exports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
  function ObjectType(root, path, current, next) {
    if (!ValueGuard.IsPlainObject(current)) pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));else {
      let currentKeys = Object.keys(current),
        nextKeys = Object.keys(next);
      for (let currentKey of currentKeys) nextKeys.includes(currentKey) || delete current[currentKey];
      for (let nextKey of nextKeys) currentKeys.includes(nextKey) || (current[nextKey] = null);
      for (let nextKey of nextKeys) Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
  __name(ObjectType, "ObjectType");
  function ArrayType(root, path, current, next) {
    if (!ValueGuard.IsArray(current)) pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));else {
      for (let index = 0; index < next.length; index++) Visit(root, `${path}/${index}`, current[index], next[index]);
      current.splice(next.length);
    }
  }
  __name(ArrayType, "ArrayType");
  function TypedArrayType(root, path, current, next) {
    if (ValueGuard.IsTypedArray(current) && current.length === next.length) for (let i = 0; i < current.length; i++) current[i] = next[i];else pointer_1.ValuePointer.Set(root, path, ValueClone.Clone(next));
  }
  __name(TypedArrayType, "TypedArrayType");
  function ValueType(root, path, current, next) {
    current !== next && pointer_1.ValuePointer.Set(root, path, next);
  }
  __name(ValueType, "ValueType");
  function Visit(root, path, current, next) {
    if (ValueGuard.IsArray(next)) return ArrayType(root, path, current, next);
    if (ValueGuard.IsTypedArray(next)) return TypedArrayType(root, path, current, next);
    if (ValueGuard.IsPlainObject(next)) return ObjectType(root, path, current, next);
    if (ValueGuard.IsValueType(next)) return ValueType(root, path, current, next);
  }
  __name(Visit, "Visit");
  function IsNonMutableValue(value) {
    return ValueGuard.IsTypedArray(value) || ValueGuard.IsValueType(value);
  }
  __name(IsNonMutableValue, "IsNonMutableValue");
  function IsMismatchedValue(current, next) {
    return ValueGuard.IsPlainObject(current) && ValueGuard.IsArray(next) || ValueGuard.IsArray(current) && ValueGuard.IsPlainObject(next);
  }
  __name(IsMismatchedValue, "IsMismatchedValue");
  function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next)) throw new ValueMutateInvalidRootMutationError();
    if (IsMismatchedValue(current, next)) throw new ValueMutateTypeMismatchError();
    Visit(current, "", current, next);
  }
  __name(Mutate, "Mutate");
  exports.Mutate = Mutate;
});
var require_equal = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Equal = void 0;
  var ValueGuard = au();
  function ObjectType(left, right) {
    if (!ValueGuard.IsPlainObject(right)) return !1;
    let leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)],
      rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    return leftKeys.length !== rightKeys.length ? !1 : leftKeys.every(key => Equal(left[key], right[key]));
  }
  __name(ObjectType, "ObjectType");
  function DateType(left, right) {
    return ValueGuard.IsDate(right) && left.getTime() === right.getTime();
  }
  __name(DateType, "DateType");
  function ArrayType(left, right) {
    return !ValueGuard.IsArray(right) || left.length !== right.length ? !1 : left.every((value, index) => Equal(value, right[index]));
  }
  __name(ArrayType, "ArrayType");
  function TypedArrayType(left, right) {
    return !ValueGuard.IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name ? !1 : left.every((value, index) => Equal(value, right[index]));
  }
  __name(TypedArrayType, "TypedArrayType");
  function ValueType(left, right) {
    return left === right;
  }
  __name(ValueType, "ValueType");
  function Equal(left, right) {
    if (ValueGuard.IsPlainObject(left)) return ObjectType(left, right);
    if (ValueGuard.IsDate(left)) return DateType(left, right);
    if (ValueGuard.IsTypedArray(left)) return TypedArrayType(left, right);
    if (ValueGuard.IsArray(left)) return ArrayType(left, right);
    if (ValueGuard.IsValueType(left)) return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
  __name(Equal, "Equal");
  exports.Equal = Equal;
});
var require_check = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Check = exports.ValueCheckDereferenceError = exports.ValueCheckUnknownTypeError = void 0;
  var index_1 = q3(),
    Types = ou(),
    ValueGuard = au(),
    ValueHash = j3(),
    ValueCheckUnknownTypeError = class extends Error {
      static {
        __name(this, "ValueCheckUnknownTypeError");
      }
      constructor(schema) {
        super(`ValueCheck: ${schema[Types.Kind] ? `Unknown type '${schema[Types.Kind]}'` : "Unknown type"}`), this.schema = schema;
      }
    };
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  var ValueCheckDereferenceError = class extends Error {
    static {
      __name(this, "ValueCheckDereferenceError");
    }
    constructor(schema) {
      super(`ValueCheck: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.ValueCheckDereferenceError = ValueCheckDereferenceError;
  function IsAnyOrUnknown(schema) {
    return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
  }
  __name(IsAnyOrUnknown, "IsAnyOrUnknown");
  function IsDefined(value) {
    return value !== void 0;
  }
  __name(IsDefined, "IsDefined");
  function IsExactOptionalProperty(value, key) {
    return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
  }
  __name(IsExactOptionalProperty, "IsExactOptionalProperty");
  function IsObject(value) {
    let isObject = ValueGuard.IsObject(value);
    return index_1.TypeSystem.AllowArrayObjects ? isObject : isObject && !ValueGuard.IsArray(value);
  }
  __name(IsObject, "IsObject");
  function IsRecordObject(value) {
    return IsObject(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  __name(IsRecordObject, "IsRecordObject");
  function IsNumber(value) {
    let isNumber = ValueGuard.IsNumber(value);
    return index_1.TypeSystem.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  __name(IsNumber, "IsNumber");
  function IsVoid(value) {
    let isUndefined = ValueGuard.IsUndefined(value);
    return index_1.TypeSystem.AllowVoidNull ? isUndefined || value === null : isUndefined;
  }
  __name(IsVoid, "IsVoid");
  function TAny(schema, references, value) {
    return !0;
  }
  __name(TAny, "TAny");
  function TArray(schema, references, value) {
    if (!Array.isArray(value) || IsDefined(schema.minItems) && !(value.length >= schema.minItems) || IsDefined(schema.maxItems) && !(value.length <= schema.maxItems) || !value.every(value => Visit(schema.items, references, value)) || schema.uniqueItems === !0 && !function () {
      let set = new Set();
      for (let element of value) {
        let hashed = ValueHash.Hash(element);
        if (set.has(hashed)) return !1;
        set.add(hashed);
      }
      return !0;
    }()) return !1;
    if (!(IsDefined(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) return !0;
    let containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never(),
      containsCount = value.reduce((acc, value) => Visit(containsSchema, references, value) ? acc + 1 : acc, 0);
    return !(containsCount === 0 || IsNumber(schema.minContains) && containsCount < schema.minContains || IsNumber(schema.maxContains) && containsCount > schema.maxContains);
  }
  __name(TArray, "TArray");
  function TAsyncIterator(schema, references, value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  __name(TAsyncIterator, "TAsyncIterator");
  function TBigInt(schema, references, value) {
    return !(!ValueGuard.IsBigInt(value) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== BigInt(0) || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.maximum) && !(value <= schema.maximum));
  }
  __name(TBigInt, "TBigInt");
  function TBoolean(schema, references, value) {
    return typeof value == "boolean";
  }
  __name(TBoolean, "TBoolean");
  function TConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  }
  __name(TConstructor, "TConstructor");
  function TDate(schema, references, value) {
    return !(!(value instanceof Date) || !IsNumber(value.getTime()) || IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp) || IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp) || IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp) || IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp));
  }
  __name(TDate, "TDate");
  function TFunction(schema, references, value) {
    return typeof value == "function";
  }
  __name(TFunction, "TFunction");
  function TInteger(schema, references, value) {
    return !(!ValueGuard.IsInteger(value) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.maximum) && !(value <= schema.maximum));
  }
  __name(TInteger, "TInteger");
  function TIntersect(schema, references, value) {
    let check1 = schema.allOf.every(schema => Visit(schema, references, value));
    if (schema.unevaluatedProperties === !1) {
      let keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema)),
        check2 = Object.getOwnPropertyNames(value).every(key => keyPattern.test(key));
      return check1 && check2;
    } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
      let keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema)),
        check2 = Object.getOwnPropertyNames(value).every(key => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else return check1;
  }
  __name(TIntersect, "TIntersect");
  function TIterator(schema, references, value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  __name(TIterator, "TIterator");
  function TLiteral(schema, references, value) {
    return value === schema.const;
  }
  __name(TLiteral, "TLiteral");
  function TNever(schema, references, value) {
    return !1;
  }
  __name(TNever, "TNever");
  function TNot(schema, references, value) {
    return !Visit(schema.not, references, value);
  }
  __name(TNot, "TNot");
  function TNull(schema, references, value) {
    return value === null;
  }
  __name(TNull, "TNull");
  function TNumber(schema, references, value) {
    return !(!IsNumber(value) || IsDefined(schema.multipleOf) && value % schema.multipleOf !== 0 || IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum) || IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum) || IsDefined(schema.minimum) && !(value >= schema.minimum) || IsDefined(schema.maximum) && !(value <= schema.maximum));
  }
  __name(TNumber, "TNumber");
  function TObject(schema, references, value) {
    if (!IsObject(value) || IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) || IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) return !1;
    let knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (let knownKey of knownKeys) {
      let property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey]) || (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) return !1;
      } else if (IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) return !1;
    }
    if (schema.additionalProperties === !1) {
      let valueKeys = Object.getOwnPropertyNames(value);
      return schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length ? !0 : valueKeys.every(valueKey => knownKeys.includes(valueKey));
    } else return typeof schema.additionalProperties == "object" ? Object.getOwnPropertyNames(value).every(key => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key])) : !0;
  }
  __name(TObject, "TObject");
  function TPromise(schema, references, value) {
    return typeof value == "object" && typeof value.then == "function";
  }
  __name(TPromise, "TPromise");
  function TRecord(schema, references, value) {
    if (!IsRecordObject(value) || IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties) || IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) return !1;
    let [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0],
      regex = new RegExp(patternKey);
    return Object.entries(value).every(([key, value]) => regex.test(key) ? Visit(patternSchema, references, value) : typeof schema.additionalProperties == "object" ? Visit(schema.additionalProperties, references, value) : schema.additionalProperties !== !1);
  }
  __name(TRecord, "TRecord");
  function TRef(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueCheckDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TRef, "TRef");
  function TString(schema, references, value) {
    return !ValueGuard.IsString(value) || IsDefined(schema.minLength) && !(value.length >= schema.minLength) || IsDefined(schema.maxLength) && !(value.length <= schema.maxLength) || IsDefined(schema.pattern) && !new RegExp(schema.pattern).test(value) ? !1 : IsDefined(schema.format) ? Types.FormatRegistry.Has(schema.format) ? Types.FormatRegistry.Get(schema.format)(value) : !1 : !0;
  }
  __name(TString, "TString");
  function TSymbol(schema, references, value) {
    return typeof value == "symbol";
  }
  __name(TSymbol, "TSymbol");
  function TTemplateLiteral(schema, references, value) {
    return ValueGuard.IsString(value) ? new RegExp(schema.pattern).test(value) : !1;
  }
  __name(TTemplateLiteral, "TTemplateLiteral");
  function TThis(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueCheckDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TThis, "TThis");
  function TTuple(schema, references, value) {
    if (!ValueGuard.IsArray(value) || schema.items === void 0 && value.length !== 0 || value.length !== schema.maxItems) return !1;
    if (!schema.items) return !0;
    for (let i = 0; i < schema.items.length; i++) if (!Visit(schema.items[i], references, value[i])) return !1;
    return !0;
  }
  __name(TTuple, "TTuple");
  function TUndefined(schema, references, value) {
    return value === void 0;
  }
  __name(TUndefined, "TUndefined");
  function TUnion(schema, references, value) {
    return schema.anyOf.some(inner => Visit(inner, references, value));
  }
  __name(TUnion, "TUnion");
  function TUint8Array(schema, references, value) {
    return !(!(value instanceof Uint8Array) || IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength) || IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength));
  }
  __name(TUint8Array, "TUint8Array");
  function TUnknown(schema, references, value) {
    return !0;
  }
  __name(TUnknown, "TUnknown");
  function TVoid(schema, references, value) {
    return IsVoid(value);
  }
  __name(TVoid, "TVoid");
  function TKind(schema, references, value) {
    return Types.TypeRegistry.Has(schema[Types.Kind]) ? Types.TypeRegistry.Get(schema[Types.Kind])(schema, value) : !1;
  }
  __name(TKind, "TKind");
  function Visit(schema, references, value) {
    let references_ = IsDefined(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_, value);
      case "Array":
        return TArray(schema_, references_, value);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Function":
        return TFunction(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Iterator":
        return TIterator(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Not":
        return TNot(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Promise":
        return TPromise(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Uint8Array":
        return TUint8Array(schema_, references_, value);
      case "Unknown":
        return TUnknown(schema_, references_, value);
      case "Void":
        return TVoid(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueCheckUnknownTypeError(schema_);
        return TKind(schema_, references_, value);
    }
  }
  __name(Visit, "Visit");
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  __name(Check, "Check");
  exports.Check = Check;
});
var require_create = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateDereferenceError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = void 0;
  var Types = ou(),
    ValueCheck = C_(),
    ValueGuard = au(),
    ValueCreateUnknownTypeError = class extends Error {
      static {
        __name(this, "ValueCreateUnknownTypeError");
      }
      constructor(schema) {
        super("ValueCreate: Unknown type"), this.schema = schema;
      }
    };
  exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
  var ValueCreateNeverTypeError = class extends Error {
    static {
      __name(this, "ValueCreateNeverTypeError");
    }
    constructor(schema) {
      super("ValueCreate: Never types cannot be created"), this.schema = schema;
    }
  };
  exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
  var ValueCreateNotTypeError = class extends Error {
    static {
      __name(this, "ValueCreateNotTypeError");
    }
    constructor(schema) {
      super("ValueCreate: Not types must have a default value"), this.schema = schema;
    }
  };
  exports.ValueCreateNotTypeError = ValueCreateNotTypeError;
  var ValueCreateIntersectTypeError = class extends Error {
    static {
      __name(this, "ValueCreateIntersectTypeError");
    }
    constructor(schema) {
      super("ValueCreate: Intersect produced invalid value. Consider using a default value."), this.schema = schema;
    }
  };
  exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
  var ValueCreateTempateLiteralTypeError = class extends Error {
    static {
      __name(this, "ValueCreateTempateLiteralTypeError");
    }
    constructor(schema) {
      super("ValueCreate: Can only create template literal values from patterns that produce finite sequences. Consider using a default value."), this.schema = schema;
    }
  };
  exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;
  var ValueCreateDereferenceError = class extends Error {
    static {
      __name(this, "ValueCreateDereferenceError");
    }
    constructor(schema) {
      super(`ValueCreate: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.ValueCreateDereferenceError = ValueCreateDereferenceError;
  var ValueCreateRecursiveInstantiationError = class extends Error {
    static {
      __name(this, "ValueCreateRecursiveInstantiationError");
    }
    constructor(schema, recursiveMaxDepth) {
      super("ValueCreate: Value cannot be created as recursive type may produce value of infinite size. Consider using a default."), this.schema = schema, this.recursiveMaxDepth = recursiveMaxDepth;
    }
  };
  exports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
  function TAny(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : {};
  }
  __name(TAny, "TAny");
  function TArray(schema, references) {
    if (schema.uniqueItems === !0 && !ValueGuard.HasPropertyKey(schema, "default")) throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    if ("contains" in schema && !ValueGuard.HasPropertyKey(schema, "default")) throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    return "default" in schema ? schema.default : schema.minItems !== void 0 ? Array.from({
      length: schema.minItems
    }).map(item => Visit(schema.items, references)) : [];
  }
  __name(TArray, "TArray");
  function TAsyncIterator(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : async function* () {}();
  }
  __name(TAsyncIterator, "TAsyncIterator");
  function TBigInt(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : BigInt(0);
  }
  __name(TBigInt, "TBigInt");
  function TBoolean(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : !1;
  }
  __name(TBoolean, "TBoolean");
  function TConstructor(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    {
      let value = Visit(schema.returns, references);
      return typeof value == "object" && !Array.isArray(value) ? class {
        constructor() {
          for (let [key, val] of Object.entries(value)) {
            let self = this;
            self[key] = val;
          }
        }
      } : class {};
    }
  }
  __name(TConstructor, "TConstructor");
  function TDate(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.minimumTimestamp !== void 0 ? new Date(schema.minimumTimestamp) : new Date(0);
  }
  __name(TDate, "TDate");
  function TFunction(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : () => Visit(schema.returns, references);
  }
  __name(TFunction, "TFunction");
  function TInteger(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.minimum !== void 0 ? schema.minimum : 0;
  }
  __name(TInteger, "TInteger");
  function TIntersect(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    {
      let value = schema.allOf.reduce((acc, schema) => {
        let next = Visit(schema, references);
        return typeof next == "object" ? {
          ...acc,
          ...next
        } : next;
      }, {});
      if (!ValueCheck.Check(schema, references, value)) throw new ValueCreateIntersectTypeError(schema);
      return value;
    }
  }
  __name(TIntersect, "TIntersect");
  function TIterator(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : function* () {}();
  }
  __name(TIterator, "TIterator");
  function TLiteral(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.const;
  }
  __name(TLiteral, "TLiteral");
  function TNever(schema, references) {
    throw new ValueCreateNeverTypeError(schema);
  }
  __name(TNever, "TNever");
  function TNot(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    throw new ValueCreateNotTypeError(schema);
  }
  __name(TNot, "TNot");
  function TNull(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : null;
  }
  __name(TNull, "TNull");
  function TNumber(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.minimum !== void 0 ? schema.minimum : 0;
  }
  __name(TNumber, "TNumber");
  function TObject(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    {
      let required = new Set(schema.required);
      return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema]) => required.has(key) ? {
        ...acc,
        [key]: Visit(schema, references)
      } : {
        ...acc
      }, {});
    }
  }
  __name(TObject, "TObject");
  function TPromise(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : Promise.resolve(Visit(schema.item, references));
  }
  __name(TPromise, "TPromise");
  function TRecord(schema, references) {
    let [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact ? {} : keyPattern.slice(1, keyPattern.length - 1).split("|").reduce((acc, key) => ({
      ...acc,
      [key]: Visit(valueSchema, references)
    }), {});
  }
  __name(TRecord, "TRecord");
  function TRef(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    {
      let index = references.findIndex(foreign => foreign.$id === schema.$ref);
      if (index === -1) throw new ValueCreateDereferenceError(schema);
      let target = references[index];
      return Visit(target, references);
    }
  }
  __name(TRef, "TRef");
  function TString(schema, references) {
    if (schema.pattern !== void 0) {
      if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
      throw new Error("ValueCreate.String: String types with patterns must specify a default value");
    } else if (schema.format !== void 0) {
      if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
      throw new Error("ValueCreate.String: String types with formats must specify a default value");
    } else return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.minLength !== void 0 ? Array.from({
      length: schema.minLength
    }).map(() => ".").join("") : "";
  }
  __name(TString, "TString");
  function TSymbol(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : "value" in schema ? Symbol.for(schema.value) : Symbol();
  }
  __name(TSymbol, "TSymbol");
  function TTemplateLiteral(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    let expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);
    if (!Types.TemplateLiteralFinite.Check(expression)) throw new ValueCreateTempateLiteralTypeError(schema);
    return Types.TemplateLiteralGenerator.Generate(expression).next().value;
  }
  __name(TTemplateLiteral, "TTemplateLiteral");
  function TThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth) throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    {
      let index = references.findIndex(foreign => foreign.$id === schema.$ref);
      if (index === -1) throw new ValueCreateDereferenceError(schema);
      let target = references[index];
      return Visit(target, references);
    }
  }
  __name(TThis, "TThis");
  function TTuple(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.items === void 0 ? [] : Array.from({
      length: schema.minItems
    }).map((_, index) => Visit(schema.items[index], references));
  }
  __name(TTuple, "TTuple");
  function TUndefined(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
  }
  __name(TUndefined, "TUndefined");
  function TUnion(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    if (schema.anyOf.length === 0) throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    return Visit(schema.anyOf[0], references);
  }
  __name(TUnion, "TUnion");
  function TUint8Array(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : schema.minByteLength !== void 0 ? new Uint8Array(schema.minByteLength) : new Uint8Array(0);
  }
  __name(TUint8Array, "TUint8Array");
  function TUnknown(schema, references) {
    return ValueGuard.HasPropertyKey(schema, "default") ? schema.default : {};
  }
  __name(TUnknown, "TUnknown");
  function TVoid(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
  }
  __name(TVoid, "TVoid");
  function TKind(schema, references) {
    if (ValueGuard.HasPropertyKey(schema, "default")) return schema.default;
    throw new Error("ValueCreate: User defined types must specify a default value");
  }
  __name(TKind, "TKind");
  function Visit(schema, references) {
    let references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_);
      case "Array":
        return TArray(schema_, references_);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_);
      case "BigInt":
        return TBigInt(schema_, references_);
      case "Boolean":
        return TBoolean(schema_, references_);
      case "Constructor":
        return TConstructor(schema_, references_);
      case "Date":
        return TDate(schema_, references_);
      case "Function":
        return TFunction(schema_, references_);
      case "Integer":
        return TInteger(schema_, references_);
      case "Intersect":
        return TIntersect(schema_, references_);
      case "Iterator":
        return TIterator(schema_, references_);
      case "Literal":
        return TLiteral(schema_, references_);
      case "Never":
        return TNever(schema_, references_);
      case "Not":
        return TNot(schema_, references_);
      case "Null":
        return TNull(schema_, references_);
      case "Number":
        return TNumber(schema_, references_);
      case "Object":
        return TObject(schema_, references_);
      case "Promise":
        return TPromise(schema_, references_);
      case "Record":
        return TRecord(schema_, references_);
      case "Ref":
        return TRef(schema_, references_);
      case "String":
        return TString(schema_, references_);
      case "Symbol":
        return TSymbol(schema_, references_);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_);
      case "This":
        return TThis(schema_, references_);
      case "Tuple":
        return TTuple(schema_, references_);
      case "Undefined":
        return TUndefined(schema_, references_);
      case "Union":
        return TUnion(schema_, references_);
      case "Uint8Array":
        return TUint8Array(schema_, references_);
      case "Unknown":
        return TUnknown(schema_, references_);
      case "Void":
        return TVoid(schema_, references_);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueCreateUnknownTypeError(schema_);
        return TKind(schema_, references_);
    }
  }
  __name(Visit, "Visit");
  var recursiveMaxDepth = 512,
    recursiveDepth = 0;
  function Create(...args) {
    return recursiveDepth = 0, args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
  }
  __name(Create, "Create");
  exports.Create = Create;
});
var require_cast = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Cast = exports.ValueCastDereferenceError = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = exports.ValueCastReferenceTypeError = void 0;
  var Types = ou(),
    ValueCreate = IL(),
    ValueCheck = C_(),
    ValueClone = $5(),
    ValueGuard = au(),
    ValueCastReferenceTypeError = class extends Error {
      static {
        __name(this, "ValueCastReferenceTypeError");
      }
      constructor(schema) {
        super(`ValueCast: Cannot locate referenced schema with $id '${schema.$ref}'`), this.schema = schema;
      }
    };
  exports.ValueCastReferenceTypeError = ValueCastReferenceTypeError;
  var ValueCastArrayUniqueItemsTypeError = class extends Error {
    static {
      __name(this, "ValueCastArrayUniqueItemsTypeError");
    }
    constructor(schema, value) {
      super("ValueCast: Array cast produced invalid data due to uniqueItems constraint"), this.schema = schema, this.value = value;
    }
  };
  exports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;
  var ValueCastNeverTypeError = class extends Error {
    static {
      __name(this, "ValueCastNeverTypeError");
    }
    constructor(schema) {
      super("ValueCast: Never types cannot be cast"), this.schema = schema;
    }
  };
  exports.ValueCastNeverTypeError = ValueCastNeverTypeError;
  var ValueCastRecursiveTypeError = class extends Error {
    static {
      __name(this, "ValueCastRecursiveTypeError");
    }
    constructor(schema) {
      super("ValueCast.Recursive: Cannot cast recursive schemas"), this.schema = schema;
    }
  };
  exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
  var ValueCastUnknownTypeError = class extends Error {
    static {
      __name(this, "ValueCastUnknownTypeError");
    }
    constructor(schema) {
      super("ValueCast: Unknown type"), this.schema = schema;
    }
  };
  exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
  var ValueCastDereferenceError = class extends Error {
    static {
      __name(this, "ValueCastDereferenceError");
    }
    constructor(schema) {
      super(`ValueCast: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.ValueCastDereferenceError = ValueCastDereferenceError;
  var UnionCastCreate;
  (function (UnionCastCreate) {
    function Score(schema, references, value) {
      if (schema[Types.Kind] === "Object" && typeof value == "object" && !ValueGuard.IsNull(value)) {
        let object = schema,
          keys = Object.getOwnPropertyNames(value),
          entries = Object.entries(object.properties),
          [point, max] = [1 / entries.length, entries.length];
        return entries.reduce((acc, [key, schema]) => {
          let literal = schema[Types.Kind] === "Literal" && schema.const === value[key] ? max : 0,
            checks = ValueCheck.Check(schema, references, value[key]) ? point : 0,
            exists = keys.includes(key) ? point : 0;
          return acc + (literal + checks + exists);
        }, 0);
      } else return ValueCheck.Check(schema, references, value) ? 1 : 0;
    }
    __name(Score, "Score");
    function Select(union, references, value) {
      let [select, best] = [union.anyOf[0], 0];
      for (let schema of union.anyOf) {
        let score = Score(schema, references, value);
        score > best && (select = schema, best = score);
      }
      return select;
    }
    __name(Select, "Select");
    function Create(union, references, value) {
      if ("default" in union) return union.default;
      {
        let schema = Select(union, references, value);
        return Cast(schema, references, value);
      }
    }
    __name(Create, "Create"), UnionCastCreate.Create = Create;
  })(UnionCastCreate || (UnionCastCreate = {}));
  function TAny(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TAny, "TAny");
  function TArray(schema, references, value) {
    if (ValueCheck.Check(schema, references, value)) return ValueClone.Clone(value);
    let created = ValueGuard.IsArray(value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references),
      minimum = ValueGuard.IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({
        length: schema.minItems - created.length
      }, () => null)] : created,
      casted = (ValueGuard.IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum).map(value => Visit(schema.items, references, value));
    if (schema.uniqueItems !== !0) return casted;
    let unique = [...new Set(casted)];
    if (!ValueCheck.Check(schema, references, unique)) throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
    return unique;
  }
  __name(TArray, "TArray");
  function TAsyncIterator(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TAsyncIterator, "TAsyncIterator");
  function TBigInt(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TBigInt, "TBigInt");
  function TBoolean(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TBoolean, "TBoolean");
  function TConstructor(schema, references, value) {
    if (ValueCheck.Check(schema, references, value)) return ValueCreate.Create(schema, references);
    let required = new Set(schema.returns.required || []),
      result = __name(function () {}, "result");
    for (let [key, property] of Object.entries(schema.returns.properties)) !required.has(key) && value.prototype[key] === void 0 || (result.prototype[key] = Visit(property, references, value.prototype[key]));
    return result;
  }
  __name(TConstructor, "TConstructor");
  function TDate(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TDate, "TDate");
  function TFunction(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TFunction, "TFunction");
  function TInteger(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TInteger, "TInteger");
  function TIntersect(schema, references, value) {
    let created = ValueCreate.Create(schema, references),
      mapped = ValueGuard.IsPlainObject(created) && ValueGuard.IsPlainObject(value) ? {
        ...created,
        ...value
      } : value;
    return ValueCheck.Check(schema, references, mapped) ? mapped : ValueCreate.Create(schema, references);
  }
  __name(TIntersect, "TIntersect");
  function TIterator(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TIterator, "TIterator");
  function TLiteral(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TLiteral, "TLiteral");
  function TNever(schema, references, value) {
    throw new ValueCastNeverTypeError(schema);
  }
  __name(TNever, "TNever");
  function TNot(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TNot, "TNot");
  function TNull(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TNull, "TNull");
  function TNumber(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TNumber, "TNumber");
  function TObject(schema, references, value) {
    if (ValueCheck.Check(schema, references, value)) return value;
    if (value === null || typeof value != "object") return ValueCreate.Create(schema, references);
    let required = new Set(schema.required || []),
      result = {};
    for (let [key, property] of Object.entries(schema.properties)) !required.has(key) && value[key] === void 0 || (result[key] = Visit(property, references, value[key]));
    if (typeof schema.additionalProperties == "object") {
      let propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (let propertyName of Object.getOwnPropertyNames(value)) propertyNames.includes(propertyName) || (result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]));
    }
    return result;
  }
  __name(TObject, "TObject");
  function TPromise(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TPromise, "TPromise");
  function TRecord(schema, references, value) {
    if (ValueCheck.Check(schema, references, value)) return ValueClone.Clone(value);
    if (value === null || typeof value != "object" || Array.isArray(value) || value instanceof Date) return ValueCreate.Create(schema, references);
    let subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0],
      subschema = schema.patternProperties[subschemaPropertyName],
      result = {};
    for (let [propKey, propValue] of Object.entries(value)) result[propKey] = Visit(subschema, references, propValue);
    return result;
  }
  __name(TRecord, "TRecord");
  function TRef(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueCastDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TRef, "TRef");
  function TString(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? value : ValueCreate.Create(schema, references);
  }
  __name(TString, "TString");
  function TSymbol(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TSymbol, "TSymbol");
  function TTemplateLiteral(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TTemplateLiteral, "TTemplateLiteral");
  function TThis(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueCastDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TThis, "TThis");
  function TTuple(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueGuard.IsArray(value) ? schema.items === void 0 ? [] : schema.items.map((schema, index) => Visit(schema, references, value[index])) : ValueCreate.Create(schema, references);
  }
  __name(TTuple, "TTuple");
  function TUndefined(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TUndefined, "TUndefined");
  function TUnion(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : UnionCastCreate.Create(schema, references, value);
  }
  __name(TUnion, "TUnion");
  function TUint8Array(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TUint8Array, "TUint8Array");
  function TUnknown(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TUnknown, "TUnknown");
  function TVoid(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TVoid, "TVoid");
  function TKind(schema, references, value) {
    return ValueCheck.Check(schema, references, value) ? ValueClone.Clone(value) : ValueCreate.Create(schema, references);
  }
  __name(TKind, "TKind");
  function Visit(schema, references, value) {
    let references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_, value);
      case "Array":
        return TArray(schema_, references_, value);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Function":
        return TFunction(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Iterator":
        return TIterator(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Not":
        return TNot(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Promise":
        return TPromise(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Uint8Array":
        return TUint8Array(schema_, references_, value);
      case "Unknown":
        return TUnknown(schema_, references_, value);
      case "Void":
        return TVoid(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueCastUnknownTypeError(schema_);
        return TKind(schema_, references_, value);
    }
  }
  __name(Visit, "Visit");
  function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  __name(Cast, "Cast");
  exports.Cast = Cast;
});
var require_convert = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Convert = exports.ValueConvertDereferenceError = exports.ValueConvertUnknownTypeError = void 0;
  var Types = ou(),
    ValueClone = $5(),
    ValueCheck = C_(),
    ValueGuard = au(),
    ValueConvertUnknownTypeError = class extends Error {
      static {
        __name(this, "ValueConvertUnknownTypeError");
      }
      constructor(schema) {
        super("ValueConvert: Unknown type"), this.schema = schema;
      }
    };
  exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
  var ValueConvertDereferenceError = class extends Error {
    static {
      __name(this, "ValueConvertDereferenceError");
    }
    constructor(schema) {
      super(`ValueConvert: Unable to dereference type with $id '${schema.$ref}'`), this.schema = schema;
    }
  };
  exports.ValueConvertDereferenceError = ValueConvertDereferenceError;
  function IsStringNumeric(value) {
    return ValueGuard.IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  __name(IsStringNumeric, "IsStringNumeric");
  function IsValueToString(value) {
    return ValueGuard.IsBigInt(value) || ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value);
  }
  __name(IsValueToString, "IsValueToString");
  function IsValueTrue(value) {
    return value === !0 || ValueGuard.IsNumber(value) && value === 1 || ValueGuard.IsBigInt(value) && value === BigInt("1") || ValueGuard.IsString(value) && (value.toLowerCase() === "true" || value === "1");
  }
  __name(IsValueTrue, "IsValueTrue");
  function IsValueFalse(value) {
    return value === !1 || ValueGuard.IsNumber(value) && value === 0 || ValueGuard.IsBigInt(value) && value === BigInt("0") || ValueGuard.IsString(value) && (value.toLowerCase() === "false" || value === "0");
  }
  __name(IsValueFalse, "IsValueFalse");
  function IsTimeStringWithTimeZone(value) {
    return ValueGuard.IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  __name(IsTimeStringWithTimeZone, "IsTimeStringWithTimeZone");
  function IsTimeStringWithoutTimeZone(value) {
    return ValueGuard.IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  __name(IsTimeStringWithoutTimeZone, "IsTimeStringWithoutTimeZone");
  function IsDateTimeStringWithTimeZone(value) {
    return ValueGuard.IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  __name(IsDateTimeStringWithTimeZone, "IsDateTimeStringWithTimeZone");
  function IsDateTimeStringWithoutTimeZone(value) {
    return ValueGuard.IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  __name(IsDateTimeStringWithoutTimeZone, "IsDateTimeStringWithoutTimeZone");
  function IsDateString(value) {
    return ValueGuard.IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  __name(IsDateString, "IsDateString");
  function TryConvertLiteralString(value, target) {
    let conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  }
  __name(TryConvertLiteralString, "TryConvertLiteralString");
  function TryConvertLiteralNumber(value, target) {
    let conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  }
  __name(TryConvertLiteralNumber, "TryConvertLiteralNumber");
  function TryConvertLiteralBoolean(value, target) {
    let conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  }
  __name(TryConvertLiteralBoolean, "TryConvertLiteralBoolean");
  function TryConvertLiteral(schema, value) {
    return typeof schema.const == "string" ? TryConvertLiteralString(value, schema.const) : typeof schema.const == "number" ? TryConvertLiteralNumber(value, schema.const) : typeof schema.const == "boolean" ? TryConvertLiteralBoolean(value, schema.const) : ValueClone.Clone(value);
  }
  __name(TryConvertLiteral, "TryConvertLiteral");
  function TryConvertBoolean(value) {
    return IsValueTrue(value) ? !0 : IsValueFalse(value) ? !1 : value;
  }
  __name(TryConvertBoolean, "TryConvertBoolean");
  function TryConvertBigInt(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : ValueGuard.IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? 0 : IsValueTrue(value) ? 1 : value;
  }
  __name(TryConvertBigInt, "TryConvertBigInt");
  function TryConvertString(value) {
    return IsValueToString(value) ? value.toString() : ValueGuard.IsSymbol(value) && value.description !== void 0 ? value.description.toString() : value;
  }
  __name(TryConvertString, "TryConvertString");
  function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  __name(TryConvertNumber, "TryConvertNumber");
  function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : ValueGuard.IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  __name(TryConvertInteger, "TryConvertInteger");
  function TryConvertNull(value) {
    return ValueGuard.IsString(value) && value.toLowerCase() === "null" ? null : value;
  }
  __name(TryConvertNull, "TryConvertNull");
  function TryConvertUndefined(value) {
    return ValueGuard.IsString(value) && value === "undefined" ? void 0 : value;
  }
  __name(TryConvertUndefined, "TryConvertUndefined");
  function TryConvertDate(value) {
    return ValueGuard.IsDate(value) ? value : ValueGuard.IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  __name(TryConvertDate, "TryConvertDate");
  function TAny(schema, references, value) {
    return value;
  }
  __name(TAny, "TAny");
  function TArray(schema, references, value) {
    return ValueGuard.IsArray(value) ? value.map(value => Visit(schema.items, references, value)) : value;
  }
  __name(TArray, "TArray");
  function TAsyncIterator(schema, references, value) {
    return value;
  }
  __name(TAsyncIterator, "TAsyncIterator");
  function TBigInt(schema, references, value) {
    return TryConvertBigInt(value);
  }
  __name(TBigInt, "TBigInt");
  function TBoolean(schema, references, value) {
    return TryConvertBoolean(value);
  }
  __name(TBoolean, "TBoolean");
  function TConstructor(schema, references, value) {
    return ValueClone.Clone(value);
  }
  __name(TConstructor, "TConstructor");
  function TDate(schema, references, value) {
    return TryConvertDate(value);
  }
  __name(TDate, "TDate");
  function TFunction(schema, references, value) {
    return value;
  }
  __name(TFunction, "TFunction");
  function TInteger(schema, references, value) {
    return TryConvertInteger(value);
  }
  __name(TInteger, "TInteger");
  function TIntersect(schema, references, value) {
    return value;
  }
  __name(TIntersect, "TIntersect");
  function TIterator(schema, references, value) {
    return value;
  }
  __name(TIterator, "TIterator");
  function TLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
  }
  __name(TLiteral, "TLiteral");
  function TNever(schema, references, value) {
    return value;
  }
  __name(TNever, "TNever");
  function TNull(schema, references, value) {
    return TryConvertNull(value);
  }
  __name(TNull, "TNull");
  function TNumber(schema, references, value) {
    return TryConvertNumber(value);
  }
  __name(TNumber, "TNumber");
  function TObject(schema, references, value) {
    return ValueGuard.IsObject(value) ? Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => value[key] !== void 0 ? {
      ...acc,
      [key]: Visit(schema.properties[key], references, value[key])
    } : {
      ...acc
    }, value) : value;
  }
  __name(TObject, "TObject");
  function TPromise(schema, references, value) {
    return value;
  }
  __name(TPromise, "TPromise");
  function TRecord(schema, references, value) {
    let propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0],
      property = schema.patternProperties[propertyKey],
      result = {};
    for (let [propKey, propValue] of Object.entries(value)) result[propKey] = Visit(property, references, propValue);
    return result;
  }
  __name(TRecord, "TRecord");
  function TRef(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueConvertDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TRef, "TRef");
  function TString(schema, references, value) {
    return TryConvertString(value);
  }
  __name(TString, "TString");
  function TSymbol(schema, references, value) {
    return value;
  }
  __name(TSymbol, "TSymbol");
  function TTemplateLiteral(schema, references, value) {
    return value;
  }
  __name(TTemplateLiteral, "TTemplateLiteral");
  function TThis(schema, references, value) {
    let index = references.findIndex(foreign => foreign.$id === schema.$ref);
    if (index === -1) throw new ValueConvertDereferenceError(schema);
    let target = references[index];
    return Visit(target, references, value);
  }
  __name(TThis, "TThis");
  function TTuple(schema, references, value) {
    return ValueGuard.IsArray(value) && !ValueGuard.IsUndefined(schema.items) ? value.map((value, index) => index < schema.items.length ? Visit(schema.items[index], references, value) : value) : value;
  }
  __name(TTuple, "TTuple");
  function TUndefined(schema, references, value) {
    return TryConvertUndefined(value);
  }
  __name(TUndefined, "TUndefined");
  function TUnion(schema, references, value) {
    for (let subschema of schema.anyOf) {
      let converted = Visit(subschema, references, value);
      if (ValueCheck.Check(subschema, references, converted)) return converted;
    }
    return value;
  }
  __name(TUnion, "TUnion");
  function TUint8Array(schema, references, value) {
    return value;
  }
  __name(TUint8Array, "TUint8Array");
  function TUnknown(schema, references, value) {
    return value;
  }
  __name(TUnknown, "TUnknown");
  function TVoid(schema, references, value) {
    return value;
  }
  __name(TVoid, "TVoid");
  function TKind(schema, references, value) {
    return value;
  }
  __name(TKind, "TKind");
  function Visit(schema, references, value) {
    let references_ = ValueGuard.IsString(schema.$id) ? [...references, schema] : references,
      schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_, value);
      case "Array":
        return TArray(schema_, references_, value);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Function":
        return TFunction(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Iterator":
        return TIterator(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Promise":
        return TPromise(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Uint8Array":
        return TUint8Array(schema_, references_, value);
      case "Unknown":
        return TUnknown(schema_, references_, value);
      case "Void":
        return TVoid(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueConvertUnknownTypeError(schema_);
        return TKind(schema_, references_, value);
    }
  }
  __name(Visit, "Visit");
  function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
  __name(Convert, "Convert");
  exports.Convert = Convert;
});
var require_value = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Value = void 0;
  var ValueErrors = $3(),
    ValueMutate = xne(),
    ValueHash = j3(),
    ValueEqual = bne(),
    ValueCast = Sne(),
    ValueClone = $5(),
    ValueConvert = Rne(),
    ValueCreate = IL(),
    ValueCheck = C_(),
    ValueDelta = TL(),
    Value;
  (function (Value) {
    function Cast(...args) {
      return ValueCast.Cast.apply(ValueCast, args);
    }
    __name(Cast, "Cast"), Value.Cast = Cast;
    function Create(...args) {
      return ValueCreate.Create.apply(ValueCreate, args);
    }
    __name(Create, "Create"), Value.Create = Create;
    function Check(...args) {
      return ValueCheck.Check.apply(ValueCheck, args);
    }
    __name(Check, "Check"), Value.Check = Check;
    function Convert(...args) {
      return ValueConvert.Convert.apply(ValueConvert, args);
    }
    __name(Convert, "Convert"), Value.Convert = Convert;
    function Clone(value) {
      return ValueClone.Clone(value);
    }
    __name(Clone, "Clone"), Value.Clone = Clone;
    function Errors(...args) {
      return ValueErrors.Errors.apply(ValueErrors, args);
    }
    __name(Errors, "Errors"), Value.Errors = Errors;
    function Equal(left, right) {
      return ValueEqual.Equal(left, right);
    }
    __name(Equal, "Equal"), Value.Equal = Equal;
    function Diff(current, next) {
      return ValueDelta.Diff(current, next);
    }
    __name(Diff, "Diff"), Value.Diff = Diff;
    function Hash(value) {
      return ValueHash.Hash(value);
    }
    __name(Hash, "Hash"), Value.Hash = Hash;
    function Patch(current, edits) {
      return ValueDelta.Patch(current, edits);
    }
    __name(Patch, "Patch"), Value.Patch = Patch;
    function Mutate(current, next) {
      ValueMutate.Mutate(current, next);
    }
    __name(Mutate, "Mutate"), Value.Mutate = Mutate;
  })(Value || (exports.Value = Value = {}));
});
var require_value = __commonJSMin(exports => {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
  var index_1 = $3();
  Object.defineProperty(exports, "ValueErrorType", {
    enumerable: !0,
    get: function () {
      return index_1.ValueErrorType;
    }
  });
  Object.defineProperty(exports, "ValueErrorIterator", {
    enumerable: !0,
    get: function () {
      return index_1.ValueErrorIterator;
    }
  });
  var delta_1 = TL();
  Object.defineProperty(exports, "Edit", {
    enumerable: !0,
    get: function () {
      return delta_1.Edit;
    }
  });
  Object.defineProperty(exports, "Insert", {
    enumerable: !0,
    get: function () {
      return delta_1.Insert;
    }
  });
  Object.defineProperty(exports, "Update", {
    enumerable: !0,
    get: function () {
      return delta_1.Update;
    }
  });
  Object.defineProperty(exports, "Delete", {
    enumerable: !0,
    get: function () {
      return delta_1.Delete;
    }
  });
  var pointer_1 = zb();
  Object.defineProperty(exports, "ValuePointer", {
    enumerable: !0,
    get: function () {
      return pointer_1.ValuePointer;
    }
  });
  var value_1 = Fne();
  Object.defineProperty(exports, "Value", {
    enumerable: !0,
    get: function () {
      return value_1.Value;
    }
  });
});
var require_fast_deep_equal = __commonJSMin((exports, module) => {
  "use strict";

  module.exports = __name(function equal(a, b) {
    if (a === b) return !0;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return !1;
      var length, i, keys;
      if (Array.isArray(a)) {
        if (length = a.length, length != b.length) return !1;
        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return !1;
        return !0;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
      if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
      for (i = length; i-- !== 0;) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return !1;
      }
      return !0;
    }
    return a !== a && b !== b;
  }, "equal");
});
var require_forge = __commonJSMin((exports, module) => {
  module.exports = {
    options: {
      usePureJavaScript: !1
    }
  };
});
var require_baseN = __commonJSMin((exports, module) => {
  var api = {};
  module.exports = api;
  var _reverseAlphabets = {};
  api.encode = function (input, alphabet, maxline) {
    if (typeof alphabet != "string") throw new TypeError('"alphabet" must be a string.');
    if (maxline !== void 0 && typeof maxline != "number") throw new TypeError('"maxline" must be a number.');
    var output = "";
    if (!(input instanceof Uint8Array)) output = _encodeWithByteBuffer(input, alphabet);else {
      var i = 0,
        base = alphabet.length,
        first = alphabet.charAt(0),
        digits = [0];
      for (i = 0; i < input.length; ++i) {
        for (var j = 0, carry = input[i]; j < digits.length; ++j) carry += digits[j] << 8, digits[j] = carry % base, carry = carry / base | 0;
        for (; carry > 0;) digits.push(carry % base), carry = carry / base | 0;
      }
      for (i = 0; input[i] === 0 && i < input.length - 1; ++i) output += first;
      for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
    }
    if (maxline) {
      var regex = new RegExp(".{1," + maxline + "}", "g");
      output = output.match(regex).join(`\r
`);
    }
    return output;
  };
  api.decode = function (input, alphabet) {
    if (typeof input != "string") throw new TypeError('"input" must be a string.');
    if (typeof alphabet != "string") throw new TypeError('"alphabet" must be a string.');
    var table = _reverseAlphabets[alphabet];
    if (!table) {
      table = _reverseAlphabets[alphabet] = [];
      for (var i = 0; i < alphabet.length; ++i) table[alphabet.charCodeAt(i)] = i;
    }
    input = input.replace(/\s/g, "");
    for (var base = alphabet.length, first = alphabet.charAt(0), bytes = [0], i = 0; i < input.length; i++) {
      var value = table[input.charCodeAt(i)];
      if (value === void 0) return;
      for (var j = 0, carry = value; j < bytes.length; ++j) carry += bytes[j] * base, bytes[j] = carry & 255, carry >>= 8;
      for (; carry > 0;) bytes.push(carry & 255), carry >>= 8;
    }
    for (var k = 0; input[k] === first && k < input.length - 1; ++k) bytes.push(0);
    return typeof Buffer < "u" ? Buffer.from(bytes.reverse()) : new Uint8Array(bytes.reverse());
  };
  function _encodeWithByteBuffer(input, alphabet) {
    var i = 0,
      base = alphabet.length,
      first = alphabet.charAt(0),
      digits = [0];
    for (i = 0; i < input.length(); ++i) {
      for (var j = 0, carry = input.at(i); j < digits.length; ++j) carry += digits[j] << 8, digits[j] = carry % base, carry = carry / base | 0;
      for (; carry > 0;) digits.push(carry % base), carry = carry / base | 0;
    }
    var output = "";
    for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) output += first;
    for (i = digits.length - 1; i >= 0; --i) output += alphabet[digits[i]];
    return output;
  }
  __name(_encodeWithByteBuffer, "_encodeWithByteBuffer");
});
var require_util = __commonJSMin((exports, module) => {
  var forge = ta(),
    baseN = Rie(),
    util = module.exports = forge.util = forge.util || {};
  (function () {
    if (typeof process < "u" && process.nextTick && !process.browser) {
      util.nextTick = process.nextTick, typeof setImmediate == "function" ? util.setImmediate = setImmediate : util.setImmediate = util.nextTick;
      return;
    }
    if (typeof setImmediate == "function") {
      util.setImmediate = function () {
        return setImmediate.apply(void 0, arguments);
      }, util.nextTick = function (callback) {
        return setImmediate(callback);
      };
      return;
    }
    if (util.setImmediate = function (callback) {
      setTimeout(callback, 0);
    }, typeof window < "u" && typeof window.postMessage == "function") {
      let handler = function (event) {
        if (event.source === window && event.data === msg) {
          event.stopPropagation();
          var copy = callbacks.slice();
          callbacks.length = 0, copy.forEach(function (callback) {
            callback();
          });
        }
      };
      var handler = c;
      __name(handler, "handler");
      var msg = "forge.setImmediate",
        callbacks = [];
      util.setImmediate = function (callback) {
        callbacks.push(callback), callbacks.length === 1 && window.postMessage(msg, "*");
      }, window.addEventListener("message", handler, !0);
    }
    if (typeof MutationObserver < "u") {
      var now = Date.now(),
        attr = !0,
        div = document.createElement("div"),
        callbacks = [];
      new MutationObserver(function () {
        var copy = callbacks.slice();
        callbacks.length = 0, copy.forEach(function (callback) {
          callback();
        });
      }).observe(div, {
        attributes: !0
      });
      var oldSetImmediate = util.setImmediate;
      util.setImmediate = function (callback) {
        Date.now() - now > 15 ? (now = Date.now(), oldSetImmediate(callback)) : (callbacks.push(callback), callbacks.length === 1 && div.setAttribute("a", attr = !attr));
      };
    }
    util.nextTick = util.setImmediate;
  })();
  util.isNodejs = typeof process < "u" && process.versions && process.versions.node;
  util.globalScope = function () {
    return util.isNodejs ? global : typeof self > "u" ? window : self;
  }();
  util.isArray = Array.isArray || function (x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  };
  util.isArrayBuffer = function (x) {
    return typeof ArrayBuffer < "u" && x instanceof ArrayBuffer;
  };
  util.isArrayBufferView = function (x) {
    return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
  };
  function _checkBitsParam(n) {
    if (!(n === 8 || n === 16 || n === 24 || n === 32)) throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
  }
  __name(_checkBitsParam, "_checkBitsParam");
  util.ByteBuffer = ByteStringBuffer;
  function ByteStringBuffer(b) {
    if (this.data = "", this.read = 0, typeof b == "string") this.data = b;else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
      if (typeof Buffer < "u" && b instanceof Buffer) this.data = b.toString("binary");else {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch {
          for (var i = 0; i < arr.length; ++i) this.putByte(arr[i]);
        }
      }
    } else (b instanceof ByteStringBuffer || typeof b == "object" && typeof b.data == "string" && typeof b.read == "number") && (this.data = b.data, this.read = b.read);
    this._constructedStringLength = 0;
  }
  __name(ByteStringBuffer, "ByteStringBuffer");
  util.ByteStringBuffer = ByteStringBuffer;
  var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
  util.ByteStringBuffer.prototype._optimizeConstructedString = function (x) {
    this._constructedStringLength += x, this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH && (this.data.substr(0, 1), this._constructedStringLength = 0);
  };
  util.ByteStringBuffer.prototype.length = function () {
    return this.data.length - this.read;
  };
  util.ByteStringBuffer.prototype.isEmpty = function () {
    return this.length() <= 0;
  };
  util.ByteStringBuffer.prototype.putByte = function (b) {
    return this.putBytes(String.fromCharCode(b));
  };
  util.ByteStringBuffer.prototype.fillWithByte = function (b, n) {
    b = String.fromCharCode(b);
    for (var d = this.data; n > 0;) n & 1 && (d += b), n >>>= 1, n > 0 && (b += b);
    return this.data = d, this._optimizeConstructedString(n), this;
  };
  util.ByteStringBuffer.prototype.putBytes = function (bytes) {
    return this.data += bytes, this._optimizeConstructedString(bytes.length), this;
  };
  util.ByteStringBuffer.prototype.putString = function (str) {
    return this.putBytes(util.encodeUtf8(str));
  };
  util.ByteStringBuffer.prototype.putInt16 = function (i) {
    return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt24 = function (i) {
    return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt32 = function (i) {
    return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt16Le = function (i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
  };
  util.ByteStringBuffer.prototype.putInt24Le = function (i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
  };
  util.ByteStringBuffer.prototype.putInt32Le = function (i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
  };
  util.ByteStringBuffer.prototype.putInt = function (i, n) {
    _checkBitsParam(n);
    var bytes = "";
    do n -= 8, bytes += String.fromCharCode(i >> n & 255); while (n > 0);
    return this.putBytes(bytes);
  };
  util.ByteStringBuffer.prototype.putSignedInt = function (i, n) {
    return i < 0 && (i += 2 << n - 1), this.putInt(i, n);
  };
  util.ByteStringBuffer.prototype.putBuffer = function (buffer) {
    return this.putBytes(buffer.getBytes());
  };
  util.ByteStringBuffer.prototype.getByte = function () {
    return this.data.charCodeAt(this.read++);
  };
  util.ByteStringBuffer.prototype.getInt16 = function () {
    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    return this.read += 2, rval;
  };
  util.ByteStringBuffer.prototype.getInt24 = function () {
    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    return this.read += 3, rval;
  };
  util.ByteStringBuffer.prototype.getInt32 = function () {
    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    return this.read += 4, rval;
  };
  util.ByteStringBuffer.prototype.getInt16Le = function () {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    return this.read += 2, rval;
  };
  util.ByteStringBuffer.prototype.getInt24Le = function () {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    return this.read += 3, rval;
  };
  util.ByteStringBuffer.prototype.getInt32Le = function () {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    return this.read += 4, rval;
  };
  util.ByteStringBuffer.prototype.getInt = function (n) {
    _checkBitsParam(n);
    var rval = 0;
    do rval = (rval << 8) + this.data.charCodeAt(this.read++), n -= 8; while (n > 0);
    return rval;
  };
  util.ByteStringBuffer.prototype.getSignedInt = function (n) {
    var x = this.getInt(n),
      max = 2 << n - 2;
    return x >= max && (x -= max << 1), x;
  };
  util.ByteStringBuffer.prototype.getBytes = function (count) {
    var rval;
    return count ? (count = Math.min(this.length(), count), rval = this.data.slice(this.read, this.read + count), this.read += count) : count === 0 ? rval = "" : (rval = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), rval;
  };
  util.ByteStringBuffer.prototype.bytes = function (count) {
    return typeof count > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.ByteStringBuffer.prototype.at = function (i) {
    return this.data.charCodeAt(this.read + i);
  };
  util.ByteStringBuffer.prototype.setAt = function (i, b) {
    return this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1), this;
  };
  util.ByteStringBuffer.prototype.last = function () {
    return this.data.charCodeAt(this.data.length - 1);
  };
  util.ByteStringBuffer.prototype.copy = function () {
    var c = util.createBuffer(this.data);
    return c.read = this.read, c;
  };
  util.ByteStringBuffer.prototype.compact = function () {
    return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
  };
  util.ByteStringBuffer.prototype.clear = function () {
    return this.data = "", this.read = 0, this;
  };
  util.ByteStringBuffer.prototype.truncate = function (count) {
    var len = Math.max(0, this.length() - count);
    return this.data = this.data.substr(this.read, len), this.read = 0, this;
  };
  util.ByteStringBuffer.prototype.toHex = function () {
    for (var rval = "", i = this.read; i < this.data.length; ++i) {
      var b = this.data.charCodeAt(i);
      b < 16 && (rval += "0"), rval += b.toString(16);
    }
    return rval;
  };
  util.ByteStringBuffer.prototype.toString = function () {
    return util.decodeUtf8(this.bytes());
  };
  function DataBuffer(b, options) {
    options = options || {}, this.read = options.readOffset || 0, this.growSize = options.growSize || 1024;
    var isArrayBuffer = util.isArrayBuffer(b),
      isArrayBufferView = util.isArrayBufferView(b);
    if (isArrayBuffer || isArrayBufferView) {
      isArrayBuffer ? this.data = new DataView(b) : this.data = new DataView(b.buffer, b.byteOffset, b.byteLength), this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
      return;
    }
    this.data = new DataView(new ArrayBuffer(0)), this.write = 0, b != null && this.putBytes(b), "writeOffset" in options && (this.write = options.writeOffset);
  }
  __name(DataBuffer, "DataBuffer");
  util.DataBuffer = DataBuffer;
  util.DataBuffer.prototype.length = function () {
    return this.write - this.read;
  };
  util.DataBuffer.prototype.isEmpty = function () {
    return this.length() <= 0;
  };
  util.DataBuffer.prototype.accommodate = function (amount, growSize) {
    if (this.length() >= amount) return this;
    growSize = Math.max(growSize || this.growSize, amount);
    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
      dst = new Uint8Array(this.length() + growSize);
    return dst.set(src), this.data = new DataView(dst.buffer), this;
  };
  util.DataBuffer.prototype.putByte = function (b) {
    return this.accommodate(1), this.data.setUint8(this.write++, b), this;
  };
  util.DataBuffer.prototype.fillWithByte = function (b, n) {
    this.accommodate(n);
    for (var i = 0; i < n; ++i) this.data.setUint8(b);
    return this;
  };
  util.DataBuffer.prototype.putBytes = function (bytes, encoding) {
    if (util.isArrayBufferView(bytes)) {
      var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength),
        len = src.byteLength - src.byteOffset;
      this.accommodate(len);
      var dst = new Uint8Array(this.data.buffer, this.write);
      return dst.set(src), this.write += len, this;
    }
    if (util.isArrayBuffer(bytes)) {
      var src = new Uint8Array(bytes);
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(this.data.buffer);
      return dst.set(src, this.write), this.write += src.byteLength, this;
    }
    if (bytes instanceof util.DataBuffer || typeof bytes == "object" && typeof bytes.read == "number" && typeof bytes.write == "number" && util.isArrayBufferView(bytes.data)) {
      var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(bytes.data.byteLength, this.write);
      return dst.set(src), this.write += src.byteLength, this;
    }
    if (bytes instanceof util.ByteStringBuffer && (bytes = bytes.data, encoding = "binary"), encoding = encoding || "binary", typeof bytes == "string") {
      var view;
      if (encoding === "hex") return this.accommodate(Math.ceil(bytes.length / 2)), view = new Uint8Array(this.data.buffer, this.write), this.write += util.binary.hex.decode(bytes, view, this.write), this;
      if (encoding === "base64") return this.accommodate(Math.ceil(bytes.length / 4) * 3), view = new Uint8Array(this.data.buffer, this.write), this.write += util.binary.base64.decode(bytes, view, this.write), this;
      if (encoding === "utf8" && (bytes = util.encodeUtf8(bytes), encoding = "binary"), encoding === "binary" || encoding === "raw") return this.accommodate(bytes.length), view = new Uint8Array(this.data.buffer, this.write), this.write += util.binary.raw.decode(view), this;
      if (encoding === "utf16") return this.accommodate(bytes.length * 2), view = new Uint16Array(this.data.buffer, this.write), this.write += util.text.utf16.encode(view), this;
      throw new Error("Invalid encoding: " + encoding);
    }
    throw Error("Invalid parameter: " + bytes);
  };
  util.DataBuffer.prototype.putBuffer = function (buffer) {
    return this.putBytes(buffer), buffer.clear(), this;
  };
  util.DataBuffer.prototype.putString = function (str) {
    return this.putBytes(str, "utf16");
  };
  util.DataBuffer.prototype.putInt16 = function (i) {
    return this.accommodate(2), this.data.setInt16(this.write, i), this.write += 2, this;
  };
  util.DataBuffer.prototype.putInt24 = function (i) {
    return this.accommodate(3), this.data.setInt16(this.write, i >> 8 & 65535), this.data.setInt8(this.write, i >> 16 & 255), this.write += 3, this;
  };
  util.DataBuffer.prototype.putInt32 = function (i) {
    return this.accommodate(4), this.data.setInt32(this.write, i), this.write += 4, this;
  };
  util.DataBuffer.prototype.putInt16Le = function (i) {
    return this.accommodate(2), this.data.setInt16(this.write, i, !0), this.write += 2, this;
  };
  util.DataBuffer.prototype.putInt24Le = function (i) {
    return this.accommodate(3), this.data.setInt8(this.write, i >> 16 & 255), this.data.setInt16(this.write, i >> 8 & 65535, !0), this.write += 3, this;
  };
  util.DataBuffer.prototype.putInt32Le = function (i) {
    return this.accommodate(4), this.data.setInt32(this.write, i, !0), this.write += 4, this;
  };
  util.DataBuffer.prototype.putInt = function (i, n) {
    _checkBitsParam(n), this.accommodate(n / 8);
    do n -= 8, this.data.setInt8(this.write++, i >> n & 255); while (n > 0);
    return this;
  };
  util.DataBuffer.prototype.putSignedInt = function (i, n) {
    return _checkBitsParam(n), this.accommodate(n / 8), i < 0 && (i += 2 << n - 1), this.putInt(i, n);
  };
  util.DataBuffer.prototype.getByte = function () {
    return this.data.getInt8(this.read++);
  };
  util.DataBuffer.prototype.getInt16 = function () {
    var rval = this.data.getInt16(this.read);
    return this.read += 2, rval;
  };
  util.DataBuffer.prototype.getInt24 = function () {
    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    return this.read += 3, rval;
  };
  util.DataBuffer.prototype.getInt32 = function () {
    var rval = this.data.getInt32(this.read);
    return this.read += 4, rval;
  };
  util.DataBuffer.prototype.getInt16Le = function () {
    var rval = this.data.getInt16(this.read, !0);
    return this.read += 2, rval;
  };
  util.DataBuffer.prototype.getInt24Le = function () {
    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
    return this.read += 3, rval;
  };
  util.DataBuffer.prototype.getInt32Le = function () {
    var rval = this.data.getInt32(this.read, !0);
    return this.read += 4, rval;
  };
  util.DataBuffer.prototype.getInt = function (n) {
    _checkBitsParam(n);
    var rval = 0;
    do rval = (rval << 8) + this.data.getInt8(this.read++), n -= 8; while (n > 0);
    return rval;
  };
  util.DataBuffer.prototype.getSignedInt = function (n) {
    var x = this.getInt(n),
      max = 2 << n - 2;
    return x >= max && (x -= max << 1), x;
  };
  util.DataBuffer.prototype.getBytes = function (count) {
    var rval;
    return count ? (count = Math.min(this.length(), count), rval = this.data.slice(this.read, this.read + count), this.read += count) : count === 0 ? rval = "" : (rval = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), rval;
  };
  util.DataBuffer.prototype.bytes = function (count) {
    return typeof count > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.DataBuffer.prototype.at = function (i) {
    return this.data.getUint8(this.read + i);
  };
  util.DataBuffer.prototype.setAt = function (i, b) {
    return this.data.setUint8(i, b), this;
  };
  util.DataBuffer.prototype.last = function () {
    return this.data.getUint8(this.write - 1);
  };
  util.DataBuffer.prototype.copy = function () {
    return new util.DataBuffer(this);
  };
  util.DataBuffer.prototype.compact = function () {
    if (this.read > 0) {
      var src = new Uint8Array(this.data.buffer, this.read),
        dst = new Uint8Array(src.byteLength);
      dst.set(src), this.data = new DataView(dst), this.write -= this.read, this.read = 0;
    }
    return this;
  };
  util.DataBuffer.prototype.clear = function () {
    return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
  };
  util.DataBuffer.prototype.truncate = function (count) {
    return this.write = Math.max(0, this.length() - count), this.read = Math.min(this.read, this.write), this;
  };
  util.DataBuffer.prototype.toHex = function () {
    for (var rval = "", i = this.read; i < this.data.byteLength; ++i) {
      var b = this.data.getUint8(i);
      b < 16 && (rval += "0"), rval += b.toString(16);
    }
    return rval;
  };
  util.DataBuffer.prototype.toString = function (encoding) {
    var view = new Uint8Array(this.data, this.read, this.length());
    if (encoding = encoding || "utf8", encoding === "binary" || encoding === "raw") return util.binary.raw.encode(view);
    if (encoding === "hex") return util.binary.hex.encode(view);
    if (encoding === "base64") return util.binary.base64.encode(view);
    if (encoding === "utf8") return util.text.utf8.decode(view);
    if (encoding === "utf16") return util.text.utf16.decode(view);
    throw new Error("Invalid encoding: " + encoding);
  };
  util.createBuffer = function (input, encoding) {
    return encoding = encoding || "raw", input !== void 0 && encoding === "utf8" && (input = util.encodeUtf8(input)), new util.ByteBuffer(input);
  };
  util.fillString = function (c, n) {
    for (var s = ""; n > 0;) n & 1 && (s += c), n >>>= 1, n > 0 && (c += c);
    return s;
  };
  util.xorBytes = function (s1, s2, n) {
    for (var s3 = "", b = "", t = "", i = 0, c = 0; n > 0; --n, ++i) b = s1.charCodeAt(i) ^ s2.charCodeAt(i), c >= 10 && (s3 += t, t = "", c = 0), t += String.fromCharCode(b), ++c;
    return s3 += t, s3;
  };
  util.hexToBytes = function (hex) {
    var rval = "",
      i = 0;
    for (hex.length & !0 && (i = 1, rval += String.fromCharCode(parseInt(hex[0], 16))); i < hex.length; i += 2) rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return rval;
  };
  util.bytesToHex = function (bytes) {
    return util.createBuffer(bytes).toHex();
  };
  util.int32ToBytes = function (i) {
    return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
  };
  var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    _base64Idx = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51],
    _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  util.encode64 = function (input, maxline) {
    for (var line = "", output = "", chr1, chr2, chr3, i = 0; i < input.length;) chr1 = input.charCodeAt(i++), chr2 = input.charCodeAt(i++), chr3 = input.charCodeAt(i++), line += _base64.charAt(chr1 >> 2), line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4), isNaN(chr2) ? line += "==" : (line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6), line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63)), maxline && line.length > maxline && (output += line.substr(0, maxline) + `\r
`, line = line.substr(maxline));
    return output += line, output;
  };
  util.decode64 = function (input) {
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    for (var output = "", enc1, enc2, enc3, enc4, i = 0; i < input.length;) enc1 = _base64Idx[input.charCodeAt(i++) - 43], enc2 = _base64Idx[input.charCodeAt(i++) - 43], enc3 = _base64Idx[input.charCodeAt(i++) - 43], enc4 = _base64Idx[input.charCodeAt(i++) - 43], output += String.fromCharCode(enc1 << 2 | enc2 >> 4), enc3 !== 64 && (output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2), enc4 !== 64 && (output += String.fromCharCode((enc3 & 3) << 6 | enc4)));
    return output;
  };
  util.encodeUtf8 = function (str) {
    return unescape(encodeURIComponent(str));
  };
  util.decodeUtf8 = function (str) {
    return decodeURIComponent(escape(str));
  };
  util.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: {
      encode: baseN.encode,
      decode: baseN.decode
    }
  };
  util.binary.raw.encode = function (bytes) {
    return String.fromCharCode.apply(null, bytes);
  };
  util.binary.raw.decode = function (str, output, offset) {
    var out = output;
    out || (out = new Uint8Array(str.length)), offset = offset || 0;
    for (var j = offset, i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
    return output ? j - offset : out;
  };
  util.binary.hex.encode = util.bytesToHex;
  util.binary.hex.decode = function (hex, output, offset) {
    var out = output;
    out || (out = new Uint8Array(Math.ceil(hex.length / 2))), offset = offset || 0;
    var i = 0,
      j = offset;
    for (hex.length & 1 && (i = 1, out[j++] = parseInt(hex[0], 16)); i < hex.length; i += 2) out[j++] = parseInt(hex.substr(i, 2), 16);
    return output ? j - offset : out;
  };
  util.binary.base64.encode = function (input, maxline) {
    for (var line = "", output = "", chr1, chr2, chr3, i = 0; i < input.byteLength;) chr1 = input[i++], chr2 = input[i++], chr3 = input[i++], line += _base64.charAt(chr1 >> 2), line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4), isNaN(chr2) ? line += "==" : (line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6), line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63)), maxline && line.length > maxline && (output += line.substr(0, maxline) + `\r
`, line = line.substr(maxline));
    return output += line, output;
  };
  util.binary.base64.decode = function (input, output, offset) {
    var out = output;
    out || (out = new Uint8Array(Math.ceil(input.length / 4) * 3)), input = input.replace(/[^A-Za-z0-9\+\/\=]/g, ""), offset = offset || 0;
    for (var enc1, enc2, enc3, enc4, i = 0, j = offset; i < input.length;) enc1 = _base64Idx[input.charCodeAt(i++) - 43], enc2 = _base64Idx[input.charCodeAt(i++) - 43], enc3 = _base64Idx[input.charCodeAt(i++) - 43], enc4 = _base64Idx[input.charCodeAt(i++) - 43], out[j++] = enc1 << 2 | enc2 >> 4, enc3 !== 64 && (out[j++] = (enc2 & 15) << 4 | enc3 >> 2, enc4 !== 64 && (out[j++] = (enc3 & 3) << 6 | enc4));
    return output ? j - offset : out.subarray(0, j);
  };
  util.binary.base58.encode = function (input, maxline) {
    return util.binary.baseN.encode(input, _base58, maxline);
  };
  util.binary.base58.decode = function (input, maxline) {
    return util.binary.baseN.decode(input, _base58, maxline);
  };
  util.text = {
    utf8: {},
    utf16: {}
  };
  util.text.utf8.encode = function (str, output, offset) {
    str = util.encodeUtf8(str);
    var out = output;
    out || (out = new Uint8Array(str.length)), offset = offset || 0;
    for (var j = offset, i = 0; i < str.length; ++i) out[j++] = str.charCodeAt(i);
    return output ? j - offset : out;
  };
  util.text.utf8.decode = function (bytes) {
    return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
  };
  util.text.utf16.encode = function (str, output, offset) {
    var out = output;
    out || (out = new Uint8Array(str.length * 2));
    var view = new Uint16Array(out.buffer);
    offset = offset || 0;
    for (var j = offset, k = offset, i = 0; i < str.length; ++i) view[k++] = str.charCodeAt(i), j += 2;
    return output ? j - offset : out;
  };
  util.text.utf16.decode = function (bytes) {
    return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
  };
  util.deflate = function (api, bytes, raw) {
    if (bytes = util.decode64(api.deflate(util.encode64(bytes)).rval), raw) {
      var start = 2,
        flg = bytes.charCodeAt(1);
      flg & 32 && (start = 6), bytes = bytes.substring(start, bytes.length - 4);
    }
    return bytes;
  };
  util.inflate = function (api, bytes, raw) {
    var rval = api.inflate(util.encode64(bytes)).rval;
    return rval === null ? null : util.decode64(rval);
  };
  var _setStorageObject = __name(function (api, id, obj) {
      if (!api) throw new Error("WebStorage not available.");
      var rval;
      if (obj === null ? rval = api.removeItem(id) : (obj = util.encode64(JSON.stringify(obj)), rval = api.setItem(id, obj)), typeof rval < "u" && rval.rval !== !0) {
        var error = new Error(rval.error.message);
        throw error.id = rval.error.id, error.name = rval.error.name, error;
      }
    }, "_setStorageObject"),
    _getStorageObject = __name(function (api, id) {
      if (!api) throw new Error("WebStorage not available.");
      var rval = api.getItem(id);
      if (api.init) if (rval.rval === null) {
        if (rval.error) {
          var error = new Error(rval.error.message);
          throw error.id = rval.error.id, error.name = rval.error.name, error;
        }
        rval = null;
      } else rval = rval.rval;
      return rval !== null && (rval = JSON.parse(util.decode64(rval))), rval;
    }, "_getStorageObject"),
    _setItem = __name(function (api, id, key, data) {
      var obj = _getStorageObject(api, id);
      obj === null && (obj = {}), obj[key] = data, _setStorageObject(api, id, obj);
    }, "_setItem"),
    _getItem = __name(function (api, id, key) {
      var rval = _getStorageObject(api, id);
      return rval !== null && (rval = key in rval ? rval[key] : null), rval;
    }, "_getItem"),
    _removeItem = __name(function (api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = !0;
        for (var prop in obj) {
          empty = !1;
          break;
        }
        empty && (obj = null), _setStorageObject(api, id, obj);
      }
    }, "_removeItem"),
    _clearItems = __name(function (api, id) {
      _setStorageObject(api, id, null);
    }, "_clearItems"),
    _callStorageFunction = __name(function (func, args, location) {
      var rval = null;
      typeof location > "u" && (location = ["web", "flash"]);
      var type,
        done = !1,
        exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) throw new Error("Flash local storage not available.");
            rval = func.apply(this, args), done = type === "flash";
          }
          (type === "web" || type === "both") && (args[0] = localStorage, rval = func.apply(this, args), done = !0);
        } catch (ex) {
          exception = ex;
        }
        if (done) break;
      }
      if (!done) throw exception;
      return rval;
    }, "_callStorageFunction");
  util.setItem = function (api, id, key, data, location) {
    _callStorageFunction(_setItem, arguments, location);
  };
  util.getItem = function (api, id, key, location) {
    return _callStorageFunction(_getItem, arguments, location);
  };
  util.removeItem = function (api, id, key, location) {
    _callStorageFunction(_removeItem, arguments, location);
  };
  util.clearItems = function (api, id, location) {
    _callStorageFunction(_clearItems, arguments, location);
  };
  util.isEmpty = function (obj) {
    for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
    return !0;
  };
  util.format = function (format) {
    for (var re = /%./g, match, part, argi = 0, parts = [], last = 0; match = re.exec(format);) {
      part = format.substring(last, re.lastIndex - 2), part.length > 0 && parts.push(part), last = re.lastIndex;
      var code = match[0][1];
      switch (code) {
        case "s":
        case "o":
          argi < arguments.length ? parts.push(arguments[argi++ + 1]) : parts.push("<?>");
          break;
        case "%":
          parts.push("%");
          break;
        default:
          parts.push("<%" + code + "?>");
      }
    }
    return parts.push(format.substring(last)), parts.join("");
  };
  util.formatNumber = function (number, decimals, dec_point, thousands_sep) {
    var n = number,
      c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals,
      d = dec_point === void 0 ? "," : dec_point,
      t = thousands_sep === void 0 ? "." : thousands_sep,
      s = n < 0 ? "-" : "",
      i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "",
      j = i.length > 3 ? i.length % 3 : 0;
    return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
  };
  util.formatSize = function (size) {
    return size >= 1073741824 ? size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB" : size >= 1048576 ? size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB" : size >= 1024 ? size = util.formatNumber(size / 1024, 0) + " KiB" : size = util.formatNumber(size, 0) + " bytes", size;
  };
  util.bytesFromIP = function (ip) {
    return ip.indexOf(".") !== -1 ? util.bytesFromIPv4(ip) : ip.indexOf(":") !== -1 ? util.bytesFromIPv6(ip) : null;
  };
  util.bytesFromIPv4 = function (ip) {
    if (ip = ip.split("."), ip.length !== 4) return null;
    for (var b = util.createBuffer(), i = 0; i < ip.length; ++i) {
      var num = parseInt(ip[i], 10);
      if (isNaN(num)) return null;
      b.putByte(num);
    }
    return b.getBytes();
  };
  util.bytesFromIPv6 = function (ip) {
    var blanks = 0;
    ip = ip.split(":").filter(function (e) {
      return e.length === 0 && ++blanks, !0;
    });
    for (var zeros = (8 - ip.length + blanks) * 2, b = util.createBuffer(), i = 0; i < 8; ++i) {
      if (!ip[i] || ip[i].length === 0) {
        b.fillWithByte(0, zeros), zeros = 0;
        continue;
      }
      var bytes = util.hexToBytes(ip[i]);
      bytes.length < 2 && b.putByte(0), b.putBytes(bytes);
    }
    return b.getBytes();
  };
  util.bytesToIP = function (bytes) {
    return bytes.length === 4 ? util.bytesToIPv4(bytes) : bytes.length === 16 ? util.bytesToIPv6(bytes) : null;
  };
  util.bytesToIPv4 = function (bytes) {
    if (bytes.length !== 4) return null;
    for (var ip = [], i = 0; i < bytes.length; ++i) ip.push(bytes.charCodeAt(i));
    return ip.join(".");
  };
  util.bytesToIPv6 = function (bytes) {
    if (bytes.length !== 16) return null;
    for (var ip = [], zeroGroups = [], zeroMaxGroup = 0, i = 0; i < bytes.length; i += 2) {
      for (var hex = util.bytesToHex(bytes[i] + bytes[i + 1]); hex[0] === "0" && hex !== "0";) hex = hex.substr(1);
      if (hex === "0") {
        var last = zeroGroups[zeroGroups.length - 1],
          idx = ip.length;
        !last || idx !== last.end + 1 ? zeroGroups.push({
          start: idx,
          end: idx
        }) : (last.end = idx, last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start && (zeroMaxGroup = zeroGroups.length - 1));
      }
      ip.push(hex);
    }
    if (zeroGroups.length > 0) {
      var group = zeroGroups[zeroMaxGroup];
      group.end - group.start > 0 && (ip.splice(group.start, group.end - group.start + 1, ""), group.start === 0 && ip.unshift(""), group.end === 7 && ip.push(""));
    }
    return ip.join(":");
  };
  util.estimateCores = function (options, callback) {
    if (typeof options == "function" && (callback = options, options = {}), options = options || {}, "cores" in util && !options.update) return callback(null, util.cores);
    if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) return util.cores = navigator.hardwareConcurrency, callback(null, util.cores);
    if (typeof Worker > "u") return util.cores = 1, callback(null, util.cores);
    if (typeof Blob > "u") return util.cores = 2, callback(null, util.cores);
    var blobUrl = URL.createObjectURL(new Blob(["(", function () {
      self.addEventListener("message", function (e) {
        for (var st = Date.now(), et = st + 4; Date.now() < et;);
        self.postMessage({
          st: st,
          et: et
        });
      });
    }.toString(), ")()"], {
      type: "application/javascript"
    }));
    sample([], 5, 16);
    function sample(max, samples, numWorkers) {
      if (samples === 0) {
        var avg = Math.floor(max.reduce(function (avg, x) {
          return avg + x;
        }, 0) / max.length);
        return util.cores = Math.max(1, avg), URL.revokeObjectURL(blobUrl), callback(null, util.cores);
      }
      map(numWorkers, function (err, results) {
        max.push(reduce(numWorkers, results)), sample(max, samples - 1, numWorkers);
      });
    }
    __name(sample, "sample");
    function map(numWorkers, callback) {
      for (var workers = [], results = [], i = 0; i < numWorkers; ++i) {
        var worker = new Worker(blobUrl);
        worker.addEventListener("message", function (e) {
          if (results.push(e.data), results.length === numWorkers) {
            for (var i = 0; i < numWorkers; ++i) workers[i].terminate();
            callback(null, results);
          }
        }), workers.push(worker);
      }
      for (var i = 0; i < numWorkers; ++i) workers[i].postMessage(i);
    }
    __name(map, "map");
    function reduce(numWorkers, results) {
      for (var overlaps = [], n = 0; n < numWorkers; ++n) for (var r1 = results[n], overlap = overlaps[n] = [], i = 0; i < numWorkers; ++i) if (n !== i) {
        var r2 = results[i];
        (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) && overlap.push(i);
      }
      return overlaps.reduce(function (max, overlap) {
        return Math.max(max, overlap.length);
      }, 0);
    }
    __name(reduce, "reduce");
  };
});
var require_cipher = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  module.exports = forge.cipher = forge.cipher || {};
  forge.cipher.algorithms = forge.cipher.algorithms || {};
  forge.cipher.createCipher = function (algorithm, key) {
    var api = algorithm;
    if (typeof api == "string" && (api = forge.cipher.getAlgorithm(api), api && (api = api())), !api) throw new Error("Unsupported algorithm: " + algorithm);
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key: key,
      decrypt: !1
    });
  };
  forge.cipher.createDecipher = function (algorithm, key) {
    var api = algorithm;
    if (typeof api == "string" && (api = forge.cipher.getAlgorithm(api), api && (api = api())), !api) throw new Error("Unsupported algorithm: " + algorithm);
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key: key,
      decrypt: !0
    });
  };
  forge.cipher.registerAlgorithm = function (name, algorithm) {
    name = name.toUpperCase(), forge.cipher.algorithms[name] = algorithm;
  };
  forge.cipher.getAlgorithm = function (name) {
    return name = name.toUpperCase(), name in forge.cipher.algorithms ? forge.cipher.algorithms[name] : null;
  };
  var BlockCipher = forge.cipher.BlockCipher = function (options) {
    this.algorithm = options.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = options.decrypt, this.algorithm.initialize(options);
  };
  BlockCipher.prototype.start = function (options) {
    options = options || {};
    var opts = {};
    for (var key in options) opts[key] = options[key];
    opts.decrypt = this._decrypt, this._finish = !1, this._input = forge.util.createBuffer(), this.output = options.output || forge.util.createBuffer(), this.mode.start(opts);
  };
  BlockCipher.prototype.update = function (input) {
    for (input && this._input.putBuffer(input); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;);
    this._input.compact();
  };
  BlockCipher.prototype.finish = function (pad) {
    pad && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function (input) {
      return pad(this.blockSize, input, !1);
    }, this.mode.unpad = function (output) {
      return pad(this.blockSize, output, !0);
    });
    var options = {};
    return options.decrypt = this._decrypt, options.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, options) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, options)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, options));
  };
});
var require_cipherModes = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  forge.cipher = forge.cipher || {};
  var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
  modes.ecb = function (options) {
    options = options || {}, this.name = "ECB", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  };
  modes.ecb.prototype.start = function (options) {};
  modes.ecb.prototype.encrypt = function (input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) return !0;
    for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
  };
  modes.ecb.prototype.decrypt = function (input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) return !0;
    for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
  };
  modes.ecb.prototype.pad = function (input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    return input.fillWithByte(padding, padding), !0;
  };
  modes.ecb.prototype.unpad = function (output, options) {
    if (options.overflow > 0) return !1;
    var len = output.length(),
      count = output.at(len - 1);
    return count > this.blockSize << 2 ? !1 : (output.truncate(count), !0);
  };
  modes.cbc = function (options) {
    options = options || {}, this.name = "CBC", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
  };
  modes.cbc.prototype.start = function (options) {
    if (options.iv === null) {
      if (!this._prev) throw new Error("Invalid IV parameter.");
      this._iv = this._prev.slice(0);
    } else if ("iv" in options) this._iv = transformIV(options.iv, this.blockSize), this._prev = this._iv.slice(0);else throw new Error("Invalid IV parameter.");
  };
  modes.cbc.prototype.encrypt = function (input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) return !0;
    for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._prev[i] ^ input.getInt32();
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i]);
    this._prev = this._outBlock;
  };
  modes.cbc.prototype.decrypt = function (input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) return !0;
    for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32();
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) output.putInt32(this._prev[i] ^ this._outBlock[i]);
    this._prev = this._inBlock.slice(0);
  };
  modes.cbc.prototype.pad = function (input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    return input.fillWithByte(padding, padding), !0;
  };
  modes.cbc.prototype.unpad = function (output, options) {
    if (options.overflow > 0) return !1;
    var len = output.length(),
      count = output.at(len - 1);
    return count > this.blockSize << 2 ? !1 : (output.truncate(count), !0);
  };
  modes.cfb = function (options) {
    options = options || {}, this.name = "CFB", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = forge.util.createBuffer(), this._partialBytes = 0;
  };
  modes.cfb.prototype.start = function (options) {
    if (!("iv" in options)) throw new Error("Invalid IV parameter.");
    this._iv = transformIV(options.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  };
  modes.cfb.prototype.encrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32() ^ this._outBlock[i], output.putInt32(this._inBlock[i]);
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    partialBytes > 0 && (partialBytes = this.blockSize - partialBytes), this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) this._partialBlock[i] = input.getInt32() ^ this._outBlock[i], this._partialOutput.putInt32(this._partialBlock[i]);
    if (partialBytes > 0) input.read -= this.blockSize;else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), partialBytes > 0 && !finish) return output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)), this._partialBytes = partialBytes, !0;
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)), this._partialBytes = 0;
  };
  modes.cfb.prototype.decrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) this._inBlock[i] = input.getInt32(), output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    partialBytes > 0 && (partialBytes = this.blockSize - partialBytes), this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) this._partialBlock[i] = input.getInt32(), this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
    if (partialBytes > 0) input.read -= this.blockSize;else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._partialBlock[i];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), partialBytes > 0 && !finish) return output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)), this._partialBytes = partialBytes, !0;
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)), this._partialBytes = 0;
  };
  modes.ofb = function (options) {
    options = options || {}, this.name = "OFB", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge.util.createBuffer(), this._partialBytes = 0;
  };
  modes.ofb.prototype.start = function (options) {
    if (!("iv" in options)) throw new Error("Invalid IV parameter.");
    this._iv = transformIV(options.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  };
  modes.ofb.prototype.encrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (input.length() === 0) return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) output.putInt32(input.getInt32() ^ this._outBlock[i]), this._inBlock[i] = this._outBlock[i];
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    partialBytes > 0 && (partialBytes = this.blockSize - partialBytes), this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    if (partialBytes > 0) input.read -= this.blockSize;else for (var i = 0; i < this._ints; ++i) this._inBlock[i] = this._outBlock[i];
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), partialBytes > 0 && !finish) return output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)), this._partialBytes = partialBytes, !0;
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)), this._partialBytes = 0;
  };
  modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
  modes.ctr = function (options) {
    options = options || {}, this.name = "CTR", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = forge.util.createBuffer(), this._partialBytes = 0;
  };
  modes.ctr.prototype.start = function (options) {
    if (!("iv" in options)) throw new Error("Invalid IV parameter.");
    this._iv = transformIV(options.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
  };
  modes.ctr.prototype.encrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && inputLength >= this.blockSize) for (var i = 0; i < this._ints; ++i) output.putInt32(input.getInt32() ^ this._outBlock[i]);else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      partialBytes > 0 && (partialBytes = this.blockSize - partialBytes), this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      if (partialBytes > 0 && (input.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), partialBytes > 0 && !finish) return output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)), this._partialBytes = partialBytes, !0;
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)), this._partialBytes = 0;
    }
    inc32(this._inBlock);
  };
  modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
  modes.gcm = function (options) {
    options = options || {}, this.name = "GCM", this.cipher = options.cipher, this.blockSize = options.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = forge.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
  };
  modes.gcm.prototype.start = function (options) {
    if (!("iv" in options)) throw new Error("Invalid IV parameter.");
    var iv = forge.util.createBuffer(options.iv);
    this._cipherLength = 0;
    var additionalData;
    if ("additionalData" in options ? additionalData = forge.util.createBuffer(options.additionalData) : additionalData = forge.util.createBuffer(), "tagLength" in options ? this._tagLength = options.tagLength : this._tagLength = 128, this._tag = null, options.decrypt && (this._tag = forge.util.createBuffer(options.tag).getBytes(), this._tag.length !== this._tagLength / 8)) throw new Error("Authentication tag does not match tag length.");
    this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var ivLength = iv.length();
    if (ivLength === 12) this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];else {
      for (this._j0 = [0, 0, 0, 0]; iv.length() > 0;) this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
    }
    this._inBlock = this._j0.slice(0), inc32(this._inBlock), this._partialBytes = 0, additionalData = forge.util.createBuffer(additionalData), this._aDataLength = from64To32(additionalData.length() * 8);
    var overflow = additionalData.length() % this.blockSize;
    for (overflow && additionalData.fillWithByte(0, this.blockSize - overflow), this._s = [0, 0, 0, 0]; additionalData.length() > 0;) this._s = this.ghash(this._hashSubkey, this._s, [additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32(), additionalData.getInt32()]);
  };
  modes.gcm.prototype.encrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) return !0;
    if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^= input.getInt32());
      this._cipherLength += this.blockSize;
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      partialBytes > 0 && (partialBytes = this.blockSize - partialBytes), this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      if (partialBytes <= 0 || finish) {
        if (finish) {
          var overflow = inputLength % this.blockSize;
          this._cipherLength += overflow, this._partialOutput.truncate(this.blockSize - overflow);
        } else this._cipherLength += this.blockSize;
        for (var i = 0; i < this._ints; ++i) this._outBlock[i] = this._partialOutput.getInt32();
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), partialBytes > 0 && !finish) return input.read -= this.blockSize, output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes)), this._partialBytes = partialBytes, !0;
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes)), this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), inc32(this._inBlock);
  };
  modes.gcm.prototype.decrypt = function (input, output, finish) {
    var inputLength = input.length();
    if (inputLength < this.blockSize && !(finish && inputLength > 0)) return !0;
    this.cipher.encrypt(this._inBlock, this._outBlock), inc32(this._inBlock), this._hashBlock[0] = input.getInt32(), this._hashBlock[1] = input.getInt32(), this._hashBlock[2] = input.getInt32(), this._hashBlock[3] = input.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var i = 0; i < this._ints; ++i) output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
    inputLength < this.blockSize ? this._cipherLength += inputLength % this.blockSize : this._cipherLength += this.blockSize;
  };
  modes.gcm.prototype.afterFinish = function (output, options) {
    var rval = !0;
    options.decrypt && options.overflow && output.truncate(this.blockSize - options.overflow), this.tag = forge.util.createBuffer();
    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
    this._s = this.ghash(this._hashSubkey, this._s, lengths);
    var tag = [];
    this.cipher.encrypt(this._j0, tag);
    for (var i = 0; i < this._ints; ++i) this.tag.putInt32(this._s[i] ^ tag[i]);
    return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), options.decrypt && this.tag.bytes() !== this._tag && (rval = !1), rval;
  };
  modes.gcm.prototype.multiply = function (x, y) {
    for (var z_i = [0, 0, 0, 0], v_i = y.slice(0), i = 0; i < 128; ++i) {
      var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
      x_i && (z_i[0] ^= v_i[0], z_i[1] ^= v_i[1], z_i[2] ^= v_i[2], z_i[3] ^= v_i[3]), this.pow(v_i, v_i);
    }
    return z_i;
  };
  modes.gcm.prototype.pow = function (x, out) {
    for (var lsb = x[3] & 1, i = 3; i > 0; --i) out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
    out[0] = x[0] >>> 1, lsb && (out[0] ^= this._R);
  };
  modes.gcm.prototype.tableMultiply = function (x) {
    for (var z = [0, 0, 0, 0], i = 0; i < 32; ++i) {
      var idx = i / 8 | 0,
        x_i = x[idx] >>> (7 - i % 8) * 4 & 15,
        ah = this._m[i][x_i];
      z[0] ^= ah[0], z[1] ^= ah[1], z[2] ^= ah[2], z[3] ^= ah[3];
    }
    return z;
  };
  modes.gcm.prototype.ghash = function (h, y, x) {
    return y[0] ^= x[0], y[1] ^= x[1], y[2] ^= x[2], y[3] ^= x[3], this.tableMultiply(y);
  };
  modes.gcm.prototype.generateHashTable = function (h, bits) {
    for (var multiplier = 8 / bits, perInt = 4 * multiplier, size = 16 * multiplier, m = new Array(size), i = 0; i < size; ++i) {
      var tmp = [0, 0, 0, 0],
        idx = i / perInt | 0,
        shft = (perInt - 1 - i % perInt) * bits;
      tmp[idx] = 1 << bits - 1 << shft, m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
    }
    return m;
  };
  modes.gcm.prototype.generateSubHashTable = function (mid, bits) {
    var size = 1 << bits,
      half = size >>> 1,
      m = new Array(size);
    m[half] = mid.slice(0);
    for (var i = half >>> 1; i > 0;) this.pow(m[2 * i], m[i] = []), i >>= 1;
    for (i = 2; i < half;) {
      for (var j = 1; j < i; ++j) {
        var m_i = m[i],
          m_j = m[j];
        m[i + j] = [m_i[0] ^ m_j[0], m_i[1] ^ m_j[1], m_i[2] ^ m_j[2], m_i[3] ^ m_j[3]];
      }
      i *= 2;
    }
    for (m[0] = [0, 0, 0, 0], i = half + 1; i < size; ++i) {
      var c = m[i ^ half];
      m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
    }
    return m;
  };
  function transformIV(iv, blockSize) {
    if (typeof iv == "string" && (iv = forge.util.createBuffer(iv)), forge.util.isArray(iv) && iv.length > 4) {
      var tmp = iv;
      iv = forge.util.createBuffer();
      for (var i = 0; i < tmp.length; ++i) iv.putByte(tmp[i]);
    }
    if (iv.length() < blockSize) throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
    if (!forge.util.isArray(iv)) {
      for (var ints = [], blocks = blockSize / 4, i = 0; i < blocks; ++i) ints.push(iv.getInt32());
      iv = ints;
    }
    return iv;
  }
  __name(transformIV, "transformIV");
  function inc32(block) {
    block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
  }
  __name(inc32, "inc32");
  function from64To32(num) {
    return [num / 4294967296 | 0, num & 4294967295];
  }
  __name(from64To32, "from64To32");
});
var require_aes = __commonJSMin((exports, module) => {
  var forge = ta();
  wE();
  XL();
  La();
  module.exports = forge.aes = forge.aes || {};
  forge.aes.startEncrypting = function (key, iv, output, mode) {
    var cipher = _createCipher({
      key: key,
      output: output,
      decrypt: !1,
      mode: mode
    });
    return cipher.start(iv), cipher;
  };
  forge.aes.createEncryptionCipher = function (key, mode) {
    return _createCipher({
      key: key,
      output: null,
      decrypt: !1,
      mode: mode
    });
  };
  forge.aes.startDecrypting = function (key, iv, output, mode) {
    var cipher = _createCipher({
      key: key,
      output: output,
      decrypt: !0,
      mode: mode
    });
    return cipher.start(iv), cipher;
  };
  forge.aes.createDecryptionCipher = function (key, mode) {
    return _createCipher({
      key: key,
      output: null,
      decrypt: !0,
      mode: mode
    });
  };
  forge.aes.Algorithm = function (name, mode) {
    init || initialize();
    var self = this;
    self.name = name, self.mode = new mode({
      blockSize: 16,
      cipher: {
        encrypt: function (inBlock, outBlock) {
          return _updateBlock(self._w, inBlock, outBlock, !1);
        },
        decrypt: function (inBlock, outBlock) {
          return _updateBlock(self._w, inBlock, outBlock, !0);
        }
      }
    }), self._init = !1;
  };
  forge.aes.Algorithm.prototype.initialize = function (options) {
    if (!this._init) {
      var key = options.key,
        tmp;
      if (typeof key == "string" && (key.length === 16 || key.length === 24 || key.length === 32)) key = forge.util.createBuffer(key);else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key, key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
      }
      if (!forge.util.isArray(key)) {
        tmp = key, key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) key.push(tmp.getInt32());
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) throw new Error("Invalid key parameter.");
      var mode = this.mode.name,
        encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp), this._init = !0;
    }
  };
  forge.aes._expandKey = function (key, decrypt) {
    return init || initialize(), _expandKey(key, decrypt);
  };
  forge.aes._updateBlock = _updateBlock;
  registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
  function registerAlgorithm(name, mode) {
    var factory = __name(function () {
      return new forge.aes.Algorithm(name, mode);
    }, "factory");
    forge.cipher.registerAlgorithm(name, factory);
  }
  __name(registerAlgorithm, "registerAlgorithm");
  var init = !1,
    Nb = 4,
    sbox,
    isbox,
    rcon,
    mix,
    imix;
  function initialize() {
    init = !0, rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    for (var xtime = new Array(256), i = 0; i < 128; ++i) xtime[i] = i << 1, xtime[i + 128] = i + 128 << 1 ^ 283;
    sbox = new Array(256), isbox = new Array(256), mix = new Array(4), imix = new Array(4);
    for (var i = 0; i < 4; ++i) mix[i] = new Array(256), imix[i] = new Array(256);
    for (var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime, i = 0; i < 256; ++i) {
      sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4, sx = sx >> 8 ^ sx & 255 ^ 99, sbox[e] = sx, isbox[sx] = e, sx2 = xtime[sx], e2 = xtime[e], e4 = xtime[e2], e8 = xtime[e4], me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2), ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
      for (var n = 0; n < 4; ++n) mix[n][e] = me, imix[n][sx] = ime, me = me << 24 | me >>> 8, ime = ime << 24 | ime >>> 8;
      e === 0 ? e = ei = 1 : (e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]], ei ^= xtime[xtime[ei]]);
    }
  }
  __name(initialize, "initialize");
  function _expandKey(key, decrypt) {
    for (var w = key.slice(0), temp, iNk = 1, Nk = w.length, Nr1 = Nk + 6 + 1, end = Nb * Nr1, i = Nk; i < end; ++i) temp = w[i - 1], i % Nk === 0 ? (temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24, iNk++) : Nk > 6 && i % Nk === 4 && (temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255]), w[i] = w[i - Nk] ^ temp;
    if (decrypt) {
      var tmp,
        m0 = imix[0],
        m1 = imix[1],
        m2 = imix[2],
        m3 = imix[3],
        wnew = w.slice(0);
      end = w.length;
      for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) if (i === 0 || i === end - Nb) wnew[i] = w[wi], wnew[i + 1] = w[wi + 3], wnew[i + 2] = w[wi + 2], wnew[i + 3] = w[wi + 1];else for (var n = 0; n < Nb; ++n) tmp = w[wi + n], wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
      w = wnew;
    }
    return w;
  }
  __name(_expandKey, "_expandKey");
  function _updateBlock(w, input, output, decrypt) {
    var Nr = w.length / 4 - 1,
      m0,
      m1,
      m2,
      m3,
      sub;
    decrypt ? (m0 = imix[0], m1 = imix[1], m2 = imix[2], m3 = imix[3], sub = isbox) : (m0 = mix[0], m1 = mix[1], m2 = mix[2], m3 = mix[3], sub = sbox);
    var a, b, c, d, a2, b2, c2;
    a = input[0] ^ w[0], b = input[decrypt ? 3 : 1] ^ w[1], c = input[2] ^ w[2], d = input[decrypt ? 1 : 3] ^ w[3];
    for (var i = 3, round = 1; round < Nr; ++round) a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i], b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i], c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i], d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i], a = a2, b = b2, c = c2;
    output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i], output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i], output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i], output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
  }
  __name(_updateBlock, "_updateBlock");
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase(),
      algorithm = "AES-" + mode,
      cipher;
    options.decrypt ? cipher = forge.cipher.createDecipher(algorithm, options.key) : cipher = forge.cipher.createCipher(algorithm, options.key);
    var start = cipher.start;
    return cipher.start = function (iv, options) {
      var output = null;
      options instanceof forge.util.ByteBuffer && (output = options, options = {}), options = options || {}, options.output = output, options.iv = iv, start.call(cipher, options);
    }, cipher;
  }
  __name(_createCipher, "_createCipher");
});
var require_oids = __commonJSMin((exports, module) => {
  var forge = ta();
  forge.pki = forge.pki || {};
  var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
  function _IN(id, name) {
    oids[id] = name, oids[name] = id;
  }
  __name(_IN, "_IN");
  function _I_(id, name) {
    oids[id] = name;
  }
  __name(_I_, "_I_");
  _IN("1.2.840.113549.1.1.1", "rsaEncryption");
  _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
  _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
  _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
  _IN("1.2.840.113549.1.1.8", "mgf1");
  _IN("1.2.840.113549.1.1.9", "pSpecified");
  _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
  _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
  _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
  _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
  _IN("1.3.101.112", "EdDSA25519");
  _IN("1.2.840.10040.4.3", "dsa-with-sha1");
  _IN("1.3.14.3.2.7", "desCBC");
  _IN("1.3.14.3.2.26", "sha1");
  _IN("1.3.14.3.2.29", "sha1WithRSASignature");
  _IN("2.16.840.1.101.3.4.2.1", "sha256");
  _IN("2.16.840.1.101.3.4.2.2", "sha384");
  _IN("2.16.840.1.101.3.4.2.3", "sha512");
  _IN("2.16.840.1.101.3.4.2.4", "sha224");
  _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
  _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
  _IN("1.2.840.113549.2.2", "md2");
  _IN("1.2.840.113549.2.5", "md5");
  _IN("1.2.840.113549.1.7.1", "data");
  _IN("1.2.840.113549.1.7.2", "signedData");
  _IN("1.2.840.113549.1.7.3", "envelopedData");
  _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
  _IN("1.2.840.113549.1.7.5", "digestedData");
  _IN("1.2.840.113549.1.7.6", "encryptedData");
  _IN("1.2.840.113549.1.9.1", "emailAddress");
  _IN("1.2.840.113549.1.9.2", "unstructuredName");
  _IN("1.2.840.113549.1.9.3", "contentType");
  _IN("1.2.840.113549.1.9.4", "messageDigest");
  _IN("1.2.840.113549.1.9.5", "signingTime");
  _IN("1.2.840.113549.1.9.6", "counterSignature");
  _IN("1.2.840.113549.1.9.7", "challengePassword");
  _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
  _IN("1.2.840.113549.1.9.14", "extensionRequest");
  _IN("1.2.840.113549.1.9.20", "friendlyName");
  _IN("1.2.840.113549.1.9.21", "localKeyId");
  _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
  _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
  _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
  _IN("1.2.840.113549.1.12.10.1.3", "certBag");
  _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
  _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
  _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
  _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
  _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
  _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
  _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
  _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
  _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
  _IN("1.2.840.113549.2.7", "hmacWithSHA1");
  _IN("1.2.840.113549.2.8", "hmacWithSHA224");
  _IN("1.2.840.113549.2.9", "hmacWithSHA256");
  _IN("1.2.840.113549.2.10", "hmacWithSHA384");
  _IN("1.2.840.113549.2.11", "hmacWithSHA512");
  _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
  _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
  _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
  _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
  _IN("2.5.4.3", "commonName");
  _IN("2.5.4.4", "surname");
  _IN("2.5.4.5", "serialNumber");
  _IN("2.5.4.6", "countryName");
  _IN("2.5.4.7", "localityName");
  _IN("2.5.4.8", "stateOrProvinceName");
  _IN("2.5.4.9", "streetAddress");
  _IN("2.5.4.10", "organizationName");
  _IN("2.5.4.11", "organizationalUnitName");
  _IN("2.5.4.12", "title");
  _IN("2.5.4.13", "description");
  _IN("2.5.4.15", "businessCategory");
  _IN("2.5.4.17", "postalCode");
  _IN("2.5.4.42", "givenName");
  _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
  _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
  _IN("2.16.840.1.113730.1.1", "nsCertType");
  _IN("2.16.840.1.113730.1.13", "nsComment");
  _I_("2.5.29.1", "authorityKeyIdentifier");
  _I_("2.5.29.2", "keyAttributes");
  _I_("2.5.29.3", "certificatePolicies");
  _I_("2.5.29.4", "keyUsageRestriction");
  _I_("2.5.29.5", "policyMapping");
  _I_("2.5.29.6", "subtreesConstraint");
  _I_("2.5.29.7", "subjectAltName");
  _I_("2.5.29.8", "issuerAltName");
  _I_("2.5.29.9", "subjectDirectoryAttributes");
  _I_("2.5.29.10", "basicConstraints");
  _I_("2.5.29.11", "nameConstraints");
  _I_("2.5.29.12", "policyConstraints");
  _I_("2.5.29.13", "basicConstraints");
  _IN("2.5.29.14", "subjectKeyIdentifier");
  _IN("2.5.29.15", "keyUsage");
  _I_("2.5.29.16", "privateKeyUsagePeriod");
  _IN("2.5.29.17", "subjectAltName");
  _IN("2.5.29.18", "issuerAltName");
  _IN("2.5.29.19", "basicConstraints");
  _I_("2.5.29.20", "cRLNumber");
  _I_("2.5.29.21", "cRLReason");
  _I_("2.5.29.22", "expirationDate");
  _I_("2.5.29.23", "instructionCode");
  _I_("2.5.29.24", "invalidityDate");
  _I_("2.5.29.25", "cRLDistributionPoints");
  _I_("2.5.29.26", "issuingDistributionPoint");
  _I_("2.5.29.27", "deltaCRLIndicator");
  _I_("2.5.29.28", "issuingDistributionPoint");
  _I_("2.5.29.29", "certificateIssuer");
  _I_("2.5.29.30", "nameConstraints");
  _IN("2.5.29.31", "cRLDistributionPoints");
  _IN("2.5.29.32", "certificatePolicies");
  _I_("2.5.29.33", "policyMappings");
  _I_("2.5.29.34", "policyConstraints");
  _IN("2.5.29.35", "authorityKeyIdentifier");
  _I_("2.5.29.36", "policyConstraints");
  _IN("2.5.29.37", "extKeyUsage");
  _I_("2.5.29.46", "freshestCRL");
  _I_("2.5.29.54", "inhibitAnyPolicy");
  _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
  _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
  _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
  _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
  _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
  _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
  _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
});
var require_asn1 = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  b1();
  var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
  asn1.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192
  };
  asn1.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30
  };
  asn1.create = function (tagClass, type, constructed, value, options) {
    if (forge.util.isArray(value)) {
      for (var tmp = [], i = 0; i < value.length; ++i) value[i] !== void 0 && tmp.push(value[i]);
      value = tmp;
    }
    var obj = {
      tagClass: tagClass,
      type: type,
      constructed: constructed,
      composed: constructed || forge.util.isArray(value),
      value: value
    };
    return options && "bitStringContents" in options && (obj.bitStringContents = options.bitStringContents, obj.original = asn1.copy(obj)), obj;
  };
  asn1.copy = function (obj, options) {
    var copy;
    if (forge.util.isArray(obj)) {
      copy = [];
      for (var i = 0; i < obj.length; ++i) copy.push(asn1.copy(obj[i], options));
      return copy;
    }
    return typeof obj == "string" ? obj : (copy = {
      tagClass: obj.tagClass,
      type: obj.type,
      constructed: obj.constructed,
      composed: obj.composed,
      value: asn1.copy(obj.value, options)
    }, options && !options.excludeBitStringContents && (copy.bitStringContents = obj.bitStringContents), copy);
  };
  asn1.equals = function (obj1, obj2, options) {
    if (forge.util.isArray(obj1)) {
      if (!forge.util.isArray(obj2) || obj1.length !== obj2.length) return !1;
      for (var i = 0; i < obj1.length; ++i) if (!asn1.equals(obj1[i], obj2[i])) return !1;
      return !0;
    }
    if (typeof obj1 != typeof obj2) return !1;
    if (typeof obj1 == "string") return obj1 === obj2;
    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
    return options && options.includeBitStringContents && (equal = equal && obj1.bitStringContents === obj2.bitStringContents), equal;
  };
  asn1.getBerValueLength = function (b) {
    var b2 = b.getByte();
    if (b2 !== 128) {
      var length,
        longForm = b2 & 128;
      return longForm ? length = b.getInt((b2 & 127) << 3) : length = b2, length;
    }
  };
  function _checkBufferLength(bytes, remaining, n) {
    if (n > remaining) {
      var error = new Error("Too few bytes to parse DER.");
      throw error.available = bytes.length(), error.remaining = remaining, error.requested = n, error;
    }
  }
  __name(_checkBufferLength, "_checkBufferLength");
  var _getValueLength = __name(function (bytes, remaining) {
    var b2 = bytes.getByte();
    if (remaining--, b2 !== 128) {
      var length,
        longForm = b2 & 128;
      if (!longForm) length = b2;else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes), length = bytes.getInt(longFormBytes << 3);
      }
      if (length < 0) throw new Error("Negative length: " + length);
      return length;
    }
  }, "_getValueLength");
  asn1.fromDer = function (bytes, options) {
    options === void 0 && (options = {
      strict: !0,
      parseAllBytes: !0,
      decodeBitStrings: !0
    }), typeof options == "boolean" && (options = {
      strict: options,
      parseAllBytes: !0,
      decodeBitStrings: !0
    }), "strict" in options || (options.strict = !0), "parseAllBytes" in options || (options.parseAllBytes = !0), "decodeBitStrings" in options || (options.decodeBitStrings = !0), typeof bytes == "string" && (bytes = forge.util.createBuffer(bytes));
    var byteCount = bytes.length(),
      value = _fromDer(bytes, bytes.length(), 0, options);
    if (options.parseAllBytes && bytes.length() !== 0) {
      var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
      throw error.byteCount = byteCount, error.remaining = bytes.length(), error;
    }
    return value;
  };
  function _fromDer(bytes, remaining, depth, options) {
    var start;
    _checkBufferLength(bytes, remaining, 2);
    var b1 = bytes.getByte();
    remaining--;
    var tagClass = b1 & 192,
      type = b1 & 31;
    start = bytes.length();
    var length = _getValueLength(bytes, remaining);
    if (remaining -= start - bytes.length(), length !== void 0 && length > remaining) {
      if (options.strict) {
        var error = new Error("Too few bytes to read ASN.1 value.");
        throw error.available = bytes.length(), error.remaining = remaining, error.requested = length, error;
      }
      length = remaining;
    }
    var value,
      bitStringContents,
      constructed = (b1 & 32) === 32;
    if (constructed) if (value = [], length === void 0) for (;;) {
      if (_checkBufferLength(bytes, remaining, 2), bytes.bytes(2) === String.fromCharCode(0, 0)) {
        bytes.getBytes(2), remaining -= 2;
        break;
      }
      start = bytes.length(), value.push(_fromDer(bytes, remaining, depth + 1, options)), remaining -= start - bytes.length();
    } else for (; length > 0;) start = bytes.length(), value.push(_fromDer(bytes, length, depth + 1, options)), remaining -= start - bytes.length(), length -= start - bytes.length();
    if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && (bitStringContents = bytes.bytes(length)), value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
      var savedRead = bytes.read,
        savedRemaining = remaining,
        unused = 0;
      if (type === asn1.Type.BITSTRING && (_checkBufferLength(bytes, remaining, 1), unused = bytes.getByte(), remaining--), unused === 0) try {
        start = bytes.length();
        var subOptions = {
            strict: !0,
            decodeBitStrings: !0
          },
          composed = _fromDer(bytes, remaining, depth + 1, subOptions),
          used = start - bytes.length();
        remaining -= used, type == asn1.Type.BITSTRING && used++;
        var tc = composed.tagClass;
        used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC) && (value = [composed]);
      } catch {}
      value === void 0 && (bytes.read = savedRead, remaining = savedRemaining);
    }
    if (value === void 0) {
      if (length === void 0) {
        if (options.strict) throw new Error("Non-constructed ASN.1 object of indefinite length.");
        length = remaining;
      }
      if (type === asn1.Type.BMPSTRING) for (value = ""; length > 0; length -= 2) _checkBufferLength(bytes, remaining, 2), value += String.fromCharCode(bytes.getInt16()), remaining -= 2;else value = bytes.getBytes(length), remaining -= length;
    }
    var asn1Options = bitStringContents === void 0 ? null : {
      bitStringContents: bitStringContents
    };
    return asn1.create(tagClass, type, constructed, value, asn1Options);
  }
  __name(_fromDer, "_fromDer");
  asn1.toDer = function (obj) {
    var bytes = forge.util.createBuffer(),
      b1 = obj.tagClass | obj.type,
      value = forge.util.createBuffer(),
      useBitStringContents = !1;
    if ("bitStringContents" in obj && (useBitStringContents = !0, obj.original && (useBitStringContents = asn1.equals(obj, obj.original))), useBitStringContents) value.putBytes(obj.bitStringContents);else if (obj.composed) {
      obj.constructed ? b1 |= 32 : value.putByte(0);
      for (var i = 0; i < obj.value.length; ++i) obj.value[i] !== void 0 && value.putBuffer(asn1.toDer(obj.value[i]));
    } else if (obj.type === asn1.Type.BMPSTRING) for (var i = 0; i < obj.value.length; ++i) value.putInt16(obj.value.charCodeAt(i));else obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && !(obj.value.charCodeAt(1) & 128) || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128) ? value.putBytes(obj.value.substr(1)) : value.putBytes(obj.value);
    if (bytes.putByte(b1), value.length() <= 127) bytes.putByte(value.length() & 127);else {
      var len = value.length(),
        lenBytes = "";
      do lenBytes += String.fromCharCode(len & 255), len = len >>> 8; while (len > 0);
      bytes.putByte(lenBytes.length | 128);
      for (var i = lenBytes.length - 1; i >= 0; --i) bytes.putByte(lenBytes.charCodeAt(i));
    }
    return bytes.putBuffer(value), bytes;
  };
  asn1.oidToDer = function (oid) {
    var values = oid.split("."),
      bytes = forge.util.createBuffer();
    bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
    for (var last, valueBytes, value, b, i = 2; i < values.length; ++i) {
      last = !0, valueBytes = [], value = parseInt(values[i], 10);
      do b = value & 127, value = value >>> 7, last || (b |= 128), valueBytes.push(b), last = !1; while (value > 0);
      for (var n = valueBytes.length - 1; n >= 0; --n) bytes.putByte(valueBytes[n]);
    }
    return bytes;
  };
  asn1.derToOid = function (bytes) {
    var oid;
    typeof bytes == "string" && (bytes = forge.util.createBuffer(bytes));
    var b = bytes.getByte();
    oid = Math.floor(b / 40) + "." + b % 40;
    for (var value = 0; bytes.length() > 0;) b = bytes.getByte(), value = value << 7, b & 128 ? value += b & 127 : (oid += "." + (value + b), value = 0);
    return oid;
  };
  asn1.utcTimeToDate = function (utc) {
    var date = new Date(),
      year = parseInt(utc.substr(0, 2), 10);
    year = year >= 50 ? 1900 + year : 2e3 + year;
    var MM = parseInt(utc.substr(2, 2), 10) - 1,
      DD = parseInt(utc.substr(4, 2), 10),
      hh = parseInt(utc.substr(6, 2), 10),
      mm = parseInt(utc.substr(8, 2), 10),
      ss = 0;
    if (utc.length > 11) {
      var c = utc.charAt(10),
        end = 10;
      c !== "+" && c !== "-" && (ss = parseInt(utc.substr(10, 2), 10), end += 2);
    }
    if (date.setUTCFullYear(year, MM, DD), date.setUTCHours(hh, mm, ss, 0), end && (c = utc.charAt(end), c === "+" || c === "-")) {
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10),
        mmoffset = parseInt(utc.substr(end + 4, 2), 10),
        offset = hhoffset * 60 + mmoffset;
      offset *= 6e4, c === "+" ? date.setTime(+date - offset) : date.setTime(+date + offset);
    }
    return date;
  };
  asn1.generalizedTimeToDate = function (gentime) {
    var date = new Date(),
      YYYY = parseInt(gentime.substr(0, 4), 10),
      MM = parseInt(gentime.substr(4, 2), 10) - 1,
      DD = parseInt(gentime.substr(6, 2), 10),
      hh = parseInt(gentime.substr(8, 2), 10),
      mm = parseInt(gentime.substr(10, 2), 10),
      ss = parseInt(gentime.substr(12, 2), 10),
      fff = 0,
      offset = 0,
      isUTC = !1;
    gentime.charAt(gentime.length - 1) === "Z" && (isUTC = !0);
    var end = gentime.length - 5,
      c = gentime.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(gentime.substr(end + 1, 2), 10),
        mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
      offset = hhoffset * 60 + mmoffset, offset *= 6e4, c === "+" && (offset *= -1), isUTC = !0;
    }
    return gentime.charAt(14) === "." && (fff = parseFloat(gentime.substr(14), 10) * 1e3), isUTC ? (date.setUTCFullYear(YYYY, MM, DD), date.setUTCHours(hh, mm, ss, fff), date.setTime(+date + offset)) : (date.setFullYear(YYYY, MM, DD), date.setHours(hh, mm, ss, fff)), date;
  };
  asn1.dateToUtcTime = function (date) {
    if (typeof date == "string") return date;
    var rval = "",
      format = [];
    format.push(("" + date.getUTCFullYear()).substr(2)), format.push("" + (date.getUTCMonth() + 1)), format.push("" + date.getUTCDate()), format.push("" + date.getUTCHours()), format.push("" + date.getUTCMinutes()), format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) format[i].length < 2 && (rval += "0"), rval += format[i];
    return rval += "Z", rval;
  };
  asn1.dateToGeneralizedTime = function (date) {
    if (typeof date == "string") return date;
    var rval = "",
      format = [];
    format.push("" + date.getUTCFullYear()), format.push("" + (date.getUTCMonth() + 1)), format.push("" + date.getUTCDate()), format.push("" + date.getUTCHours()), format.push("" + date.getUTCMinutes()), format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) format[i].length < 2 && (rval += "0"), rval += format[i];
    return rval += "Z", rval;
  };
  asn1.integerToDer = function (x) {
    var rval = forge.util.createBuffer();
    if (x >= -128 && x < 128) return rval.putSignedInt(x, 8);
    if (x >= -32768 && x < 32768) return rval.putSignedInt(x, 16);
    if (x >= -8388608 && x < 8388608) return rval.putSignedInt(x, 24);
    if (x >= -2147483648 && x < 2147483648) return rval.putSignedInt(x, 32);
    var error = new Error("Integer too large; max is 32-bits.");
    throw error.integer = x, error;
  };
  asn1.derToInteger = function (bytes) {
    typeof bytes == "string" && (bytes = forge.util.createBuffer(bytes));
    var n = bytes.length() * 8;
    if (n > 32) throw new Error("Integer too large; max is 32-bits.");
    return bytes.getSignedInt(n);
  };
  asn1.validate = function (obj, v, capture, errors) {
    var rval = !1;
    if ((obj.tagClass === v.tagClass || typeof v.tagClass > "u") && (obj.type === v.type || typeof v.type > "u")) {
      if (obj.constructed === v.constructed || typeof v.constructed > "u") {
        if (rval = !0, v.value && forge.util.isArray(v.value)) for (var j = 0, i = 0; rval && i < v.value.length; ++i) rval = v.value[i].optional || !1, obj.value[j] && (rval = asn1.validate(obj.value[j], v.value[i], capture, errors), rval ? ++j : v.value[i].optional && (rval = !0)), !rval && errors && errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
        if (rval && capture && (v.capture && (capture[v.capture] = obj.value), v.captureAsn1 && (capture[v.captureAsn1] = obj), v.captureBitStringContents && "bitStringContents" in obj && (capture[v.captureBitStringContents] = obj.bitStringContents), v.captureBitStringValue && "bitStringContents" in obj)) {
          var value;
          if (obj.bitStringContents.length < 2) capture[v.captureBitStringValue] = "";else {
            var unused = obj.bitStringContents.charCodeAt(0);
            if (unused !== 0) throw new Error("captureBitStringValue only supported for zero unused bits");
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      } else errors && errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
    } else errors && (obj.tagClass !== v.tagClass && errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'), obj.type !== v.type && errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'));
    return rval;
  };
  var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
  asn1.prettyPrint = function (obj, level, indentation) {
    var rval = "";
    level = level || 0, indentation = indentation || 2, level > 0 && (rval += `
`);
    for (var indent = "", i = 0; i < level * indentation; ++i) indent += " ";
    switch (rval += indent + "Tag: ", obj.tagClass) {
      case asn1.Class.UNIVERSAL:
        rval += "Universal:";
        break;
      case asn1.Class.APPLICATION:
        rval += "Application:";
        break;
      case asn1.Class.CONTEXT_SPECIFIC:
        rval += "Context-Specific:";
        break;
      case asn1.Class.PRIVATE:
        rval += "Private:";
        break;
    }
    if (obj.tagClass === asn1.Class.UNIVERSAL) switch (rval += obj.type, obj.type) {
      case asn1.Type.NONE:
        rval += " (None)";
        break;
      case asn1.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1.Type.NULL:
        rval += " (Null)";
        break;
      case asn1.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1.Type.REAL:
        rval += " (Real)";
        break;
      case asn1.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1.Type.SET:
        rval += " (Set)";
        break;
      case asn1.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    } else rval += obj.type;
    if (rval += `
`, rval += indent + "Constructed: " + obj.constructed + `
`, obj.composed) {
      for (var subvalues = 0, sub = "", i = 0; i < obj.value.length; ++i) obj.value[i] !== void 0 && (subvalues += 1, sub += asn1.prettyPrint(obj.value[i], level + 1, indentation), i + 1 < obj.value.length && (sub += ","));
      rval += indent + "Sub values: " + subvalues + sub;
    } else {
      if (rval += indent + "Value: ", obj.type === asn1.Type.OID) {
        var oid = asn1.derToOid(obj.value);
        rval += oid, forge.pki && forge.pki.oids && oid in forge.pki.oids && (rval += " (" + forge.pki.oids[oid] + ") ");
      }
      if (obj.type === asn1.Type.INTEGER) try {
        rval += asn1.derToInteger(obj.value);
      } catch {
        rval += "0x" + forge.util.bytesToHex(obj.value);
      } else if (obj.type === asn1.Type.BITSTRING) {
        if (obj.value.length > 1 ? rval += "0x" + forge.util.bytesToHex(obj.value.slice(1)) : rval += "(none)", obj.value.length > 0) {
          var unused = obj.value.charCodeAt(0);
          unused == 1 ? rval += " (1 unused bit shown)" : unused > 1 && (rval += " (" + unused + " unused bits shown)");
        }
      } else if (obj.type === asn1.Type.OCTETSTRING) _nonLatinRegex.test(obj.value) || (rval += "(" + obj.value + ") "), rval += "0x" + forge.util.bytesToHex(obj.value);else if (obj.type === asn1.Type.UTF8) try {
        rval += forge.util.decodeUtf8(obj.value);
      } catch (e) {
        if (e.message === "URI malformed") rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";else throw e;
      } else obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String ? rval += obj.value : _nonLatinRegex.test(obj.value) ? rval += "0x" + forge.util.bytesToHex(obj.value) : obj.value.length === 0 ? rval += "[null]" : rval += obj.value;
    }
    return rval;
  };
});
var require_md = __commonJSMin((exports, module) => {
  var forge = ta();
  module.exports = forge.md = forge.md || {};
  forge.md.algorithms = forge.md.algorithms || {};
});
var require_hmac = __commonJSMin((exports, module) => {
  var forge = ta();
  Qf();
  La();
  var hmac = module.exports = forge.hmac = forge.hmac || {};
  hmac.create = function () {
    var _key = null,
      _md = null,
      _ipadding = null,
      _opadding = null,
      ctx = {};
    return ctx.start = function (md, key) {
      if (md !== null) if (typeof md == "string") {
        if (md = md.toLowerCase(), md in forge.md.algorithms) _md = forge.md.algorithms[md].create();else throw new Error('Unknown hash algorithm "' + md + '"');
      } else _md = md;
      if (key === null) key = _key;else {
        if (typeof key == "string") key = forge.util.createBuffer(key);else if (forge.util.isArray(key)) {
          var tmp = key;
          key = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) key.putByte(tmp[i]);
        }
        var keylen = key.length();
        keylen > _md.blockLength && (_md.start(), _md.update(key.bytes()), key = _md.digest()), _ipadding = forge.util.createBuffer(), _opadding = forge.util.createBuffer(), keylen = key.length();
        for (var i = 0; i < keylen; ++i) {
          var tmp = key.at(i);
          _ipadding.putByte(54 ^ tmp), _opadding.putByte(92 ^ tmp);
        }
        if (keylen < _md.blockLength) for (var tmp = _md.blockLength - keylen, i = 0; i < tmp; ++i) _ipadding.putByte(54), _opadding.putByte(92);
        _key = key, _ipadding = _ipadding.bytes(), _opadding = _opadding.bytes();
      }
      _md.start(), _md.update(_ipadding);
    }, ctx.update = function (bytes) {
      _md.update(bytes);
    }, ctx.getMac = function () {
      var inner = _md.digest().bytes();
      return _md.start(), _md.update(_opadding), _md.update(inner), _md.digest();
    }, ctx.digest = ctx.getMac, ctx;
  };
});
var require_md5 = __commonJSMin((exports, module) => {
  var forge = ta();
  Qf();
  La();
  var md5 = module.exports = forge.md5 = forge.md5 || {};
  forge.md.md5 = forge.md.algorithms.md5 = md5;
  md5.create = function () {
    _initialized || _init();
    var _state = null,
      _input = forge.util.createBuffer(),
      _w = new Array(16),
      md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
    return md.start = function () {
      md.messageLength = 0, md.fullMessageLength = md.messageLength64 = [];
      for (var int32s = md.messageLengthSize / 4, i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
      return _input = forge.util.createBuffer(), _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878
      }, md;
    }, md.start(), md.update = function (msg, encoding) {
      encoding === "utf8" && (msg = forge.util.encodeUtf8(msg));
      var len = msg.length;
      md.messageLength += len, len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) md.fullMessageLength[i] += len[1], len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0), md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0, len[0] = len[1] / 4294967296 >>> 0;
      return _input.putBytes(msg), _update(_state, _w, _input), (_input.read > 2048 || _input.length() === 0) && _input.compact(), md;
    }, md.digest = function () {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize,
        overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      for (var bits, carry = 0, i = md.fullMessageLength.length - 1; i >= 0; --i) bits = md.fullMessageLength[i] * 8 + carry, carry = bits / 4294967296 >>> 0, finalBlock.putInt32Le(bits >>> 0);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      return rval.putInt32Le(s2.h0), rval.putInt32Le(s2.h1), rval.putInt32Le(s2.h2), rval.putInt32Le(s2.h3), rval;
    }, md;
  };
  var _padding = null,
    _g = null,
    _r = null,
    _k = null,
    _initialized = !1;
  function _init() {
    _padding = String.fromCharCode(128), _padding += forge.util.fillString(String.fromCharCode(0), 64), _g = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2, 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9], _r = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], _k = new Array(64);
    for (var i = 0; i < 64; ++i) _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
    _initialized = !0;
  }
  __name(_init, "_init");
  function _update(s, w, bytes) {
    for (var t, a, b, c, d, f, r, i, len = bytes.length(); len >= 64;) {
      for (a = s.h0, b = s.h1, c = s.h2, d = s.h3, i = 0; i < 16; ++i) w[i] = bytes.getInt32Le(), f = d ^ b & (c ^ d), t = a + f + _k[i] + w[i], r = _r[i], a = d, d = c, c = b, b += t << r | t >>> 32 - r;
      for (; i < 32; ++i) f = c ^ d & (b ^ c), t = a + f + _k[i] + w[_g[i]], r = _r[i], a = d, d = c, c = b, b += t << r | t >>> 32 - r;
      for (; i < 48; ++i) f = b ^ c ^ d, t = a + f + _k[i] + w[_g[i]], r = _r[i], a = d, d = c, c = b, b += t << r | t >>> 32 - r;
      for (; i < 64; ++i) f = c ^ (b | ~d), t = a + f + _k[i] + w[_g[i]], r = _r[i], a = d, d = c, c = b, b += t << r | t >>> 32 - r;
      s.h0 = s.h0 + a | 0, s.h1 = s.h1 + b | 0, s.h2 = s.h2 + c | 0, s.h3 = s.h3 + d | 0, len -= 64;
    }
  }
  __name(_update, "_update");
});
var require_pem = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  var pem = module.exports = forge.pem = forge.pem || {};
  pem.encode = function (msg, options) {
    options = options || {};
    var rval = "-----BEGIN " + msg.type + `-----\r
`,
      header;
    if (msg.procType && (header = {
      name: "Proc-Type",
      values: [String(msg.procType.version), msg.procType.type]
    }, rval += foldHeader(header)), msg.contentDomain && (header = {
      name: "Content-Domain",
      values: [msg.contentDomain]
    }, rval += foldHeader(header)), msg.dekInfo && (header = {
      name: "DEK-Info",
      values: [msg.dekInfo.algorithm]
    }, msg.dekInfo.parameters && header.values.push(msg.dekInfo.parameters), rval += foldHeader(header)), msg.headers) for (var i = 0; i < msg.headers.length; ++i) rval += foldHeader(msg.headers[i]);
    return msg.procType && (rval += `\r
`), rval += forge.util.encode64(msg.body, options.maxline || 64) + `\r
`, rval += "-----END " + msg.type + `-----\r
`, rval;
  };
  pem.decode = function (str) {
    for (var rval = [], rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, rCRLF = /\r?\n/, match; match = rMessage.exec(str), !!match;) {
      var type = match[1];
      type === "NEW CERTIFICATE REQUEST" && (type = "CERTIFICATE REQUEST");
      var msg = {
        type: type,
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: forge.util.decode64(match[3])
      };
      if (rval.push(msg), !!match[2]) {
        for (var lines = match[2].split(rCRLF), li = 0; match && li < lines.length;) {
          for (var line = lines[li].replace(/\s+$/, ""), nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) break;
            line += next, li = nl;
          }
          if (match = line.match(rHeader), match) {
            for (var header = {
                name: match[1],
                values: []
              }, values = match[2].split(","), vi = 0; vi < values.length; ++vi) header.values.push(ltrim(values[vi]));
            if (msg.procType) {
              if (!msg.contentDomain && header.name === "Content-Domain") msg.contentDomain = values[0] || "";else if (!msg.dekInfo && header.name === "DEK-Info") {
                if (header.values.length === 0) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                msg.dekInfo = {
                  algorithm: values[0],
                  parameters: values[1] || null
                };
              } else msg.headers.push(header);
            } else {
              if (header.name !== "Proc-Type") throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              if (header.values.length !== 2) throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              msg.procType = {
                version: values[0],
                type: values[1]
              };
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (rval.length === 0) throw new Error("Invalid PEM formatted message.");
    return rval;
  };
  function foldHeader(header) {
    for (var rval = header.name + ": ", values = [], insertSpace = __name(function (match, $1) {
        return " " + $1;
      }, "insertSpace"), i = 0; i < header.values.length; ++i) values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
    rval += values.join(",") + `\r
`;
    for (var length = 0, candidate = -1, i = 0; i < rval.length; ++i, ++length) if (length > 65 && candidate !== -1) {
      var insert = rval[candidate];
      insert === "," ? (++candidate, rval = rval.substr(0, candidate) + `\r
 ` + rval.substr(candidate)) : rval = rval.substr(0, candidate) + `\r
` + insert + rval.substr(candidate + 1), length = i - candidate - 1, candidate = -1, ++i;
    } else (rval[i] === " " || rval[i] === "	" || rval[i] === ",") && (candidate = i);
    return rval;
  }
  __name(foldHeader, "foldHeader");
  function ltrim(str) {
    return str.replace(/^\s+/, "");
  }
  __name(ltrim, "ltrim");
});
var require_des = __commonJSMin((exports, module) => {
  var forge = ta();
  wE();
  XL();
  La();
  module.exports = forge.des = forge.des || {};
  forge.des.startEncrypting = function (key, iv, output, mode) {
    var cipher = _createCipher({
      key: key,
      output: output,
      decrypt: !1,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    return cipher.start(iv), cipher;
  };
  forge.des.createEncryptionCipher = function (key, mode) {
    return _createCipher({
      key: key,
      output: null,
      decrypt: !1,
      mode: mode
    });
  };
  forge.des.startDecrypting = function (key, iv, output, mode) {
    var cipher = _createCipher({
      key: key,
      output: output,
      decrypt: !0,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    return cipher.start(iv), cipher;
  };
  forge.des.createDecryptionCipher = function (key, mode) {
    return _createCipher({
      key: key,
      output: null,
      decrypt: !0,
      mode: mode
    });
  };
  forge.des.Algorithm = function (name, mode) {
    var self = this;
    self.name = name, self.mode = new mode({
      blockSize: 8,
      cipher: {
        encrypt: function (inBlock, outBlock) {
          return _updateBlock(self._keys, inBlock, outBlock, !1);
        },
        decrypt: function (inBlock, outBlock) {
          return _updateBlock(self._keys, inBlock, outBlock, !0);
        }
      }
    }), self._init = !1;
  };
  forge.des.Algorithm.prototype.initialize = function (options) {
    if (!this._init) {
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0 && key.length() !== 24) throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
      this._keys = _createKeys(key), this._init = !0;
    }
  };
  registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
  function registerAlgorithm(name, mode) {
    var factory = __name(function () {
      return new forge.des.Algorithm(name, mode);
    }, "factory");
    forge.cipher.registerAlgorithm(name, factory);
  }
  __name(registerAlgorithm, "registerAlgorithm");
  var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756],
    spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344],
    spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584],
    spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928],
    spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080],
    spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312],
    spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154],
    spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  function _createKeys(key) {
    for (var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], iterations = key.length() > 8 ? 3 : 1, keys = [], shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], n = 0, tmp, j = 0; j < iterations; j++) {
      var left = key.getInt32(),
        right = key.getInt32();
      tmp = (left >>> 4 ^ right) & 252645135, right ^= tmp, left ^= tmp << 4, tmp = (right >>> -16 ^ left) & 65535, left ^= tmp, right ^= tmp << -16, tmp = (left >>> 2 ^ right) & 858993459, right ^= tmp, left ^= tmp << 2, tmp = (right >>> -16 ^ left) & 65535, left ^= tmp, right ^= tmp << -16, tmp = (left >>> 1 ^ right) & 1431655765, right ^= tmp, left ^= tmp << 1, tmp = (right >>> 8 ^ left) & 16711935, left ^= tmp, right ^= tmp << 8, tmp = (left >>> 1 ^ right) & 1431655765, right ^= tmp, left ^= tmp << 1, tmp = left << 8 | right >>> 20 & 240, left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240, right = tmp;
      for (var i = 0; i < shifts.length; ++i) {
        shifts[i] ? (left = left << 2 | left >>> 26, right = right << 2 | right >>> 26) : (left = left << 1 | left >>> 27, right = right << 1 | right >>> 27), left &= -15, right &= -15;
        var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15],
          righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
        tmp = (righttmp >>> 16 ^ lefttmp) & 65535, keys[n++] = lefttmp ^ tmp, keys[n++] = righttmp ^ tmp << 16;
      }
    }
    return keys;
  }
  __name(_createKeys, "_createKeys");
  function _updateBlock(keys, input, output, decrypt) {
    var iterations = keys.length === 32 ? 3 : 9,
      looping;
    iterations === 3 ? looping = decrypt ? [30, -2, -2] : [0, 32, 2] : looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
    var tmp,
      left = input[0],
      right = input[1];
    tmp = (left >>> 4 ^ right) & 252645135, right ^= tmp, left ^= tmp << 4, tmp = (left >>> 16 ^ right) & 65535, right ^= tmp, left ^= tmp << 16, tmp = (right >>> 2 ^ left) & 858993459, left ^= tmp, right ^= tmp << 2, tmp = (right >>> 8 ^ left) & 16711935, left ^= tmp, right ^= tmp << 8, tmp = (left >>> 1 ^ right) & 1431655765, right ^= tmp, left ^= tmp << 1, left = left << 1 | left >>> 31, right = right << 1 | right >>> 31;
    for (var j = 0; j < iterations; j += 3) {
      for (var endloop = looping[j + 1], loopinc = looping[j + 2], i = looping[j]; i != endloop; i += loopinc) {
        var right1 = right ^ keys[i],
          right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
        tmp = left, left = right, right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
      }
      tmp = left, left = right, right = tmp;
    }
    left = left >>> 1 | left << 31, right = right >>> 1 | right << 31, tmp = (left >>> 1 ^ right) & 1431655765, right ^= tmp, left ^= tmp << 1, tmp = (right >>> 8 ^ left) & 16711935, left ^= tmp, right ^= tmp << 8, tmp = (right >>> 2 ^ left) & 858993459, left ^= tmp, right ^= tmp << 2, tmp = (left >>> 16 ^ right) & 65535, right ^= tmp, left ^= tmp << 16, tmp = (left >>> 4 ^ right) & 252645135, right ^= tmp, left ^= tmp << 4, output[0] = left, output[1] = right;
  }
  __name(_updateBlock, "_updateBlock");
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase(),
      algorithm = "DES-" + mode,
      cipher;
    options.decrypt ? cipher = forge.cipher.createDecipher(algorithm, options.key) : cipher = forge.cipher.createCipher(algorithm, options.key);
    var start = cipher.start;
    return cipher.start = function (iv, options) {
      var output = null;
      options instanceof forge.util.ByteBuffer && (output = options, options = {}), options = options || {}, options.output = output, options.iv = iv, start.call(cipher, options);
    }, cipher;
  }
  __name(_createCipher, "_createCipher");
});
var require_pbkdf2 = __commonJSMin((exports, module) => {
  var forge = ta();
  Z5();
  Qf();
  La();
  var pkcs5 = forge.pkcs5 = forge.pkcs5 || {},
    crypto;
  forge.util.isNodejs && !forge.options.usePureJavaScript && (crypto = require("crypto"));
  module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function (p, s, c, dkLen, md, callback) {
    if (typeof md == "function" && (callback = md, md = null), forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md != "object") && (crypto.pbkdf2Sync.length > 4 || !md || md === "sha1")) return typeof md != "string" && (md = "sha1"), p = Buffer.from(p, "binary"), s = Buffer.from(s, "binary"), callback ? crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2(p, s, c, dkLen, function (err, key) {
      if (err) return callback(err);
      callback(null, key.toString("binary"));
    }) : crypto.pbkdf2(p, s, c, dkLen, md, function (err, key) {
      if (err) return callback(err);
      callback(null, key.toString("binary"));
    }) : crypto.pbkdf2Sync.length === 4 ? crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary") : crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
    if ((typeof md > "u" || md === null) && (md = "sha1"), typeof md == "string") {
      if (!(md in forge.md.algorithms)) throw new Error("Unknown hash algorithm: " + md);
      md = forge.md[md].create();
    }
    var hLen = md.digestLength;
    if (dkLen > 4294967295 * hLen) {
      var err = new Error("Derived key is too long.");
      if (callback) return callback(err);
      throw err;
    }
    var len = Math.ceil(dkLen / hLen),
      r = dkLen - (len - 1) * hLen,
      prf = forge.hmac.create();
    prf.start(md, p);
    var dk = "",
      xor,
      u_c,
      u_c1;
    if (!callback) {
      for (var i = 1; i <= len; ++i) {
        prf.start(null, null), prf.update(s), prf.update(forge.util.int32ToBytes(i)), xor = u_c1 = prf.digest().getBytes();
        for (var j = 2; j <= c; ++j) prf.start(null, null), prf.update(u_c1), u_c = prf.digest().getBytes(), xor = forge.util.xorBytes(xor, u_c, hLen), u_c1 = u_c;
        dk += i < len ? xor : xor.substr(0, r);
      }
      return dk;
    }
    var i = 1,
      j;
    function outer() {
      if (i > len) return callback(null, dk);
      prf.start(null, null), prf.update(s), prf.update(forge.util.int32ToBytes(i)), xor = u_c1 = prf.digest().getBytes(), j = 2, inner();
    }
    __name(outer, "outer");
    function inner() {
      if (j <= c) return prf.start(null, null), prf.update(u_c1), u_c = prf.digest().getBytes(), xor = forge.util.xorBytes(xor, u_c, hLen), u_c1 = u_c, ++j, forge.util.setImmediate(inner);
      dk += i < len ? xor : xor.substr(0, r), ++i, outer();
    }
    __name(inner, "inner"), outer();
  };
});
var require_sha256 = __commonJSMin((exports, module) => {
  var forge = ta();
  Qf();
  La();
  var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
  forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
  sha256.create = function () {
    _initialized || _init();
    var _state = null,
      _input = forge.util.createBuffer(),
      _w = new Array(64),
      md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
    return md.start = function () {
      md.messageLength = 0, md.fullMessageLength = md.messageLength64 = [];
      for (var int32s = md.messageLengthSize / 4, i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
      return _input = forge.util.createBuffer(), _state = {
        h0: 1779033703,
        h1: 3144134277,
        h2: 1013904242,
        h3: 2773480762,
        h4: 1359893119,
        h5: 2600822924,
        h6: 528734635,
        h7: 1541459225
      }, md;
    }, md.start(), md.update = function (msg, encoding) {
      encoding === "utf8" && (msg = forge.util.encodeUtf8(msg));
      var len = msg.length;
      md.messageLength += len, len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) md.fullMessageLength[i] += len[1], len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0), md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0, len[0] = len[1] / 4294967296 >>> 0;
      return _input.putBytes(msg), _update(_state, _w, _input), (_input.read > 2048 || _input.length() === 0) && _input.compact(), md;
    }, md.digest = function () {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize,
        overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      for (var next, carry, bits = md.fullMessageLength[0] * 8, i = 0; i < md.fullMessageLength.length - 1; ++i) next = md.fullMessageLength[i + 1] * 8, carry = next / 4294967296 >>> 0, bits += carry, finalBlock.putInt32(bits >>> 0), bits = next >>> 0;
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4,
        h5: _state.h5,
        h6: _state.h6,
        h7: _state.h7
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      return rval.putInt32(s2.h0), rval.putInt32(s2.h1), rval.putInt32(s2.h2), rval.putInt32(s2.h3), rval.putInt32(s2.h4), rval.putInt32(s2.h5), rval.putInt32(s2.h6), rval.putInt32(s2.h7), rval;
    }, md;
  };
  var _padding = null,
    _initialized = !1,
    _k = null;
  function _init() {
    _padding = String.fromCharCode(128), _padding += forge.util.fillString(String.fromCharCode(0), 64), _k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], _initialized = !0;
  }
  __name(_init, "_init");
  function _update(s, w, bytes) {
    for (var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h, len = bytes.length(); len >= 64;) {
      for (i = 0; i < 16; ++i) w[i] = bytes.getInt32();
      for (; i < 64; ++i) t1 = w[i - 2], t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10, t2 = w[i - 15], t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3, w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
      for (a = s.h0, b = s.h1, c = s.h2, d = s.h3, e = s.h4, f = s.h5, g = s.h6, h = s.h7, i = 0; i < 64; ++i) s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7), ch = g ^ e & (f ^ g), s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10), maj = a & b | c & (a ^ b), t1 = h + s1 + ch + _k[i] + w[i], t2 = s0 + maj, h = g, g = f, f = e, e = d + t1 >>> 0, d = c, c = b, b = a, a = t1 + t2 >>> 0;
      s.h0 = s.h0 + a | 0, s.h1 = s.h1 + b | 0, s.h2 = s.h2 + c | 0, s.h3 = s.h3 + d | 0, s.h4 = s.h4 + e | 0, s.h5 = s.h5 + f | 0, s.h6 = s.h6 + g | 0, s.h7 = s.h7 + h | 0, len -= 64;
    }
  }
  __name(_update, "_update");
});
var require_prng = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  var _crypto = null;
  forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"] && (_crypto = require("crypto"));
  var prng = module.exports = forge.prng = forge.prng || {};
  prng.create = function (plugin) {
    for (var ctx = {
        plugin: plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      }, md = plugin.md, pools = new Array(32), i = 0; i < 32; ++i) pools[i] = md.create();
    ctx.pools = pools, ctx.pool = 0, ctx.generate = function (count, callback) {
      if (!callback) return ctx.generateSync(count);
      var cipher = ctx.plugin.cipher,
        increment = ctx.plugin.increment,
        formatKey = ctx.plugin.formatKey,
        formatSeed = ctx.plugin.formatSeed,
        b = forge.util.createBuffer();
      ctx.key = null, generate();
      function generate(err) {
        if (err) return callback(err);
        if (b.length() >= count) return callback(null, b.getBytes(count));
        if (ctx.generated > 1048575 && (ctx.key = null), ctx.key === null) return forge.util.nextTick(function () {
          _reseed(generate);
        });
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length, b.putBytes(bytes), ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed))), ctx.seed = formatSeed(cipher(ctx.key, ctx.seed)), forge.util.setImmediate(generate);
      }
      __name(generate, "generate");
    }, ctx.generateSync = function (count) {
      var cipher = ctx.plugin.cipher,
        increment = ctx.plugin.increment,
        formatKey = ctx.plugin.formatKey,
        formatSeed = ctx.plugin.formatSeed;
      ctx.key = null;
      for (var b = forge.util.createBuffer(); b.length() < count;) {
        ctx.generated > 1048575 && (ctx.key = null), ctx.key === null && _reseedSync();
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length, b.putBytes(bytes), ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed))), ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      }
      return b.getBytes(count);
    };
    function _reseed(callback) {
      if (ctx.pools[0].messageLength >= 32) return _seed(), callback();
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.seedFile(needed, function (err, bytes) {
        if (err) return callback(err);
        ctx.collect(bytes), _seed(), callback();
      });
    }
    __name(_reseed, "_reseed");
    function _reseedSync() {
      if (ctx.pools[0].messageLength >= 32) return _seed();
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.collect(ctx.seedFileSync(needed)), _seed();
    }
    __name(_reseedSync, "_reseedSync");
    function _seed() {
      ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
      var md = ctx.plugin.md.create();
      md.update(ctx.keyBytes);
      for (var _2powK = 1, k = 0; k < 32; ++k) ctx.reseeds % _2powK === 0 && (md.update(ctx.pools[k].digest().getBytes()), ctx.pools[k].start()), _2powK = _2powK << 1;
      ctx.keyBytes = md.digest().getBytes(), md.start(), md.update(ctx.keyBytes);
      var seedBytes = md.digest().getBytes();
      ctx.key = ctx.plugin.formatKey(ctx.keyBytes), ctx.seed = ctx.plugin.formatSeed(seedBytes), ctx.generated = 0;
    }
    __name(_seed, "_seed");
    function defaultSeedFile(needed) {
      var getRandomValues = null,
        globalScope = forge.util.globalScope,
        _crypto = globalScope.crypto || globalScope.msCrypto;
      _crypto && _crypto.getRandomValues && (getRandomValues = __name(function (arr) {
        return _crypto.getRandomValues(arr);
      }, "getRandomValues"));
      var b = forge.util.createBuffer();
      if (getRandomValues) for (; b.length() < needed;) {
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4),
          entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i = 0; i < entropy.length; ++i) b.putInt32(entropy[i]);
        } catch (e) {
          if (!(typeof QuotaExceededError < "u" && e instanceof QuotaExceededError)) throw e;
        }
      }
      if (b.length() < needed) for (var hi, lo, next, seed = Math.floor(Math.random() * 65536); b.length() < needed;) {
        lo = 16807 * (seed & 65535), hi = 16807 * (seed >> 16), lo += (hi & 32767) << 16, lo += hi >> 15, lo = (lo & 2147483647) + (lo >> 31), seed = lo & 4294967295;
        for (var i = 0; i < 3; ++i) next = seed >>> (i << 3), next ^= Math.floor(Math.random() * 256), b.putByte(next & 255);
      }
      return b.getBytes(needed);
    }
    return __name(defaultSeedFile, "defaultSeedFile"), _crypto ? (ctx.seedFile = function (needed, callback) {
      _crypto.randomBytes(needed, function (err, bytes) {
        if (err) return callback(err);
        callback(null, bytes.toString());
      });
    }, ctx.seedFileSync = function (needed) {
      return _crypto.randomBytes(needed).toString();
    }) : (ctx.seedFile = function (needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e) {
        callback(e);
      }
    }, ctx.seedFileSync = defaultSeedFile), ctx.collect = function (bytes) {
      for (var count = bytes.length, i = 0; i < count; ++i) ctx.pools[ctx.pool].update(bytes.substr(i, 1)), ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }, ctx.collectInt = function (i, n) {
      for (var bytes = "", x = 0; x < n; x += 8) bytes += String.fromCharCode(i >> x & 255);
      ctx.collect(bytes);
    }, ctx.registerWorker = function (worker) {
      if (worker === self) ctx.seedFile = function (needed, callback) {
        function listener(e) {
          var data = e.data;
          data.forge && data.forge.prng && (self.removeEventListener("message", listener), callback(data.forge.prng.err, data.forge.prng.bytes));
        }
        __name(listener, "listener"), self.addEventListener("message", listener), self.postMessage({
          forge: {
            prng: {
              needed: needed
            }
          }
        });
      };else {
        var listener = __name(function (e) {
          var data = e.data;
          data.forge && data.forge.prng && ctx.seedFile(data.forge.prng.needed, function (err, bytes) {
            worker.postMessage({
              forge: {
                prng: {
                  err: err,
                  bytes: bytes
                }
              }
            });
          });
        }, "listener");
        worker.addEventListener("message", listener);
      }
    }, ctx;
  };
});
var require_random = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  rk();
  nk();
  La();
  (function () {
    if (forge.random && forge.random.getBytes) {
      module.exports = forge.random;
      return;
    }
    (function (jQuery) {
      var prng_aes = {},
        _prng_aes_output = new Array(4),
        _prng_aes_buffer = forge.util.createBuffer();
      prng_aes.formatKey = function (key) {
        var tmp = forge.util.createBuffer(key);
        return key = new Array(4), key[0] = tmp.getInt32(), key[1] = tmp.getInt32(), key[2] = tmp.getInt32(), key[3] = tmp.getInt32(), forge.aes._expandKey(key, !1);
      }, prng_aes.formatSeed = function (seed) {
        var tmp = forge.util.createBuffer(seed);
        return seed = new Array(4), seed[0] = tmp.getInt32(), seed[1] = tmp.getInt32(), seed[2] = tmp.getInt32(), seed[3] = tmp.getInt32(), seed;
      }, prng_aes.cipher = function (key, seed) {
        return forge.aes._updateBlock(key, seed, _prng_aes_output, !1), _prng_aes_buffer.putInt32(_prng_aes_output[0]), _prng_aes_buffer.putInt32(_prng_aes_output[1]), _prng_aes_buffer.putInt32(_prng_aes_output[2]), _prng_aes_buffer.putInt32(_prng_aes_output[3]), _prng_aes_buffer.getBytes();
      }, prng_aes.increment = function (seed) {
        return ++seed[3], seed;
      }, prng_aes.md = forge.md.sha256;
      function spawnPrng() {
        var ctx = forge.prng.create(prng_aes);
        return ctx.getBytes = function (count, callback) {
          return ctx.generate(count, callback);
        }, ctx.getBytesSync = function (count) {
          return ctx.generate(count);
        }, ctx;
      }
      __name(spawnPrng, "spawnPrng");
      var _ctx = spawnPrng(),
        getRandomValues = null,
        globalScope = forge.util.globalScope,
        _crypto = globalScope.crypto || globalScope.msCrypto;
      if (_crypto && _crypto.getRandomValues && (getRandomValues = __name(function (arr) {
        return _crypto.getRandomValues(arr);
      }, "getRandomValues")), forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
        if (typeof window > "u" || window.document, _ctx.collectInt(+new Date(), 32), typeof navigator < "u") {
          var _navBytes = "";
          for (var key in navigator) try {
            typeof navigator[key] == "string" && (_navBytes += navigator[key]);
          } catch {}
          _ctx.collect(_navBytes), _navBytes = null;
        }
        jQuery && (jQuery().mousemove(function (e) {
          _ctx.collectInt(e.clientX, 16), _ctx.collectInt(e.clientY, 16);
        }), jQuery().keypress(function (e) {
          _ctx.collectInt(e.charCode, 8);
        }));
      }
      if (!forge.random) forge.random = _ctx;else for (var key in _ctx) forge.random[key] = _ctx[key];
      forge.random.createInstance = spawnPrng, module.exports = forge.random;
    })(typeof jQuery < "u" ? jQuery : null);
  })();
});
var require_rc2 = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  var piTable = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173],
    s = [1, 2, 3, 5],
    rol = __name(function (word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    }, "rol"),
    ror = __name(function (word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    }, "ror");
  module.exports = forge.rc2 = forge.rc2 || {};
  forge.rc2.expandKey = function (key, effKeyBits) {
    typeof key == "string" && (key = forge.util.createBuffer(key)), effKeyBits = effKeyBits || 128;
    var L = key,
      T = key.length(),
      T1 = effKeyBits,
      T8 = Math.ceil(T1 / 8),
      TM = 255 >> (T1 & 7),
      i;
    for (i = T; i < 128; i++) L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
    for (L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]), i = 127 - T8; i >= 0; i--) L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
    return L;
  };
  var createCipher = __name(function (key, bits, encrypt) {
    var _finish = !1,
      _input = null,
      _output = null,
      _iv = null,
      mixRound,
      mashRound,
      i,
      j,
      K = [];
    for (key = forge.rc2.expandKey(key, bits), i = 0; i < 64; i++) K.push(key.getInt16Le());
    encrypt ? (mixRound = __name(function (R) {
      for (i = 0; i < 4; i++) R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]), R[i] = rol(R[i], s[i]), j++;
    }, "mixRound"), mashRound = __name(function (R) {
      for (i = 0; i < 4; i++) R[i] += K[R[(i + 3) % 4] & 63];
    }, "mashRound")) : (mixRound = __name(function (R) {
      for (i = 3; i >= 0; i--) R[i] = ror(R[i], s[i]), R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]), j--;
    }, "mixRound"), mashRound = __name(function (R) {
      for (i = 3; i >= 0; i--) R[i] -= K[R[(i + 3) % 4] & 63];
    }, "mashRound"));
    var runPlan = __name(function (plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          _iv !== null && (encrypt ? val ^= _iv.getInt16Le() : _iv.putInt16Le(val)), R.push(val & 65535);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) for (var ctr = 0; ctr < plan[ptr][0]; ctr++) plan[ptr][1](R);
        for (i = 0; i < 4; i++) _iv !== null && (encrypt ? _iv.putInt16Le(R[i]) : R[i] ^= _iv.getInt16Le()), _output.putInt16Le(R[i]);
      }, "runPlan"),
      cipher = null;
    return cipher = {
      start: function (iv, output) {
        iv && typeof iv == "string" && (iv = forge.util.createBuffer(iv)), _finish = !1, _input = forge.util.createBuffer(), _output = output || new forge.util.createBuffer(), _iv = iv, cipher.output = _output;
      },
      update: function (input) {
        for (_finish || _input.putBuffer(input); _input.length() >= 8;) runPlan([[5, mixRound], [1, mashRound], [6, mixRound], [1, mashRound], [5, mixRound]]);
      },
      finish: function (pad) {
        var rval = !0;
        if (encrypt) if (pad) rval = pad(8, _input, !encrypt);else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
        if (rval && (_finish = !0, cipher.update()), !encrypt && (rval = _input.length() === 0, rval)) if (pad) rval = pad(8, _output, !encrypt);else {
          var len = _output.length(),
            count = _output.at(len - 1);
          count > len ? rval = !1 : _output.truncate(count);
        }
        return rval;
      }
    }, cipher;
  }, "createCipher");
  forge.rc2.startEncrypting = function (key, iv, output) {
    var cipher = forge.rc2.createEncryptionCipher(key, 128);
    return cipher.start(iv, output), cipher;
  };
  forge.rc2.createEncryptionCipher = function (key, bits) {
    return createCipher(key, bits, !0);
  };
  forge.rc2.startDecrypting = function (key, iv, output) {
    var cipher = forge.rc2.createDecryptionCipher(key, 128);
    return cipher.start(iv, output), cipher;
  };
  forge.rc2.createDecryptionCipher = function (key, bits) {
    return createCipher(key, bits, !1);
  };
});
var require_jsbn = __commonJSMin((exports, module) => {
  var forge = ta();
  module.exports = forge.jsbn = forge.jsbn || {};
  var dbits,
    canary = 0xdeadbeefcafe,
    j_lm = (canary & 16777215) == 15715070;
  function BigInteger(a, b, c) {
    this.data = [], a != null && (typeof a == "number" ? this.fromNumber(a, b, c) : b == null && typeof a != "string" ? this.fromString(a, 256) : this.fromString(a, b));
  }
  __name(BigInteger, "BigInteger");
  forge.jsbn.BigInteger = BigInteger;
  function nbi() {
    return new BigInteger(null);
  }
  __name(nbi, "nbi");
  function am1(i, x, w, j, c, n) {
    for (; --n >= 0;) {
      var v = x * this.data[i++] + w.data[j] + c;
      c = Math.floor(v / 67108864), w.data[j++] = v & 67108863;
    }
    return c;
  }
  __name(am1, "am1");
  function am2(i, x, w, j, c, n) {
    for (var xl = x & 32767, xh = x >> 15; --n >= 0;) {
      var l = this.data[i] & 32767,
        h = this.data[i++] >> 15,
        m = xh * l + h * xl;
      l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823), c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30), w.data[j++] = l & 1073741823;
    }
    return c;
  }
  __name(am2, "am2");
  function am3(i, x, w, j, c, n) {
    for (var xl = x & 16383, xh = x >> 14; --n >= 0;) {
      var l = this.data[i] & 16383,
        h = this.data[i++] >> 14,
        m = xh * l + h * xl;
      l = xl * l + ((m & 16383) << 14) + w.data[j] + c, c = (l >> 28) + (m >> 14) + xh * h, w.data[j++] = l & 268435455;
    }
    return c;
  }
  __name(am3, "am3");
  typeof navigator > "u" ? (BigInteger.prototype.am = am3, dbits = 28) : j_lm && navigator.appName == "Microsoft Internet Explorer" ? (BigInteger.prototype.am = am2, dbits = 30) : j_lm && navigator.appName != "Netscape" ? (BigInteger.prototype.am = am1, dbits = 26) : (BigInteger.prototype.am = am3, dbits = 28);
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = (1 << dbits) - 1;
  BigInteger.prototype.DV = 1 << dbits;
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz",
    BI_RC = new Array(),
    rr,
    vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  function int2char(n) {
    return BI_RM.charAt(n);
  }
  __name(int2char, "int2char");
  function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return c ?? -1;
  }
  __name(intAt, "intAt");
  function bnpCopyTo(r) {
    for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
    r.t = this.t, r.s = this.s;
  }
  __name(bnpCopyTo, "bnpCopyTo");
  function bnpFromInt(x) {
    this.t = 1, this.s = x < 0 ? -1 : 0, x > 0 ? this.data[0] = x : x < -1 ? this.data[0] = x + this.DV : this.t = 0;
  }
  __name(bnpFromInt, "bnpFromInt");
  function nbv(i) {
    var r = nbi();
    return r.fromInt(i), r;
  }
  __name(nbv, "nbv");
  function bnpFromString(s, b) {
    var k;
    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 256) k = 8;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0, this.s = 0;
    for (var i = s.length, mi = !1, sh = 0; --i >= 0;) {
      var x = k == 8 ? s[i] & 255 : intAt(s, i);
      if (x < 0) {
        s.charAt(i) == "-" && (mi = !0);
        continue;
      }
      mi = !1, sh == 0 ? this.data[this.t++] = x : sh + k > this.DB ? (this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh, this.data[this.t++] = x >> this.DB - sh) : this.data[this.t - 1] |= x << sh, sh += k, sh >= this.DB && (sh -= this.DB);
    }
    k == 8 && s[0] & 128 && (this.s = -1, sh > 0 && (this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh)), this.clamp(), mi && BigInteger.ZERO.subTo(this, this);
  }
  __name(bnpFromString, "bnpFromString");
  function bnpClamp() {
    for (var c = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == c;) --this.t;
  }
  __name(bnpClamp, "bnpClamp");
  function bnToString(b) {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else return this.toRadix(b);
    var km = (1 << k) - 1,
      d,
      m = !1,
      r = "",
      i = this.t,
      p = this.DB - i * this.DB % k;
    if (i-- > 0) for (p < this.DB && (d = this.data[i] >> p) > 0 && (m = !0, r = int2char(d)); i >= 0;) p < k ? (d = (this.data[i] & (1 << p) - 1) << k - p, d |= this.data[--i] >> (p += this.DB - k)) : (d = this.data[i] >> (p -= k) & km, p <= 0 && (p += this.DB, --i)), d > 0 && (m = !0), m && (r += int2char(d));
    return m ? r : "0";
  }
  __name(bnToString, "bnToString");
  function bnNegate() {
    var r = nbi();
    return BigInteger.ZERO.subTo(this, r), r;
  }
  __name(bnNegate, "bnNegate");
  function bnAbs() {
    return this.s < 0 ? this.negate() : this;
  }
  __name(bnAbs, "bnAbs");
  function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    if (r = i - a.t, r != 0) return this.s < 0 ? -r : r;
    for (; --i >= 0;) if ((r = this.data[i] - a.data[i]) != 0) return r;
    return 0;
  }
  __name(bnCompareTo, "bnCompareTo");
  function nbits(x) {
    var r = 1,
      t;
    return (t = x >>> 16) != 0 && (x = t, r += 16), (t = x >> 8) != 0 && (x = t, r += 8), (t = x >> 4) != 0 && (x = t, r += 4), (t = x >> 2) != 0 && (x = t, r += 2), (t = x >> 1) != 0 && (x = t, r += 1), r;
  }
  __name(nbits, "nbits");
  function bnBitLength() {
    return this.t <= 0 ? 0 : this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
  }
  __name(bnBitLength, "bnBitLength");
  function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
    for (i = n - 1; i >= 0; --i) r.data[i] = 0;
    r.t = this.t + n, r.s = this.s;
  }
  __name(bnpDLShiftTo, "bnpDLShiftTo");
  function bnpDRShiftTo(n, r) {
    for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
    r.t = Math.max(this.t - n, 0), r.s = this.s;
  }
  __name(bnpDRShiftTo, "bnpDRShiftTo");
  function bnpLShiftTo(n, r) {
    var bs = n % this.DB,
      cbs = this.DB - bs,
      bm = (1 << cbs) - 1,
      ds = Math.floor(n / this.DB),
      c = this.s << bs & this.DM,
      i;
    for (i = this.t - 1; i >= 0; --i) r.data[i + ds + 1] = this.data[i] >> cbs | c, c = (this.data[i] & bm) << bs;
    for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
    r.data[ds] = c, r.t = this.t + ds + 1, r.s = this.s, r.clamp();
  }
  __name(bnpLShiftTo, "bnpLShiftTo");
  function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
      r.t = 0;
      return;
    }
    var bs = n % this.DB,
      cbs = this.DB - bs,
      bm = (1 << bs) - 1;
    r.data[0] = this.data[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i) r.data[i - ds - 1] |= (this.data[i] & bm) << cbs, r.data[i - ds] = this.data[i] >> bs;
    bs > 0 && (r.data[this.t - ds - 1] |= (this.s & bm) << cbs), r.t = this.t - ds, r.clamp();
  }
  __name(bnpRShiftTo, "bnpRShiftTo");
  function bnpSubTo(a, r) {
    for (var i = 0, c = 0, m = Math.min(a.t, this.t); i < m;) c += this.data[i] - a.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
    if (a.t < this.t) {
      for (c -= a.s; i < this.t;) c += this.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
      c += this.s;
    } else {
      for (c += this.s; i < a.t;) c -= a.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
      c -= a.s;
    }
    r.s = c < 0 ? -1 : 0, c < -1 ? r.data[i++] = this.DV + c : c > 0 && (r.data[i++] = c), r.t = i, r.clamp();
  }
  __name(bnpSubTo, "bnpSubTo");
  function bnpMultiplyTo(a, r) {
    var x = this.abs(),
      y = a.abs(),
      i = x.t;
    for (r.t = i + y.t; --i >= 0;) r.data[i] = 0;
    for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
    r.s = 0, r.clamp(), this.s != a.s && BigInteger.ZERO.subTo(r, r);
  }
  __name(bnpMultiplyTo, "bnpMultiplyTo");
  function bnpSquareTo(r) {
    for (var x = this.abs(), i = r.t = 2 * x.t; --i >= 0;) r.data[i] = 0;
    for (i = 0; i < x.t - 1; ++i) {
      var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
      (r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV && (r.data[i + x.t] -= x.DV, r.data[i + x.t + 1] = 1);
    }
    r.t > 0 && (r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1)), r.s = 0, r.clamp();
  }
  __name(bnpSquareTo, "bnpSquareTo");
  function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (!(pm.t <= 0)) {
      var pt = this.abs();
      if (pt.t < pm.t) {
        q?.fromInt(0), r != null && this.copyTo(r);
        return;
      }
      r == null && (r = nbi());
      var y = nbi(),
        ts = this.s,
        ms = m.s,
        nsh = this.DB - nbits(pm.data[pm.t - 1]);
      nsh > 0 ? (pm.lShiftTo(nsh, y), pt.lShiftTo(nsh, r)) : (pm.copyTo(y), pt.copyTo(r));
      var ys = y.t,
        y0 = y.data[ys - 1];
      if (y0 != 0) {
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0),
          d1 = this.FV / yt,
          d2 = (1 << this.F1) / yt,
          e = 1 << this.F2,
          i = r.t,
          j = i - ys,
          t = q ?? nbi();
        for (y.dlShiftTo(j, t), r.compareTo(t) >= 0 && (r.data[r.t++] = 1, r.subTo(t, r)), BigInteger.ONE.dlShiftTo(ys, t), t.subTo(y, y); y.t < ys;) y.data[y.t++] = 0;
        for (; --j >= 0;) {
          var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
          if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) for (y.dlShiftTo(j, t), r.subTo(t, r); r.data[i] < --qd;) r.subTo(t, r);
        }
        q != null && (r.drShiftTo(ys, q), ts != ms && BigInteger.ZERO.subTo(q, q)), r.t = ys, r.clamp(), nsh > 0 && r.rShiftTo(nsh, r), ts < 0 && BigInteger.ZERO.subTo(r, r);
      }
    }
  }
  __name(bnpDivRemTo, "bnpDivRemTo");
  function bnMod(a) {
    var r = nbi();
    return this.abs().divRemTo(a, null, r), this.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && a.subTo(r, r), r;
  }
  __name(bnMod, "bnMod");
  function Classic(m) {
    this.m = m;
  }
  __name(Classic, "Classic");
  function cConvert(x) {
    return x.s < 0 || x.compareTo(this.m) >= 0 ? x.mod(this.m) : x;
  }
  __name(cConvert, "cConvert");
  function cRevert(x) {
    return x;
  }
  __name(cRevert, "cRevert");
  function cReduce(x) {
    x.divRemTo(this.m, null, x);
  }
  __name(cReduce, "cReduce");
  function cMulTo(x, y, r) {
    x.multiplyTo(y, r), this.reduce(r);
  }
  __name(cMulTo, "cMulTo");
  function cSqrTo(x, r) {
    x.squareTo(r), this.reduce(r);
  }
  __name(cSqrTo, "cSqrTo");
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  function bnpInvDigit() {
    if (this.t < 1) return 0;
    var x = this.data[0];
    if (!(x & 1)) return 0;
    var y = x & 3;
    return y = y * (2 - (x & 15) * y) & 15, y = y * (2 - (x & 255) * y) & 255, y = y * (2 - ((x & 65535) * y & 65535)) & 65535, y = y * (2 - x * y % this.DV) % this.DV, y > 0 ? this.DV - y : -y;
  }
  __name(bnpInvDigit, "bnpInvDigit");
  function Montgomery(m) {
    this.m = m, this.mp = m.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << m.DB - 15) - 1, this.mt2 = 2 * m.t;
  }
  __name(Montgomery, "Montgomery");
  function montConvert(x) {
    var r = nbi();
    return x.abs().dlShiftTo(this.m.t, r), r.divRemTo(this.m, null, r), x.s < 0 && r.compareTo(BigInteger.ZERO) > 0 && this.m.subTo(r, r), r;
  }
  __name(montConvert, "montConvert");
  function montRevert(x) {
    var r = nbi();
    return x.copyTo(r), this.reduce(r), r;
  }
  __name(montRevert, "montRevert");
  function montReduce(x) {
    for (; x.t <= this.mt2;) x.data[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i) {
      var j = x.data[i] & 32767,
        u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
      for (j = i + this.m.t, x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t); x.data[j] >= x.DV;) x.data[j] -= x.DV, x.data[++j]++;
    }
    x.clamp(), x.drShiftTo(this.m.t, x), x.compareTo(this.m) >= 0 && x.subTo(this.m, x);
  }
  __name(montReduce, "montReduce");
  function montSqrTo(x, r) {
    x.squareTo(r), this.reduce(r);
  }
  __name(montSqrTo, "montSqrTo");
  function montMulTo(x, y, r) {
    x.multiplyTo(y, r), this.reduce(r);
  }
  __name(montMulTo, "montMulTo");
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  function bnpIsEven() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
  }
  __name(bnpIsEven, "bnpIsEven");
  function bnpExp(e, z) {
    if (e > 4294967295 || e < 1) return BigInteger.ONE;
    var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
    for (g.copyTo(r); --i >= 0;) if (z.sqrTo(r, r2), (e & 1 << i) > 0) z.mulTo(r2, g, r);else {
      var t = r;
      r = r2, r2 = t;
    }
    return z.revert(r);
  }
  __name(bnpExp, "bnpExp");
  function bnModPowInt(e, m) {
    var z;
    return e < 256 || m.isEven() ? z = new Classic(m) : z = new Montgomery(m), this.exp(e, z);
  }
  __name(bnModPowInt, "bnModPowInt");
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  function bnClone() {
    var r = nbi();
    return this.copyTo(r), r;
  }
  __name(bnClone, "bnClone");
  function bnIntValue() {
    if (this.s < 0) {
      if (this.t == 1) return this.data[0] - this.DV;
      if (this.t == 0) return -1;
    } else {
      if (this.t == 1) return this.data[0];
      if (this.t == 0) return 0;
    }
    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
  }
  __name(bnIntValue, "bnIntValue");
  function bnByteValue() {
    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
  }
  __name(bnByteValue, "bnByteValue");
  function bnShortValue() {
    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
  }
  __name(bnShortValue, "bnShortValue");
  function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  __name(bnpChunkSize, "bnpChunkSize");
  function bnSigNum() {
    return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
  }
  __name(bnSigNum, "bnSigNum");
  function bnpToRadix(b) {
    if (b == null && (b = 10), this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b),
      a = Math.pow(b, cs),
      d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
    for (this.divRemTo(d, y, z); y.signum() > 0;) r = (a + z.intValue()).toString(b).substr(1) + r, y.divRemTo(d, y, z);
    return z.intValue().toString(b) + r;
  }
  __name(bnpToRadix, "bnpToRadix");
  function bnpFromRadix(s, b) {
    this.fromInt(0), b == null && (b = 10);
    for (var cs = this.chunkSize(b), d = Math.pow(b, cs), mi = !1, j = 0, w = 0, i = 0; i < s.length; ++i) {
      var x = intAt(s, i);
      if (x < 0) {
        s.charAt(i) == "-" && this.signum() == 0 && (mi = !0);
        continue;
      }
      w = b * w + x, ++j >= cs && (this.dMultiply(d), this.dAddOffset(w, 0), j = 0, w = 0);
    }
    j > 0 && (this.dMultiply(Math.pow(b, j)), this.dAddOffset(w, 0)), mi && BigInteger.ZERO.subTo(this, this);
  }
  __name(bnpFromRadix, "bnpFromRadix");
  function bnpFromNumber(a, b, c) {
    if (typeof b == "number") {
      if (a < 2) this.fromInt(1);else for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);) this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
    } else {
      var x = new Array(),
        t = a & 7;
      x.length = (a >> 3) + 1, b.nextBytes(x), t > 0 ? x[0] &= (1 << t) - 1 : x[0] = 0, this.fromString(x, 256);
    }
  }
  __name(bnpFromNumber, "bnpFromNumber");
  function bnToByteArray() {
    var i = this.t,
      r = new Array();
    r[0] = this.s;
    var p = this.DB - i * this.DB % 8,
      d,
      k = 0;
    if (i-- > 0) for (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p && (r[k++] = d | this.s << this.DB - p); i >= 0;) p < 8 ? (d = (this.data[i] & (1 << p) - 1) << 8 - p, d |= this.data[--i] >> (p += this.DB - 8)) : (d = this.data[i] >> (p -= 8) & 255, p <= 0 && (p += this.DB, --i)), d & 128 && (d |= -256), k == 0 && (this.s & 128) != (d & 128) && ++k, (k > 0 || d != this.s) && (r[k++] = d);
    return r;
  }
  __name(bnToByteArray, "bnToByteArray");
  function bnEquals(a) {
    return this.compareTo(a) == 0;
  }
  __name(bnEquals, "bnEquals");
  function bnMin(a) {
    return this.compareTo(a) < 0 ? this : a;
  }
  __name(bnMin, "bnMin");
  function bnMax(a) {
    return this.compareTo(a) > 0 ? this : a;
  }
  __name(bnMax, "bnMax");
  function bnpBitwiseTo(a, op, r) {
    var i,
      f,
      m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
    if (a.t < this.t) {
      for (f = a.s & this.DM, i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f);
      r.t = this.t;
    } else {
      for (f = this.s & this.DM, i = m; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s), r.clamp();
  }
  __name(bnpBitwiseTo, "bnpBitwiseTo");
  function op_and(x, y) {
    return x & y;
  }
  __name(op_and, "op_and");
  function bnAnd(a) {
    var r = nbi();
    return this.bitwiseTo(a, op_and, r), r;
  }
  __name(bnAnd, "bnAnd");
  function op_or(x, y) {
    return x | y;
  }
  __name(op_or, "op_or");
  function bnOr(a) {
    var r = nbi();
    return this.bitwiseTo(a, op_or, r), r;
  }
  __name(bnOr, "bnOr");
  function op_xor(x, y) {
    return x ^ y;
  }
  __name(op_xor, "op_xor");
  function bnXor(a) {
    var r = nbi();
    return this.bitwiseTo(a, op_xor, r), r;
  }
  __name(bnXor, "bnXor");
  function op_andnot(x, y) {
    return x & ~y;
  }
  __name(op_andnot, "op_andnot");
  function bnAndNot(a) {
    var r = nbi();
    return this.bitwiseTo(a, op_andnot, r), r;
  }
  __name(bnAndNot, "bnAndNot");
  function bnNot() {
    for (var r = nbi(), i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
    return r.t = this.t, r.s = ~this.s, r;
  }
  __name(bnNot, "bnNot");
  function bnShiftLeft(n) {
    var r = nbi();
    return n < 0 ? this.rShiftTo(-n, r) : this.lShiftTo(n, r), r;
  }
  __name(bnShiftLeft, "bnShiftLeft");
  function bnShiftRight(n) {
    var r = nbi();
    return n < 0 ? this.lShiftTo(-n, r) : this.rShiftTo(n, r), r;
  }
  __name(bnShiftRight, "bnShiftRight");
  function lbit(x) {
    if (x == 0) return -1;
    var r = 0;
    return x & 65535 || (x >>= 16, r += 16), x & 255 || (x >>= 8, r += 8), x & 15 || (x >>= 4, r += 4), x & 3 || (x >>= 2, r += 2), x & 1 || ++r, r;
  }
  __name(lbit, "lbit");
  function bnGetLowestSetBit() {
    for (var i = 0; i < this.t; ++i) if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
    return this.s < 0 ? this.t * this.DB : -1;
  }
  __name(bnGetLowestSetBit, "bnGetLowestSetBit");
  function cbit(x) {
    for (var r = 0; x != 0;) x &= x - 1, ++r;
    return r;
  }
  __name(cbit, "cbit");
  function bnBitCount() {
    for (var r = 0, x = this.s & this.DM, i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
    return r;
  }
  __name(bnBitCount, "bnBitCount");
  function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    return j >= this.t ? this.s != 0 : (this.data[j] & 1 << n % this.DB) != 0;
  }
  __name(bnTestBit, "bnTestBit");
  function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    return this.bitwiseTo(r, op, r), r;
  }
  __name(bnpChangeBit, "bnpChangeBit");
  function bnSetBit(n) {
    return this.changeBit(n, op_or);
  }
  __name(bnSetBit, "bnSetBit");
  function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
  }
  __name(bnClearBit, "bnClearBit");
  function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
  }
  __name(bnFlipBit, "bnFlipBit");
  function bnpAddTo(a, r) {
    for (var i = 0, c = 0, m = Math.min(a.t, this.t); i < m;) c += this.data[i] + a.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
    if (a.t < this.t) {
      for (c += a.s; i < this.t;) c += this.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
      c += this.s;
    } else {
      for (c += this.s; i < a.t;) c += a.data[i], r.data[i++] = c & this.DM, c >>= this.DB;
      c += a.s;
    }
    r.s = c < 0 ? -1 : 0, c > 0 ? r.data[i++] = c : c < -1 && (r.data[i++] = this.DV + c), r.t = i, r.clamp();
  }
  __name(bnpAddTo, "bnpAddTo");
  function bnAdd(a) {
    var r = nbi();
    return this.addTo(a, r), r;
  }
  __name(bnAdd, "bnAdd");
  function bnSubtract(a) {
    var r = nbi();
    return this.subTo(a, r), r;
  }
  __name(bnSubtract, "bnSubtract");
  function bnMultiply(a) {
    var r = nbi();
    return this.multiplyTo(a, r), r;
  }
  __name(bnMultiply, "bnMultiply");
  function bnDivide(a) {
    var r = nbi();
    return this.divRemTo(a, r, null), r;
  }
  __name(bnDivide, "bnDivide");
  function bnRemainder(a) {
    var r = nbi();
    return this.divRemTo(a, null, r), r;
  }
  __name(bnRemainder, "bnRemainder");
  function bnDivideAndRemainder(a) {
    var q = nbi(),
      r = nbi();
    return this.divRemTo(a, q, r), new Array(q, r);
  }
  __name(bnDivideAndRemainder, "bnDivideAndRemainder");
  function bnpDMultiply(n) {
    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t), ++this.t, this.clamp();
  }
  __name(bnpDMultiply, "bnpDMultiply");
  function bnpDAddOffset(n, w) {
    if (n != 0) {
      for (; this.t <= w;) this.data[this.t++] = 0;
      for (this.data[w] += n; this.data[w] >= this.DV;) this.data[w] -= this.DV, ++w >= this.t && (this.data[this.t++] = 0), ++this.data[w];
    }
  }
  __name(bnpDAddOffset, "bnpDAddOffset");
  function NullExp() {}
  __name(NullExp, "NullExp");
  function nNop(x) {
    return x;
  }
  __name(nNop, "nNop");
  function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
  }
  __name(nMulTo, "nMulTo");
  function nSqrTo(x, r) {
    x.squareTo(r);
  }
  __name(nSqrTo, "nSqrTo");
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  function bnPow(e) {
    return this.exp(e, new NullExp());
  }
  __name(bnPow, "bnPow");
  function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    for (r.s = 0, r.t = i; i > 0;) r.data[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
    r.clamp();
  }
  __name(bnpMultiplyLowerTo, "bnpMultiplyLowerTo");
  function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    for (r.s = 0; --i >= 0;) r.data[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i) r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
    r.clamp(), r.drShiftTo(1, r);
  }
  __name(bnpMultiplyUpperTo, "bnpMultiplyUpperTo");
  function Barrett(m) {
    this.r2 = nbi(), this.q3 = nbi(), BigInteger.ONE.dlShiftTo(2 * m.t, this.r2), this.mu = this.r2.divide(m), this.m = m;
  }
  __name(Barrett, "Barrett");
  function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    if (x.compareTo(this.m) < 0) return x;
    var r = nbi();
    return x.copyTo(r), this.reduce(r), r;
  }
  __name(barrettConvert, "barrettConvert");
  function barrettRevert(x) {
    return x;
  }
  __name(barrettRevert, "barrettRevert");
  function barrettReduce(x) {
    for (x.drShiftTo(this.m.t - 1, this.r2), x.t > this.m.t + 1 && (x.t = this.m.t + 1, x.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); x.compareTo(this.r2) < 0;) x.dAddOffset(1, this.m.t + 1);
    for (x.subTo(this.r2, x); x.compareTo(this.m) >= 0;) x.subTo(this.m, x);
  }
  __name(barrettReduce, "barrettReduce");
  function barrettSqrTo(x, r) {
    x.squareTo(r), this.reduce(r);
  }
  __name(barrettSqrTo, "barrettSqrTo");
  function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r), this.reduce(r);
  }
  __name(barrettMulTo, "barrettMulTo");
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  function bnModPow(e, m) {
    var i = e.bitLength(),
      k,
      r = nbv(1),
      z;
    if (i <= 0) return r;
    i < 18 ? k = 1 : i < 48 ? k = 3 : i < 144 ? k = 4 : i < 768 ? k = 5 : k = 6, i < 8 ? z = new Classic(m) : m.isEven() ? z = new Barrett(m) : z = new Montgomery(m);
    var g = new Array(),
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
    if (g[1] = z.convert(this), k > 1) {
      var g2 = nbi();
      for (z.sqrTo(g[1], g2); n <= km;) g[n] = nbi(), z.mulTo(g2, g[n - 2], g[n]), n += 2;
    }
    var j = e.t - 1,
      w,
      is1 = !0,
      r2 = nbi(),
      t;
    for (i = nbits(e.data[j]) - 1; j >= 0;) {
      for (i >= k1 ? w = e.data[j] >> i - k1 & km : (w = (e.data[j] & (1 << i + 1) - 1) << k1 - i, j > 0 && (w |= e.data[j - 1] >> this.DB + i - k1)), n = k; !(w & 1);) w >>= 1, --n;
      if ((i -= n) < 0 && (i += this.DB, --j), is1) g[w].copyTo(r), is1 = !1;else {
        for (; n > 1;) z.sqrTo(r, r2), z.sqrTo(r2, r), n -= 2;
        n > 0 ? z.sqrTo(r, r2) : (t = r, r = r2, r2 = t), z.mulTo(r2, g[w], r);
      }
      for (; j >= 0 && !(e.data[j] & 1 << i);) z.sqrTo(r, r2), t = r, r = r2, r2 = t, --i < 0 && (i = this.DB - 1, --j);
    }
    return z.revert(r);
  }
  __name(bnModPow, "bnModPow");
  function bnGCD(a) {
    var x = this.s < 0 ? this.negate() : this.clone(),
      y = a.s < 0 ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
      var t = x;
      x = y, y = t;
    }
    var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
    if (g < 0) return x;
    for (i < g && (g = i), g > 0 && (x.rShiftTo(g, x), y.rShiftTo(g, y)); x.signum() > 0;) (i = x.getLowestSetBit()) > 0 && x.rShiftTo(i, x), (i = y.getLowestSetBit()) > 0 && y.rShiftTo(i, y), x.compareTo(y) >= 0 ? (x.subTo(y, x), x.rShiftTo(1, x)) : (y.subTo(x, y), y.rShiftTo(1, y));
    return g > 0 && y.lShiftTo(g, y), y;
  }
  __name(bnGCD, "bnGCD");
  function bnpModInt(n) {
    if (n <= 0) return 0;
    var d = this.DV % n,
      r = this.s < 0 ? n - 1 : 0;
    if (this.t > 0) if (d == 0) r = this.data[0] % n;else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
    return r;
  }
  __name(bnpModInt, "bnpModInt");
  function bnModInverse(m) {
    var ac = m.isEven();
    if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
    for (var u = m.clone(), v = this.clone(), a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1); u.signum() != 0;) {
      for (; u.isEven();) u.rShiftTo(1, u), ac ? ((!a.isEven() || !b.isEven()) && (a.addTo(this, a), b.subTo(m, b)), a.rShiftTo(1, a)) : b.isEven() || b.subTo(m, b), b.rShiftTo(1, b);
      for (; v.isEven();) v.rShiftTo(1, v), ac ? ((!c.isEven() || !d.isEven()) && (c.addTo(this, c), d.subTo(m, d)), c.rShiftTo(1, c)) : d.isEven() || d.subTo(m, d), d.rShiftTo(1, d);
      u.compareTo(v) >= 0 ? (u.subTo(v, u), ac && a.subTo(c, a), b.subTo(d, b)) : (v.subTo(u, v), ac && c.subTo(a, c), d.subTo(b, d));
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d);else return d;
    return d.signum() < 0 ? d.add(m) : d;
  }
  __name(bnModInverse, "bnModInverse");
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509],
    lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  function bnIsProbablePrime(t) {
    var i,
      x = this.abs();
    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
      for (i = 0; i < lowprimes.length; ++i) if (x.data[0] == lowprimes[i]) return !0;
      return !1;
    }
    if (x.isEven()) return !1;
    for (i = 1; i < lowprimes.length;) {
      for (var m = lowprimes[i], j = i + 1; j < lowprimes.length && m < lplim;) m *= lowprimes[j++];
      for (m = x.modInt(m); i < j;) if (m % lowprimes[i++] == 0) return !1;
    }
    return x.millerRabin(t);
  }
  __name(bnIsProbablePrime, "bnIsProbablePrime");
  function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE),
      k = n1.getLowestSetBit();
    if (k <= 0) return !1;
    for (var r = n1.shiftRight(k), prng = bnGetPrng(), a, i = 0; i < t; ++i) {
      do a = new BigInteger(this.bitLength(), prng); while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
        for (var j = 1; j++ < k && y.compareTo(n1) != 0;) if (y = y.modPowInt(2, this), y.compareTo(BigInteger.ONE) == 0) return !1;
        if (y.compareTo(n1) != 0) return !1;
      }
    }
    return !0;
  }
  __name(bnpMillerRabin, "bnpMillerRabin");
  function bnGetPrng() {
    return {
      nextBytes: function (x) {
        for (var i = 0; i < x.length; ++i) x[i] = Math.floor(Math.random() * 256);
      }
    };
  }
  __name(bnGetPrng, "bnGetPrng");
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
});
var require_sha1 = __commonJSMin((exports, module) => {
  var forge = ta();
  Qf();
  La();
  var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
  forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
  sha1.create = function () {
    _initialized || _init();
    var _state = null,
      _input = forge.util.createBuffer(),
      _w = new Array(80),
      md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
    return md.start = function () {
      md.messageLength = 0, md.fullMessageLength = md.messageLength64 = [];
      for (var int32s = md.messageLengthSize / 4, i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
      return _input = forge.util.createBuffer(), _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878,
        h4: 3285377520
      }, md;
    }, md.start(), md.update = function (msg, encoding) {
      encoding === "utf8" && (msg = forge.util.encodeUtf8(msg));
      var len = msg.length;
      md.messageLength += len, len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) md.fullMessageLength[i] += len[1], len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0), md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0, len[0] = len[1] / 4294967296 >>> 0;
      return _input.putBytes(msg), _update(_state, _w, _input), (_input.read > 2048 || _input.length() === 0) && _input.compact(), md;
    }, md.digest = function () {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize,
        overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      for (var next, carry, bits = md.fullMessageLength[0] * 8, i = 0; i < md.fullMessageLength.length - 1; ++i) next = md.fullMessageLength[i + 1] * 8, carry = next / 4294967296 >>> 0, bits += carry, finalBlock.putInt32(bits >>> 0), bits = next >>> 0;
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      return rval.putInt32(s2.h0), rval.putInt32(s2.h1), rval.putInt32(s2.h2), rval.putInt32(s2.h3), rval.putInt32(s2.h4), rval;
    }, md;
  };
  var _padding = null,
    _initialized = !1;
  function _init() {
    _padding = String.fromCharCode(128), _padding += forge.util.fillString(String.fromCharCode(0), 64), _initialized = !0;
  }
  __name(_init, "_init");
  function _update(s, w, bytes) {
    for (var t, a, b, c, d, e, f, i, len = bytes.length(); len >= 64;) {
      for (a = s.h0, b = s.h1, c = s.h2, d = s.h3, e = s.h4, i = 0; i < 16; ++i) t = bytes.getInt32(), w[i] = t, f = d ^ b & (c ^ d), t = (a << 5 | a >>> 27) + f + e + 1518500249 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      for (; i < 20; ++i) t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], t = t << 1 | t >>> 31, w[i] = t, f = d ^ b & (c ^ d), t = (a << 5 | a >>> 27) + f + e + 1518500249 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      for (; i < 32; ++i) t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], t = t << 1 | t >>> 31, w[i] = t, f = b ^ c ^ d, t = (a << 5 | a >>> 27) + f + e + 1859775393 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      for (; i < 40; ++i) t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32], t = t << 2 | t >>> 30, w[i] = t, f = b ^ c ^ d, t = (a << 5 | a >>> 27) + f + e + 1859775393 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      for (; i < 60; ++i) t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32], t = t << 2 | t >>> 30, w[i] = t, f = b & c | d & (b ^ c), t = (a << 5 | a >>> 27) + f + e + 2400959708 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      for (; i < 80; ++i) t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32], t = t << 2 | t >>> 30, w[i] = t, f = b ^ c ^ d, t = (a << 5 | a >>> 27) + f + e + 3395469782 + t, e = d, d = c, c = (b << 30 | b >>> 2) >>> 0, b = a, a = t;
      s.h0 = s.h0 + a | 0, s.h1 = s.h1 + b | 0, s.h2 = s.h2 + c | 0, s.h3 = s.h3 + d | 0, s.h4 = s.h4 + e | 0, len -= 64;
    }
  }
  __name(_update, "_update");
});
var require_pkcs1 = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  Du();
  r3();
  var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
  pkcs1.encode_rsa_oaep = function (key, message, options) {
    var label, seed, md, mgf1Md;
    typeof options == "string" ? (label = options, seed = arguments[3] || void 0, md = arguments[4] || void 0) : options && (label = options.label || void 0, seed = options.seed || void 0, md = options.md || void 0, options.mgf1 && options.mgf1.md && (mgf1Md = options.mgf1.md)), md ? md.start() : md = forge.md.sha1.create(), mgf1Md || (mgf1Md = md);
    var keyLength = Math.ceil(key.n.bitLength() / 8),
      maxLength = keyLength - 2 * md.digestLength - 2;
    if (message.length > maxLength) {
      var error = new Error("RSAES-OAEP input message length is too long.");
      throw error.length = message.length, error.maxLength = maxLength, error;
    }
    label || (label = ""), md.update(label, "raw");
    for (var lHash = md.digest(), PS = "", PS_length = maxLength - message.length, i = 0; i < PS_length; i++) PS += "\0";
    var DB = lHash.getBytes() + PS + "" + message;
    if (!seed) seed = forge.random.getBytes(md.digestLength);else if (seed.length !== md.digestLength) {
      var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      throw error.seedLength = seed.length, error.digestLength = md.digestLength, error;
    }
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md),
      maskedDB = forge.util.xorBytes(DB, dbMask, DB.length),
      seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md),
      maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
    return "\0" + maskedSeed + maskedDB;
  };
  pkcs1.decode_rsa_oaep = function (key, em, options) {
    var label, md, mgf1Md;
    typeof options == "string" ? (label = options, md = arguments[3] || void 0) : options && (label = options.label || void 0, md = options.md || void 0, options.mgf1 && options.mgf1.md && (mgf1Md = options.mgf1.md));
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    if (em.length !== keyLength) {
      var error = new Error("RSAES-OAEP encoded message length is invalid.");
      throw error.length = em.length, error.expectedLength = keyLength, error;
    }
    if (md === void 0 ? md = forge.md.sha1.create() : md.start(), mgf1Md || (mgf1Md = md), keyLength < 2 * md.digestLength + 2) throw new Error("RSAES-OAEP key is too short for the hash function.");
    label || (label = ""), md.update(label, "raw");
    for (var lHash = md.digest().getBytes(), y = em.charAt(0), maskedSeed = em.substring(1, md.digestLength + 1), maskedDB = em.substring(1 + md.digestLength), seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md), seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length), dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md), db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length), lHashPrime = db.substring(0, md.digestLength), error = y !== "\0", i = 0; i < md.digestLength; ++i) error |= lHash.charAt(i) !== lHashPrime.charAt(i);
    for (var in_ps = 1, index = md.digestLength, j = md.digestLength; j < db.length; j++) {
      var code = db.charCodeAt(j),
        is_0 = code & 1 ^ 1,
        error_mask = in_ps ? 65534 : 0;
      error |= code & error_mask, in_ps = in_ps & is_0, index += in_ps;
    }
    if (error || db.charCodeAt(index) !== 1) throw new Error("Invalid RSAES-OAEP padding.");
    return db.substring(index + 1);
  };
  function rsa_mgf1(seed, maskLength, hash) {
    hash || (hash = forge.md.sha1.create());
    for (var t = "", count = Math.ceil(maskLength / hash.digestLength), i = 0; i < count; ++i) {
      var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
      hash.start(), hash.update(seed + c), t += hash.digest().getBytes();
    }
    return t.substring(0, maskLength);
  }
  __name(rsa_mgf1, "rsa_mgf1");
});
var require_prime = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  H_();
  Du();
  (function () {
    if (forge.prime) {
      module.exports = forge.prime;
      return;
    }
    var prime = module.exports = forge.prime = forge.prime || {},
      BigInteger = forge.jsbn.BigInteger,
      GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2],
      THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var op_or = __name(function (x, y) {
      return x | y;
    }, "op_or");
    prime.generateProbablePrime = function (bits, options, callback) {
      typeof options == "function" && (callback = options, options = {}), options = options || {};
      var algorithm = options.algorithm || "PRIMEINC";
      typeof algorithm == "string" && (algorithm = {
        name: algorithm
      }), algorithm.options = algorithm.options || {};
      var prng = options.prng || forge.random,
        rng = {
          nextBytes: function (x) {
            for (var b = prng.getBytesSync(x.length), i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
          }
        };
      if (algorithm.name === "PRIMEINC") return primeincFindPrime(bits, rng, algorithm.options, callback);
      throw new Error("Invalid prime generation algorithm: " + algorithm.name);
    };
    function primeincFindPrime(bits, rng, options, callback) {
      return "workers" in options ? primeincFindPrimeWithWorkers(bits, rng, options, callback) : primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    __name(primeincFindPrime, "primeincFindPrime");
    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
      var num = generateRandom(bits, rng),
        deltaIdx = 0,
        mrTests = getMillerRabinTests(num.bitLength());
      "millerRabinTests" in options && (mrTests = options.millerRabinTests);
      var maxBlockTime = 10;
      "maxBlockTime" in options && (maxBlockTime = options.maxBlockTime), _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    }
    __name(primeincFindPrimeWithoutWorkers, "primeincFindPrimeWithoutWorkers");
    function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
      var start = +new Date();
      do {
        if (num.bitLength() > bits && (num = generateRandom(bits, rng)), num.isProbablePrime(mrTests)) return callback(null, num);
        num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
      forge.util.setImmediate(function () {
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      });
    }
    __name(_primeinc, "_primeinc");
    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
      if (typeof Worker > "u") return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      var num = generateRandom(bits, rng),
        numWorkers = options.workers,
        workLoad = options.workLoad || 100,
        range = workLoad * 30 / 8,
        workerScript = options.workerScript || "forge/prime.worker.js";
      if (numWorkers === -1) return forge.util.estimateCores(function (err, cores) {
        err && (cores = 2), numWorkers = cores - 1, generate();
      });
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        for (var workers = [], i = 0; i < numWorkers; ++i) workers[i] = new Worker(workerScript);
        for (var running = numWorkers, i = 0; i < numWorkers; ++i) workers[i].addEventListener("message", workerMessage);
        var found = !1;
        function workerMessage(e) {
          if (!found) {
            --running;
            var data = e.data;
            if (data.found) {
              for (var i = 0; i < workers.length; ++i) workers[i].terminate();
              return found = !0, callback(null, new BigInteger(data.prime, 16));
            }
            num.bitLength() > bits && (num = generateRandom(bits, rng));
            var hex = num.toString(16);
            e.target.postMessage({
              hex: hex,
              workLoad: workLoad
            }), num.dAddOffset(range, 0);
          }
        }
        __name(workerMessage, "workerMessage");
      }
      __name(generate, "generate");
    }
    __name(primeincFindPrimeWithWorkers, "primeincFindPrimeWithWorkers");
    function generateRandom(bits, rng) {
      var num = new BigInteger(bits, rng),
        bits1 = bits - 1;
      return num.testBit(bits1) || num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num), num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0), num;
    }
    __name(generateRandom, "generateRandom");
    function getMillerRabinTests(bits) {
      return bits <= 100 ? 27 : bits <= 150 ? 18 : bits <= 200 ? 15 : bits <= 250 ? 12 : bits <= 300 ? 9 : bits <= 350 ? 8 : bits <= 400 ? 7 : bits <= 500 ? 6 : bits <= 600 ? 5 : bits <= 800 ? 4 : bits <= 1250 ? 3 : 2;
    }
    __name(getMillerRabinTests, "getMillerRabinTests");
  })();
});
var require_rsa = __commonJSMin((exports, module) => {
  var forge = ta();
  df();
  H_();
  b1();
  fk();
  pk();
  Du();
  La();
  typeof BigInteger > "u" && (BigInteger = forge.jsbn.BigInteger);
  var BigInteger,
    _crypto = forge.util.isNodejs ? require("crypto") : null,
    asn1 = forge.asn1,
    util = forge.util;
  forge.pki = forge.pki || {};
  module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
  var pki = forge.pki,
    GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2],
    privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "privateKey"
      }]
    },
    rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "privateKeyCoefficient"
      }]
    },
    rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "publicKeyExponent"
      }]
    },
    publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          optional: !0,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    },
    digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "algorithmIdentifier"
        }, {
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          capture: "parameters",
          optional: !0,
          constructed: !1
        }]
      }, {
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "digest"
      }]
    },
    emsaPkcs1v15encode = __name(function (md) {
      var oid;
      if (md.algorithm in pki.oids) oid = pki.oids[md.algorithm];else {
        var error = new Error("Unknown message digest algorithm.");
        throw error.algorithm = md.algorithm, error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes(),
        digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []),
        digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, oidBytes)), digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, ""));
      var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, md.digest().getBytes());
      return digestInfo.value.push(digestAlgorithm), digestInfo.value.push(digest), asn1.toDer(digestInfo).getBytes();
    }, "emsaPkcs1v15encode"),
    _modPow = __name(function (x, key, pub) {
      if (pub) return x.modPow(key.e, key.n);
      if (!key.p || !key.q) return x.modPow(key.d, key.n);
      key.dP || (key.dP = key.d.mod(key.p.subtract(BigInteger.ONE))), key.dQ || (key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE))), key.qInv || (key.qInv = key.q.modInverse(key.p));
      var r;
      do r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16); while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      for (var xp = x.mod(key.p).modPow(key.dP, key.p), xq = x.mod(key.q).modPow(key.dQ, key.q); xp.compareTo(xq) < 0;) xp = xp.add(key.p);
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      return y = y.multiply(r.modInverse(key.n)).mod(key.n), y;
    }, "_modPow");
  pki.rsa.encrypt = function (m, key, bt) {
    var pub = bt,
      eb,
      k = Math.ceil(key.n.bitLength() / 8);
    bt !== !1 && bt !== !0 ? (pub = bt === 2, eb = _encodePkcs1_v1_5(m, key, bt)) : (eb = forge.util.createBuffer(), eb.putBytes(m));
    for (var x = new BigInteger(eb.toHex(), 16), y = _modPow(x, key, pub), yhex = y.toString(16), ed = forge.util.createBuffer(), zeros = k - Math.ceil(yhex.length / 2); zeros > 0;) ed.putByte(0), --zeros;
    return ed.putBytes(forge.util.hexToBytes(yhex)), ed.getBytes();
  };
  pki.rsa.decrypt = function (ed, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    if (ed.length !== k) {
      var error = new Error("Encrypted message length is invalid.");
      throw error.length = ed.length, error.expected = k, error;
    }
    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
    if (y.compareTo(key.n) >= 0) throw new Error("Encrypted message is invalid.");
    for (var x = _modPow(y, key, pub), xhex = x.toString(16), eb = forge.util.createBuffer(), zeros = k - Math.ceil(xhex.length / 2); zeros > 0;) eb.putByte(0), --zeros;
    return eb.putBytes(forge.util.hexToBytes(xhex)), ml !== !1 ? _decodePkcs1_v1_5(eb.getBytes(), key, pub) : eb.getBytes();
  };
  pki.rsa.createKeyPairGenerationState = function (bits, e, options) {
    typeof bits == "string" && (bits = parseInt(bits, 10)), bits = bits || 2048, options = options || {};
    var prng = options.prng || forge.random,
      rng = {
        nextBytes: function (x) {
          for (var b = prng.getBytesSync(x.length), i = 0; i < x.length; ++i) x[i] = b.charCodeAt(i);
        }
      },
      algorithm = options.algorithm || "PRIMEINC",
      rval;
    if (algorithm === "PRIMEINC") rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, rval.e.fromInt(rval.eInt);else throw new Error("Invalid key generation algorithm: " + algorithm);
    return rval;
  };
  pki.rsa.stepKeyPairGenerationState = function (state, n) {
    "algorithm" in state || (state.algorithm = "PRIMEINC");
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    for (var deltaIdx = 0, op_or = __name(function (x, y) {
        return x | y;
      }, "op_or"), t1 = +new Date(), t2, total = 0; state.keys === null && (n <= 0 || total < n);) {
      if (state.state === 0) {
        var bits = state.p === null ? state.pBits : state.qBits,
          bits1 = bits - 1;
        state.pqState === 0 ? (state.num = new BigInteger(bits, state.rng), state.num.testBit(bits1) || state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num), state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0), deltaIdx = 0, ++state.pqState) : state.pqState === 1 ? state.num.bitLength() > bits ? state.pqState = 0 : state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength())) ? ++state.pqState : state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0) : state.pqState === 2 ? state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0 : state.pqState === 3 && (state.pqState = 0, state.p === null ? state.p = state.num : state.q = state.num, state.p !== null && state.q !== null && ++state.state, state.num = null);
      } else if (state.state === 1) state.p.compareTo(state.q) < 0 && (state.num = state.p, state.p = state.q, state.q = state.num), ++state.state;else if (state.state === 2) state.p1 = state.p.subtract(BigInteger.ONE), state.q1 = state.q.subtract(BigInteger.ONE), state.phi = state.p1.multiply(state.q1), ++state.state;else if (state.state === 3) state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0 ? ++state.state : (state.p = null, state.q = null, state.state = 0);else if (state.state === 4) state.n = state.p.multiply(state.q), state.n.bitLength() === state.bits ? ++state.state : (state.q = null, state.state = 0);else if (state.state === 5) {
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
      }
      t2 = +new Date(), total += t2 - t1, t1 = t2;
    }
    return state.keys !== null;
  };
  pki.rsa.generateKeyPair = function (bits, e, options, callback) {
    if (arguments.length === 1 ? typeof bits == "object" ? (options = bits, bits = void 0) : typeof bits == "function" && (callback = bits, bits = void 0) : arguments.length === 2 ? typeof bits == "number" ? typeof e == "function" ? (callback = e, e = void 0) : typeof e != "number" && (options = e, e = void 0) : (options = bits, callback = e, bits = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof options == "function" && (callback = options, options = void 0) : (callback = options, options = e, e = void 0)), options = options || {}, bits === void 0 && (bits = options.bits || 2048), e === void 0 && (e = options.e || 65537), !forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
      if (callback) {
        if (_detectNodeCrypto("generateKeyPair")) return _crypto.generateKeyPair("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function (err, pub, priv) {
          if (err) return callback(err);
          callback(null, {
            privateKey: pki.privateKeyFromPem(priv),
            publicKey: pki.publicKeyFromPem(pub)
          });
        });
        if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) return util.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {
            name: "SHA-256"
          }
        }, !0, ["sign", "verify"]).then(function (pair) {
          return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
        }).then(void 0, function (err) {
          callback(err);
        }).then(function (pkcs8) {
          if (pkcs8) {
            var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
        if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
          var genOp = util.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {
              name: "SHA-256"
            }
          }, !0, ["sign", "verify"]);
          genOp.oncomplete = function (e) {
            var pair = e.target.result,
              exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
            exportOp.oncomplete = function (e) {
              var pkcs8 = e.target.result,
                privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey: privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            }, exportOp.onerror = function (err) {
              callback(err);
            };
          }, genOp.onerror = function (err) {
            callback(err);
          };
          return;
        }
      } else if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: pki.privateKeyFromPem(keypair.privateKey),
          publicKey: pki.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
    if (!callback) return pki.rsa.stepKeyPairGenerationState(state, 0), state.keys;
    _generateKeyPair(state, options, callback);
  };
  pki.setRsaPublicKey = pki.rsa.setPublicKey = function (n, e) {
    var key = {
      n: n,
      e: e
    };
    return key.encrypt = function (data, scheme, schemeOptions) {
      if (typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSAES-PKCS1-V1_5"), scheme === "RSAES-PKCS1-V1_5") scheme = {
        encode: function (m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 2).getBytes();
        }
      };else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = {
        encode: function (m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) scheme = {
        encode: function (e) {
          return e;
        }
      };else if (typeof scheme == "string") throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      var e = scheme.encode(data, key, !0);
      return pki.rsa.encrypt(e, key, !0);
    }, key.verify = function (digest, signature, scheme, options) {
      typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSASSA-PKCS1-V1_5"), options === void 0 && (options = {
        _parseAllDigestBytes: !0
      }), "_parseAllDigestBytes" in options || (options._parseAllDigestBytes = !0), scheme === "RSASSA-PKCS1-V1_5" ? scheme = {
        verify: function (digest, d) {
          d = _decodePkcs1_v1_5(d, key, !0);
          var obj = asn1.fromDer(d, {
              parseAllBytes: options._parseAllDigestBytes
            }),
            capture = {},
            errors = [];
          if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
            var error = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
            throw error.errors = errors, error;
          }
          var oid = asn1.derToOid(capture.algorithmIdentifier);
          if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
            var error = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
            throw error.oid = oid, error;
          }
          if ((oid === forge.oids.md2 || oid === forge.oids.md5) && !("parameters" in capture)) throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
          return digest === capture.digest;
        }
      } : (scheme === "NONE" || scheme === "NULL" || scheme === null) && (scheme = {
        verify: function (digest, d) {
          return d = _decodePkcs1_v1_5(d, key, !0), digest === d;
        }
      });
      var d = pki.rsa.decrypt(signature, key, !0, !1);
      return scheme.verify(digest, d, key.n.bitLength());
    }, key;
  };
  pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function (n, e, d, p, q, dP, dQ, qInv) {
    var key = {
      n: n,
      e: e,
      d: d,
      p: p,
      q: q,
      dP: dP,
      dQ: dQ,
      qInv: qInv
    };
    return key.decrypt = function (data, scheme, schemeOptions) {
      typeof scheme == "string" ? scheme = scheme.toUpperCase() : scheme === void 0 && (scheme = "RSAES-PKCS1-V1_5");
      var d = pki.rsa.decrypt(data, key, !1, !1);
      if (scheme === "RSAES-PKCS1-V1_5") scheme = {
        decode: _decodePkcs1_v1_5
      };else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") scheme = {
        decode: function (d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) scheme = {
        decode: function (d) {
          return d;
        }
      };else throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      return scheme.decode(d, key, !1);
    }, key.sign = function (md, scheme) {
      var bt = !1;
      typeof scheme == "string" && (scheme = scheme.toUpperCase()), scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5" ? (scheme = {
        encode: emsaPkcs1v15encode
      }, bt = 1) : (scheme === "NONE" || scheme === "NULL" || scheme === null) && (scheme = {
        encode: function () {
          return md;
        }
      }, bt = 1);
      var d = scheme.encode(md, key.n.bitLength());
      return pki.rsa.encrypt(d, key, bt);
    }, key;
  };
  pki.wrapRsaPrivateKey = function (rsaKey) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(rsaKey).getBytes())]);
  };
  pki.privateKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [];
    if (asn1.validate(obj, privateKeyValidator, capture, errors) && (obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey))), capture = {}, errors = [], !asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      throw error.errors = errors, error;
    }
    var n, e, d, p, q, dP, dQ, qInv;
    return n = forge.util.createBuffer(capture.privateKeyModulus).toHex(), e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex(), d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex(), p = forge.util.createBuffer(capture.privateKeyPrime1).toHex(), q = forge.util.createBuffer(capture.privateKeyPrime2).toHex(), dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex(), dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex(), qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex(), pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
  };
  pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(0).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.e)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.d)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.p)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.q)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.dP)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.dQ)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.qInv))]);
  };
  pki.publicKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [];
    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        var error = new Error("Cannot read public key. Unknown OID.");
        throw error.oid = oid, error;
      }
      obj = capture.rsaPublicKey;
    }
    if (errors = [], !asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
      var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      throw error.errors = errors, error;
    }
    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex(),
      e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
  };
  pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, [pki.publicKeyToRSAPublicKey(key)])]);
  };
  pki.publicKeyToRSAPublicKey = function (key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.n)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, _bnToBytes(key.e))]);
  };
  function _encodePkcs1_v1_5(m, key, bt) {
    var eb = forge.util.createBuffer(),
      k = Math.ceil(key.n.bitLength() / 8);
    if (m.length > k - 11) {
      var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
      throw error.length = m.length, error.max = k - 11, error;
    }
    eb.putByte(0), eb.putByte(bt);
    var padNum = k - 3 - m.length,
      padByte;
    if (bt === 0 || bt === 1) {
      padByte = bt === 0 ? 0 : 255;
      for (var i = 0; i < padNum; ++i) eb.putByte(padByte);
    } else for (; padNum > 0;) {
      for (var numZeros = 0, padBytes = forge.random.getBytes(padNum), i = 0; i < padNum; ++i) padByte = padBytes.charCodeAt(i), padByte === 0 ? ++numZeros : eb.putByte(padByte);
      padNum = numZeros;
    }
    return eb.putByte(0), eb.putBytes(m), eb;
  }
  __name(_encodePkcs1_v1_5, "_encodePkcs1_v1_5");
  function _decodePkcs1_v1_5(em, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8),
      eb = forge.util.createBuffer(em),
      first = eb.getByte(),
      bt = eb.getByte();
    if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml > "u") throw new Error("Encryption block is invalid.");
    var padNum = 0;
    if (bt === 0) {
      padNum = k - 3 - ml;
      for (var i = 0; i < padNum; ++i) if (eb.getByte() !== 0) throw new Error("Encryption block is invalid.");
    } else if (bt === 1) for (padNum = 0; eb.length() > 1;) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    } else if (bt === 2) for (padNum = 0; eb.length() > 1;) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
    var zero = eb.getByte();
    if (zero !== 0 || padNum !== k - 3 - eb.length()) throw new Error("Encryption block is invalid.");
    return eb.getBytes();
  }
  __name(_decodePkcs1_v1_5, "_decodePkcs1_v1_5");
  function _generateKeyPair(state, options, callback) {
    typeof options == "function" && (callback = options, options = {}), options = options || {};
    var opts = {
      algorithm: {
        name: options.algorithm || "PRIMEINC",
        options: {
          workers: options.workers || 2,
          workLoad: options.workLoad || 100,
          workerScript: options.workerScript
        }
      }
    };
    "prng" in options && (opts.prng = options.prng), generate();
    function generate() {
      getPrime(state.pBits, function (err, num) {
        if (err) return callback(err);
        if (state.p = num, state.q !== null) return finish(err, state.q);
        getPrime(state.qBits, finish);
      });
    }
    __name(generate, "generate");
    function getPrime(bits, callback) {
      forge.prime.generateProbablePrime(bits, opts, callback);
    }
    __name(getPrime, "getPrime");
    function finish(err, num) {
      if (err) return callback(err);
      if (state.q = num, state.p.compareTo(state.q) < 0) {
        var tmp = state.p;
        state.p = state.q, state.q = tmp;
      }
      if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = null, generate();
        return;
      }
      if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.q = null, getPrime(state.qBits, finish);
        return;
      }
      if (state.p1 = state.p.subtract(BigInteger.ONE), state.q1 = state.q.subtract(BigInteger.ONE), state.phi = state.p1.multiply(state.q1), state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = state.q = null, generate();
        return;
      }
      if (state.n = state.p.multiply(state.q), state.n.bitLength() !== state.bits) {
        state.q = null, getPrime(state.qBits, finish);
        return;
      }
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      }, callback(null, state.keys);
    }
    __name(finish, "finish");
  }
  __name(_generateKeyPair, "_generateKeyPair");
  function _bnToBytes(b) {
    var hex = b.toString(16);
    hex[0] >= "8" && (hex = "00" + hex);
    var bytes = forge.util.hexToBytes(hex);
    return bytes.length > 1 && (bytes.charCodeAt(0) === 0 && !(bytes.charCodeAt(1) & 128) || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128) ? bytes.substr(1) : bytes;
  }
  __name(_bnToBytes, "_bnToBytes");
  function _getMillerRabinTests(bits) {
    return bits <= 100 ? 27 : bits <= 150 ? 18 : bits <= 200 ? 15 : bits <= 250 ? 12 : bits <= 300 ? 9 : bits <= 350 ? 8 : bits <= 400 ? 7 : bits <= 500 ? 6 : bits <= 600 ? 5 : bits <= 800 ? 4 : bits <= 1250 ? 3 : 2;
  }
  __name(_getMillerRabinTests, "_getMillerRabinTests");
  function _detectNodeCrypto(fn) {
    return forge.util.isNodejs && typeof _crypto[fn] == "function";
  }
  __name(_detectNodeCrypto, "_detectNodeCrypto");
  function _detectSubtleCrypto(fn) {
    return typeof util.globalScope < "u" && typeof util.globalScope.crypto == "object" && typeof util.globalScope.crypto.subtle == "object" && typeof util.globalScope.crypto.subtle[fn] == "function";
  }
  __name(_detectSubtleCrypto, "_detectSubtleCrypto");
  function _detectSubtleMsCrypto(fn) {
    return typeof util.globalScope < "u" && typeof util.globalScope.msCrypto == "object" && typeof util.globalScope.msCrypto.subtle == "object" && typeof util.globalScope.msCrypto.subtle[fn] == "function";
  }
  __name(_detectSubtleMsCrypto, "_detectSubtleMsCrypto");
  function _intToUint8Array(x) {
    for (var bytes = forge.util.hexToBytes(x.toString(16)), buffer = new Uint8Array(bytes.length), i = 0; i < bytes.length; ++i) buffer[i] = bytes.charCodeAt(i);
    return buffer;
  }
  __name(_intToUint8Array, "_intToUint8Array");
});
var require_pbe = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  df();
  q_();
  Qf();
  b1();
  BE();
  dh();
  Du();
  ok();
  $_();
  La();
  typeof BigInteger > "u" && (BigInteger = forge.jsbn.BigInteger);
  var BigInteger,
    asn1 = forge.asn1,
    pki = forge.pki = forge.pki || {};
  module.exports = pki.pbe = forge.pbe = forge.pbe || {};
  var oids = pki.oids,
    encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "encryptedData"
      }]
    },
    PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: !1,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            optional: !0,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            optional: !0,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: !1,
          capture: "encIv"
        }]
      }]
    },
    pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: !1,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "iterations"
      }]
    };
  pki.encryptPrivateKeyInfo = function (obj, password, options) {
    options = options || {}, options.saltSize = options.saltSize || 8, options.count = options.count || 2048, options.algorithm = options.algorithm || "aes128", options.prfAlgorithm = options.prfAlgorithm || "sha1";
    var salt = forge.random.getBytesSync(options.saltSize),
      count = options.count,
      countBytes = asn1.integerToDer(count),
      dkLen,
      encryptionAlgorithm,
      encryptedData;
    if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
      var ivLen, encOid, cipherFn;
      switch (options.algorithm) {
        case "aes128":
          dkLen = 16, ivLen = 16, encOid = oids["aes128-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          dkLen = 24, ivLen = 16, encOid = oids["aes192-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          dkLen = 32, ivLen = 16, encOid = oids["aes256-CBC"], cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "des":
          dkLen = 8, ivLen = 8, encOid = oids.desCBC, cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          throw error.algorithm = options.algorithm, error;
      }
      var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase(),
        md = prfAlgorithmToMessageDigest(prfAlgorithm),
        dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md),
        iv = forge.random.getBytesSync(ivLen),
        cipher = cipherFn(dk);
      cipher.start(iv), cipher.update(asn1.toDer(obj)), cipher.finish(), encryptedData = cipher.output.getBytes();
      var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids.pkcs5PBES2).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()), params]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(encOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, iv)])])]);
    } else if (options.algorithm === "3des") {
      dkLen = 24;
      var saltBytes = new forge.util.ByteBuffer(salt),
        dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen),
        iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen),
        cipher = forge.des.createEncryptionCipher(dk);
      cipher.start(iv), cipher.update(asn1.toDer(obj)), cipher.finish(), encryptedData = cipher.output.getBytes(), encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, countBytes.getBytes())])]);
    } else {
      var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      throw error.algorithm = options.algorithm, error;
    }
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [encryptionAlgorithm, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, encryptedData)]);
    return rval;
  };
  pki.decryptPrivateKeyInfo = function (obj, password) {
    var rval = null,
      capture = {},
      errors = [];
    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.encryptionOid),
      cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password),
      encrypted = forge.util.createBuffer(capture.encryptedData);
    return cipher.update(encrypted), cipher.finish() && (rval = asn1.fromDer(cipher.output)), rval;
  };
  pki.encryptedPrivateKeyToPem = function (epki, maxline) {
    var msg = {
      type: "ENCRYPTED PRIVATE KEY",
      body: asn1.toDer(epki).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.encryptedPrivateKeyFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY") {
      var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    return asn1.fromDer(msg.body);
  };
  pki.encryptRsaPrivateKey = function (rsaKey, password, options) {
    if (options = options || {}, !options.legacy) {
      var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
      return rval = pki.encryptPrivateKeyInfo(rval, password, options), pki.encryptedPrivateKeyToPem(rval);
    }
    var algorithm, iv, dkLen, cipherFn;
    switch (options.algorithm) {
      case "aes128":
        algorithm = "AES-128-CBC", dkLen = 16, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes192":
        algorithm = "AES-192-CBC", dkLen = 24, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes256":
        algorithm = "AES-256-CBC", dkLen = 32, iv = forge.random.getBytesSync(16), cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "3des":
        algorithm = "DES-EDE3-CBC", dkLen = 24, iv = forge.random.getBytesSync(8), cipherFn = forge.des.createEncryptionCipher;
        break;
      case "des":
        algorithm = "DES-CBC", dkLen = 8, iv = forge.random.getBytesSync(8), cipherFn = forge.des.createEncryptionCipher;
        break;
      default:
        var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
        throw error.algorithm = options.algorithm, error;
    }
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen),
      cipher = cipherFn(dk);
    cipher.start(iv), cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey))), cipher.finish();
    var msg = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm: algorithm,
        parameters: forge.util.bytesToHex(iv).toUpperCase()
      },
      body: cipher.output.getBytes()
    };
    return forge.pem.encode(msg);
  };
  pki.decryptRsaPrivateKey = function (pem, password) {
    var rval = null,
      msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      throw error.headerType = error, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      var dkLen, cipherFn;
      switch (msg.dekInfo.algorithm) {
        case "DES-CBC":
          dkLen = 8, cipherFn = forge.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          dkLen = 24, cipherFn = forge.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          dkLen = 16, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          dkLen = 24, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          dkLen = 32, cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          dkLen = 5, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 40);
          }, "cipherFn");
          break;
        case "RC2-64-CBC":
          dkLen = 8, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 64);
          }, "cipherFn");
          break;
        case "RC2-128-CBC":
          dkLen = 16, cipherFn = __name(function (key) {
            return forge.rc2.createDecryptionCipher(key, 128);
          }, "cipherFn");
          break;
        default:
          var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
          throw error.algorithm = msg.dekInfo.algorithm, error;
      }
      var iv = forge.util.hexToBytes(msg.dekInfo.parameters),
        dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen),
        cipher = cipherFn(dk);
      if (cipher.start(iv), cipher.update(forge.util.createBuffer(msg.body)), cipher.finish()) rval = cipher.output.getBytes();else return rval;
    } else rval = msg.body;
    return msg.type === "ENCRYPTED PRIVATE KEY" ? rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password) : rval = asn1.fromDer(rval), rval !== null && (rval = pki.privateKeyFromAsn1(rval)), rval;
  };
  pki.pbe.generatePkcs12Key = function (password, salt, id, iter, n, md) {
    var j, l;
    if (typeof md > "u" || md === null) {
      if (!("sha1" in forge.md)) throw new Error('"sha1" hash algorithm unavailable.');
      md = forge.md.sha1.create();
    }
    var u = md.digestLength,
      v = md.blockLength,
      result = new forge.util.ByteBuffer(),
      passBuf = new forge.util.ByteBuffer();
    if (password != null) {
      for (l = 0; l < password.length; l++) passBuf.putInt16(password.charCodeAt(l));
      passBuf.putInt16(0);
    }
    var p = passBuf.length(),
      s = salt.length(),
      D = new forge.util.ByteBuffer();
    D.fillWithByte(id, v);
    var Slen = v * Math.ceil(s / v),
      S = new forge.util.ByteBuffer();
    for (l = 0; l < Slen; l++) S.putByte(salt.at(l % s));
    var Plen = v * Math.ceil(p / v),
      P = new forge.util.ByteBuffer();
    for (l = 0; l < Plen; l++) P.putByte(passBuf.at(l % p));
    var I = S;
    I.putBuffer(P);
    for (var c = Math.ceil(n / u), i = 1; i <= c; i++) {
      var buf = new forge.util.ByteBuffer();
      buf.putBytes(D.bytes()), buf.putBytes(I.bytes());
      for (var round = 0; round < iter; round++) md.start(), md.update(buf.getBytes()), buf = md.digest();
      var B = new forge.util.ByteBuffer();
      for (l = 0; l < v; l++) B.putByte(buf.at(l % u));
      var k = Math.ceil(s / v) + Math.ceil(p / v),
        Inew = new forge.util.ByteBuffer();
      for (j = 0; j < k; j++) {
        var chunk = new forge.util.ByteBuffer(I.getBytes(v)),
          x = 511;
        for (l = B.length() - 1; l >= 0; l--) x = x >> 8, x += B.at(l) + chunk.at(l), chunk.setAt(l, x & 255);
        Inew.putBuffer(chunk);
      }
      I = Inew, result.putBuffer(buf);
    }
    return result.truncate(result.length() - n), result;
  };
  pki.pbe.getCipher = function (oid, params, password) {
    switch (oid) {
      case pki.oids.pkcs5PBES2:
        return pki.pbe.getCipherForPBES2(oid, params, password);
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
      default:
        var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        throw error.oid = oid, error.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], error;
    }
  };
  pki.pbe.getCipherForPBES2 = function (oid, params, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    if (oid = asn1.derToOid(capture.kdfOid), oid !== pki.oids.pkcs5PBKDF2) {
      var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      throw error.oid = oid, error.supportedOids = ["pkcs5PBKDF2"], error;
    }
    if (oid = asn1.derToOid(capture.encOid), oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids.desCBC) {
      var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      throw error.oid = oid, error.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], error;
    }
    var salt = capture.kdfSalt,
      count = forge.util.createBuffer(capture.kdfIterationCount);
    count = count.getInt(count.length() << 3);
    var dkLen, cipherFn;
    switch (pki.oids[oid]) {
      case "aes128-CBC":
        dkLen = 16, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        dkLen = 24, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        dkLen = 32, cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        dkLen = 24, cipherFn = forge.des.createDecryptionCipher;
        break;
      case "desCBC":
        dkLen = 8, cipherFn = forge.des.createDecryptionCipher;
        break;
    }
    var md = prfOidToMessageDigest(capture.prfOid),
      dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md),
      iv = capture.encIv,
      cipher = cipherFn(dk);
    return cipher.start(iv), cipher;
  };
  pki.pbe.getCipherForPKCS12PBE = function (oid, params, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      throw error.errors = errors, error;
    }
    var salt = forge.util.createBuffer(capture.salt),
      count = forge.util.createBuffer(capture.iterations);
    count = count.getInt(count.length() << 3);
    var dkLen, dIvLen, cipherFn;
    switch (oid) {
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        dkLen = 24, dIvLen = 8, cipherFn = forge.des.startDecrypting;
        break;
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        dkLen = 5, dIvLen = 8, cipherFn = __name(function (key, iv) {
          var cipher = forge.rc2.createDecryptionCipher(key, 40);
          return cipher.start(iv, null), cipher;
        }, "cipherFn");
        break;
      default:
        var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        throw error.oid = oid, error;
    }
    var md = prfOidToMessageDigest(capture.prfOid),
      key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
    md.start();
    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
    return cipherFn(key, iv);
  };
  pki.pbe.opensslDeriveBytes = function (password, salt, dkLen, md) {
    if (typeof md > "u" || md === null) {
      if (!("md5" in forge.md)) throw new Error('"md5" hash algorithm unavailable.');
      md = forge.md.md5.create();
    }
    salt === null && (salt = "");
    for (var digests = [hash(md, password + salt)], length = 16, i = 1; length < dkLen; ++i, length += 16) digests.push(hash(md, digests[i - 1] + password + salt));
    return digests.join("").substr(0, dkLen);
  };
  function hash(md, bytes) {
    return md.start().update(bytes).digest().getBytes();
  }
  __name(hash, "hash");
  function prfOidToMessageDigest(prfOid) {
    var prfAlgorithm;
    if (!prfOid) prfAlgorithm = "hmacWithSHA1";else if (prfAlgorithm = pki.oids[asn1.derToOid(prfOid)], !prfAlgorithm) {
      var error = new Error("Unsupported PRF OID.");
      throw error.oid = prfOid, error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], error;
    }
    return prfAlgorithmToMessageDigest(prfAlgorithm);
  }
  __name(prfOidToMessageDigest, "prfOidToMessageDigest");
  function prfAlgorithmToMessageDigest(prfAlgorithm) {
    var factory = forge.md;
    switch (prfAlgorithm) {
      case "hmacWithSHA224":
        factory = forge.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
        break;
      default:
        var error = new Error("Unsupported PRF algorithm.");
        throw error.algorithm = prfAlgorithm, error.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], error;
    }
    if (!factory || !(prfAlgorithm in factory)) throw new Error("Unknown hash algorithm: " + prfAlgorithm);
    return factory[prfAlgorithm].create();
  }
  __name(prfAlgorithmToMessageDigest, "prfAlgorithmToMessageDigest");
  function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, salt), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, countBytes.getBytes())]);
    return prfAlgorithm !== "hmacWithSHA1" && params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])), params;
  }
  __name(createPbkdf2Params, "createPbkdf2Params");
});
var require_pkcs7asn1 = __commonJSMin((exports, module) => {
  var forge = ta();
  df();
  La();
  var asn1 = forge.asn1,
    p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
  forge.pkcs7 = forge.pkcs7 || {};
  forge.pkcs7.asn1 = p7v;
  var contentInfoValidator = {
    name: "ContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "ContentInfo.ContentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: !1,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      captureAsn1: "content"
    }]
  };
  p7v.contentInfoValidator = contentInfoValidator;
  var encryptedContentInfoValidator = {
    name: "EncryptedContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedContentInfo.contentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: !1,
      capture: "contentType"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "encAlgorithm"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "EncryptedContentInfo.encryptedContent",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      capture: "encryptedContent",
      captureAsn1: "encryptedContentAsn1"
    }]
  };
  p7v.envelopedDataValidator = {
    name: "EnvelopedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EnvelopedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }, {
      name: "EnvelopedData.RecipientInfos",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: !0,
      captureAsn1: "recipientInfos"
    }].concat(encryptedContentInfoValidator)
  };
  p7v.encryptedDataValidator = {
    name: "EncryptedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }].concat(encryptedContentInfoValidator)
  };
  var signerValidator = {
    name: "SignerInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1
    }, {
      name: "SignerInfo.issuerAndSerialNumber",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignerInfo.issuerAndSerialNumber.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "issuer"
      }, {
        name: "SignerInfo.issuerAndSerialNumber.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "serial"
      }]
    }, {
      name: "SignerInfo.digestAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SignerInfo.digestAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "digestAlgorithm"
      }, {
        name: "SignerInfo.digestAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: !1,
        captureAsn1: "digestParameter",
        optional: !0
      }]
    }, {
      name: "SignerInfo.authenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      capture: "authenticatedAttributes"
    }, {
      name: "SignerInfo.digestEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      capture: "signatureAlgorithm"
    }, {
      name: "SignerInfo.encryptedDigest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: !1,
      capture: "signature"
    }, {
      name: "SignerInfo.unauthenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: !0,
      optional: !0,
      capture: "unauthenticatedAttributes"
    }]
  };
  p7v.signedDataValidator = {
    name: "SignedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }, {
      name: "SignedData.DigestAlgorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: !0,
      captureAsn1: "digestAlgorithms"
    }, contentInfoValidator, {
      name: "SignedData.Certificates",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: !0,
      captureAsn1: "certificates"
    }, {
      name: "SignedData.CertificateRevocationLists",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: !0,
      captureAsn1: "crls"
    }, {
      name: "SignedData.SignerInfos",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      capture: "signerInfos",
      optional: !0,
      value: [signerValidator]
    }]
  };
  p7v.recipientInfoValidator = {
    name: "RecipientInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1,
      capture: "version"
    }, {
      name: "RecipientInfo.issuerAndSerial",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RecipientInfo.issuerAndSerial.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "issuer"
      }, {
        name: "RecipientInfo.issuerAndSerial.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "serial"
      }]
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "encAlgorithm"
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: !1,
        captureAsn1: "encParameter",
        optional: !0
      }]
    }, {
      name: "RecipientInfo.encryptedKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: !1,
      capture: "encKey"
    }]
  };
});
var require_mgf1 = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  forge.mgf = forge.mgf || {};
  var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
  mgf1.create = function (md) {
    var mgf = {
      generate: function (seed, maskLen) {
        for (var t = new forge.util.ByteBuffer(), len = Math.ceil(maskLen / md.digestLength), i = 0; i < len; i++) {
          var c = new forge.util.ByteBuffer();
          c.putInt32(i), md.start(), md.update(seed + c.getBytes()), t.putBuffer(md.digest());
        }
        return t.truncate(t.length() - maskLen), t.getBytes();
      }
    };
    return mgf;
  };
});
var require_mgf = __commonJSMin((exports, module) => {
  var forge = ta();
  _k();
  module.exports = forge.mgf = forge.mgf || {};
  forge.mgf.mgf1 = forge.mgf1;
});
var require_pss = __commonJSMin((exports, module) => {
  var forge = ta();
  Du();
  La();
  var pss = module.exports = forge.pss = forge.pss || {};
  pss.create = function (options) {
    arguments.length === 3 && (options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    });
    var hash = options.md,
      mgf = options.mgf,
      hLen = hash.digestLength,
      salt_ = options.salt || null;
    typeof salt_ == "string" && (salt_ = forge.util.createBuffer(salt_));
    var sLen;
    if ("saltLength" in options) sLen = options.saltLength;else if (salt_ !== null) sLen = salt_.length();else throw new Error("Salt length not specified or specific salt not given.");
    if (salt_ !== null && salt_.length() !== sLen) throw new Error("Given salt length does not match length of given salt.");
    var prng = options.prng || forge.random,
      pssobj = {};
    return pssobj.encode = function (md, modBits) {
      var i,
        emBits = modBits - 1,
        emLen = Math.ceil(emBits / 8),
        mHash = md.digest().getBytes();
      if (emLen < hLen + sLen + 2) throw new Error("Message is too long to encrypt.");
      var salt;
      salt_ === null ? salt = prng.getBytesSync(sLen) : salt = salt_.bytes();
      var m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8), m_.putBytes(mHash), m_.putBytes(salt), hash.start(), hash.update(m_.getBytes());
      var h = hash.digest().getBytes(),
        ps = new forge.util.ByteBuffer();
      ps.fillWithByte(0, emLen - sLen - hLen - 2), ps.putByte(1), ps.putBytes(salt);
      var db = ps.getBytes(),
        maskLen = emLen - hLen - 1,
        dbMask = mgf.generate(h, maskLen),
        maskedDB = "";
      for (i = 0; i < maskLen; i++) maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
      var mask = 65280 >> 8 * emLen - emBits & 255;
      return maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1), maskedDB + h + String.fromCharCode(188);
    }, pssobj.verify = function (mHash, em, modBits) {
      var i,
        emBits = modBits - 1,
        emLen = Math.ceil(emBits / 8);
      if (em = em.substr(-emLen), emLen < hLen + sLen + 2) throw new Error("Inconsistent parameters to PSS signature verification.");
      if (em.charCodeAt(emLen - 1) !== 188) throw new Error("Encoded message does not end in 0xBC.");
      var maskLen = emLen - hLen - 1,
        maskedDB = em.substr(0, maskLen),
        h = em.substr(maskLen, hLen),
        mask = 65280 >> 8 * emLen - emBits & 255;
      if (maskedDB.charCodeAt(0) & mask) throw new Error("Bits beyond keysize not zero as expected.");
      var dbMask = mgf.generate(h, maskLen),
        db = "";
      for (i = 0; i < maskLen; i++) db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
      db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
      var checkLen = emLen - hLen - sLen - 2;
      for (i = 0; i < checkLen; i++) if (db.charCodeAt(i) !== 0) throw new Error("Leftmost octets not zero as expected");
      if (db.charCodeAt(checkLen) !== 1) throw new Error("Inconsistent PSS signature, 0x01 marker not found");
      var salt = db.substr(-sLen),
        m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8), m_.putBytes(mHash), m_.putBytes(salt), hash.start(), hash.update(m_.getBytes());
      var h_ = hash.digest().getBytes();
      return h === h_;
    }, pssobj;
  };
});
var require_x509 = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  df();
  q_();
  Qf();
  jse();
  b1();
  dh();
  VE();
  $_();
  La();
  var asn1 = forge.asn1,
    pki = module.exports = forge.pki = forge.pki || {},
    oids = pki.oids,
    _shortNames = {};
  _shortNames.CN = oids.commonName;
  _shortNames.commonName = "CN";
  _shortNames.C = oids.countryName;
  _shortNames.countryName = "C";
  _shortNames.L = oids.localityName;
  _shortNames.localityName = "L";
  _shortNames.ST = oids.stateOrProvinceName;
  _shortNames.stateOrProvinceName = "ST";
  _shortNames.O = oids.organizationName;
  _shortNames.organizationName = "O";
  _shortNames.OU = oids.organizationalUnitName;
  _shortNames.organizationalUnitName = "OU";
  _shortNames.E = oids.emailAddress;
  _shortNames.emailAddress = "E";
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator,
    x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "tbsCertificate",
        value: [{
          name: "Certificate.TBSCertificate.version",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.version.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: !1,
            capture: "certVersion"
          }]
        }, {
          name: "Certificate.TBSCertificate.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: !1,
          capture: "certSerialNumber"
        }, {
          name: "Certificate.TBSCertificate.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate.signature.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "certinfoSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: !0,
            captureAsn1: "certinfoSignatureParams"
          }]
        }, {
          name: "Certificate.TBSCertificate.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certIssuer"
        }, {
          name: "Certificate.TBSCertificate.validity",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity1UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity2GeneralizedTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity3UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: !1,
            optional: !0,
            capture: "certValidity4GeneralizedTime"
          }]
        }, {
          name: "Certificate.TBSCertificate.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: "certSubject"
        }, publicKeyValidator, {
          name: "Certificate.TBSCertificate.issuerUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.issuerUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: !1,
            captureBitStringValue: "certIssuerUniqueId"
          }]
        }, {
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: !0,
          optional: !0,
          value: [{
            name: "Certificate.TBSCertificate.subjectUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: !1,
            captureBitStringValue: "certSubjectUniqueId"
          }]
        }, {
          name: "Certificate.TBSCertificate.extensions",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: !0,
          captureAsn1: "certExtensions",
          optional: !0
        }]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        captureBitStringValue: "certSignature"
      }]
    },
    rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: !0,
          optional: !0,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: !0,
          optional: !0,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: !0,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: !1,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: !0,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: !1,
          capture: "trailer"
        }]
      }]
    },
    certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "certificationRequestInfo",
      value: [{
        name: "CertificationRequestInfo.integer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "certificationRequestInfoVersion"
      }, {
        name: "CertificationRequestInfo.subject",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certificationRequestInfoSubject"
      }, publicKeyValidator, {
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        capture: "certificationRequestInfoAttributes",
        value: [{
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "CertificationRequestInfo.attributes.type",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: !1
          }, {
            name: "CertificationRequestInfo.attributes.value",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: !0
          }]
        }]
      }]
    },
    certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "csr",
      value: [certificationRequestInfoValidator, {
        name: "CertificationRequest.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertificationRequest.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: !1,
          capture: "csrSignatureOid"
        }, {
          name: "CertificationRequest.signatureAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "csrSignatureParams"
        }]
      }, {
        name: "CertificationRequest.signature",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: !1,
        captureBitStringValue: "csrSignature"
      }]
    };
  pki.RDNAttributesAsArray = function (rdn, md) {
    for (var rval = [], set, attr, obj, si = 0; si < rdn.value.length; ++si) {
      set = rdn.value[si];
      for (var i = 0; i < set.value.length; ++i) obj = {}, attr = set.value[i], obj.type = asn1.derToOid(attr.value[0].value), obj.value = attr.value[1].value, obj.valueTagClass = attr.value[1].type, obj.type in oids && (obj.name = oids[obj.type], obj.name in _shortNames && (obj.shortName = _shortNames[obj.name])), md && (md.update(obj.type), md.update(obj.value)), rval.push(obj);
    }
    return rval;
  };
  pki.CRIAttributesAsArray = function (attributes) {
    for (var rval = [], si = 0; si < attributes.length; ++si) for (var seq = attributes[si], type = asn1.derToOid(seq.value[0].value), values = seq.value[1].value, vi = 0; vi < values.length; ++vi) {
      var obj = {};
      if (obj.type = type, obj.value = values[vi].value, obj.valueTagClass = values[vi].type, obj.type in oids && (obj.name = oids[obj.type], obj.name in _shortNames && (obj.shortName = _shortNames[obj.name])), obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for (var ei = 0; ei < obj.value.length; ++ei) obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
      }
      rval.push(obj);
    }
    return rval;
  };
  function _getAttribute(obj, options) {
    typeof options == "string" && (options = {
      shortName: options
    });
    for (var rval = null, attr, i = 0; rval === null && i < obj.attributes.length; ++i) attr = obj.attributes[i], (options.type && options.type === attr.type || options.name && options.name === attr.name || options.shortName && options.shortName === attr.shortName) && (rval = attr);
    return rval;
  }
  __name(_getAttribute, "_getAttribute");
  var _readSignatureParameters = __name(function (oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) return params;
      fillDefaults && (params = {
        hash: {
          algorithmOid: oids.sha1
        },
        mgf: {
          algorithmOid: oids.mgf1,
          hash: {
            algorithmOid: oids.sha1
          }
        },
        saltLength: 20
      });
      var capture = {},
        errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        throw error.errors = errors, error;
      }
      return capture.hashOid !== void 0 && (params.hash = params.hash || {}, params.hash.algorithmOid = asn1.derToOid(capture.hashOid)), capture.maskGenOid !== void 0 && (params.mgf = params.mgf || {}, params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid), params.mgf.hash = params.mgf.hash || {}, params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid)), capture.saltLength !== void 0 && (params.saltLength = capture.saltLength.charCodeAt(0)), params;
    }, "_readSignatureParameters"),
    _createSignatureDigest = __name(function (options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error = new Error("Could not compute " + options.type + " digest. Unknown signature OID.");
          throw error.signatureOid = options.signatureOid, error;
      }
    }, "_createSignatureDigest"),
    _verifySignature = __name(function (options) {
      var cert = options.certificate,
        scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          if (hash = oids[cert.signatureParameters.mgf.hash.algorithmOid], hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            throw error.oid = cert.signatureParameters.mgf.hash.algorithmOid, error.name = hash, error;
          }
          if (mgf = oids[cert.signatureParameters.mgf.algorithmOid], mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            throw error.oid = cert.signatureParameters.mgf.algorithmOid, error.name = mgf, error;
          }
          if (mgf = forge.mgf[mgf].create(forge.md[hash].create()), hash = oids[cert.signatureParameters.hash.algorithmOid], hash === void 0 || forge.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            throw error.oid = cert.signatureParameters.hash.algorithmOid, error.name = hash, error;
          }
          scheme = forge.pss.create(forge.md[hash].create(), mgf, cert.signatureParameters.saltLength);
          break;
      }
      return cert.publicKey.verify(options.md.digest().getBytes(), options.signature, scheme);
    }, "_verifySignature");
  pki.certificateFromPem = function (pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
      var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificateFromAsn1(obj, computeHash);
  };
  pki.certificateToPem = function (cert, maxline) {
    var msg = {
      type: "CERTIFICATE",
      body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.publicKeyFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
      var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body);
    return pki.publicKeyFromAsn1(obj);
  };
  pki.publicKeyToPem = function (key, maxline) {
    var msg = {
      type: "PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.publicKeyToRSAPublicKeyPem = function (key, maxline) {
    var msg = {
      type: "RSA PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.getPublicKeyFingerprint = function (key, options) {
    options = options || {};
    var md = options.md || forge.md.sha1.create(),
      type = options.type || "RSAPublicKey",
      bytes;
    switch (type) {
      case "RSAPublicKey":
        bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + options.type + '".');
    }
    md.start(), md.update(bytes);
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      return options.delimiter ? hex.match(/.{2}/g).join(options.delimiter) : hex;
    } else {
      if (options.encoding === "binary") return digest.getBytes();
      if (options.encoding) throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  pki.certificationRequestFromPem = function (pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE REQUEST") {
      var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificationRequestFromAsn1(obj, computeHash);
  };
  pki.certificationRequestToPem = function (csr, maxline) {
    var msg = {
      type: "CERTIFICATE REQUEST",
      body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.createCertificate = function () {
    var cert = {};
    return cert.version = 2, cert.serialNumber = "00", cert.signatureOid = null, cert.signature = null, cert.siginfo = {}, cert.siginfo.algorithmOid = null, cert.validity = {}, cert.validity.notBefore = new Date(), cert.validity.notAfter = new Date(), cert.issuer = {}, cert.issuer.getField = function (sn) {
      return _getAttribute(cert.issuer, sn);
    }, cert.issuer.addField = function (attr) {
      _fillMissingFields([attr]), cert.issuer.attributes.push(attr);
    }, cert.issuer.attributes = [], cert.issuer.hash = null, cert.subject = {}, cert.subject.getField = function (sn) {
      return _getAttribute(cert.subject, sn);
    }, cert.subject.addField = function (attr) {
      _fillMissingFields([attr]), cert.subject.attributes.push(attr);
    }, cert.subject.attributes = [], cert.subject.hash = null, cert.extensions = [], cert.publicKey = null, cert.md = null, cert.setSubject = function (attrs, uniqueId) {
      _fillMissingFields(attrs), cert.subject.attributes = attrs, delete cert.subject.uniqueId, uniqueId && (cert.subject.uniqueId = uniqueId), cert.subject.hash = null;
    }, cert.setIssuer = function (attrs, uniqueId) {
      _fillMissingFields(attrs), cert.issuer.attributes = attrs, delete cert.issuer.uniqueId, uniqueId && (cert.issuer.uniqueId = uniqueId), cert.issuer.hash = null;
    }, cert.setExtensions = function (exts) {
      for (var i = 0; i < exts.length; ++i) _fillMissingExtensionFields(exts[i], {
        cert: cert
      });
      cert.extensions = exts;
    }, cert.getExtension = function (options) {
      typeof options == "string" && (options = {
        name: options
      });
      for (var rval = null, ext, i = 0; rval === null && i < cert.extensions.length; ++i) ext = cert.extensions[i], (options.id && ext.id === options.id || options.name && ext.name === options.name) && (rval = ext);
      return rval;
    }, cert.sign = function (key, md) {
      cert.md = md || forge.md.sha1.create();
      var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        throw error.algorithm = cert.md.algorithm, error;
      }
      cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid, cert.tbsCertificate = pki.getTBSCertificate(cert);
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes()), cert.signature = key.sign(cert.md);
    }, cert.verify = function (child) {
      var rval = !1;
      if (!cert.issued(child)) {
        var issuer = child.issuer,
          subject = cert.subject,
          error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
        throw error.expectedIssuer = subject.attributes, error.actualIssuer = issuer.attributes, error;
      }
      var md = child.md;
      if (md === null) {
        md = _createSignatureDigest({
          signatureOid: child.signatureOid,
          type: "certificate"
        });
        var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child),
          bytes = asn1.toDer(tbsCertificate);
        md.update(bytes.getBytes());
      }
      return md !== null && (rval = _verifySignature({
        certificate: cert,
        md: md,
        signature: child.signature
      })), rval;
    }, cert.isIssuer = function (parent) {
      var rval = !1,
        i = cert.issuer,
        s = parent.subject;
      if (i.hash && s.hash) rval = i.hash === s.hash;else if (i.attributes.length === s.attributes.length) {
        rval = !0;
        for (var iattr, sattr, n = 0; rval && n < i.attributes.length; ++n) iattr = i.attributes[n], sattr = s.attributes[n], (iattr.type !== sattr.type || iattr.value !== sattr.value) && (rval = !1);
      }
      return rval;
    }, cert.issued = function (child) {
      return child.isIssuer(cert);
    }, cert.generateSubjectKeyIdentifier = function () {
      return pki.getPublicKeyFingerprint(cert.publicKey, {
        type: "RSAPublicKey"
      });
    }, cert.verifySubjectKeyIdentifier = function () {
      for (var oid = oids.subjectKeyIdentifier, i = 0; i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.id === oid) {
          var ski = cert.generateSubjectKeyIdentifier().getBytes();
          return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
        }
      }
      return !1;
    }, cert;
  };
  pki.certificateFromAsn1 = function (obj, computeHash) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
      var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
    var cert = pki.createCertificate();
    cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
    var serial = forge.util.createBuffer(capture.certSerialNumber);
    cert.serialNumber = serial.toHex(), cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid), cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, !0), cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid), cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, !1), cert.signature = capture.certSignature;
    var validity = [];
    if (capture.certValidity1UTCTime !== void 0 && validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime)), capture.certValidity2GeneralizedTime !== void 0 && validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime)), capture.certValidity3UTCTime !== void 0 && validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime)), capture.certValidity4GeneralizedTime !== void 0 && validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime)), validity.length > 2) throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    if (validity.length < 2) throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    if (cert.validity.notBefore = validity[0], cert.validity.notAfter = validity[1], cert.tbsCertificate = capture.tbsCertificate, computeHash) {
      cert.md = _createSignatureDigest({
        signatureOid: cert.signatureOid,
        type: "certificate"
      });
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
    }
    var imd = forge.md.sha1.create(),
      ibytes = asn1.toDer(capture.certIssuer);
    imd.update(ibytes.getBytes()), cert.issuer.getField = function (sn) {
      return _getAttribute(cert.issuer, sn);
    }, cert.issuer.addField = function (attr) {
      _fillMissingFields([attr]), cert.issuer.attributes.push(attr);
    }, cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer), capture.certIssuerUniqueId && (cert.issuer.uniqueId = capture.certIssuerUniqueId), cert.issuer.hash = imd.digest().toHex();
    var smd = forge.md.sha1.create(),
      sbytes = asn1.toDer(capture.certSubject);
    return smd.update(sbytes.getBytes()), cert.subject.getField = function (sn) {
      return _getAttribute(cert.subject, sn);
    }, cert.subject.addField = function (attr) {
      _fillMissingFields([attr]), cert.subject.attributes.push(attr);
    }, cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject), capture.certSubjectUniqueId && (cert.subject.uniqueId = capture.certSubjectUniqueId), cert.subject.hash = smd.digest().toHex(), capture.certExtensions ? cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions) : cert.extensions = [], cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo), cert;
  };
  pki.certificateExtensionsFromAsn1 = function (exts) {
    for (var rval = [], i = 0; i < exts.value.length; ++i) for (var extseq = exts.value[i], ei = 0; ei < extseq.value.length; ++ei) rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    return rval;
  };
  pki.certificateExtensionFromAsn1 = function (ext) {
    var e = {};
    if (e.id = asn1.derToOid(ext.value[0].value), e.critical = !1, ext.value[1].type === asn1.Type.BOOLEAN ? (e.critical = ext.value[1].value.charCodeAt(0) !== 0, e.value = ext.value[2].value) : e.value = ext.value[1].value, e.id in oids) {
      if (e.name = oids[e.id], e.name === "keyUsage") {
        var ev = asn1.fromDer(e.value),
          b2 = 0,
          b3 = 0;
        ev.value.length > 1 && (b2 = ev.value.charCodeAt(1), b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0), e.digitalSignature = (b2 & 128) === 128, e.nonRepudiation = (b2 & 64) === 64, e.keyEncipherment = (b2 & 32) === 32, e.dataEncipherment = (b2 & 16) === 16, e.keyAgreement = (b2 & 8) === 8, e.keyCertSign = (b2 & 4) === 4, e.cRLSign = (b2 & 2) === 2, e.encipherOnly = (b2 & 1) === 1, e.decipherOnly = (b3 & 128) === 128;
      } else if (e.name === "basicConstraints") {
        var ev = asn1.fromDer(e.value);
        ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN ? e.cA = ev.value[0].value.charCodeAt(0) !== 0 : e.cA = !1;
        var value = null;
        ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER ? value = ev.value[0].value : ev.value.length > 1 && (value = ev.value[1].value), value !== null && (e.pathLenConstraint = asn1.derToInteger(value));
      } else if (e.name === "extKeyUsage") for (var ev = asn1.fromDer(e.value), vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        oid in oids ? e[oids[oid]] = !0 : e[oid] = !0;
      } else if (e.name === "nsCertType") {
        var ev = asn1.fromDer(e.value),
          b2 = 0;
        ev.value.length > 1 && (b2 = ev.value.charCodeAt(1)), e.client = (b2 & 128) === 128, e.server = (b2 & 64) === 64, e.email = (b2 & 32) === 32, e.objsign = (b2 & 16) === 16, e.reserved = (b2 & 8) === 8, e.sslCA = (b2 & 4) === 4, e.emailCA = (b2 & 2) === 2, e.objCA = (b2 & 1) === 1;
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.altNames = [];
        for (var gn, ev = asn1.fromDer(e.value), n = 0; n < ev.value.length; ++n) {
          gn = ev.value[n];
          var altName = {
            type: gn.type,
            value: gn.value
          };
          switch (e.altNames.push(altName), gn.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              altName.ip = forge.util.bytesToIP(gn.value);
              break;
            case 8:
              altName.oid = asn1.derToOid(gn.value);
              break;
            default:
          }
        }
      } else if (e.name === "subjectKeyIdentifier") {
        var ev = asn1.fromDer(e.value);
        e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
      }
    }
    return e;
  };
  pki.certificationRequestFromAsn1 = function (obj, computeHash) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) throw new Error("Cannot read public key. OID is not RSA.");
    var csr = pki.createCertificationRequest();
    if (csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0, csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid), csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, !0), csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid), csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, !1), csr.signature = capture.csrSignature, csr.certificationRequestInfo = capture.certificationRequestInfo, computeHash) {
      csr.md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: "certification request"
      });
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
    }
    var smd = forge.md.sha1.create();
    return csr.subject.getField = function (sn) {
      return _getAttribute(csr.subject, sn);
    }, csr.subject.addField = function (attr) {
      _fillMissingFields([attr]), csr.subject.attributes.push(attr);
    }, csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd), csr.subject.hash = smd.digest().toHex(), csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo), csr.getAttribute = function (sn) {
      return _getAttribute(csr, sn);
    }, csr.addAttribute = function (attr) {
      _fillMissingFields([attr]), csr.attributes.push(attr);
    }, csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []), csr;
  };
  pki.createCertificationRequest = function () {
    var csr = {};
    return csr.version = 0, csr.signatureOid = null, csr.signature = null, csr.siginfo = {}, csr.siginfo.algorithmOid = null, csr.subject = {}, csr.subject.getField = function (sn) {
      return _getAttribute(csr.subject, sn);
    }, csr.subject.addField = function (attr) {
      _fillMissingFields([attr]), csr.subject.attributes.push(attr);
    }, csr.subject.attributes = [], csr.subject.hash = null, csr.publicKey = null, csr.attributes = [], csr.getAttribute = function (sn) {
      return _getAttribute(csr, sn);
    }, csr.addAttribute = function (attr) {
      _fillMissingFields([attr]), csr.attributes.push(attr);
    }, csr.md = null, csr.setSubject = function (attrs) {
      _fillMissingFields(attrs), csr.subject.attributes = attrs, csr.subject.hash = null;
    }, csr.setAttributes = function (attrs) {
      _fillMissingFields(attrs), csr.attributes = attrs;
    }, csr.sign = function (key, md) {
      csr.md = md || forge.md.sha1.create();
      var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        throw error.algorithm = csr.md.algorithm, error;
      }
      csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid, csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes()), csr.signature = key.sign(csr.md);
    }, csr.verify = function () {
      var rval = !1,
        md = csr.md;
      if (md === null) {
        md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr),
          bytes = asn1.toDer(cri);
        md.update(bytes.getBytes());
      }
      return md !== null && (rval = _verifySignature({
        certificate: csr,
        md: md,
        signature: csr.signature
      })), rval;
    }, csr;
  };
  function _dnToAsn1(obj) {
    for (var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), attr, set, attrs = obj.attributes, i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      var value = attr.value,
        valueTagClass = asn1.Type.PRINTABLESTRING;
      "valueTagClass" in attr && (valueTagClass = attr.valueTagClass, valueTagClass === asn1.Type.UTF8 && (value = forge.util.encodeUtf8(value))), set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, valueTagClass, !1, value)])]), rval.value.push(set);
    }
    return rval;
  }
  __name(_dnToAsn1, "_dnToAsn1");
  function _fillMissingFields(attrs) {
    for (var attr, i = 0; i < attrs.length; ++i) {
      if (attr = attrs[i], typeof attr.name > "u" && (attr.type && attr.type in pki.oids ? attr.name = pki.oids[attr.type] : attr.shortName && attr.shortName in _shortNames && (attr.name = pki.oids[_shortNames[attr.shortName]])), typeof attr.type > "u") if (attr.name && attr.name in pki.oids) attr.type = pki.oids[attr.name];else {
        var error = new Error("Attribute type not specified.");
        throw error.attribute = attr, error;
      }
      if (typeof attr.shortName > "u" && attr.name && attr.name in _shortNames && (attr.shortName = _shortNames[attr.name]), attr.type === oids.extensionRequest && (attr.valueConstructed = !0, attr.valueTagClass = asn1.Type.SEQUENCE, !attr.value && attr.extensions)) {
        attr.value = [];
        for (var ei = 0; ei < attr.extensions.length; ++ei) attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
      }
      if (typeof attr.value > "u") {
        var error = new Error("Attribute value not specified.");
        throw error.attribute = attr, error;
      }
    }
  }
  __name(_fillMissingFields, "_fillMissingFields");
  function _fillMissingExtensionFields(e, options) {
    if (options = options || {}, typeof e.name > "u" && e.id && e.id in pki.oids && (e.name = pki.oids[e.id]), typeof e.id > "u") if (e.name && e.name in pki.oids) e.id = pki.oids[e.name];else {
      var error = new Error("Extension ID not specified.");
      throw error.extension = e, error;
    }
    if (typeof e.value < "u") return e;
    if (e.name === "keyUsage") {
      var unused = 0,
        b2 = 0,
        b3 = 0;
      e.digitalSignature && (b2 |= 128, unused = 7), e.nonRepudiation && (b2 |= 64, unused = 6), e.keyEncipherment && (b2 |= 32, unused = 5), e.dataEncipherment && (b2 |= 16, unused = 4), e.keyAgreement && (b2 |= 8, unused = 3), e.keyCertSign && (b2 |= 4, unused = 2), e.cRLSign && (b2 |= 2, unused = 1), e.encipherOnly && (b2 |= 1, unused = 0), e.decipherOnly && (b3 |= 128, unused = 7);
      var value = String.fromCharCode(unused);
      b3 !== 0 ? value += String.fromCharCode(b2) + String.fromCharCode(b3) : b2 !== 0 && (value += String.fromCharCode(b2)), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, value);
    } else if (e.name === "basicConstraints") e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), e.cA && e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in e && e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(e.pathLenConstraint).getBytes()));else if (e.name === "extKeyUsage") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      var seq = e.value.value;
      for (var key in e) e[key] === !0 && (key in oids ? seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oids[key]).getBytes())) : key.indexOf(".") !== -1 && seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(key).getBytes())));
    } else if (e.name === "nsCertType") {
      var unused = 0,
        b2 = 0;
      e.client && (b2 |= 128, unused = 7), e.server && (b2 |= 64, unused = 6), e.email && (b2 |= 32, unused = 5), e.objsign && (b2 |= 16, unused = 4), e.reserved && (b2 |= 8, unused = 3), e.sslCA && (b2 |= 4, unused = 2), e.emailCA && (b2 |= 2, unused = 1), e.objCA && (b2 |= 1, unused = 0);
      var value = String.fromCharCode(unused);
      b2 !== 0 && (value += String.fromCharCode(b2)), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, value);
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      for (var altName, n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          if (value = forge.util.bytesFromIP(altName.ip), value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            throw error.extension = e, error;
          }
        } else altName.type === 8 && (altName.oid ? value = asn1.oidToDer(asn1.oidToDer(altName.oid)) : value = asn1.oidToDer(value));
        e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, !1, value));
      }
    } else if (e.name === "nsComment" && options.cert) {
      if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) throw new Error('Invalid "nsComment" content.');
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, !1, e.comment);
    } else if (e.name === "subjectKeyIdentifier" && options.cert) {
      var ski = options.cert.generateSubjectKeyIdentifier();
      e.subjectKeyIdentifier = ski.toHex(), e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, ski.getBytes());
    } else if (e.name === "authorityKeyIdentifier" && options.cert) {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      var seq = e.value.value;
      if (e.keyIdentifier) {
        var keyIdentifier = e.keyIdentifier === !0 ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !1, keyIdentifier));
      }
      if (e.authorityCertIssuer) {
        var authorityCertIssuer = [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, !0, [_dnToAsn1(e.authorityCertIssuer === !0 ? options.cert.issuer : e.authorityCertIssuer)])];
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, authorityCertIssuer));
      }
      if (e.serialNumber) {
        var serialNumber = forge.util.hexToBytes(e.serialNumber === !0 ? options.cert.serialNumber : e.serialNumber);
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !1, serialNumber));
      }
    } else if (e.name === "cRLDistributionPoints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
      for (var seq = e.value.value, subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []), fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, []), altName, n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          if (value = forge.util.bytesFromIP(altName.ip), value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            throw error.extension = e, error;
          }
        } else altName.type === 8 && (altName.oid ? value = asn1.oidToDer(asn1.oidToDer(altName.oid)) : value = asn1.oidToDer(value));
        fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, !1, value));
      }
      subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [fullNameGeneralNames])), seq.push(subSeq);
    }
    if (typeof e.value > "u") {
      var error = new Error("Extension value not specified.");
      throw error.extension = e, error;
    }
    return e;
  }
  __name(_fillMissingExtensionFields, "_fillMissingExtensionFields");
  function _signatureParametersToAsn1(oid, params) {
    switch (oid) {
      case oids["RSASSA-PSS"]:
        var parts = [];
        return params.hash.algorithmOid !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])])), params.mgf.algorithmOid !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.mgf.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])])])), params.saltLength !== void 0 && parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(params.saltLength).getBytes())])), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, parts);
      default:
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "");
    }
  }
  __name(_signatureParametersToAsn1, "_signatureParametersToAsn1");
  function _CRIAttributesToAsn1(csr) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, []);
    if (csr.attributes.length === 0) return rval;
    for (var attrs = csr.attributes, i = 0; i < attrs.length; ++i) {
      var attr = attrs[i],
        value = attr.value,
        valueTagClass = asn1.Type.UTF8;
      "valueTagClass" in attr && (valueTagClass = attr.valueTagClass), valueTagClass === asn1.Type.UTF8 && (value = forge.util.encodeUtf8(value));
      var valueConstructed = !1;
      "valueConstructed" in attr && (valueConstructed = attr.valueConstructed);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)])]);
      rval.value.push(seq);
    }
    return rval;
  }
  __name(_CRIAttributesToAsn1, "_CRIAttributesToAsn1");
  var jan_1_1950 = new Date("1950-01-01T00:00:00Z"),
    jan_1_2050 = new Date("2050-01-01T00:00:00Z");
  function _dateToAsn1(date) {
    return date >= jan_1_1950 && date < jan_1_2050 ? asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, !1, asn1.dateToUtcTime(date)) : asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, !1, asn1.dateToGeneralizedTime(date));
  }
  __name(_dateToAsn1, "_dateToAsn1");
  pki.getTBSCertificate = function (cert) {
    var notBefore = _dateToAsn1(cert.validity.notBefore),
      notAfter = _dateToAsn1(cert.validity.notAfter),
      tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(cert.version).getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(cert.serialNumber)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()), _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)]), _dnToAsn1(cert.issuer), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [notBefore, notAfter]), _dnToAsn1(cert.subject), pki.publicKeyToAsn1(cert.publicKey)]);
    return cert.issuer.uniqueId && tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, String.fromCharCode(0) + cert.issuer.uniqueId)])), cert.subject.uniqueId && tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, String.fromCharCode(0) + cert.subject.uniqueId)])), cert.extensions.length > 0 && tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions)), tbs;
  };
  pki.getCertificationRequestInfo = function (csr) {
    var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(csr.version).getBytes()), _dnToAsn1(csr.subject), pki.publicKeyToAsn1(csr.publicKey), _CRIAttributesToAsn1(csr)]);
    return cri;
  };
  pki.distinguishedNameToAsn1 = function (dn) {
    return _dnToAsn1(dn);
  };
  pki.certificateToAsn1 = function (cert) {
    var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [tbsCertificate, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(cert.signatureOid).getBytes()), _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, String.fromCharCode(0) + cert.signature)]);
  };
  pki.certificateExtensionsToAsn1 = function (exts) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, !0, []),
      seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
    rval.value.push(seq);
    for (var i = 0; i < exts.length; ++i) seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
    return rval;
  };
  pki.certificateExtensionToAsn1 = function (ext) {
    var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, []);
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(ext.id).getBytes())), ext.critical && extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, !1, String.fromCharCode(255)));
    var value = ext.value;
    return typeof ext.value != "string" && (value = asn1.toDer(value).getBytes()), extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, value)), extseq;
  };
  pki.certificationRequestToAsn1 = function (csr) {
    var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [cri, asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(csr.signatureOid).getBytes()), _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, !1, String.fromCharCode(0) + csr.signature)]);
  };
  pki.createCaStore = function (certs) {
    var caStore = {
      certs: {}
    };
    caStore.getIssuer = function (cert) {
      var rval = getBySubject(cert.issuer);
      return rval;
    }, caStore.addCertificate = function (cert) {
      if (typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), ensureSubjectHasHash(cert.subject), !caStore.hasCertificate(cert)) if (cert.subject.hash in caStore.certs) {
        var tmp = caStore.certs[cert.subject.hash];
        forge.util.isArray(tmp) || (tmp = [tmp]), tmp.push(cert), caStore.certs[cert.subject.hash] = tmp;
      } else caStore.certs[cert.subject.hash] = cert;
    }, caStore.hasCertificate = function (cert) {
      typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert));
      var match = getBySubject(cert.subject);
      if (!match) return !1;
      forge.util.isArray(match) || (match = [match]);
      for (var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(), i = 0; i < match.length; ++i) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
        if (der1 === der2) return !0;
      }
      return !1;
    }, caStore.listAllCertificates = function () {
      var certList = [];
      for (var hash in caStore.certs) if (caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if (!forge.util.isArray(value)) certList.push(value);else for (var i = 0; i < value.length; ++i) certList.push(value[i]);
      }
      return certList;
    }, caStore.removeCertificate = function (cert) {
      var result;
      if (typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), ensureSubjectHasHash(cert.subject), !caStore.hasCertificate(cert)) return null;
      var match = getBySubject(cert.subject);
      if (!forge.util.isArray(match)) return result = caStore.certs[cert.subject.hash], delete caStore.certs[cert.subject.hash], result;
      for (var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes(), i = 0; i < match.length; ++i) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
        der1 === der2 && (result = match[i], match.splice(i, 1));
      }
      return match.length === 0 && delete caStore.certs[cert.subject.hash], result;
    };
    function getBySubject(subject) {
      return ensureSubjectHasHash(subject), caStore.certs[subject.hash] || null;
    }
    __name(getBySubject, "getBySubject");
    function ensureSubjectHasHash(subject) {
      if (!subject.hash) {
        var md = forge.md.sha1.create();
        subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md), subject.hash = md.digest().toHex();
      }
    }
    if (__name(ensureSubjectHasHash, "ensureSubjectHasHash"), certs) for (var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
    return caStore;
  };
  pki.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority"
  };
  pki.verifyCertificateChain = function (caStore, chain, options) {
    typeof options == "function" && (options = {
      verify: options
    }), options = options || {}, chain = chain.slice(0);
    var certs = chain.slice(0),
      validityCheckDate = options.validityCheckDate;
    typeof validityCheckDate > "u" && (validityCheckDate = new Date());
    var first = !0,
      error = null,
      depth = 0;
    do {
      var cert = chain.shift(),
        parent = null,
        selfSigned = !1;
      if (validityCheckDate && (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) && (error = {
        message: "Certificate is not valid yet or has expired.",
        error: pki.certificateError.certificate_expired,
        notBefore: cert.validity.notBefore,
        notAfter: cert.validity.notAfter,
        now: validityCheckDate
      }), error === null) {
        if (parent = chain[0] || caStore.getIssuer(cert), parent === null && cert.isIssuer(cert) && (selfSigned = !0, parent = cert), parent) {
          var parents = parent;
          forge.util.isArray(parents) || (parents = [parents]);
          for (var verified = !1; !verified && parents.length > 0;) {
            parent = parents.shift();
            try {
              verified = parent.verify(cert);
            } catch {}
          }
          verified || (error = {
            message: "Certificate signature is invalid.",
            error: pki.certificateError.bad_certificate
          });
        }
        error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert) && (error = {
          message: "Certificate is not trusted.",
          error: pki.certificateError.unknown_ca
        });
      }
      if (error === null && parent && !cert.isIssuer(parent) && (error = {
        message: "Certificate issuer is invalid.",
        error: pki.certificateError.bad_certificate
      }), error === null) for (var se = {
          keyUsage: !0,
          basicConstraints: !0
        }, i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        ext.critical && !(ext.name in se) && (error = {
          message: "Certificate has an unsupported critical extension.",
          error: pki.certificateError.unsupported_certificate
        });
      }
      if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
        var bcExt = cert.getExtension("basicConstraints"),
          keyUsageExt = cert.getExtension("keyUsage");
        if (keyUsageExt !== null && (!keyUsageExt.keyCertSign || bcExt === null) && (error = {
          message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
          error: pki.certificateError.bad_certificate
        }), error === null && bcExt !== null && !bcExt.cA && (error = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: pki.certificateError.bad_certificate
        }), error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
          var pathLen = depth - 1;
          pathLen > bcExt.pathLenConstraint && (error = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: pki.certificateError.bad_certificate
          });
        }
      }
      var vfd = error === null ? !0 : error.error,
        ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
      if (ret === !0) error = null;else throw vfd === !0 && (error = {
        message: "The application rejected the certificate.",
        error: pki.certificateError.bad_certificate
      }), (ret || ret === 0) && (typeof ret == "object" && !forge.util.isArray(ret) ? (ret.message && (error.message = ret.message), ret.error && (error.error = ret.error)) : typeof ret == "string" && (error.error = ret)), error;
      first = !1, ++depth;
    } while (chain.length > 0);
    return !0;
  };
});
var require_pkcs12 = __commonJSMin((exports, module) => {
  var forge = ta();
  df();
  Z5();
  b1();
  gk();
  hk();
  Du();
  $_();
  r3();
  La();
  WE();
  var asn1 = forge.asn1,
    pki = forge.pki,
    p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {},
    contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        captureAsn1: "content"
      }]
    },
    pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PFX.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: !1,
        capture: "version"
      }, contentInfoValidator, {
        name: "PFX.macData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        captureAsn1: "mac",
        value: [{
          name: "PFX.macData.mac",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: !0,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: !1,
              capture: "macAlgorithm"
            }, {
              name: "PFX.macData.mac.digestAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: "macAlgorithmParameters"
            }]
          }, {
            name: "PFX.macData.mac.digest",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: !1,
            capture: "macDigest"
          }]
        }, {
          name: "PFX.macData.macSalt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: !1,
          capture: "macSalt"
        }, {
          name: "PFX.macData.iterations",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: !1,
          optional: !0,
          capture: "macIterations"
        }]
      }]
    },
    safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: !0,
        optional: !0,
        capture: "bagAttributes"
      }]
    },
    attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: !0,
        capture: "values"
      }]
    },
    certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: !0,
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: !1,
          capture: "cert"
        }]
      }]
    };
  function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
    for (var result = [], i = 0; i < safeContents.length; i++) for (var j = 0; j < safeContents[i].safeBags.length; j++) {
      var bag = safeContents[i].safeBags[j];
      if (!(bagType !== void 0 && bag.type !== bagType)) {
        if (attrName === null) {
          result.push(bag);
          continue;
        }
        bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0 && result.push(bag);
      }
    }
    return result;
  }
  __name(_getBagsByAttribute, "_getBagsByAttribute");
  p12.pkcs12FromAsn1 = function (obj, strict, password) {
    typeof strict == "string" ? (password = strict, strict = !0) : strict === void 0 && (strict = !0);
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, pfxValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
      throw error.errors = error, error;
    }
    var pfx = {
      version: capture.version.charCodeAt(0),
      safeContents: [],
      getBags: function (filter) {
        var rval = {},
          localKeyId;
        return "localKeyId" in filter ? localKeyId = filter.localKeyId : "localKeyIdHex" in filter && (localKeyId = forge.util.hexToBytes(filter.localKeyIdHex)), localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter && (rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType)), localKeyId !== void 0 && (rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType)), "friendlyName" in filter && (rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType)), rval;
      },
      getBagsByFriendlyName: function (friendlyName, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
      },
      getBagsByLocalKeyId: function (localKeyId, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
      }
    };
    if (capture.version.charCodeAt(0) !== 3) {
      var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
      throw error.version = capture.version.charCodeAt(0), error;
    }
    if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
      var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
      throw error.oid = asn1.derToOid(capture.contentType), error;
    }
    var data = capture.content.value[0];
    if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
    if (data = _decodePkcs7Data(data), capture.mac) {
      var md = null,
        macKeyBytes = 0,
        macAlgorithm = asn1.derToOid(capture.macAlgorithm);
      switch (macAlgorithm) {
        case pki.oids.sha1:
          md = forge.md.sha1.create(), macKeyBytes = 20;
          break;
        case pki.oids.sha256:
          md = forge.md.sha256.create(), macKeyBytes = 32;
          break;
        case pki.oids.sha384:
          md = forge.md.sha384.create(), macKeyBytes = 48;
          break;
        case pki.oids.sha512:
          md = forge.md.sha512.create(), macKeyBytes = 64;
          break;
        case pki.oids.md5:
          md = forge.md.md5.create(), macKeyBytes = 16;
          break;
      }
      if (md === null) throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
      var macSalt = new forge.util.ByteBuffer(capture.macSalt),
        macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1,
        macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md),
        mac = forge.hmac.create();
      mac.start(md, macKey), mac.update(data.value);
      var macValue = mac.getMac();
      if (macValue.getBytes() !== capture.macDigest) throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
    return _decodeAuthenticatedSafe(pfx, data.value, strict, password), pfx;
  };
  function _decodePkcs7Data(data) {
    if (data.composed || data.constructed) {
      for (var value = forge.util.createBuffer(), i = 0; i < data.value.length; ++i) value.putBytes(data.value[i].value);
      data.composed = data.constructed = !1, data.value = value.getBytes();
    }
    return data;
  }
  __name(_decodePkcs7Data, "_decodePkcs7Data");
  function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
    if (authSafe = asn1.fromDer(authSafe, strict), authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== !0) throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
    for (var i = 0; i < authSafe.value.length; i++) {
      var contentInfo = authSafe.value[i],
        capture = {},
        errors = [];
      if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read ContentInfo.");
        throw error.errors = errors, error;
      }
      var obj = {
          encrypted: !1
        },
        safeContents = null,
        data = capture.content.value[0];
      switch (asn1.derToOid(capture.contentType)) {
        case pki.oids.data:
          if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
          safeContents = _decodePkcs7Data(data).value;
          break;
        case pki.oids.encryptedData:
          safeContents = _decryptSafeContents(data, password), obj.encrypted = !0;
          break;
        default:
          var error = new Error("Unsupported PKCS#12 contentType.");
          throw error.contentType = asn1.derToOid(capture.contentType), error;
      }
      obj.safeBags = _decodeSafeContents(safeContents, strict, password), pfx.safeContents.push(obj);
    }
  }
  __name(_decodeAuthenticatedSafe, "_decodeAuthenticatedSafe");
  function _decryptSafeContents(data, password) {
    var capture = {},
      errors = [];
    if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
      var error = new Error("Cannot read EncryptedContentInfo.");
      throw error.errors = errors, error;
    }
    var oid = asn1.derToOid(capture.contentType);
    if (oid !== pki.oids.data) {
      var error = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
      throw error.oid = oid, error;
    }
    oid = asn1.derToOid(capture.encAlgorithm);
    var cipher = pki.pbe.getCipher(oid, capture.encParameter, password),
      encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1),
      encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
    if (cipher.update(encrypted), !cipher.finish()) throw new Error("Failed to decrypt PKCS#12 SafeContents.");
    return cipher.output.getBytes();
  }
  __name(_decryptSafeContents, "_decryptSafeContents");
  function _decodeSafeContents(safeContents, strict, password) {
    if (!strict && safeContents.length === 0) return [];
    if (safeContents = asn1.fromDer(safeContents, strict), safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== !0) throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
    for (var res = [], i = 0; i < safeContents.value.length; i++) {
      var safeBag = safeContents.value[i],
        capture = {},
        errors = [];
      if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
        var error = new Error("Cannot read SafeBag.");
        throw error.errors = errors, error;
      }
      var bag = {
        type: asn1.derToOid(capture.bagId),
        attributes: _decodeBagAttributes(capture.bagAttributes)
      };
      res.push(bag);
      var validator,
        decoder,
        bagAsn1 = capture.bagValue.value[0];
      switch (bag.type) {
        case pki.oids.pkcs8ShroudedKeyBag:
          if (bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password), bagAsn1 === null) throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
        case pki.oids.keyBag:
          try {
            bag.key = pki.privateKeyFromAsn1(bagAsn1);
          } catch {
            bag.key = null, bag.asn1 = bagAsn1;
          }
          continue;
        case pki.oids.certBag:
          validator = certBagValidator, decoder = __name(function () {
            if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
              var error = new Error("Unsupported certificate type, only X.509 supported.");
              throw error.oid = asn1.derToOid(capture.certId), error;
            }
            var certAsn1 = asn1.fromDer(capture.cert, strict);
            try {
              bag.cert = pki.certificateFromAsn1(certAsn1, !0);
            } catch {
              bag.cert = null, bag.asn1 = certAsn1;
            }
          }, "decoder");
          break;
        default:
          var error = new Error("Unsupported PKCS#12 SafeBag type.");
          throw error.oid = bag.type, error;
      }
      if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 " + validator.name);
        throw error.errors = errors, error;
      }
      decoder();
    }
    return res;
  }
  __name(_decodeSafeContents, "_decodeSafeContents");
  function _decodeBagAttributes(attributes) {
    var decodedAttrs = {};
    if (attributes !== void 0) for (var i = 0; i < attributes.length; ++i) {
      var capture = {},
        errors = [];
      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 BagAttribute.");
        throw error.errors = errors, error;
      }
      var oid = asn1.derToOid(capture.oid);
      if (pki.oids[oid] !== void 0) {
        decodedAttrs[pki.oids[oid]] = [];
        for (var j = 0; j < capture.values.length; ++j) decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
      }
    }
    return decodedAttrs;
  }
  __name(_decodeBagAttributes, "_decodeBagAttributes");
  p12.toPkcs12Asn1 = function (key, cert, password, options) {
    options = options || {}, options.saltSize = options.saltSize || 8, options.count = options.count || 2048, options.algorithm = options.algorithm || options.encAlgorithm || "aes128", "useMac" in options || (options.useMac = !0), "localKeyId" in options || (options.localKeyId = null), "generateLocalKeyId" in options || (options.generateLocalKeyId = !0);
    var localKeyId = options.localKeyId,
      bagAttrs;
    if (localKeyId !== null) localKeyId = forge.util.hexToBytes(localKeyId);else if (options.generateLocalKeyId) if (cert) {
      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
      typeof pairedCert == "string" && (pairedCert = pki.certificateFromPem(pairedCert));
      var sha1 = forge.md.sha1.create();
      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes()), localKeyId = sha1.digest().getBytes();
    } else localKeyId = forge.random.getBytes(20);
    var attrs = [];
    localKeyId !== null && attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.localKeyId).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, localKeyId)])])), "friendlyName" in options && attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.friendlyName).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, !1, options.friendlyName)])])), attrs.length > 0 && (bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, attrs));
    var contents = [],
      chain = [];
    cert !== null && (forge.util.isArray(cert) ? chain = cert : chain = [cert]);
    for (var certSafeBags = [], i = 0; i < chain.length; ++i) {
      cert = chain[i], typeof cert == "string" && (cert = pki.certificateFromPem(cert));
      var certBagAttrs = i === 0 ? bagAttrs : void 0,
        certAsn1 = pki.certificateToAsn1(cert),
        certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.certBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(certAsn1).getBytes())])])]), certBagAttrs]);
      certSafeBags.push(certSafeBag);
    }
    if (certSafeBags.length > 0) {
      var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, certSafeBags),
        certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(certSafeContents).getBytes())])]);
      contents.push(certCI);
    }
    var keyBag = null;
    if (key !== null) {
      var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
      password === null ? keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.keyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [pkAsn1]), bagAttrs]) : keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), bagAttrs]);
      var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [keyBag]),
        keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(keySafeContents).getBytes())])]);
      contents.push(keyCI);
    }
    var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, contents),
      macData;
    if (options.useMac) {
      var sha1 = forge.md.sha1.create(),
        macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize)),
        count = options.count,
        key = p12.generateKey(password, macSalt, 3, count, 20),
        mac = forge.hmac.create();
      mac.start(sha1, key), mac.update(asn1.toDer(safe).getBytes());
      var macValue = mac.getMac();
      macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.sha1).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, macValue.getBytes())]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, macSalt.getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(count).getBytes())]);
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(3).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(pki.oids.data).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, asn1.toDer(safe).getBytes())])]), macData]);
  };
  p12.generateKey = forge.pbe.generatePkcs12Key;
});
var require_pki = __commonJSMin((exports, module) => {
  var forge = ta();
  df();
  b1();
  hk();
  dh();
  BE();
  xk();
  VE();
  $_();
  La();
  WE();
  var asn1 = forge.asn1,
    pki = module.exports = forge.pki = forge.pki || {};
  pki.pemToDer = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PEM to DER; PEM is encrypted.");
    return forge.util.createBuffer(msg.body);
  };
  pki.privateKeyFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert private key from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body);
    return pki.privateKeyFromAsn1(obj);
  };
  pki.privateKeyToPem = function (key, maxline) {
    var msg = {
      type: "RSA PRIVATE KEY",
      body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
  pki.privateKeyInfoToPem = function (pki, maxline) {
    var msg = {
      type: "PRIVATE KEY",
      body: asn1.toDer(pki).getBytes()
    };
    return forge.pem.encode(msg, {
      maxline: maxline
    });
  };
});
var require_tls = __commonJSMin((exports, module) => {
  var forge = ta();
  df();
  Z5();
  LE();
  dh();
  Ek();
  Du();
  r3();
  La();
  var prf_TLS1 = __name(function (secret, label, seed, length) {
      var rval = forge.util.createBuffer(),
        idx = secret.length >> 1,
        slen = idx + (secret.length & 1),
        s1 = secret.substr(0, slen),
        s2 = secret.substr(idx, slen),
        ai = forge.util.createBuffer(),
        hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16),
        sha1itr = Math.ceil(length / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) hmac.start(null, null), hmac.update(ai.getBytes()), ai.putBuffer(hmac.digest()), hmac.start(null, null), hmac.update(ai.bytes() + seed), md5bytes.putBuffer(hmac.digest());
      hmac.start("SHA1", s2);
      var sha1bytes = forge.util.createBuffer();
      ai.clear(), ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) hmac.start(null, null), hmac.update(ai.getBytes()), ai.putBuffer(hmac.digest()), hmac.start(null, null), hmac.update(ai.bytes() + seed), sha1bytes.putBuffer(hmac.digest());
      return rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length)), rval;
    }, "prf_TLS1"),
    hmac_sha1 = __name(function (key, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key);
      var b = forge.util.createBuffer();
      return b.putInt32(seqNum[0]), b.putInt32(seqNum[1]), b.putByte(record.type), b.putByte(record.version.major), b.putByte(record.version.minor), b.putInt16(record.length), b.putBytes(record.fragment.bytes()), hmac.update(b.getBytes()), hmac.digest().getBytes();
    }, "hmac_sha1"),
    deflate = __name(function (c, record, s) {
      var rval = !1;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes), record.length = bytes.length, rval = !0;
      } catch {}
      return rval;
    }, "deflate"),
    inflate = __name(function (c, record, s) {
      var rval = !1;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes), record.length = bytes.length, rval = !0;
      } catch {}
      return rval;
    }, "inflate"),
    readVector = __name(function (b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge.util.createBuffer(b.getBytes(len));
    }, "readVector"),
    writeVector = __name(function (b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3), b.putBuffer(v);
    }, "writeVector"),
    tls = {};
  tls.Versions = {
    TLS_1_0: {
      major: 3,
      minor: 1
    },
    TLS_1_1: {
      major: 3,
      minor: 2
    },
    TLS_1_2: {
      major: 3,
      minor: 3
    }
  };
  tls.SupportedVersions = [tls.Versions.TLS_1_1, tls.Versions.TLS_1_0];
  tls.Version = tls.SupportedVersions[0];
  tls.MaxFragment = 16384 - 1024;
  tls.ConnectionEnd = {
    server: 0,
    client: 1
  };
  tls.PRFAlgorithm = {
    tls_prf_sha256: 0
  };
  tls.BulkCipherAlgorithm = {
    none: null,
    rc4: 0,
    des3: 1,
    aes: 2
  };
  tls.CipherType = {
    stream: 0,
    block: 1,
    aead: 2
  };
  tls.MACAlgorithm = {
    none: null,
    hmac_md5: 0,
    hmac_sha1: 1,
    hmac_sha256: 2,
    hmac_sha384: 3,
    hmac_sha512: 4
  };
  tls.CompressionMethod = {
    none: 0,
    deflate: 1
  };
  tls.ContentType = {
    change_cipher_spec: 20,
    alert: 21,
    handshake: 22,
    application_data: 23,
    heartbeat: 24
  };
  tls.HandshakeType = {
    hello_request: 0,
    client_hello: 1,
    server_hello: 2,
    certificate: 11,
    server_key_exchange: 12,
    certificate_request: 13,
    server_hello_done: 14,
    certificate_verify: 15,
    client_key_exchange: 16,
    finished: 20
  };
  tls.Alert = {};
  tls.Alert.Level = {
    warning: 1,
    fatal: 2
  };
  tls.Alert.Description = {
    close_notify: 0,
    unexpected_message: 10,
    bad_record_mac: 20,
    decryption_failed: 21,
    record_overflow: 22,
    decompression_failure: 30,
    handshake_failure: 40,
    bad_certificate: 42,
    unsupported_certificate: 43,
    certificate_revoked: 44,
    certificate_expired: 45,
    certificate_unknown: 46,
    illegal_parameter: 47,
    unknown_ca: 48,
    access_denied: 49,
    decode_error: 50,
    decrypt_error: 51,
    export_restriction: 60,
    protocol_version: 70,
    insufficient_security: 71,
    internal_error: 80,
    user_canceled: 90,
    no_renegotiation: 100
  };
  tls.HeartbeatMessageType = {
    heartbeat_request: 1,
    heartbeat_response: 2
  };
  tls.CipherSuites = {};
  tls.getCipherSuite = function (twoBytes) {
    var rval = null;
    for (var key in tls.CipherSuites) {
      var cs = tls.CipherSuites[key];
      if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
        rval = cs;
        break;
      }
    }
    return rval;
  };
  tls.handleUnexpected = function (c, record) {
    var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
    ignore || c.error(c, {
      message: "Unexpected message. Received TLS record out of order.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.unexpected_message
      }
    });
  };
  tls.handleHelloRequest = function (c, record, length) {
    !c.handshaking && c.handshakes > 0 && (tls.queue(c, tls.createAlert(c, {
      level: tls.Alert.Level.warning,
      description: tls.Alert.Description.no_renegotiation
    })), tls.flush(c)), c.process();
  };
  tls.parseHelloMessage = function (c, record, length) {
    var msg = null,
      client = c.entity === tls.ConnectionEnd.client;
    if (length < 38) c.error(c, {
      message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    });else {
      var b = record.fragment,
        remaining = b.length();
      if (msg = {
        version: {
          major: b.getByte(),
          minor: b.getByte()
        },
        random: forge.util.createBuffer(b.getBytes(32)),
        session_id: readVector(b, 1),
        extensions: []
      }, client ? (msg.cipher_suite = b.getBytes(2), msg.compression_method = b.getByte()) : (msg.cipher_suites = readVector(b, 2), msg.compression_methods = readVector(b, 1)), remaining = length - (remaining - b.length()), remaining > 0) {
        for (var exts = readVector(b, 2); exts.length() > 0;) msg.extensions.push({
          type: [exts.getByte(), exts.getByte()],
          data: readVector(exts, 2)
        });
        if (!client) for (var i = 0; i < msg.extensions.length; ++i) {
          var ext = msg.extensions[i];
          if (ext.type[0] === 0 && ext.type[1] === 0) for (var snl = readVector(ext.data, 2); snl.length() > 0;) {
            var snType = snl.getByte();
            if (snType !== 0) break;
            c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
          }
        }
      }
      if (c.session.version && (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor)) return c.error(c, {
        message: "TLS version change is disallowed during renegotiation.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.protocol_version
        }
      });
      if (client) c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);else for (var tmp = forge.util.createBuffer(msg.cipher_suites.bytes()); tmp.length() > 0 && (c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2)), c.session.cipherSuite === null););
      if (c.session.cipherSuite === null) return c.error(c, {
        message: "No cipher suites in common.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.handshake_failure
        },
        cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
      });
      client ? c.session.compressionMethod = msg.compression_method : c.session.compressionMethod = tls.CompressionMethod.none;
    }
    return msg;
  };
  tls.createSecurityParameters = function (c, msg) {
    var client = c.entity === tls.ConnectionEnd.client,
      msgRandom = msg.random.bytes(),
      cRandom = client ? c.session.sp.client_random : msgRandom,
      sRandom = client ? msgRandom : tls.createRandom().getBytes();
    c.session.sp = {
      entity: c.entity,
      prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
      bulk_cipher_algorithm: null,
      cipher_type: null,
      enc_key_length: null,
      block_length: null,
      fixed_iv_length: null,
      record_iv_length: null,
      mac_algorithm: null,
      mac_length: null,
      mac_key_length: null,
      compression_algorithm: c.session.compressionMethod,
      pre_master_secret: null,
      master_secret: null,
      client_random: cRandom,
      server_random: sRandom
    };
  };
  tls.handleServerHello = function (c, record, length) {
    var msg = tls.parseHelloMessage(c, record, length);
    if (!c.fail) {
      if (msg.version.minor <= c.version.minor) c.version.minor = msg.version.minor;else return c.error(c, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.protocol_version
        }
      });
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      sessionId.length > 0 && sessionId === c.session.id ? (c.expect = SCC, c.session.resuming = !0, c.session.sp.server_random = msg.random.bytes()) : (c.expect = SCE, c.session.resuming = !1, tls.createSecurityParameters(c, msg)), c.session.id = sessionId, c.process();
    }
  };
  tls.handleClientHello = function (c, record, length) {
    var msg = tls.parseHelloMessage(c, record, length);
    if (!c.fail) {
      var sessionId = msg.session_id.bytes(),
        session = null;
      if (c.sessionCache && (session = c.sessionCache.getSession(sessionId), session === null ? sessionId = "" : (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) && (session = null, sessionId = "")), sessionId.length === 0 && (sessionId = forge.random.getBytes(32)), c.session.id = sessionId, c.session.clientHelloVersion = msg.version, c.session.sp = {}, session) c.version = c.session.version = session.version, c.session.sp = session.sp;else {
        for (var version, i = 1; i < tls.SupportedVersions.length && (version = tls.SupportedVersions[i], !(version.minor <= msg.version.minor)); ++i);
        c.version = {
          major: version.major,
          minor: version.minor
        }, c.session.version = c.version;
      }
      session !== null ? (c.expect = CCC, c.session.resuming = !0, c.session.sp.client_random = msg.random.bytes()) : (c.expect = c.verifyClient !== !1 ? CCE : CKE, c.session.resuming = !1, tls.createSecurityParameters(c, msg)), c.open = !0, tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      })), c.session.resuming ? (tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.change_cipher_spec,
        data: tls.createChangeCipherSpec()
      })), c.state.pending = tls.createConnectionState(c), c.state.current.write = c.state.pending.write, tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createFinished(c)
      }))) : (tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createCertificate(c)
      })), c.fail || (tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerKeyExchange(c)
      })), c.verifyClient !== !1 && tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createCertificateRequest(c)
      })), tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHelloDone(c)
      })))), tls.flush(c), c.process();
    }
  };
  tls.handleCertificate = function (c, record, length) {
    if (length < 3) return c.error(c, {
      message: "Invalid Certificate message. Message too short.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    });
    var b = record.fragment,
      msg = {
        certificate_list: readVector(b, 3)
      },
      cert,
      asn1,
      certs = [];
    try {
      for (; msg.certificate_list.length() > 0;) cert = readVector(msg.certificate_list, 3), asn1 = forge.asn1.fromDer(cert), cert = forge.pki.certificateFromAsn1(asn1, !0), certs.push(cert);
    } catch (ex) {
      return c.error(c, {
        message: "Could not parse certificate list.",
        cause: ex,
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.bad_certificate
        }
      });
    }
    var client = c.entity === tls.ConnectionEnd.client;
    (client || c.verifyClient === !0) && certs.length === 0 ? c.error(c, {
      message: client ? "No server certificate provided." : "No client certificate provided.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    }) : certs.length === 0 ? c.expect = client ? SKE : CKE : (client ? c.session.serverCertificate = certs[0] : c.session.clientCertificate = certs[0], tls.verifyCertificateChain(c, certs) && (c.expect = client ? SKE : CKE)), c.process();
  };
  tls.handleServerKeyExchange = function (c, record, length) {
    if (length > 0) return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.unsupported_certificate
      }
    });
    c.expect = SCR, c.process();
  };
  tls.handleClientKeyExchange = function (c, record, length) {
    if (length < 48) return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.unsupported_certificate
      }
    });
    var b = record.fragment,
      msg = {
        enc_pre_master_secret: readVector(b, 2).getBytes()
      },
      privateKey = null;
    if (c.getPrivateKey) try {
      privateKey = c.getPrivateKey(c, c.session.serverCertificate), privateKey = forge.pki.privateKeyFromPem(privateKey);
    } catch (ex) {
      c.error(c, {
        message: "Could not get private key.",
        cause: ex,
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.internal_error
        }
      });
    }
    if (privateKey === null) return c.error(c, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.internal_error
      }
    });
    try {
      var sp = c.session.sp;
      sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
      var version = c.session.clientHelloVersion;
      if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) throw new Error("TLS version rollback attack detected.");
    } catch {
      sp.pre_master_secret = forge.random.getBytes(48);
    }
    c.expect = CCC, c.session.clientCertificate !== null && (c.expect = CCV), c.process();
  };
  tls.handleCertificateRequest = function (c, record, length) {
    if (length < 3) return c.error(c, {
      message: "Invalid CertificateRequest. Message too short.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    });
    var b = record.fragment,
      msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
    c.session.certificateRequest = msg, c.expect = SHD, c.process();
  };
  tls.handleCertificateVerify = function (c, record, length) {
    if (length < 2) return c.error(c, {
      message: "Invalid CertificateVerify. Message too short.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    });
    var b = record.fragment;
    b.read -= 4;
    var msgBytes = b.bytes();
    b.read += 4;
    var msg = {
        signature: readVector(b, 2).getBytes()
      },
      verify = forge.util.createBuffer();
    verify.putBuffer(c.session.md5.digest()), verify.putBuffer(c.session.sha1.digest()), verify = verify.getBytes();
    try {
      var cert = c.session.clientCertificate;
      if (!cert.publicKey.verify(verify, msg.signature, "NONE")) throw new Error("CertificateVerify signature does not match.");
      c.session.md5.update(msgBytes), c.session.sha1.update(msgBytes);
    } catch {
      return c.error(c, {
        message: "Bad signature in CertificateVerify.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.handshake_failure
        }
      });
    }
    c.expect = CCC, c.process();
  };
  tls.handleServerHelloDone = function (c, record, length) {
    if (length > 0) return c.error(c, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.record_overflow
      }
    });
    if (c.serverCertificate === null) {
      var error = {
          message: "No server certificate provided. Not enough security.",
          send: !0,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        },
        depth = 0,
        ret = c.verify(c, error.alert.description, depth, []);
      if (ret !== !0) return (ret || ret === 0) && (typeof ret == "object" && !forge.util.isArray(ret) ? (ret.message && (error.message = ret.message), ret.alert && (error.alert.description = ret.alert)) : typeof ret == "number" && (error.alert.description = ret)), c.error(c, error);
    }
    c.session.certificateRequest !== null && (record = tls.createRecord(c, {
      type: tls.ContentType.handshake,
      data: tls.createCertificate(c)
    }), tls.queue(c, record)), record = tls.createRecord(c, {
      type: tls.ContentType.handshake,
      data: tls.createClientKeyExchange(c)
    }), tls.queue(c, record), c.expect = SER;
    var callback = __name(function (c, signature) {
      c.session.certificateRequest !== null && c.session.clientCertificate !== null && tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createCertificateVerify(c, signature)
      })), tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.change_cipher_spec,
        data: tls.createChangeCipherSpec()
      })), c.state.pending = tls.createConnectionState(c), c.state.current.write = c.state.pending.write, tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createFinished(c)
      })), c.expect = SCC, tls.flush(c), c.process();
    }, "callback");
    if (c.session.certificateRequest === null || c.session.clientCertificate === null) return callback(c, null);
    tls.getClientSignature(c, callback);
  };
  tls.handleChangeCipherSpec = function (c, record) {
    if (record.fragment.getByte() !== 1) return c.error(c, {
      message: "Invalid ChangeCipherSpec message received.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.illegal_parameter
      }
    });
    var client = c.entity === tls.ConnectionEnd.client;
    (c.session.resuming && client || !c.session.resuming && !client) && (c.state.pending = tls.createConnectionState(c)), c.state.current.read = c.state.pending.read, (!c.session.resuming && client || c.session.resuming && !client) && (c.state.pending = null), c.expect = client ? SFI : CFI, c.process();
  };
  tls.handleFinished = function (c, record, length) {
    var b = record.fragment;
    b.read -= 4;
    var msgBytes = b.bytes();
    b.read += 4;
    var vd = record.fragment.getBytes();
    b = forge.util.createBuffer(), b.putBuffer(c.session.md5.digest()), b.putBuffer(c.session.sha1.digest());
    var client = c.entity === tls.ConnectionEnd.client,
      label = client ? "server finished" : "client finished",
      sp = c.session.sp,
      vdl = 12,
      prf = prf_TLS1;
    if (b = prf(sp.master_secret, label, b.getBytes(), vdl), b.getBytes() !== vd) return c.error(c, {
      message: "Invalid verify_data in Finished message.",
      send: !0,
      alert: {
        level: tls.Alert.Level.fatal,
        description: tls.Alert.Description.decrypt_error
      }
    });
    c.session.md5.update(msgBytes), c.session.sha1.update(msgBytes), (c.session.resuming && client || !c.session.resuming && !client) && (tls.queue(c, tls.createRecord(c, {
      type: tls.ContentType.change_cipher_spec,
      data: tls.createChangeCipherSpec()
    })), c.state.current.write = c.state.pending.write, c.state.pending = null, tls.queue(c, tls.createRecord(c, {
      type: tls.ContentType.handshake,
      data: tls.createFinished(c)
    }))), c.expect = client ? SAD : CAD, c.handshaking = !1, ++c.handshakes, c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate, tls.flush(c), c.isConnected = !0, c.connected(c), c.process();
  };
  tls.handleAlert = function (c, record) {
    var b = record.fragment,
      alert = {
        level: b.getByte(),
        description: b.getByte()
      },
      msg;
    switch (alert.description) {
      case tls.Alert.Description.close_notify:
        msg = "Connection closed.";
        break;
      case tls.Alert.Description.unexpected_message:
        msg = "Unexpected message.";
        break;
      case tls.Alert.Description.bad_record_mac:
        msg = "Bad record MAC.";
        break;
      case tls.Alert.Description.decryption_failed:
        msg = "Decryption failed.";
        break;
      case tls.Alert.Description.record_overflow:
        msg = "Record overflow.";
        break;
      case tls.Alert.Description.decompression_failure:
        msg = "Decompression failed.";
        break;
      case tls.Alert.Description.handshake_failure:
        msg = "Handshake failure.";
        break;
      case tls.Alert.Description.bad_certificate:
        msg = "Bad certificate.";
        break;
      case tls.Alert.Description.unsupported_certificate:
        msg = "Unsupported certificate.";
        break;
      case tls.Alert.Description.certificate_revoked:
        msg = "Certificate revoked.";
        break;
      case tls.Alert.Description.certificate_expired:
        msg = "Certificate expired.";
        break;
      case tls.Alert.Description.certificate_unknown:
        msg = "Certificate unknown.";
        break;
      case tls.Alert.Description.illegal_parameter:
        msg = "Illegal parameter.";
        break;
      case tls.Alert.Description.unknown_ca:
        msg = "Unknown certificate authority.";
        break;
      case tls.Alert.Description.access_denied:
        msg = "Access denied.";
        break;
      case tls.Alert.Description.decode_error:
        msg = "Decode error.";
        break;
      case tls.Alert.Description.decrypt_error:
        msg = "Decrypt error.";
        break;
      case tls.Alert.Description.export_restriction:
        msg = "Export restriction.";
        break;
      case tls.Alert.Description.protocol_version:
        msg = "Unsupported protocol version.";
        break;
      case tls.Alert.Description.insufficient_security:
        msg = "Insufficient security.";
        break;
      case tls.Alert.Description.internal_error:
        msg = "Internal error.";
        break;
      case tls.Alert.Description.user_canceled:
        msg = "User canceled.";
        break;
      case tls.Alert.Description.no_renegotiation:
        msg = "Renegotiation not supported.";
        break;
      default:
        msg = "Unknown error.";
        break;
    }
    if (alert.description === tls.Alert.Description.close_notify) return c.close();
    c.error(c, {
      message: msg,
      send: !1,
      origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
      alert: alert
    }), c.process();
  };
  tls.handleHandshake = function (c, record) {
    var b = record.fragment,
      type = b.getByte(),
      length = b.getInt24();
    if (length > b.length()) return c.fragmented = record, record.fragment = forge.util.createBuffer(), b.read -= 4, c.process();
    c.fragmented = null, b.read -= 4;
    var bytes = b.bytes(length + 4);
    b.read += 4, type in hsTable[c.entity][c.expect] ? (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail && (c.handshaking = !0, c.session = {
      version: null,
      extensions: {
        server_name: {
          serverNameList: []
        }
      },
      cipherSuite: null,
      compressionMethod: null,
      serverCertificate: null,
      clientCertificate: null,
      md5: forge.md.md5.create(),
      sha1: forge.md.sha1.create()
    }), type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished && (c.session.md5.update(bytes), c.session.sha1.update(bytes)), hsTable[c.entity][c.expect][type](c, record, length)) : tls.handleUnexpected(c, record);
  };
  tls.handleApplicationData = function (c, record) {
    c.data.putBuffer(record.fragment), c.dataReady(c), c.process();
  };
  tls.handleHeartbeat = function (c, record) {
    var b = record.fragment,
      type = b.getByte(),
      length = b.getInt16(),
      payload = b.getBytes(length);
    if (type === tls.HeartbeatMessageType.heartbeat_request) {
      if (c.handshaking || length > payload.length) return c.process();
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.heartbeat,
        data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
      })), tls.flush(c);
    } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
      if (payload !== c.expectedHeartbeatPayload) return c.process();
      c.heartbeatReceived && c.heartbeatReceived(c, forge.util.createBuffer(payload));
    }
    c.process();
  };
  var SHE = 0,
    SCE = 1,
    SKE = 2,
    SCR = 3,
    SHD = 4,
    SCC = 5,
    SFI = 6,
    SAD = 7,
    SER = 8,
    CHE = 0,
    CCE = 1,
    CKE = 2,
    CCV = 3,
    CCC = 4,
    CFI = 5,
    CAD = 6,
    __ = tls.handleUnexpected,
    R0 = tls.handleChangeCipherSpec,
    R1 = tls.handleAlert,
    R2 = tls.handleHandshake,
    R3 = tls.handleApplicationData,
    R4 = tls.handleHeartbeat,
    ctTable = [];
  ctTable[tls.ConnectionEnd.client] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
  ctTable[tls.ConnectionEnd.server] = [[__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [__, R1, R2, __, R4], [R0, R1, __, __, R4], [__, R1, R2, __, R4], [__, R1, R2, R3, R4], [__, R1, R2, __, R4]];
  var H0 = tls.handleHelloRequest,
    H1 = tls.handleServerHello,
    H2 = tls.handleCertificate,
    H3 = tls.handleServerKeyExchange,
    H4 = tls.handleCertificateRequest,
    H5 = tls.handleServerHelloDone,
    H6 = tls.handleFinished,
    hsTable = [];
  hsTable[tls.ConnectionEnd.client] = [[__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
  var H7 = tls.handleClientHello,
    H8 = tls.handleClientKeyExchange,
    H9 = tls.handleCertificateVerify;
  hsTable[tls.ConnectionEnd.server] = [[__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __], [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]];
  tls.generateKeys = function (c, sp) {
    var prf = prf_TLS1,
      random = sp.client_random + sp.server_random;
    c.session.resuming || (sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes(), sp.pre_master_secret = null), random = sp.server_random + sp.client_random;
    var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length,
      tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
    tls10 && (length += 2 * sp.fixed_iv_length);
    var km = prf(sp.master_secret, "key expansion", random, length),
      rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
    return tls10 && (rval.client_write_IV = km.getBytes(sp.fixed_iv_length), rval.server_write_IV = km.getBytes(sp.fixed_iv_length)), rval;
  };
  tls.createConnectionState = function (c) {
    var client = c.entity === tls.ConnectionEnd.client,
      createMode = __name(function () {
        var mode = {
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function (record) {
            return !0;
          },
          compressionState: null,
          compressFunction: function (record) {
            return !0;
          },
          updateSequenceNumber: function () {
            mode.sequenceNumber[1] === 4294967295 ? (mode.sequenceNumber[1] = 0, ++mode.sequenceNumber[0]) : ++mode.sequenceNumber[1];
          }
        };
        return mode;
      }, "createMode"),
      state = {
        read: createMode(),
        write: createMode()
      };
    if (state.read.update = function (c, record) {
      return state.read.cipherFunction(record, state.read) ? state.read.compressFunction(c, record, state.read) || c.error(c, {
        message: "Could not decompress record.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.decompression_failure
        }
      }) : c.error(c, {
        message: "Could not decrypt record or bad MAC.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.bad_record_mac
        }
      }), !c.fail;
    }, state.write.update = function (c, record) {
      return state.write.compressFunction(c, record, state.write) ? state.write.cipherFunction(record, state.write) || c.error(c, {
        message: "Could not encrypt record.",
        send: !1,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.internal_error
        }
      }) : c.error(c, {
        message: "Could not compress record.",
        send: !1,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.internal_error
        }
      }), !c.fail;
    }, c.session) {
      var sp = c.session.sp;
      switch (c.session.cipherSuite.initSecurityParameters(sp), sp.keys = tls.generateKeys(c, sp), state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key, state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key, c.session.cipherSuite.initConnectionState(state, c, sp), sp.compression_algorithm) {
        case tls.CompressionMethod.none:
          break;
        case tls.CompressionMethod.deflate:
          state.read.compressFunction = inflate, state.write.compressFunction = deflate;
          break;
        default:
          throw new Error("Unsupported compression algorithm.");
      }
    }
    return state;
  };
  tls.createRandom = function () {
    var d = new Date(),
      utc = +d + d.getTimezoneOffset() * 6e4,
      rval = forge.util.createBuffer();
    return rval.putInt32(utc), rval.putBytes(forge.random.getBytes(28)), rval;
  };
  tls.createRecord = function (c, options) {
    if (!options.data) return null;
    var record = {
      type: options.type,
      version: {
        major: c.version.major,
        minor: c.version.minor
      },
      length: options.data.length(),
      fragment: options.data
    };
    return record;
  };
  tls.createAlert = function (c, alert) {
    var b = forge.util.createBuffer();
    return b.putByte(alert.level), b.putByte(alert.description), tls.createRecord(c, {
      type: tls.ContentType.alert,
      data: b
    });
  };
  tls.createClientHello = function (c) {
    c.session.clientHelloVersion = {
      major: c.version.major,
      minor: c.version.minor
    };
    for (var cipherSuites = forge.util.createBuffer(), i = 0; i < c.cipherSuites.length; ++i) {
      var cs = c.cipherSuites[i];
      cipherSuites.putByte(cs.id[0]), cipherSuites.putByte(cs.id[1]);
    }
    var cSuites = cipherSuites.length(),
      compressionMethods = forge.util.createBuffer();
    compressionMethods.putByte(tls.CompressionMethod.none);
    var cMethods = compressionMethods.length(),
      extensions = forge.util.createBuffer();
    if (c.virtualHost) {
      var ext = forge.util.createBuffer();
      ext.putByte(0), ext.putByte(0);
      var serverName = forge.util.createBuffer();
      serverName.putByte(0), writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
      var snList = forge.util.createBuffer();
      writeVector(snList, 2, serverName), writeVector(ext, 2, snList), extensions.putBuffer(ext);
    }
    var extLength = extensions.length();
    extLength > 0 && (extLength += 2);
    var sessionId = c.session.id,
      length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength,
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.client_hello), rval.putInt24(length), rval.putByte(c.version.major), rval.putByte(c.version.minor), rval.putBytes(c.session.sp.client_random), writeVector(rval, 1, forge.util.createBuffer(sessionId)), writeVector(rval, 2, cipherSuites), writeVector(rval, 1, compressionMethods), extLength > 0 && writeVector(rval, 2, extensions), rval;
  };
  tls.createServerHello = function (c) {
    var sessionId = c.session.id,
      length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1,
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.server_hello), rval.putInt24(length), rval.putByte(c.version.major), rval.putByte(c.version.minor), rval.putBytes(c.session.sp.server_random), writeVector(rval, 1, forge.util.createBuffer(sessionId)), rval.putByte(c.session.cipherSuite.id[0]), rval.putByte(c.session.cipherSuite.id[1]), rval.putByte(c.session.compressionMethod), rval;
  };
  tls.createCertificate = function (c) {
    var client = c.entity === tls.ConnectionEnd.client,
      cert = null;
    if (c.getCertificate) {
      var hint;
      client ? hint = c.session.certificateRequest : hint = c.session.extensions.server_name.serverNameList, cert = c.getCertificate(c, hint);
    }
    var certList = forge.util.createBuffer();
    if (cert !== null) try {
      forge.util.isArray(cert) || (cert = [cert]);
      for (var asn1 = null, i = 0; i < cert.length; ++i) {
        var msg = forge.pem.decode(cert[i])[0];
        if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
          var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          throw error.headerType = msg.type, error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        var der = forge.util.createBuffer(msg.body);
        asn1 === null && (asn1 = forge.asn1.fromDer(der.bytes(), !1));
        var certBuffer = forge.util.createBuffer();
        writeVector(certBuffer, 3, der), certList.putBuffer(certBuffer);
      }
      cert = forge.pki.certificateFromAsn1(asn1), client ? c.session.clientCertificate = cert : c.session.serverCertificate = cert;
    } catch (ex) {
      return c.error(c, {
        message: "Could not send certificate list.",
        cause: ex,
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.bad_certificate
        }
      });
    }
    var length = 3 + certList.length(),
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.certificate), rval.putInt24(length), writeVector(rval, 3, certList), rval;
  };
  tls.createClientKeyExchange = function (c) {
    var b = forge.util.createBuffer();
    b.putByte(c.session.clientHelloVersion.major), b.putByte(c.session.clientHelloVersion.minor), b.putBytes(forge.random.getBytes(46));
    var sp = c.session.sp;
    sp.pre_master_secret = b.getBytes();
    var key = c.session.serverCertificate.publicKey;
    b = key.encrypt(sp.pre_master_secret);
    var length = b.length + 2,
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.client_key_exchange), rval.putInt24(length), rval.putInt16(b.length), rval.putBytes(b), rval;
  };
  tls.createServerKeyExchange = function (c) {
    var length = 0,
      rval = forge.util.createBuffer();
    return length > 0 && (rval.putByte(tls.HandshakeType.server_key_exchange), rval.putInt24(length)), rval;
  };
  tls.getClientSignature = function (c, callback) {
    var b = forge.util.createBuffer();
    b.putBuffer(c.session.md5.digest()), b.putBuffer(c.session.sha1.digest()), b = b.getBytes(), c.getSignature = c.getSignature || function (c, b, callback) {
      var privateKey = null;
      if (c.getPrivateKey) try {
        privateKey = c.getPrivateKey(c, c.session.clientCertificate), privateKey = forge.pki.privateKeyFromPem(privateKey);
      } catch (ex) {
        c.error(c, {
          message: "Could not get private key.",
          cause: ex,
          send: !0,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      privateKey === null ? c.error(c, {
        message: "No private key set.",
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.internal_error
        }
      }) : b = privateKey.sign(b, null), callback(c, b);
    }, c.getSignature(c, b, callback);
  };
  tls.createCertificateVerify = function (c, signature) {
    var length = signature.length + 2,
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.certificate_verify), rval.putInt24(length), rval.putInt16(signature.length), rval.putBytes(signature), rval;
  };
  tls.createCertificateRequest = function (c) {
    var certTypes = forge.util.createBuffer();
    certTypes.putByte(1);
    var cAs = forge.util.createBuffer();
    for (var key in c.caStore.certs) {
      var cert = c.caStore.certs[key],
        dn = forge.pki.distinguishedNameToAsn1(cert.subject),
        byteBuffer = forge.asn1.toDer(dn);
      cAs.putInt16(byteBuffer.length()), cAs.putBuffer(byteBuffer);
    }
    var length = 1 + certTypes.length() + 2 + cAs.length(),
      rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.certificate_request), rval.putInt24(length), writeVector(rval, 1, certTypes), writeVector(rval, 2, cAs), rval;
  };
  tls.createServerHelloDone = function (c) {
    var rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.server_hello_done), rval.putInt24(0), rval;
  };
  tls.createChangeCipherSpec = function () {
    var rval = forge.util.createBuffer();
    return rval.putByte(1), rval;
  };
  tls.createFinished = function (c) {
    var b = forge.util.createBuffer();
    b.putBuffer(c.session.md5.digest()), b.putBuffer(c.session.sha1.digest());
    var client = c.entity === tls.ConnectionEnd.client,
      sp = c.session.sp,
      vdl = 12,
      prf = prf_TLS1,
      label = client ? "client finished" : "server finished";
    b = prf(sp.master_secret, label, b.getBytes(), vdl);
    var rval = forge.util.createBuffer();
    return rval.putByte(tls.HandshakeType.finished), rval.putInt24(b.length()), rval.putBuffer(b), rval;
  };
  tls.createHeartbeat = function (type, payload, payloadLength) {
    typeof payloadLength > "u" && (payloadLength = payload.length);
    var rval = forge.util.createBuffer();
    rval.putByte(type), rval.putInt16(payloadLength), rval.putBytes(payload);
    var plaintextLength = rval.length(),
      paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
    return rval.putBytes(forge.random.getBytes(paddingLength)), rval;
  };
  tls.queue = function (c, record) {
    if (record && !(record.fragment.length() === 0 && (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec))) {
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes), c.session.sha1.update(bytes), bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) records = [record];else {
        records = [];
        for (var data = record.fragment.bytes(); data.length > tls.MaxFragment;) records.push(tls.createRecord(c, {
          type: record.type,
          data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
        })), data = data.slice(tls.MaxFragment);
        data.length > 0 && records.push(tls.createRecord(c, {
          type: record.type,
          data: forge.util.createBuffer(data)
        }));
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i],
          s = c.state.current.write;
        s.update(c, rec) && c.records.push(rec);
      }
    }
  };
  tls.flush = function (c) {
    for (var i = 0; i < c.records.length; ++i) {
      var record = c.records[i];
      c.tlsData.putByte(record.type), c.tlsData.putByte(record.version.major), c.tlsData.putByte(record.version.minor), c.tlsData.putInt16(record.fragment.length()), c.tlsData.putBuffer(c.records[i].fragment);
    }
    return c.records = [], c.tlsDataReady(c);
  };
  var _certErrorToAlertDesc = __name(function (error) {
      switch (error) {
        case !0:
          return !0;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    }, "_certErrorToAlertDesc"),
    _alertDescToCertError = __name(function (desc) {
      switch (desc) {
        case !0:
          return !0;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    }, "_alertDescToCertError");
  tls.verifyCertificateChain = function (c, chain) {
    try {
      var options = {};
      for (var key in c.verifyOptions) options[key] = c.verifyOptions[key];
      options.verify = function (vfd, depth, chain) {
        var desc = _certErrorToAlertDesc(vfd),
          ret = c.verify(c, vfd, depth, chain);
        if (ret !== !0) {
          if (typeof ret == "object" && !forge.util.isArray(ret)) {
            var error = new Error("The application rejected the certificate.");
            throw error.send = !0, error.alert = {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }, ret.message && (error.message = ret.message), ret.alert && (error.alert.description = ret.alert), error;
          }
          ret !== vfd && (ret = _alertDescToCertError(ret));
        }
        return ret;
      }, forge.pki.verifyCertificateChain(c.caStore, chain, options);
    } catch (ex) {
      var err = ex;
      (typeof err != "object" || forge.util.isArray(err)) && (err = {
        send: !0,
        alert: {
          level: tls.Alert.Level.fatal,
          description: _certErrorToAlertDesc(ex)
        }
      }), "send" in err || (err.send = !0), "alert" in err || (err.alert = {
        level: tls.Alert.Level.fatal,
        description: _certErrorToAlertDesc(err.error)
      }), c.error(c, err);
    }
    return !c.fail;
  };
  tls.createSessionCache = function (cache, capacity) {
    var rval = null;
    if (cache && cache.getSession && cache.setSession && cache.order) rval = cache;else {
      rval = {}, rval.cache = cache || {}, rval.capacity = Math.max(capacity || 100, 1), rval.order = [];
      for (var key in cache) rval.order.length <= capacity ? rval.order.push(key) : delete cache[key];
      rval.getSession = function (sessionId) {
        var session = null,
          key = null;
        if (sessionId ? key = forge.util.bytesToHex(sessionId) : rval.order.length > 0 && (key = rval.order[0]), key !== null && key in rval.cache) {
          session = rval.cache[key], delete rval.cache[key];
          for (var i in rval.order) if (rval.order[i] === key) {
            rval.order.splice(i, 1);
            break;
          }
        }
        return session;
      }, rval.setSession = function (sessionId, session) {
        if (rval.order.length === rval.capacity) {
          var key = rval.order.shift();
          delete rval.cache[key];
        }
        var key = forge.util.bytesToHex(sessionId);
        rval.order.push(key), rval.cache[key] = session;
      };
    }
    return rval;
  };
  tls.createConnection = function (options) {
    var caStore = null;
    options.caStore ? forge.util.isArray(options.caStore) ? caStore = forge.pki.createCaStore(options.caStore) : caStore = options.caStore : caStore = forge.pki.createCaStore();
    var cipherSuites = options.cipherSuites || null;
    if (cipherSuites === null) {
      cipherSuites = [];
      for (var key in tls.CipherSuites) cipherSuites.push(tls.CipherSuites[key]);
    }
    var entity = options.server ? tls.ConnectionEnd.server : tls.ConnectionEnd.client,
      sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null,
      c = {
        version: {
          major: tls.Version.major,
          minor: tls.Version.minor
        },
        entity: entity,
        sessionId: options.sessionId,
        caStore: caStore,
        sessionCache: sessionCache,
        cipherSuites: cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || !1,
        verify: options.verify || function (cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function (c, ex) {
          ex.origin = ex.origin || (c.entity === tls.ConnectionEnd.client ? "client" : "server"), ex.send && (tls.queue(c, tls.createAlert(c, ex.alert)), tls.flush(c));
          var fatal = ex.fatal !== !1;
          fatal && (c.fail = !0), options.error(c, ex), fatal && c.close(!1);
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
    c.reset = function (clearFail) {
      c.version = {
        major: tls.Version.major,
        minor: tls.Version.minor
      }, c.record = null, c.session = null, c.peerCertificate = null, c.state = {
        pending: null,
        current: null
      }, c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE, c.fragmented = null, c.records = [], c.open = !1, c.handshakes = 0, c.handshaking = !1, c.isConnected = !1, c.fail = !(clearFail || typeof clearFail > "u"), c.input.clear(), c.tlsData.clear(), c.data.clear(), c.state.current = tls.createConnectionState(c);
    }, c.reset();
    var _update = __name(function (c, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec,
          handlers = ctTable[c.entity][c.expect];
        aligned in handlers ? handlers[aligned](c, record) : tls.handleUnexpected(c, record);
      }, "_update"),
      _readRecordHeader = __name(function (c) {
        var rval = 0,
          b = c.input,
          len = b.length();
        if (len < 5) rval = 5 - len;else {
          c.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: !1
          };
          var compatibleVersion = c.record.version.major === c.version.major;
          compatibleVersion && c.session && c.session.version && (compatibleVersion = c.record.version.minor === c.version.minor), compatibleVersion || c.error(c, {
            message: "Incompatible TLS version.",
            send: !0,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.protocol_version
            }
          });
        }
        return rval;
      }, "_readRecordHeader"),
      _readRecord = __name(function (c) {
        var rval = 0,
          b = c.input,
          len = b.length();
        if (len < c.record.length) rval = c.record.length - len;else {
          c.record.fragment.putBytes(b.getBytes(c.record.length)), b.compact();
          var s = c.state.current.read;
          s.update(c, c.record) && (c.fragmented !== null && (c.fragmented.type === c.record.type ? (c.fragmented.fragment.putBuffer(c.record.fragment), c.record = c.fragmented) : c.error(c, {
            message: "Invalid fragmented record.",
            send: !0,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.unexpected_message
            }
          })), c.record.ready = !0);
        }
        return rval;
      }, "_readRecord");
    return c.handshake = function (sessionId) {
      if (c.entity !== tls.ConnectionEnd.client) c.error(c, {
        message: "Cannot initiate handshake as a server.",
        fatal: !1
      });else if (c.handshaking) c.error(c, {
        message: "Handshake already in progress.",
        fatal: !1
      });else {
        c.fail && !c.open && c.handshakes === 0 && (c.fail = !1), c.handshaking = !0, sessionId = sessionId || "";
        var session = null;
        sessionId.length > 0 && (c.sessionCache && (session = c.sessionCache.getSession(sessionId)), session === null && (sessionId = "")), sessionId.length === 0 && c.sessionCache && (session = c.sessionCache.getSession(), session !== null && (sessionId = session.id)), c.session = {
          id: sessionId,
          version: null,
          cipherSuite: null,
          compressionMethod: null,
          serverCertificate: null,
          certificateRequest: null,
          clientCertificate: null,
          sp: {},
          md5: forge.md.md5.create(),
          sha1: forge.md.sha1.create()
        }, session && (c.version = session.version, c.session.sp = session.sp), c.session.sp.client_random = tls.createRandom().getBytes(), c.open = !0, tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createClientHello(c)
        })), tls.flush(c);
      }
    }, c.process = function (data) {
      var rval = 0;
      return data && c.input.putBytes(data), c.fail || (c.record !== null && c.record.ready && c.record.fragment.isEmpty() && (c.record = null), c.record === null && (rval = _readRecordHeader(c)), !c.fail && c.record !== null && !c.record.ready && (rval = _readRecord(c)), !c.fail && c.record !== null && c.record.ready && _update(c, c.record)), rval;
    }, c.prepare = function (data) {
      return tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.application_data,
        data: forge.util.createBuffer(data)
      })), tls.flush(c);
    }, c.prepareHeartbeatRequest = function (payload, payloadLength) {
      return payload instanceof forge.util.ByteBuffer && (payload = payload.bytes()), typeof payloadLength > "u" && (payloadLength = payload.length), c.expectedHeartbeatPayload = payload, tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.heartbeat,
        data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
      })), tls.flush(c);
    }, c.close = function (clearFail) {
      if (!c.fail && c.sessionCache && c.session) {
        var session = {
          id: c.session.id,
          version: c.session.version,
          sp: c.session.sp
        };
        session.sp.keys = null, c.sessionCache.setSession(session.id, session);
      }
      c.open && (c.open = !1, c.input.clear(), (c.isConnected || c.handshaking) && (c.isConnected = c.handshaking = !1, tls.queue(c, tls.createAlert(c, {
        level: tls.Alert.Level.warning,
        description: tls.Alert.Description.close_notify
      })), tls.flush(c)), c.closed(c)), c.reset(clearFail);
    }, c;
  };
  module.exports = forge.tls = forge.tls || {};
  for (key in tls) typeof tls[key] != "function" && (forge.tls[key] = tls[key]);
  var key;
  forge.tls.prf_tls1 = prf_TLS1;
  forge.tls.hmac_sha1 = hmac_sha1;
  forge.tls.createSessionCache = tls.createSessionCache;
  forge.tls.createConnection = tls.createConnection;
});
var require_aesCipherSuites = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  Ak();
  var tls = module.exports = forge.tls;
  tls.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
    id: [0, 47],
    name: "TLS_RSA_WITH_AES_128_CBC_SHA",
    initSecurityParameters: function (sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, sp.cipher_type = tls.CipherType.block, sp.enc_key_length = 16, sp.block_length = 16, sp.fixed_iv_length = 16, sp.record_iv_length = 16, sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1, sp.mac_length = 20, sp.mac_key_length = 20;
    },
    initConnectionState: initConnectionState
  };
  tls.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
    id: [0, 53],
    name: "TLS_RSA_WITH_AES_256_CBC_SHA",
    initSecurityParameters: function (sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes, sp.cipher_type = tls.CipherType.block, sp.enc_key_length = 32, sp.block_length = 16, sp.fixed_iv_length = 16, sp.record_iv_length = 16, sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1, sp.mac_length = 20, sp.mac_key_length = 20;
    },
    initConnectionState: initConnectionState
  };
  function initConnectionState(state, c, sp) {
    var client = c.entity === forge.tls.ConnectionEnd.client;
    state.read.cipherState = {
      init: !1,
      cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
      iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
    }, state.write.cipherState = {
      init: !1,
      cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
      iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
    }, state.read.cipherFunction = decrypt_aes_cbc_sha1, state.write.cipherFunction = encrypt_aes_cbc_sha1, state.read.macLength = state.write.macLength = sp.mac_length, state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
  }
  __name(initConnectionState, "initConnectionState");
  function encrypt_aes_cbc_sha1(record, s) {
    var rval = !1,
      mac = s.macFunction(s.macKey, s.sequenceNumber, record);
    record.fragment.putBytes(mac), s.updateSequenceNumber();
    var iv;
    record.version.minor === tls.Versions.TLS_1_0.minor ? iv = s.cipherState.init ? null : s.cipherState.iv : iv = forge.random.getBytesSync(16), s.cipherState.init = !0;
    var cipher = s.cipherState.cipher;
    return cipher.start({
      iv: iv
    }), record.version.minor >= tls.Versions.TLS_1_1.minor && cipher.output.putBytes(iv), cipher.update(record.fragment), cipher.finish(encrypt_aes_cbc_sha1_padding) && (record.fragment = cipher.output, record.length = record.fragment.length(), rval = !0), rval;
  }
  __name(encrypt_aes_cbc_sha1, "encrypt_aes_cbc_sha1");
  function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
    if (!decrypt) {
      var padding = blockSize - input.length() % blockSize;
      input.fillWithByte(padding - 1, padding);
    }
    return !0;
  }
  __name(encrypt_aes_cbc_sha1_padding, "encrypt_aes_cbc_sha1_padding");
  function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
    var rval = !0;
    if (decrypt) {
      for (var len = output.length(), paddingLength = output.last(), i = len - 1 - paddingLength; i < len - 1; ++i) rval = rval && output.at(i) == paddingLength;
      rval && output.truncate(paddingLength + 1);
    }
    return rval;
  }
  __name(decrypt_aes_cbc_sha1_padding, "decrypt_aes_cbc_sha1_padding");
  function decrypt_aes_cbc_sha1(record, s) {
    var rval = !1,
      iv;
    record.version.minor === tls.Versions.TLS_1_0.minor ? iv = s.cipherState.init ? null : s.cipherState.iv : iv = record.fragment.getBytes(16), s.cipherState.init = !0;
    var cipher = s.cipherState.cipher;
    cipher.start({
      iv: iv
    }), cipher.update(record.fragment), rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
    var macLen = s.macLength,
      mac = forge.random.getBytesSync(macLen),
      len = cipher.output.length();
    len >= macLen ? (record.fragment = cipher.output.getBytes(len - macLen), mac = cipher.output.getBytes(macLen)) : record.fragment = cipher.output.getBytes(), record.fragment = forge.util.createBuffer(record.fragment), record.length = record.fragment.length();
    var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
    return s.updateSequenceNumber(), rval = compareMacs(s.macKey, mac, mac2) && rval, rval;
  }
  __name(decrypt_aes_cbc_sha1, "decrypt_aes_cbc_sha1");
  function compareMacs(key, mac1, mac2) {
    var hmac = forge.hmac.create();
    return hmac.start("SHA1", key), hmac.update(mac1), mac1 = hmac.digest().getBytes(), hmac.start(null, null), hmac.update(mac2), mac2 = hmac.digest().getBytes(), mac1 === mac2;
  }
  __name(compareMacs, "compareMacs");
});
var require_sha512 = __commonJSMin((exports, module) => {
  var forge = ta();
  Qf();
  La();
  var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
  forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
  var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
  sha384.create = function () {
    return sha512.create("SHA-384");
  };
  forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
  forge.sha512.sha256 = forge.sha512.sha256 || {
    create: function () {
      return sha512.create("SHA-512/256");
    }
  };
  forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
  forge.sha512.sha224 = forge.sha512.sha224 || {
    create: function () {
      return sha512.create("SHA-512/224");
    }
  };
  forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
  sha512.create = function (algorithm) {
    if (_initialized || _init(), typeof algorithm > "u" && (algorithm = "SHA-512"), !(algorithm in _states)) throw new Error("Invalid SHA-512 algorithm: " + algorithm);
    for (var _state = _states[algorithm], _h = null, _input = forge.util.createBuffer(), _w = new Array(80), wi = 0; wi < 80; ++wi) _w[wi] = new Array(2);
    var digestLength = 64;
    switch (algorithm) {
      case "SHA-384":
        digestLength = 48;
        break;
      case "SHA-512/256":
        digestLength = 32;
        break;
      case "SHA-512/224":
        digestLength = 28;
        break;
    }
    var md = {
      algorithm: algorithm.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength: digestLength,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16
    };
    return md.start = function () {
      md.messageLength = 0, md.fullMessageLength = md.messageLength128 = [];
      for (var int32s = md.messageLengthSize / 4, i = 0; i < int32s; ++i) md.fullMessageLength.push(0);
      _input = forge.util.createBuffer(), _h = new Array(_state.length);
      for (var i = 0; i < _state.length; ++i) _h[i] = _state[i].slice(0);
      return md;
    }, md.start(), md.update = function (msg, encoding) {
      encoding === "utf8" && (msg = forge.util.encodeUtf8(msg));
      var len = msg.length;
      md.messageLength += len, len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) md.fullMessageLength[i] += len[1], len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0), md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0, len[0] = len[1] / 4294967296 >>> 0;
      return _input.putBytes(msg), _update(_h, _w, _input), (_input.read > 2048 || _input.length() === 0) && _input.compact(), md;
    }, md.digest = function () {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize,
        overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      for (var next, carry, bits = md.fullMessageLength[0] * 8, i = 0; i < md.fullMessageLength.length - 1; ++i) next = md.fullMessageLength[i + 1] * 8, carry = next / 4294967296 >>> 0, bits += carry, finalBlock.putInt32(bits >>> 0), bits = next >>> 0;
      finalBlock.putInt32(bits);
      for (var h = new Array(_h.length), i = 0; i < _h.length; ++i) h[i] = _h[i].slice(0);
      _update(h, _w, finalBlock);
      var rval = forge.util.createBuffer(),
        hlen;
      algorithm === "SHA-512" ? hlen = h.length : algorithm === "SHA-384" ? hlen = h.length - 2 : hlen = h.length - 4;
      for (var i = 0; i < hlen; ++i) rval.putInt32(h[i][0]), (i !== hlen - 1 || algorithm !== "SHA-512/224") && rval.putInt32(h[i][1]);
      return rval;
    }, md;
  };
  var _padding = null,
    _initialized = !1,
    _k = null,
    _states = null;
  function _init() {
    _padding = String.fromCharCode(128), _padding += forge.util.fillString(String.fromCharCode(0), 128), _k = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]], _states = {}, _states["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]], _states["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]], _states["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]], _states["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]], _initialized = !0;
  }
  __name(_init, "_init");
  function _update(s, w, bytes) {
    for (var t1_hi, t1_lo, t2_hi, t2_lo, s0_hi, s0_lo, s1_hi, s1_lo, ch_hi, ch_lo, maj_hi, maj_lo, a_hi, a_lo, b_hi, b_lo, c_hi, c_lo, d_hi, d_lo, e_hi, e_lo, f_hi, f_lo, g_hi, g_lo, h_hi, h_lo, i, hi, lo, w2, w7, w15, w16, len = bytes.length(); len >= 128;) {
      for (i = 0; i < 16; ++i) w[i][0] = bytes.getInt32() >>> 0, w[i][1] = bytes.getInt32() >>> 0;
      for (; i < 80; ++i) w2 = w[i - 2], hi = w2[0], lo = w2[1], t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0, t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0, w15 = w[i - 15], hi = w15[0], lo = w15[1], t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0, t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0, w7 = w[i - 7], w16 = w[i - 16], lo = t1_lo + w7[1] + t2_lo + w16[1], w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0, w[i][1] = lo >>> 0;
      for (a_hi = s[0][0], a_lo = s[0][1], b_hi = s[1][0], b_lo = s[1][1], c_hi = s[2][0], c_lo = s[2][1], d_hi = s[3][0], d_lo = s[3][1], e_hi = s[4][0], e_lo = s[4][1], f_hi = s[5][0], f_lo = s[5][1], g_hi = s[6][0], g_lo = s[6][1], h_hi = s[7][0], h_lo = s[7][1], i = 0; i < 80; ++i) s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0, s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0, ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0, ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0, s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0, s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0, maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0, maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0, lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1], t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0, t1_lo = lo >>> 0, lo = s0_lo + maj_lo, t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0, t2_lo = lo >>> 0, h_hi = g_hi, h_lo = g_lo, g_hi = f_hi, g_lo = f_lo, f_hi = e_hi, f_lo = e_lo, lo = d_lo + t1_lo, e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0, e_lo = lo >>> 0, d_hi = c_hi, d_lo = c_lo, c_hi = b_hi, c_lo = b_lo, b_hi = a_hi, b_lo = a_lo, lo = t1_lo + t2_lo, a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0, a_lo = lo >>> 0;
      lo = s[0][1] + a_lo, s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0, s[0][1] = lo >>> 0, lo = s[1][1] + b_lo, s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0, s[1][1] = lo >>> 0, lo = s[2][1] + c_lo, s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0, s[2][1] = lo >>> 0, lo = s[3][1] + d_lo, s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0, s[3][1] = lo >>> 0, lo = s[4][1] + e_lo, s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0, s[4][1] = lo >>> 0, lo = s[5][1] + f_lo, s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0, s[5][1] = lo >>> 0, lo = s[6][1] + g_lo, s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0, s[6][1] = lo >>> 0, lo = s[7][1] + h_lo, s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0, s[7][1] = lo >>> 0, len -= 128;
    }
  }
  __name(_update, "_update");
});
var require_asn1_validator = __commonJSMin(exports => {
  var forge = ta();
  df();
  var asn1 = forge.asn1;
  exports.privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: !1,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: !1,
      capture: "privateKey"
    }]
  };
  exports.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "subjectPublicKeyInfo",
    value: [{
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: !1,
        capture: "publicKeyOid"
      }]
    }, {
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: !1,
      composed: !0,
      captureBitStringValue: "ed25519PublicKey"
    }]
  };
});
var require_ed25519 = __commonJSMin((exports, module) => {
  var forge = ta();
  H_();
  Du();
  Nk();
  La();
  var asn1Validator = doe(),
    publicKeyValidator = asn1Validator.publicKeyValidator,
    privateKeyValidator = asn1Validator.privateKeyValidator;
  typeof BigInteger > "u" && (BigInteger = forge.jsbn.BigInteger);
  var BigInteger,
    ByteBuffer = forge.util.ByteBuffer,
    NativeBuffer = typeof Buffer > "u" ? Uint8Array : Buffer;
  forge.pki = forge.pki || {};
  module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
  var ed25519 = forge.ed25519;
  ed25519.constants = {};
  ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
  ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
  ed25519.constants.SEED_BYTE_LENGTH = 32;
  ed25519.constants.SIGN_BYTE_LENGTH = 64;
  ed25519.constants.HASH_BYTE_LENGTH = 64;
  ed25519.generateKeyPair = function (options) {
    options = options || {};
    var seed = options.seed;
    if (seed === void 0) seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);else if (typeof seed == "string") {
      if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
    } else if (!(seed instanceof Uint8Array)) throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
    seed = messageToNativeBuffer({
      message: seed,
      encoding: "binary"
    });
    for (var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH), sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH), i = 0; i < 32; ++i) sk[i] = seed[i];
    return crypto_sign_keypair(pk, sk), {
      publicKey: pk,
      privateKey: sk
    };
  };
  ed25519.privateKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [],
      valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      throw error.errors = errors, error;
    }
    var oid = forge.asn1.derToOid(capture.privateKeyOid),
      ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    var privateKey = capture.privateKey,
      privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
    return {
      privateKeyBytes: privateKeyBytes
    };
  };
  ed25519.publicKeyFromAsn1 = function (obj) {
    var capture = {},
      errors = [],
      valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      throw error.errors = errors, error;
    }
    var oid = forge.asn1.derToOid(capture.publicKeyOid),
      ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    var publicKeyBytes = capture.ed25519PublicKey;
    if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error("Key length is invalid.");
    return messageToNativeBuffer({
      message: publicKeyBytes,
      encoding: "binary"
    });
  };
  ed25519.publicKeyFromPrivateKey = function (options) {
    options = options || {};
    var privateKey = messageToNativeBuffer({
      message: options.privateKey,
      encoding: "binary"
    });
    if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    for (var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH), i = 0; i < pk.length; ++i) pk[i] = privateKey[32 + i];
    return pk;
  };
  ed25519.sign = function (options) {
    options = options || {};
    var msg = messageToNativeBuffer(options),
      privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
    if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
      var keyPair = ed25519.generateKeyPair({
        seed: privateKey
      });
      privateKey = keyPair.privateKey;
    } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    crypto_sign(signedMsg, msg, msg.length, privateKey);
    for (var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH), i = 0; i < sig.length; ++i) sig[i] = signedMsg[i];
    return sig;
  };
  ed25519.verify = function (options) {
    options = options || {};
    var msg = messageToNativeBuffer(options);
    if (options.signature === void 0) throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
    var sig = messageToNativeBuffer({
      message: options.signature,
      encoding: "binary"
    });
    if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
    var publicKey = messageToNativeBuffer({
      message: options.publicKey,
      encoding: "binary"
    });
    if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length),
      m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length),
      i;
    for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) sm[i] = sig[i];
    for (i = 0; i < msg.length; ++i) sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
  };
  function messageToNativeBuffer(options) {
    var message = options.message;
    if (message instanceof Uint8Array || message instanceof NativeBuffer) return message;
    var encoding = options.encoding;
    if (message === void 0) if (options.md) message = options.md.digest().getBytes(), encoding = "binary";else throw new TypeError('"options.message" or "options.md" not specified.');
    if (typeof message == "string" && !encoding) throw new TypeError('"options.encoding" must be "binary" or "utf8".');
    if (typeof message == "string") {
      if (typeof Buffer < "u") return Buffer.from(message, encoding);
      message = new ByteBuffer(message, encoding);
    } else if (!(message instanceof ByteBuffer)) throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
    for (var buffer = new NativeBuffer(message.length()), i = 0; i < buffer.length; ++i) buffer[i] = message.at(i);
    return buffer;
  }
  __name(messageToNativeBuffer, "messageToNativeBuffer");
  var gf0 = gf(),
    gf1 = gf([1]),
    D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
    D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
    X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
    Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
    L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]),
    I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
  function sha512(msg, msgLen) {
    var md = forge.md.sha512.create(),
      buffer = new ByteBuffer(msg);
    md.update(buffer.getBytes(msgLen), "binary");
    var hash = md.digest().getBytes();
    if (typeof Buffer < "u") return Buffer.from(hash, "binary");
    for (var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH), i = 0; i < 64; ++i) out[i] = hash.charCodeAt(i);
    return out;
  }
  __name(sha512, "sha512");
  function crypto_sign_keypair(pk, sk) {
    var p = [gf(), gf(), gf(), gf()],
      i,
      d = sha512(sk, 32);
    for (d[0] &= 248, d[31] &= 127, d[31] |= 64, scalarbase(p, d), pack(pk, p), i = 0; i < 32; ++i) sk[i + 32] = pk[i];
    return 0;
  }
  __name(crypto_sign_keypair, "crypto_sign_keypair");
  function crypto_sign(sm, m, n, sk) {
    var i,
      j,
      x = new Float64Array(64),
      p = [gf(), gf(), gf(), gf()],
      d = sha512(sk, 32);
    d[0] &= 248, d[31] &= 127, d[31] |= 64;
    var smlen = n + 64;
    for (i = 0; i < n; ++i) sm[64 + i] = m[i];
    for (i = 0; i < 32; ++i) sm[32 + i] = d[32 + i];
    var r = sha512(sm.subarray(32), n + 32);
    for (reduce(r), scalarbase(p, r), pack(sm, p), i = 32; i < 64; ++i) sm[i] = sk[i];
    var h = sha512(sm, n + 64);
    for (reduce(h), i = 32; i < 64; ++i) x[i] = 0;
    for (i = 0; i < 32; ++i) x[i] = r[i];
    for (i = 0; i < 32; ++i) for (j = 0; j < 32; j++) x[i + j] += h[i] * d[j];
    return modL(sm.subarray(32), x), smlen;
  }
  __name(crypto_sign, "crypto_sign");
  function crypto_sign_open(m, sm, n, pk) {
    var i,
      mlen,
      t = new NativeBuffer(32),
      p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];
    if (mlen = -1, n < 64 || unpackneg(q, pk)) return -1;
    for (i = 0; i < n; ++i) m[i] = sm[i];
    for (i = 0; i < 32; ++i) m[i + 32] = pk[i];
    var h = sha512(m, n);
    if (reduce(h), scalarmult(p, q, h), scalarbase(q, sm.subarray(32)), add(p, q), pack(t, p), n -= 64, crypto_verify_32(sm, 0, t, 0)) {
      for (i = 0; i < n; ++i) m[i] = 0;
      return -1;
    }
    for (i = 0; i < n; ++i) m[i] = sm[i + 64];
    return mlen = n, mlen;
  }
  __name(crypto_sign_open, "crypto_sign_open");
  function modL(r, x) {
    var carry, i, j, k;
    for (i = 63; i >= 32; --i) {
      for (carry = 0, j = i - 32, k = i - 12; j < k; ++j) x[j] += carry - 16 * x[i] * L[j - (i - 32)], carry = x[j] + 128 >> 8, x[j] -= carry * 256;
      x[j] += carry, x[i] = 0;
    }
    for (carry = 0, j = 0; j < 32; ++j) x[j] += carry - (x[31] >> 4) * L[j], carry = x[j] >> 8, x[j] &= 255;
    for (j = 0; j < 32; ++j) x[j] -= carry * L[j];
    for (i = 0; i < 32; ++i) x[i + 1] += x[i] >> 8, r[i] = x[i] & 255;
  }
  __name(modL, "modL");
  function reduce(r) {
    for (var x = new Float64Array(64), i = 0; i < 64; ++i) x[i] = r[i], r[i] = 0;
    modL(r, x);
  }
  __name(reduce, "reduce");
  function add(p, q) {
    var a = gf(),
      b = gf(),
      c = gf(),
      d = gf(),
      e = gf(),
      f = gf(),
      g = gf(),
      h = gf(),
      t = gf();
    Z(a, p[1], p[0]), Z(t, q[1], q[0]), M(a, a, t), A(b, p[0], p[1]), A(t, q[0], q[1]), M(b, b, t), M(c, p[3], q[3]), M(c, c, D2), M(d, p[2], q[2]), A(d, d, d), Z(e, b, a), Z(f, d, c), A(g, d, c), A(h, b, a), M(p[0], e, f), M(p[1], h, g), M(p[2], g, f), M(p[3], e, h);
  }
  __name(add, "add");
  function cswap(p, q, b) {
    for (var i = 0; i < 4; ++i) sel25519(p[i], q[i], b);
  }
  __name(cswap, "cswap");
  function pack(r, p) {
    var tx = gf(),
      ty = gf(),
      zi = gf();
    inv25519(zi, p[2]), M(tx, p[0], zi), M(ty, p[1], zi), pack25519(r, ty), r[31] ^= par25519(tx) << 7;
  }
  __name(pack, "pack");
  function pack25519(o, n) {
    var i,
      j,
      b,
      m = gf(),
      t = gf();
    for (i = 0; i < 16; ++i) t[i] = n[i];
    for (car25519(t), car25519(t), car25519(t), j = 0; j < 2; ++j) {
      for (m[0] = t[0] - 65517, i = 1; i < 15; ++i) m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1), m[i - 1] &= 65535;
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1), b = m[15] >> 16 & 1, m[14] &= 65535, sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) o[2 * i] = t[i] & 255, o[2 * i + 1] = t[i] >> 8;
  }
  __name(pack25519, "pack25519");
  function unpackneg(r, p) {
    var t = gf(),
      chk = gf(),
      num = gf(),
      den = gf(),
      den2 = gf(),
      den4 = gf(),
      den6 = gf();
    return set25519(r[2], gf1), unpack25519(r[1], p), S(num, r[1]), M(den, num, D), Z(num, num, r[2]), A(den, r[2], den), S(den2, den), S(den4, den2), M(den6, den4, den2), M(t, den6, num), M(t, t, den), pow2523(t, t), M(t, t, num), M(t, t, den), M(t, t, den), M(r[0], t, den), S(chk, r[0]), M(chk, chk, den), neq25519(chk, num) && M(r[0], r[0], I), S(chk, r[0]), M(chk, chk, den), neq25519(chk, num) ? -1 : (par25519(r[0]) === p[31] >> 7 && Z(r[0], gf0, r[0]), M(r[3], r[0], r[1]), 0);
  }
  __name(unpackneg, "unpackneg");
  function unpack25519(o, n) {
    var i;
    for (i = 0; i < 16; ++i) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    o[15] &= 32767;
  }
  __name(unpack25519, "unpack25519");
  function pow2523(o, i) {
    var c = gf(),
      a;
    for (a = 0; a < 16; ++a) c[a] = i[a];
    for (a = 250; a >= 0; --a) S(c, c), a !== 1 && M(c, c, i);
    for (a = 0; a < 16; ++a) o[a] = c[a];
  }
  __name(pow2523, "pow2523");
  function neq25519(a, b) {
    var c = new NativeBuffer(32),
      d = new NativeBuffer(32);
    return pack25519(c, a), pack25519(d, b), crypto_verify_32(c, 0, d, 0);
  }
  __name(neq25519, "neq25519");
  function crypto_verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
  }
  __name(crypto_verify_32, "crypto_verify_32");
  function vn(x, xi, y, yi, n) {
    var i,
      d = 0;
    for (i = 0; i < n; ++i) d |= x[xi + i] ^ y[yi + i];
    return (1 & d - 1 >>> 8) - 1;
  }
  __name(vn, "vn");
  function par25519(a) {
    var d = new NativeBuffer(32);
    return pack25519(d, a), d[0] & 1;
  }
  __name(par25519, "par25519");
  function scalarmult(p, q, s) {
    var b, i;
    for (set25519(p[0], gf0), set25519(p[1], gf1), set25519(p[2], gf1), set25519(p[3], gf0), i = 255; i >= 0; --i) b = s[i / 8 | 0] >> (i & 7) & 1, cswap(p, q, b), add(q, p), add(p, p), cswap(p, q, b);
  }
  __name(scalarmult, "scalarmult");
  function scalarbase(p, s) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X), set25519(q[1], Y), set25519(q[2], gf1), M(q[3], X, Y), scalarmult(p, q, s);
  }
  __name(scalarbase, "scalarbase");
  function set25519(r, a) {
    var i;
    for (i = 0; i < 16; i++) r[i] = a[i] | 0;
  }
  __name(set25519, "set25519");
  function inv25519(o, i) {
    var c = gf(),
      a;
    for (a = 0; a < 16; ++a) c[a] = i[a];
    for (a = 253; a >= 0; --a) S(c, c), a !== 2 && a !== 4 && M(c, c, i);
    for (a = 0; a < 16; ++a) o[a] = c[a];
  }
  __name(inv25519, "inv25519");
  function car25519(o) {
    var i,
      v,
      c = 1;
    for (i = 0; i < 16; ++i) v = o[i] + c + 65535, c = Math.floor(v / 65536), o[i] = v - c * 65536;
    o[0] += c - 1 + 37 * (c - 1);
  }
  __name(car25519, "car25519");
  function sel25519(p, q, b) {
    for (var t, c = ~(b - 1), i = 0; i < 16; ++i) t = c & (p[i] ^ q[i]), p[i] ^= t, q[i] ^= t;
  }
  __name(sel25519, "sel25519");
  function gf(init) {
    var i,
      r = new Float64Array(16);
    if (init) for (i = 0; i < init.length; ++i) r[i] = init[i];
    return r;
  }
  __name(gf, "gf");
  function A(o, a, b) {
    for (var i = 0; i < 16; ++i) o[i] = a[i] + b[i];
  }
  __name(A, "A");
  function Z(o, a, b) {
    for (var i = 0; i < 16; ++i) o[i] = a[i] - b[i];
  }
  __name(Z, "Z");
  function S(o, a) {
    M(o, a, a);
  }
  __name(S, "S");
  function M(o, a, b) {
    var v,
      c,
      t0 = 0,
      t1 = 0,
      t2 = 0,
      t3 = 0,
      t4 = 0,
      t5 = 0,
      t6 = 0,
      t7 = 0,
      t8 = 0,
      t9 = 0,
      t10 = 0,
      t11 = 0,
      t12 = 0,
      t13 = 0,
      t14 = 0,
      t15 = 0,
      t16 = 0,
      t17 = 0,
      t18 = 0,
      t19 = 0,
      t20 = 0,
      t21 = 0,
      t22 = 0,
      t23 = 0,
      t24 = 0,
      t25 = 0,
      t26 = 0,
      t27 = 0,
      t28 = 0,
      t29 = 0,
      t30 = 0,
      b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11],
      b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
    v = a[0], t0 += v * b0, t1 += v * b1, t2 += v * b2, t3 += v * b3, t4 += v * b4, t5 += v * b5, t6 += v * b6, t7 += v * b7, t8 += v * b8, t9 += v * b9, t10 += v * b10, t11 += v * b11, t12 += v * b12, t13 += v * b13, t14 += v * b14, t15 += v * b15, v = a[1], t1 += v * b0, t2 += v * b1, t3 += v * b2, t4 += v * b3, t5 += v * b4, t6 += v * b5, t7 += v * b6, t8 += v * b7, t9 += v * b8, t10 += v * b9, t11 += v * b10, t12 += v * b11, t13 += v * b12, t14 += v * b13, t15 += v * b14, t16 += v * b15, v = a[2], t2 += v * b0, t3 += v * b1, t4 += v * b2, t5 += v * b3, t6 += v * b4, t7 += v * b5, t8 += v * b6, t9 += v * b7, t10 += v * b8, t11 += v * b9, t12 += v * b10, t13 += v * b11, t14 += v * b12, t15 += v * b13, t16 += v * b14, t17 += v * b15, v = a[3], t3 += v * b0, t4 += v * b1, t5 += v * b2, t6 += v * b3, t7 += v * b4, t8 += v * b5, t9 += v * b6, t10 += v * b7, t11 += v * b8, t12 += v * b9, t13 += v * b10, t14 += v * b11, t15 += v * b12, t16 += v * b13, t17 += v * b14, t18 += v * b15, v = a[4], t4 += v * b0, t5 += v * b1, t6 += v * b2, t7 += v * b3, t8 += v * b4, t9 += v * b5, t10 += v * b6, t11 += v * b7, t12 += v * b8, t13 += v * b9, t14 += v * b10, t15 += v * b11, t16 += v * b12, t17 += v * b13, t18 += v * b14, t19 += v * b15, v = a[5], t5 += v * b0, t6 += v * b1, t7 += v * b2, t8 += v * b3, t9 += v * b4, t10 += v * b5, t11 += v * b6, t12 += v * b7, t13 += v * b8, t14 += v * b9, t15 += v * b10, t16 += v * b11, t17 += v * b12, t18 += v * b13, t19 += v * b14, t20 += v * b15, v = a[6], t6 += v * b0, t7 += v * b1, t8 += v * b2, t9 += v * b3, t10 += v * b4, t11 += v * b5, t12 += v * b6, t13 += v * b7, t14 += v * b8, t15 += v * b9, t16 += v * b10, t17 += v * b11, t18 += v * b12, t19 += v * b13, t20 += v * b14, t21 += v * b15, v = a[7], t7 += v * b0, t8 += v * b1, t9 += v * b2, t10 += v * b3, t11 += v * b4, t12 += v * b5, t13 += v * b6, t14 += v * b7, t15 += v * b8, t16 += v * b9, t17 += v * b10, t18 += v * b11, t19 += v * b12, t20 += v * b13, t21 += v * b14, t22 += v * b15, v = a[8], t8 += v * b0, t9 += v * b1, t10 += v * b2, t11 += v * b3, t12 += v * b4, t13 += v * b5, t14 += v * b6, t15 += v * b7, t16 += v * b8, t17 += v * b9, t18 += v * b10, t19 += v * b11, t20 += v * b12, t21 += v * b13, t22 += v * b14, t23 += v * b15, v = a[9], t9 += v * b0, t10 += v * b1, t11 += v * b2, t12 += v * b3, t13 += v * b4, t14 += v * b5, t15 += v * b6, t16 += v * b7, t17 += v * b8, t18 += v * b9, t19 += v * b10, t20 += v * b11, t21 += v * b12, t22 += v * b13, t23 += v * b14, t24 += v * b15, v = a[10], t10 += v * b0, t11 += v * b1, t12 += v * b2, t13 += v * b3, t14 += v * b4, t15 += v * b5, t16 += v * b6, t17 += v * b7, t18 += v * b8, t19 += v * b9, t20 += v * b10, t21 += v * b11, t22 += v * b12, t23 += v * b13, t24 += v * b14, t25 += v * b15, v = a[11], t11 += v * b0, t12 += v * b1, t13 += v * b2, t14 += v * b3, t15 += v * b4, t16 += v * b5, t17 += v * b6, t18 += v * b7, t19 += v * b8, t20 += v * b9, t21 += v * b10, t22 += v * b11, t23 += v * b12, t24 += v * b13, t25 += v * b14, t26 += v * b15, v = a[12], t12 += v * b0, t13 += v * b1, t14 += v * b2, t15 += v * b3, t16 += v * b4, t17 += v * b5, t18 += v * b6, t19 += v * b7, t20 += v * b8, t21 += v * b9, t22 += v * b10, t23 += v * b11, t24 += v * b12, t25 += v * b13, t26 += v * b14, t27 += v * b15, v = a[13], t13 += v * b0, t14 += v * b1, t15 += v * b2, t16 += v * b3, t17 += v * b4, t18 += v * b5, t19 += v * b6, t20 += v * b7, t21 += v * b8, t22 += v * b9, t23 += v * b10, t24 += v * b11, t25 += v * b12, t26 += v * b13, t27 += v * b14, t28 += v * b15, v = a[14], t14 += v * b0, t15 += v * b1, t16 += v * b2, t17 += v * b3, t18 += v * b4, t19 += v * b5, t20 += v * b6, t21 += v * b7, t22 += v * b8, t23 += v * b9, t24 += v * b10, t25 += v * b11, t26 += v * b12, t27 += v * b13, t28 += v * b14, t29 += v * b15, v = a[15], t15 += v * b0, t16 += v * b1, t17 += v * b2, t18 += v * b3, t19 += v * b4, t20 += v * b5, t21 += v * b6, t22 += v * b7, t23 += v * b8, t24 += v * b9, t25 += v * b10, t26 += v * b11, t27 += v * b12, t28 += v * b13, t29 += v * b14, t30 += v * b15, t0 += 38 * t16, t1 += 38 * t17, t2 += 38 * t18, t3 += 38 * t19, t4 += 38 * t20, t5 += 38 * t21, t6 += 38 * t22, t7 += 38 * t23, t8 += 38 * t24, t9 += 38 * t25, t10 += 38 * t26, t11 += 38 * t27, t12 += 38 * t28, t13 += 38 * t29, t14 += 38 * t30, c = 1, v = t0 + c + 65535, c = Math.floor(v / 65536), t0 = v - c * 65536, v = t1 + c + 65535, c = Math.floor(v / 65536), t1 = v - c * 65536, v = t2 + c + 65535, c = Math.floor(v / 65536), t2 = v - c * 65536, v = t3 + c + 65535, c = Math.floor(v / 65536), t3 = v - c * 65536, v = t4 + c + 65535, c = Math.floor(v / 65536), t4 = v - c * 65536, v = t5 + c + 65535, c = Math.floor(v / 65536), t5 = v - c * 65536, v = t6 + c + 65535, c = Math.floor(v / 65536), t6 = v - c * 65536, v = t7 + c + 65535, c = Math.floor(v / 65536), t7 = v - c * 65536, v = t8 + c + 65535, c = Math.floor(v / 65536), t8 = v - c * 65536, v = t9 + c + 65535, c = Math.floor(v / 65536), t9 = v - c * 65536, v = t10 + c + 65535, c = Math.floor(v / 65536), t10 = v - c * 65536, v = t11 + c + 65535, c = Math.floor(v / 65536), t11 = v - c * 65536, v = t12 + c + 65535, c = Math.floor(v / 65536), t12 = v - c * 65536, v = t13 + c + 65535, c = Math.floor(v / 65536), t13 = v - c * 65536, v = t14 + c + 65535, c = Math.floor(v / 65536), t14 = v - c * 65536, v = t15 + c + 65535, c = Math.floor(v / 65536), t15 = v - c * 65536, t0 += c - 1 + 37 * (c - 1), c = 1, v = t0 + c + 65535, c = Math.floor(v / 65536), t0 = v - c * 65536, v = t1 + c + 65535, c = Math.floor(v / 65536), t1 = v - c * 65536, v = t2 + c + 65535, c = Math.floor(v / 65536), t2 = v - c * 65536, v = t3 + c + 65535, c = Math.floor(v / 65536), t3 = v - c * 65536, v = t4 + c + 65535, c = Math.floor(v / 65536), t4 = v - c * 65536, v = t5 + c + 65535, c = Math.floor(v / 65536), t5 = v - c * 65536, v = t6 + c + 65535, c = Math.floor(v / 65536), t6 = v - c * 65536, v = t7 + c + 65535, c = Math.floor(v / 65536), t7 = v - c * 65536, v = t8 + c + 65535, c = Math.floor(v / 65536), t8 = v - c * 65536, v = t9 + c + 65535, c = Math.floor(v / 65536), t9 = v - c * 65536, v = t10 + c + 65535, c = Math.floor(v / 65536), t10 = v - c * 65536, v = t11 + c + 65535, c = Math.floor(v / 65536), t11 = v - c * 65536, v = t12 + c + 65535, c = Math.floor(v / 65536), t12 = v - c * 65536, v = t13 + c + 65535, c = Math.floor(v / 65536), t13 = v - c * 65536, v = t14 + c + 65535, c = Math.floor(v / 65536), t14 = v - c * 65536, v = t15 + c + 65535, c = Math.floor(v / 65536), t15 = v - c * 65536, t0 += c - 1 + 37 * (c - 1), o[0] = t0, o[1] = t1, o[2] = t2, o[3] = t3, o[4] = t4, o[5] = t5, o[6] = t6, o[7] = t7, o[8] = t8, o[9] = t9, o[10] = t10, o[11] = t11, o[12] = t12, o[13] = t13, o[14] = t14, o[15] = t15;
  }
  __name(M, "M");
});
var require_kem = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  Du();
  H_();
  module.exports = forge.kem = forge.kem || {};
  var BigInteger = forge.jsbn.BigInteger;
  forge.kem.rsa = {};
  forge.kem.rsa.create = function (kdf, options) {
    options = options || {};
    var prng = options.prng || forge.random,
      kem = {};
    return kem.encrypt = function (publicKey, keyLength) {
      var byteLength = Math.ceil(publicKey.n.bitLength() / 8),
        r;
      do r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n); while (r.compareTo(BigInteger.ONE) <= 0);
      r = forge.util.hexToBytes(r.toString(16));
      var zeros = byteLength - r.length;
      zeros > 0 && (r = forge.util.fillString(String.fromCharCode(0), zeros) + r);
      var encapsulation = publicKey.encrypt(r, "NONE"),
        key = kdf.generate(r, keyLength);
      return {
        encapsulation: encapsulation,
        key: key
      };
    }, kem.decrypt = function (privateKey, encapsulation, keyLength) {
      var r = privateKey.decrypt(encapsulation, "NONE");
      return kdf.generate(r, keyLength);
    }, kem;
  };
  forge.kem.kdf1 = function (md, digestLength) {
    _createKDF(this, md, 0, digestLength || md.digestLength);
  };
  forge.kem.kdf2 = function (md, digestLength) {
    _createKDF(this, md, 1, digestLength || md.digestLength);
  };
  function _createKDF(kdf, md, counterStart, digestLength) {
    kdf.generate = function (x, length) {
      for (var key = new forge.util.ByteBuffer(), k = Math.ceil(length / digestLength) + counterStart, c = new forge.util.ByteBuffer(), i = counterStart; i < k; ++i) {
        c.putInt32(i), md.start(), md.update(x + c.getBytes());
        var hash = md.digest();
        key.putBytes(hash.getBytes(digestLength));
      }
      return key.truncate(key.length() - length), key.getBytes();
    };
  }
  __name(_createKDF, "_createKDF");
});
var require_log = __commonJSMin((exports, module) => {
  var forge = ta();
  La();
  module.exports = forge.log = forge.log || {};
  forge.log.levels = ["none", "error", "warning", "info", "debug", "verbose", "max"];
  var sLevelInfo = {},
    sLoggers = [],
    sConsoleLogger = null;
  forge.log.LEVEL_LOCKED = 2;
  forge.log.NO_LEVEL_CHECK = 4;
  forge.log.INTERPOLATE = 8;
  for (i = 0; i < forge.log.levels.length; ++i) level = forge.log.levels[i], sLevelInfo[level] = {
    index: i,
    name: level.toUpperCase()
  };
  var level, i;
  forge.log.logMessage = function (message) {
    for (var messageLevelIndex = sLevelInfo[message.level].index, i = 0; i < sLoggers.length; ++i) {
      var logger = sLoggers[i];
      if (logger.flags & forge.log.NO_LEVEL_CHECK) logger.f(message);else {
        var loggerLevelIndex = sLevelInfo[logger.level].index;
        messageLevelIndex <= loggerLevelIndex && logger.f(logger, message);
      }
    }
  };
  forge.log.prepareStandard = function (message) {
    "standard" in message || (message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message);
  };
  forge.log.prepareFull = function (message) {
    if (!("full" in message)) {
      var args = [message.message];
      args = args.concat([]), message.full = forge.util.format.apply(this, args);
    }
  };
  forge.log.prepareStandardFull = function (message) {
    "standardFull" in message || (forge.log.prepareStandard(message), message.standardFull = message.standard);
  };
  for (levels = ["error", "warning", "info", "debug", "verbose"], i = 0; i < levels.length; ++i) (function (level) {
    forge.log[level] = function (category, message) {
      var args = Array.prototype.slice.call(arguments).slice(2),
        msg = {
          timestamp: new Date(),
          level: level,
          category: category,
          message: message,
          arguments: args
        };
      forge.log.logMessage(msg);
    };
  })(levels[i]);
  var levels, i;
  forge.log.makeLogger = function (logFunction) {
    var logger = {
      flags: 0,
      f: logFunction
    };
    return forge.log.setLevel(logger, "none"), logger;
  };
  forge.log.setLevel = function (logger, level) {
    var rval = !1;
    if (logger && !(logger.flags & forge.log.LEVEL_LOCKED)) for (var i = 0; i < forge.log.levels.length; ++i) {
      var aValidLevel = forge.log.levels[i];
      if (level == aValidLevel) {
        logger.level = level, rval = !0;
        break;
      }
    }
    return rval;
  };
  forge.log.lock = function (logger, lock) {
    typeof lock > "u" || lock ? logger.flags |= forge.log.LEVEL_LOCKED : logger.flags &= ~forge.log.LEVEL_LOCKED;
  };
  forge.log.addLogger = function (logger) {
    sLoggers.push(logger);
  };
  typeof console < "u" && "log" in console ? (console.error && console.warn && console.info && console.debug ? (levelHandlers = {
    error: console.error,
    warning: console.warn,
    info: console.info,
    debug: console.debug,
    verbose: console.debug
  }, f = __name(function (logger, message) {
    forge.log.prepareStandard(message);
    var handler = levelHandlers[message.level],
      args = [message.standard];
    args = args.concat(message.arguments.slice()), handler.apply(console, args);
  }, "f"), logger = forge.log.makeLogger(f)) : (f = __name(function (logger, message) {
    forge.log.prepareStandardFull(message), console.log(message.standardFull);
  }, "f"), logger = forge.log.makeLogger(f)), forge.log.setLevel(logger, "debug"), forge.log.addLogger(logger), sConsoleLogger = logger) : console = {
    log: function () {}
  };
  var logger, levelHandlers, f;
  sConsoleLogger !== null && typeof window < "u" && window.location && (query = new URL(window.location.href).searchParams, query.has("console.level") && forge.log.setLevel(sConsoleLogger, query.get("console.level").slice(-1)[0]), query.has("console.lock") && (lock = query.get("console.lock").slice(-1)[0], lock == "true" && forge.log.lock(sConsoleLogger)));
  var query, lock;
  forge.log.consoleLogger = sConsoleLogger;
});
var require_md_all = __commonJSMin((exports, module) => {
  module.exports = Qf();
  LE();
  r3();
  rk();
  Nk();
});
var require_pkcs7 = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  df();
  q_();
  b1();
  dh();
  gk();
  Du();
  La();
  WE();
  var asn1 = forge.asn1,
    p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
  p7.messageFromPem = function (pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PKCS7") {
      var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
      throw error.headerType = msg.type, error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
    var obj = asn1.fromDer(msg.body);
    return p7.messageFromAsn1(obj);
  };
  p7.messageToPem = function (msg, maxline) {
    var pemObj = {
      type: "PKCS7",
      body: asn1.toDer(msg.toAsn1()).getBytes()
    };
    return forge.pem.encode(pemObj, {
      maxline: maxline
    });
  };
  p7.messageFromAsn1 = function (obj) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
      throw error.errors = errors, error;
    }
    var contentType = asn1.derToOid(capture.contentType),
      msg;
    switch (contentType) {
      case forge.pki.oids.envelopedData:
        msg = p7.createEnvelopedData();
        break;
      case forge.pki.oids.encryptedData:
        msg = p7.createEncryptedData();
        break;
      case forge.pki.oids.signedData:
        msg = p7.createSignedData();
        break;
      default:
        throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
    }
    return msg.fromAsn1(capture.content.value[0]), msg;
  };
  p7.createSignedData = function () {
    var msg = null;
    return msg = {
      type: forge.pki.oids.signedData,
      version: 1,
      certificates: [],
      crls: [],
      signers: [],
      digestAlgorithmIdentifiers: [],
      contentInfo: null,
      signerInfos: [],
      fromAsn1: function (obj) {
        if (_fromAsn1(msg, obj, p7.asn1.signedDataValidator), msg.certificates = [], msg.crls = [], msg.digestAlgorithmIdentifiers = [], msg.contentInfo = null, msg.signerInfos = [], msg.rawCapture.certificates) for (var certs = msg.rawCapture.certificates.value, i = 0; i < certs.length; ++i) msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
      },
      toAsn1: function () {
        msg.contentInfo || msg.sign();
        for (var certs = [], i = 0; i < msg.certificates.length; ++i) certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
        var crls = [],
          signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, msg.digestAlgorithmIdentifiers), msg.contentInfo])]);
        return certs.length > 0 && signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, certs)), crls.length > 0 && signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, crls)), signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, msg.signerInfos)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(msg.type).getBytes()), signedData]);
      },
      addSigner: function (signer) {
        var issuer = signer.issuer,
          serialNumber = signer.serialNumber;
        if (signer.certificate) {
          var cert = signer.certificate;
          typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), issuer = cert.issuer.attributes, serialNumber = cert.serialNumber;
        }
        var key = signer.key;
        if (!key) throw new Error("Could not add PKCS#7 signer; no private key specified.");
        typeof key == "string" && (key = forge.pki.privateKeyFromPem(key));
        var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
        switch (digestAlgorithm) {
          case forge.pki.oids.sha1:
          case forge.pki.oids.sha256:
          case forge.pki.oids.sha384:
          case forge.pki.oids.sha512:
          case forge.pki.oids.md5:
            break;
          default:
            throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
        }
        var authenticatedAttributes = signer.authenticatedAttributes || [];
        if (authenticatedAttributes.length > 0) {
          for (var contentType = !1, messageDigest = !1, i = 0; i < authenticatedAttributes.length; ++i) {
            var attr = authenticatedAttributes[i];
            if (!contentType && attr.type === forge.pki.oids.contentType) {
              if (contentType = !0, messageDigest) break;
              continue;
            }
            if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
              if (messageDigest = !0, contentType) break;
              continue;
            }
          }
          if (!contentType || !messageDigest) throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
        }
        msg.signers.push({
          key: key,
          version: 1,
          issuer: issuer,
          serialNumber: serialNumber,
          digestAlgorithm: digestAlgorithm,
          signatureAlgorithm: forge.pki.oids.rsaEncryption,
          signature: null,
          authenticatedAttributes: authenticatedAttributes,
          unauthenticatedAttributes: []
        });
      },
      sign: function (options) {
        if (options = options || {}, (typeof msg.content != "object" || msg.contentInfo === null) && (msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(forge.pki.oids.data).getBytes())]), "content" in msg)) {
          var content;
          msg.content instanceof forge.util.ByteBuffer ? content = msg.content.bytes() : typeof msg.content == "string" && (content = forge.util.encodeUtf8(msg.content)), options.detached ? msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, content) : msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, content)]));
        }
        if (msg.signers.length !== 0) {
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        }
      },
      verify: function () {
        throw new Error("PKCS#7 signature verification not yet implemented.");
      },
      addCertificate: function (cert) {
        typeof cert == "string" && (cert = forge.pki.certificateFromPem(cert)), msg.certificates.push(cert);
      },
      addCertificateRevokationList: function (crl) {
        throw new Error("PKCS#7 CRL support not yet implemented.");
      }
    }, msg;
    function addDigestAlgorithmIds() {
      for (var mds = {}, i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i],
          oid = signer.digestAlgorithm;
        oid in mds || (mds[oid] = forge.md[forge.pki.oids[oid]].create()), signer.authenticatedAttributes.length === 0 ? signer.md = mds[oid] : signer.md = forge.md[forge.pki.oids[oid]].create();
      }
      msg.digestAlgorithmIdentifiers = [];
      for (var oid in mds) msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(oid).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]));
      return mds;
    }
    __name(addDigestAlgorithmIds, "addDigestAlgorithmIds");
    function addSignerInfos(mds) {
      var content;
      if (msg.detachedContent ? content = msg.detachedContent : (content = msg.contentInfo.value[1], content = content.value[0]), !content) throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
      var contentType = asn1.derToOid(msg.contentInfo.value[0].value),
        bytes = asn1.toDer(content);
      bytes.getByte(), asn1.getBerValueLength(bytes), bytes = bytes.getBytes();
      for (var oid in mds) mds[oid].start().update(bytes);
      for (var signingTime = new Date(), i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i];
        if (signer.authenticatedAttributes.length === 0) {
          if (contentType !== forge.pki.oids.data) throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
        } else {
          signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, []);
          for (var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, []), ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
            var attr = signer.authenticatedAttributes[ai];
            attr.type === forge.pki.oids.messageDigest ? attr.value = mds[signer.digestAlgorithm].digest() : attr.type === forge.pki.oids.signingTime && (attr.value || (attr.value = signingTime)), attrsAsn1.value.push(_attributeToAsn1(attr)), signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
          }
          bytes = asn1.toDer(attrsAsn1).getBytes(), signer.md.start().update(bytes);
        }
        signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
      }
      msg.signerInfos = _signersToAsn1(msg.signers);
    }
    __name(addSignerInfos, "addSignerInfos");
  };
  p7.createEncryptedData = function () {
    var msg = null;
    return msg = {
      type: forge.pki.oids.encryptedData,
      version: 0,
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function (obj) {
        _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
      },
      decrypt: function (key) {
        key !== void 0 && (msg.encryptedContent.key = key), _decryptContent(msg);
      }
    }, msg;
  };
  p7.createEnvelopedData = function () {
    var msg = null;
    return msg = {
      type: forge.pki.oids.envelopedData,
      version: 0,
      recipients: [],
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function (obj) {
        var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
        msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
      },
      toAsn1: function () {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(msg.type).getBytes()), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(msg.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, _recipientsToAsn1(msg.recipients)), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, _encryptedContentToAsn1(msg.encryptedContent))])])]);
      },
      findRecipient: function (cert) {
        for (var sAttr = cert.issuer.attributes, i = 0; i < msg.recipients.length; ++i) {
          var r = msg.recipients[i],
            rAttr = r.issuer;
          if (r.serialNumber === cert.serialNumber && rAttr.length === sAttr.length) {
            for (var match = !0, j = 0; j < sAttr.length; ++j) if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
              match = !1;
              break;
            }
            if (match) return r;
          }
        }
        return null;
      },
      decrypt: function (recipient, privKey) {
        if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) switch (recipient.encryptedContent.algorithm) {
          case forge.pki.oids.rsaEncryption:
          case forge.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge.util.createBuffer(key);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
        _decryptContent(msg);
      },
      addRecipient: function (cert) {
        msg.recipients.push({
          version: 0,
          issuer: cert.issuer.attributes,
          serialNumber: cert.serialNumber,
          encryptedContent: {
            algorithm: forge.pki.oids.rsaEncryption,
            key: cert.publicKey
          }
        });
      },
      encrypt: function (key, cipher) {
        if (msg.encryptedContent.content === void 0) {
          cipher = cipher || msg.encryptedContent.algorithm, key = key || msg.encryptedContent.key;
          var keyLen, ivLen, ciphFn;
          switch (cipher) {
            case forge.pki.oids["aes128-CBC"]:
              keyLen = 16, ivLen = 16, ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes192-CBC"]:
              keyLen = 24, ivLen = 16, ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes256-CBC"]:
              keyLen = 32, ivLen = 16, ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["des-EDE3-CBC"]:
              keyLen = 24, ivLen = 8, ciphFn = forge.des.createEncryptionCipher;
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + cipher);
          }
          if (key === void 0) key = forge.util.createBuffer(forge.random.getBytes(keyLen));else if (key.length() != keyLen) throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
          msg.encryptedContent.algorithm = cipher, msg.encryptedContent.key = key, msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
          var ciph = ciphFn(key);
          if (ciph.start(msg.encryptedContent.parameter.copy()), ciph.update(msg.content), !ciph.finish()) throw new Error("Symmetric encryption failed.");
          msg.encryptedContent.content = ciph.output;
        }
        for (var i = 0; i < msg.recipients.length; ++i) {
          var recipient = msg.recipients[i];
          if (recipient.encryptedContent.content === void 0) switch (recipient.encryptedContent.algorithm) {
            case forge.pki.oids.rsaEncryption:
              recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
          }
        }
      }
    }, msg;
  };
  function _recipientFromAsn1(obj) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
      throw error.errors = errors, error;
    }
    return {
      version: capture.version.charCodeAt(0),
      issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
      serialNumber: forge.util.createBuffer(capture.serial).toHex(),
      encryptedContent: {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: capture.encParameter ? capture.encParameter.value : void 0,
        content: capture.encKey
      }
    };
  }
  __name(_recipientFromAsn1, "_recipientFromAsn1");
  function _recipientToAsn1(obj) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [forge.pki.distinguishedNameToAsn1({
      attributes: obj.issuer
    }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, obj.encryptedContent.content)]);
  }
  __name(_recipientToAsn1, "_recipientToAsn1");
  function _recipientsFromAsn1(infos) {
    for (var ret = [], i = 0; i < infos.length; ++i) ret.push(_recipientFromAsn1(infos[i]));
    return ret;
  }
  __name(_recipientsFromAsn1, "_recipientsFromAsn1");
  function _recipientsToAsn1(recipients) {
    for (var ret = [], i = 0; i < recipients.length; ++i) ret.push(_recipientToAsn1(recipients[i]));
    return ret;
  }
  __name(_recipientsToAsn1, "_recipientsToAsn1");
  function _signerToAsn1(obj) {
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, asn1.integerToDer(obj.version).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [forge.pki.distinguishedNameToAsn1({
      attributes: obj.issuer
    }), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, !1, forge.util.hexToBytes(obj.serialNumber))]), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(obj.digestAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])]);
    if (obj.authenticatedAttributesAsn1 && rval.value.push(obj.authenticatedAttributesAsn1), rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(obj.signatureAlgorithm).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, !1, "")])), rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, obj.signature)), obj.unauthenticatedAttributes.length > 0) {
      for (var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, !0, []), i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
        var attr = obj.unauthenticatedAttributes[i];
        attrsAsn1.values.push(_attributeToAsn1(attr));
      }
      rval.value.push(attrsAsn1);
    }
    return rval;
  }
  __name(_signerToAsn1, "_signerToAsn1");
  function _signersToAsn1(signers) {
    for (var ret = [], i = 0; i < signers.length; ++i) ret.push(_signerToAsn1(signers[i]));
    return ret;
  }
  __name(_signersToAsn1, "_signersToAsn1");
  function _attributeToAsn1(attr) {
    var value;
    if (attr.type === forge.pki.oids.contentType) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.value).getBytes());else if (attr.type === forge.pki.oids.messageDigest) value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, attr.value.bytes());else if (attr.type === forge.pki.oids.signingTime) {
      var jan_1_1950 = new Date("1950-01-01T00:00:00Z"),
        jan_1_2050 = new Date("2050-01-01T00:00:00Z"),
        date = attr.value;
      if (typeof date == "string") {
        var timestamp = Date.parse(date);
        isNaN(timestamp) ? date.length === 13 ? date = asn1.utcTimeToDate(date) : date = asn1.generalizedTimeToDate(date) : date = new Date(timestamp);
      }
      date >= jan_1_1950 && date < jan_1_2050 ? value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, !1, asn1.dateToUtcTime(date)) : value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, !1, asn1.dateToGeneralizedTime(date));
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(attr.type).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, !0, [value])]);
  }
  __name(_attributeToAsn1, "_attributeToAsn1");
  function _encryptedContentToAsn1(ec) {
    return [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(forge.pki.oids.data).getBytes()), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, !1, asn1.oidToDer(ec.algorithm).getBytes()), ec.parameter ? asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, ec.parameter.getBytes()) : void 0]), asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, !0, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, !1, ec.content.getBytes())])];
  }
  __name(_encryptedContentToAsn1, "_encryptedContentToAsn1");
  function _fromAsn1(msg, obj, validator) {
    var capture = {},
      errors = [];
    if (!asn1.validate(obj, validator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
      throw error.errors = error, error;
    }
    var contentType = asn1.derToOid(capture.contentType);
    if (contentType !== forge.pki.oids.data) throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
    if (capture.encryptedContent) {
      var content = "";
      if (forge.util.isArray(capture.encryptedContent)) for (var i = 0; i < capture.encryptedContent.length; ++i) {
        if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        content += capture.encryptedContent[i].value;
      } else content = capture.encryptedContent;
      msg.encryptedContent = {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: forge.util.createBuffer(capture.encParameter.value),
        content: forge.util.createBuffer(content)
      };
    }
    if (capture.content) {
      var content = "";
      if (forge.util.isArray(capture.content)) for (var i = 0; i < capture.content.length; ++i) {
        if (capture.content[i].type !== asn1.Type.OCTETSTRING) throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        content += capture.content[i].value;
      } else content = capture.content;
      msg.content = forge.util.createBuffer(content);
    }
    return msg.version = capture.version.charCodeAt(0), msg.rawCapture = capture, capture;
  }
  __name(_fromAsn1, "_fromAsn1");
  function _decryptContent(msg) {
    if (msg.encryptedContent.key === void 0) throw new Error("Symmetric key not available.");
    if (msg.content === void 0) {
      var ciph;
      switch (msg.encryptedContent.algorithm) {
        case forge.pki.oids["aes128-CBC"]:
        case forge.pki.oids["aes192-CBC"]:
        case forge.pki.oids["aes256-CBC"]:
          ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
          break;
        case forge.pki.oids.desCBC:
        case forge.pki.oids["des-EDE3-CBC"]:
          ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
          break;
        default:
          throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
      }
      if (ciph.start(msg.encryptedContent.parameter), ciph.update(msg.encryptedContent.content), !ciph.finish()) throw new Error("Symmetric decryption failed.");
      msg.content = ciph.output;
    }
  }
  __name(_decryptContent, "_decryptContent");
});
var require_ssh = __commonJSMin((exports, module) => {
  var forge = ta();
  x1();
  Z5();
  LE();
  r3();
  La();
  var ssh = module.exports = forge.ssh = forge.ssh || {};
  ssh.privateKeyToPutty = function (privateKey, passphrase, comment) {
    comment = comment || "", passphrase = passphrase || "";
    var algorithm = "ssh-rsa",
      encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc",
      ppk = "PuTTY-User-Key-File-2: " + algorithm + `\r
`;
    ppk += "Encryption: " + encryptionAlgorithm + `\r
`, ppk += "Comment: " + comment + `\r
`;
    var pubbuffer = forge.util.createBuffer();
    _addStringToBuffer(pubbuffer, algorithm), _addBigIntegerToBuffer(pubbuffer, privateKey.e), _addBigIntegerToBuffer(pubbuffer, privateKey.n);
    var pub = forge.util.encode64(pubbuffer.bytes(), 64),
      length = Math.floor(pub.length / 66) + 1;
    ppk += "Public-Lines: " + length + `\r
`, ppk += pub;
    var privbuffer = forge.util.createBuffer();
    _addBigIntegerToBuffer(privbuffer, privateKey.d), _addBigIntegerToBuffer(privbuffer, privateKey.p), _addBigIntegerToBuffer(privbuffer, privateKey.q), _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
    var priv;
    if (!passphrase) priv = forge.util.encode64(privbuffer.bytes(), 64);else {
      var encLen = privbuffer.length() + 16 - 1;
      encLen -= encLen % 16;
      var padding = _sha1(privbuffer.bytes());
      padding.truncate(padding.length() - encLen + privbuffer.length()), privbuffer.putBuffer(padding);
      var aeskey = forge.util.createBuffer();
      aeskey.putBuffer(_sha1("\0\0\0\0", passphrase)), aeskey.putBuffer(_sha1("\0\0\0", passphrase));
      var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
      cipher.start(forge.util.createBuffer().fillWithByte(0, 16)), cipher.update(privbuffer.copy()), cipher.finish();
      var encrypted = cipher.output;
      encrypted.truncate(16), priv = forge.util.encode64(encrypted.bytes(), 64);
    }
    length = Math.floor(priv.length / 66) + 1, ppk += `\r
Private-Lines: ` + length + `\r
`, ppk += priv;
    var mackey = _sha1("putty-private-key-file-mac-key", passphrase),
      macbuffer = forge.util.createBuffer();
    _addStringToBuffer(macbuffer, algorithm), _addStringToBuffer(macbuffer, encryptionAlgorithm), _addStringToBuffer(macbuffer, comment), macbuffer.putInt32(pubbuffer.length()), macbuffer.putBuffer(pubbuffer), macbuffer.putInt32(privbuffer.length()), macbuffer.putBuffer(privbuffer);
    var hmac = forge.hmac.create();
    return hmac.start("sha1", mackey), hmac.update(macbuffer.bytes()), ppk += `\r
Private-MAC: ` + hmac.digest().toHex() + `\r
`, ppk;
  };
  ssh.publicKeyToOpenSSH = function (key, comment) {
    var type = "ssh-rsa";
    comment = comment || "";
    var buffer = forge.util.createBuffer();
    return _addStringToBuffer(buffer, type), _addBigIntegerToBuffer(buffer, key.e), _addBigIntegerToBuffer(buffer, key.n), type + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
  };
  ssh.privateKeyToOpenSSH = function (privateKey, passphrase) {
    return passphrase ? forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {
      legacy: !0,
      algorithm: "aes128"
    }) : forge.pki.privateKeyToPem(privateKey);
  };
  ssh.getPublicKeyFingerprint = function (key, options) {
    options = options || {};
    var md = options.md || forge.md.md5.create(),
      type = "ssh-rsa",
      buffer = forge.util.createBuffer();
    _addStringToBuffer(buffer, type), _addBigIntegerToBuffer(buffer, key.e), _addBigIntegerToBuffer(buffer, key.n), md.start(), md.update(buffer.getBytes());
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      return options.delimiter ? hex.match(/.{2}/g).join(options.delimiter) : hex;
    } else {
      if (options.encoding === "binary") return digest.getBytes();
      if (options.encoding) throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  function _addBigIntegerToBuffer(buffer, val) {
    var hexVal = val.toString(16);
    hexVal[0] >= "8" && (hexVal = "00" + hexVal);
    var bytes = forge.util.hexToBytes(hexVal);
    buffer.putInt32(bytes.length), buffer.putBytes(bytes);
  }
  __name(_addBigIntegerToBuffer, "_addBigIntegerToBuffer");
  function _addStringToBuffer(buffer, val) {
    buffer.putInt32(val.length), buffer.putString(val);
  }
  __name(_addStringToBuffer, "_addStringToBuffer");
  function _sha1() {
    for (var sha = forge.md.sha1.create(), num = arguments.length, i = 0; i < num; ++i) sha.update(arguments[i]);
    return sha.digest();
  }
  __name(_sha1, "_sha1");
});
var require_lib = __commonJSMin((exports, module) => {
  module.exports = ta();
  x1();
  aoe();
  df();
  wE();
  q_();
  Soe();
  Z5();
  Poe();
  Loe();
  Doe();
  _k();
  BE();
  dh();
  fk();
  xk();
  Foe();
  Ek();
  pk();
  nk();
  VE();
  Du();
  ok();
  qoe();
  Ak();
  La();
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "@roamhq/mac-ca",
    version: "1.0.7",
    description: "Get Mac OS Root certificates",
    main: "index.js",
    repository: {
      type: "git",
      url: "https://github.com/WonderInventions/mac-ca.git"
    },
    scripts: {
      test: 'echo "Error: no test specified" && exit 1',
      lint: "eslint ."
    },
    license: "BSD-3-Clause",
    dependencies: {
      "node-forge": "^1.3.1"
    },
    devDependencies: {
      eslint: "^8.22.0"
    }
  };
});
var require_formatter = __commonJSMin((exports, module) => {
  var forge = Hoe(),
    packageJson = $oe(),
    formats = module.exports.validFormats = {
      der: 0,
      pem: 1,
      txt: 2,
      asn1: 3
    };
  function myASN(pem) {
    let der = forge.pki.pemToDer(pem),
      asn1 = forge.asn1,
      crt = asn1.fromDer(der.data.toString("binary")).value[0].value,
      serial = crt[0],
      hasSerial = serial.tagClass === asn1.Class.CONTEXT_SPECIFIC && serial.type === 0 && serial.constructed,
      slicedCrt = crt.slice(hasSerial);
    return {
      serial: slicedCrt[0],
      issuer: slicedCrt[2],
      valid: slicedCrt[3],
      subject: slicedCrt[4]
    };
  }
  __name(myASN, "myASN");
  function txtFormat(pem) {
    let crt = myASN(pem),
      d = new Date(),
      subject = crt.subject.value.map(rdn => rdn.value[0].value[1].value).join("/"),
      valid = crt.valid.value.map(date => date.value).join(" - "),
      savedTime = d.toTimeString().replace(/\s*\(.*\)\s*/, "");
    return [`Subject	${subject}`, `Valid	${valid}`, `Saved	${d.toLocaleDateString()} ${savedTime} by ${packageJson.name}@${packageJson.version}`, String(pem)].join(`
`);
  }
  __name(txtFormat, "txtFormat");
  module.exports.transform = function (format) {
    return function (pem) {
      try {
        switch (format) {
          case formats.der:
            return forge.pki.pemToDer(pem);
          case formats.pem:
            return pem;
          case formats.txt:
            return txtFormat(pem);
          case formats.asn1:
            return myASN(pem);
          default:
            return forge.pki.certificateFromPem(pem);
        }
      } catch {
        return;
      }
    };
  };
});
var require_mac_ca = __commonJSMin((exports, module) => {
  var https = require("https"),
    formatter = zoe();
  if (process.platform !== "darwin") module.exports.all = () => [], module.exports.each = () => {};else {
    let duplicated = function (cert, index, arr) {
      return arr.indexOf(cert) === index;
    };
    duplicated = c, __name(duplicated, "duplicated");
    let child_process = require("child_process"),
      splitPattern = /(?=-----BEGIN\sCERTIFICATE-----)/g,
      systemRootCertsPath = "/System/Library/Keychains/SystemRootCertificates.keychain",
      args = ["find-certificate", "-a", "-p"],
      allTrusted = child_process.spawnSync("/usr/bin/security", args).stdout.toString().split(splitPattern),
      allRoot = child_process.spawnSync("/usr/bin/security", args.concat(systemRootCertsPath)).stdout.toString().split(splitPattern);
    https.globalAgent.options.ca = https.globalAgent.options.ca || [];
    let ca = https.globalAgent.options.ca,
      all = allTrusted.concat(allRoot);
    all.filter(duplicated).forEach(cert => ca.push(cert)), module.exports.der2 = formatter.validFormats, module.exports.all = function (format) {
      return all.map(formatter.transform(format)).filter(c => c);
    }, module.exports.each = function (format, callback) {
      return typeof format == "function" && (callback = format, format = void 0), all.map(formatter.transform(format)).filter(c => c).forEach(callback);
    };
  }
  var duplicated;
});
var require_windows_ca_certs = __commonJSMin((exports, module) => {
  function all() {
    let {
        X509Certificate: X509Certificate
      } = require("crypto"),
      {
        join: join
      } = require("path");
    var requireFunc = typeof __webpack_require__ == "function" ? __non_webpack_require__ : require;
    let crypt = requireFunc(join(__dirname, "crypt32.node")),
      pems = [],
      store = new crypt.Crypt32();
    try {
      let der;
      for (; der = store.next();) {
        let cert = new X509Certificate(der);
        pems.push(cert.toString());
      }
    } finally {
      store.done();
    }
    return Array.from(new Set(pems));
  }
  __name(all, "all");
  process.platform !== "win32" ? module.exports.all = () => [] : module.exports.all = all;
});
var require_file_uri_to_path = __commonJSMin((exports, module) => {
  var sep = require("path").sep || "/";
  module.exports = fileUriToPath;
  function fileUriToPath(uri) {
    if (typeof uri != "string" || uri.length <= 7 || uri.substring(0, 7) != "file://") throw new TypeError("must pass in a file:// URI to convert to a file path");
    var rest = decodeURI(uri.substring(7)),
      firstSlash = rest.indexOf("/"),
      host = rest.substring(0, firstSlash),
      path = rest.substring(firstSlash + 1);
    return host == "localhost" && (host = ""), host && (host = sep + sep + host), path = path.replace(/^(.+)\|/, "$1:"), sep == "\\" && (path = path.replace(/\//g, "\\")), /^.+\:/.test(path) || (path = sep + path), host + path;
  }
  __name(fileUriToPath, "fileUriToPath");
});
var require_bindings = __commonJSMin((exports, module) => {
  var fs = require("fs"),
    path = require("path"),
    fileURLToPath = tae(),
    join = path.join,
    dirname = path.dirname,
    exists = fs.accessSync && function (path) {
      try {
        fs.accessSync(path);
      } catch {
        return !1;
      }
      return !0;
    } || fs.existsSync || path.existsSync,
    defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [["module_root", "build", "bindings"], ["module_root", "build", "Debug", "bindings"], ["module_root", "build", "Release", "bindings"], ["module_root", "out", "Debug", "bindings"], ["module_root", "Debug", "bindings"], ["module_root", "out", "Release", "bindings"], ["module_root", "Release", "bindings"], ["module_root", "build", "default", "bindings"], ["module_root", "compiled", "version", "platform", "arch", "bindings"], ["module_root", "compiled", "platform", "arch", "bindings"], ["module_root", "addon-build", "release", "install-root", "bindings"], ["module_root", "addon-build", "debug", "install-root", "bindings"], ["module_root", "addon-build", "default", "install-root", "bindings"], ["module_root", "lib", "binding", "nodePreGyp", "bindings"]]
    };
  function bindings(opts) {
    typeof opts == "string" ? opts = {
      bindings: opts
    } : opts || (opts = {}), Object.keys(defaults).map(function (i) {
      i in opts || (opts[i] = defaults[i]);
    }), opts.module_root || (opts.module_root = dirname(__filename)), path.extname(opts.bindings) != ".node" && (opts.bindings += ".node");
    for (var requireFunc = typeof __webpack_require__ == "function" ? __non_webpack_require__ : require, tries = [], i = 0, l = opts.try.length, n, b, err; i < l; i++) {
      n = join.apply(null, opts.try[i].map(function (p) {
        return opts[p] || p;
      })), tries.push(n);
      try {
        return b = opts.path ? requireFunc.resolve(n) : requireFunc(n), opts.path || (b.path = n), b;
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) throw e;
      }
    }
    throw err = new Error(`Could not locate the bindings file. Tried:
` + tries.map(function (a) {
      return opts.arrow + a;
    }).join(`
`)), err.tries = tries, err;
  }
  __name(bindings, "bindings");
  module.exports = exports = bindings;
  exports.getFileName = __name(function (calling_file) {
    var origPST = Error.prepareStackTrace,
      origSTL = Error.stackTraceLimit,
      dummy = {},
      fileName;
    Error.stackTraceLimit = 10, Error.prepareStackTrace = function (e, st) {
      for (var i = 0, l = st.length; i < l; i++) if (fileName = st[i].getFileName(), fileName !== __filename) if (calling_file) {
        if (fileName !== calling_file) return;
      } else return;
    }, Error.captureStackTrace(dummy), new Error(dummy.stack), Error.prepareStackTrace = origPST, Error.stackTraceLimit = origSTL;
    var fileSchema = "file://";
    return fileName.indexOf(fileSchema) === 0 && (fileName = fileURLToPath(fileName)), fileName;
  }, "getFileName");
  exports.getRoot = __name(function (file) {
    for (var dir = dirname(file), prev;;) {
      if (dir === "." && (dir = process.cwd()), exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) return dir;
      if (prev === dir) throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
      prev = dir, dir = join(dir, "..");
    }
  }, "getRoot");
});
var require_util = __commonJSMin((exports, module) => {
  "use strict";

  function validateParameter(parameter, specs, specIndex) {
    let spec = specs[specIndex];
    if (parameter == null && spec.required === !1) return;
    if (parameter == null) throw new TypeError(`Required parameter \`${spec.name}\` missing`);
    let paramType = typeof parameter;
    if (spec.type && paramType !== spec.type) {
      if (spec.required === !1 && specs.slice(specIndex).some(def => def.type === paramType)) return !1;
      throw new TypeError(`Invalid type for parameter \`${spec.name}\`, expected \`${spec.type}\` but found \`${typeof parameter}\``);
    }
    return !0;
  }
  __name(validateParameter, "validateParameter");
  function hasOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  __name(hasOwnProperty, "hasOwnProperty");
  function defineOperation(fn, paramDefs) {
    return function () {
      let args = Array.prototype.slice.call(arguments),
        params = [];
      for (let i = 0, argIdx = 0; i < paramDefs.length; ++i, ++argIdx) {
        let def = paramDefs[i],
          arg = args[argIdx];
        hasOwnProperty(def, "default") && arg == null && (arg = def.default), def.type === "object" && def.default != null && (arg = Object.assign({}, def.default, arg)), def.name === "options" && (typeof arg == "function" || arg == null) && (arg = {}), validateParameter(arg, paramDefs, i) ? params.push(arg) : argIdx--;
      }
      if (typeof arguments[arguments.length - 1] != "function") return new Promise((resolve, reject) => {
        params.push((err, response) => {
          if (err) return reject(err);
          resolve(response);
        }), fn.apply(this, params);
      });
      fn.apply(this, params);
    };
  }
  __name(defineOperation, "defineOperation");
  module.exports = {
    defineOperation: defineOperation,
    validateParameter: validateParameter
  };
});
var require_kerberos = __commonJSMin((exports, module) => {
  "use strict";

  var kerberos = oae()("kerberos"),
    KerberosClient = kerberos.KerberosClient,
    KerberosServer = kerberos.KerberosServer,
    defineOperation = cae().defineOperation,
    GSS_C_DELEG_FLAG = 1,
    GSS_C_MUTUAL_FLAG = 2,
    GSS_C_REPLAY_FLAG = 4,
    GSS_C_SEQUENCE_FLAG = 8,
    GSS_C_CONF_FLAG = 16,
    GSS_C_INTEG_FLAG = 32,
    GSS_C_ANON_FLAG = 64,
    GSS_C_PROT_READY_FLAG = 128,
    GSS_C_TRANS_FLAG = 256,
    GSS_C_NO_OID = 0,
    GSS_MECH_OID_KRB5 = 9,
    GSS_MECH_OID_SPNEGO = 6;
  KerberosClient.prototype.step = defineOperation(KerberosClient.prototype.step, [{
    name: "challenge",
    type: "string"
  }, {
    name: "callback",
    type: "function",
    required: !1
  }]);
  KerberosClient.prototype.wrap = defineOperation(KerberosClient.prototype.wrap, [{
    name: "challenge",
    type: "string"
  }, {
    name: "options",
    type: "object"
  }, {
    name: "callback",
    type: "function",
    required: !1
  }]);
  KerberosClient.prototype.unwrap = defineOperation(KerberosClient.prototype.unwrap, [{
    name: "challenge",
    type: "string"
  }, {
    name: "callback",
    type: "function",
    required: !1
  }]);
  KerberosServer.prototype.step = defineOperation(KerberosServer.prototype.step, [{
    name: "challenge",
    type: "string"
  }, {
    name: "callback",
    type: "function",
    required: !1
  }]);
  var checkPassword = defineOperation(kerberos.checkPassword, [{
      name: "username",
      type: "string"
    }, {
      name: "password",
      type: "string"
    }, {
      name: "service",
      type: "string"
    }, {
      name: "defaultRealm",
      type: "string",
      required: !1
    }, {
      name: "callback",
      type: "function",
      required: !1
    }]),
    principalDetails = defineOperation(kerberos.principalDetails, [{
      name: "service",
      type: "string"
    }, {
      name: "hostname",
      type: "string"
    }, {
      name: "callback",
      type: "function",
      required: !1
    }]),
    initializeClient = defineOperation(kerberos.initializeClient, [{
      name: "service",
      type: "string"
    }, {
      name: "options",
      type: "object",
      default: {
        mechOID: GSS_C_NO_OID
      }
    }, {
      name: "callback",
      type: "function",
      required: !1
    }]),
    initializeServer = defineOperation(kerberos.initializeServer, [{
      name: "service",
      type: "string"
    }, {
      name: "callback",
      type: "function",
      required: !1
    }]);
  module.exports = {
    initializeClient: initializeClient,
    initializeServer: initializeServer,
    principalDetails: principalDetails,
    checkPassword: checkPassword,
    GSS_C_DELEG_FLAG: GSS_C_DELEG_FLAG,
    GSS_C_MUTUAL_FLAG: GSS_C_MUTUAL_FLAG,
    GSS_C_REPLAY_FLAG: GSS_C_REPLAY_FLAG,
    GSS_C_SEQUENCE_FLAG: GSS_C_SEQUENCE_FLAG,
    GSS_C_CONF_FLAG: GSS_C_CONF_FLAG,
    GSS_C_INTEG_FLAG: GSS_C_INTEG_FLAG,
    GSS_C_ANON_FLAG: GSS_C_ANON_FLAG,
    GSS_C_PROT_READY_FLAG: GSS_C_PROT_READY_FLAG,
    GSS_C_TRANS_FLAG: GSS_C_TRANS_FLAG,
    GSS_C_NO_OID: GSS_C_NO_OID,
    GSS_MECH_OID_KRB5: GSS_MECH_OID_KRB5,
    GSS_MECH_OID_SPNEGO: GSS_MECH_OID_SPNEGO
  };
});
var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "kerberos",
    version: "2.0.1",
    description: "Kerberos library for Node.js",
    main: "lib/index.js",
    files: ["lib", "src", "binding.gyp", "HISTORY.md", "README.md"],
    repository: {
      type: "git",
      url: "https://github.com/mongodb-js/kerberos.git"
    },
    keywords: ["kerberos", "security", "authentication"],
    author: {
      name: "The MongoDB NodeJS Team",
      email: "dbx-node@mongodb.com"
    },
    bugs: {
      url: "https://jira.mongodb.org/projects/NODE/issues/"
    },
    dependencies: {
      bindings: "^1.5.0",
      "node-addon-api": "^4.3.0",
      "prebuild-install": "7.1.1"
    },
    devDependencies: {
      chai: "^4.3.6",
      "chai-string": "^1.5.0",
      chalk: "^4.1.2",
      "clang-format": "^1.6.0",
      "dmd-clear": "^0.1.2",
      eslint: "^8.9.0",
      "eslint-config-prettier": "^8.3.0",
      "eslint-plugin-prettier": "^4.0.0",
      "jsdoc-to-markdown": "^7.1.1",
      mocha: "^9.2.0",
      mongodb: "^4.3.1",
      prebuild: "^11.0.3",
      prettier: "^2.5.1",
      request: "^2.88.0",
      "standard-version": "^9.3.2"
    },
    scripts: {
      install: "prebuild-install --runtime napi || node-gyp rebuild",
      "format-cxx": "git-clang-format",
      "format-js": "eslint lib test --fix",
      "check:lint": "eslint lib test",
      precommit: "check-clang-format",
      test: "mocha test",
      docs: "jsdoc2md --template etc/README.hbs --plugin dmd-clear --files lib/kerberos.js > README.md",
      rebuild: "prebuild --runtime napi --compile",
      prebuild: "prebuild --runtime napi --strip --verbose --all",
      release: "standard-version -i HISTORY.md"
    },
    engines: {
      node: ">=12.9.0"
    },
    binary: {
      napi_versions: [4]
    },
    license: "Apache-2.0",
    readmeFilename: "README.md"
  };
});
var require_mongodb = __commonJSMin((exports, module) => {
  "use strict";

  var dns = require("dns"),
    kerberos = sD(),
    MongoAuthProcess = class {
      static {
        __name(this, "MongoAuthProcess");
      }
      constructor(host, port, serviceName, options) {
        options = options || {}, this.host = host, this.port = port, this.serviceName = serviceName || options.gssapiServiceName || "mongodb", this.canonicalizeHostName = typeof options.gssapiCanonicalizeHostName == "boolean" ? options.gssapiCanonicalizeHostName : !1, this._transition = firstTransition(this), this.retries = 10;
      }
      init(username, password, callback) {
        let self = this;
        this.username = username, this.password = password;
        function performGssapiCanonicalizeHostName(canonicalizeHostName, host, callback) {
          if (!canonicalizeHostName) return callback();
          dns.resolveCname(host, (err, r) => {
            if (err) return callback(err);
            Array.isArray(r) && r.length > 0 && (self.host = r[0]), callback();
          });
        }
        __name(performGssapiCanonicalizeHostName, "performGssapiCanonicalizeHostName"), performGssapiCanonicalizeHostName(this.canonicalizeHostName, this.host, err => {
          if (err) return callback(err);
          let initOptions = {};
          password != null && Object.assign(initOptions, {
            user: username,
            password: password
          });
          let service = process.platform === "win32" ? `${this.serviceName}/${this.host}` : `${this.serviceName}@${this.host}`;
          kerberos.initializeClient(service, initOptions, (err, client) => {
            if (err) return callback(err, null);
            self.client = client, callback(null, client);
          });
        });
      }
      transition(payload, callback) {
        if (this._transition == null) return callback(new Error("Transition finished"));
        this._transition(payload, callback);
      }
    };
  function firstTransition(auth) {
    return (payload, callback) => {
      auth.client.step("", (err, response) => {
        if (err) return callback(err);
        auth._transition = secondTransition(auth), callback(null, response);
      });
    };
  }
  __name(firstTransition, "firstTransition");
  function secondTransition(auth) {
    return (payload, callback) => {
      auth.client.step(payload, (err, response) => {
        if (err && auth.retries === 0) return callback(err);
        if (err) return auth.retries = auth.retries - 1, auth.transition(payload, callback);
        auth._transition = thirdTransition(auth), callback(null, response || "");
      });
    };
  }
  __name(secondTransition, "secondTransition");
  function thirdTransition(auth) {
    return (payload, callback) => {
      auth.client.unwrap(payload, (err, response) => {
        if (err) return callback(err, !1);
        auth.client.wrap(response, {
          user: auth.username
        }, (err, wrapped) => {
          if (err) return callback(err, !1);
          auth._transition = fourthTransition(auth), callback(null, wrapped);
        });
      });
    };
  }
  __name(thirdTransition, "thirdTransition");
  function fourthTransition(auth) {
    return (payload, callback) => {
      auth._transition = null, callback(null, !0);
    };
  }
  __name(fourthTransition, "fourthTransition");
  module.exports = {
    MongoAuthProcess: MongoAuthProcess
  };
});
var require_lib = __commonJSMin((exports, module) => {
  "use strict";

  var kerberos = sD();
  module.exports = kerberos;
  module.exports.Kerberos = kerberos;
  module.exports.version = pae().version;
  module.exports.processes = {
    MongoAuthProcess: hae().MongoAuthProcess
  };
});
var extension_exports = {};
__export(extension_exports, {
  Extension: () => Extension,
  activate: () => activate,
  createExtensionContext: () => createExtensionContext,
  onDeactivate: () => onDeactivate
});
module.exports = __toCommonJS(extension_exports);
var import_register = Ns(wT()),
  import_copilot_promptlib = Ns(Dc()),
  import_vscode = require("vscode");
var import_events = require("events");
var Clock = class {
  static {
    __name(this, "Clock");
  }
  now() {
    return new Date();
  }
};
var import_copilot_promptlib = Ns(Dc());
var CopilotConfigPrefix = "github.copilot";
var import_copilot_promptlib = Ns(Dc());
var import_crypto_js = Ns(o8());
function keyForPrompt(prompt) {
  return (0, a8.SHA256)(a8.enc.Utf16.parse(prompt.prefix + prompt.suffix)).toString();
}
__name(keyForPrompt, "keyForPrompt");
var LRUCacheMap = class {
  constructor(size = 10) {
    this.valueMap = new Map();
    this.lruKeys = [];
    this.sizeLimit = size;
  }
  static {
    __name(this, "LRUCacheMap");
  }
  set(key, value) {
    let maybeKeyToDelete;
    return this.valueMap.has(key) ? maybeKeyToDelete = key : this.lruKeys.length >= this.sizeLimit && (maybeKeyToDelete = this.lruKeys[0]), maybeKeyToDelete !== void 0 && this.delete(maybeKeyToDelete), this.valueMap.set(key, value), this.touchKeyInLRU(key), this;
  }
  get(key) {
    if (this.valueMap.has(key)) {
      let entry = this.valueMap.get(key);
      return this.touchKeyInLRU(key), entry;
    }
  }
  delete(key) {
    return this.has(key) ? (this.removeKeyFromLRU(key), this.valueMap.get(key) !== void 0 && this.valueMap.delete(key), !0) : !1;
  }
  clear() {
    this.valueMap.clear(), this.lruKeys = [];
  }
  get size() {
    return this.valueMap.size;
  }
  keys() {
    return this.lruKeys.slice().values();
  }
  values() {
    return new Map(this.valueMap).values();
  }
  entries() {
    return new Map(this.valueMap).entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  has(key) {
    return this.valueMap.has(key);
  }
  forEach(callbackfn, thisArg) {
    new Map(this.valueMap).forEach(callbackfn, thisArg);
  }
  get [Symbol.toStringTag]() {
    return "LRUCacheMap";
  }
  peek(key) {
    return this.valueMap.get(key);
  }
  removeKeyFromLRU(key) {
    let index = this.lruKeys.indexOf(key);
    index !== -1 && this.lruKeys.splice(index, 1);
  }
  touchKeyInLRU(key) {
    this.removeKeyFromLRU(key), this.lruKeys.push(key);
  }
};
var contextualFilterIntercept = -.3043572714994554,
  contextualFilterWeights = [.9978708359643611, .7001905605239328, -.1736749244124868, -.22994157947320112, .13406692641682572, -.007751370662011853, .0057783222035240715, .41910878254476003, -.1621657125711092, .13770814958908187, -.06036011308184006, -.07351180985800129, 0, -.05584878151248109, .30618794079412015, -.1282197982598485, .10951859303997555, .1700461782788777, -.3346057842644757, .22497985923128136, 0, -.44038101825774356, -.6540115939236782, .16595600081341702, .20733910722385135, -.1337033766105696, -.06923072125290894, -.05806684191976292, .3583334671633344, -.47357732824944315, .17810871365594377, .42268219963946685, 0, 0, -.16379620467004602, -.43893868831061167, 0, .11570094006709251, .9326431262654882, -.9990110509203912, -.44125275652726503, -.15840786997162004, -.4600396256644451, -.018814811994044403, .09230944537175266, .025814790934742798, -1.0940162204190154, -.9407503631235489, -.9854303778694269, -1.1045822488262245, -1.1417299456573262, -1.5623704405345513, -.4157473855795939, -1.0244257735561713, -.7477401944601753, -1.1275109699068402, -.0714715633552533, -1.1408628006786907, -1.0409898655074672, -.2288889836518878, -.5469549893760344, -.181946611106845, .1264329316374918, 0, 0, .312206968554707, -.3656436392517924, .23655650686038968, .1014912419901576, 0, .06287549221765308, 0, 0, .19027065218932154, -.8519502045974378, 0, .23753599905971923, .2488809322489166, .019969251907983224, 0, .06916505526229488, .29053356359188204, -.14484456555431657, .014768129429370188, -.15051464926341374, .07614835502776021, -.3317489901313935, 0, 0, .04921938684669103, -.28248576768353445, -.9708816204525345, -1.3560464522265527, .014165375212383239, -.23924166472544983, .10006595730248855, .09867233147279562, .32330430333220644, -.058625706114180595, .17149853105783947, .4436484054395367, .047189049576707255, .16832520944790552, .1117259900942179, -.35469010329927253, 0, -.1528189124465582, -.3804848349564939, .07278077320753953, .13263786480064088, .22920682659292527, 1.1512955314336537, 0, .016939862282340023, .4242994650403408, .12759835577444986, -.5577261135825583, -.19764560943067672, -.4042102444736004, .12063461617733708, -.2933966817484834, .2715683893968593, 0, -.7138548251238751, 0, -.023066228703035277, 0, -.06383043976746139, .09683723720709651, -.7337151424080791, 0, -.27191370124625525, .2819781269656171, -.08711496549050252, .11048604909969338, -.0934849550450534, .0721001250772912, .2589126797890794, .6729582659532254, -.21921032738244908, -.21535277468651456, -.45474006124091354, -.05861820126419139, -.007875306207720204, -.056661261678809284, .17727881404222662, .23603713348534658, .17485861412377932, -.5737483768696752, -.38220029570342745, -.5202722985519168, -.37187947527657256, .47155277792990113, -.12077912346691123, .47825628981545326, .4736704404000214, -.1615218651546898, .18362447973513005, 0, 0, -.18183417425866824, 0, 0, -.2538532305733833, -.1303692690676528, -.4073577969188216, .04172985870928789, -.1704527388573901, 0, 0, .7536858953385828, -.44703159588787644, 0, -.7246484085580873, -.21378128540782063, 0, .037461090552656146, -.16205852364367032, -.10973952064404884, .017468043407647377, -.1288980387397392, 0, 0, 0, -1.218692715379445, .05536949662193305, -.3763799844799116, -.1845001725624579, -.1615576298149558, 0, -.15373262203249874, -.04603412604270418, 0, -.3068149681460828, .09412352468269412, 0, .09116543650609721, .06065865264082559, .05688267379386188, -.05873945477722306, 0, .14532465133322153, .1870857769705463, .36304258043185555, .1411392422180405, .0630388629716367, 0, -1.1170522012450395, .16133697772771127, .15908534390781448, -.23485453704002232, -.1419980841417892, .21909510179526218, .39948420260153766, .40802294284289187, .15403767653746853, 0, .19764784115096676, .584914157527457, 0, -.4573883817015294],
  contextualFilterLanguageMap = {
    javascript: 1,
    typescript: 2,
    typescriptreact: 3,
    python: 4,
    vue: 5,
    php: 6,
    dart: 7,
    javascriptreact: 8,
    go: 9,
    css: 10,
    cpp: 11,
    html: 12,
    scss: 13,
    markdown: 14,
    csharp: 15,
    java: 16,
    json: 17,
    rust: 18,
    ruby: 19,
    c: 20
  },
  contextualFilterCharacterMap = {
    " ": 1,
    "!": 2,
    '"': 3,
    "#": 4,
    $: 5,
    "%": 6,
    "&": 7,
    "'": 8,
    "(": 9,
    ")": 10,
    "*": 11,
    "+": 12,
    ",": 13,
    "-": 14,
    ".": 15,
    "/": 16,
    0: 17,
    1: 18,
    2: 19,
    3: 20,
    4: 21,
    5: 22,
    6: 23,
    7: 24,
    8: 25,
    9: 26,
    ":": 27,
    ";": 28,
    "<": 29,
    "=": 30,
    ">": 31,
    "?": 32,
    "@": 33,
    A: 34,
    B: 35,
    C: 36,
    D: 37,
    E: 38,
    F: 39,
    G: 40,
    H: 41,
    I: 42,
    J: 43,
    K: 44,
    L: 45,
    M: 46,
    N: 47,
    O: 48,
    P: 49,
    Q: 50,
    R: 51,
    S: 52,
    T: 53,
    U: 54,
    V: 55,
    W: 56,
    X: 57,
    Y: 58,
    Z: 59,
    "[": 60,
    "\\": 61,
    "]": 62,
    "^": 63,
    _: 64,
    "`": 65,
    a: 66,
    b: 67,
    c: 68,
    d: 69,
    e: 70,
    f: 71,
    g: 72,
    h: 73,
    i: 74,
    j: 75,
    k: 76,
    l: 77,
    m: 78,
    n: 79,
    o: 80,
    p: 81,
    q: 82,
    r: 83,
    s: 84,
    t: 85,
    u: 86,
    v: 87,
    w: 88,
    x: 89,
    y: 90,
    z: 91,
    "{": 92,
    "|": 93,
    "}": 94,
    "~": 95
  };
var CommitFileResolver = class {
  static {
    __name(this, "CommitFileResolver");
  }
};
var path = require("path");
function getRelativePath(workspaceFolders, docURI) {
  for (let uri of workspaceFolders) {
    let parentURI = `${uri}/`;
    if (docURI.toString().startsWith(parentURI)) return docURI.toString().slice(parentURI.length);
  }
}
__name(getRelativePath, "getRelativePath");
var TextDocumentManager = class {
  static {
    __name(this, "TextDocumentManager");
  }
  async getWorkspaceFolder(doc) {
    return this.getWorkspaceFolders().find(folder => {
      if (doc.uri.toString().startsWith(folder.toString())) return folder;
    });
  }
  async getRelativePath(doc) {
    if (doc.uri.scheme !== "untitled") return getRelativePath(this.getWorkspaceFolders(), doc.uri) ?? path.basename(doc.uri.fsPath);
  }
};
var WorkspaceFileSystem = class {
  static {
    __name(this, "WorkspaceFileSystem");
  }
};
var import_vscode_uri = Ns(B1());
var MAX_NUM_FILES = 100,
  CursorHistoryManager = class {
    static {
      __name(this, "CursorHistoryManager");
    }
    constructor() {
      this.lineCursorHistory = new LRUCacheMap(MAX_NUM_FILES), this.fileCursorHistory = new LRUCacheMap(MAX_NUM_FILES);
    }
    add(doc, line, timestamp) {
      let uri = doc.uri.toString(),
        singleFile = this.lineCursorHistory.get(uri) ?? new Map(),
        numFocused = singleFile.get(line) ?? 0;
      singleFile.set(line, numFocused + 1), this.lineCursorHistory.set(uri, singleFile), this.fileCursorHistory.set(uri, {
        uri: uri,
        doc: doc,
        clickCount: (this.fileCursorHistory.get(uri)?.clickCount ?? 0) + 1,
        lastClickTime: timestamp
      });
    }
    getDocs() {
      let docs = [];
      for (let key of this.fileCursorHistory.keys()) {
        let docTime = this.fileCursorHistory.get(key);
        docTime !== void 0 && docs.push(docTime);
      }
      return docs;
    }
    sortedDocsByClickTime() {
      return this.getDocs().sort((a, b) => b.lastClickTime - a.lastClickTime).map(f => f.doc);
    }
    sortedDocsByClickCount() {
      return this.getDocs().sort((a, b) => b.clickCount === a.clickCount ? b.lastClickTime - a.lastClickTime : b.clickCount - a.clickCount).map(f => f.doc);
    }
  };
var accessTimes = new LRUCacheMap();
function sortByAccessTimes(docs) {
  return [...docs].sort((a, b) => {
    let aAccessTime = accessTimes.get(a.uri.toString()) ?? 0;
    return (accessTimes.get(b.uri.toString()) ?? 0) - aAccessTime;
  });
}
__name(sortByAccessTimes, "sortByAccessTimes");
var registerDocumentTracker = __name(ctx => ctx.get(TextDocumentManager).onDidFocusTextDocument(e => {
    e && accessTimes.set(e.document.uri.toString(), Date.now());
  }), "registerDocumentTracker"),
  cursorHistoryManager = new CursorHistoryManager(),
  registerCursorTracker = __name(ctx => ctx.get(TextDocumentManager).onDidChangeCursor(e => {
    if (e && e.selections) for (let selection of e.selections) cursorHistoryManager.add(e.textEditor.document, selection.anchor.line, Date.now()), cursorHistoryManager.add(e.textEditor.document, selection.active.line, Date.now());
  }), "registerCursorTracker");
var CoCommittedFiles = class _CoCommittedFiles {
  constructor(docManager, commitFileResolver) {
    this.docManager = docManager;
    this.commitFileResolver = commitFileResolver;
    this.cocommittedFilesCache = this.computeInBackgroundAndMemoize(_CoCommittedFiles.getCoCommittedFiles, 1);
  }
  static {
    __name(this, "CoCommittedFiles");
  }
  async tryGetTextDocument(uri) {
    try {
      return await this.docManager.getTextDocument(FB.URI.parse(uri));
    } catch {
      return;
    }
  }
  static async getCoCommittedFiles(ns, fileURI, neighboringFileType, languageId, maxNumFiles) {
    if (ns.commitFileResolver === void 0) return [];
    let coCommittedFiles = await ns.commitFileResolver.getCoCommitResult(fileURI, maxNumFiles),
      totalLen = 0,
      files = [];
    for (let cocommittedFile of coCommittedFiles) {
      if (cocommittedFile.toString() === fileURI.toString()) continue;
      let doc = await ns.tryGetTextDocument(cocommittedFile.toString());
      if (!(doc === void 0 || totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && doc.uri.scheme == "file" && doc.languageId === languageId && (files.push({
        uri: doc.uri.toString(),
        relativePath: await ns.docManager.getRelativePath(doc),
        languageId: doc.languageId,
        source: doc.getText()
      }), totalLen += doc.getText().length, files.length >= maxNumFiles)) break;
    }
    return files;
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && doc.languageId === languageId && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  computeInBackgroundAndMemoize(fct, cacheSize) {
    let resultsCache = new LRUCacheMap(cacheSize),
      inComputation = new Set();
    return (fileURI, type, ...args) => {
      let key = fileURI.toString() + type,
        memorizedComputation = resultsCache.get(key);
      if (memorizedComputation) return memorizedComputation;
      if (inComputation.has(key)) return null;
      let computation = fct(this, fileURI, type, ...args);
      return inComputation.add(key), computation.then(computedResult => {
        resultsCache.set(key, computedResult), inComputation.delete(key);
      }), null;
    };
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    if (neighborFiles = await this.truncateDocs(sortByAccessTimes((await this.docManager.textDocuments()).filter(doc => accessTimes.get(doc.uri.toString()) !== void 0)), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), neighborFiles.length < maxNumNeighborFiles) {
      let cocommittedFiles = this.cocommittedFilesCache(uri, neighboringFileType, languageId, maxNumNeighborFiles);
      if (cocommittedFiles !== null) {
        let neighborFileUriSet = new Set(neighborFiles.map(f => f.uri));
        cocommittedFiles = cocommittedFiles.filter(f => !neighborFileUriSet.has(f.uri)).slice(0, maxNumNeighborFiles - neighborFiles.length), neighborFiles.push(...cocommittedFiles), neighborSource.set(neighboringFileType, cocommittedFiles.map(f => f.uri));
      }
    }
    return {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var CursorHistoryFiles = class {
  constructor(docManager) {
    this.docManager = docManager;
  }
  static {
    __name(this, "CursorHistoryFiles");
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    return neighboringFileType === "cursormostrecent" ? (neighborFiles = await this.truncateDocs(cursorHistoryManager.sortedDocsByClickTime(), uri, languageId, maxNumNeighborFiles), neighborSource.set("cursormostrecent", neighborFiles.map(f => f.uri))) : neighboringFileType === "cursormostcount" && (neighborFiles = await this.truncateDocs(cursorHistoryManager.sortedDocsByClickCount(), uri, languageId, maxNumNeighborFiles), neighborSource.set("cursormostcount", neighborFiles.map(f => f.uri))), {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var OpenTabFiles = class {
  constructor(docManager) {
    this.docManager = docManager;
  }
  static {
    __name(this, "OpenTabFiles");
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    return neighborFiles = await this.truncateDocs(sortByAccessTimes(await this.docManager.textDocuments()), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
var path = Ns(require("path")),
  import_vscode_uri = Ns(B1());
var knownLanguages = {
  abap: {
    extensions: [".abap"]
  },
  bat: {
    extensions: [".bat", ".cmd"]
  },
  bibtex: {
    extensions: [".bib", ".bibtex"]
  },
  blade: {
    extensions: [".blade", ".blade.php"]
  },
  c: {
    extensions: [".c", ".cats", ".h", ".idc"]
  },
  csharp: {
    extensions: [".cake", ".cs", ".csx", ".linq"]
  },
  cpp: {
    extensions: [".c++", ".cc", ".cp", ".cpp", ".cxx", ".h", ".h++", ".hh", ".hpp", ".hxx", ".inc", ".inl", ".ino", ".ipp", ".ixx", ".re", ".tcc", ".tpp", ".i"]
  },
  css: {
    extensions: [".css", ".wxss"]
  },
  clojure: {
    extensions: [".bb", ".boot", ".cl2", ".clj", ".cljc", ".cljs", ".cljs.hl", ".cljscm", ".cljx", ".edn", ".hic"],
    filenames: ["riemann.config"]
  },
  ql: {
    extensions: [".ql", ".qll"]
  },
  coffeescript: {
    extensions: ["._coffee", ".cake", ".cjsx", ".coffee", ".iced"],
    filenames: ["Cakefile"]
  },
  dart: {
    extensions: [".dart"]
  },
  dockerfile: {
    extensions: [".dockerfile"],
    filenames: ["Containerfile", "Dockerfile"]
  },
  html: {
    extensions: [".ect", ".ejs", ".ejs.t", ".jst", ".hta", ".htm", ".html", ".html.hl", ".html5", ".inc", ".jsp", ".tpl", ".twig", ".wxml", ".xht", ".xhtml", ".phtml", ".liquid"]
  },
  elixir: {
    extensions: [".ex", ".exs"],
    filenames: ["mix.lock"]
  },
  erlang: {
    extensions: [".app.src", ".erl", ".es", ".escript", ".hrl", ".xrl", ".yrl"],
    filenames: ["Emakefile", "rebar.config", "rebar.config.lock", "rebar.lock"]
  },
  fsharp: {
    extensions: [".fs", ".fsi", ".fsx"]
  },
  go: {
    extensions: [".go"]
  },
  groovy: {
    extensions: [".gradle", ".groovy", ".grt", ".gtpl", ".gvy", ".jenkinsfile"],
    filenames: ["Jenkinsfile", "Jenkinsfile"]
  },
  terraform: {
    extensions: [".hcl", ".nomad", ".tf", ".tfvars", ".workflow"]
  },
  erb: {
    extensions: [".erb", ".erb.deface", ".rhtml"]
  },
  razor: {
    extensions: [".cshtml", ".razor"]
  },
  haml: {
    extensions: [".haml", ".haml.deface"]
  },
  handlebars: {
    extensions: [".handlebars", ".hbs"]
  },
  haskell: {
    extensions: [".hs", ".hs-boot", ".hsc"]
  },
  ini: {
    extensions: [".cfg", ".dof", ".ini", ".lektorproject", ".prefs", ".pro", ".properties", ".url"],
    filenames: [".coveragerc", ".flake8", ".pylintrc", "buildozer.spec", "pylintrc"]
  },
  jsonc: {
    extensions: [".code-snippets", ".code-workspace", ".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"],
    filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "launch.json", "settings.json", "tsconfig.json", "tslint.json"]
  },
  java: {
    extensions: [".jav", ".java", ".jsh"]
  },
  javascript: {
    extensions: ["._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".js", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"],
    filenames: ["Jakefile"]
  },
  julia: {
    extensions: [".jl"]
  },
  python: {
    extensions: [".ipynb", ".cgi", ".codon", ".fcgi", ".gyp", ".gypi", ".lmi", ".py", ".py3", ".pyde", ".pyi", ".pyp", ".pyt", ".pyw", ".rpy", ".smk", ".spec", ".tac", ".wsgi", ".xpy"],
    filenames: ["Notebook", ".gclient", "DEPS", "SConscript", "SConstruct", "Snakefile", "wscript"]
  },
  kotlin: {
    extensions: [".kt", ".ktm", ".kts"]
  },
  less: {
    extensions: [".less"]
  },
  lua: {
    extensions: [".fcgi", ".lua", ".luau", ".nse", ".p8", ".pd_lua", ".rbxs", ".rockspec", ".wlua"],
    filenames: [".luacheckrc"]
  },
  makefile: {
    extensions: [".d", ".mak", ".make", ".makefile", ".mk", ".mkfile"],
    filenames: ["BSDmakefile", "GNUmakefile", "Kbuild", "Makefile", "Makefile.am", "Makefile.boot", "Makefile.frag", "Makefile.in", "Makefile.inc", "Makefile.wat", "makefile", "makefile.sco", "mkfile"]
  },
  markdown: {
    extensions: [".livemd", ".markdown", ".md", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"],
    filenames: ["contents.lr"]
  },
  "objective-c": {
    extensions: [".h", ".m"]
  },
  "objective-cpp": {
    extensions: [".mm"]
  },
  php: {
    extensions: [".aw", ".ctp", ".fcgi", ".inc", ".php", ".php3", ".php4", ".php5", ".phps", ".phpt"],
    filenames: [".php", ".php_cs", ".php_cs.dist", "Phakefile"]
  },
  perl: {
    extensions: [".al", ".cgi", ".fcgi", ".perl", ".ph", ".pl", ".plx", ".pm", ".psgi", ".t"],
    filenames: [".latexmkrc", "Makefile.PL", "Rexfile", "ack", "cpanfile", "latexmkrc"]
  },
  powershell: {
    extensions: [".ps1", ".psd1", ".psm1"]
  },
  pug: {
    extensions: [".jade", ".pug"]
  },
  r: {
    extensions: [".r", ".rd", ".rsx"],
    filenames: [".Rprofile", "expr-dist"]
  },
  ruby: {
    extensions: [".builder", ".eye", ".fcgi", ".gemspec", ".god", ".jbuilder", ".mspec", ".pluginspec", ".podspec", ".prawn", ".rabl", ".rake", ".rb", ".rbi", ".rbuild", ".rbw", ".rbx", ".ru", ".ruby", ".spec", ".thor", ".watchr"],
    filenames: [".irbrc", ".pryrc", ".simplecov", "Appraisals", "Berksfile", "Brewfile", "Buildfile", "Capfile", "Dangerfile", "Deliverfile", "Fastfile", "Gemfile", "Guardfile", "Jarfile", "Mavenfile", "Podfile", "Puppetfile", "Rakefile", "Snapfile", "Steepfile", "Thorfile", "Vagrantfile", "buildfile"]
  },
  rust: {
    extensions: [".rs", ".rs.in"]
  },
  scss: {
    extensions: [".scss"]
  },
  sql: {
    extensions: [".cql", ".ddl", ".inc", ".mysql", ".prc", ".sql", ".tab", ".udf", ".viw"]
  },
  sass: {
    extensions: [".sass"]
  },
  scala: {
    extensions: [".kojo", ".sbt", ".sc", ".scala"]
  },
  shellscript: {
    extensions: [".bash", ".bats", ".cgi", ".command", ".fcgi", ".ksh", ".sh", ".sh.in", ".tmux", ".tool", ".zsh", ".zsh-theme"],
    filenames: [".bash_aliases", ".bash_functions", ".bash_history", ".bash_logout", ".bash_profile", ".bashrc", ".cshrc", ".flaskenv", ".kshrc", ".login", ".profile", ".zlogin", ".zlogout", ".zprofile", ".zshenv", ".zshrc", "9fs", "PKGBUILD", "bash_aliases", "bash_logout", "bash_profile", "bashrc", "cshrc", "gradlew", "kshrc", "login", "man", "profile", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc"]
  },
  slim: {
    extensions: [".slim"]
  },
  solidity: {
    extensions: [".sol"]
  },
  stylus: {
    extensions: [".styl"]
  },
  svelte: {
    extensions: [".svelte"]
  },
  swift: {
    extensions: [".swift"]
  },
  typescriptreact: {
    extensions: [".tsx"]
  },
  latex: {
    extensions: [".aux", ".bbx", ".cbx", ".cls", ".dtx", ".ins", ".lbx", ".ltx", ".mkii", ".mkiv", ".mkvi", ".sty", ".tex", ".toc"]
  },
  typescript: {
    extensions: [".cts", ".mts", ".ts"]
  },
  verilog: {
    extensions: [".v", ".veo"]
  },
  vb: {
    extensions: [".vb", ".vbhtml", ".Dsr", ".bas", ".cls", ".ctl", ".frm"]
  },
  vue: {
    extensions: [".nvue", ".vue"]
  },
  xml: {
    extensions: [".adml", ".admx", ".ant", ".axaml", ".axml", ".builds", ".ccproj", ".ccxml", ".clixml", ".cproject", ".cscfg", ".csdef", ".csl", ".csproj", ".ct", ".depproj", ".dita", ".ditamap", ".ditaval", ".dll.config", ".dotsettings", ".filters", ".fsproj", ".fxml", ".glade", ".gml", ".gmx", ".grxml", ".gst", ".hzp", ".iml", ".ivy", ".jelly", ".jsproj", ".kml", ".launch", ".mdpolicy", ".mjml", ".mm", ".mod", ".mxml", ".natvis", ".ncl", ".ndproj", ".nproj", ".nuspec", ".odd", ".osm", ".pkgproj", ".plist", ".pluginspec", ".proj", ".props", ".ps1xml", ".psc1", ".pt", ".qhelp", ".rdf", ".res", ".resx", ".rss", ".sch", ".scxml", ".sfproj", ".shproj", ".srdf", ".storyboard", ".sublime-snippet", ".svg", ".targets", ".tml", ".ui", ".urdf", ".ux", ".vbproj", ".vcxproj", ".vsixmanifest", ".vssettings", ".vstemplate", ".vxml", ".wixproj", ".workflow", ".wsdl", ".wsf", ".wxi", ".wxl", ".wxs", ".x3d", ".xacro", ".xaml", ".xib", ".xlf", ".xliff", ".xmi", ".xml", ".xml.dist", ".xmp", ".xproj", ".xsd", ".xspec", ".xul", ".zcml"],
    filenames: [".classpath", ".cproject", ".project", "App.config", "NuGet.config", "Settings.StyleCop", "Web.Debug.config", "Web.Release.config", "Web.config", "packages.config"]
  },
  xsl: {
    extensions: [".xsl", ".xslt"]
  },
  yaml: {
    extensions: [".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml", ".yml.mysql"],
    filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"]
  },
  javascriptreact: {
    extensions: [".jsx"]
  }
};
var WorkspaceFiles = class _WorkspaceFiles {
  constructor(docManager, workspaceFileSystem) {
    this.docManager = docManager;
    this.workspaceFileSystem = workspaceFileSystem;
    this.workspaceFilesCache = this.computeInBackgroundAndMemoize(_WorkspaceFiles.getWorkspaceFiles, 1);
  }
  static {
    __name(this, "WorkspaceFiles");
  }
  static {
    this.EXCLUDED_NEIGHBORS = ["node_modules", "dist", "site-packages"];
  }
  async tryGetTextDocument(uri) {
    try {
      return await this.docManager.getTextDocument(m8.URI.parse(uri));
    } catch {
      return;
    }
  }
  filePathDistance(filePath, targetFilePath) {
    let distance = Mc.relative(filePath, targetFilePath).split(Mc.sep).length;
    return {
      dist: distance,
      lca: (filePath.split(Mc.sep).length + targetFilePath.split(Mc.sep).length - distance) / 2
    };
  }
  static async getWorkspaceFiles(ns, filePath, neighboringFileType, languageId, maxNumWorkspaceFiles, blacklist) {
    if (ns.workspaceFileSystem === void 0 || ns.workspaceFilesCache === void 0) return [];
    let workspaceUri = await ns.workspaceFileSystem.getWorkspaceFolder(m8.URI.file(filePath));
    if (workspaceUri === void 0) return [];
    let include = `**/*.{${knownLanguages[languageId].extensions.map(ext => ext.replace(/^\.+/g, "")).join(",")}}`;
    if (neighboringFileType === "workspacesmallestpathdist") {
      let currentFileRepository = (await ns.workspaceFileSystem.findFiles("**/.git/config")).map(f => Mc.dirname(Mc.dirname(f.fsPath))).sort((a, b) => b.split(Mc.sep).length - a.split(Mc.sep).length).find(repo => filePath.startsWith(repo));
      currentFileRepository !== void 0 && currentFileRepository !== "" && (include = `${currentFileRepository}/${include}`);
    } else {
      let fileRelativePath = Mc.relative(workspaceUri.fsPath, Mc.dirname(filePath));
      fileRelativePath !== "" && (include = `${fileRelativePath}/${include}`);
    }
    let visitedFiles = new Set(blacklist.map(f => m8.URI.parse(f.uri).fsPath));
    visitedFiles.add(filePath);
    let exclude = `**/{${_WorkspaceFiles.EXCLUDED_NEIGHBORS.join(",")},.*}/**`,
      workspaceFiles = (await ns.workspaceFileSystem.findFiles(include, exclude)).filter(f => !visitedFiles.has(f.fsPath)).sort((a, b) => {
        let aDist = ns.filePathDistance(a.fsPath, filePath),
          bDist = ns.filePathDistance(b.fsPath, filePath);
        return aDist.dist !== bDist.dist ? aDist.dist - bDist.dist : bDist.lca - aDist.lca;
      }),
      files = [],
      totalLen = 0;
    for (let workspaceFile of workspaceFiles) {
      let doc = await ns.tryGetTextDocument(workspaceFile.toString());
      if (!(doc === void 0 || totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && doc.uri.scheme == "file" && considerNeighborFile(languageId, doc.languageId) && (files.push({
        uri: doc.uri.toString(),
        relativePath: await ns.docManager.getRelativePath(doc),
        languageId: doc.languageId,
        source: doc.getText()
      }), totalLen += doc.getText().length, files.length >= maxNumWorkspaceFiles)) break;
    }
    return files;
  }
  async truncateDocs(docs, fileURI, languageId, maxNumNeighborFiles) {
    let openFiles = [],
      totalLen = 0;
    for (let doc of docs) if (!(totalLen + doc.getText().length > NeighborSource.MAX_NEIGHBOR_AGGREGATE_LENGTH) && (doc.uri.scheme === "file" && fileURI.scheme === "file" && doc.uri.fsPath !== fileURI.fsPath && considerNeighborFile(languageId, doc.languageId) && (openFiles.push({
      uri: doc.uri.toString(),
      relativePath: await this.docManager.getRelativePath(doc),
      languageId: doc.languageId,
      source: doc.getText()
    }), totalLen += doc.getText().length), openFiles.length >= maxNumNeighborFiles)) break;
    return openFiles;
  }
  computeInBackgroundAndMemoize(fct, cacheSize) {
    let resultsCache = new LRUCacheMap(cacheSize),
      inComputation = new Set();
    return (filePath, type, ...args) => {
      let key = filePath + type,
        memorizedComputation = resultsCache.get(key);
      if (memorizedComputation) return memorizedComputation;
      if (inComputation.has(key)) return null;
      let computation = fct(this, filePath, type, ...args);
      return inComputation.add(key), computation.then(computedResult => {
        resultsCache.set(key, computedResult), inComputation.delete(key);
      }), null;
    };
  }
  async getNeighborFiles(uri, neighboringFileType, languageId, maxNumNeighborFiles) {
    let neighborFiles = [],
      neighborSource = new Map();
    if (neighborFiles = await this.truncateDocs(sortByAccessTimes((await this.docManager.textDocuments()).filter(doc => accessTimes.get(doc.uri.toString()) !== void 0)), uri, languageId, maxNumNeighborFiles), neighborSource.set("opentabs", neighborFiles.map(f => f.uri)), neighborFiles.length < maxNumNeighborFiles) {
      let workspaceFiles = this.workspaceFilesCache(uri.fsPath, neighboringFileType, languageId, maxNumNeighborFiles, neighborFiles);
      if (workspaceFiles !== null) {
        let neighborFileUriSet = new Set(neighborFiles.map(f => f.uri));
        workspaceFiles = workspaceFiles.filter(f => !neighborFileUriSet.has(f.uri)).slice(0, maxNumNeighborFiles - neighborFiles.length), neighborFiles.push(...workspaceFiles), neighborSource.set(neighboringFileType, workspaceFiles.map(f => f.uri));
      }
    }
    return {
      docs: neighborFiles,
      neighborSource: neighborSource
    };
  }
};
function considerNeighborFile(languageId, neighborLanguageId) {
  return languageId === neighborLanguageId;
}
__name(considerNeighborFile, "considerNeighborFile");
var NeighborSource = class _NeighborSource {
  static {
    __name(this, "NeighborSource");
  }
  static {
    this.MAX_NEIGHBOR_AGGREGATE_LENGTH = 2e5;
  }
  static {
    this.MAX_NEIGHBOR_FILES = 20;
  }
  static {
    this.EXCLUDED_NEIGHBORS = ["node_modules", "dist", "site-packages"];
  }
  static reset() {
    _NeighborSource.instance = void 0;
  }
  static async getNeighborFiles(ctx, uri, featuresFilterArgs) {
    let neighboringFileType = await ctx.get(Features).neighboringFileType(featuresFilterArgs);
    if (neighboringFileType === "none") return {
      docs: [],
      neighborSource: new Map()
    };
    if (_NeighborSource.instance === void 0) {
      let docManager = ctx.get(TextDocumentManager);
      if (neighboringFileType === "workspacesharingsamefolder" || neighboringFileType === "workspacesmallestpathdist") {
        let workspaceFileSystem = ctx.get(WorkspaceFileSystem);
        _NeighborSource.instance = new WorkspaceFiles(docManager, workspaceFileSystem);
      } else if (neighboringFileType == "opentabsandcocommitted") {
        let commitFileResolver = ctx.get(CommitFileResolver);
        _NeighborSource.instance = new CoCommittedFiles(docManager, commitFileResolver);
      } else neighboringFileType === "cursormostcount" || neighboringFileType === "cursormostrecent" ? _NeighborSource.instance = new CursorHistoryFiles(docManager) : _NeighborSource.instance = new OpenTabFiles(docManager);
    }
    return await _NeighborSource.instance.getNeighborFiles(uri, neighboringFileType, featuresFilterArgs.fileType, _NeighborSource.MAX_NEIGHBOR_FILES);
  }
};
var import_typebox = Ns(ou()),
  import_compiler = Ns(rF()),
  import_system = Ns(q3());
var import_crypto = Ns(require("crypto"));
var rnds8Pool = new Uint8Array(256),
  poolPtr = rnds8Pool.length;
function rng() {
  return poolPtr > rnds8Pool.length - 16 && (nF.crypto.randomFillSync(rnds8Pool), poolPtr = 0), rnds8Pool.slice(poolPtr, poolPtr += 16);
}
__name(rng, "rng");
var byteToHex = [];
for (let i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
__name(unsafeStringify, "unsafeStringify");
var import_crypto = Ns(require("crypto")),
  native_default = {
    randomUUID: sF.crypto.randomUUID
  };
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) return native_default.randomUUID();
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;
var CopilotAuthError = class extends Error {
  static {
    __name(this, "CopilotAuthError");
  }
  constructor(message) {
    super(message), this.name = "CopilotAuthError";
  }
};
var import_index = Ns(xU(), 1),
  ALPNProtocol = {
    ALPN_HTTP2: Gh.api.ALPN_HTTP2,
    ALPN_HTTP2C: Gh.api.ALPN_HTTP2C,
    ALPN_HTTP1_1: Gh.api.ALPN_HTTP1_1,
    ALPN_HTTP1_0: Gh.api.ALPN_HTTP1_0
  },
  {
    fetch: fetch,
    context: context,
    reset: reset,
    noCache: noCache,
    h1: h1,
    keepAlive: keepAlive,
    h1NoCache: h1NoCache,
    keepAliveNoCache: keepAliveNoCache,
    cacheStats: cacheStats,
    clearCache: clearCache,
    offPush: offPush,
    onPush: onPush,
    createUrl: createUrl,
    timeoutSignal: timeoutSignal,
    Body: Body,
    Headers: Headers,
    Request: Request,
    Response: Response,
    AbortController: AbortController,
    AbortError: AbortError,
    AbortSignal: AbortSignal,
    FetchBaseError: FetchBaseError,
    FetchError: FetchError,
    ALPN_HTTP2: ALPN_HTTP2,
    ALPN_HTTP2C: ALPN_HTTP2C,
    ALPN_HTTP1_1: ALPN_HTTP1_1,
    ALPN_HTTP1_0: ALPN_HTTP1_0
  } = Gh.api;
var util = Ns(require("util")),
  import_util = require("util");
var HeaderContributors = class {
  constructor() {
    this.contributors = [];
  }
  static {
    __name(this, "HeaderContributors");
  }
  add(contributor) {
    this.contributors.push(contributor);
  }
  remove(contributor) {
    let index = this.contributors.indexOf(contributor);
    index !== -1 && this.contributors.splice(index, 1);
  }
  contributeHeaders(headers) {
    for (let contributor of this.contributors) contributor.contributeHeaderValues(headers);
  }
  size() {
    return this.contributors.length;
  }
};
var Fetcher = class {
  static {
    __name(this, "Fetcher");
  }
  set rejectUnauthorized(value) {
    this._rejectUnauthorized = value;
  }
  get rejectUnauthorized() {
    return this._rejectUnauthorized;
  }
};
function isAbortError(e) {
  return e instanceof AbortError || e.name === "AbortError" && e.code === "ABORT_ERR" && e instanceof Error || e instanceof FetchError && e.code === "ABORT_ERR";
}
__name(isAbortError, "isAbortError");
var JsonParseError = class extends SyntaxError {
    constructor(message, code) {
      super(message);
      this.code = code;
      this.name = "JsonParseError";
    }
    static {
      __name(this, "JsonParseError");
    }
  },
  networkErrorCodes = new Set(["ECONNABORTED", "ECONNRESET", "EHOSTUNREACH", "ENETUNREACH", "ENOTCONN", "ETIMEDOUT", "ERR_HTTP2_STREAM_ERROR", "ERR_SSL_BAD_DECRYPT", "ERR_SSL_DECRYPTION_FAILED_OR_BAD_RECORD_MAC", "ERR_STREAM_PREMATURE_CLOSE"]);
function isNetworkError(e) {
  return e instanceof FetchError || e instanceof JsonParseError || e instanceof Error && networkErrorCodes.has(e.code);
}
__name(isNetworkError, "isNetworkError");
var Response = class {
    constructor(status, statusText, headers, getText, getBody) {
      this.status = status;
      this.statusText = statusText;
      this.headers = headers;
      this.getText = getText;
      this.getBody = getBody;
      this.ok = this.status >= 200 && this.status < 300;
    }
    static {
      __name(this, "Response");
    }
    async text() {
      return this.getText();
    }
    async json() {
      let text = await this.text(),
        contentType = this.headers.get("content-type");
      if (!contentType || !contentType.includes("json")) throw new JsonParseError(`Response content-type is ${contentType ?? "missing"} (status=${this.status})`, `ContentType=${contentType}`);
      try {
        return JSON.parse(text);
      } catch (e) {
        if (e instanceof SyntaxError) {
          let posMatch = e.message.match(/^(.*?) in JSON at position (\d+)$/);
          if (posMatch && parseInt(posMatch[2], 10) == text.length || e.message === "Unexpected end of JSON input") {
            let actualLength = new wU.TextEncoder().encode(text).length,
              headerLength = this.headers.get("content-length");
            throw headerLength === null ? new JsonParseError(`Response body truncated: actualLength=${actualLength}`, "Truncated") : new JsonParseError(`Response body truncated: actualLength=${actualLength}, headerLength=${headerLength}`, "Truncated");
          }
        }
        throw e;
      }
    }
    async body() {
      return this.getBody();
    }
  },
  requestTimeoutMs = 30 * 1e3;
function postRequest(ctx, url, secretKey, intent, requestId, body, cancelToken) {
  let headers = {
    Authorization: SU.format("Bearer %s", secretKey),
    "X-Request-Id": requestId,
    "Openai-Organization": "github-copilot",
    "VScode-SessionId": ctx.get(EditorSession).sessionId,
    "VScode-MachineId": ctx.get(EditorSession).machineId,
    ...editorVersionHeaders(ctx)
  };
  ctx.get(HeaderContributors).contributeHeaders(headers), intent && (headers["OpenAI-Intent"] = intent);
  let request = {
      method: "POST",
      headers: headers,
      json: body,
      timeout: requestTimeoutMs
    },
    fetcher = ctx.get(Fetcher);
  if (cancelToken) {
    let abort = fetcher.makeAbortController();
    cancelToken.onCancellationRequested(() => {
      telemetry(ctx, "networking.cancelRequest", TelemetryData.createAndMarkAsIssued({
        headerRequestId: requestId
      })), abort.abort();
    }), request.signal = abort.signal;
  }
  return fetcher.fetch(url, request).catch(reason => {
    if (reason.code == "ECONNRESET" || reason.code == "ETIMEDOUT" || reason.code == "ERR_HTTP2_INVALID_SESSION" || reason.message == "ERR_HTTP2_GOAWAY_SESSION") return telemetry(ctx, "networking.disconnectAll"), fetcher.disconnectAll().then(() => fetcher.fetch(url, request));
    throw reason;
  });
}
__name(postRequest, "postRequest");
var import_crypto_js = Ns(o8()),
  os = Ns(require("os"));
var EventEmitter = require("events"),
  CopilotTokenNotifier = class extends EventEmitter {
    static {
      __name(this, "CopilotTokenNotifier");
    }
    constructor() {
      super();
    }
    emit(event, token, envelope) {
      return super.emit(event, token, envelope);
    }
  };
var TelemetryUserConfig = class {
  static {
    __name(this, "TelemetryUserConfig");
  }
  constructor(ctx, trackingId, optedIn, ftFlag) {
    this.trackingId = trackingId, this.optedIn = optedIn ?? !1, this.ftFlag = ftFlag ?? "", this.setupUpdateOnToken(ctx);
  }
  setupUpdateOnToken(ctx) {
    ctx.get(CopilotTokenNotifier).on("onCopilotToken", copilotToken => {
      let restrictedTelemetry = copilotToken.getTokenValue("rt") === "1",
        ftFlag = copilotToken.getTokenValue("ft") ?? "",
        trackingId = copilotToken.getTokenValue("tid"),
        organizationsList = copilotToken.organization_list,
        enterpriseList = copilotToken.enterprise_list,
        sku = copilotToken.getTokenValue("sku");
      trackingId !== void 0 && (this.trackingId = trackingId, this.organizationsList = organizationsList?.toString(), this.enterpriseList = enterpriseList?.toString(), this.sku = sku, this.optedIn = restrictedTelemetry, this.ftFlag = ftFlag);
    });
  }
};
var frameRegexp = /^(\s+at)?(.*?)(@|\s\(|\s)([^(\n]+?)(:\d+)?(:\d+)?(\)?)$/;
function buildExceptionDetail(error) {
  let exceptionDetail = {
      type: error.name,
      value: error.message
    },
    originalStack = error.stack?.replace(/^.*?:\d+\n.*\n *\^?\n\n/, "");
  if (originalStack?.startsWith(error.toString() + `
`)) {
    exceptionDetail.stacktrace = [];
    for (let assembly of originalStack.slice(error.toString().length + 1).split(/\n/).reverse()) {
      let matches = assembly.match(frameRegexp),
        frame = {
          filename: "",
          function: ""
        };
      matches && (frame.function = matches[2]?.trim()?.replace(/^[^.]{1,2}(\.|$)/, "_$1") ?? frame.function, frame.filename = matches[4]?.trim() ?? frame.filename, matches[5] && matches[5] !== ":0" && (frame.lineno = matches[5].slice(1)), matches[6] && matches[5] !== ":0" && (frame.colno = matches[6].slice(1)), frame.in_app = !/[[<:]|(?:^|\/)node_modules\//.test(frame.filename)), exceptionDetail.stacktrace.push(frame);
    }
  }
  return exceptionDetail;
}
__name(buildExceptionDetail, "buildExceptionDetail");
function buildPayload(ctx, redactedError, properties = {}) {
  let buildInfo = ctx.get(BuildInfo),
    epinfo = ctx.get(EditorAndPluginInfo),
    payload = {
      app: "copilot-client",
      rollup_id: "auto",
      platform: "node",
      release: buildInfo.getBuildType() !== "dev" ? `copilot-client@${buildInfo.getVersion()}` : void 0,
      deployed_to: buildInfo.getBuildType(),
      catalog_service: epinfo.getEditorInfo().name === "vscode" ? "CopilotCompletionsVSCode" : "CopilotIDEAgent",
      context: {
        ...properties,
        "#editor": epinfo.getEditorInfo().name,
        "#editor_version": formatNameAndVersion(epinfo.getEditorInfo()),
        "#editor_remote_name": `${epinfo.getEditorInfo().name}/${epinfo.getEditorInfo().remoteName ?? "none"}`,
        "#plugin": epinfo.getEditorPluginInfo().name,
        "#plugin_version": formatNameAndVersion(epinfo.getEditorPluginInfo()),
        "#session_id": ctx.get(EditorSession).sessionId,
        "#machine_id": ctx.get(EditorSession).machineId,
        "#node_version": process.versions.node,
        "#architecture": r6.arch(),
        "#os_platform": r6.platform()
      },
      sensitive_context: {}
    },
    telemetryConfig = ctx.get(TelemetryUserConfig);
  telemetryConfig.trackingId && (payload.context.user = telemetryConfig.trackingId, payload.context["#tracking_id"] = telemetryConfig.trackingId);
  let exceptionsWithDetails = [];
  payload.exception_detail = [];
  let i = 0,
    exception = redactedError;
  for (; exception instanceof Error && i < 10;) {
    let detail = buildExceptionDetail(exception);
    payload.exception_detail.unshift(detail), exceptionsWithDetails.unshift([exception, detail]), i += 1, exception = exception.cause;
  }
  let rollup = [];
  for (let [exception, detail] of exceptionsWithDetails) if (detail.stacktrace && detail.stacktrace.length > 0) {
    rollup.push(`${detail.type}: ${exception.code ?? ""}`);
    let stacktrace = [...detail.stacktrace].reverse();
    for (let frame of stacktrace) if (frame.in_app) {
      rollup.push(`${frame.filename}:${frame.lineno}:${frame.colno}`);
      break;
    }
    rollup.push(`${stacktrace[0].filename}`);
  } else return payload;
  return payload.exception_detail.length > 0 && (payload.rollup_id = (0, t6.SHA256)(t6.enc.Utf16.parse(rollup.join(`
`))).toString()), payload;
}
__name(buildPayload, "buildPayload");
var RuntimeMode = class _RuntimeMode {
  constructor(flags) {
    this.flags = flags;
  }
  static {
    __name(this, "RuntimeMode");
  }
  static fromEnvironment(isRunningInTest) {
    return new _RuntimeMode({
      debug: determineDebugFlag(process.argv, process.env),
      verboseLogging: determineVerboseLoggingEnabled(process.env),
      telemetryLogging: determineTelemetryLoggingEnabled(process.env),
      testMode: isRunningInTest,
      recordInput: determineRecordInput(process.argv, process.env)
    });
  }
};
function isRunningInTest(ctx) {
  return ctx.get(RuntimeMode).flags.testMode;
}
__name(isRunningInTest, "isRunningInTest");
function shouldFailForDebugPurposes(ctx) {
  return isRunningInTest(ctx);
}
__name(shouldFailForDebugPurposes, "shouldFailForDebugPurposes");
function isVerboseLoggingEnabled(ctx) {
  return ctx.get(RuntimeMode).flags.verboseLogging;
}
__name(isVerboseLoggingEnabled, "isVerboseLoggingEnabled");
function determineDebugFlag(argv, env) {
  return argv.includes("--debug") || determineEnvFlagEnabled(env, "GITHUB_COPILOT_DEBUG");
}
__name(determineDebugFlag, "determineDebugFlag");
function determineVerboseLoggingEnabled(env) {
  return determineEnvFlagEnabled(env, "COPILOT_AGENT_VERBOSE");
}
__name(determineVerboseLoggingEnabled, "determineVerboseLoggingEnabled");
function determineTelemetryLoggingEnabled(env) {
  return determineEnvFlagEnabled(env, "COPILOT_LOG_TELEMETRY");
}
__name(determineTelemetryLoggingEnabled, "determineTelemetryLoggingEnabled");
function determineRecordInput(argv, env) {
  return argv.includes("--record") || determineEnvFlagEnabled(env, "GITHUB_COPILOT_RECORD");
}
__name(determineRecordInput, "determineRecordInput");
function determineEnvFlagEnabled(env, key) {
  if (key in env) {
    let val = env[key];
    return val === "1" || val?.toLowerCase() === "true";
  }
  return !1;
}
__name(determineEnvFlagEnabled, "determineEnvFlagEnabled");
var assert = Ns(require("assert"));
var Context = class {
  constructor(baseContext) {
    this.baseContext = baseContext;
    this.constructionStack = [];
    this.instances = new Map();
    let stack = new Error().stack?.split(`
`);
    stack && this.constructionStack.push(...stack.slice(1));
  }
  static {
    __name(this, "Context");
  }
  get(ctor) {
    let value = this.tryGet(ctor);
    if (value) return value;
    throw new Error(`No instance of ${ctor.name} has been registered.`);
  }
  tryGet(ctor) {
    let value = this.instances.get(ctor);
    if (value) return value;
    if (this.baseContext) return this.baseContext.tryGet(ctor);
  }
  set(ctor, instance) {
    if (this.tryGet(ctor)) throw new Error(`An instance of ${ctor.name} has already been registered. Use forceSet() if you're sure it's a good idea.`);
    this.assertIsInstance(ctor, instance), this.instances.set(ctor, instance);
  }
  forceSet(ctor, instance) {
    this.assertIsInstance(ctor, instance), this.instances.set(ctor, instance);
  }
  assertIsInstance(ctor, instance) {
    if (!(instance instanceof ctor)) {
      let inst = JSON.stringify(instance);
      throw new Error(`The instance you're trying to register for ${ctor.name} is not an instance of it (${inst}).`);
    }
  }
  toString() {
    let lines = `    Context created at:
`;
    for (let stackEntry of this.constructionStack || []) lines += `    ${stackEntry}
`;
    return lines += this.baseContext?.toString() ?? "", lines;
  }
};
var appInsights = Ns(TJ()),
  os = Ns(require("os")),
  import_stream = require("stream");
var IngestionEndpointPattern = /^https:\/\/[^.]*\.in\.applicationinsights\.azure\.com\//,
  Util = il(),
  originalMakeRequest = Util.makeRequest.bind(Util),
  AzureInsightReporter = class {
    constructor(ctx, namespace, key) {
      this.namespace = namespace;
      this.client = createAppInsightsClient(ctx, key), configureReporter(ctx, this.client), ctx.get(CopilotTokenNotifier).on("onCopilotToken", copilotToken => {
        let userId = copilotToken.getTokenValue("tid");
        userId !== void 0 && updateReporterUserId(userId, this.client);
      });
    }
    static {
      __name(this, "AzureInsightReporter");
    }
    sendTelemetryEvent(eventName, properties, measurements) {
      this.client.trackEvent({
        name: this.qualifyEventName(eventName),
        properties: properties,
        measurements: measurements
      });
    }
    sendTelemetryErrorEvent(eventName, properties, measurements) {
      this.sendTelemetryEvent(this.qualifyEventName(eventName), properties, measurements);
    }
    sendTelemetryException(error, properties, measurements) {
      this.client.trackException({
        exception: error,
        properties: properties,
        measurements: measurements
      });
    }
    dispose() {
      return new Promise(resolve => {
        this.client.flush({
          callback: s => {
            resolve(void 0);
          }
        });
      });
    }
    qualifyEventName(eventName) {
      return eventName.startsWith(this.namespace) ? eventName : `${this.namespace}/${eventName}`;
    }
  };
function monkeyPatchMakeRequest(ctx) {
  Util.makeRequest = function (config, requestUrl, requestOptions, requestCallback, ...rest) {
    if (!ctx.get(Fetcher).proxySettings) return originalMakeRequest(config, requestUrl, requestOptions, requestCallback, ...rest);
    requestUrl && requestUrl.indexOf("//") === 0 && (requestUrl = "https:" + requestUrl);
    let fakeResponse = new $N.EventEmitter();
    fakeResponse.setEncoding = () => fakeResponse;
    let fakeRequest = new $N.EventEmitter(),
      body;
    return fakeRequest.write = (chunk, _, __) => {
      body = chunk;
    }, fakeRequest.end = () => {
      if (requestUrl.includes("169.254.169.254")) return fakeRequest.emit("error", new Error("UNREACH")), fakeRequest;
      if (IngestionEndpointPattern.test(requestUrl)) return fakeRequest.emit("error", new Error("UNKNOWN")), fakeRequest;
      let method = requestOptions.method,
        headers = requestOptions.headers;
      return ctx.get(Fetcher).fetch(requestUrl, {
        method: method,
        headers: headers,
        body: body
      }).then(res => {
        res.text().then(text => {
          fakeResponse.emit("data", text), fakeResponse.emit("end");
        });
      }).catch(err => {
        fakeRequest.emit("error", err);
      }), fakeRequest;
    }, fakeRequest.setTimeout = () => fakeRequest, fakeRequest.abort = () => {}, requestCallback(fakeResponse), fakeRequest;
  };
}
__name(monkeyPatchMakeRequest, "monkeyPatchMakeRequest");
function createAppInsightsClient(ctx, key) {
  monkeyPatchMakeRequest(ctx);
  let client = new SJ.TelemetryClient(key);
  return client.config.enableAutoCollectRequests = !1, client.config.enableAutoCollectPerformance = !1, client.config.enableAutoCollectExceptions = !1, client.config.enableAutoCollectConsole = !1, client.config.enableAutoCollectDependencies = !1, client.config.noDiagnosticChannel = !0, configureReporter(ctx, client), client;
}
__name(createAppInsightsClient, "createAppInsightsClient");
function configureReporter(ctx, client) {
  client.commonProperties = decorateWithCommonProperties(client.commonProperties, ctx);
  let editorSession = ctx.get(EditorSession);
  client.context.tags[client.context.keys.sessionId] = editorSession.sessionId;
  let telemetryConfig = ctx.get(TelemetryUserConfig);
  telemetryConfig.trackingId && (client.context.tags[client.context.keys.userId] = telemetryConfig.trackingId), client.context.tags[client.context.keys.cloudRoleInstance] = "REDACTED", client.config.endpointUrl = ctx.get(TelemetryEndpointUrl).getUrl();
}
__name(configureReporter, "configureReporter");
function updateReporterUserId(userId, client) {
  client.context.tags[client.context.keys.userId] = userId;
}
__name(updateReporterUserId, "updateReporterUserId");
function decorateWithCommonProperties(properties, ctx) {
  properties = properties || {}, properties.common_os = Ex.platform(), properties.common_platformversion = Ex.release();
  let editorSession = ctx.get(EditorSession);
  return properties.common_vscodemachineid = editorSession.machineId, properties.common_vscodesessionid = editorSession.sessionId, properties.common_uikind = "desktop", properties.common_remotename = "none", properties.common_isnewappinstall = "", properties;
}
__name(decorateWithCommonProperties, "decorateWithCommonProperties");
var APP_INSIGHTS_KEY = "7d7048df-6dd0-4048-bb23-b716c1461f8f",
  APP_INSIGHTS_KEY_SECURE = "3fdd7f28-937a-48c8-9a21-ba337db23bd1",
  APP_INSIGHTS_KEY_FT = "f0000000-0000-0000-0000-000000000000";
async function setupTelemetryReporters(ctx, telemetryNamespace, telemetryEnabled) {
  let deactivation = ctx.get(TelemetryReporters).deactivate();
  if (telemetryEnabled) {
    let container = ctx.get(TelemetryReporters),
      reporter = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY);
    container.setReporter(reporter);
    let reporterRestricted = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY_SECURE);
    container.setRestrictedReporter(reporterRestricted);
    let reporterFt = new AzureInsightReporter(ctx, telemetryNamespace, APP_INSIGHTS_KEY_FT);
    container.setFTReporter(reporterFt);
  }
  await deactivation;
}
__name(setupTelemetryReporters, "setupTelemetryReporters");
var path = Ns(require("path")),
  import_worker_threads = require("worker_threads");
var path = Ns(require("path")),
  packageRoot = H4.basename(__dirname) === "dist" ? H4.resolve(__dirname, "..") : H4.resolve(__dirname, "..", "..", "..");
var fakeTelemetryServerPortPromise;
async function startFakeTelemetryServerIfNecessary() {
  return fakeTelemetryServerPortPromise === void 0 && (fakeTelemetryServerPortPromise = new Promise((r, err) => {
    console.warn("Launching fake telemetry server");
    let fakeTelemetryServer = new NJ.Worker(RJ.join(packageRoot, "lib", "src", "testing", "telemetryFakeWorker.js"));
    fakeTelemetryServer.on("message", ({
      port: port
    }) => {
      console.warn(`Telemetry server ready on port ${port}`), r(port);
    }), fakeTelemetryServer.on("error", err);
  })), fakeTelemetryServerPortPromise;
}
__name(startFakeTelemetryServerIfNecessary, "startFakeTelemetryServerIfNecessary");
var PromiseQueue = class {
    static {
      __name(this, "PromiseQueue");
    }
    async register(promise) {
      return promise;
    }
  },
  TestPromiseQueue = class extends PromiseQueue {
    constructor() {
      super(...arguments);
      this.promises = [];
    }
    static {
      __name(this, "TestPromiseQueue");
    }
    async register(promise) {
      return this.promises.push(promise), promise;
    }
    async awaitPromises() {
      await Promise.all(this.promises);
    }
  };
async function collectCapturedTelemetry(ctx) {
  let url = ctx.get(TelemetryEndpointUrl).getUrl(),
    messages = (await (await ctx.get(Fetcher).fetch(url, {})).json()).messages ?? [];
  for (let message of messages) WN.strictEqual(message.tags["ai.cloud.roleInstance"], "REDACTED");
  return messages;
}
__name(collectCapturedTelemetry, "collectCapturedTelemetry");
async function withInlineTelemetryCapture(ctx, work) {
  return _withTelemetryCapture(ctx, !0, work);
}
__name(withInlineTelemetryCapture, "withInlineTelemetryCapture");
async function _withTelemetryCapture(ctx, forceTelemetry, work) {
  let port = await startFakeTelemetryServerIfNecessary(),
    extensionId = "copilot-test",
    endpoint = Math.floor(Math.random() * 1e5).toString();
  delete process.env.http_proxy, delete process.env.https_proxy;
  let oldUrl = ctx.get(TelemetryEndpointUrl).getUrl();
  ctx.get(TelemetryEndpointUrl).setUrlForTesting(`http://localhost:${port}/${endpoint}`), setupTelemetryReporters(ctx, extensionId, forceTelemetry);
  try {
    let queue = new TestPromiseQueue();
    ctx.forceSet(PromiseQueue, queue);
    let result = await work(ctx);
    return await queue.awaitPromises(), await ctx.get(TelemetryReporters).deactivate(), [await collectMessagesWithRetry(ctx), result];
  } finally {
    ctx.get(TelemetryEndpointUrl).setUrlForTesting(oldUrl);
  }
}
__name(_withTelemetryCapture, "_withTelemetryCapture");
async function collectMessagesWithRetry(ctx) {
  for (let waitTimeMultiplier = 0; waitTimeMultiplier < 3; waitTimeMultiplier++) {
    await new Promise(resolve => setTimeout(resolve, waitTimeMultiplier * 1e3));
    let messages = await collectCapturedTelemetry(ctx);
    if (messages.length > 0) return messages;
    console.warn("Retrying to collect telemetry messages #" + (waitTimeMultiplier + 1));
  }
  return [];
}
__name(collectMessagesWithRetry, "collectMessagesWithRetry");
var FailingTelemetryReporter = class {
  static {
    __name(this, "FailingTelemetryReporter");
  }
  sendTelemetryEvent(eventName, properties, measurements) {
    throw new Error("Telemetry disabled");
  }
  sendTelemetryErrorEvent(eventName, properties, measurements, errorProps) {
    throw new Error("Telemetry disabled");
  }
  sendTelemetryException(error, properties, measurements) {
    throw new Error("Telemetry disabled");
  }
  dispose() {
    return Promise.resolve();
  }
  hackOptOutListener() {}
};
var import_os = require("os"),
  path = Ns(require("path"));
function redactPaths(input) {
  return input.replace(/([\s|(]|file:\/\/)(\/[^\s]+)/g, "$1[redacted]").replace(/([\s|(]|file:\/\/)([a-zA-Z]:[\\/]{1,2}[^\s]+)/gi, "$1[redacted]").replace(/([\s|(]|file:\/\/)(\\[^\s]+)/gi, "$1[redacted]");
}
__name(redactPaths, "redactPaths");
function escapeForRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeForRegExp, "escapeForRegExp");
var homedirRegExp = new RegExp("(?<=^|[\\s|(\"'`]|file://)" + escapeForRegExp((0, MJ.homedir)()) + "(?=$|[\\\\/:\"'`])", "gi");
function redactHomeDir(input) {
  return input.replace(homedirRegExp, "~");
}
__name(redactHomeDir, "redactHomeDir");
var relativePathSuffix = "[\\\\/]?([^:)]*)(?=:\\d)",
  pathSepRegExp = new RegExp(escapeForRegExp(BJ.sep), "g"),
  rootDirRegExp = new RegExp(escapeForRegExp(__dirname.replace(/[\\/]lib[\\/]src[\\/]util$|[\\/]dist$/, "")) + relativePathSuffix, "gi");
function cloneError(original, prepareMessage, allowUnknownPaths = !1, replacements = []) {
  let error = new Error(prepareMessage(original));
  error.name = original.name, typeof original.syscall == "string" && (error.syscall = original.syscall), typeof original.code == "string" && (error.code = original.code), typeof original.errno == "number" && (error.errno = original.errno), error.stack = void 0;
  let originalStack = original.stack?.replace(/^.*?:\d+\n.*\n *\^?\n\n/, "");
  if (originalStack?.startsWith(original.toString() + `
`)) {
    error.stack = error.toString();
    for (let frame of originalStack.slice(original.toString().length + 1).split(/\n/)) if (rootDirRegExp.test(frame)) error.stack += `
${redactPaths(frame.replace(rootDirRegExp, (_, relative) => relative.replace(pathSepRegExp, "/")))}`;else if (/[ (]node:|[ (]wasm:\/\/wasm\/| \(<anonymous>\)$/.test(frame)) error.stack += `
${redactPaths(frame)}`;else {
      let found = !1;
      for (let {
        prefix: prefix,
        path: dir
      } of replacements) {
        let dirRegExp = new RegExp(escapeForRegExp(dir.replace(/[\\/]$/, "")) + relativePathSuffix, "gi");
        if (dirRegExp.test(frame)) {
          error.stack += `
${redactPaths(frame.replace(dirRegExp, (_, relative) => prefix + relative.replace(pathSepRegExp, "/")))}`, found = !0;
          break;
        }
      }
      if (found) continue;
      allowUnknownPaths ? error.stack += `
${redactHomeDir(frame)}` : error.stack += `
    at [redacted]:0:0`;
    }
  } else allowUnknownPaths && originalStack && (error.stack = redactHomeDir(originalStack));
  return original.cause instanceof Error && (error.cause = cloneError(original.cause, prepareMessage, allowUnknownPaths, replacements)), error;
}
__name(cloneError, "cloneError");
function prepareErrorForRestrictedTelemetry(original, replacements) {
  return cloneError(original, __name(function (e) {
    let message = e.message;
    return typeof e.path == "string" && e.path.length > 0 && (message = message.replaceAll(e.path, "<path>")), redactHomeDir(message);
  }, "prepareMessage"), !0, replacements);
}
__name(prepareErrorForRestrictedTelemetry, "prepareErrorForRestrictedTelemetry");
function redactError(original, replacements) {
  return cloneError(original, __name(function (e) {
    let message = "[redacted]";
    return e.syscall && e.code !== void 0 ? message = `${redactPaths(e.syscall.toString())} ${e.code} ${message}` : e instanceof FetchError && e.erroredSysCall && e.code !== void 0 ? message = `${e.erroredSysCall} ${e.code} ${message}` : e.code !== void 0 && (message = `${e.code} ${message}`), message;
  }, "redactMessage"), !1, replacements);
}
__name(redactError, "redactError");
function isRestricted(store) {
  return store === 1;
}
__name(isRestricted, "isRestricted");
var ftTelemetryEvents = ["engine.prompt", "engine.completion", "ghostText.capturedAfterAccepted", "ghostText.capturedAfterRejected"];
var TelemetryReporters = class {
  static {
    __name(this, "TelemetryReporters");
  }
  getReporter(ctx, store = 0) {
    return isRestricted(store) ? this.getRestrictedReporter(ctx) : this.reporter;
  }
  getRestrictedReporter(ctx) {
    if (shouldSendRestricted(ctx)) return this.reporterRestricted;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  getFTReporter(ctx) {
    if (shouldSendFinetuningTelemetry(ctx)) return this.reporterFT;
    if (shouldFailForDebugPurposes(ctx)) return new FailingTelemetryReporter();
  }
  setReporter(reporter) {
    this.reporter = reporter;
  }
  setRestrictedReporter(reporter) {
    this.reporterRestricted = reporter;
  }
  setFTReporter(reporter) {
    this.reporterFT = reporter;
  }
  async deactivate() {
    let disposeReporter = Promise.resolve();
    this.reporter && (disposeReporter = this.reporter.dispose(), this.reporter = void 0);
    let disposeReporterRestricted = Promise.resolve();
    this.reporterRestricted && (disposeReporterRestricted = this.reporterRestricted.dispose(), this.reporterRestricted = void 0);
    let disposeReporterFT = Promise.resolve();
    this.reporterFT && (disposeReporterFT = this.reporterFT.dispose(), this.reporterFT = void 0), await Promise.all([disposeReporter, disposeReporterRestricted, disposeReporterFT]);
  }
};
HJ.TypeSystem.AllowNaN = !0;
var propertiesSchema = jd.Type.Object({}, {
    additionalProperties: jd.Type.String()
  }),
  measurementsSchema = jd.Type.Object({
    meanLogProb: jd.Type.Optional(jd.Type.Number()),
    meanAlternativeLogProb: jd.Type.Optional(jd.Type.Number())
  }, {
    additionalProperties: jd.Type.Number()
  }),
  oomCodes = new Set(["ERR_WORKER_OUT_OF_MEMORY", "ENOMEM"]);
function isOomError(error) {
  return oomCodes.has(error.code ?? "") || error.name === "RangeError" && error.message === "WebAssembly.Memory(): could not allocate memory";
}
__name(isOomError, "isOomError");
function getErrorType(error) {
  return isNetworkError(error) ? "network" : isOomError(error) || error.code === "EMFILE" || error.code === "ENFILE" || error.syscall === "uv_cwd" && (error.code === "ENOENT" || error.code == "EIO") || error.code === "CopilotPromptLoadFailure" || `${error.code}`.startsWith("CopilotPromptWorkerExit") ? "local" : "exception";
}
__name(getErrorType, "getErrorType");
var TelemetryData = class _TelemetryData {
  static {
    __name(this, "TelemetryData");
  }
  static {
    this.validateTelemetryProperties = YN.TypeCompiler.Compile(propertiesSchema);
  }
  static {
    this.validateTelemetryMeasurements = YN.TypeCompiler.Compile(measurementsSchema);
  }
  static {
    this.keysExemptedFromSanitization = ["abexp.assignmentcontext", "VSCode.ABExp.Features"];
  }
  constructor(properties, measurements, issuedTime) {
    this.properties = properties, this.measurements = measurements, this.issuedTime = issuedTime;
  }
  static createAndMarkAsIssued(properties, measurements) {
    return new _TelemetryData(properties || {}, measurements || {}, now());
  }
  extendedBy(properties, measurements) {
    let newProperties = {
        ...this.properties,
        ...properties
      },
      newMeasurements = {
        ...this.measurements,
        ...measurements
      },
      newData = new _TelemetryData(newProperties, newMeasurements, this.issuedTime);
    return newData.displayedTime = this.displayedTime, newData.filtersAndExp = this.filtersAndExp, newData;
  }
  markAsDisplayed() {
    this.displayedTime === void 0 && (this.displayedTime = now());
  }
  async extendWithExpTelemetry(ctx) {
    this.filtersAndExp || (await ctx.get(Features).addExpAndFilterToTelemetry(this)), this.filtersAndExp.exp.addToTelemetry(this), this.filtersAndExp.filters.addToTelemetry(this);
  }
  extendWithEditorAgnosticFields(ctx) {
    this.properties.editor_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorInfo()), this.properties.editor_plugin_version = formatNameAndVersion(ctx.get(EditorAndPluginInfo).getEditorPluginInfo());
    let editorSession = ctx.get(EditorSession);
    this.properties.client_machineid = editorSession.machineId, this.properties.client_sessionid = editorSession.sessionId, this.properties.copilot_version = `copilot/${getVersion(ctx)}`, this.properties.runtime_version = `node/${process.versions.node}`;
    let editorInfo = ctx.get(EditorAndPluginInfo);
    this.properties.common_extname = editorInfo.getEditorPluginInfo().name, this.properties.common_extversion = editorInfo.getEditorPluginInfo().version, this.properties.common_vscodeversion = formatNameAndVersion(editorInfo.getEditorInfo());
    let fetcher = ctx.get(Fetcher),
      proxySettings = fetcher.proxySettings;
    this.properties.proxy_enabled = proxySettings ? "true" : "false", this.properties.proxy_auth = proxySettings?.proxyAuth ? "true" : "false", this.properties.proxy_kerberos_spn = proxySettings?.kerberosServicePrincipal ? "true" : "false", this.properties.reject_unauthorized = fetcher.rejectUnauthorized ? "true" : "false";
  }
  extendWithConfigProperties(ctx) {
    let configProperties = dumpConfig(ctx);
    configProperties["copilot.build"] = getBuild(ctx), configProperties["copilot.buildType"] = getBuildType(ctx);
    let telemetryConfig = ctx.get(TelemetryUserConfig);
    telemetryConfig.trackingId && (configProperties["copilot.trackingId"] = telemetryConfig.trackingId), telemetryConfig.organizationsList && (configProperties.organizations_list = telemetryConfig.organizationsList), telemetryConfig.enterpriseList && (configProperties.enterprise_list = telemetryConfig.enterpriseList), telemetryConfig.sku && (configProperties.sku = telemetryConfig.sku), this.properties = {
      ...this.properties,
      ...configProperties
    };
  }
  extendWithRequestId(requestId) {
    let requestProperties = {
      completionId: requestId.completionId,
      created: requestId.created.toString(),
      headerRequestId: requestId.headerRequestId,
      serverExperiments: requestId.serverExperiments,
      deploymentId: requestId.deploymentId
    };
    this.properties = {
      ...this.properties,
      ...requestProperties
    };
  }
  static {
    this.keysToRemoveFromStandardTelemetryHack = ["gitRepoHost", "gitRepoName", "gitRepoOwner", "gitRepoUrl", "gitRepoPath", "repo", "request_option_nwo", "userKind"];
  }
  static maybeRemoveRepoInfoFromPropertiesHack(store, map) {
    if (isRestricted(store)) return map;
    let returnValue = {};
    for (let key in map) _TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(key) || (returnValue[key] = map[key]);
    return returnValue;
  }
  sanitizeKeys() {
    this.properties = _TelemetryData.sanitizeKeys(this.properties), this.measurements = _TelemetryData.sanitizeKeys(this.measurements);
  }
  static sanitizeKeys(map) {
    map = map || {};
    let returnValue = {};
    for (let key in map) {
      let newKey = _TelemetryData.keysExemptedFromSanitization.includes(key) ? key : key.replace(/\./g, "_");
      returnValue[newKey] = map[key];
    }
    return returnValue;
  }
  updateTimeSinceIssuedAndDisplayed() {
    let timeSinceIssued = now() - this.issuedTime;
    if (this.measurements.timeSinceIssuedMs = timeSinceIssued, this.displayedTime !== void 0) {
      let timeSinceDisplayed = now() - this.displayedTime;
      this.measurements.timeSinceDisplayedMs = timeSinceDisplayed;
    }
  }
  validateData(ctx, store) {
    let invalid;
    if (_TelemetryData.validateTelemetryProperties.Check(this.properties) || (invalid = {
      problem: "properties",
      error: JSON.stringify([..._TelemetryData.validateTelemetryProperties.Errors(this.properties)])
    }), !_TelemetryData.validateTelemetryMeasurements.Check(this.measurements)) {
      let m_err = JSON.stringify([..._TelemetryData.validateTelemetryMeasurements.Errors(this.measurements)]);
      invalid === void 0 ? invalid = {
        problem: "measurements",
        error: m_err
      } : (invalid.problem = "both", invalid.error += `; ${m_err}`);
    }
    if (invalid === void 0) return !0;
    if (shouldFailForDebugPurposes(ctx)) throw new Error(`Invalid telemetry data: ${invalid.problem} ${invalid.error} properties=${JSON.stringify(this.properties)} measurements=${JSON.stringify(this.measurements)}`);
    return telemetryError(ctx, "invalidTelemetryData", _TelemetryData.createAndMarkAsIssued({
      properties: JSON.stringify(this.properties),
      measurements: JSON.stringify(this.measurements),
      problem: invalid.problem,
      validationError: invalid.error
    }), store), isRestricted(store) && telemetryError(ctx, "invalidTelemetryData_in_secure", _TelemetryData.createAndMarkAsIssued({
      problem: invalid.problem,
      requestId: this.properties.requestId ?? "unknown"
    }), 0), !1;
  }
  async makeReadyForSending(ctx, store, includeExp) {
    this.extendWithConfigProperties(ctx), this.extendWithEditorAgnosticFields(ctx), this.sanitizeKeys(), includeExp === "IncludeExp" && (await this.extendWithExpTelemetry(ctx)), this.updateTimeSinceIssuedAndDisplayed(), this.validateData(ctx, store) || (this.properties.telemetry_failed_validation = "true"), addRequiredProperties(ctx, this.properties);
  }
};
function sendTelemetryEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryEvent, "sendTelemetryEvent");
function sendTelemetryException(ctx, store, error, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryException(error, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryException, "sendTelemetryException");
function sendTelemetryErrorEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getReporter(ctx, store)?.sendTelemetryErrorEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendTelemetryErrorEvent, "sendTelemetryErrorEvent");
function sendFTTelemetryEvent(ctx, store, name, data) {
  ctx.get(TelemetryReporters).getFTReporter(ctx)?.sendTelemetryEvent(name, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(store, data.properties), data.measurements);
}
__name(sendFTTelemetryEvent, "sendFTTelemetryEvent");
function telemetrizePromptLength(prompt) {
  return prompt.isFimEnabled ? {
    promptPrefixCharLen: prompt.prefix.length,
    promptSuffixCharLen: prompt.suffix.length
  } : {
    promptCharLen: prompt.prefix.length
  };
}
__name(telemetrizePromptLength, "telemetrizePromptLength");
function now() {
  return new Date().getTime();
}
__name(now, "now");
var COPILOT_TELEMETRY_SERVICE_ENDPOINT = "https://copilot-telemetry.githubusercontent.com/telemetry",
  TelemetryEndpointUrl = class {
    constructor(url = COPILOT_TELEMETRY_SERVICE_ENDPOINT) {
      this.url = url;
    }
    static {
      __name(this, "TelemetryEndpointUrl");
    }
    getUrl() {
      return this.url;
    }
    setUrlForTesting(url) {
      this.url = url;
    }
  };
function shouldSendRestricted(ctx) {
  return ctx.get(TelemetryUserConfig).optedIn;
}
__name(shouldSendRestricted, "shouldSendRestricted");
function shouldSendFinetuningTelemetry(ctx) {
  return ctx.get(TelemetryUserConfig).ftFlag !== "";
}
__name(shouldSendFinetuningTelemetry, "shouldSendFinetuningTelemetry");
async function telemetry(ctx, name, telemetryData, store) {
  await ctx.get(PromiseQueue).register(_telemetry(ctx, name, telemetryData, store));
}
__name(telemetry, "telemetry");
async function _telemetry(ctx, name, telemetryData, store = 0) {
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store ?? !1, "IncludeExp"), (!isRestricted(store) || shouldSendRestricted(ctx)) && sendTelemetryEvent(ctx, store, name, definedTelemetryData), isRestricted(store) && ftTelemetryEvents.includes(name) && shouldSendFinetuningTelemetry(ctx) && sendFTTelemetryEvent(ctx, store, name, definedTelemetryData);
}
__name(_telemetry, "_telemetry");
async function telemetryExpProblem(ctx, telemetryProperties) {
  await ctx.get(PromiseQueue).register(_telemetryExpProblem(ctx, telemetryProperties));
}
__name(telemetryExpProblem, "telemetryExpProblem");
async function _telemetryExpProblem(ctx, telemetryProperties) {
  let name = "expProblem",
    definedTelemetryData = TelemetryData.createAndMarkAsIssued(telemetryProperties, {});
  await definedTelemetryData.makeReadyForSending(ctx, 0, "SkipExp"), sendTelemetryEvent(ctx, 0, name, definedTelemetryData);
}
__name(_telemetryExpProblem, "_telemetryExpProblem");
async function telemetryRaw(ctx, name, properties, measurements) {
  await ctx.get(PromiseQueue).register(_telemetryRaw(ctx, name, properties, measurements));
}
__name(telemetryRaw, "telemetryRaw");
async function _telemetryRaw(ctx, name, properties, measurements) {
  addRequiredProperties(ctx, properties), sendTelemetryEvent(ctx, 0, name, {
    properties: properties,
    measurements: measurements
  });
}
__name(_telemetryRaw, "_telemetryRaw");
function addRequiredProperties(ctx, properties) {
  properties.unique_id = v4_default();
  let editorInfo = ctx.get(EditorAndPluginInfo);
  properties.common_extname = editorInfo.getEditorPluginInfo().name, properties.common_extversion = editorInfo.getEditorPluginInfo().version, properties.common_vscodeversion = formatNameAndVersion(editorInfo.getEditorInfo());
}
__name(addRequiredProperties, "addRequiredProperties");
var CopilotNonError = class extends Error {
  static {
    __name(this, "CopilotNonError");
  }
  constructor(thrown) {
    let message;
    try {
      message = JSON.stringify(thrown);
    } catch {
      message = thrown.toString();
    }
    super(message), this.name = "CopilotNonError";
  }
};
async function telemetryException(ctx, maybeError, origin, properties) {
  let error;
  if (maybeError instanceof Error) {
    if (error = maybeError, error.name === "Canceled" && error.message === "Canceled" || error.name === "CodeExpectedError" || error instanceof CopilotAuthError) return;
  } else if (error = new CopilotNonError(maybeError), error.stack?.startsWith(`${error}
`)) {
    let frames = error.stack.slice(`${error}
`.length).split(`
`);
    /^\s*(?:at )?(?:\w+\.)*telemetryException\b/.test(frames[0]) && frames.shift(), error.stack = `${error}
${frames.join(`
`)}`;
  }
  await ctx.get(PromiseQueue).register(_telemetryException(ctx, error, origin, properties));
}
__name(telemetryException, "telemetryException");
async function _telemetryException(ctx, error, origin, properties) {
  let editorInfo = ctx.get(EditorAndPluginInfo).getEditorInfo(),
    stackPaths;
  editorInfo.root && (stackPaths = [{
    prefix: `${editorInfo.name}:`,
    path: editorInfo.root
  }]);
  let redactedError = redactError(error, stackPaths),
    sendRestricted = shouldSendRestricted(ctx),
    errorType = getErrorType(error),
    sendAsException = errorType === "exception",
    definedTelemetryDataStub = TelemetryData.createAndMarkAsIssued({
      origin: redactPaths(origin),
      type: error.name,
      code: `${error.code ?? ""}`,
      reason: redactedError.stack || redactedError.toString(),
      message: redactedError.message,
      ...properties
    });
  await definedTelemetryDataStub.makeReadyForSending(ctx, 0, "IncludeExp");
  let failbotPayload = buildPayload(ctx, redactedError, {
    "#origin": origin,
    "copilot_event.unique_id": definedTelemetryDataStub.properties.unique_id,
    "#restricted_telemetry": sendRestricted ? "true" : "false"
  });
  if (failbotPayload.rollup_id !== "auto" && (definedTelemetryDataStub.properties.errno = failbotPayload.rollup_id), failbotPayload.created_at = new Date(definedTelemetryDataStub.issuedTime).toISOString(), sendRestricted) {
    let restrictedError = prepareErrorForRestrictedTelemetry(error, stackPaths),
      definedTelemetryDataRestricted = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        type: error.name,
        code: `${error.code ?? ""}`,
        reason: restrictedError.stack || restrictedError.toString(),
        message: restrictedError.message,
        ...properties
      });
    failbotPayload.rollup_id !== "auto" && (definedTelemetryDataRestricted.properties.errno = failbotPayload.rollup_id), await definedTelemetryDataRestricted.makeReadyForSending(ctx, 1, "IncludeExp"), definedTelemetryDataRestricted.properties.unique_id = definedTelemetryDataStub.properties.unique_id, definedTelemetryDataStub.properties.restricted_unique_id = definedTelemetryDataRestricted.properties.unique_id, sendAsException && sendTelemetryException(ctx, 1, restrictedError, definedTelemetryDataRestricted), sendTelemetryEvent(ctx, 1, `error.${errorType}`, definedTelemetryDataRestricted);
  }
  sendAsException && (sendTelemetryException(ctx, 0, redactedError, definedTelemetryDataStub), definedTelemetryDataStub.properties.failbot_payload = JSON.stringify(failbotPayload)), sendTelemetryEvent(ctx, 0, `error.${errorType}`, definedTelemetryDataStub);
}
__name(_telemetryException, "_telemetryException");
async function telemetryError(ctx, name, telemetryData, store) {
  await ctx.get(PromiseQueue).register(_telemetryError(ctx, name, telemetryData, store));
}
__name(telemetryError, "telemetryError");
async function _telemetryError(ctx, name, telemetryData, store = 0) {
  if (isRestricted(store) && !shouldSendRestricted(ctx)) return;
  let definedTelemetryData = telemetryData || TelemetryData.createAndMarkAsIssued({}, {});
  await definedTelemetryData.makeReadyForSending(ctx, store, "IncludeExp"), sendTelemetryErrorEvent(ctx, store, name, definedTelemetryData);
}
__name(_telemetryError, "_telemetryError");
async function logEngineCompletion(ctx, completionText, jsonData, requestId, choiceIndex) {
  let telemetryData = TelemetryData.createAndMarkAsIssued({
    completionTextJson: JSON.stringify(completionText),
    choiceIndex: choiceIndex.toString()
  });
  if (jsonData.logprobs) for (let [key, value] of Object.entries(jsonData.logprobs)) telemetryData.properties["logprobs_" + key] = JSON.stringify(value) ?? "unset";
  telemetryData.extendWithRequestId(requestId), await telemetry(ctx, "engine.completion", telemetryData, 1);
}
__name(logEngineCompletion, "logEngineCompletion");
async function logEnginePrompt(ctx, prompt, telemetryData) {
  let promptTelemetry;
  prompt.isFimEnabled ? promptTelemetry = {
    promptPrefixJson: JSON.stringify(prompt.prefix),
    promptSuffixJson: JSON.stringify(prompt.suffix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  } : promptTelemetry = {
    promptJson: JSON.stringify(prompt.prefix),
    promptElementRanges: JSON.stringify(prompt.promptElementRanges)
  };
  let telemetryDataWithPrompt = telemetryData.extendedBy(promptTelemetry);
  await telemetry(ctx, "engine.prompt", telemetryDataWithPrompt, 1);
}
__name(logEnginePrompt, "logEnginePrompt");
var ExpConfig = class _ExpConfig {
  static {
    __name(this, "ExpConfig");
  }
  constructor(variables, assignmentContext, features) {
    this.variables = variables, this.assignmentContext = assignmentContext, this.features = features;
  }
  static createFallbackConfig(ctx, reason) {
    return telemetryExpProblem(ctx, {
      reason: reason
    }), this.createEmptyConfig();
  }
  static createEmptyConfig() {
    return new _ExpConfig({}, "", "");
  }
  addToTelemetry(telemetryData) {
    telemetryData.properties["VSCode.ABExp.Features"] = this.features, telemetryData.properties["abexp.assignmentcontext"] = this.assignmentContext;
  }
};
var ExpConfigMaker = class {
    static {
      __name(this, "ExpConfigMaker");
    }
  },
  ExpConfigFromTAS = class extends ExpConfigMaker {
    static {
      __name(this, "ExpConfigFromTAS");
    }
    async fetchExperiments(ctx, filterHeaders) {
      let fetcher = ctx.get(Fetcher),
        resp;
      try {
        resp = await fetcher.fetch("https://default.exp-tas.com/vscode/ab", {
          method: "GET",
          headers: filterHeaders
        });
      } catch (e) {
        return ExpConfig.createFallbackConfig(ctx, `Error fetching ExP config: ${e}`);
      }
      if (!resp.ok) return ExpConfig.createFallbackConfig(ctx, `ExP responded with ${resp.status}`);
      let json;
      try {
        json = await resp.json();
      } catch (e) {
        if (e instanceof SyntaxError) return telemetryException(ctx, e, "fetchExperiments"), ExpConfig.createFallbackConfig(ctx, "ExP responded with invalid JSON");
        throw e;
      }
      let vscodeConfig = json.Configs.find(c => c.Id === "vscode") ?? {
          Id: "vscode",
          Parameters: {}
        },
        features = Object.entries(vscodeConfig.Parameters).map(([name, value]) => name + (value ? "" : "cf"));
      return new ExpConfig(vscodeConfig.Parameters, json.AssignmentContext, features.join(";"));
    }
  },
  ExpConfigNone = class extends ExpConfigMaker {
    static {
      __name(this, "ExpConfigNone");
    }
    async fetchExperiments(ctx, filterHeaders) {
      return ExpConfig.createEmptyConfig();
    }
  };
var telmetryNames = {
    "X-Copilot-ClientTimeBucket": "timeBucket",
    "X-Copilot-OverrideEngine": "engine",
    "X-Copilot-Repository": "repo",
    "X-Copilot-FileType": "fileType",
    "X-Copilot-UserKind": "userKind"
  },
  FilterSettings = class _FilterSettings {
    constructor(filters) {
      this.filters = filters;
      for (let [filter, value] of Object.entries(this.filters)) value === "" && delete this.filters[filter];
    }
    static {
      __name(this, "FilterSettings");
    }
    extends(otherFilterSettings) {
      for (let [filter, value] of Object.entries(otherFilterSettings.filters)) if (this.filters[filter] !== value) return !1;
      return !0;
    }
    addToTelemetry(telemetryData) {
      for (let [filter, value] of Object.entries(this.filters)) {
        let telemetryName = telmetryNames[filter];
        telemetryName !== void 0 && (telemetryData.properties[telemetryName] = value);
      }
    }
    stringify() {
      let keys = Object.keys(this.filters);
      return keys.sort(), keys.map(key => `${key}:${this.filters[key]}`).join(";");
    }
    toHeaders() {
      return {
        ...this.filters
      };
    }
    withChange(filter, value) {
      return new _FilterSettings({
        ...this.filters,
        [filter]: value
      });
    }
  };
var GranularityImplementation = class {
    constructor(prefix) {
      this.prefix = prefix;
    }
    static {
      __name(this, "GranularityImplementation");
    }
    getCurrentAndUpComingValues(now) {
      let currentValue = this.getValue(now),
        upcomingValues = this.getUpcomingValues(now);
      return [currentValue, upcomingValues];
    }
  },
  ConstantGranularity = class extends GranularityImplementation {
    static {
      __name(this, "ConstantGranularity");
    }
    getValue(now) {
      return this.prefix;
    }
    getUpcomingValues(now) {
      return [];
    }
  },
  DEFAULT_GRANULARITY = __name(prefix => new ConstantGranularity(prefix), "DEFAULT_GRANULARITY"),
  TimeBucketGranularity = class extends GranularityImplementation {
    constructor(prefix, fetchBeforeFactor = .5, anchor = new Date().setUTCHours(0, 0, 0, 0)) {
      super(prefix);
      this.prefix = prefix;
      this.fetchBeforeFactor = fetchBeforeFactor;
      this.anchor = anchor;
    }
    static {
      __name(this, "TimeBucketGranularity");
    }
    setTimePeriod(lengthMs) {
      isNaN(lengthMs) ? this.timePeriodLengthMs = void 0 : this.timePeriodLengthMs = lengthMs;
    }
    setByCallBuckets(numBuckets) {
      isNaN(numBuckets) ? this.numByCallBuckets = void 0 : this.numByCallBuckets = numBuckets;
    }
    getValue(now) {
      return this.prefix + this.getTimePeriodBucketString(now) + (this.numByCallBuckets ? this.timeHash(now) : "");
    }
    getTimePeriodBucketString(now) {
      return this.timePeriodLengthMs ? this.dateToTimePartString(now) : "";
    }
    getUpcomingValues(now) {
      let upcomingValues = [],
        upcomingTimePeriodBucketStrings = this.getUpcomingTimePeriodBucketStrings(now),
        upcomingByCallBucketStrings = this.getUpcomingByCallBucketStrings();
      for (let upcomingTimePeriodBucketString of upcomingTimePeriodBucketStrings) for (let upcomingByCallBucketString of upcomingByCallBucketStrings) upcomingValues.push(this.prefix + upcomingTimePeriodBucketString + upcomingByCallBucketString);
      return upcomingValues;
    }
    getUpcomingTimePeriodBucketStrings(now) {
      if (this.timePeriodLengthMs === void 0) return [""];
      if ((now.getTime() - this.anchor) % this.timePeriodLengthMs < this.fetchBeforeFactor * this.timePeriodLengthMs) return [this.getTimePeriodBucketString(now)];
      {
        let inABit = new Date(now.getTime() + this.timePeriodLengthMs);
        return [this.getTimePeriodBucketString(now), this.getTimePeriodBucketString(inABit)];
      }
    }
    getUpcomingByCallBucketStrings() {
      return this.numByCallBuckets === void 0 ? [""] : Array.from(Array(this.numByCallBuckets).keys()).map(x => x.toString());
    }
    timeHash(time) {
      return this.numByCallBuckets == null ? 0 : 7883 * (time.getTime() % this.numByCallBuckets) % this.numByCallBuckets;
    }
    dateToTimePartString(date) {
      return this.timePeriodLengthMs == null ? "" : Math.floor((date.getTime() - this.anchor) / this.timePeriodLengthMs).toString();
    }
  };
var BUCKETFILTER = "X-Copilot-ClientTimeBucket",
  GranularityDirectory = class {
    constructor(prefix, clock) {
      this.specs = new Map();
      this.prefix = prefix, this.clock = clock, this.defaultGranularity = DEFAULT_GRANULARITY(prefix);
    }
    static {
      __name(this, "GranularityDirectory");
    }
    selectGranularity(filters) {
      for (let [rememberedFilters, granularity] of this.specs.entries()) if (filters.extends(rememberedFilters)) return granularity;
      return this.defaultGranularity;
    }
    update(filters, byCallBuckets, timePeriodSizeInH) {
      if (byCallBuckets = byCallBuckets > 1 ? byCallBuckets : NaN, timePeriodSizeInH = timePeriodSizeInH > 0 ? timePeriodSizeInH : NaN, isNaN(byCallBuckets) && isNaN(timePeriodSizeInH)) this.specs.delete(filters);else {
        let newGranularity = new TimeBucketGranularity(this.prefix);
        isNaN(byCallBuckets) || newGranularity.setByCallBuckets(byCallBuckets), isNaN(timePeriodSizeInH) || newGranularity.setTimePeriod(timePeriodSizeInH * 3600 * 1e3), this.specs.set(filters, newGranularity);
      }
    }
    extendFilters(filters) {
      let implementation = this.selectGranularity(filters),
        [value, upcomingValues] = implementation.getCurrentAndUpComingValues(this.clock.now());
      return {
        newFilterSettings: filters.withChange(BUCKETFILTER, value),
        otherFilterSettingsToPrefetch: upcomingValues.map(value => filters.withChange(BUCKETFILTER, value))
      };
    }
  };
var FilterSettingsToExpConfigs = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.cache = new LRUCacheMap(200);
    }
    static {
      __name(this, "FilterSettingsToExpConfigs");
    }
    async fetchExpConfig(settings) {
      let task = this.cache.get(settings.stringify());
      return task || (task = new Task(() => this.ctx.get(ExpConfigMaker).fetchExperiments(this.ctx, settings.toHeaders()), 1e3 * 60 * 60), this.cache.set(settings.stringify(), task)), task.run();
    }
    getCachedExpConfig(settings) {
      return this.cache.get(settings.stringify())?.value();
    }
  },
  Task = class {
    constructor(producer, expirationMs = 1 / 0) {
      this.producer = producer;
      this.expirationMs = expirationMs;
    }
    static {
      __name(this, "Task");
    }
    async run() {
      return this.promise === void 0 && (this.promise = this.producer(), this.storeResult(this.promise).then(() => {
        this.expirationMs < 1 / 0 && this.promise !== void 0 && setTimeout(() => this.promise = void 0, this.expirationMs);
      })), this.promise;
    }
    async storeResult(promise) {
      try {
        this.result = await promise;
      } finally {
        this.result === void 0 && (this.promise = void 0);
      }
    }
    value() {
      return this.result;
    }
  },
  Features = class _Features {
    constructor(ctx) {
      this.ctx = ctx;
      this.staticFilters = {};
      this.dynamicFilters = {};
      this.upcomingDynamicFilters = {};
      this.assignments = new FilterSettingsToExpConfigs(this.ctx);
    }
    static {
      __name(this, "Features");
    }
    static {
      this.upcomingDynamicFilterCheckDelayMs = 20;
    }
    static {
      this.upcomingTimeBucketMinutes = 5 + Math.floor(Math.random() * 11);
    }
    registerStaticFilters(filters) {
      Object.assign(this.staticFilters, filters);
    }
    registerDynamicFilter(filter, generator) {
      this.dynamicFilters[filter] = generator;
    }
    getDynamicFilterValues() {
      let values = {};
      for (let [filter, generator] of Object.entries(this.dynamicFilters)) values[filter] = generator();
      return values;
    }
    registerUpcomingDynamicFilter(filter, generator) {
      this.upcomingDynamicFilters[filter] = generator;
    }
    async getAssignment(feature, requestFilters = {}, telemetryData) {
      let granularityDirectory = this.getGranularityDirectory(),
        preGranularityFilters = this.makeFilterSettings(requestFilters),
        rememberedGranularityExtension = granularityDirectory.extendFilters(preGranularityFilters),
        expAccordingToRememberedExtension = await this.getExpConfig(rememberedGranularityExtension.newFilterSettings);
      granularityDirectory.update(preGranularityFilters, +(expAccordingToRememberedExtension.variables.copilotbycallbuckets ?? NaN), +(expAccordingToRememberedExtension.variables.copilottimeperiodsizeinh ?? NaN));
      let currentGranularityExtension = granularityDirectory.extendFilters(preGranularityFilters),
        filters = currentGranularityExtension.newFilterSettings,
        exp = await this.getExpConfig(filters),
        backgroundQueue = new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs));
      for (let upcomingFilter of currentGranularityExtension.otherFilterSettingsToPrefetch) backgroundQueue = backgroundQueue.then(async () => {
        await new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs)), this.getExpConfig(upcomingFilter);
      });
      return this.prepareForUpcomingFilters(filters), telemetryData && (telemetryData.filtersAndExp = {
        exp: exp,
        filters: filters
      }), exp.variables[feature];
    }
    getGranularityDirectory() {
      if (!this.granularityDirectory) {
        let machineId = this.ctx.get(EditorSession).machineId;
        this.granularityDirectory = new GranularityDirectory(machineId, this.ctx.get(Clock));
      }
      return this.granularityDirectory;
    }
    makeFilterSettings(requestFilters) {
      return new FilterSettings({
        ...this.staticFilters,
        ...this.getDynamicFilterValues(),
        ...requestFilters
      });
    }
    async getExpConfig(settings) {
      try {
        return this.assignments.fetchExpConfig(settings);
      } catch (e) {
        return ExpConfig.createFallbackConfig(this.ctx, `Error fetching ExP config: ${e}`);
      }
    }
    async prepareForUpcomingFilters(filters) {
      if (!(new Date().getMinutes() < 60 - _Features.upcomingTimeBucketMinutes)) for (let [filter, generator] of Object.entries(this.upcomingDynamicFilters)) await new Promise(resolve => setTimeout(resolve, _Features.upcomingDynamicFilterCheckDelayMs)), this.getExpConfig(filters.withChange(filter, generator()));
    }
    stringify() {
      let defaultExpConfig = this.assignments.getCachedExpConfig(new FilterSettings({}));
      return JSON.stringify(defaultExpConfig?.variables ?? {});
    }
    async addExpAndFilterToTelemetry(telemetryData) {
      let filters = this.makeFilterSettings({});
      telemetryData.filtersAndExp = {
        filters: filters,
        exp: await this.getExpConfig(filters)
      };
    }
    async debounceMs() {
      return (await this.getAssignment("copilotdebouncems")) ?? 0;
    }
    async debouncePredict() {
      return (await this.getAssignment("copilotdebouncepredict")) ?? !1;
    }
    async contextualFilterEnable() {
      return (await this.getAssignment("copilotcontextualfilterenable")) ?? !0;
    }
    async contextualFilterEnableTree() {
      return (await this.getAssignment("copilotcontextualfilterenabletree")) ?? !0;
    }
    async contextualFilterAcceptThreshold() {
      return (await this.getAssignment("copilotcontextualfilteracceptthreshold")) ?? 35;
    }
    async contextualFilterExplorationTraffic() {
      return (await this.getAssignment("copilotcontextualfilterexplorationtraffic")) ?? 1;
    }
    async disableLogProb() {
      return (await this.getAssignment("copilotdisablelogprob")) ?? !0;
    }
    async overrideBlockMode() {
      return (await this.getAssignment("copilotoverrideblockmode")) || void 0;
    }
    async fastCancellation() {
      return (await this.getAssignment("copilotoverridefastcancellation")) ?? !0;
    }
    async overrideNumGhostCompletions() {
      return await this.getAssignment("copilotoverridednumghostcompletions");
    }
    async dropCompletionReasons() {
      let reasons = await this.getAssignment("copilotdropcompletionreasons");
      if (reasons) return reasons.split(",");
    }
    async customEngine({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotcustomengine", filters, telemetryData)) ?? "";
    }
    async beforeRequestWaitMs({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotlms", filters, telemetryData)) ?? 0;
    }
    async multiLogitBias({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotlbeot", filters, telemetryData)) ?? !1;
    }
    async requestMultilineExploration({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultilineexploration", filters, telemetryData)) ?? !1;
    }
    async suffixPercent({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return getConfig(this.ctx, ConfigKey.DebugOverrideEngine) ? 0 : (await this.getAssignment("CopilotSuffixPercent", filters)) ?? 15;
    }
    async suffixMatchThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotsuffixmatchthreshold", filters)) ?? 10;
    }
    async fimSuffixLengthThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotfimsuffixlenthreshold", filters)) ?? 0;
    }
    async suffixStartMode({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotsuffixstartmode", filters)) {
        case "cursor":
          return $a.SuffixStartMode.Cursor;
        case "cursortrimstart":
          return $a.SuffixStartMode.CursorTrimStart;
        case "siblingblock":
          return $a.SuffixStartMode.SiblingBlock;
        case "siblingblocktrimstart":
          return $a.SuffixStartMode.SiblingBlockTrimStart;
        default:
          return $a.SuffixStartMode.CursorTrimStart;
      }
    }
    async numberOfSnippets({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotnumberofsnippets", filters)) ?? $a.DEFAULT_NUM_OF_SNIPPETS;
    }
    async snippetPercent({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("snippetpercent", filters)) ?? 0;
    }
    async neighboringTabsOption({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringtabs", filters)) {
        case "none":
          return $a.NeighboringTabsOption.None;
        case "conservative":
          return $a.NeighboringTabsOption.Conservative;
        case "medium":
          return $a.NeighboringTabsOption.Medium;
        case "eager":
          return $a.NeighboringTabsOption.Eager;
        case "eagerbutlittle":
          return $a.NeighboringTabsOption.EagerButLittle;
        case "eagerbutmedium":
          return $a.NeighboringTabsOption.EagerButMedium;
        case "eagerbutmuch":
          return $a.NeighboringTabsOption.EagerButMuch;
        case "retrievalcomparable":
          return $a.NeighboringTabsOption.RetrievalComparable;
        default:
          return $a.NeighboringTabsOption.Eager;
      }
    }
    async neighboringSnippetTypes({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringsnippettypes", filters)) {
        case "function":
          return $a.NeighboringSnippetType.NeighboringFunctions;
        case "snippet":
          return $a.NeighboringSnippetType.NeighboringSnippets;
        case "cursor":
          return $a.NeighboringSnippetType.CursorHistoryMatcher;
        default:
          return $a.NeighboringSnippetType.NeighboringSnippets;
      }
    }
    async neighboringFileType({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("copilotneighboringfiletype", filters)) {
        case "none":
          return "none";
        case "cursormostrecent":
          return "cursormostrecent";
        case "cursormostcount":
          return "cursormostcount";
        case "workspacesharingsamefolder":
          return "workspacesharingsamefolder";
        case "workspacesmallestpathdist":
          return "workspacesmallestpathdist";
        case "cocommitted":
          return "opentabsandcocommitted";
        case "opentabs":
        default:
          return "opentabs";
      }
    }
    async cursorSnippetsPickingStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("cursorsnippetspickingstrategy", filters)) {
        case "cursoronly":
          return $a.CursorSnippetsPickingStrategy.CursorOnly;
        case "jaccardcursor":
          return $a.CursorSnippetsPickingStrategy.JaccardCursor;
        case "cursorjaccard":
        default:
          return $a.CursorSnippetsPickingStrategy.CursorJaccard;
      }
    }
    async retrievalStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("retrieval", filters, telemetryData)) ?? !1;
    }
    async retrievalServerRoute({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, telemetryData) {
      let filters = {
          "X-Copilot-Repository": repoNwo,
          "X-Copilot-FileType": fileType,
          "X-Copilot-UserKind": userKind,
          "X-Copilot-Dogfood": dogFood,
          "X-Copilot-CustomModel": customModel,
          "X-Copilot-RetrievalOrg": retrievalOrg
        },
        expvalue = await this.getAssignment("retrievalserverroute", filters, telemetryData);
      switch (expvalue) {
        case "aims":
          return "2";
        case "devdiv":
          return "1";
        case "githubnext":
          return "0";
        default:
          return expvalue ?? "0";
      }
    }
    async symbolDefinitionStrategy({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotsymboldefinitionstrategy", filters)) ?? !1;
    }
    async localImportContext({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      switch (await this.getAssignment("localimportcontext", filters)) {
        case !0:
          return $a.LocalImportContextOption.Declarations;
        case !1:
        default:
          return $a.LocalImportContextOption.NoContext;
      }
    }
    async maxPromptCompletionTokens({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }, def) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("maxpromptcompletionTokens", filters)) ?? def;
    }
    async hybridInference({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("hybridinference", filters)) ?? !1;
    }
    async hybridInferenceThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return ((await this.getAssignment("hybridinferencethreshold", filters)) ?? -100) / 100;
    }
    async requestMultiOnNewLine({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultionnewline", filters)) ?? !1;
    }
    async requestMultiModel({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return (await this.getAssignment("copilotrequestmultimodel", filters)) ?? !1;
    }
    async requestMultiModelThreshold({
      repoNwo: repoNwo,
      fileType: fileType,
      userKind: userKind,
      dogFood: dogFood,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    }) {
      let filters = {
        "X-Copilot-Repository": repoNwo,
        "X-Copilot-FileType": fileType,
        "X-Copilot-UserKind": userKind,
        "X-Copilot-Dogfood": dogFood,
        "X-Copilot-CustomModel": customModel,
        "X-Copilot-RetrievalOrg": retrievalOrg
      };
      return ((await this.getAssignment("copilotrequestmultimodelthreshold", filters)) ?? 100) / 100;
    }
  };
var packageJson = rO(),
  ConfigKey = {
    Enable: "enable",
    InlineSuggestEnable: "inlineSuggest.enable",
    ShowEditorCompletions: ["editor", "showEditorCompletions"],
    EnableAutoCompletions: ["editor", "enableAutoCompletions"],
    DelayCompletions: ["editor", "delayCompletions"],
    FilterCompletions: ["editor", "filterCompletions"],
    DisplayStyle: ["advanced", "displayStyle"],
    SecretKey: ["advanced", "secret_key"],
    SolutionLength: ["advanced", "length"],
    Stops: ["advanced", "stops"],
    Temperature: ["advanced", "temperature"],
    TopP: ["advanced", "top_p"],
    IndentationMode: ["advanced", "indentationMode"],
    InlineSuggestCount: ["advanced", "inlineSuggestCount"],
    ListCount: ["advanced", "listCount"],
    DebugOverrideCapiUrl: ["advanced", "debug.overrideCapiUrl"],
    DebugTestOverrideCapiUrl: ["advanced", "debug.testOverrideCapiUrl"],
    DebugOverrideProxyUrl: ["advanced", "debug.overrideProxyUrl"],
    DebugTestOverrideProxyUrl: ["advanced", "debug.testOverrideProxyUrl"],
    DebugOverrideEngine: ["advanced", "debug.overrideEngine"],
    DebugShowScores: ["advanced", "debug.showScores"],
    DebugOverrideLogLevels: ["advanced", "debug.overrideLogLevels"],
    DebugFilterLogCategories: ["advanced", "debug.filterLogCategories"],
    DebugSnippyOverrideUrl: ["advanced", "debug.codeRefOverrideUrl"],
    DebugTruncationKiwi: ["advanced", "debug.truncationKiwi"],
    KerberosServicePrincipal: ["advanced", "kerberosServicePrincipal"]
  };
function shouldDoParsingTrimming(blockMode) {
  return ["parsing", "parsingandserver"].includes(blockMode);
}
__name(shouldDoParsingTrimming, "shouldDoParsingTrimming");
function shouldDoServerTrimming(blockMode) {
  return ["server", "parsingandserver"].includes(blockMode);
}
__name(shouldDoServerTrimming, "shouldDoServerTrimming");
var BlockModeConfig = class {
    static {
      __name(this, "BlockModeConfig");
    }
  },
  ConfigBlockModeConfig = class extends BlockModeConfig {
    static {
      __name(this, "ConfigBlockModeConfig");
    }
    async forLanguage(ctx, languageId) {
      if (ctx.get(ConfigProvider).isDefaultSettingOverwritten(ConfigKey.IndentationMode)) switch (ctx.get(ConfigProvider).getLanguageConfig(ConfigKey.IndentationMode, languageId)) {
        case "client":
        case !0:
        case "server":
          return "server";
        case "clientandserver":
          return toApplicableBlockMode("parsingandserver", languageId);
        default:
          return "parsing";
      }
      let overrideBlockMode = await ctx.get(Features).overrideBlockMode();
      return overrideBlockMode ? toApplicableBlockMode(overrideBlockMode, languageId) : languageId == "ruby" ? "parsing" : (0, Ox.isSupportedLanguageId)(languageId) ? "parsingandserver" : "server";
    }
  };
function toApplicableBlockMode(blockMode, languageId) {
  switch (blockMode) {
    case "parsing":
      return (0, Ox.isSupportedLanguageId)(languageId) ? "parsing" : "server";
    case "server":
      return "server";
    case "parsingandserver":
    default:
      return (0, Ox.isSupportedLanguageId)(languageId) ? "parsingandserver" : "server";
  }
}
__name(toApplicableBlockMode, "toApplicableBlockMode");
var ConfigProvider = class {
  static {
    __name(this, "ConfigProvider");
  }
};
function getConfigDefaultForObjectKey(key, objectKey) {
  try {
    let value = packageJson.contributes.configuration[0].properties[`${CopilotConfigPrefix}.${key}`].properties[objectKey].default;
    if (value === void 0) throw new Error(`Missing config default value: ${CopilotConfigPrefix}.${key}`);
    return value;
  } catch (e) {
    throw new Error(`Error inspecting config default value ${CopilotConfigPrefix}.${key}.${objectKey}: ${e}`);
  }
}
__name(getConfigDefaultForObjectKey, "getConfigDefaultForObjectKey");
function getConfig(ctx, key) {
  return ctx.get(ConfigProvider).getConfig(key);
}
__name(getConfig, "getConfig");
function isDefaultSettingOverwritten(ctx, key) {
  return ctx.get(ConfigProvider).isDefaultSettingOverwritten(key);
}
__name(isDefaultSettingOverwritten, "isDefaultSettingOverwritten");
function getHiddenConfig(ctx, key, options) {
  return isDefaultSettingOverwritten(ctx, key) ? getConfig(ctx, key) : options.default;
}
__name(getHiddenConfig, "getHiddenConfig");
function dumpConfig(ctx) {
  return ctx.get(ConfigProvider).dumpConfig();
}
__name(dumpConfig, "dumpConfig");
function getLanguageConfig(ctx, key, language) {
  return ctx.get(ConfigProvider).getLanguageConfig(key, language);
}
__name(getLanguageConfig, "getLanguageConfig");
function getEnabledConfig(ctx, language) {
  return getLanguageConfig(ctx, ConfigKey.Enable, language);
}
__name(getEnabledConfig, "getEnabledConfig");
var BuildInfo = class {
  constructor() {
    this.packageJson = packageJson;
  }
  static {
    __name(this, "BuildInfo");
  }
  isProduction() {
    return this.getBuildType() != "dev";
  }
  getBuildType() {
    return this.packageJson.buildType;
  }
  getVersion() {
    return this.packageJson.version;
  }
  getBuild() {
    return this.packageJson.build;
  }
  getName() {
    return this.packageJson.name;
  }
};
function isProduction(ctx) {
  return ctx.get(BuildInfo).isProduction();
}
__name(isProduction, "isProduction");
function getBuildType(ctx) {
  return ctx.get(BuildInfo).getBuildType();
}
__name(getBuildType, "getBuildType");
function getBuild(ctx) {
  return ctx.get(BuildInfo).getBuild();
}
__name(getBuild, "getBuild");
function getVersion(ctx) {
  return ctx.get(BuildInfo).getVersion();
}
__name(getVersion, "getVersion");
var EditorSession = class {
  constructor(sessionId, machineId) {
    this.sessionId = sessionId;
    this.machineId = machineId;
  }
  static {
    __name(this, "EditorSession");
  }
};
function formatNameAndVersion({
  name: name,
  version: version
}) {
  return `${name}/${version}`;
}
__name(formatNameAndVersion, "formatNameAndVersion");
var EditorAndPluginInfo = class {
  static {
    __name(this, "EditorAndPluginInfo");
  }
};
function editorVersionHeaders(ctx) {
  let info = ctx.get(EditorAndPluginInfo);
  return {
    "Editor-Version": formatNameAndVersion(info.getEditorInfo()),
    "Editor-Plugin-Version": formatNameAndVersion(info.getEditorPluginInfo())
  };
}
__name(editorVersionHeaders, "editorVersionHeaders");
var LogLevel = (i => (LogLevel[i.DEBUG = 0] = "DEBUG", LogLevel[i.INFO = 1] = "INFO", LogLevel[i.WARN = 2] = "WARN", LogLevel[i.ERROR = 3] = "ERROR", LogLevel))(g0 || {}),
  LogVerbose = class {
    constructor(logVerbose) {
      this.logVerbose = logVerbose;
    }
    static {
      __name(this, "LogVerbose");
    }
  };
function verboseLogging(ctx) {
  return ctx.get(LogVerbose).logVerbose;
}
__name(verboseLogging, "verboseLogging");
var LogTarget = class {
    static {
      __name(this, "LogTarget");
    }
    shouldLog(ctx, level) {}
  },
  ConsoleLog = class extends LogTarget {
    constructor(console) {
      super();
      this.console = console;
    }
    static {
      __name(this, "ConsoleLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      verboseLogging(ctx) || level == 3 ? this.console.error(metadataStr, ...extra) : level == 2 && this.console.warn(metadataStr, ...extra);
    }
  },
  OutputChannelLog = class extends LogTarget {
    constructor(output) {
      super();
      this.output = output;
    }
    static {
      __name(this, "OutputChannelLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      this.output.appendLine(`${metadataStr} ${extra.map(toPlainText)}`);
    }
  },
  MultiLog = class extends LogTarget {
    constructor(targets) {
      super();
      this.targets = targets;
    }
    static {
      __name(this, "MultiLog");
    }
    logIt(ctx, level, metadataStr, ...extra) {
      this.targets.forEach(t => t.logIt(ctx, level, metadataStr, ...extra));
    }
  },
  Logger = class {
    static {
      __name(this, "Logger");
    }
    constructor(minLoggedLevel, context) {
      this.minLoggedLevel = minLoggedLevel, this.context = context;
    }
    setLevel(level) {
      this.minLoggedLevel = level;
    }
    stringToLevel(s) {
      return LogLevel[s];
    }
    log(ctx, level, ...extra) {
      let levelString = LogLevel[level],
        logTarget = ctx.get(LogTarget),
        targetOverride = logTarget.shouldLog(ctx, level);
      if (targetOverride === !1 || targetOverride === void 0 && !this.shouldLog(ctx, level, this.context)) return;
      let timestamp = ctx.get(Clock).now().toISOString(),
        metadataStr = `[${levelString}] [${this.context}] [${timestamp}]`;
      logTarget.logIt(ctx, level, metadataStr, ...extra);
    }
    sendErrorTelemetry(ctx, name, secureMessage, standardMessage) {
      telemetryError(ctx, name, TelemetryData.createAndMarkAsIssued({
        context: this.context,
        level: LogLevel[3],
        message: secureMessage
      }), 1), telemetryError(ctx, name, TelemetryData.createAndMarkAsIssued({
        context: this.context,
        level: LogLevel[3],
        message: standardMessage
      }), 0);
    }
    telemetryMessage(...extra) {
      return extra.length > 0 ? JSON.stringify(extra) : "no msg";
    }
    shouldLog(ctx, level, category) {
      if (verboseLogging(ctx)) return !0;
      let levels = getConfig(ctx, ConfigKey.DebugFilterLogCategories);
      if (levels.length > 0 && !levels.includes(category)) return !1;
      if (isProduction(ctx)) return level >= this.minLoggedLevel;
      let overrides = getConfig(ctx, ConfigKey.DebugOverrideLogLevels),
        minLevel = this.stringToLevel(overrides["*"]) ?? this.stringToLevel(overrides[this.context]) ?? this.minLoggedLevel;
      return level >= minLevel;
    }
    debug(ctx, ...extra) {
      this.log(ctx, 0, ...extra);
    }
    info(ctx, ...extra) {
      this.log(ctx, 1, ...extra);
    }
    warn(ctx, ...extra) {
      this.log(ctx, 2, ...extra);
    }
    error(ctx, ...extra) {
      this.sendErrorTelemetry(ctx, "log", this.telemetryMessage(...extra), "[redacted]"), this.log(ctx, 3, ...extra);
    }
    exception(ctx, error, message) {
      if (error instanceof Error && error.name === "Canceled" && error.message === "Canceled") return;
      telemetryException(ctx, error, message ?? "logger.exception");
      let prefix = message ? `${message}: ` : "",
        safeError = error instanceof Error ? error : new Error("Non-error thrown: " + error);
      this.log(ctx, 3, `${prefix}(${safeError.constructor.name}) ${safeError.message}`);
    }
  };
function toPlainText(x) {
  switch (typeof x) {
    case "object":
      return JSON.stringify(x);
    default:
      return String(x);
  }
}
__name(toPlainText, "toPlainText");
var logger = new Logger(1, "default");
var NotificationSender = class {
  static {
    __name(this, "NotificationSender");
  }
};
var open = yee(),
  UrlOpener = class {
    static {
      __name(this, "UrlOpener");
    }
  },
  RealUrlOpener = class extends UrlOpener {
    static {
      __name(this, "RealUrlOpener");
    }
    async open(target) {
      await open(target);
    }
  };
var CERTIFICATE_ERRORS = ["UNABLE_TO_VERIFY_LEAF_SIGNATURE", "CERT_SIGNATURE_FAILURE"],
  UserErrorNotifier = class {
    constructor(ctx) {
      this.notifiedErrorCodes = [];
      ctx.get(CopilotTokenNotifier).on("onCopilotToken", token => {
        this.supportsSSC = token.getTokenValue("ssc") === "1";
      });
    }
    static {
      __name(this, "UserErrorNotifier");
    }
    async notifyUser(ctx, error) {
      CERTIFICATE_ERRORS.includes(error.code) && !this.didNotifyBefore(error.code) && (this.displayCertificateErrorNotification(ctx, error), this.notifiedErrorCodes.push(error.code));
    }
    displayCertificateErrorNotification(ctx, err) {
      let learnMoreLink = "https://gh.io/copilot-network-errors",
        errorMsg = this.certificateErrorMessage();
      new Logger(3, "certificates").error(ctx, `${errorMsg} Please visit ${learnMoreLink} to learn more. Original cause: ${JSON.stringify(err)}`), this.showCertificateWarningMessage(ctx, errorMsg, learnMoreLink);
    }
    certificateErrorMessage() {
      return this.supportsSSC === void 0 ? "The proxy connection couldn't be established due to an untrusted custom certificate, or your Copilot license might not support their use." : this.supportsSSC ? "Your proxy connection requires a trusted certificate. Please make sure the proxy certificate and any issuers are configured correctly and trusted by your operating system." : "Your current Copilot license doesn't support proxy connections with custom certificates.";
    }
    showCertificateWarningMessage(ctx, errorMsg, learnMoreLink) {
      let learnMoreAction = {
        title: "Learn more"
      };
      ctx.get(NotificationSender).showWarningMessage(errorMsg, learnMoreAction).then(userResponse => {
        userResponse?.title === learnMoreAction.title && ctx.get(UrlOpener).open(learnMoreLink);
      });
    }
    didNotifyBefore(code) {
      return this.notifiedErrorCodes.indexOf(code) !== -1;
    }
  };
var import_vscode_uri = Ns(B1());
var DotComAuthority = "github.com",
  DotComUrl = `https://${DotComAuthority}`,
  NetworkConfiguration = class {
    static {
      __name(this, "NetworkConfiguration");
    }
  },
  DefaultNetworkConfiguration = class extends NetworkConfiguration {
    constructor(url = DotComUrl, env = process.env) {
      super();
      this.env = env;
      this.recalculateUrls(url);
    }
    static {
      __name(this, "DefaultNetworkConfiguration");
    }
    isGitHubEnterprise() {
      return this.isEnterprise;
    }
    getAuthAuthority() {
      return this.baseUri.authority;
    }
    getTokenUrl(githubToken) {
      return githubToken.devOverride?.copilotTokenUrl ?? this.tokenUrl;
    }
    getNotificationUrl(githubToken) {
      return githubToken.devOverride?.notificationUrl ?? this.notificationUrl;
    }
    getContentRestrictionsUrl(githubToken) {
      return githubToken.devOverride?.contentRestrictionsUrl ?? this.contentRestrictionsUrl;
    }
    getDeviceFlowStartUrl() {
      return this.deviceFlowStartUrl;
    }
    getDeviceFlowCompletionUrl() {
      return this.deviceFlowCompletionUrl;
    }
    getUserInfoUrl() {
      return this.userInfoUrl;
    }
    updateBaseUrl(ctx, newUrl = DotComUrl) {
      let oldUri = this.baseUri;
      this.recalculateUrls(newUrl), oldUri.toString() !== this.baseUri.toString() && ctx.get(CopilotTokenManager).resetCopilotToken(ctx);
    }
    recalculateUrls(url) {
      let uris = this.parseUris(url);
      this.baseUri = uris.base;
      let apiUri = uris.api;
      this.isEnterprise = this.baseUri.authority !== DotComAuthority, this.tokenUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/v2/token").toString(), this.notificationUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/notification").toString(), this.contentRestrictionsUrl = Pu.Utils.joinPath(apiUri, "/copilot_internal/content_exclusion").toString(), this.deviceFlowStartUrl = Pu.Utils.joinPath(this.baseUri, "/login/device/code").toString(), this.deviceFlowCompletionUrl = Pu.Utils.joinPath(this.baseUri, "/login/oauth/access_token").toString(), this.userInfoUrl = Pu.Utils.joinPath(apiUri, "/user").toString();
    }
    parseUris(url) {
      if (this.env.CODESPACES === "true" && this.env.GITHUB_TOKEN && this.env.GITHUB_SERVER_URL && this.env.GITHUB_API_URL) try {
        return {
          base: Pu.URI.parse(this.env.GITHUB_SERVER_URL, !0),
          api: Pu.URI.parse(this.env.GITHUB_API_URL, !0)
        };
      } catch {}
      let base = Pu.URI.parse(url),
        api = Pu.URI.parse(`${base.scheme}://api.${base.authority}`);
      return {
        base: base,
        api: api
      };
    }
  };
var authLogger = new Logger(1, "auth"),
  REFRESH_BUFFER_SECONDS = 60,
  refreshRunningCount = 0,
  TOKEN_REFRESHED_EVENT = "token_refreshed";
function nowSeconds() {
  return Math.floor(Date.now() / 1e3);
}
__name(nowSeconds, "nowSeconds");
async function authFromGitHubToken(ctx, githubToken) {
  telemetry(ctx, "auth.new_login");
  let response = await fetchCopilotToken(ctx, githubToken),
    tokenInfo = await response.json();
  if (!tokenInfo) return authLogger.info(ctx, "Failed to get copilot token"), telemetryError(ctx, "auth.request_read_failed"), {
    kind: "failure",
    reason: "FailedToGetToken"
  };
  let notification = tokenInfo.user_notification;
  if (notifyUser(ctx, notification, githubToken), response.status === 401) {
    let message = "Failed to get copilot token due to 401 status. Please sign out and try again.";
    return authLogger.info(ctx, message), telemetryError(ctx, "auth.unknown_401"), {
      kind: "failure",
      reason: "HTTP401",
      message: message
    };
  }
  if (!response.ok || !tokenInfo.token) {
    authLogger.info(ctx, `Invalid copilot token: missing token: ${response.status} ${response.statusText}`), telemetryError(ctx, "auth.invalid_token", TelemetryData.createAndMarkAsIssued({
      status: response.status.toString(),
      status_text: response.statusText
    }));
    let error_details = tokenInfo.error_details;
    return notifyUser(ctx, error_details, githubToken), {
      kind: "failure",
      reason: "NotAuthorized",
      message: "User not authorized",
      ...error_details
    };
  }
  let expires_at = tokenInfo.expires_at;
  tokenInfo.expires_at = nowSeconds() + tokenInfo.refresh_in + REFRESH_BUFFER_SECONDS;
  let {
      token: token,
      organization_list: organization_list,
      enterprise_list: enterprise_list,
      ...tokenEnvelope
    } = tokenInfo,
    copilotToken = new CopilotToken(token, organization_list, enterprise_list);
  return ctx.get(CopilotTokenNotifier).emit("onCopilotToken", copilotToken, tokenEnvelope), telemetry(ctx, "auth.new_token", TelemetryData.createAndMarkAsIssued({}, {
    adjusted_expires_at: tokenInfo.expires_at,
    expires_at: expires_at,
    current_time: nowSeconds()
  })), {
    kind: "success",
    ...tokenInfo
  };
}
__name(authFromGitHubToken, "authFromGitHubToken");
async function fetchCopilotToken(ctx, githubToken) {
  let copilotTokenUrl = ctx.get(NetworkConfiguration).getTokenUrl(githubToken);
  try {
    return await ctx.get(Fetcher).fetch(copilotTokenUrl, {
      headers: {
        Authorization: `token ${githubToken.token}`,
        ...editorVersionHeaders(ctx)
      }
    });
  } catch (err) {
    throw ctx.get(UserErrorNotifier).notifyUser(ctx, err), err;
  }
}
__name(fetchCopilotToken, "fetchCopilotToken");
var recentNotifications = new Map();
function notifyUser(ctx, notification, githubToken) {
  if (!notification) return;
  let now = nowSeconds();
  recentNotifications.get(notification.message) || (recentNotifications.set(notification.message, now), ctx.get(NotificationSender).showWarningMessage(notification.message, {
    title: notification.title
  }, {
    title: "Dismiss"
  }).then(async r => {
    let showUrl = r?.title === notification.title,
      ackNotification = showUrl || r?.title === "Dismiss";
    if (showUrl) {
      let editorInfo = ctx.get(EditorAndPluginInfo).getEditorPluginInfo(),
        urlWithContext = notification.url.replace("{EDITOR}", encodeURIComponent(editorInfo.name + "_" + editorInfo.version));
      await ctx.get(UrlOpener).open(urlWithContext);
    }
    "notification_id" in notification && ackNotification && (await sendNotificationResultToGitHub(ctx, notification.notification_id, githubToken));
  }).catch(error => {
    authLogger.exception(ctx, error, "copilotToken.notification");
  }));
}
__name(notifyUser, "notifyUser");
async function sendNotificationResultToGitHub(ctx, notification_id, githubToken) {
  let notificationUrl = ctx.get(NetworkConfiguration).getNotificationUrl(githubToken),
    response = await ctx.get(Fetcher).fetch(notificationUrl, {
      headers: {
        Authorization: `token ${githubToken.token}`,
        ...editorVersionHeaders(ctx)
      },
      method: "POST",
      body: JSON.stringify({
        notification_id: notification_id
      })
    });
  (!response || !response.ok) && authLogger.error(ctx, `Failed to send notification result to GitHub: ${response?.status} ${response?.statusText}`);
}
__name(sendNotificationResultToGitHub, "sendNotificationResultToGitHub");
var CopilotToken = class {
  constructor(token, organization_list, enterprise_list) {
    this.token = token;
    this.organization_list = organization_list;
    this.enterprise_list = enterprise_list;
    this.tokenMap = this.parseToken(token);
  }
  static {
    __name(this, "CopilotToken");
  }
  parseToken(token) {
    let result = new Map(),
      fields = token?.split(":")[0]?.split(";");
    for (let field of fields) {
      let [key, value] = field.split("=");
      result.set(key, value);
    }
    return result;
  }
  getTokenValue(key) {
    return this.tokenMap.get(key);
  }
};
function refreshToken(ctx, tokenManager, refreshIn) {
  let now = nowSeconds();
  refreshRunningCount > 0 || (refreshRunningCount++, setTimeout(async () => {
    let kind,
      error = "";
    try {
      refreshRunningCount--, await tokenManager.getCopilotToken(ctx, !0), kind = "success", tokenManager.tokenRefreshEventEmitter.emit(TOKEN_REFRESHED_EVENT);
    } catch (e) {
      kind = "failure", error = e.toString();
    }
    let data = TelemetryData.createAndMarkAsIssued({
      result: kind
    }, {
      time_taken: nowSeconds() - now,
      refresh_count: refreshRunningCount
    });
    error && (data.properties.reason = error), telemetry(ctx, "auth.token_refresh", data);
  }, refreshIn * 1e3));
}
__name(refreshToken, "refreshToken");
var authLogger = new Logger(1, "auth"),
  CopilotTokenManager = class {
    static {
      __name(this, "CopilotTokenManager");
    }
    constructor() {
      this.tokenRefreshEventEmitter = new Cee.EventEmitter();
    }
    async getGitHubToken(ctx) {
      return (await this.getGitHubSession(ctx))?.token;
    }
  },
  CopilotTokenManagerFromGitHubTokenBase = class extends CopilotTokenManager {
    constructor() {
      super();
      this.copilotToken = void 0;
    }
    static {
      __name(this, "CopilotTokenManagerFromGitHubTokenBase");
    }
    async getCopilotToken(ctx, force) {
      if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds() || force) {
        let gitHubToken = await this.getGitHubSession(ctx);
        if (!gitHubToken) throw new CopilotAuthError("Not signed in");
        let tokenResult = await authFromGitHubToken(ctx, gitHubToken);
        if (tokenResult.kind === "failure") {
          if (tokenResult.message) throw new CopilotAuthError(tokenResult.message);
          let error = new Error(`Unexpected error getting Copilot token: ${tokenResult.reason}`);
          throw error.code = `CopilotToken.${tokenResult.reason}`, error;
        }
        this.copilotToken = {
          ...tokenResult
        }, refreshToken(ctx, this, tokenResult.refresh_in);
      }
      return new CopilotToken(this.copilotToken.token, this.copilotToken.organization_list);
    }
    async checkCopilotToken(ctx) {
      if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {
        let gitHubToken = await this.getGitHubSession(ctx);
        if (!gitHubToken) throw new CopilotAuthError("Not signed in");
        let tokenResult = await authFromGitHubToken(ctx, gitHubToken);
        if (tokenResult.kind === "failure") return tokenResult;
        this.copilotToken = {
          ...tokenResult
        }, refreshToken(ctx, this, tokenResult.refresh_in);
      }
      return {
        status: "OK"
      };
    }
    resetCopilotToken(ctx, httpError) {
      httpError !== void 0 && telemetry(ctx, "auth.reset_token_" + httpError), authLogger.debug(ctx, `Resetting copilot token on HTTP error ${httpError || "unknown"}`), this.copilotToken = void 0;
    }
  };
var Debouncer = class {
  static {
    __name(this, "Debouncer");
  }
  async debounce(ms) {
    return this.state && (clearTimeout(this.state.timer), this.state.reject(), this.state = void 0), new Promise((resolve, reject) => {
      this.state = {
        timer: setTimeout(() => resolve(), ms),
        reject: reject
      };
    });
  }
};
function debounce(ms, callback) {
  let timer;
  return (...args) => (timer && clearTimeout(timer), new Promise(resolve => {
    timer = setTimeout(() => {
      let returnValue = callback(...args);
      resolve(returnValue);
    }, ms);
  }));
}
__name(debounce, "debounce");
var import_copilot_promptlib = Ns(Dc());
var CompletionsCache = class {
  static {
    __name(this, "CompletionsCache");
  }
  constructor() {
    this._cache = new LRUCacheMap(100);
  }
  get(promptKey) {
    return this._cache.get(promptKey);
  }
  set(promptKey, contents) {
    this._cache.set(promptKey, contents);
  }
  clear() {
    this._cache.clear();
  }
};
function treeScore(input) {
  let var0;
  input[0] > 1e-35 ? input[29] > 1e-35 ? input[138] > 1e-35 ? var0 = .49496579646815353 : var0 = .47546580490346646 : input[30] > 1e-35 ? var0 = .4456371992737078 : input[4] > 3.238486181444842 ? input[135] > 1e-35 ? var0 = .2645576817782658 : input[46] > 1e-35 ? var0 = .20251922126765812 : var0 = .37359143313367105 : input[7] > .9662372103242399 ? var0 = .44975631109230374 : var0 = .4067133376207218 : input[7] > .960816451500545 ? input[29] > 1e-35 ? input[4] > 1.7005986908310777 ? var0 = .4240336839258693 : var0 = .35414085998710754 : input[4] > 3.238486181444842 ? var0 = .353882328354817 : input[100] > 1e-35 ? var0 = .48783079865293355 : input[30] > 1e-35 ? var0 = .419904106522537 : var0 = .38599249795612806 : input[4] > 3.6242520361853052 ? input[29] > 1e-35 ? input[7] > .5086748127709895 ? var0 = .37522628419389664 : var0 = .3359393805000766 : input[30] > 1e-35 ? var0 = .3685210833144829 : input[135] > 1e-35 ? var0 = .22140958666091123 : input[134] > 1e-35 ? var0 = .38379851487275685 : input[46] > 1e-35 ? var0 = .1926283522107934 : var0 = .3098162447812857 : input[46] > 1e-35 ? var0 = .22698331991181095 : input[4] > 1.4978661367769956 ? input[30] > 1e-35 ? input[4] > 2.138333059508028 ? var0 = .39709448374768985 : var0 = .34711865383837703 : input[134] > 1e-35 ? var0 = .40608455346469957 : input[135] > 1e-35 ? var0 = .3084120164848763 : input[48] > 1e-35 ? var0 = .24193590696691425 : input[51] > 1e-35 ? var0 = .2087938690163009 : input[4] > 3.1984648276080736 ? var0 = .3529508564858481 : var0 = .3698795818909763 : var0 = .30210240039979064;
  let var1;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[2] > 3.676220550121792 ? input[7] > .9246495578512688 ? var1 = .0570428673081833 : var1 = .019779482100154476 : input[7] > .9705672697050661 ? var1 = .1023948532887641 : var1 = .06265430080550045 : input[29] > 1e-35 ? input[5] > 4.658699722134796 ? input[2] > 1.2424533248940002 ? var1 = .12784241430585772 : var1 = .15126156743993927 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var1 = .10624230855386699 : var1 = -.1699142543394302 : var1 = .10290106276456985 : input[5] > 3.5694334999727624 ? var1 = .09368877801612557 : var1 = .1552615744687782 : input[2] > 3.3842466058243152 ? input[4] > 3.5694334999727624 ? input[29] > 1e-35 ? input[7] > .7022798213723723 ? var1 = .02282408308012389 : var1 = -.032610792718175546 : var1 = -.04405498437523181 : input[46] > 1e-35 ? var1 = -.14475563528583885 : input[7] > .9159108669154322 ? var1 = .02539215399728953 : input[134] > 1e-35 ? var1 = .04720629593220485 : input[4] > 1.8688348091416842 ? var1 = -.00150052748656963 : var1 = -.04528409340753242 : input[5] > 3.5694334999727624 ? input[4] > 3.6505739029280164 ? input[29] > 1e-35 ? var1 = .050909089229765704 : input[39] > 1e-35 ? var1 = -.08747827386821926 : input[46] > 1e-35 ? var1 = -.11300671054986217 : var1 = -.002669293928522137 : input[46] > 1e-35 ? var1 = -.07873653229849684 : input[39] > 1e-35 ? var1 = -.06389470798465265 : input[2] > .8958797346140276 ? input[47] > 1e-35 ? var1 = -.07102696386827136 : input[4] > 1.8688348091416842 ? var1 = .04567768852273886 : var1 = .016429189359442275 : var1 = .024223384872688037 : input[7] > .9569480028661056 ? var1 = .12458720561596202 : var1 = -.006224718391409129;
  let var2;
  input[29] > 1e-35 ? input[2] > 2.602003343538398 ? input[2] > 4.166635176627655 ? input[7] > .8375851232899904 ? var2 = .027219239366992384 : var2 = -.023288925509443156 : input[7] > .5866799179067689 ? var2 = .05780689652787357 : var2 = .019914206435185725 : input[2] > 1.2424533248940002 ? input[7] > .9246495578512688 ? var2 = .1091540005913688 : var2 = .08430043254349175 : input[6] > 4.832297822126891 ? input[125] > 1e-35 ? var2 = .029350728374412424 : var2 = .1327178977041336 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var2 = -.10742256752042179 : var2 = .10128035205992136 : var2 = .08719230025231978 : input[5] > 3.772694874805912 ? input[39] > 1e-35 ? var2 = -.07712063687837625 : input[46] > 1e-35 ? var2 = -.09987046122905541 : input[2] > 3.6242520361853052 ? input[134] > 1e-35 ? var2 = .0549278412468898 : input[155] > 1e-35 ? var2 = .0628934857241284 : input[47] > 1e-35 ? var2 = -.14605662411148382 : input[48] > 1e-35 ? var2 = -.1460221669882455 : var2 = .002073957868392086 : input[2] > 1e-35 ? input[47] > 1e-35 ? var2 = -.0769198367034467 : input[155] > 1e-35 ? var2 = .0769122902449957 : input[134] > 1e-35 ? var2 = .06856131328753592 : input[152] > 1e-35 ? var2 = .07081107422282688 : input[51] > 1e-35 ? var2 = -.11095669360187602 : input[91] > 1e-35 ? var2 = -.08136006552659215 : input[48] > 1e-35 ? var2 = -.07180356044417698 : input[18] > 1e-35 ? var2 = -.029572927306223313 : input[50] > 1e-35 ? var2 = -.11419309779400831 : var2 = .03331652781327257 : var2 = .0015747823792064454 : input[7] > .9662372103242399 ? var2 = .1203598683210537 : var2 = .011240838199712565;
  let var3;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[1] > 1e-35 ? input[2] > 4.03420147928485 ? var3 = .03823654007072966 : input[7] > .9033253454895247 ? var3 = .09329944316059466 : var3 = .06705865009439997 : input[134] > 1e-35 ? var3 = .06865805795066232 : input[30] > 1e-35 ? var3 = .05189058132179502 : input[217] > 1e-35 ? var3 = .044913757044379055 : var3 = -.05078929160105722 : input[1] > 1e-35 ? input[6] > 5.161920636569023 ? input[2] > 1.4978661367769956 ? var3 = .10652732380394028 : var3 = .13307829460294332 : input[7] > .985694415330804 ? var3 = .06936133858882627 : var3 = .11090193559908544 : input[30] > 1e-35 ? var3 = .10406540623634791 : var3 = .03985408831881549 : input[1] > 1e-35 ? input[2] > 3.772694874805912 ? input[29] > 1e-35 ? input[7] > .7316379010844482 ? var3 = .012897973304512032 : var3 = -.028068579877067623 : var3 = .024577017676752924 : input[5] > 3.417592293073651 ? input[22] > 1e-35 ? var3 = -.023871063947594612 : input[7] > .8255520169851381 ? var3 = .0513970804870914 : input[153] > 1e-35 ? var3 = .0032035784177419503 : var3 = .038713568639820416 : input[7] > .9527510849235538 ? var3 = .10975706910869304 : var3 = -.009433959232316078 : input[38] > 1e-35 ? var3 = .05195298239886214 : input[30] > 1e-35 ? var3 = .02476336300816124 : input[2] > 2.524928003624769 ? input[217] > 1e-35 ? var3 = .0135414448190362 : input[135] > 1e-35 ? var3 = -.14660288310803915 : var3 = -.07298980826531443 : input[135] > 1e-35 ? var3 = -.11136111748165503 : input[123] > 1e-35 ? var3 = -.1489448617480049 : input[46] > 1e-35 ? var3 = -.0922792773195811 : var3 = -.024587716086845016;
  let var4;
  input[0] > 1e-35 ? input[2] > 2.249904835165133 ? input[1] > 1e-35 ? input[2] > 3.540854293052788 ? input[3] > 2.249904835165133 ? var4 = .0590142410559562 : input[7] > .6376007852429183 ? var4 = .043799948513989724 : var4 = -4018626768373957e-20 : var4 = .0790082705503403 : input[38] > 1e-35 ? var4 = .06581244939148062 : input[30] > 1e-35 ? var4 = .04874874335011108 : var4 = -.03908081910821116 : input[3] > 2.602003343538398 ? input[1] > 1e-35 ? var4 = .0902076086329385 : input[30] > 1e-35 ? var4 = .10143876154366023 : var4 = .021304615514737626 : input[2] > 1.4978661367769956 ? var4 = .10248710197602005 : input[8] > 1e-35 ? input[125] > 1e-35 ? var4 = -.1652240484643952 : var4 = .09695355914385996 : var4 = .12574960258243387 : input[1] > 1e-35 ? input[2] > 3.8815106545092593 ? input[3] > 2.249904835165133 ? var4 = .030411053020370282 : input[7] > .8375851232899904 ? var4 = .01347947217941036 : var4 = -.02329004077119854 : input[7] > .9480659774309611 ? input[22] > 1e-35 ? var4 = -.021734552060979462 : input[100] > 1e-35 ? var4 = .12154672718218543 : input[3] > 1e-35 ? var4 = .0467045097539336 : var4 = .07133232987671506 : input[4] > 2.012675845367575 ? input[4] > 3.9219243190762363 ? var4 = .018631928508103857 : var4 = .04026129961424531 : var4 = -.0060403819170799225 : input[38] > 1e-35 ? var4 = .04740678443866351 : input[30] > 1e-35 ? var4 = .022411595432555845 : input[2] > 2.970085626360216 ? input[121] > 1e-35 ? var4 = .016385457091892035 : var4 = -.07115043890873148 : input[4] > 3.417592293073651 ? var4 = -.04057726754591634 : input[29] > 1e-35 ? var4 = -.10601923621749415 : var4 = -.013474385705240824;
  let var5;
  input[3] > 1e-35 ? input[3] > 3.481121732133104 ? input[30] > 1e-35 ? var5 = .03419190074885174 : input[39] > 1e-35 ? var5 = -.07596248521514803 : input[142] > 1e-35 ? var5 = -.09906305142951233 : input[143] > 1e-35 ? var5 = -.11544208927241095 : input[134] > 1e-35 ? var5 = .03231677158309109 : input[217] > 1e-35 ? var5 = .04584520241402839 : var5 = -.014587374070287719 : input[30] > 1e-35 ? input[141] > 1e-35 ? var5 = -.05022127515891476 : input[6] > 3.540854293052788 ? var5 = .046006786519929344 : input[3] > 2.3502401828962087 ? var5 = .03746852485580482 : var5 = .11887634683908754 : input[142] > 1e-35 ? var5 = -.0715680845257123 : input[134] > 1e-35 ? var5 = .05310603374316432 : input[39] > 1e-35 ? var5 = -.05301061369502469 : input[143] > 1e-35 ? var5 = -.06806923450459589 : input[21] > 1e-35 ? var5 = -.054617004299251364 : input[113] > 1e-35 ? input[6] > 3.795426061844291 ? var5 = .03901365322581413 : var5 = .11833310693969545 : input[141] > 1e-35 ? var5 = -.039041289505442084 : input[3] > 3.0677824455408698 ? var5 = .010823236602311471 : input[29] > 1e-35 ? var5 = -.062100944449970996 : input[58] > 1e-35 ? var5 = -.04585181543113668 : input[99] > 1e-35 ? var5 = .053796582993543764 : input[100] > 1e-35 ? input[6] > 3.676220550121792 ? var5 = .02800134029424525 : var5 = .12622387863644666 : input[98] > 1e-35 ? var5 = .06289940430905602 : var5 = .023655750883710656 : input[138] > 1e-35 ? var5 = .09902929683374195 : input[6] > 5.161920636569023 ? var5 = .07160940969782595 : input[141] > 1e-35 ? var5 = .11975693334861698 : var5 = .03480602671098732;
  let var6;
  input[0] > 1e-35 ? input[2] > 2.4414009612931857 ? input[1] > 1e-35 ? input[2] > 4.600145018061341 ? var6 = .02024868069387139 : input[2] > 3.1984648276080736 ? var6 = .048682024362267456 : var6 = .07158946327961134 : input[134] > 1e-35 ? var6 = .05360858064017479 : input[30] > 1e-35 ? var6 = .03969788038954029 : input[39] > 1e-35 ? var6 = -.1339275468398512 : var6 = -.03340699462411555 : input[1] > 1e-35 ? input[2] > 1.2424533248940002 ? var6 = .09338368602561321 : input[5] > 4.5379471377116305 ? var6 = .11818377094705468 : var6 = .02406138301472482 : input[30] > 1e-35 ? var6 = .08786833398626331 : var6 = .031294938606502315 : input[1] > 1e-35 ? input[2] > 2.970085626360216 ? input[29] > 1e-35 ? input[2] > 4.923617305492666 ? var6 = -.0247806554659429 : var6 = .00415615978158072 : input[4] > 2.138333059508028 ? input[4] > 3.6505739029280164 ? var6 = -.0025888569756007704 : var6 = .033556460788819964 : var6 = -.011238496891848667 : input[5] > 3.5694334999727624 ? input[4] > 2.012675845367575 ? input[2] > .8958797346140276 ? var6 = .03964701920383755 : var6 = .024902380380505313 : input[141] > 1e-35 ? var6 = -.07221122170573789 : var6 = .009221806859728395 : input[2] > .8958797346140276 ? var6 = .09633850035166669 : var6 = .007323280248710229 : input[134] > 1e-35 ? var6 = .038330704525669945 : input[30] > 1e-35 ? var6 = .01660549386778516 : input[2] > 2.524928003624769 ? input[217] > 1e-35 ? var6 = .008967266036665084 : input[29] > 1e-35 ? var6 = -.12693911437262784 : var6 = -.05779560753585583 : input[29] > 1e-35 ? var6 = -.0908743155940788 : input[4] > 3.314020688089767 ? var6 = -.030882471980034343 : var6 = -.010429019903489632;
  let var7;
  input[0] > 1e-35 ? input[2] > 2.138333059508028 ? input[1] > 1e-35 ? input[2] > 3.4498615536424366 ? input[3] > 2.249904835165133 ? var7 = .04956831432894648 : input[2] > 5.223051249395764 ? var7 = -.010305811579773205 : var7 = .027491320728082233 : var7 = .06656735137915168 : input[38] > 1e-35 ? var7 = .05309749470598965 : input[30] > 1e-35 ? var7 = .03843762763805799 : var7 = -.030980078724697425 : input[3] > 1e-35 ? input[1] > 1e-35 ? var7 = .08089335516186445 : var7 = .04120452858949669 : input[6] > 4.832297822126891 ? input[2] > .8958797346140276 ? var7 = .10006865536846919 : var7 = .11917243570572485 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var7 = .06704577104028654 : var7 = -.1454046740476985 : input[219] > 1e-35 ? var7 = -.13678871665753098 : var7 = .07859247859374968 : input[1] > 1e-35 ? input[2] > 3.314020688089767 ? input[3] > 2.249904835165133 ? var7 = .024623237775190106 : input[2] > 4.73179313355342 ? var7 = -.02080435685185878 : var7 = .0026175118278487855 : input[6] > 3.417592293073651 ? input[22] > 1e-35 ? var7 = -.025465692791530083 : input[45] > 1e-35 ? var7 = -.044807460105408044 : input[8] > 1e-35 ? var7 = .008766235663186964 : var7 = .032712521408248645 : input[3] > 2.602003343538398 ? var7 = -.0056332432294706036 : input[6] > 2.524928003624769 ? var7 = .09592889105245415 : var7 = -.013339150198983546 : input[38] > 1e-35 ? var7 = .03563564253379704 : input[30] > 1e-35 ? var7 = .014870517098142924 : input[2] > 2.970085626360216 ? var7 = -.054537994223319376 : input[219] > 1e-35 ? var7 = -.13242819761683536 : input[39] > 1e-35 ? var7 = -.0910629106840573 : var7 = -.01970485337755703;
  let var8;
  input[0] > 1e-35 ? input[2] > 2.012675845367575 ? input[1] > 1e-35 ? input[2] > 3.4498615536424366 ? input[7] > .9246495578512688 ? var8 = .04812308497880073 : input[29] > 1e-35 ? var8 = .0005380021336956461 : var8 = .03361690381564229 : input[5] > 3.5694334999727624 ? var8 = .05947219194425965 : var8 = .11024468105183681 : input[134] > 1e-35 ? var8 = .04905351957215242 : input[138] > 1e-35 ? var8 = .05554447267811877 : var8 = -.021863233324542066 : input[29] > 1e-35 ? input[5] > 4.855921334140645 ? input[2] > .8958797346140276 ? var8 = .09590438270550732 : var8 = .11498869480105023 : var8 = .04093609484315685 : var8 = .06588820186431316 : input[1] > 1e-35 ? input[2] > 2.970085626360216 ? input[29] > 1e-35 ? input[7] > .41763374498947375 ? var8 = .0043146758499583255 : var8 = -.03443798345003191 : input[58] > 1e-35 ? var8 = -.08355523706358281 : var8 = .017928058505534663 : input[5] > 3.5694334999727624 ? input[22] > 1e-35 ? var8 = -.02209335592785362 : input[2] > .8958797346140276 ? var8 = .03223396066919647 : var8 = .0170789547385017 : input[7] > .9546729796082215 ? input[2] > .8958797346140276 ? var8 = .09545837551902411 : var8 = .008923660539643153 : var8 = -.012322532316048181 : input[134] > 1e-35 ? var8 = .03182502017906531 : input[138] > 1e-35 ? input[29] > 1e-35 ? var8 = -.06617589040350445 : var8 = .040440282181288686 : input[2] > 2.802901033147999 ? var8 = -.043412758816960974 : input[219] > 1e-35 ? var8 = -.11700143817568372 : input[48] > 1e-35 ? var8 = -.11379636451926181 : input[49] > 1e-35 ? var8 = -.14202838670262277 : input[39] > 1e-35 ? var8 = -.08160450909782378 : var8 = -.013448620144296253;
  let var9;
  input[1] > 1e-35 ? input[2] > 2.602003343538398 ? input[3] > 2.249904835165133 ? input[4] > 3.6505739029280164 ? var9 = .004170792297448336 : var9 = .0368033867902024 : input[7] > .8333442551332461 ? input[2] > 4.677480030793064 ? var9 = .009136341105716223 : var9 = .03568813371096505 : input[7] > .22301866079069904 ? input[2] > 5.1209788959100075 ? var9 = -.02365589472388456 : var9 = .00919157417627931 : var9 = -.0379399276194825 : input[3] > 1e-35 ? input[5] > 3.5694334999727624 ? input[2] > .8958797346140276 ? input[22] > 1e-35 ? var9 = -.019258819649469603 : var9 = .03709105125649261 : var9 = .016860660630369267 : input[3] > 2.602003343538398 ? var9 = -.00991261350028801 : input[7] > .9626084674797213 ? var9 = .11517814309711256 : var9 = -.009719045525281071 : input[2] > 1.2424533248940002 ? input[7] > .7316379010844482 ? var9 = .07097600019370685 : var9 = .04586465946843457 : input[6] > 4.783307617946789 ? var9 = .09722756919612678 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var9 = -.11805054859481241 : var9 = .07110946491407406 : var9 = .05402719662002902 : input[134] > 1e-35 ? var9 = .03393227005537922 : input[30] > 1e-35 ? var9 = .023661319650909306 : input[2] > 2.970085626360216 ? input[121] > 1e-35 ? var9 = .031049210793405797 : input[135] > 1e-35 ? var9 = -.10837216222444626 : input[219] > 1e-35 ? var9 = -.14640457784236915 : var9 = -.03965818070110935 : input[121] > 1e-35 ? var9 = .039992710146502054 : input[143] > 1e-35 ? var9 = -.09311937611688731 : input[46] > 1e-35 ? var9 = -.07559392834101462 : input[219] > 1e-35 ? var9 = -.09895720087616466 : input[135] > 1e-35 ? var9 = -.07586062007425573 : var9 = -.011775153504486295;
  let var10;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[141] > 1e-35 ? var10 = -.03681630636575175 : input[22] > 1e-35 ? var10 = -.024594313135047084 : input[7] > .9626084674797213 ? input[6] > 3.676220550121792 ? var10 = .03355559026428929 : input[3] > 2.602003343538398 ? var10 = .012516956280523336 : var10 = .1113827943542528 : input[3] > 2.3502401828962087 ? input[39] > 1e-35 ? var10 = -.03483153469277968 : input[29] > 1e-35 ? var10 = -.06012725416594425 : var10 = .03180949281577552 : input[3] > 1.2424533248940002 ? var10 = .007572391854701212 : var10 = -.04833059473573461 : input[7] > .5866799179067689 ? input[138] > 1e-35 ? var10 = .084956566507563 : input[7] > .9407436463973539 ? input[6] > 5.161920636569023 ? var10 = .07174368742657447 : input[7] > .9793410316570949 ? var10 = .024186357466630726 : var10 = .07739671408330714 : var10 = .048429456456843774 : input[6] > 5.078289090109146 ? input[138] > 1e-35 ? var10 = .07555203090037793 : var10 = .033181836695182196 : var10 = -.02197298038836975 : input[38] > 1e-35 ? var10 = .031334580210504996 : input[30] > 1e-35 ? var10 = .021270582199851534 : input[121] > 1e-35 ? var10 = .0329970846397004 : input[42] > 1e-35 ? var10 = .04064092183581017 : input[135] > 1e-35 ? var10 = -.08440485061890712 : input[219] > 1e-35 ? var10 = -.10638369254266776 : input[143] > 1e-35 ? var10 = -.09755269717731242 : input[144] > 1e-35 ? var10 = -.1173397395002877 : input[51] > 1e-35 ? var10 = -.1288517354356988 : input[49] > 1e-35 ? var10 = -.13923283846721088 : input[91] > 1e-35 ? var10 = -.1224188861275682 : input[3] > 3.156774023138548 ? var10 = -.02477169567121223 : var10 = -.006917307470148426;
  let var11;
  input[2] > 2.802901033147999 ? input[7] > .9159108669154322 ? input[3] > 3.314020688089767 ? var11 = -.0010700017432373199 : input[2] > 4.832297822126891 ? var11 = .009582861728698568 : var11 = .029780100164495754 : input[30] > 1e-35 ? input[210] > 1e-35 ? var11 = -.028942339056712313 : var11 = .020599853201598167 : input[3] > 3.540854293052788 ? var11 = -.030156164189210577 : input[2] > 4.620046665062766 ? input[3] > 1.8688348091416842 ? var11 = -.00103151911027294 : input[217] > 1e-35 ? var11 = .005930672148987754 : var11 = -.03586108945255643 : var11 = .004417350848115493 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[5] > 3.5694334999727624 ? input[3] > 3.6242520361853052 ? input[30] > 1e-35 ? var11 = .02388317653477103 : var11 = -.0034021644637823034 : input[125] > 1e-35 ? var11 = -.059034648546006076 : input[18] > 1e-35 ? var11 = -.02514305472376584 : input[46] > 1e-35 ? var11 = -.05290744310611087 : input[21] > 1e-35 ? var11 = -.03750702516022783 : input[39] > 1e-35 ? var11 = -.031092446888446753 : var11 = .028272541588979773 : input[7] > .9676186228082213 ? input[3] > 2.602003343538398 ? var11 = -.009169247394016047 : var11 = .11347856526033356 : var11 = -.00310251177264949 : input[2] > 1e-35 ? var11 = .00844340216096322 : var11 = -.00894414829369423 : input[2] > 1.4978661367769956 ? input[7] > .6223082132708274 ? input[6] > 3.0677824455408698 ? var11 = .04885293193722139 : var11 = .10736598620828455 : var11 = .026545392586289893 : input[6] > 4.938058177869999 ? input[2] > .8958797346140276 ? var11 = .07355143458077283 : var11 = .09420954595651049 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var11 = .07966619891180966 : var11 = -.10471235843714122 : var11 = .04867207725748343;
  let var12;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[5] > 3.5694334999727624 ? input[3] > 2.249904835165133 ? input[22] > 1e-35 ? var12 = -.0262424908256809 : input[8] > 1e-35 ? var12 = .001637419319408071 : input[155] > 1e-35 ? var12 = .053444838794586114 : input[99] > 1e-35 ? var12 = .05039717103923269 : var12 = .02448689278350471 : input[141] > 1e-35 ? var12 = -.05723199469388615 : var12 = .005411562031545046 : input[7] > .9626084674797213 ? input[3] > 2.602003343538398 ? var12 = .00980665121101267 : var12 = .10420505846679201 : var12 = -.001639851950872336 : input[7] > .26911173821332884 ? input[138] > 1e-35 ? var12 = .07591724033622518 : input[7] > .9275861021112151 ? input[5] > 5.173316863805991 ? var12 = .06276466446882598 : input[194] > 1e-35 ? var12 = -.1330802382498368 : input[5] > 3.156774023138548 ? input[8] > 1e-35 ? var12 = -.027034262965141144 : var12 = .03949417085855365 : var12 = .08851962788853085 : input[9] > 1e-35 ? var12 = .05379608621573637 : var12 = .032253635727649325 : input[138] > 1e-35 ? var12 = .058048925881989615 : var12 = .005620237500451222 : input[134] > 1e-35 ? var12 = .02734220426041116 : input[30] > 1e-35 ? var12 = .017746745665275825 : input[142] > 1e-35 ? var12 = -.07814745820732061 : input[143] > 1e-35 ? var12 = -.08860968498533135 : input[14] > 1e-35 ? var12 = .01954819512523945 : input[42] > 1e-35 ? var12 = .03333354798081121 : input[147] > 1e-35 ? var12 = -.11642554317575503 : input[49] > 1e-35 ? var12 = -.12425086420883341 : input[146] > 1e-35 ? var12 = -.12996952774815626 : input[3] > 3.817651943129708 ? var12 = -.03275661606585881 : var12 = -.014860694091417102;
  let var13;
  input[1] > 1e-35 ? input[2] > 2.524928003624769 ? input[3] > 2.249904835165133 ? input[3] > 3.725620842493839 ? var13 = -.000906155627647317 : input[24] > 1e-35 ? var13 = .0785324151067157 : input[154] > 1e-35 ? var13 = -.058309500036909157 : var13 = .026762512119806844 : input[7] > .26911173821332884 ? input[2] > 4.505334588423558 ? var13 = -.010584135839537876 : var13 = .013982545022862853 : var13 = -.03208712711019827 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[5] > 3.5694334999727624 ? var13 = .026401003398891884 : input[3] > 2.602003343538398 ? var13 = -.008168418058515686 : input[7] > .9662372103242399 ? var13 = .10626422692131453 : var13 = -.01031637351522216 : var13 = .010358942714602982 : input[2] > 1.2424533248940002 ? input[2] > 2.012675845367575 ? var13 = .0312811686023135 : var13 = .05423507965224627 : input[6] > 4.832297822126891 ? var13 = .08479742987484738 : input[8] > 1e-35 ? input[7] > .9793410316570949 ? var13 = -.09338070882722671 : var13 = .058145805002919916 : var13 = .04227449937397909 : input[38] > 1e-35 ? var13 = .025289091019879376 : input[2] > 3.1132683346437333 ? input[3] > .8958797346140276 ? input[46] > 1e-35 ? var13 = -.09114331684757576 : input[135] > 1e-35 ? var13 = -.07948190608487016 : input[48] > 1e-35 ? var13 = -.12911151777601662 : input[143] > 1e-35 ? var13 = -.09735205976374478 : var13 = -.017192402584465798 : var13 = -.08661537827420282 : input[217] > 1e-35 ? var13 = .033425023239885124 : input[14] > 1e-35 ? var13 = .02729990952110066 : input[48] > 1e-35 ? var13 = -.09098188061865646 : input[46] > 1e-35 ? var13 = -.05848458618550134 : input[91] > 1e-35 ? var13 = -.10969774095556883 : var13 = -.0068971807474334365;
  let var14;
  input[1] > 1e-35 ? input[3] > 1e-35 ? input[3] > 1.2424533248940002 ? input[125] > 1e-35 ? var14 = -.06150017523108556 : input[39] > 1e-35 ? var14 = -.03350257370473994 : input[22] > 1e-35 ? var14 = -.02193617429266551 : input[8] > 1e-35 ? var14 = 7274245146620154e-20 : input[6] > 3.676220550121792 ? input[4] > 2.3502401828962087 ? var14 = .026702786904914785 : var14 = .00851181280021978 : input[4] > 2.673553765358735 ? var14 = .010358811529123666 : input[6] > 2.802901033147999 ? var14 = .08891517935366504 : var14 = .023114323891227237 : var14 = -.02875694375159779 : input[4] > 1.7005986908310777 ? input[138] > 1e-35 ? var14 = .06720372648635974 : input[6] > 5.427147823217923 ? input[9] > 1e-35 ? var14 = .0544777682515472 : var14 = .037060547607205986 : input[6] > 1e-35 ? var14 = .022016394753027843 : var14 = -.1559604133821172 : input[6] > 3.540854293052788 ? var14 = -.009372509268454739 : var14 = -.24388295956457617 : input[38] > 1e-35 ? var14 = .023012278764368795 : input[138] > 1e-35 ? var14 = .03564423186175008 : input[30] > 1e-35 ? var14 = .008093643695090883 : input[217] > 1e-35 ? var14 = .028810461962454004 : input[135] > 1e-35 ? var14 = -.07120877224354143 : input[46] > 1e-35 ? var14 = -.06546454537408128 : input[144] > 1e-35 ? var14 = -.09534262423492412 : input[143] > 1e-35 ? var14 = -.0770344566882831 : input[29] > 1e-35 ? var14 = -.06285371287531509 : input[14] > 1e-35 ? var14 = .02073120300153793 : input[123] > 1e-35 ? var14 = -.09016320513643451 : input[51] > 1e-35 ? var14 = -.10496442920973255 : input[3] > 3.1132683346437333 ? var14 = -.019949599427836494 : var14 = -.0019060085544902166;
  let var15;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 3.1984648276080736 ? input[1] > 1e-35 ? input[3] > 2.249904835165133 ? var15 = .03174009468268253 : input[2] > 5.363634090365639 ? var15 = -.019608371322822362 : var15 = .012560836552403976 : var15 = -.006925466014569184 : input[1] > 1e-35 ? var15 = .047796055675515446 : var15 = .014363935217773802 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var15 = .05193425865217324 : var15 = .07891754708034264 : var15 = .09859506024630252 : input[8] > 1e-35 ? input[5] > 4.424828703319957 ? var15 = .0288226384042998 : var15 = -.09397342098461306 : input[4] > .8958797346140276 ? var15 = .06181532763949055 : input[3] > 1e-35 ? var15 = .0661728888522049 : var15 = -.18938681666136592 : input[2] > 3.6242520361853052 ? input[30] > 1e-35 ? var15 = .005754128097002715 : input[4] > 1.7005986908310777 ? input[1] > 1e-35 ? input[3] > 1.8688348091416842 ? var15 = .003940381852503271 : var15 = -.01767544594631589 : input[134] > 1e-35 ? var15 = .005683243725945637 : var15 = -.033167818200618454 : var15 = -.049739953036904844 : input[1] > 1e-35 ? input[5] > 3.417592293073651 ? input[3] > 2.249904835165133 ? input[3] > 4.051747139190486 ? var15 = -.013281167238314323 : var15 = .016971087295600894 : var15 = -.0032296953806057044 : input[8] > 1e-35 ? input[3] > 1e-35 ? var15 = -.09772932329003692 : var15 = .10215199291158968 : input[3] > 1e-35 ? var15 = .04042124133857408 : input[4] > 1.7005986908310777 ? var15 = -.03780917296974188 : var15 = -.29617407728303585 : input[3] > 1.2424533248940002 ? input[134] > 1e-35 ? var15 = .019695468056761475 : var15 = -.008073287117671947 : var15 = -.07196945037292647;
  let var16;
  input[0] > 1e-35 ? input[3] > 1e-35 ? input[30] > 1e-35 ? var16 = .04565870990720628 : input[4] > 3.481121732133104 ? var16 = -.0010242035152053465 : input[46] > 1e-35 ? var16 = -.06735757101078846 : var16 = .028047085557873476 : input[4] > .8958797346140276 ? var16 = .061451212522936484 : var16 = -.008994471708946133 : input[4] > 3.8815106545092593 ? var16 = -.015862290359637304 : input[4] > 1.2424533248940002 ? input[156] > 1e-35 ? var16 = -.0353203284829365 : input[135] > 1e-35 ? var16 = -.029955239188290975 : input[153] > 1e-35 ? var16 = -.024262881593313065 : input[21] > 1e-35 ? var16 = -.04039396048201336 : input[155] > 1e-35 ? var16 = .031605649750965394 : input[46] > 1e-35 ? var16 = -.0412690351363074 : input[18] > 1e-35 ? var16 = -.02516534034859168 : input[51] > 1e-35 ? var16 = -.09383050740007202 : input[219] > 1e-35 ? input[30] > 1e-35 ? var16 = .05781620337941066 : var16 = -.031029108058883783 : input[54] > 1e-35 ? var16 = -.1312103962175427 : input[14] > 1e-35 ? var16 = .029309503966067275 : input[52] > 1e-35 ? var16 = -.12376041877584809 : input[49] > 1e-35 ? var16 = -.08405476403385437 : input[129] > 1e-35 ? var16 = -.07017699310303659 : input[3] > 3.238486181444842 ? var16 = .0005864979938663785 : input[90] > 1e-35 ? var16 = -.19027994988708324 : input[4] > 2.4414009612931857 ? var16 = .013036973814688194 : input[141] > 1e-35 ? var16 = -.05866284827055356 : input[196] > 1e-35 ? input[3] > 1.2424533248940002 ? input[3] > 1.4978661367769956 ? var16 = .021738540839636195 : var16 = .10410506831002041 : var16 = -.25590968590756463 : var16 = .0023982515170817725 : var16 = -.04143304307857132;
  let var17;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 3.417592293073651 ? input[2] > 5.335128436483344 ? var17 = -.011443269019739626 : input[1] > 1e-35 ? var17 = .015228192424880932 : var17 = -.005492858431736962 : input[1] > 1e-35 ? input[5] > 3.5694334999727624 ? var17 = .03605247912942737 : var17 = .08439131345296227 : var17 = .009650676995478455 : input[5] > 5.096808314315481 ? input[2] > .8958797346140276 ? input[29] > 1e-35 ? var17 = .07077360688836766 : var17 = .044754385330663386 : var17 = .09313294724999382 : input[8] > 1e-35 ? input[2] > .8958797346140276 ? var17 = .04214845406094496 : var17 = -.10283747682230321 : input[4] > .8958797346140276 ? var17 = .05232959789940822 : input[2] > .8958797346140276 ? var17 = .00730829946441921 : var17 = -.23825070451282065 : input[7] > .9358314658959646 ? input[5] > 3.417592293073651 ? input[8] > 1e-35 ? var17 = -.013117301012430346 : var17 = .010418379595902224 : input[19] > 1e-35 ? var17 = -.07514668047310291 : var17 = .05032486941219513 : input[29] > 1e-35 ? input[1] > 1e-35 ? input[7] > .14547530463198097 ? input[4] > 2.138333059508028 ? var17 = -.009576060406554683 : var17 = -.04582944318062007 : var17 = -.04685159067258116 : var17 = -.07022291581850879 : input[1] > 1e-35 ? input[4] > 2.3502401828962087 ? input[4] > 3.8815106545092593 ? var17 = -.008313873320272646 : input[140] > 1e-35 ? var17 = -.029352675967497712 : input[37] > 1e-35 ? var17 = -.09937923794037767 : var17 = .015967772276156707 : var17 = -.009857373135428817 : input[38] > 1e-35 ? var17 = .011345159604794278 : input[2] > 2.4414009612931857 ? input[30] > 1e-35 ? var17 = .001522017389940959 : var17 = -.026992183902105407 : var17 = -.006358778971076675;
  let var18;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[2] > 2.970085626360216 ? input[7] > .8649016459419877 ? var18 = .018617011644318126 : input[29] > 1e-35 ? input[2] > 4.832297822126891 ? var18 = -.03407648259949232 : var18 = -.0036502511604675977 : input[4] > 3.540854293052788 ? var18 = -.00934040898683245 : var18 = .010922739771398862 : input[7] > .9676186228082213 ? var18 = .05137169375874399 : var18 = .02682190004807807 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? var18 = .065076078729683 : input[8] > 1e-35 ? input[7] > .9750059495478345 ? input[7] > .996914501566243 ? var18 = .08915557171019604 : var18 = -.06286636147644172 : var18 = .0902247220475161 : input[4] > .8958797346140276 ? var18 = .09051085461905525 : input[9] > 1e-35 ? var18 = -.19701197524821418 : var18 = .005536577088671752 : input[30] > 1e-35 ? var18 = .0682573098268795 : var18 = .031380692115494484 : input[2] > 4.151008904875603 ? input[155] > 1e-35 ? var18 = .026867659395235544 : input[7] > .5866799179067689 ? var18 = -.008345671861059714 : var18 = -.02185200164340811 : input[7] > .9626084674797213 ? input[22] > 1e-35 ? var18 = -.024341883095402903 : input[141] > 1e-35 ? input[29] > 1e-35 ? var18 = .08888912525147288 : var18 = -.040584195806350004 : var18 = .014817521849450843 : input[4] > 1.7005986908310777 ? input[4] > 3.9219243190762363 ? var18 = -.01259238316205765 : input[156] > 1e-35 ? var18 = -.03305969547622109 : input[50] > 1e-35 ? var18 = -.10133912689920138 : input[155] > 1e-35 ? var18 = .025358210175047153 : input[55] > 1e-35 ? var18 = -.14645261489281414 : input[9] > 1e-35 ? var18 = .012035823488806215 : var18 = .0010743871783232305 : var18 = -.030440082321355873;
  let var19;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[7] > .30853255358841714 ? input[4] > .8958797346140276 ? input[138] > 1e-35 ? var19 = .0708169212387357 : input[7] > .9974623466432676 ? var19 = .06323909894881967 : var19 = .04463133906529934 : var19 = -.006876640569960593 : input[4] > 2.138333059508028 ? var19 = .02983313061920756 : var19 = -.012849740499321841 : input[138] > 1e-35 ? var19 = .05170725384597862 : input[134] > 1e-35 ? var19 = .03407970940934425 : input[32] > 1e-35 ? var19 = .04641257566344885 : input[217] > 1e-35 ? var19 = .04726549849359106 : input[152] > 1e-35 ? var19 = .04284855498215312 : var19 = -.018635981778740818 : input[7] > .9358314658959646 ? input[1] > 1e-35 ? var19 = .013495195381145214 : var19 = -.0017562536904350947 : input[153] > 1e-35 ? var19 = -.035450683955968364 : input[135] > 1e-35 ? var19 = -.033677490938511655 : input[1] > 1e-35 ? input[156] > 1e-35 ? var19 = -.03492338371344172 : input[4] > 2.012675845367575 ? input[8] > 1e-35 ? var19 = -.012478407554855247 : input[58] > 1e-35 ? var19 = -.06588308463544146 : var19 = .01024668455910621 : var19 = -.017964352445712636 : input[138] > 1e-35 ? var19 = .023509519134334668 : input[134] > 1e-35 ? var19 = .009985116251562821 : input[219] > 1e-35 ? var19 = -.08089904073615993 : input[144] > 1e-35 ? var19 = -.08668450969211726 : input[146] > 1e-35 ? var19 = -.11193950701534479 : input[91] > 1e-35 ? var19 = -.09510832561737878 : input[47] > 1e-35 ? var19 = -.06671901650698997 : input[145] > 1e-35 ? var19 = -.10185972302071798 : input[142] > 1e-35 ? var19 = -.050979038763275586 : var19 = -.008318124414257324;
  let var20;
  input[2] > 2.4414009612931857 ? input[7] > .5866799179067689 ? input[1] > 1e-35 ? input[2] > 5.059420419187638 ? var20 = -.004966114458456121 : input[3] > 1.4978661367769956 ? input[6] > 3.9219243190762363 ? var20 = .016160825033090097 : input[4] > 2.673553765358735 ? var20 = -.008119911797705546 : input[7] > .9676186228082213 ? var20 = .10191214482603793 : var20 = .010406721157764452 : input[4] > 2.602003343538398 ? var20 = .011963972867583182 : input[209] > 1e-35 ? input[24] > 1e-35 ? var20 = -.4633165603515741 : var20 = -.027241411195905924 : var20 = -.01021341522779383 : input[3] > .8958797346140276 ? input[39] > 1e-35 ? var20 = -.07106669495723826 : var20 = -.003949154414882924 : var20 = -.06434150131915288 : input[3] > 1.7005986908310777 ? input[1] > 1e-35 ? var20 = .005050893558647285 : var20 = -.01649483548684653 : input[217] > 1e-35 ? var20 = .0027009145619870485 : input[7] > .16413460456379095 ? var20 = -.021492035902356262 : var20 = -.04956173856083012 : input[3] > 1e-35 ? input[2] > .8958797346140276 ? input[4] > 3.314020688089767 ? var20 = .004614615289098078 : input[125] > 1e-35 ? var20 = -.053838919278819175 : input[141] > 1e-35 ? var20 = -.031232660335016666 : input[7] > .9676186228082213 ? var20 = .031522536832188655 : var20 = .016369948821613637 : var20 = -.001970208279177045 : input[2] > 1.2424533248940002 ? input[7] > .8045995506441456 ? input[6] > 3.0677824455408698 ? var20 = .035653122678366796 : var20 = .09668798382116887 : var20 = .017192957672541906 : input[6] > 5.427147823217923 ? input[2] > .8958797346140276 ? var20 = .05167603828162103 : var20 = .07201242912898732 : input[4] > .8958797346140276 ? input[6] > 4.3882378946731615 ? var20 = .04079789432551034 : var20 = -.00477197753110532 : var20 = -.1330224689055222;
  let var21;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[6] > 5.519456907163478 ? input[3] > 1e-35 ? var21 = .025938224253040522 : input[7] > .9480659774309611 ? var21 = .06369970668749851 : var21 = .04567224211157202 : input[8] > 1e-35 ? var21 = -.03272937728465352 : input[7] > .8002228006195066 ? input[219] > 1e-35 ? var21 = -.06304921759586735 : var21 = .04293432033794005 : var21 = .0034607309539607385 : input[30] > 1e-35 ? var21 = .03333728636724803 : input[134] > 1e-35 ? var21 = .03171739664928598 : input[32] > 1e-35 ? var21 = .04247521237473512 : input[217] > 1e-35 ? var21 = .04515237436183519 : input[138] > 1e-35 ? var21 = .043674672816657406 : var21 = -.021495642896979555 : input[153] > 1e-35 ? input[7] > .7405695827634472 ? var21 = -.005353425538700483 : var21 = -.03818743916821677 : input[1] > 1e-35 ? input[156] > 1e-35 ? var21 = -.026937004040991603 : input[9] > 1e-35 ? var21 = .01687211330975012 : input[129] > 1e-35 ? var21 = -.06344334253531962 : input[5] > 3.276966702012906 ? input[3] > 2.4414009612931857 ? input[3] > 4.3882378946731615 ? var21 = -.029787052855333836 : input[140] > 1e-35 ? var21 = -.0315337765152156 : var21 = .01010125865272709 : var21 = -.003643087951301554 : input[3] > 1.8688348091416842 ? var21 = -.009293469974765106 : input[7] > .9407436463973539 ? input[19] > 1e-35 ? var21 = -.10837629052758145 : var21 = .08012552652666853 : var21 = -.03240188731353479 : input[3] > .8958797346140276 ? input[138] > 1e-35 ? var21 = .028089541906112948 : input[134] > 1e-35 ? var21 = .011775653029555359 : input[54] > 1e-35 ? var21 = -.1329256322319015 : var21 = -.010520589644656487 : var21 = -.058476715353390545;
  let var22;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 2.970085626360216 ? input[3] > 1.4978661367769956 ? input[1] > 1e-35 ? var22 = .015966021866473425 : var22 = -.004942501766182043 : input[7] > .7646034107159144 ? var22 = .0008922354520049755 : var22 = -.02377096637770522 : input[1] > 1e-35 ? var22 = .03185471115279236 : var22 = .009030463601278762 : input[6] > 5.033695261903033 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var22 = .03583918176912262 : var22 = .05978765203310842 : input[3] > 1.4978661367769956 ? var22 = .04363706154403441 : var22 = .08596238935719265 : input[8] > 1e-35 ? input[4] > 3.676220550121792 ? var22 = -.14139420543234502 : input[6] > 4.135134555718313 ? var22 = .06641653507737781 : var22 = -.08482961471233386 : input[219] > 1e-35 ? var22 = -.08432601495298837 : var22 = .036383288293587494 : input[2] > 4.212100162283537 ? input[4] > 4.06899022722607 ? var22 = -.027653216441781994 : input[4] > 1.2424533248940002 ? var22 = -.0074990353344818825 : var22 = -.047274115298751654 : input[3] > 4.350257124271638 ? var22 = -.021535524001034215 : input[7] > .9626084674797213 ? input[6] > 3.314020688089767 ? var22 = .008343192891130257 : input[3] > 2.602003343538398 ? var22 = -.029175290449111352 : input[19] > 1e-35 ? var22 = -.0982821612709299 : var22 = .07967468666491928 : input[3] > 2.012675845367575 ? input[1] > 1e-35 ? input[141] > 1e-35 ? var22 = -.050000478457880464 : input[99] > 1e-35 ? var22 = .03066844761711629 : var22 = .00757148708610041 : input[14] > 1e-35 ? var22 = .030325269400598688 : input[138] > 1e-35 ? var22 = .029925649226634522 : var22 = -.005865781126590595 : input[7] > .14547530463198097 ? var22 = -.006746433384005582 : var22 = -.03419211369300411;
  let var23;
  input[7] > .8453853180651066 ? input[9] > 1e-35 ? input[204] > 1e-35 ? input[5] > 3.979637980058199 ? var23 = .03492440471960614 : var23 = .10640952227810228 : var23 = .024674544399570984 : input[21] > 1e-35 ? var23 = -.03056548710005192 : input[24] > 1e-35 ? var23 = .04417102228084844 : input[18] > 1e-35 ? input[5] > 3.417592293073651 ? var23 = -.01915628728670732 : var23 = .08218968786016527 : input[22] > 1e-35 ? var23 = -.015022557207326592 : input[7] > .9941118339384912 ? var23 = .024199625103362956 : input[135] > 1e-35 ? var23 = -.01204089678887213 : input[5] > 3.156774023138548 ? input[14] > 1e-35 ? var23 = .03343354440638259 : input[144] > 1e-35 ? var23 = -.06832894943893354 : var23 = .0114980261254499 : input[12] > 1e-35 ? input[100] > 1e-35 ? var23 = .09915326976032354 : var23 = -.011405707270850872 : var23 = .05400113313957842 : input[138] > 1e-35 ? var23 = .029070115198082648 : input[7] > .11348809759407426 ? input[9] > 1e-35 ? var23 = .0124381999772114 : input[14] > 1e-35 ? var23 = .021548670539672424 : input[152] > 1e-35 ? var23 = .02386756199239544 : input[155] > 1e-35 ? var23 = .024879667358339554 : input[217] > 1e-35 ? var23 = .014495299809094343 : input[17] > 1e-35 ? var23 = .023665548251738264 : input[21] > 1e-35 ? var23 = -.04352613176288253 : input[142] > 1e-35 ? var23 = -.041479100066479035 : input[47] > 1e-35 ? var23 = -.054730987834988636 : input[135] > 1e-35 ? var23 = -.02041552814087628 : input[12] > 1e-35 ? var23 = .00599257601351913 : input[19] > 1e-35 ? var23 = .017289098956116435 : var23 = -.005346146967029123 : var23 = -.015035114021856248;
  let var24;
  input[2] > 2.524928003624769 ? input[39] > 1e-35 ? var24 = -.054727205204329936 : input[2] > 5.1209788959100075 ? input[3] > 1.7005986908310777 ? var24 = -.006846267565269392 : input[5] > 6.826002629905951 ? var24 = -.031164989612379426 : var24 = -.002741497453668024 : input[91] > 1e-35 ? var24 = -.09671408062751485 : input[4] > 1.4978661367769956 ? input[1] > 1e-35 ? input[3] > 2.249904835165133 ? var24 = .01457038163563883 : input[7] > .1998775237752378 ? var24 = .0022386178156093236 : var24 = -.023878153904868322 : input[138] > 1e-35 ? var24 = .02577301491883366 : input[134] > 1e-35 ? var24 = .012196636151923639 : var24 = -.011620066788940737 : var24 = -.02547345266933859 : input[3] > 1e-35 ? input[2] > 1e-35 ? input[1] > 1e-35 ? input[125] > 1e-35 ? var24 = -.054140900037670386 : input[5] > 3.5694334999727624 ? var24 = .011956526123643832 : input[3] > 2.602003343538398 ? var24 = -.02114925328017154 : input[7] > .9662372103242399 ? var24 = .08782010508103752 : var24 = -.017223208918198857 : input[138] > 1e-35 ? var24 = .03552967765214556 : input[134] > 1e-35 ? var24 = .02029988465200251 : var24 = -.0027071098830831453 : var24 = -.010563423003945922 : input[2] > 1.2424533248940002 ? input[1] > 1e-35 ? input[5] > 3.156774023138548 ? var24 = .020789754957971127 : input[8] > 1e-35 ? var24 = .09676607622337308 : var24 = -.13431522143386382 : var24 = -.04328684841078818 : input[6] > 5.427147823217923 ? input[2] > .8958797346140276 ? var24 = .04286558286931383 : var24 = .0632450248289209 : input[4] > .8958797346140276 ? input[8] > 1e-35 ? input[4] > 3.676220550121792 ? var24 = -.12134536828900527 : var24 = -.0021406313647826976 : var24 = .02703554321037796 : var24 = -.10987991092748431;
  let var25;
  input[3] > 3.238486181444842 ? input[30] > 1e-35 ? var25 = .009506310623811853 : input[39] > 1e-35 ? var25 = -.0390989997202559 : input[187] > 1e-35 ? var25 = -.07249802958837052 : input[46] > 1e-35 ? var25 = -.05080833699879983 : input[143] > 1e-35 ? var25 = -.06014247774751084 : input[219] > 1e-35 ? var25 = -.05179602905357869 : input[6] > 6.1537953943602615 ? input[15] > 1e-35 ? var25 = -.025022238573512268 : var25 = .0011147676050071987 : var25 = -.013840284878987585 : input[7] > .9626084674797213 ? input[5] > 3.417592293073651 ? input[3] > 1e-35 ? input[6] > 3.9219243190762363 ? var25 = .008593726678003006 : var25 = .05272960047875293 : input[5] > 4.424828703319957 ? var25 = .03164186747443643 : var25 = -.019512539098210834 : input[3] > 2.602003343538398 ? var25 = -.0016290671598964486 : input[3] > 1.2424533248940002 ? input[8] > 1e-35 ? var25 = -.1920669264002081 : var25 = .09024848315677546 : input[8] > 1e-35 ? var25 = .06434775905745808 : input[44] > 1e-35 ? var25 = .11389595321585716 : var25 = -.036695137521575945 : input[6] > 4.987019604243537 ? input[141] > 1e-35 ? var25 = -.03813401544172915 : input[138] > 1e-35 ? var25 = .029859363038130183 : input[58] > 1e-35 ? var25 = -.06135288076045784 : input[39] > 1e-35 ? var25 = -.04609789446034826 : input[7] > .14547530463198097 ? input[11] > 1e-35 ? var25 = .0007666746170242386 : input[129] > 1e-35 ? var25 = -.04984156530077896 : input[18] > 1e-35 ? var25 = -.01554744241744757 : input[10] > 1e-35 ? input[219] > 1e-35 ? var25 = -.043774129950223145 : var25 = .0062051346459236715 : var25 = .014331149613197688 : var25 = -.004868728135790881 : var25 = -.009310258638274059;
  let var26;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 3.817651943129708 ? input[3] > 1.8688348091416842 ? var26 = .0015603015891380355 : var26 = -.018128739944024166 : input[5] > 3.5694334999727624 ? input[6] > 5.427147823217923 ? var26 = .017445711714402918 : var26 = -.006013735620008879 : input[3] > 1.2424533248940002 ? var26 = .08568755276415789 : input[4] > 2.602003343538398 ? var26 = .03195371214541369 : input[6] > 2.970085626360216 ? var26 = -.3506562612672139 : var26 = -.038898555979475155 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? var26 = .04755052122467952 : input[3] > 1.4978661367769956 ? var26 = .03861414711908666 : var26 = .08185303441168128 : input[8] > 1e-35 ? input[5] > 4.424828703319957 ? var26 = .016473058697350277 : var26 = -.08025494910794358 : input[219] > 1e-35 ? var26 = -.06606152909975703 : var26 = .033955083083682974 : input[153] > 1e-35 ? var26 = -.022769519242142378 : input[155] > 1e-35 ? var26 = .021917770434351808 : input[3] > 4.051747139190486 ? var26 = -.016298405734735375 : input[4] > 1.2424533248940002 ? input[156] > 1e-35 ? var26 = -.023334559703496013 : input[91] > 1e-35 ? var26 = -.07354920004445119 : input[21] > 1e-35 ? var26 = -.03472005783841508 : input[9] > 1e-35 ? var26 = .0088614848397155 : input[152] > 1e-35 ? var26 = .01650058356046536 : input[50] > 1e-35 ? var26 = -.08689386936995537 : input[219] > 1e-35 ? var26 = -.025293957964644554 : input[22] > 1e-35 ? var26 = -.02911571993589908 : input[52] > 1e-35 ? var26 = -.10060771324188006 : input[151] > 1e-35 ? var26 = -.11187645020980451 : input[49] > 1e-35 ? var26 = -.07269389735370566 : var26 = .00010096962399904588 : var26 = -.0308050484468705;
  let var27;
  input[0] > 1e-35 ? input[2] > 1.7005986908310777 ? input[2] > 3.1132683346437333 ? input[2] > 5.589117819455554 ? var27 = -.01634394676179118 : input[135] > 1e-35 ? var27 = -.025978770194490092 : var27 = .003478202132522329 : input[5] > 3.772694874805912 ? input[6] > 5.55101783490842 ? var27 = .0201238113260563 : var27 = -.003889163967162744 : var27 = .0619995705843029 : input[6] > 5.391349638084432 ? input[2] > .8958797346140276 ? var27 = .04441301244720888 : var27 = .07580163057048642 : input[5] > 4.424828703319957 ? var27 = .030400021609279876 : input[135] > 1e-35 ? input[6] > 4.03420147928485 ? var27 = -.1614949959350695 : var27 = .011868201115510678 : input[144] > 1e-35 ? var27 = -.24480189212017833 : var27 = .00743113235503554 : input[135] > 1e-35 ? var27 = -.02500550080046047 : input[155] > 1e-35 ? var27 = .019914668189284807 : input[14] > 1e-35 ? var27 = .016272311078771865 : input[2] > 4.436734027666816 ? var27 = -.010942143677155697 : input[152] > 1e-35 ? var27 = .01655515192923104 : input[5] > 3.276966702012906 ? input[208] > 1e-35 ? var27 = .01544696196221499 : input[209] > 1e-35 ? var27 = .011686634595667988 : input[204] > 1e-35 ? var27 = .012948259428096241 : input[54] > 1e-35 ? var27 = -.0987840586310838 : input[17] > 1e-35 ? var27 = .019642065140602974 : input[9] > 1e-35 ? var27 = .002408217148588979 : input[129] > 1e-35 ? var27 = -.051760999013377655 : input[53] > 1e-35 ? var27 = -.12326801905337725 : input[156] > 1e-35 ? var27 = -.027148214121600067 : var27 = -.00591946140033722 : input[141] > 1e-35 ? var27 = .08076229481403298 : input[100] > 1e-35 ? var27 = .09029873540689846 : var27 = .004633440115146894;
  let var28;
  input[1] > 1e-35 ? input[4] > 2.138333059508028 ? input[9] > 1e-35 ? input[7] > .9738681190948303 ? input[4] > 2.249904835165133 ? var28 = .0335386338744903 : var28 = .08871810783567416 : var28 = .019225035967642936 : input[7] > .5866799179067689 ? input[44] > 1e-35 ? var28 = -.028577747938027556 : input[22] > 1e-35 ? var28 = -.017080349342057245 : input[123] > 1e-35 ? var28 = -.06459630434555787 : var28 = .01496396100048332 : input[7] > .04507521918085865 ? var28 = .0037545927605624665 : var28 = -.024364818555823085 : input[7] > .3301972011875425 ? input[4] > .8958797346140276 ? var28 = .003955118988355861 : var28 = -.024852972286710795 : input[210] > 1e-35 ? var28 = -.06918033561606161 : var28 = -.016436360434421187 : input[219] > 1e-35 ? var28 = -.07074619361594191 : input[14] > 1e-35 ? var28 = .02288621182895308 : input[30] > 1e-35 ? var28 = .009951065285890723 : input[4] > 3.0677824455408698 ? input[48] > 1e-35 ? var28 = -.08645289278185848 : input[18] > 1e-35 ? var28 = -.07128859518483391 : input[46] > 1e-35 ? var28 = -.059012415377229614 : input[51] > 1e-35 ? var28 = -.09897820075751956 : input[143] > 1e-35 ? var28 = -.0658809793369211 : input[39] > 1e-35 ? var28 = -.05072244120975425 : input[145] > 1e-35 ? var28 = -.1041573357946847 : input[21] > 1e-35 ? var28 = -.07265724033978356 : input[121] > 1e-35 ? var28 = .032340406020414894 : input[150] > 1e-35 ? var28 = -.12780465144045577 : input[50] > 1e-35 ? var28 = -.10084067045905792 : var28 = -.008282579596590931 : input[31] > 1e-35 ? var28 = .09475423612489574 : input[134] > 1e-35 ? var28 = .016436600209473996 : var28 = -.0032052350949025154;
  let var29;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[6] > 5.980149988077803 ? input[3] > 1e-35 ? var29 = .016868562767356994 : input[7] > .9480659774309611 ? var29 = .0490126593301439 : var29 = .03183712887814021 : input[4] > .8958797346140276 ? input[8] > 1e-35 ? var29 = -.018344689935240077 : input[7] > .5762123732244849 ? var29 = .027823839417468396 : var29 = .0022237549483396734 : var29 = -.049221463486990365 : input[30] > 1e-35 ? var29 = .024881540664409785 : input[4] > 3.0677824455408698 ? var29 = -.012956173562801246 : var29 = .010844244442972509 : input[153] > 1e-35 ? var29 = -.021011529883710918 : input[135] > 1e-35 ? var29 = -.022862755771243214 : input[91] > 1e-35 ? var29 = -.06523564179230792 : input[3] > 4.3372693810700085 ? var29 = -.01836396186345982 : input[4] > 1.2424533248940002 ? input[14] > 1e-35 ? var29 = .018063557788938384 : input[1] > 1e-35 ? input[58] > 1e-35 ? var29 = -.05666864992513037 : input[37] > 1e-35 ? var29 = -.09859173931566362 : input[140] > 1e-35 ? var29 = -.026368697925604742 : input[139] > 1e-35 ? var29 = -.06458698835998881 : input[3] > 2.4414009612931857 ? input[8] > 1e-35 ? var29 = -.012750470980894203 : input[128] > 1e-35 ? var29 = -.06062526587440112 : var29 = .011637315217958607 : input[7] > .9569480028661056 ? input[6] > 3.314020688089767 ? input[6] > 8.256477558772088 ? var29 = -.01867324944649552 : var29 = .013333709765106694 : input[19] > 1e-35 ? var29 = -.0862336521704207 : var29 = .06263843669460754 : var29 = -.005209374987876728 : input[29] > 1e-35 ? var29 = -.05314556259108334 : input[144] > 1e-35 ? var29 = -.06747511467043471 : var29 = -.0032459743896180644 : var29 = -.025647852465095045;
  let var30;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.802901033147999 ? input[153] > 1e-35 ? var30 = -.028446025186518367 : input[135] > 1e-35 ? var30 = -.030498458478750823 : input[4] > 1.4978661367769956 ? var30 = .0028332406263713176 : var30 = -.029966327008991617 : var30 = .018714561890725637 : input[6] > 5.033695261903033 ? input[2] > .8958797346140276 ? var30 = .041738631496127304 : var30 = .0701395739744944 : input[7] > .9811887196001154 ? input[28] > 1e-35 ? input[194] > 1e-35 ? var30 = -.6270617037879163 : var30 = -.14198370205598315 : var30 = -.008029082191082339 : var30 = .03966126215239892 : input[153] > 1e-35 ? var30 = -.018792731305353614 : input[135] > 1e-35 ? var30 = -.020500053366640306 : input[156] > 1e-35 ? input[11] > 1e-35 ? var30 = -.05063175110475535 : var30 = -.0120172710473678 : input[147] > 1e-35 ? var30 = -.06181360325166399 : input[7] > .06275229375044648 ? input[52] > 1e-35 ? var30 = -.09381845963236321 : input[4] > 4.424828703319957 ? var30 = -.015836182358134197 : input[4] > 1.2424533248940002 ? input[48] > 1e-35 ? var30 = -.047387335727107405 : input[50] > 1e-35 ? var30 = -.07061356901704502 : input[151] > 1e-35 ? var30 = -.09680213548388712 : input[46] > 1e-35 ? var30 = -.028970851669790916 : input[123] > 1e-35 ? var30 = -.035197840867969954 : input[49] > 1e-35 ? var30 = -.06299268464836878 : input[149] > 1e-35 ? var30 = -.10197175263174806 : input[58] > 1e-35 ? var30 = -.03908263666673043 : input[22] > 1e-35 ? var30 = -.021903737116021876 : input[2] > .8958797346140276 ? var30 = .005307704388235018 : var30 = -.0020984759645931708 : var30 = -.021935509998616008 : var30 = -.01887705116018838;
  let var31;
  input[2] > 2.4414009612931857 ? input[2] > 4.749261159734808 ? input[219] > 1e-35 ? var31 = -.0427111578574511 : input[153] > 1e-35 ? var31 = -.030189831687705213 : input[135] > 1e-35 ? var31 = -.03512251542671204 : var31 = -.005813108237155817 : input[39] > 1e-35 ? var31 = -.03612853474204475 : input[91] > 1e-35 ? var31 = -.07347487395456895 : input[142] > 1e-35 ? var31 = -.04314124434818331 : input[21] > 1e-35 ? var31 = -.03933135423264962 : input[29] > 1e-35 ? input[6] > 4.3882378946731615 ? input[1] > 1e-35 ? var31 = -.0015250307417007892 : var31 = -.0490054084929899 : input[209] > 1e-35 ? var31 = -.19107169934362123 : var31 = -.032434842765588306 : input[18] > 1e-35 ? var31 = -.04413318629193353 : input[5] > 3.772694874805912 ? var31 = .004026864766696988 : input[7] > .9705672697050661 ? input[4] > 2.602003343538398 ? var31 = -.0184663870129198 : var31 = .08888448773905216 : var31 = -.0040785146358560806 : input[29] > 1e-35 ? input[2] > 1.2424533248940002 ? input[1] > 1e-35 ? input[5] > 3.156774023138548 ? var31 = .012676257607559291 : input[4] > 2.012675845367575 ? var31 = .07794141958502514 : var31 = -.23905004122480836 : var31 = -.03904279404529968 : input[6] > 5.818597045157784 ? input[1] > 1e-35 ? var31 = .04439337662833094 : var31 = -.009601154125838422 : input[28] > 1e-35 ? input[7] > .9926276364955392 ? input[156] > 1e-35 ? var31 = .08495906118788314 : input[153] > 1e-35 ? var31 = .09808912606252018 : var31 = -.41470362752984724 : var31 = .024659633328041372 : input[6] > 4.3882378946731615 ? var31 = .02348696158531392 : var31 = -.011219631635525798 : input[2] > .8958797346140276 ? var31 = .00764827947682953 : var31 = -.002636723662133651;
  let var32;
  input[0] > 1e-35 ? input[138] > 1e-35 ? var32 = .04040206743401164 : input[7] > .47159631571429605 ? input[39] > 1e-35 ? var32 = -.04204265697956852 : input[18] > 1e-35 ? var32 = -.02345608311313191 : input[46] > 1e-35 ? var32 = -.07250113205332377 : input[47] > 1e-35 ? var32 = -.06901706560471924 : input[123] > 1e-35 ? var32 = -.02471508138476658 : input[91] > 1e-35 ? var32 = -.08527667683257537 : input[6] > 5.519456907163478 ? input[7] > .9811887196001154 ? var32 = .033642311398086024 : var32 = .019968221974742344 : input[6] > 3.540854293052788 ? input[28] > 1e-35 ? input[7] > .9914949911911836 ? var32 = -.17171139407761582 : var32 = .033182911468765224 : var32 = .0060896749985828915 : input[7] > .9626084674797213 ? var32 = .050178751374534494 : var32 = -.008697473314227091 : input[6] > 5.957131031247307 ? var32 = .008840008772752947 : var32 = -.00839587224544437 : input[57] > 1e-35 ? var32 = -.11000065936717814 : input[187] > 1e-35 ? var32 = -.039919217528968265 : input[135] > 1e-35 ? var32 = -.01777859479698383 : input[7] > .841541958453746 ? input[6] > 8.681774988134558 ? var32 = -.006645633391127337 : var32 = .005363553180866138 : input[7] > .06275229375044648 ? input[141] > 1e-35 ? var32 = -.028575934798358252 : input[147] > 1e-35 ? var32 = -.06523418671938815 : input[53] > 1e-35 ? var32 = -.12439699935111644 : input[47] > 1e-35 ? var32 = -.04201034294282216 : input[21] > 1e-35 ? var32 = -.029998534764449716 : input[11] > 1e-35 ? var32 = -.008349262144218515 : input[10] > 1e-35 ? input[152] > 1e-35 ? var32 = .03211843381827455 : var32 = -.009616753935387912 : var32 = .001507728277179471 : var32 = -.018453367252451447;
  let var33;
  input[2] > 2.4414009612931857 ? input[155] > 1e-35 ? var33 = .02097415247337288 : input[2] > 5.1209788959100075 ? input[219] > 1e-35 ? var33 = -.04107586321461544 : input[153] > 1e-35 ? var33 = -.030708779452328257 : var33 = -.008547089256234949 : input[24] > 1e-35 ? input[113] > 1e-35 ? var33 = .10372474211849725 : var33 = .010871474495452506 : input[46] > 1e-35 ? var33 = -.048875079231930615 : input[152] > 1e-35 ? var33 = .0169028183837229 : input[91] > 1e-35 ? var33 = -.06545106192484919 : input[7] > .5395500104437768 ? input[21] > 1e-35 ? var33 = -.03634133884877529 : input[123] > 1e-35 ? var33 = -.04524486315275367 : var33 = .0007726000210664368 : input[153] > 1e-35 ? var33 = -.026631444280113794 : var33 = -.005897540198114922 : input[29] > 1e-35 ? input[2] > 1.2424533248940002 ? input[141] > 1e-35 ? var33 = .06938494238244022 : input[1] > 1e-35 ? input[4] > 2.602003343538398 ? input[7] > .21160651352969054 ? var33 = .016731168841731828 : var33 = -.009280453313693341 : var33 = -.006549806005743951 : var33 = -.035447929694275064 : input[8] > 1e-35 ? var33 = -.0032912467465369953 : input[4] > 1.2424533248940002 ? input[1] > 1e-35 ? input[2] > .8958797346140276 ? var33 = .024369266212637037 : input[138] > 1e-35 ? var33 = .06205121318768558 : var33 = .03811769435016647 : var33 = -.009452348851889555 : var33 = -.025248141993897872 : input[2] > 1e-35 ? input[57] > 1e-35 ? var33 = -.12191990737301042 : input[4] > 3.3842466058243152 ? var33 = .00020591213976092076 : input[141] > 1e-35 ? var33 = -.03252260939244301 : input[186] > 1e-35 ? var33 = -.13818838492678748 : var33 = .009368844137034227 : var33 = -.007973426105216213;
  let var34;
  input[2] > 2.3502401828962087 ? input[14] > 1e-35 ? var34 = .015015656987761437 : input[30] > 1e-35 ? input[210] > 1e-35 ? input[7] > .6876768869498817 ? var34 = .00543900892248828 : var34 = -.04253496769494065 : input[141] > 1e-35 ? var34 = -.052958350924390156 : input[140] > 1e-35 ? var34 = -.10364099832282586 : var34 = .010452960405207413 : input[24] > 1e-35 ? input[113] > 1e-35 ? var34 = .09898709072741292 : input[209] > 1e-35 ? input[7] > .9821472231924556 ? var34 = -.26615665549082984 : var34 = .09636256138859388 : var34 = .01708542025496261 : input[217] > 1e-35 ? var34 = .008049408683788317 : input[21] > 1e-35 ? var34 = -.04590265539954756 : input[90] > 1e-35 ? var34 = -.13784770816769107 : input[142] > 1e-35 ? var34 = -.04628126597884301 : input[47] > 1e-35 ? var34 = -.05827975565933709 : input[135] > 1e-35 ? var34 = -.0223224900840969 : input[18] > 1e-35 ? var34 = -.03220713396184497 : input[91] > 1e-35 ? var34 = -.06447405488640102 : input[58] > 1e-35 ? var34 = -.05284544446869763 : input[48] > 1e-35 ? var34 = -.06649148594881385 : input[123] > 1e-35 ? var34 = -.04383701454842744 : input[7] > .07815070294696584 ? input[52] > 1e-35 ? var34 = -.11846610284210293 : input[50] > 1e-35 ? var34 = -.08907531725085399 : input[156] > 1e-35 ? var34 = -.018270336483319834 : input[150] > 1e-35 ? var34 = -.1090721461891663 : input[151] > 1e-35 ? var34 = -.12157322199183473 : var34 = -.001565820654257863 : var34 = -.02380240397829804 : input[7] > .7957410883753849 ? var34 = .01267070049428537 : input[9] > 1e-35 ? var34 = .012970301396505988 : var34 = .0031136826722851885;
  let var35;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 3.817651943129708 ? input[29] > 1e-35 ? var35 = -.01811927921170173 : var35 = -.0007182192063435364 : input[30] > 1e-35 ? var35 = .024303187146750442 : input[1] > 1e-35 ? var35 = .011106265465270054 : input[134] > 1e-35 ? var35 = .029835980521591587 : var35 = -.011058553872914158 : input[29] > 1e-35 ? input[4] > .8958797346140276 ? input[2] > .8958797346140276 ? var35 = .038081831260496 : input[7] > .9761943980359399 ? input[7] > .9974623466432676 ? var35 = .0678338591810893 : var35 = .02371719224774027 : var35 = .0682898584583309 : var35 = -.023148464063014726 : input[30] > 1e-35 ? var35 = .04610988679672867 : var35 = .003060113702583105 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[4] > 2.4414009612931857 ? input[7] > .9587163092581167 ? var35 = .01081564552001606 : var35 = -.006807357600587744 : var35 = -.02409609521595022 : var35 = -.033329165496176885 : input[4] > 4.051747139190486 ? var35 = -.01130115168237245 : input[129] > 1e-35 ? var35 = -.04589370141507604 : input[21] > 1e-35 ? var35 = -.029442074982620643 : input[14] > 1e-35 ? var35 = .016895124578179443 : input[186] > 1e-35 ? var35 = -.11907557430036886 : input[1] > 1e-35 ? input[139] > 1e-35 ? var35 = -.06194447560538838 : input[133] > 1e-35 ? var35 = -.0758465323292204 : input[58] > 1e-35 ? var35 = -.04330766372695393 : input[138] > 1e-35 ? var35 = -.04155491116231014 : input[156] > 1e-35 ? var35 = -.04841608169206507 : input[44] > 1e-35 ? var35 = -.01948221703985556 : var35 = .006580878599054945 : input[217] > 1e-35 ? var35 = .022433802380447482 : var35 = -.00412091757515532;
  let var36;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.970085626360216 ? input[153] > 1e-35 ? var36 = -.024502725801264887 : input[2] > 5.589117819455554 ? var36 = -.01230190569981064 : var36 = .0013078979950003464 : input[1] > 1e-35 ? var36 = .016172143068823742 : var36 = .0006345060509537773 : input[2] > .8958797346140276 ? var36 = .030005982109869073 : input[7] > .9811887196001154 ? input[7] > .9983480540068196 ? var36 = .0671951915420627 : input[4] > .8958797346140276 ? input[204] > 1e-35 ? input[4] > 2.4414009612931857 ? var36 = .044068636573383585 : var36 = -.6634026033584294 : input[28] > 1e-35 ? input[194] > 1e-35 ? var36 = -.3139210817530322 : var36 = -.030502668897116853 : var36 = .02841326513237545 : var36 = -.12080826254458728 : var36 = .05983169094937563 : input[25] > 1e-35 ? var36 = -.03468266531519899 : input[17] > 1e-35 ? var36 = .018557285805987474 : input[91] > 1e-35 ? var36 = -.051420462987159146 : input[153] > 1e-35 ? input[24] > 1e-35 ? var36 = .04301006671297924 : input[57] > 1e-35 ? var36 = -.09748386515224282 : input[7] > .43956365248689394 ? var36 = -.00756781004151352 : var36 = -.03008603678955382 : input[40] > 1e-35 ? var36 = -.06712212199178254 : input[9] > 1e-35 ? input[99] > 1e-35 ? var36 = .02709638137622776 : var36 = .00311232737924217 : input[219] > 1e-35 ? var36 = -.021650545703290135 : input[129] > 1e-35 ? var36 = -.04139534817677377 : input[4] > 4.482986592105174 ? var36 = -.01666373169408667 : input[7] > .14547530463198097 ? input[28] > 1e-35 ? var36 = .0203181446326991 : input[24] > 1e-35 ? var36 = .019321702534414745 : var36 = -.0013149142637674523 : var36 = -.010572437649803333;
  let var37;
  input[1] > 1e-35 ? input[99] > 1e-35 ? var37 = .024922390516579074 : input[7] > .6223082132708274 ? input[5] > 8.674624195715621 ? var37 = -.0013697481432616754 : input[8] > 1e-35 ? input[5] > 3.0201273556387074 ? input[5] > 4.855921334140645 ? var37 = -.0034268395365245545 : var37 = -.034186463672076346 : input[29] > 1e-35 ? var37 = .07759914281958613 : var37 = -.07773573805144608 : input[22] > 1e-35 ? var37 = -.0175879419801366 : input[7] > .9626084674797213 ? var37 = .016773359142537643 : var37 = .008028381804196754 : input[133] > 1e-35 ? var37 = -.0535216100744091 : var37 = -.0005000628423357899 : input[38] > 1e-35 ? input[14] > 1e-35 ? var37 = .05090247458630403 : var37 = .007750826606170666 : input[30] > 1e-35 ? var37 = .007698939719746262 : input[121] > 1e-35 ? var37 = .02303487268261317 : input[56] > 1e-35 ? var37 = .04301822779572479 : input[219] > 1e-35 ? var37 = -.061056125991793546 : input[49] > 1e-35 ? var37 = -.08519783826666813 : input[54] > 1e-35 ? var37 = -.11098408863832084 : input[51] > 1e-35 ? var37 = -.07495147940928196 : input[52] > 1e-35 ? var37 = -.10268521021357209 : input[143] > 1e-35 ? var37 = -.050337621945760906 : input[50] > 1e-35 ? var37 = -.08215637358309871 : input[135] > 1e-35 ? var37 = -.037923453156281546 : input[29] > 1e-35 ? var37 = -.03275476659364492 : input[118] > 1e-35 ? var37 = -.05655325181162936 : input[46] > 1e-35 ? var37 = -.03579874818682071 : input[55] > 1e-35 ? var37 = -.10858775815345066 : input[98] > 1e-35 ? var37 = -.02949179817285505 : input[91] > 1e-35 ? var37 = -.06114394873657414 : var37 = -.0024381269826722327;
  let var38;
  input[0] > 1e-35 ? input[138] > 1e-35 ? var38 = .03188433658945665 : input[6] > 5.957131031247307 ? input[29] > 1e-35 ? var38 = .02161439640262312 : input[46] > 1e-35 ? var38 = -.05856082884648366 : var38 = .00579188508436574 : input[5] > 3.417592293073651 ? var38 = -.0023781291067078423 : input[6] > 2.524928003624769 ? input[29] > 1e-35 ? var38 = -.009165058612451055 : var38 = .06060298049441096 : var38 = -.024654633200924148 : input[29] > 1e-35 ? input[141] > 1e-35 ? var38 = .047057536167451744 : input[5] > 7.751690325550034 ? var38 = -.014630738159823437 : input[6] > 1e-35 ? var38 = -.0022830386545257364 : var38 = -.1244934159203967 : input[141] > 1e-35 ? var38 = -.03108265181870111 : input[151] > 1e-35 ? var38 = -.0899976208431091 : input[53] > 1e-35 ? var38 = -.10125439914522794 : input[57] > 1e-35 ? var38 = -.08285049636367613 : input[48] > 1e-35 ? var38 = -.04071723813859757 : input[147] > 1e-35 ? var38 = -.05043191744833317 : input[49] > 1e-35 ? var38 = -.05480244282058292 : input[52] > 1e-35 ? var38 = -.07341553831872409 : input[91] > 1e-35 ? var38 = -.04164336745260387 : input[50] > 1e-35 ? var38 = -.05943962674275153 : input[40] > 1e-35 ? var38 = -.054773037913883875 : input[129] > 1e-35 ? var38 = -.03640370706396673 : input[54] > 1e-35 ? var38 = -.07483146938849299 : input[22] > 1e-35 ? var38 = -.02027834075472462 : input[186] > 1e-35 ? var38 = -.08116240011202293 : input[143] > 1e-35 ? var38 = -.028437692949603324 : input[21] > 1e-35 ? var38 = -.02421670339700474 : input[46] > 1e-35 ? var38 = -.02303808594532841 : var38 = .0030552215125396933;
  let var39;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[4] > 2.138333059508028 ? input[9] > 1e-35 ? var39 = .02933727780739186 : input[6] > 4.722943345003718 ? input[7] > .9246495578512688 ? var39 = .024680404379144982 : var39 = .012015730636539185 : input[113] > 1e-35 ? var39 = .09112392780348796 : input[135] > 1e-35 ? input[7] > .990877425524446 ? var39 = -.11617284449593282 : var39 = -.005246041787488675 : var39 = -.011069319481086321 : input[90] > 1e-35 ? var39 = -.2763006993902732 : input[7] > .9546729796082215 ? input[6] > 3.0677824455408698 ? var39 = .009233858920042097 : var39 = .08920751503262825 : var39 = -.008824102277148265 : input[138] > 1e-35 ? var39 = .02736126919460762 : input[4] > 2.917405368531303 ? input[30] > 1e-35 ? var39 = .013112272135200274 : input[217] > 1e-35 ? var39 = .035799930603658235 : var39 = -.015618218537266096 : var39 = .010656981322113845 : input[14] > 1e-35 ? var39 = .01147191978691208 : input[17] > 1e-35 ? var39 = .016681596753170068 : input[135] > 1e-35 ? var39 = -.017396147137824756 : input[4] > 1.8688348091416842 ? input[4] > 4.03420147928485 ? var39 = -.008863534867945834 : input[31] > 1e-35 ? var39 = .05416038384474034 : input[113] > 1e-35 ? var39 = .012656827040897288 : input[204] > 1e-35 ? var39 = .011410879858785482 : input[208] > 1e-35 ? input[1] > 1e-35 ? var39 = .02085606775425661 : var39 = -.008618410086291444 : input[53] > 1e-35 ? var39 = -.09674487817291225 : input[155] > 1e-35 ? var39 = .010841012663281826 : var39 = -.0027234799964982103 : input[100] > 1e-35 ? input[6] > 4.226807104886684 ? var39 = -.02684998739505702 : var39 = .09196076999373319 : var39 = -.014557367931257406;
  let var40;
  input[1] > 1e-35 ? input[4] > 2.4414009612931857 ? input[140] > 1e-35 ? var40 = -.020508725755139606 : input[9] > 1e-35 ? var40 = .014160204295049248 : input[37] > 1e-35 ? var40 = -.06190233326923697 : input[6] > 1e-35 ? var40 = .005164496028342236 : var40 = -.11389189550910446 : input[141] > 1e-35 ? var40 = -.04125881484049697 : input[186] > 1e-35 ? var40 = -.17160163910476212 : input[29] > 1e-35 ? input[6] > 3.676220550121792 ? var40 = -.010283419868136159 : input[7] > .9626084674797213 ? var40 = -.1716178372310524 : var40 = -.008856137283327148 : input[28] > 1e-35 ? var40 = .05315666786902214 : input[129] > 1e-35 ? var40 = -.04136913767615559 : input[7] > .9705672697050661 ? input[6] > 3.540854293052788 ? var40 = .00751812285476753 : input[8] > 1e-35 ? var40 = -.11960098941111366 : var40 = .06631760098044483 : input[210] > 1e-35 ? input[30] > 1e-35 ? var40 = -.05338190010412709 : var40 = .017275201286894953 : input[30] > 1e-35 ? var40 = .014424216946760394 : input[99] > 1e-35 ? var40 = .027062693955934525 : var40 = -.006762492910108134 : input[219] > 1e-35 ? var40 = -.0534489198792768 : input[138] > 1e-35 ? var40 = .017328465617667224 : input[4] > 2.970085626360216 ? input[144] > 1e-35 ? var40 = -.0662951231725991 : input[143] > 1e-35 ? var40 = -.04739088646917139 : input[145] > 1e-35 ? var40 = -.07635546796992515 : input[14] > 1e-35 ? var40 = .012433708195861912 : input[217] > 1e-35 ? var40 = .021046036228368578 : input[51] > 1e-35 ? var40 = -.07024391932712475 : var40 = -.007585229386863768 : input[127] > 1e-35 ? var40 = .0788172427657374 : var40 = .0036475442240054556;
  let var41;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 2.802901033147999 ? input[153] > 1e-35 ? var41 = -.02488671343402725 : input[135] > 1e-35 ? var41 = -.026342401137212534 : input[4] > 1.4978661367769956 ? var41 = -.0002120610158998857 : var41 = -.02619014803287452 : input[5] > 3.772694874805912 ? var41 = .00791871819482647 : var41 = .05245006986819034 : input[5] > 5.431533816254341 ? input[2] > .8958797346140276 ? var41 = .026755493155023333 : var41 = .05657996196424821 : input[5] > 4.424828703319957 ? input[28] > 1e-35 ? var41 = -.12833948112036647 : var41 = .02009706276124955 : input[135] > 1e-35 ? var41 = -.1062651205805238 : var41 = -.014392542658357654 : input[156] > 1e-35 ? input[11] > 1e-35 ? var41 = -.0426876288098691 : var41 = -.009210886749467585 : input[25] > 1e-35 ? var41 = -.029685120249418873 : input[153] > 1e-35 ? input[24] > 1e-35 ? var41 = .039675921298659045 : var41 = -.01470247025894634 : input[135] > 1e-35 ? var41 = -.013162475027411236 : input[2] > 1e-35 ? input[22] > 1e-35 ? var41 = -.01924589513592333 : input[21] > 1e-35 ? var41 = -.02301719200164619 : input[5] > 8.75754777636908 ? input[4] > 2.602003343538398 ? var41 = -.0007468484638490539 : var41 = -.0158247553028744 : input[1] > 1e-35 ? input[99] > 1e-35 ? var41 = .024493682002973784 : input[42] > 1e-35 ? var41 = -.07469088345156226 : input[45] > 1e-35 ? var41 = -.03838380763638677 : input[114] > 1e-35 ? var41 = .02409327545276692 : input[154] > 1e-35 ? var41 = -.038977286951036944 : input[208] > 1e-35 ? var41 = .021915882358345885 : var41 = .003839964304606302 : var41 = -.0014382346596150915 : var41 = -.008713493537728363;
  let var42;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 4.119004124609202 ? input[3] > 1.2424533248940002 ? var42 = -.0017308950709495397 : var42 = -.020269742816377157 : input[5] > 3.5694334999727624 ? input[6] > 6.468474521450064 ? var42 = .007854184286630537 : var42 = -.005163758444496073 : input[3] > 1.2424533248940002 ? input[12] > 1e-35 ? var42 = -.009039854020477722 : var42 = .08762320620103459 : input[194] > 1e-35 ? var42 = -.3433922378591172 : input[24] > 1e-35 ? var42 = -.2523113760729937 : var42 = -.000461371156912453 : input[5] > 5.692045796563381 ? input[3] > 1.4978661367769956 ? var42 = .007177758561499448 : input[2] > .8958797346140276 ? var42 = .03195343200682438 : var42 = .059909349900388334 : input[5] > 4.424828703319957 ? input[28] > 1e-35 ? var42 = -.10695282804536732 : var42 = .019125081292682575 : input[135] > 1e-35 ? var42 = -.09257011968677195 : var42 = -.012855523323410875 : input[14] > 1e-35 ? var42 = .010052176448775013 : input[152] > 1e-35 ? var42 = .011482760058014926 : input[156] > 1e-35 ? var42 = -.017677609761538152 : input[24] > 1e-35 ? var42 = .01670301885059328 : input[39] > 1e-35 ? var42 = -.02425844450882272 : input[12] > 1e-35 ? input[3] > 1.2424533248940002 ? input[6] > 5.980149988077803 ? var42 = .01117036123239103 : input[3] > 1.4978661367769956 ? var42 = -.005154239762347923 : var42 = .06349844063391799 : var42 = -.011876368966362884 : input[4] > 3.772694874805912 ? var42 = -.010120762110714197 : input[5] > 3.276966702012906 ? input[4] > 2.4414009612931857 ? input[4] > 3.1132683346437333 ? var42 = -.0035902728428789336 : var42 = .003411450739155564 : input[5] > 8.17933999189099 ? var42 = -.018866709049095685 : var42 = -.0038747233097564068 : var42 = .024379138339081993;
  let var43;
  input[7] > .5866799179067689 ? input[11] > 1e-35 ? input[217] > 1e-35 ? var43 = .01816196279626246 : var43 = -.008720340174685528 : input[14] > 1e-35 ? var43 = .017422275374961747 : input[3] > 2.802901033147999 ? input[6] > 6.0026509725338455 ? input[18] > 1e-35 ? var43 = -.035421013136394335 : input[219] > 1e-35 ? var43 = -.03997357699142973 : input[3] > 4.993822430271426 ? var43 = -.03250278247092862 : var43 = .004080430247607075 : var43 = -.010055330454519094 : input[5] > 9.345963324807864 ? var43 = -.008136951493137817 : input[90] > 1e-35 ? var43 = -.16414188828180187 : input[45] > 1e-35 ? var43 = -.0395103723535772 : input[17] > 1e-35 ? input[6] > 3.314020688089767 ? var43 = .03144428117941763 : var43 = -.12305809642153893 : input[5] > 3.417592293073651 ? var43 = .006863569747629234 : input[7] > .9626084674797213 ? input[204] > 1e-35 ? var43 = .08986402088848823 : input[100] > 1e-35 ? var43 = .09658177526577977 : input[141] > 1e-35 ? var43 = .06795495668113817 : input[28] > 1e-35 ? input[3] > 1e-35 ? var43 = .10311172778826272 : var43 = -.12367638872784459 : input[209] > 1e-35 ? var43 = .06796205879581844 : input[6] > 3.0677824455408698 ? input[3] > 2.012675845367575 ? var43 = -.1815028770626217 : var43 = -.027600842388305583 : var43 = .013979123567456554 : var43 = -.003475039039176338 : input[6] > 4.3882378946731615 ? input[3] > 3.6242520361853052 ? var43 = -.008151073332139989 : input[3] > 2.4414009612931857 ? input[48] > 1e-35 ? var43 = -.05732062477153205 : var43 = .0038104987226822806 : input[7] > .14547530463198097 ? var43 = -.0015360108147469411 : var43 = -.014797616303672155 : input[3] > .8958797346140276 ? var43 = -.010446976011382926 : var43 = -.039018423658353285;
  let var44;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 4.620046665062766 ? input[3] > 1.8688348091416842 ? var44 = -.0031733808376565214 : var44 = -.019463570735432378 : var44 = .0032566959999593536 : input[5] > 5.692045796563381 ? input[3] > 1.4978661367769956 ? var44 = .006472511895453073 : input[2] > .8958797346140276 ? var44 = .029439910335277677 : var44 = .05703290277034656 : input[219] > 1e-35 ? var44 = -.06489530937321614 : input[5] > 4.424828703319957 ? var44 = .017756995160153607 : input[125] > 1e-35 ? var44 = -.13863131633711023 : var44 = -.011337464460106939 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[3] > 1e-35 ? var44 = -.04822012795561216 : input[125] > 1e-35 ? var44 = .06083023155995546 : input[141] > 1e-35 ? var44 = .04503531231698771 : input[5] > 7.751690325550034 ? var44 = -.008826435995092507 : var44 = .0004769856196102064 : input[5] > 5.895778350950796 ? var44 = -.03439788269853701 : var44 = .0012862199645308793 : input[141] > 1e-35 ? input[3] > 3.0677824455408698 ? var44 = .0046610227653059695 : var44 = -.04504560149384845 : input[3] > 4.3372693810700085 ? var44 = -.011924612526365003 : input[151] > 1e-35 ? var44 = -.07909878419302184 : input[40] > 1e-35 ? var44 = -.04837106565429512 : input[52] > 1e-35 ? var44 = -.06478730352567258 : input[18] > 1e-35 ? input[46] > 1e-35 ? var44 = .060888920864590634 : input[5] > 3.5694334999727624 ? var44 = -.02601024872439008 : var44 = .07960150564774994 : input[46] > 1e-35 ? var44 = -.027213119561154103 : input[51] > 1e-35 ? var44 = -.054081846676903716 : input[54] > 1e-35 ? var44 = -.07375359621246233 : input[50] > 1e-35 ? var44 = -.0570341640965886 : var44 = .0021129818482267812;
  let var45;
  input[2] > 2.861792550976191 ? input[11] > 1e-35 ? input[58] > 1e-35 ? var45 = -.09222476830824185 : input[156] > 1e-35 ? var45 = -.044357001480428 : var45 = -.009033627105152873 : input[8] > 1e-35 ? input[5] > 7.429817490674132 ? var45 = -.007435399919321396 : var45 = -.025630334739367253 : input[155] > 1e-35 ? var45 = .02064199664419035 : input[5] > 8.75754777636908 ? input[2] > 4.119004124609202 ? var45 = -.012759040985224594 : var45 = -.0009375109950390992 : input[21] > 1e-35 ? var45 = -.028664595543047417 : input[187] > 1e-35 ? var45 = -.03837361994986333 : input[22] > 1e-35 ? var45 = -.027274995074267547 : input[14] > 1e-35 ? var45 = .016392245342055616 : input[17] > 1e-35 ? var45 = .022509678093313362 : input[28] > 1e-35 ? var45 = .025145343126000193 : input[39] > 1e-35 ? var45 = -.02939647868188604 : var45 = .00042395552644239256 : input[29] > 1e-35 ? input[2] > 2.012675845367575 ? var45 = -.0030925701821976686 : input[5] > 6.0390628155997765 ? input[2] > .8958797346140276 ? var45 = .010736817315927911 : var45 = .02426980448005241 : input[28] > 1e-35 ? input[194] > 1e-35 ? var45 = -.3070569158934055 : input[196] > 1e-35 ? var45 = -.5506885961570867 : var45 = -.033353293982668515 : var45 = .006553036790621832 : input[2] > 1.2424533248940002 ? input[5] > 3.5694334999727624 ? input[155] > 1e-35 ? var45 = .02102370525016274 : var45 = .003409533559556135 : input[204] > 1e-35 ? var45 = .08873962123163927 : input[24] > 1e-35 ? var45 = .10555359938821945 : input[28] > 1e-35 ? var45 = .09719645392539251 : input[196] > 1e-35 ? var45 = .08224623369607056 : var45 = -.020134405544960793 : var45 = -.0015937623030202052;
  let var46;
  input[0] > 1e-35 ? input[2] > 1.8688348091416842 ? input[3] > 1.4978661367769956 ? input[3] > 3.540854293052788 ? var46 = -.0076758153562413375 : input[18] > 1e-35 ? var46 = -.04295196457825341 : input[51] > 1e-35 ? var46 = -.13248011320062422 : var46 = .008952360414023641 : input[7] > .987306237235768 ? var46 = .006439776900137331 : var46 = -.012660562195035134 : input[3] > 2.861792550976191 ? input[30] > 1e-35 ? var46 = .026757175255811883 : var46 = -.01062556784320532 : input[2] > .8958797346140276 ? var46 = .02114926571950188 : input[8] > 1e-35 ? input[7] > .9738681190948303 ? input[7] > .996914501566243 ? var46 = .039844832378913425 : var46 = -.06690456482695102 : var46 = .05010759067838343 : input[7] > .9901971344332651 ? input[204] > 1e-35 ? input[7] > .9945060383544003 ? var46 = .03772632631184001 : var46 = -.28522617893050056 : input[28] > 1e-35 ? var46 = -.060992612788434375 : var46 = .03341245674945403 : var46 = .051288950777861456 : input[8] > 1e-35 ? var46 = -.010769283931178146 : input[29] > 1e-35 ? input[2] > .8958797346140276 ? input[1] > 1e-35 ? input[7] > .98482287934795 ? var46 = .009069204772381522 : var46 = -.004081394384581673 : var46 = -.03594060084257492 : input[7] > .9216401592048815 ? var46 = -.00442206228805168 : var46 = -.03576891499137606 : input[55] > 1e-35 ? var46 = -.08223884312902127 : input[57] > 1e-35 ? var46 = -.0742535346669798 : input[149] > 1e-35 ? var46 = -.07940704728071792 : input[39] > 1e-35 ? var46 = -.017161105634171125 : input[49] > 1e-35 ? var46 = -.04763279499691125 : input[139] > 1e-35 ? var46 = -.027192821855546695 : input[10] > 1e-35 ? var46 = -.0036316338579956914 : var46 = .0026484338648234077;
  let var47;
  input[0] > 1e-35 ? input[2] > 1.4978661367769956 ? input[2] > 5.527441013321604 ? var47 = -.012306712525171806 : input[7] > .26911173821332884 ? input[18] > 1e-35 ? var47 = -.027850707388722303 : input[91] > 1e-35 ? var47 = -.07216882827488169 : input[2] > 2.740319461670996 ? input[3] > 1.4978661367769956 ? var47 = .005596837686865309 : var47 = -.0059429747278747225 : var47 = .009524033665726878 : var47 = -.0077898166249992535 : input[6] > 5.912149824839399 ? input[3] > 1.4978661367769956 ? input[30] > 1e-35 ? var47 = .032201880996274065 : var47 = -.009587971174292791 : input[2] > .8958797346140276 ? var47 = .02761965407835318 : var47 = .05238312639482409 : input[7] > .990877425524446 ? input[28] > 1e-35 ? input[156] > 1e-35 ? var47 = .08220352701195494 : var47 = -.16200772313735304 : input[135] > 1e-35 ? input[6] > 4.310776603370241 ? var47 = -.03126230621131264 : var47 = -.15437767199900418 : input[219] > 1e-35 ? input[2] > .8958797346140276 ? var47 = .018944713961164792 : input[3] > 1e-35 ? var47 = .06629929139668997 : var47 = -.16790799717043633 : input[192] > 1e-35 ? var47 = -.3320398525405097 : var47 = .009790162291004705 : input[125] > 1e-35 ? var47 = -.0996239956884951 : var47 = .017982806591038288 : input[25] > 1e-35 ? var47 = -.02642518530716432 : input[6] > 9.286096980078398 ? input[3] > 2.740319461670996 ? var47 = -.0027582177390145703 : var47 = -.02047492290459601 : input[17] > 1e-35 ? var47 = .01622159988588393 : input[7] > .5866799179067689 ? var47 = .0012556670436606133 : input[3] > 2.3502401828962087 ? input[3] > 3.314020688089767 ? var47 = -.00567335909535631 : var47 = .0036605424249172938 : input[7] > .085616240166877 ? var47 = -.00662352094724046 : var47 = -.024196995936398374;
  let var48;
  input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[2] > 2.802901033147999 ? input[3] > 1.8688348091416842 ? input[4] > 3.6242520361853052 ? var48 = -.008283589876968955 : var48 = .005263882290960596 : input[7] > .9662372103242399 ? var48 = .0028703212438091555 : var48 = -.014488335095453487 : input[5] > 3.5694334999727624 ? var48 = .006182444666070272 : var48 = .04834325475124454 : input[5] > 5.821564412917691 ? input[3] > 1.4978661367769956 ? var48 = .006862035478899274 : input[2] > 1e-35 ? var48 = .03694434517261685 : var48 = .06818308291563471 : input[8] > 1e-35 ? input[4] > 3.979637980058199 ? var48 = -.14792403668068005 : input[5] > 4.297262267176281 ? var48 = .04085199387960594 : var48 = -.08112459203056922 : input[7] > .990877425524446 ? input[204] > 1e-35 ? input[4] > 2.4414009612931857 ? var48 = .040094872099644886 : var48 = -.37432021591644105 : input[128] > 1e-35 ? input[17] > 1e-35 ? var48 = .11216772098992614 : var48 = -.39517539261887863 : var48 = -.006202508512715542 : var48 = .031730389306944315 : input[8] > 1e-35 ? input[5] > 3.156774023138548 ? var48 = -.011787620507206525 : input[3] > 1.2424533248940002 ? var48 = -.0681989521208321 : var48 = .06597717957453096 : input[2] > 1e-35 ? input[25] > 1e-35 ? var48 = -.024543929344106336 : input[5] > 8.193814844759492 ? input[4] > 2.602003343538398 ? input[2] > 5.167634984480833 ? var48 = -.00996811570890536 : var48 = .001134417943860963 : var48 = -.013004815776467261 : input[1] > 1e-35 ? input[22] > 1e-35 ? var48 = -.019057324908699217 : input[141] > 1e-35 ? var48 = -.026707851278989517 : var48 = .005608056403567553 : var48 = -.0017699070677530831 : input[3] > 1.4978661367769956 ? var48 = -.005457163739006659 : var48 = -.02994467745413277;
  let var49;
  input[11] > 1e-35 ? input[154] > 1e-35 ? var49 = -.07640004589975245 : input[153] > 1e-35 ? var49 = -.027921183286970398 : input[156] > 1e-35 ? var49 = -.02508900369371103 : input[47] > 1e-35 ? var49 = -.09621039139423637 : input[46] > 1e-35 ? var49 = -.05890206826599292 : var49 = -.0018521707885188695 : input[7] > .1998775237752378 ? input[39] > 1e-35 ? var49 = -.02026563108381904 : input[91] > 1e-35 ? var49 = -.03979999802398471 : input[14] > 1e-35 ? input[134] > 1e-35 ? var49 = .044705853812635206 : var49 = .01112016315736189 : input[24] > 1e-35 ? input[6] > 3.417592293073651 ? var49 = .01585670681557334 : var49 = .0820229237073549 : input[9] > 1e-35 ? input[204] > 1e-35 ? input[6] > 3.9219243190762363 ? var49 = .01475544028693712 : input[30] > 1e-35 ? var49 = .10219265831102325 : var49 = -.0567832116465987 : input[154] > 1e-35 ? var49 = -.04682869193620295 : var49 = .0058147572533605784 : input[123] > 1e-35 ? var49 = -.04011640490395746 : input[17] > 1e-35 ? input[6] > 3.314020688089767 ? var49 = .016472642951500794 : var49 = -.10372235311156908 : input[19] > 1e-35 ? var49 = .013619887374131652 : input[28] > 1e-35 ? input[6] > 3.1984648276080736 ? input[6] > 5.5816130673839615 ? var49 = .021404525777064917 : var49 = -.022090537029637168 : var49 = .07927547222505857 : input[129] > 1e-35 ? var49 = -.0315112950229846 : input[90] > 1e-35 ? var49 = -.08016175793969123 : input[60] > 1e-35 ? var49 = -.044255594885932 : input[150] > 1e-35 ? var49 = -.0643645650066138 : var49 = 18071436579202054e-21 : input[6] > 6.132312266239896 ? var49 = .00017227075512669227 : var49 = -.010904669702571911;
  let var50;
  input[0] > 1e-35 ? input[1] > 1e-35 ? input[7] > .30853255358841714 ? input[154] > 1e-35 ? var50 = -.053460642910797676 : var50 = .009652079082741289 : var50 = -.0017676195976280011 : input[134] > 1e-35 ? var50 = .01746182064829904 : input[32] > 1e-35 ? var50 = .033149881191962445 : input[138] > 1e-35 ? var50 = .02149173543949675 : input[37] > 1e-35 ? var50 = .028519159270523897 : input[152] > 1e-35 ? var50 = .023352031441951773 : input[217] > 1e-35 ? var50 = .02290558132732214 : var50 = -.01850975101703459 : input[152] > 1e-35 ? var50 = .010488854074509982 : input[155] > 1e-35 ? input[12] > 1e-35 ? var50 = .027490522294963154 : var50 = .002575743497494008 : input[131] > 1e-35 ? var50 = -.07138027268500055 : input[57] > 1e-35 ? var50 = -.06658662137088783 : input[28] > 1e-35 ? var50 = .015141080652315508 : input[55] > 1e-35 ? var50 = -.07156337757427284 : input[204] > 1e-35 ? var50 = .008085415901726045 : input[99] > 1e-35 ? input[1] > 1e-35 ? var50 = .01803019280250009 : var50 = -.012275416064615064 : input[113] > 1e-35 ? var50 = .007680714218522011 : input[102] > 1e-35 ? var50 = .01923593781092882 : input[38] > 1e-35 ? var50 = .00598208846998872 : input[112] > 1e-35 ? var50 = .00895148693111358 : input[217] > 1e-35 ? var50 = .004322676779141819 : input[114] > 1e-35 ? input[1] > 1e-35 ? var50 = .019173900241286065 : input[18] > 1e-35 ? var50 = -.1302545616586715 : var50 = -.012219608237225175 : input[89] > 1e-35 ? var50 = .019080595932083305 : input[95] > 1e-35 ? var50 = .009182530113836561 : var50 = -.006531048204768366;
  let var51;
  input[2] > 4.135134555718313 ? input[47] > 1e-35 ? var51 = -.06057129526622943 : input[5] > 6.805168536739806 ? input[3] > 2.4414009612931857 ? input[1] > 1e-35 ? input[32] > 1e-35 ? var51 = -.09672976728291365 : input[217] > 1e-35 ? var51 = -.09138286775903748 : input[114] > 1e-35 ? var51 = .034435801312936894 : var51 = .003550781249532139 : input[56] > 1e-35 ? var51 = .06582022232543998 : input[144] > 1e-35 ? var51 = -.08601101006110747 : var51 = -.006766914059699758 : input[217] > 1e-35 ? var51 = .001822103802069182 : var51 = -.013646878234832634 : input[8] > 1e-35 ? var51 = -.02495807137678248 : input[1] > 1e-35 ? var51 = .009517017217557915 : var51 = -.007488737506950444 : input[6] > 6.1537953943602615 ? input[140] > 1e-35 ? var51 = -.013180308369805589 : input[51] > 1e-35 ? var51 = -.0496089337787575 : input[15] > 1e-35 ? input[30] > 1e-35 ? var51 = .017032153502995334 : var51 = -.01330098154550191 : input[10] > 1e-35 ? input[56] > 1e-35 ? var51 = .04713518460375107 : var51 = -.0016223104582873055 : input[131] > 1e-35 ? var51 = -.07291331059881433 : input[27] > 1e-35 ? var51 = -.015619378359486803 : var51 = .006051005570772542 : input[3] > 3.1132683346437333 ? input[8] > 1e-35 ? var51 = -.02945681137428643 : var51 = -.00725026522062693 : input[6] > 1e-35 ? input[3] > 1.2424533248940002 ? var51 = .0035081297381004684 : input[194] > 1e-35 ? input[5] > 3.772694874805912 ? var51 = -.03142097937872678 : var51 = -.17253564001853064 : input[5] > 3.156774023138548 ? var51 = -.004860170522962415 : input[12] > 1e-35 ? var51 = -.04169370739781986 : var51 = .05886396855048806 : var51 = -.10415236736977414;
  let var52;
  input[2] > 2.3502401828962087 ? input[11] > 1e-35 ? input[58] > 1e-35 ? var52 = -.07548370555339029 : var52 = -.009060327134219393 : input[21] > 1e-35 ? var52 = -.02536204329245056 : input[155] > 1e-35 ? var52 = .01626198918750622 : input[142] > 1e-35 ? var52 = -.029262265693304763 : input[4] > 1.8688348091416842 ? input[48] > 1e-35 ? var52 = -.0522966414357639 : input[47] > 1e-35 ? var52 = -.03867213359133592 : input[149] > 1e-35 ? var52 = -.10392339919606915 : input[135] > 1e-35 ? var52 = -.010541433982611018 : input[51] > 1e-35 ? var52 = -.06273170107556418 : input[54] > 1e-35 ? var52 = -.08769404750229767 : input[18] > 1e-35 ? input[1] > 1e-35 ? var52 = .0022966362330231133 : input[31] > 1e-35 ? var52 = .19571528454816625 : var52 = -.04919246049942885 : input[50] > 1e-35 ? var52 = -.06766114512966344 : input[7] > .9793410316570949 ? var52 = .00837983401462093 : var52 = .0007986280224776339 : input[186] > 1e-35 ? var52 = -.16446174535054356 : input[62] > 1e-35 ? var52 = .06508947502037822 : var52 = -.010260699234562241 : input[6] > 5.486867329823672 ? input[140] > 1e-35 ? var52 = -.01589822136096899 : input[125] > 1e-35 ? var52 = -.025465846683560996 : input[190] > 1e-35 ? var52 = -.03671457167643481 : input[91] > 1e-35 ? var52 = -.03821691103237143 : input[57] > 1e-35 ? var52 = -.07502589184745939 : input[50] > 1e-35 ? var52 = -.05395522531288487 : var52 = .005241788285288346 : input[4] > 3.1132683346437333 ? var52 = -.008741587825172916 : input[12] > 1e-35 ? input[100] > 1e-35 ? var52 = .06608964318040904 : var52 = -.012827641806975033 : var52 = .004744161815471635;
  let var53;
  input[4] > .8958797346140276 ? input[2] > 5.4049245766661995 ? input[5] > 6.0051201133541365 ? var53 = -.008352440702113342 : var53 = .00818161196788124 : input[123] > 1e-35 ? var53 = -.02387242845183433 : input[190] > 1e-35 ? var53 = -.03574127589374163 : input[152] > 1e-35 ? var53 = .01262147105943106 : input[11] > 1e-35 ? input[58] > 1e-35 ? var53 = -.05955906348417553 : var53 = -.003717083835106387 : input[6] > 6.0026509725338455 ? input[15] > 1e-35 ? input[30] > 1e-35 ? var53 = .023589988800048537 : var53 = -.01290090410411923 : input[38] > 1e-35 ? var53 = .015295369946508892 : input[1] > 1e-35 ? input[4] > 2.740319461670996 ? input[22] > 1e-35 ? var53 = -.01614208413608714 : input[42] > 1e-35 ? var53 = -.05454658382875832 : var53 = .008894057269932708 : input[141] > 1e-35 ? var53 = -.029660896741885025 : var53 = .0007918628584206305 : input[12] > 1e-35 ? var53 = .010735865892076339 : input[218] > 1e-35 ? var53 = .06499398466334683 : input[29] > 1e-35 ? var53 = -.02987220407530282 : input[118] > 1e-35 ? var53 = -.05994319680494358 : var53 = -.0022119035344297464 : input[113] > 1e-35 ? input[24] > 1e-35 ? var53 = .09992180359591052 : var53 = .003953091072683087 : input[204] > 1e-35 ? input[4] > 2.249904835165133 ? var53 = .0012737346185997833 : input[5] > 3.979637980058199 ? var53 = .012350990163327259 : input[29] > 1e-35 ? var53 = -.4173182186315585 : var53 = .09483857671510697 : var53 = -.0034771114722081282 : input[19] > 1e-35 ? var53 = .04818172610227253 : input[158] > 1e-35 ? var53 = .09085872490042819 : input[123] > 1e-35 ? var53 = .046170414156546824 : var53 = -.030833991141721785;
  let var54;
  input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[2] > 2.138333059508028 ? input[3] > 1.4978661367769956 ? input[3] > 4.197173680708697 ? var54 = -.015067858446918237 : input[5] > 3.979637980058199 ? var54 = .0025493966284458503 : input[24] > 1e-35 ? var54 = .10170949517680355 : input[3] > 2.3502401828962087 ? var54 = -.010182198776560389 : input[7] > .9662372103242399 ? var54 = .0855616171705204 : var54 = -.0044290837387121786 : input[7] > .992067132663463 ? var54 = .006950766900495411 : var54 = -.011703657118613042 : input[3] > 3.314020688089767 ? var54 = -.007590151825214328 : var54 = .011931088318037653 : input[5] > 4.424828703319957 ? input[3] > 1.4978661367769956 ? var54 = .003895993078605918 : input[2] > 1e-35 ? input[5] > 5.859359688974663 ? var54 = .03311360926528595 : input[7] > .9936484368123463 ? input[28] > 1e-35 ? var54 = -.1296383065201116 : input[18] > 1e-35 ? var54 = -.2304238024287801 : var54 = -.0007035160942990814 : var54 = .03872938637191365 : var54 = .05931958562003542 : input[204] > 1e-35 ? input[7] > .9926276364955392 ? var54 = -.2503820824196552 : var54 = .01514980593659256 : input[135] > 1e-35 ? input[7] > .990877425524446 ? var54 = -.12146435764173391 : var54 = .03579230653026111 : input[125] > 1e-35 ? var54 = -.11990587076136816 : var54 = -.0017264106529335022 : input[2] > .8958797346140276 ? input[3] > 4.878999622893762 ? var54 = -.028006872909888104 : input[17] > 1e-35 ? var54 = .015327119563713427 : input[14] > 1e-35 ? var54 = .008966123864441086 : input[24] > 1e-35 ? var54 = .014884319812071584 : var54 = -.0008180929266082377 : input[29] > 1e-35 ? input[5] > 5.895778350950796 ? var54 = -.02927173520516398 : var54 = .004256706136162408 : var54 = -.0030692852485265805;
  let var55;
  input[39] > 1e-35 ? var55 = -.019116728566000912 : input[152] > 1e-35 ? var55 = .011159312353677259 : input[52] > 1e-35 ? var55 = -.06556505864685434 : input[7] > .14547530463198097 ? input[187] > 1e-35 ? var55 = -.02203060071288757 : input[48] > 1e-35 ? var55 = -.03406851575382452 : input[10] > 1e-35 ? input[219] > 1e-35 ? var55 = -.026242020752538932 : var55 = -.0026163734864036088 : input[21] > 1e-35 ? var55 = -.016803181860075653 : input[8] > 1e-35 ? input[5] > 3.0201273556387074 ? input[6] > 4.722943345003718 ? input[125] > 1e-35 ? var55 = -.07907862980413462 : var55 = -.0024968534057976956 : input[141] > 1e-35 ? var55 = .01751368963010255 : var55 = -.035334686232177996 : input[3] > 1e-35 ? var55 = -.049727650261844114 : var55 = .06649006602788514 : input[51] > 1e-35 ? var55 = -.047051279496267896 : input[58] > 1e-35 ? input[19] > 1e-35 ? var55 = .06794814379814933 : var55 = -.033933057704283995 : input[6] > 8.681774988134558 ? var55 = -.001906867260604815 : input[3] > 3.3842466058243152 ? input[23] > 1e-35 ? var55 = .029126145919054786 : input[12] > 1e-35 ? input[59] > 1e-35 ? var55 = .06547842372312768 : var55 = .005706402727440608 : input[89] > 1e-35 ? var55 = .05238448470974841 : var55 = -.003970577798047124 : input[141] > 1e-35 ? input[3] > 1e-35 ? var55 = -.02994666941636212 : var55 = .029175297065511276 : input[139] > 1e-35 ? var55 = -.03926804943552878 : input[7] > .9626084674797213 ? var55 = .010270060885238803 : input[6] > 4.5379471377116305 ? var55 = .0051640733904868355 : var55 = -.006326617548806485 : input[3] > 2.3502401828962087 ? var55 = -.001064039369711557 : var55 = -.015232776877478657;
  let var56;
  input[4] > .8958797346140276 ? input[0] > 1e-35 ? input[3] > 3.540854293052788 ? input[138] > 1e-35 ? var56 = .020620751195117866 : var56 = -.007657642824282572 : input[9] > 1e-35 ? var56 = .013255738783000171 : input[123] > 1e-35 ? var56 = -.04553588467808997 : input[14] > 1e-35 ? var56 = .020257942633657516 : input[17] > 1e-35 ? var56 = .02379466680602821 : input[7] > .26911173821332884 ? var56 = .004563013176326579 : var56 = -.006044878247080096 : input[208] > 1e-35 ? input[1] > 1e-35 ? var56 = .016583051243963785 : var56 = -.005473696128326885 : input[53] > 1e-35 ? var56 = -.07392011100318682 : input[3] > 4.840234496705036 ? var56 = -.022277334024938686 : input[49] > 1e-35 ? var56 = -.04140311782670083 : input[40] > 1e-35 ? var56 = -.041278341040658334 : input[156] > 1e-35 ? var56 = -.01087788432462589 : input[8] > 1e-35 ? input[141] > 1e-35 ? var56 = .032404890147508435 : var56 = -.008762958389316138 : input[153] > 1e-35 ? input[18] > 1e-35 ? var56 = .03064796696780178 : input[19] > 1e-35 ? var56 = .025912082684934896 : input[7] > .9033253454895247 ? var56 = .00010665286308939541 : var56 = -.019390651252802232 : input[133] > 1e-35 ? var56 = -.013215417920201165 : input[35] > 1e-35 ? var56 = -.07409193965805899 : input[16] > 1e-35 ? var56 = .010595288788401727 : var56 = .0004445963442680354 : input[19] > 1e-35 ? var56 = .043800560164078434 : input[62] > 1e-35 ? var56 = .08440762960688118 : input[123] > 1e-35 ? var56 = .04196062757398021 : input[44] > 1e-35 ? input[7] > .9880960409521241 ? var56 = -.14025705728324367 : var56 = .07605327900446729 : var56 = -.030453882536033008;
  let var57;
  input[14] > 1e-35 ? input[134] > 1e-35 ? var57 = .03807815059641535 : var57 = .007895137847547357 : input[39] > 1e-35 ? var57 = -.019172673927560828 : input[138] > 1e-35 ? var57 = .009207480510332959 : input[152] > 1e-35 ? input[10] > 1e-35 ? var57 = .029310247627617716 : var57 = .006422126177312616 : input[3] > 3.5114340430413216 ? input[155] > 1e-35 ? var57 = .02869511059037871 : input[137] > 1e-35 ? var57 = .048763707543632046 : input[218] > 1e-35 ? var57 = .0393143924208134 : var57 = -.0065205942363783 : input[4] > 2.4414009612931857 ? input[113] > 1e-35 ? var57 = .016047178137914484 : input[35] > 1e-35 ? var57 = -.09486179869071369 : input[118] > 1e-35 ? var57 = -.032706818831570415 : input[0] > 1e-35 ? var57 = .004733859562945298 : var57 = -4345884264792552e-20 : input[29] > 1e-35 ? input[204] > 1e-35 ? input[4] > 2.3502401828962087 ? var57 = -.23804773582311067 : var57 = .0015066742334155967 : input[194] > 1e-35 ? input[4] > 1.7005986908310777 ? var57 = -.013296404682101122 : var57 = -.14340192620927933 : input[196] > 1e-35 ? var57 = -.17446678790111786 : var57 = -.01140535620661492 : input[141] > 1e-35 ? var57 = -.03362328403627273 : input[99] > 1e-35 ? var57 = .02082592497315901 : input[196] > 1e-35 ? var57 = .02125156827172031 : input[204] > 1e-35 ? var57 = .018738441981476887 : input[194] > 1e-35 ? var57 = .022230335367621302 : input[114] > 1e-35 ? var57 = .017460982004618885 : input[210] > 1e-35 ? input[11] > 1e-35 ? var57 = -.07421933796695453 : var57 = -.02600449772874995 : input[62] > 1e-35 ? var57 = .0435295764572802 : var57 = -.0036358741919687645;
  let var58;
  input[2] > 4.749261159734808 ? input[5] > 6.826002629905951 ? input[29] > 1e-35 ? var58 = -.012866931871530748 : input[47] > 1e-35 ? var58 = -.06511122680099479 : var58 = -.0033152297369715466 : input[1] > 1e-35 ? var58 = .00634942519508748 : var58 = -.008516826211528918 : input[6] > 6.1537953943602615 ? input[11] > 1e-35 ? input[121] > 1e-35 ? input[1] > 1e-35 ? var58 = -.06214080664476329 : var58 = .037029947625630194 : input[47] > 1e-35 ? var58 = -.08203414630098728 : var58 = -.0044122376347199765 : input[15] > 1e-35 ? input[30] > 1e-35 ? var58 = .012452689013210465 : var58 = -.011970977023212193 : input[10] > 1e-35 ? input[152] > 1e-35 ? var58 = .02888624440861723 : var58 = -.0026872248277927456 : input[27] > 1e-35 ? var58 = -.01471521834054285 : input[21] > 1e-35 ? var58 = -.014970363019863132 : input[13] > 1e-35 ? var58 = -.0057151868439017945 : input[38] > 1e-35 ? var58 = .01633003881478886 : var58 = .005850603591179588 : input[113] > 1e-35 ? input[5] > 3.979637980058199 ? var58 = .006600693642185256 : input[6] > 3.1984648276080736 ? var58 = .07576534772024612 : var58 = -.013028252220942527 : input[204] > 1e-35 ? input[9] > 1e-35 ? input[6] > 3.9219243190762363 ? var58 = .01266221511189265 : input[29] > 1e-35 ? var58 = -.20167612409830682 : var58 = .09361829582187109 : var58 = .0016303497789744046 : input[6] > 4.310776603370241 ? var58 = -.0015960016142716584 : input[141] > 1e-35 ? input[2] > 2.249904835165133 ? input[6] > 2.970085626360216 ? var58 = -.05054316446311788 : var58 = .06528096075929847 : input[29] > 1e-35 ? var58 = .07763431964140277 : var58 = -.017239135292908336 : var58 = -.011068823413100247;
  let var59;
  input[91] > 1e-35 ? var59 = -.03524202222673902 : input[55] > 1e-35 ? var59 = -.07505808762820981 : input[47] > 1e-35 ? var59 = -.026314216162986376 : input[49] > 1e-35 ? var59 = -.045488810456426665 : input[54] > 1e-35 ? var59 = -.06424779605129435 : input[0] > 1e-35 ? input[39] > 1e-35 ? var59 = -.03267263134559766 : input[46] > 1e-35 ? var59 = -.049285436356671077 : input[51] > 1e-35 ? var59 = -.09277060040547602 : input[4] > .8958797346140276 ? input[123] > 1e-35 ? var59 = -.027164727231258436 : input[7] > .4232249052377311 ? input[14] > 1e-35 ? var59 = .021561483416797714 : input[9] > 1e-35 ? input[58] > 1e-35 ? var59 = -.08387877475105178 : var59 = .014404401501386124 : var59 = .004694473365260974 : var59 = -.0001897538693116325 : var59 = -.017140588284242805 : input[5] > 9.119594757170685 ? input[3] > 2.740319461670996 ? var59 = -.0007153953072197825 : var59 = -.010378474356201449 : input[8] > 1e-35 ? input[5] > 3.276966702012906 ? input[125] > 1e-35 ? var59 = -.06966241558514917 : input[4] > 4.82429765145367 ? var59 = -.05703428861212874 : var59 = -.007549683006633188 : input[3] > 1.2424533248940002 ? var59 = -.05340556429257431 : var59 = .0524214727387076 : input[22] > 1e-35 ? var59 = -.012756524179901607 : input[186] > 1e-35 ? var59 = -.06578146880564559 : input[208] > 1e-35 ? var59 = .011189277267677045 : input[11] > 1e-35 ? input[58] > 1e-35 ? var59 = -.05051984734793551 : input[3] > 1.2424533248940002 ? var59 = -.0002576217567062796 : input[134] > 1e-35 ? var59 = -.07452351335236179 : var59 = -.010366062496356129 : input[94] > 1e-35 ? var59 = -.04206673603732986 : var59 = .0017654268359667174;
  let var60;
  input[2] > 2.3502401828962087 ? input[28] > 1e-35 ? var60 = .018743416209068924 : input[142] > 1e-35 ? var60 = -.027628078748284907 : input[4] > 1.7005986908310777 ? input[123] > 1e-35 ? var60 = -.039485087567133176 : input[48] > 1e-35 ? var60 = -.04707407726639779 : input[49] > 1e-35 ? var60 = -.0644727439161007 : input[47] > 1e-35 ? var60 = -.03586301268310228 : input[52] > 1e-35 ? var60 = -.08213761833929575 : input[60] > 1e-35 ? var60 = -.036939376764301805 : input[22] > 1e-35 ? var60 = -.02264827779335228 : input[153] > 1e-35 ? input[24] > 1e-35 ? var60 = .03651632275248908 : var60 = -.010403215174169965 : input[18] > 1e-35 ? input[31] > 1e-35 ? var60 = .17011943799802248 : var60 = -.024083374989820074 : input[147] > 1e-35 ? var60 = -.05792387046048145 : input[39] > 1e-35 ? var60 = -.019000152117179 : input[54] > 1e-35 ? var60 = -.09256681585621543 : input[50] > 1e-35 ? var60 = -.06535283940797192 : input[187] > 1e-35 ? var60 = -.023020538580498528 : input[149] > 1e-35 ? var60 = -.09670391878996044 : input[8] > 1e-35 ? input[6] > 5.865049616265698 ? var60 = .0007122257672540384 : var60 = -.024203929126070334 : input[55] > 1e-35 ? var60 = -.10687519344783902 : input[21] > 1e-35 ? var60 = -.019836359134795922 : var60 = .0028141634686288143 : input[153] > 1e-35 ? var60 = -.044827592367532504 : var60 = -.009894012855110334 : input[140] > 1e-35 ? input[18] > 1e-35 ? var60 = .060584003745668275 : var60 = -.015006980258423744 : input[6] > 5.161920636569023 ? input[125] > 1e-35 ? var60 = -.021624709427283298 : var60 = .0035264081894521636 : var60 = -.0030260520850755417;
  let var61;
  input[57] > 1e-35 ? var61 = -.06665941268716478 : input[2] > 5.4049245766661995 ? var61 = -.0048763725607228565 : input[17] > 1e-35 ? var61 = .012937023835595996 : input[91] > 1e-35 ? var61 = -.032642493399923284 : input[40] > 1e-35 ? var61 = -.04355571234278559 : input[14] > 1e-35 ? input[217] > 1e-35 ? var61 = -.030555708374197955 : var61 = .010895997063478696 : input[1] > 1e-35 ? input[99] > 1e-35 ? var61 = .016029829045206837 : input[114] > 1e-35 ? var61 = .017475123428921584 : input[139] > 1e-35 ? var61 = -.042037981483985604 : input[210] > 1e-35 ? input[29] > 1e-35 ? var61 = .015395913258454092 : var61 = -.024779051599098958 : input[90] > 1e-35 ? var61 = -.09436512907953146 : input[25] > 1e-35 ? var61 = -.0385103760507401 : input[113] > 1e-35 ? var61 = .014955995782471 : input[208] > 1e-35 ? var61 = .01363101947809469 : var61 = .0004708078358576994 : input[29] > 1e-35 ? var61 = -.02567148566035587 : input[217] > 1e-35 ? var61 = .017896286118860596 : input[118] > 1e-35 ? var61 = -.04366196842115269 : input[144] > 1e-35 ? var61 = -.04332564222613586 : input[54] > 1e-35 ? var61 = -.08095356842154083 : input[31] > 1e-35 ? input[15] > 1e-35 ? var61 = -.12797365603832508 : var61 = .05407709367007049 : input[56] > 1e-35 ? var61 = .030874690971051524 : input[148] > 1e-35 ? var61 = -.06664437092250396 : input[50] > 1e-35 ? var61 = -.05710031053092695 : input[114] > 1e-35 ? input[18] > 1e-35 ? var61 = -.12348764088627251 : var61 = -.014081947133593207 : input[147] > 1e-35 ? var61 = -.044629298717173554 : var61 = -.000742893245658901;
  let var62;
  input[138] > 1e-35 ? var62 = .008266725465725232 : input[1] > 1e-35 ? input[37] > 1e-35 ? var62 = -.06288072801700428 : input[114] > 1e-35 ? var62 = .01701875404216428 : input[128] > 1e-35 ? var62 = -.022207708344996902 : input[113] > 1e-35 ? input[24] > 1e-35 ? var62 = .08078133512323216 : var62 = .010126216487392538 : input[11] > 1e-35 ? input[58] > 1e-35 ? var62 = -.0542116306120395 : var62 = -.004962440421854299 : input[155] > 1e-35 ? input[30] > 1e-35 ? var62 = .02107443326718807 : var62 = -.01069225359959257 : var62 = .0009105709984003484 : input[218] > 1e-35 ? var62 = .05160355321154702 : input[134] > 1e-35 ? var62 = .006114948378400552 : input[121] > 1e-35 ? var62 = .016106484014031797 : input[89] > 1e-35 ? var62 = .01912348851711998 : input[56] > 1e-35 ? var62 = .029777849606436514 : input[157] > 1e-35 ? var62 = .04060172642469715 : input[31] > 1e-35 ? var62 = .040190765597096945 : input[115] > 1e-35 ? var62 = .038285461163007885 : input[144] > 1e-35 ? var62 = -.04397941351839926 : input[53] > 1e-35 ? var62 = -.09153555712989248 : input[34] > 1e-35 ? var62 = .05063635650139542 : input[145] > 1e-35 ? var62 = -.05531793235403996 : input[18] > 1e-35 ? input[142] > 1e-35 ? var62 = .050915836711889595 : var62 = -.038668153033606156 : input[142] > 1e-35 ? var62 = -.03161888799270195 : input[21] > 1e-35 ? var62 = -.039152400008548416 : input[147] > 1e-35 ? var62 = -.06369054146375448 : input[146] > 1e-35 ? var62 = -.06687062048733548 : input[143] > 1e-35 ? var62 = -.0374398909044375 : var62 = -.004075281311375503;
  let var63;
  input[19] > 1e-35 ? var63 = .011138060439416179 : input[7] > .054053454943712505 ? input[17] > 1e-35 ? input[30] > 1e-35 ? var63 = .031458353209402545 : var63 = .006712963530887799 : input[135] > 1e-35 ? var63 = -.008268741342836259 : input[60] > 1e-35 ? var63 = -.026373116795568554 : input[7] > .8375851232899904 ? input[3] > 2.602003343538398 ? input[6] > 4.832297822126891 ? var63 = .001164103411669833 : input[8] > 1e-35 ? var63 = -.04419920795209664 : var63 = -.007580602414427876 : input[6] > 3.417592293073651 ? input[6] > 8.80963889693121 ? var63 = -.00653283113371423 : input[8] > 1e-35 ? input[125] > 1e-35 ? var63 = -.10156793652811894 : var63 = -.004200534838133274 : input[18] > 1e-35 ? var63 = -.01192673279840267 : var63 = .007421951916920296 : input[7] > .9626084674797213 ? input[29] > 1e-35 ? input[6] > 2.970085626360216 ? var63 = -.0032059430383565256 : var63 = .05159315082197918 : input[8] > 1e-35 ? var63 = -.0890031715943104 : input[22] > 1e-35 ? var63 = -.16814104441488775 : input[12] > 1e-35 ? input[100] > 1e-35 ? var63 = .1021284677424052 : var63 = -.13655977142603173 : var63 = .09393254504800182 : var63 = -.0008030674521708154 : input[153] > 1e-35 ? input[18] > 1e-35 ? var63 = .028570793527563892 : var63 = -.01146507406243734 : input[125] > 1e-35 ? input[3] > 1e-35 ? var63 = -.04344386283066575 : var63 = .049543778722220704 : input[47] > 1e-35 ? var63 = -.025602694767462936 : var63 = 41633336342102227e-21 : input[3] > 2.3502401828962087 ? input[3] > 3.3497501700808394 ? var63 = -.018924000087166926 : var63 = .005374758944061522 : input[14] > 1e-35 ? var63 = .02825013192303339 : var63 = -.028367959366723622;
  let var64;
  input[190] > 1e-35 ? var64 = -.033259392758942484 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var64 = -.030965448877928344 : input[150] > 1e-35 ? var64 = -.05353588365501967 : input[53] > 1e-35 ? var64 = -.07322459471644706 : input[0] > 1e-35 ? input[6] > 6.9012339353508745 ? var64 = .007566110700214329 : input[4] > 3.0677824455408698 ? input[7] > .5242163672259389 ? input[8] > 1e-35 ? input[6] > 4.722943345003718 ? var64 = -.00508197369229565 : input[4] > 3.5694334999727624 ? var64 = -.09566908841488272 : var64 = -.009799018561370653 : input[29] > 1e-35 ? var64 = .01134634874419129 : var64 = -.008480456528154491 : var64 = -.010775036248093376 : var64 = .006611525544742429 : input[23] > 1e-35 ? var64 = .01761735039511882 : input[19] > 1e-35 ? var64 = .01278442042249664 : var64 = -.0002242132003162585 : input[186] > 1e-35 ? var64 = -.1282956565830828 : input[99] > 1e-35 ? var64 = .018493666625505303 : input[141] > 1e-35 ? var64 = -.026024552608676074 : input[29] > 1e-35 ? input[5] > 3.5694334999727624 ? input[217] > 1e-35 ? var64 = .010089877008871859 : input[7] > .9569480028661056 ? var64 = -.0021891593882122327 : var64 = -.019455050281455402 : input[7] > .960816451500545 ? var64 = -.13777176433158442 : var64 = .02722608122697913 : input[28] > 1e-35 ? input[194] > 1e-35 ? var64 = .09549833737461155 : var64 = .012447932823540411 : input[129] > 1e-35 ? input[26] > 1e-35 ? var64 = .147381625399948 : var64 = -.03418523266130075 : input[7] > .26911173821332884 ? var64 = .0014660191124088442 : input[217] > 1e-35 ? var64 = -.08282397562490618 : input[210] > 1e-35 ? var64 = -.0386848317545183 : var64 = -.001892646396528824;
  let var65;
  input[57] > 1e-35 ? var65 = -.059790543460520464 : input[55] > 1e-35 ? var65 = -.06524069243313577 : input[3] > 4.283562780082224 ? input[37] > 1e-35 ? var65 = -.054605342954169904 : var65 = -.006343751747681404 : input[17] > 1e-35 ? var65 = .011961708215735271 : input[40] > 1e-35 ? var65 = -.04296088601962452 : input[6] > 1e-35 ? input[24] > 1e-35 ? input[113] > 1e-35 ? input[6] > 4.460127707454046 ? var65 = -.026498922218692673 : var65 = .10501477027016158 : input[6] > 4.03420147928485 ? var65 = .012792216148037112 : input[7] > .9830997303909479 ? var65 = -.2271005546552327 : var65 = -.008348690537914538 : input[9] > 1e-35 ? input[153] > 1e-35 ? input[7] > .20588252599634785 ? var65 = -.004842123367456505 : var65 = -.03575275485660392 : input[99] > 1e-35 ? input[1] > 1e-35 ? var65 = .032397176999597294 : var65 = -.0033271937210452387 : input[204] > 1e-35 ? var65 = .02154799118278769 : var65 = .0034498877728340095 : input[28] > 1e-35 ? input[6] > 3.0677824455408698 ? input[6] > 5.5816130673839615 ? var65 = .01602715871650751 : input[7] > .9901971344332651 ? input[194] > 1e-35 ? var65 = -.21161676626091178 : input[127] > 1e-35 ? var65 = -.4024450297968636 : var65 = -.030976570087232314 : var65 = .0031980605341801454 : var65 = .07943810970798848 : input[135] > 1e-35 ? var65 = -.00869354055420051 : input[123] > 1e-35 ? var65 = -.022241787113206086 : input[62] > 1e-35 ? var65 = .037165483434744594 : input[7] > .04507521918085865 ? input[21] > 1e-35 ? var65 = -.013433718654288605 : input[155] > 1e-35 ? var65 = .00919342834132915 : var65 = -.0002729025327531227 : var65 = -.012537468897218136 : var65 = -.07894994665155514;
  let var66;
  input[4] > .8958797346140276 ? input[14] > 1e-35 ? var66 = .007800140351631253 : input[138] > 1e-35 ? var66 = .007294945388686309 : input[1] > 1e-35 ? input[32] > 1e-35 ? input[28] > 1e-35 ? var66 = .09462192942805535 : var66 = -.06376046128949985 : input[37] > 1e-35 ? var66 = -.06442220885770956 : input[140] > 1e-35 ? input[30] > 1e-35 ? var66 = -.09261012186873348 : var66 = -.015294712278584928 : input[98] > 1e-35 ? var66 = .019329173498247088 : input[58] > 1e-35 ? var66 = -.026405515460271967 : input[5] > 8.608586615680721 ? input[4] > 2.602003343538398 ? var66 = 6125118307170923e-20 : var66 = -.009497787119169794 : input[40] > 1e-35 ? var66 = -.05491317248554455 : input[7] > .30853255358841714 ? var66 = .003951848833690266 : var66 = -.0021827028977256715 : input[219] > 1e-35 ? var66 = -.03918852409108207 : input[98] > 1e-35 ? var66 = -.025490621458423603 : input[218] > 1e-35 ? var66 = .04685239586600909 : input[4] > 2.970085626360216 ? input[152] > 1e-35 ? var66 = .019288400231624092 : input[132] > 1e-35 ? var66 = .04845025214421127 : input[157] > 1e-35 ? var66 = .03681235344369351 : input[18] > 1e-35 ? var66 = -.034132162265456074 : input[48] > 1e-35 ? var66 = -.04861483835690636 : input[142] > 1e-35 ? var66 = -.031057400959951156 : input[148] > 1e-35 ? var66 = -.06903688486009983 : var66 = -.004426858558248682 : input[31] > 1e-35 ? var66 = .06983425899920179 : var66 = .002335587968443938 : input[19] > 1e-35 ? var66 = .04178364096434334 : input[123] > 1e-35 ? var66 = .03954255208630935 : input[62] > 1e-35 ? var66 = .07169067239737285 : var66 = -.022094630155173406;
  let var67;
  input[190] > 1e-35 ? var67 = -.029705030481716018 : input[2] > 2.4414009612931857 ? input[125] > 1e-35 ? input[3] > 1e-35 ? var67 = -.052080713549693486 : var67 = .015237248725743169 : input[49] > 1e-35 ? var67 = -.05738028956460733 : input[28] > 1e-35 ? var67 = .015629889576502864 : input[14] > 1e-35 ? var67 = .007178838639724632 : input[217] > 1e-35 ? var67 = .006873744757442591 : input[3] > .8958797346140276 ? var67 = -.0009297977761919447 : input[4] > 2.740319461670996 ? var67 = -.0032588616048005344 : input[209] > 1e-35 ? var67 = -.09352716353634213 : var67 = -.015820890219545396 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[30] > 1e-35 ? var67 = .019248760742983276 : input[3] > 2.861792550976191 ? input[6] > 8.372051799062541 ? var67 = .011687619771455333 : var67 = -.014380012538782239 : var67 = .007119108038702808 : input[5] > 4.424828703319957 ? input[3] > 2.249904835165133 ? var67 = -.004571416888569663 : input[4] > .8958797346140276 ? input[2] > 1e-35 ? var67 = .03291298609827498 : var67 = .056149641245301286 : input[6] > 5.66469358412419 ? var67 = .03259771207074825 : var67 = -.09357704176112766 : input[135] > 1e-35 ? input[4] > 3.1132683346437333 ? input[4] > 3.276966702012906 ? var67 = -.061655392996083594 : var67 = -.32745698278768204 : var67 = .05791789791717941 : var67 = -.018505458368810124 : input[2] > 1.2424533248940002 ? var67 = .0026761409362875913 : input[3] > 1e-35 ? input[30] > 1e-35 ? input[210] > 1e-35 ? var67 = -.039544237504098204 : var67 = -.00840469876565937 : input[138] > 1e-35 ? var67 = -.03964217397514852 : var67 = -4311139741723525e-22 : input[5] > 6.136645972583987 ? var67 = -.022772355719852342 : var67 = .00817231129409795;
  let var68;
  input[91] > 1e-35 ? var68 = -.028069212077752072 : input[2] > 5.1209788959100075 ? input[25] > 1e-35 ? input[4] > 3.314020688089767 ? var68 = -.07374751231467579 : var68 = -.012603466600012023 : var68 = -.003323309316995181 : input[0] > 1e-35 ? input[2] > 1.2424533248940002 ? input[11] > 1e-35 ? var68 = -.008138434386494645 : input[2] > 1.8688348091416842 ? input[18] > 1e-35 ? var68 = -.021752576521312197 : input[142] > 1e-35 ? var68 = -.03703704004008216 : input[21] > 1e-35 ? var68 = -.031901873695323615 : var68 = .0007949433315561949 : input[156] > 1e-35 ? var68 = .04622194605125366 : var68 = .007164185384903575 : input[156] > 1e-35 ? var68 = .05649230717257425 : input[192] > 1e-35 ? var68 = -.14560972428612223 : input[144] > 1e-35 ? var68 = -.0847860756426489 : input[4] > .8958797346140276 ? input[2] > .8958797346140276 ? var68 = .009443385055723438 : input[9] > 1e-35 ? var68 = .0384706300742172 : input[7] > .9738681190948303 ? input[7] > .9983480540068196 ? var68 = .03566002120217884 : input[125] > 1e-35 ? var68 = -.08601531943220733 : input[28] > 1e-35 ? var68 = -.07136595081940608 : var68 = .005430826378707227 : var68 = .026279964393698674 : input[2] > .8958797346140276 ? var68 = .025916235406054845 : var68 = -.05093685243097706 : input[2] > .8958797346140276 ? input[4] > 2.4414009612931857 ? input[22] > 1e-35 ? var68 = -.018458649485324576 : input[123] > 1e-35 ? var68 = -.027048533130577097 : input[9] > 1e-35 ? var68 = .005768627348361876 : var68 = .0011976274380886302 : input[196] > 1e-35 ? var68 = .024074476840894424 : var68 = -.0040891042038809855 : input[156] > 1e-35 ? var68 = -.03722816735059365 : var68 = -.004021663177778795;
  let var69;
  input[57] > 1e-35 ? var69 = -.054174378986311306 : input[55] > 1e-35 ? var69 = -.05937408126377534 : input[35] > 1e-35 ? var69 = -.06355743050048665 : input[52] > 1e-35 ? var69 = -.049028563645544726 : input[10] > 1e-35 ? input[152] > 1e-35 ? var69 = .023779508772836917 : input[217] > 1e-35 ? var69 = .00760039749111183 : var69 = -.005758267779536595 : input[6] > 1e-35 ? input[50] > 1e-35 ? var69 = -.03899686693288482 : input[53] > 1e-35 ? var69 = -.06158372699069763 : input[19] > 1e-35 ? var69 = .009506113370718208 : input[154] > 1e-35 ? var69 = -.021220440237800273 : input[129] > 1e-35 ? input[26] > 1e-35 ? var69 = .12643307498280917 : var69 = -.02322694568396696 : input[49] > 1e-35 ? var69 = -.03489161935560748 : input[173] > 1e-35 ? var69 = -.041310484369004336 : input[116] > 1e-35 ? var69 = -.026931019221510855 : input[150] > 1e-35 ? var69 = -.04336081700276943 : input[46] > 1e-35 ? var69 = -.01503021840754708 : input[21] > 1e-35 ? var69 = -.011723313966476847 : input[187] > 1e-35 ? input[30] > 1e-35 ? var69 = .029035482597327224 : var69 = -.020238143126606493 : input[22] > 1e-35 ? var69 = -.0092659038594408 : input[6] > 8.954867306462836 ? var69 = -.002270298325316596 : input[25] > 1e-35 ? input[1] > 1e-35 ? input[152] > 1e-35 ? var69 = .025059955137215612 : var69 = -.058962720741665454 : var69 = 4061285457160542e-20 : input[7] > .787025207541384 ? var69 = .0045073893285534905 : input[156] > 1e-35 ? var69 = -.00956127321029558 : input[153] > 1e-35 ? var69 = -.006428735642845697 : var69 = .0020065887307204903 : var69 = -.07142994726664682;
  let var70;
  input[190] > 1e-35 ? var70 = -.026482483927372538 : input[11] > 1e-35 ? input[153] > 1e-35 ? var70 = -.019448665116575673 : input[46] > 1e-35 ? var70 = -.046207503035123526 : input[143] > 1e-35 ? var70 = -.060693025841649276 : input[125] > 1e-35 ? var70 = -.0635615784828548 : var70 = -.0020226769939179086 : input[10] > 1e-35 ? input[152] > 1e-35 ? var70 = .021657999498329004 : input[217] > 1e-35 ? var70 = .006867901248533881 : input[186] > 1e-35 ? var70 = -.17526174685635476 : input[7] > .3736576099860928 ? input[125] > 1e-35 ? var70 = -.06860813037660739 : var70 = -.0030373931794416857 : input[153] > 1e-35 ? var70 = -.036659407900460406 : var70 = -.009138716679401575 : input[8] > 1e-35 ? input[141] > 1e-35 ? var70 = .022488528656368925 : var70 = -.004824813956579289 : input[155] > 1e-35 ? input[29] > 1e-35 ? var70 = -.0923825728762917 : var70 = .013279779321478072 : input[13] > 1e-35 ? input[29] > 1e-35 ? var70 = -.02015430689927317 : var70 = -.0014075476679032272 : input[21] > 1e-35 ? var70 = -.010052866682366596 : input[15] > 1e-35 ? input[127] > 1e-35 ? var70 = -.11613127921904604 : var70 = -.004425492436566155 : input[61] > 1e-35 ? var70 = -.04761391619756717 : input[38] > 1e-35 ? var70 = .010790742168686546 : input[138] > 1e-35 ? input[25] > 1e-35 ? var70 = -.03936956646884221 : var70 = .012187893435100131 : input[18] > 1e-35 ? input[46] > 1e-35 ? var70 = .052404637972043124 : input[29] > 1e-35 ? input[219] > 1e-35 ? var70 = -.026128288926960785 : var70 = .01402455905339408 : var70 = -.018095204676971146 : var70 = .002238241111198228;
  let var71;
  input[3] > 4.993822430271426 ? var71 = -.021704560089024494 : input[39] > 1e-35 ? var71 = -.012978601337522922 : input[57] > 1e-35 ? var71 = -.04850734344953324 : input[190] > 1e-35 ? var71 = -.02323817835232452 : input[55] > 1e-35 ? var71 = -.054265924680079236 : input[144] > 1e-35 ? var71 = -.020797331827991154 : input[52] > 1e-35 ? var71 = -.04407078296749134 : input[50] > 1e-35 ? var71 = -.03531075513550682 : input[14] > 1e-35 ? input[217] > 1e-35 ? var71 = -.02603818360896512 : var71 = .00845420085528292 : input[90] > 1e-35 ? input[3] > 3.5114340430413216 ? var71 = .010289606334961197 : var71 = -.10259966877314837 : input[139] > 1e-35 ? var71 = -.01903913128660918 : input[17] > 1e-35 ? input[30] > 1e-35 ? var71 = .027295226228104732 : input[38] > 1e-35 ? var71 = .036847447575421244 : input[3] > 2.861792550976191 ? var71 = -.016454620470329126 : var71 = .010475083165212631 : input[19] > 1e-35 ? var71 = .008675111927467 : input[40] > 1e-35 ? var71 = -.036362054443170776 : input[9] > 1e-35 ? var71 = .0031294075955568394 : input[123] > 1e-35 ? var71 = -.02131953072683769 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[3] > 2.602003343538398 ? var71 = -.005045224468848018 : input[3] > 2.3502401828962087 ? var71 = .1006727710215487 : var71 = -.21606952724358763 : input[209] > 1e-35 ? var71 = -.07903381656359819 : var71 = .0099843967860757 : input[28] > 1e-35 ? var71 = .009909672751437115 : input[155] > 1e-35 ? input[3] > 3.941534675652877 ? var71 = .04961274235179155 : var71 = .005113567009198253 : input[158] > 1e-35 ? var71 = .031566828492110836 : var71 = -.0012534895812835874;
  let var72;
  input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var72 = -.022743199998420272 : input[47] > 1e-35 ? var72 = -.02199867034393067 : input[3] > 3.238486181444842 ? input[155] > 1e-35 ? var72 = .015256601991879549 : input[23] > 1e-35 ? var72 = .01997791344831838 : input[97] > 1e-35 ? var72 = .024977281654938052 : input[218] > 1e-35 ? var72 = .031730655567930977 : input[32] > 1e-35 ? input[1] > 1e-35 ? var72 = -.05855958691798028 : var72 = -.009630189044251312 : input[195] > 1e-35 ? var72 = -.009842090802252708 : input[125] > 1e-35 ? var72 = -.030084333742373532 : var72 = -.0009935375527704107 : input[135] > 1e-35 ? var72 = -.006040875366017567 : input[43] > 1e-35 ? var72 = -.03616920022546756 : input[44] > 1e-35 ? var72 = -.014787601622259254 : input[0] > 1e-35 ? var72 = .005949240867095038 : var72 = .0018435357767462809 : input[141] > 1e-35 ? input[3] > 1e-35 ? var72 = -.030610116678182732 : var72 = .01960307197844505 : input[3] > 1.2424533248940002 ? input[101] > 1e-35 ? var72 = -.04366907994393087 : input[28] > 1e-35 ? input[194] > 1e-35 ? var72 = .0927536258129216 : var72 = .00806369969474508 : input[198] > 1e-35 ? var72 = .03402296877725087 : var72 = -.00033907517363096143 : input[194] > 1e-35 ? input[19] > 1e-35 ? var72 = -.16957712930341856 : input[28] > 1e-35 ? var72 = -.2078243840685859 : var72 = -.01982072284112783 : input[134] > 1e-35 ? var72 = -.059093837808976674 : input[155] > 1e-35 ? var72 = -.11429749518431415 : input[1] > 1e-35 ? input[123] > 1e-35 ? var72 = .04159085402090426 : var72 = -.0053579302271092874 : var72 = -.038428527597709254;
  let var73;
  input[2] > 2.249904835165133 ? input[53] > 1e-35 ? var73 = -.09149569302330776 : input[142] > 1e-35 ? var73 = -.020143603866796752 : input[29] > 1e-35 ? input[1] > 1e-35 ? input[4] > 2.740319461670996 ? input[0] > 1e-35 ? var73 = -.005838073295705989 : var73 = .0025448179376697196 : input[217] > 1e-35 ? var73 = .010391363152324442 : input[6] > 3.9219243190762363 ? input[7] > .9546729796082215 ? var73 = .00016709708501075782 : var73 = -.019274537854809464 : input[7] > .9717523368299734 ? input[2] > 4.848108675189105 ? var73 = .0038332904395533517 : input[141] > 1e-35 ? input[6] > 3.0677824455408698 ? var73 = -.12592300140122323 : var73 = -1.2073741246841418 : var73 = -.17682453022795175 : var73 = -.004373737265888883 : var73 = -.032810714691009164 : input[18] > 1e-35 ? var73 = -.024280045660709612 : input[156] > 1e-35 ? var73 = -.023509654115095334 : input[1] > 1e-35 ? input[141] > 1e-35 ? var73 = -.032438707623116556 : input[32] > 1e-35 ? var73 = -.061272201063817755 : var73 = .004415514992097752 : var73 = -.0017176659108089432 : input[0] > 1e-35 ? input[6] > 6.288787065535392 ? input[2] > .8958797346140276 ? var73 = .008680085548304642 : input[29] > 1e-35 ? var73 = .03767506445697859 : var73 = -.0007537359215762705 : input[4] > .8958797346140276 ? var73 = .0002799056937607271 : var73 = -.039667032027283916 : input[2] > 1.2424533248940002 ? var73 = .002506908961838236 : input[29] > 1e-35 ? input[7] > .950335336459789 ? var73 = .0027367426972748597 : var73 = -.021265206402010337 : input[30] > 1e-35 ? input[210] > 1e-35 ? var73 = -.03496264625173957 : var73 = -.007705718616493613 : input[138] > 1e-35 ? var73 = -.035840689909527164 : var73 = .0006855012949462712;
  let var74;
  input[2] > 5.418317700738354 ? input[5] > 6.0051201133541365 ? input[156] > 1e-35 ? var74 = -.024776046248283234 : var74 = -.004761578172448051 : input[8] > 1e-35 ? var74 = -.025343070913887773 : var74 = .012224469039913016 : input[150] > 1e-35 ? var74 = -.04079051452350429 : input[10] > 1e-35 ? input[152] > 1e-35 ? var74 = .019743419118584654 : input[186] > 1e-35 ? var74 = -.15575093795294756 : input[217] > 1e-35 ? var74 = .0056968023991711995 : var74 = -.004356449942923164 : input[5] > 6.0051201133541365 ? input[125] > 1e-35 ? var74 = -.01597803134795572 : input[151] > 1e-35 ? var74 = -.05058454115923059 : input[50] > 1e-35 ? var74 = -.03619853041443809 : input[49] > 1e-35 ? var74 = -.03261722685392842 : input[24] > 1e-35 ? var74 = .011909155984778505 : input[2] > 2.012675845367575 ? var74 = .0004933624031973823 : input[219] > 1e-35 ? var74 = .015579421213152617 : var74 = .002812703494519415 : input[113] > 1e-35 ? input[24] > 1e-35 ? var74 = .09675188599473092 : var74 = .0008025077587732017 : input[204] > 1e-35 ? input[9] > 1e-35 ? input[5] > 3.772694874805912 ? var74 = .02609533140492082 : input[29] > 1e-35 ? var74 = -.21256031284758028 : var74 = .09442590919716193 : var74 = -.004086903422513798 : input[24] > 1e-35 ? input[5] > 3.979637980058199 ? var74 = -.011071875945121415 : input[209] > 1e-35 ? var74 = -.19367443751378252 : var74 = -.04414838576908475 : input[178] > 1e-35 ? var74 = -.06538606241685795 : input[100] > 1e-35 ? input[5] > 3.772694874805912 ? var74 = -.01294941588968201 : input[5] > 2.673553765358735 ? var74 = .08150000027300734 : var74 = -.08989919051554107 : var74 = -.0032151101072856354;
  let var75;
  input[35] > 1e-35 ? var75 = -.05704221149718709 : input[91] > 1e-35 ? var75 = -.023832002943165256 : input[102] > 1e-35 ? var75 = .015441451551750014 : input[3] > 4.993822430271426 ? var75 = -.020159490027748073 : input[4] > 2.3502401828962087 ? input[144] > 1e-35 ? var75 = -.022873219553742163 : input[22] > 1e-35 ? var75 = -.01287591196884623 : input[47] > 1e-35 ? input[18] > 1e-35 ? var75 = .07657102696661595 : var75 = -.0243921910773003 : input[150] > 1e-35 ? var75 = -.043982850497096056 : input[138] > 1e-35 ? input[25] > 1e-35 ? var75 = -.03740348349716821 : var75 = .008237493112057112 : input[49] > 1e-35 ? var75 = -.03254806921800082 : input[53] > 1e-35 ? var75 = -.057370285686186163 : input[3] > 4.085941003063911 ? input[37] > 1e-35 ? var75 = -.04084726667137505 : input[155] > 1e-35 ? var75 = .0323666619020495 : var75 = -.0038866525930422893 : input[118] > 1e-35 ? input[18] > 1e-35 ? var75 = -.0975422096275863 : var75 = -.014038224866250074 : input[136] > 1e-35 ? var75 = -.03199938604211209 : var75 = .0014268928516615767 : input[99] > 1e-35 ? var75 = .018668567929263327 : input[5] > 7.334002872979111 ? input[156] > 1e-35 ? var75 = -.05380541629812827 : input[210] > 1e-35 ? input[30] > 1e-35 ? var75 = -.047112416583853595 : var75 = .00900546030963941 : input[208] > 1e-35 ? var75 = .02334424121914086 : input[158] > 1e-35 ? var75 = .04595592178250823 : var75 = -.006709820970668842 : input[204] > 1e-35 ? input[5] > 3.772694874805912 ? var75 = .009489783712825852 : input[3] > 2.249904835165133 ? var75 = .09999429949553015 : var75 = -.03961464289941561 : var75 = -.001190853283470586;
  let var76;
  input[39] > 1e-35 ? var76 = -.011391872842603505 : input[190] > 1e-35 ? var76 = -.021093147889461955 : input[51] > 1e-35 ? input[18] > 1e-35 ? var76 = .08723256651643213 : var76 = -.04233732133209843 : input[19] > 1e-35 ? var76 = .008078856044745801 : input[4] > .8958797346140276 ? input[60] > 1e-35 ? var76 = -.022165860715145688 : input[129] > 1e-35 ? input[3] > 3.314020688089767 ? var76 = .019990677612126993 : var76 = -.035520772730423776 : input[153] > 1e-35 ? input[2] > .8958797346140276 ? var76 = -.006946377120973384 : input[0] > 1e-35 ? input[8] > 1e-35 ? input[5] > 5.692045796563381 ? var76 = .04230611914121616 : var76 = -.1152833284663223 : var76 = .03987788751961305 : var76 = -.02748865099804465 : input[46] > 1e-35 ? input[18] > 1e-35 ? var76 = .047655531405650486 : var76 = -.022707509947190632 : input[18] > 1e-35 ? input[3] > .8958797346140276 ? input[31] > 1e-35 ? var76 = .1425984397283696 : input[143] > 1e-35 ? var76 = .05597721538261218 : var76 = -.02117927246804007 : var76 = .011077153043550766 : input[143] > 1e-35 ? var76 = -.0158979963012007 : input[187] > 1e-35 ? input[30] > 1e-35 ? var76 = .02515771028113912 : var76 = -.019084229614362958 : input[49] > 1e-35 ? input[1] > 1e-35 ? var76 = .014623537050735559 : var76 = -.05320125987679328 : input[58] > 1e-35 ? input[3] > 3.1132683346437333 ? var76 = .021421346835282216 : var76 = -.03287702034784505 : input[16] > 1e-35 ? var76 = .008645735809593434 : input[3] > 4.993822430271426 ? var76 = -.01889537207927676 : var76 = .00131546333396141 : input[153] > 1e-35 ? var76 = -.09822789507794744 : var76 = -.010292962989428067;
  let var77;
  input[11] > 1e-35 ? input[156] > 1e-35 ? input[4] > 3.1132683346437333 ? var77 = -.009153166060719259 : var77 = -.035386636811765286 : input[58] > 1e-35 ? var77 = -.03881024236774208 : input[153] > 1e-35 ? input[7] > .12645023619128054 ? var77 = -.01286680669029116 : var77 = -.0573874491021103 : input[3] > 3.276966702012906 ? input[38] > 1e-35 ? var77 = -.03084033316462023 : var77 = -.00517175216868761 : input[195] > 1e-35 ? var77 = .01773824295809578 : input[131] > 1e-35 ? var77 = -.17828043850421407 : var77 = .0005554487984838318 : input[7] > .14547530463198097 ? input[105] > 1e-35 ? var77 = -.018589129226123456 : input[116] > 1e-35 ? var77 = -.0227108777687536 : input[24] > 1e-35 ? var77 = .009520152980411787 : input[135] > 1e-35 ? var77 = -.004364970908897872 : input[0] > 1e-35 ? input[18] > 1e-35 ? var77 = -.015737703364129243 : var77 = .003711277180349787 : input[12] > 1e-35 ? input[4] > 3.540854293052788 ? input[155] > 1e-35 ? var77 = .04655165952772795 : var77 = .009321761971665682 : input[210] > 1e-35 ? var77 = .018839890489201528 : input[129] > 1e-35 ? var77 = -.03111680952187252 : var77 = .0002649813454447912 : input[23] > 1e-35 ? var77 = .014110539528977999 : input[109] > 1e-35 ? var77 = .014168740682742625 : var77 = -.0008607565404007093 : input[3] > 2.3502401828962087 ? input[9] > 1e-35 ? input[4] > 3.3842466058243152 ? var77 = -.004252607769147212 : var77 = .02017003996344357 : input[16] > 1e-35 ? var77 = .01594899805169211 : var77 = -.006372071796745688 : input[12] > 1e-35 ? var77 = -.0251011457777017 : input[121] > 1e-35 ? var77 = -.07822588279288774 : var77 = -.005026529762858;
  let var78;
  input[7] > .8375851232899904 ? input[155] > 1e-35 ? input[3] > 1.2424533248940002 ? var78 = .014982109981371684 : var78 = -.08302064203662592 : input[3] > 2.602003343538398 ? input[125] > 1e-35 ? var78 = -.02862612402789537 : var78 = -.0004831913476108919 : input[42] > 1e-35 ? var78 = -.08030278175390543 : input[90] > 1e-35 ? var78 = -.11931838045625616 : var78 = .003328726909052652 : input[125] > 1e-35 ? input[3] > 1e-35 ? var78 = -.03347653784336098 : var78 = .0381767649776156 : input[3] > 2.4414009612931857 ? input[3] > 3.1132683346437333 ? input[137] > 1e-35 ? var78 = .04078434374172937 : input[130] > 1e-35 ? var78 = .04811471469938318 : input[152] > 1e-35 ? var78 = .012079515899716571 : input[23] > 1e-35 ? var78 = .017817807971301534 : input[122] > 1e-35 ? var78 = .049338146544587284 : input[115] > 1e-35 ? var78 = .026905923036994708 : input[10] > 1e-35 ? var78 = -.008135082370740723 : input[89] > 1e-35 ? var78 = .023584069012120446 : input[95] > 1e-35 ? var78 = .013988944683250695 : var78 = -.002584756192745314 : input[139] > 1e-35 ? var78 = -.04454469703180858 : input[99] > 1e-35 ? input[3] > 2.524928003624769 ? var78 = .010620580427538877 : var78 = .047779724434429495 : input[131] > 1e-35 ? var78 = -.08155143867377633 : var78 = .0031488702256745843 : input[7] > .06275229375044648 ? input[99] > 1e-35 ? var78 = .016956254821045937 : input[90] > 1e-35 ? var78 = -.11685880917620971 : input[210] > 1e-35 ? input[11] > 1e-35 ? var78 = -.040607887814632475 : var78 = -.006287900824728332 : var78 = -.0018997472673294537 : input[14] > 1e-35 ? var78 = .02358706984105576 : var78 = -.01737075534918072;
  let var79;
  input[6] > 1e-35 ? input[2] > 5.4049245766661995 ? input[5] > 6.441743353550561 ? input[29] > 1e-35 ? input[4] > 2.673553765358735 ? var79 = -.007517267159018327 : var79 = -.02379463821120899 : var79 = -.0026543290628044274 : input[8] > 1e-35 ? var79 = -.022865480180725452 : var79 = .009005117181880752 : input[6] > 5.161920636569023 ? input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[2] > 2.012675845367575 ? input[3] > 2.3502401828962087 ? var79 = .0021573820428423146 : var79 = -.0046125093600082965 : input[3] > 3.314020688089767 ? var79 = -.005566488595229649 : input[6] > 6.288787065535392 ? var79 = .012796965207082116 : var79 = -.0023971957228440767 : input[3] > 2.249904835165133 ? input[2] > 1e-35 ? var79 = -.0003832411399288501 : input[1] > 1e-35 ? var79 = -.03148874544425103 : var79 = -.3158553329522586 : input[2] > 1e-35 ? var79 = .025981575700247922 : var79 = .052944809618023905 : input[6] > 8.681774988134558 ? input[3] > 2.970085626360216 ? var79 = -.0005280655103032829 : var79 = -.009402467452152188 : input[2] > .8958797346140276 ? var79 = .0018798828715775142 : input[3] > 1.7005986908310777 ? var79 = -.0002583719758369029 : var79 = -.014467497542301198 : input[128] > 1e-35 ? var79 = -.03075061856353219 : input[3] > 3.0201273556387074 ? input[8] > 1e-35 ? var79 = -.03107874404542307 : var79 = -.0063178690978266385 : input[113] > 1e-35 ? input[24] > 1e-35 ? var79 = .10168122236339333 : var79 = .0027676566086997536 : input[100] > 1e-35 ? input[3] > 1.4978661367769956 ? var79 = -.019182725682091863 : input[3] > 1.2424533248940002 ? var79 = .10007959215270637 : var79 = -.049901874168813753 : input[12] > 1e-35 ? var79 = -.008354674563617942 : var79 = .000556773623388255 : var79 = -.06338083699889271;
  let var80;
  input[14] > 1e-35 ? input[5] > 7.841296344941067 ? input[217] > 1e-35 ? var80 = -.03452197748259044 : input[141] > 1e-35 ? var80 = -.05526745933972476 : var80 = .003096257901065188 : var80 = .013468654879205778 : input[90] > 1e-35 ? var80 = -.04633994478668718 : input[7] > .04507521918085865 ? input[39] > 1e-35 ? var80 = -.011427282692256308 : input[188] > 1e-35 ? var80 = -.11824461537515621 : input[17] > 1e-35 ? input[5] > 3.276966702012906 ? var80 = .009014346731620665 : var80 = -.10784986305366669 : input[102] > 1e-35 ? var80 = .014356846380168074 : input[109] > 1e-35 ? var80 = .0100955463134877 : input[31] > 1e-35 ? var80 = .025672511171270042 : input[127] > 1e-35 ? var80 = -.10904631172619624 : input[19] > 1e-35 ? var80 = .007015456473363717 : input[60] > 1e-35 ? var80 = -.02409044800892067 : input[217] > 1e-35 ? input[7] > .9914949911911836 ? var80 = .02334115299069277 : input[1] > 1e-35 ? var80 = -29013080593250377e-21 : var80 = .014307421165143329 : input[1] > 1e-35 ? input[42] > 1e-35 ? var80 = -.06673983904970003 : input[37] > 1e-35 ? var80 = -.05636396687178933 : input[32] > 1e-35 ? var80 = -.042854874962508754 : input[140] > 1e-35 ? var80 = -.014546243613252019 : input[119] > 1e-35 ? var80 = .02592806792359847 : var80 = .0008331579108247542 : input[12] > 1e-35 ? var80 = .004348565717870661 : input[195] > 1e-35 ? var80 = -.016064193157584304 : input[210] > 1e-35 ? var80 = -.01896835246692864 : input[122] > 1e-35 ? var80 = .06415669138405272 : input[219] > 1e-35 ? var80 = -.03191239858069586 : var80 = -.0022170295258555585 : var80 = -.00965022020696389;
  let var81;
  input[55] > 1e-35 ? var81 = -.04649484416236924 : input[6] > 1e-35 ? input[35] > 1e-35 ? var81 = -.04814595674860986 : input[173] > 1e-35 ? var81 = -.030965289355370126 : input[190] > 1e-35 ? var81 = -.01892908615035444 : input[50] > 1e-35 ? var81 = -.03023310323845746 : input[14] > 1e-35 ? input[134] > 1e-35 ? var81 = .029102388421738776 : input[217] > 1e-35 ? var81 = -.021829759931582565 : var81 = .005209049556942947 : input[90] > 1e-35 ? input[3] > 3.276966702012906 ? var81 = .007482519637019732 : input[28] > 1e-35 ? var81 = .08823476156200263 : var81 = -.1134870648564767 : input[17] > 1e-35 ? input[5] > 3.156774023138548 ? input[3] > 2.861792550976191 ? input[134] > 1e-35 ? var81 = .037573808092493166 : var81 = -.008120569804875069 : var81 = .015185866424900767 : var81 = -.10150107137017012 : input[39] > 1e-35 ? var81 = -.011108691883331833 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? var81 = -.019406534412652932 : input[22] > 1e-35 ? var81 = -.011646225036274034 : input[118] > 1e-35 ? input[1] > 1e-35 ? var81 = .007977856608752276 : var81 = -.038946271309380914 : var81 = .0009257226566265858 : input[101] > 1e-35 ? input[6] > 5.769881059461895 ? var81 = -.06484570063989317 : var81 = .016294764421436982 : input[29] > 1e-35 ? input[204] > 1e-35 ? input[5] > 5.859359688974663 ? var81 = .036329398743295674 : var81 = -.20474934656494398 : input[4] > 1.7005986908310777 ? var81 = -.0005630875641286038 : input[5] > 3.5694334999727624 ? input[19] > 1e-35 ? var81 = .03322386202318951 : var81 = -.01687696637036405 : var81 = -.10533305728771972 : var81 = -.0004901077590279651 : var81 = -.05758869249681345;
  let var82;
  input[57] > 1e-35 ? var82 = -.043478488738181505 : input[53] > 1e-35 ? var82 = -.05188532777589009 : input[11] > 1e-35 ? input[156] > 1e-35 ? var82 = -.01733439245316815 : input[58] > 1e-35 ? var82 = -.03508850349398082 : input[134] > 1e-35 ? input[38] > 1e-35 ? input[3] > 3.156774023138548 ? var82 = -.02641618586067251 : var82 = .0053883499998111746 : var82 = -.04111067521339709 : input[46] > 1e-35 ? var82 = -.03960880739147387 : input[56] > 1e-35 ? var82 = .02833430038101972 : input[3] > 4.548585836935273 ? var82 = -.028156779064728323 : var82 = -.0006287807275955149 : input[105] > 1e-35 ? var82 = -.018589321466431944 : input[187] > 1e-35 ? input[30] > 1e-35 ? var82 = .021938681282791916 : var82 = -.016917430307970042 : input[7] > .015258684697466883 ? input[132] > 1e-35 ? var82 = .026815659384164206 : input[204] > 1e-35 ? input[7] > .992067132663463 ? var82 = -.010565408217521758 : input[7] > .9738681190948303 ? input[9] > 1e-35 ? input[30] > 1e-35 ? var82 = .09345774314045512 : var82 = -.003460687191126055 : var82 = .009778848673591349 : var82 = .006207652194161698 : input[134] > 1e-35 ? input[14] > 1e-35 ? var82 = .026940863472122597 : var82 = .004032635910042969 : input[16] > 1e-35 ? input[156] > 1e-35 ? var82 = -.014571620220052964 : input[219] > 1e-35 ? var82 = .03394257525872151 : input[189] > 1e-35 ? var82 = -.16441255476933125 : var82 = .006890416623408193 : input[7] > .5866799179067689 ? input[156] > 1e-35 ? input[9] > 1e-35 ? var82 = -.002374233797129139 : var82 = .015343494638416642 : var82 = .0007085956801478842 : var82 = -.0014226167854637043 : var82 = -.014931890774210171;
  let var83;
  input[52] > 1e-35 ? var83 = -.040552145534119004 : input[88] > 1e-35 ? var83 = -.11616238297789526 : input[147] > 1e-35 ? input[21] > 1e-35 ? var83 = .08405882357263977 : var83 = -.028120036866471673 : input[89] > 1e-35 ? var83 = .013417411709807947 : input[138] > 1e-35 ? input[25] > 1e-35 ? var83 = -.03104795267483152 : input[8] > 1e-35 ? var83 = -.013793892541819341 : var83 = .007067793368543704 : input[3] > 4.212100162283537 ? input[37] > 1e-35 ? var83 = -.04169781427571004 : input[59] > 1e-35 ? var83 = .039366779099462186 : input[190] > 1e-35 ? var83 = -.0746572875957972 : var83 = -.0046665287028623895 : input[31] > 1e-35 ? input[3] > 3.3497501700808394 ? var83 = -.015043885860062665 : var83 = .04427790295514171 : input[127] > 1e-35 ? var83 = -.09222397003880911 : input[188] > 1e-35 ? var83 = -.11791399942046604 : input[116] > 1e-35 ? var83 = -.022670774074606673 : input[21] > 1e-35 ? input[118] > 1e-35 ? var83 = -.08590814127371893 : var83 = -.009079159755287763 : input[10] > 1e-35 ? input[153] > 1e-35 ? input[7] > .12025037553499339 ? var83 = -.010834658570263708 : var83 = -.06942979142484561 : input[59] > 1e-35 ? var83 = -.0368654965105411 : input[186] > 1e-35 ? var83 = -.13585047638050318 : var83 = -.001475385731000911 : input[11] > 1e-35 ? input[47] > 1e-35 ? var83 = -.07021793045868131 : input[58] > 1e-35 ? var83 = -.03264322466138671 : input[153] > 1e-35 ? input[7] > .4982752029697964 ? var83 = -.000719771928860618 : var83 = -.02550581685370434 : var83 = -.001300530189452872 : input[216] > 1e-35 ? var83 = -.04553949138490546 : var83 = .0013445292966782988;
  let var84;
  input[152] > 1e-35 ? var84 = .005642349825665321 : input[108] > 1e-35 ? input[1] > 1e-35 ? var84 = .012759171568581189 : var84 = -.0015650437871311187 : input[102] > 1e-35 ? var84 = .012533880283367552 : input[10] > 1e-35 ? input[4] > 1.4978661367769956 ? input[7] > .9888588760569341 ? var84 = .007453521083396632 : var84 = -.0036225862281260785 : input[3] > .8958797346140276 ? var84 = -.0027177080775155366 : input[5] > 5.782284349061034 ? var84 = -.04454373321655838 : var84 = .021964247026786614 : input[11] > 1e-35 ? input[47] > 1e-35 ? var84 = -.06196070580382676 : input[121] > 1e-35 ? input[1] > 1e-35 ? var84 = -.06122312462911518 : input[7] > .3847172300624272 ? var84 = .03518239795956787 : input[3] > 2.4414009612931857 ? var84 = .006811972713764457 : var84 = -.0933556055347465 : input[5] > 4.938058177869999 ? var84 = -.004012086267764631 : var84 = .01930669434547199 : input[5] > 6.0051201133541365 ? input[27] > 1e-35 ? var84 = -.012304580143719986 : var84 = .0013650712455989071 : input[3] > 2.802901033147999 ? var84 = -.0083470520183599 : input[7] > .5811983411966435 ? input[7] > .990877425524446 ? input[219] > 1e-35 ? input[3] > 1e-35 ? var84 = .06211865200552023 : input[17] > 1e-35 ? var84 = .06775644666502018 : var84 = -.06866304616688222 : input[217] > 1e-35 ? var84 = .059656960273077646 : var84 = -.004328630560280456 : input[204] > 1e-35 ? input[4] > 2.249904835165133 ? var84 = .006371564018556469 : input[3] > 2.138333059508028 ? var84 = .09486061534469152 : var84 = -.09409330595635478 : input[4] > 2.602003343538398 ? var84 = .011308844028341723 : input[100] > 1e-35 ? var84 = .0439316487073224 : var84 = -.003403233436702135 : var84 = -.00960652384005499;
  let var85;
  input[144] > 1e-35 ? input[18] > 1e-35 ? var85 = .07197995497453837 : input[1] > 1e-35 ? var85 = -.001274320993832369 : var85 = -.040032546534329444 : input[52] > 1e-35 ? input[18] > 1e-35 ? var85 = .09098124993319018 : var85 = -.04537404774072243 : input[40] > 1e-35 ? var85 = -.02515534903180516 : input[53] > 1e-35 ? var85 = -.04736675675905027 : input[178] > 1e-35 ? var85 = -.021374380471858013 : input[55] > 1e-35 ? var85 = -.04240162360893064 : input[51] > 1e-35 ? input[18] > 1e-35 ? var85 = .07999652271774131 : var85 = -.036649228565504045 : input[109] > 1e-35 ? var85 = .009067075019741765 : input[54] > 1e-35 ? input[1] > 1e-35 ? var85 = .019160818735605257 : var85 = -.05967997790089002 : input[35] > 1e-35 ? var85 = -.043420689526233285 : input[173] > 1e-35 ? var85 = -.027561163630755333 : input[190] > 1e-35 ? var85 = -.016370101115869642 : input[14] > 1e-35 ? input[217] > 1e-35 ? var85 = -.019735056448517897 : input[141] > 1e-35 ? var85 = -.028090004807030017 : var85 = .006865378253320941 : input[139] > 1e-35 ? input[1] > 1e-35 ? var85 = -.032389864623829076 : var85 = .005458607214221278 : input[60] > 1e-35 ? var85 = -.019089857559617188 : input[153] > 1e-35 ? input[18] > 1e-35 ? var85 = .015189336996079859 : input[19] > 1e-35 ? var85 = .013745154147527805 : input[1] > 1e-35 ? var85 = -.005284271350108698 : var85 = -.0374184512092477 : input[18] > 1e-35 ? input[99] > 1e-35 ? var85 = -.0595395395199616 : input[100] > 1e-35 ? var85 = -.09991342902311327 : var85 = -.0042488091801234805 : var85 = .0006682804828197052;
  let var86;
  input[46] > 1e-35 ? var86 = -.012191380765172536 : input[88] > 1e-35 ? var86 = -.10266216005056819 : input[91] > 1e-35 ? var86 = -.018445844031974568 : input[50] > 1e-35 ? var86 = -.027431707051961525 : input[144] > 1e-35 ? input[7] > .9945060383544003 ? var86 = .03614842925379388 : var86 = -.02095650990295711 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? input[3] > 3.0201273556387074 ? var86 = -.01053451990903616 : var86 = -.05114195197878968 : input[16] > 1e-35 ? var86 = .007316468830803533 : input[9] > 1e-35 ? var86 = .003316750172048933 : var86 = 860911526134492e-20 : input[141] > 1e-35 ? input[3] > 1e-35 ? var86 = -.02547358042212171 : var86 = .019472890771357998 : input[186] > 1e-35 ? var86 = -.09288424685816356 : input[41] > 1e-35 ? var86 = -.1310231930206974 : input[42] > 1e-35 ? var86 = -.056216247465863484 : input[29] > 1e-35 ? input[5] > 3.5694334999727624 ? input[134] > 1e-35 ? var86 = -.054747915129536466 : input[1] > 1e-35 ? input[131] > 1e-35 ? var86 = -.16815706432319097 : var86 = -.002818043413853223 : var86 = -.041951940639575136 : input[7] > .960816451500545 ? input[219] > 1e-35 ? var86 = .10052885656939581 : var86 = -.11599835225683999 : var86 = .029922858316313545 : input[101] > 1e-35 ? input[5] > 7.429817490674132 ? var86 = -.06576516230122952 : var86 = -.0008540865426696243 : input[210] > 1e-35 ? input[114] > 1e-35 ? var86 = .013062456952379193 : input[7] > .7267616382562012 ? var86 = .0022613700798703854 : var86 = -.03938763940013096 : input[59] > 1e-35 ? input[12] > 1e-35 ? var86 = .008501036224046256 : var86 = -.06542467236134167 : var86 = .002585754319607976;
  let var87;
  input[28] > 1e-35 ? var87 = .008779900390406317 : input[7] > .9880960409521241 ? input[8] > 1e-35 ? var87 = -.008991654120695218 : input[3] > 1e-35 ? input[140] > 1e-35 ? var87 = -.02731072195122447 : var87 = .002008744895602654 : input[217] > 1e-35 ? var87 = .02359361264236281 : var87 = .007024522001417586 : input[2] > 2.138333059508028 ? input[3] > 2.4414009612931857 ? input[125] > 1e-35 ? var87 = -.04199133736767654 : input[47] > 1e-35 ? var87 = -.027561033349225085 : input[3] > 4.085941003063911 ? input[12] > 1e-35 ? var87 = .007807873722550442 : input[152] > 1e-35 ? var87 = .030689318204494505 : input[137] > 1e-35 ? var87 = .06699720359975746 : var87 = -.010441301216813357 : input[118] > 1e-35 ? var87 = -.03153852460438172 : input[48] > 1e-35 ? var87 = -.03440026517387997 : var87 = .0015296602873888215 : input[0] > 1e-35 ? input[2] > 6.607325405747152 ? var87 = -.027110120892630915 : input[153] > 1e-35 ? var87 = -.017016088064422574 : var87 = -.005723165911539293 : input[187] > 1e-35 ? var87 = -.031718114891806884 : var87 = -.0005272212291525389 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[46] > 1e-35 ? var87 = -.09171631422683799 : var87 = .003327268948098216 : input[3] > 2.3502401828962087 ? input[125] > 1e-35 ? var87 = -.5887915327321841 : input[2] > 1e-35 ? var87 = -.006637502258168407 : var87 = -.08424468641004934 : input[125] > 1e-35 ? var87 = -.06617256968162606 : var87 = .028846174454930092 : input[2] > 1.2424533248940002 ? input[15] > 1e-35 ? var87 = -.016616715415331784 : var87 = .002680237807803091 : input[3] > 1e-35 ? var87 = -.0012589163812412535 : var87 = -.015154395987664649;
  let var88;
  input[6] > 9.286096980078398 ? input[4] > 2.970085626360216 ? var88 = -.001155963563974424 : var88 = -.011949331884445141 : input[6] > 6.3071868642287745 ? input[2] > 5.150393035655617 ? var88 = -.0033183579364470086 : input[11] > 1e-35 ? var88 = -.0018887492076874403 : input[169] > 1e-35 ? var88 = -.09486398911649394 : var88 = .0025252552927441433 : input[4] > 3.0677824455408698 ? input[7] > .09963982551990838 ? input[141] > 1e-35 ? input[6] > 3.314020688089767 ? var88 = .012137569190879735 : var88 = .09584425242224671 : input[8] > 1e-35 ? input[7] > .987306237235768 ? input[2] > .8958797346140276 ? var88 = -.020817404206469048 : var88 = -.06464699261956137 : var88 = -.008121005894366425 : var88 = -.002273798477153842 : input[4] > 3.5114340430413216 ? var88 = -.024199637055494112 : var88 = -.0044500308011184275 : input[12] > 1e-35 ? var88 = -.00483411782477681 : input[5] > 3.156774023138548 ? input[8] > 1e-35 ? input[5] > 3.772694874805912 ? input[6] > 3.795426061844291 ? var88 = .0013628724281773107 : var88 = -.04205266437322089 : input[141] > 1e-35 ? input[4] > 2.861792550976191 ? input[5] > 3.417592293073651 ? var88 = -.15445392240959782 : input[2] > 2.970085626360216 ? var88 = -.5683130345409004 : var88 = -1.2639522532467855 : var88 = -.12861577169349267 : var88 = -.08527127841498366 : input[4] > 2.4414009612931857 ? input[7] > .29163353806150266 ? var88 = .003881870206848933 : var88 = .01474849027472377 : input[18] > 1e-35 ? input[219] > 1e-35 ? var88 = -.07387984252991263 : var88 = -.013089382916580447 : var88 = -.0008129634296833813 : input[3] > 2.3502401828962087 ? input[2] > 3.1132683346437333 ? var88 = .019943967048858428 : var88 = -.04278248600927625 : input[17] > 1e-35 ? var88 = -.11809979934412335 : var88 = .03777084692378827;
  let var89;
  input[57] > 1e-35 ? var89 = -.03805766278012468 : input[6] > 9.286096980078398 ? input[2] > 3.725620842493839 ? var89 = -.010152097691926694 : var89 = -.000726856757223527 : input[25] > 1e-35 ? input[4] > 2.917405368531303 ? input[6] > 4.226807104886684 ? input[5] > 8.866229029069968 ? var89 = .016965184252348844 : var89 = -.027524673351863413 : var89 = -.09999982742666325 : input[219] > 1e-35 ? var89 = -.11642840619184194 : input[6] > 3.1984648276080736 ? var89 = .02202934385365115 : var89 = -.0758508504188626 : input[17] > 1e-35 ? input[5] > 3.276966702012906 ? input[3] > 2.861792550976191 ? input[38] > 1e-35 ? var89 = .03529859841404316 : var89 = -.005442656204983076 : var89 = .013832633319757828 : var89 = -.07099090377505678 : input[40] > 1e-35 ? input[12] > 1e-35 ? var89 = .020780509349314687 : var89 = -.0412229778697227 : input[178] > 1e-35 ? input[6] > 4.832297822126891 ? var89 = -.012751356404573045 : var89 = -.07365946414911166 : input[6] > 1e-35 ? input[91] > 1e-35 ? var89 = -.018973855754862178 : input[31] > 1e-35 ? input[3] > 3.3497501700808394 ? var89 = -.019342018507399077 : var89 = .04336755184633714 : input[52] > 1e-35 ? var89 = -.034601279556920723 : input[53] > 1e-35 ? var89 = -.04570921257037347 : input[4] > 2.4414009612931857 ? input[22] > 1e-35 ? var89 = -.009909029766665835 : input[88] > 1e-35 ? var89 = -.13759996623650647 : var89 = .0010774168904012999 : input[90] > 1e-35 ? var89 = -.09942790916464699 : input[5] > 8.17933999189099 ? var89 = -.006237804261380787 : input[154] > 1e-35 ? var89 = -.02869365685254793 : input[41] > 1e-35 ? var89 = -.11951308633255478 : var89 = .0005720279396045617 : var89 = -.05091927304878396;
  let var90;
  input[2] > 8.18910569469239 ? var90 = -.011281718118735835 : input[2] > 8.136957041085973 ? var90 = .007639929297282146 : input[2] > 6.178980383851587 ? var90 = -.006867711027875817 : input[6] > 4.5379471377116305 ? input[125] > 1e-35 ? input[3] > 1e-35 ? var90 = -.026657037414316055 : var90 = .03822052894720058 : input[89] > 1e-35 ? var90 = .01442240494610187 : var90 = .0005482931472826037 : input[3] > 2.970085626360216 ? input[8] > 1e-35 ? var90 = -.04157937378268839 : input[25] > 1e-35 ? var90 = -.07438346384769444 : var90 = -.007688780027797844 : input[113] > 1e-35 ? input[24] > 1e-35 ? var90 = .10208422768618285 : var90 = -.0025376848550412623 : input[24] > 1e-35 ? input[209] > 1e-35 ? input[7] > .9738681190948303 ? var90 = -.18081467351794253 : var90 = .06403272706376394 : var90 = -.006045919721112658 : input[100] > 1e-35 ? input[3] > 1.4978661367769956 ? var90 = -.034372452343283254 : input[3] > 1.2424533248940002 ? var90 = .10087241747333926 : var90 = -.06270133551905664 : input[12] > 1e-35 ? input[209] > 1e-35 ? var90 = .02872327658284419 : var90 = -.012940407270969699 : input[5] > 3.276966702012906 ? input[8] > 1e-35 ? var90 = -.02165149142042258 : input[3] > 2.249904835165133 ? var90 = .011522668417532612 : var90 = -.005129494488342788 : input[3] > 2.3502401828962087 ? input[2] > 3.1132683346437333 ? var90 = .018894357520732635 : var90 = -.03443967069634786 : input[19] > 1e-35 ? input[0] > 1e-35 ? var90 = .0868126244943877 : input[2] > 1.4978661367769956 ? input[194] > 1e-35 ? var90 = -.16834554324370338 : var90 = .08799302490518951 : var90 = .007907573815540844 : input[17] > 1e-35 ? var90 = -.07843101628051594 : var90 = .04322926522720053;
  let var91;
  input[7] > .987306237235768 ? input[8] > 1e-35 ? input[5] > 6.285066127789834 ? var91 = 6536595256810364e-20 : input[153] > 1e-35 ? var91 = -.07687008855803332 : var91 = -.015088524832702519 : input[18] > 1e-35 ? var91 = -.012556097563484098 : input[217] > 1e-35 ? input[5] > 8.28387302567733 ? var91 = -.004574660978375117 : var91 = .02566519458840368 : var91 = .003837771337656032 : input[28] > 1e-35 ? input[194] > 1e-35 ? input[29] > 1e-35 ? input[5] > 3.979637980058199 ? var91 = .04675774128546983 : var91 = -.16922871147253024 : input[5] > 5.821564412917691 ? var91 = .017788548280824237 : var91 = .101599048954043 : input[5] > 4.424828703319957 ? var91 = .009470487487627452 : var91 = -.046977132290520585 : input[95] > 1e-35 ? var91 = .008579165333164537 : input[204] > 1e-35 ? input[7] > .9782662069407232 ? input[9] > 1e-35 ? var91 = .0717824359443052 : var91 = .01776258010455891 : var91 = .003970948558978321 : input[208] > 1e-35 ? input[1] > 1e-35 ? var91 = .012428835257375037 : input[18] > 1e-35 ? var91 = -.08152843296689005 : var91 = -.0059907248803252305 : input[109] > 1e-35 ? var91 = .008117980905290326 : input[89] > 1e-35 ? input[1] > 1e-35 ? var91 = -.08097766993639294 : var91 = .014258345453663996 : input[62] > 1e-35 ? var91 = .025185598552042956 : input[213] > 1e-35 ? var91 = .01261362855232781 : input[138] > 1e-35 ? input[1] > 1e-35 ? input[29] > 1e-35 ? var91 = .004355449069502461 : var91 = -.03327693117307522 : input[29] > 1e-35 ? var91 = -.024228224306581475 : input[5] > 5.244385543610066 ? var91 = .01690188327986934 : var91 = -.02426164440751183 : var91 = -.0016932467092565535;
  let var92;
  input[116] > 1e-35 ? var92 = -.018106356667092538 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[5] > 4.658699722134796 ? var92 = -.0289267666661116 : var92 = .10225466717059267 : input[5] > 3.979637980058199 ? var92 = .007715497036238576 : input[209] > 1e-35 ? var92 = -.1596622066794057 : var92 = -.02153459011172981 : input[46] > 1e-35 ? input[18] > 1e-35 ? var92 = .044010040060630896 : var92 = -.018791912393741998 : input[39] > 1e-35 ? var92 = -.008648992983623099 : input[3] > 4.993822430271426 ? var92 = -.01442291433054286 : input[158] > 1e-35 ? var92 = .023944934429097977 : input[21] > 1e-35 ? var92 = -.008731676115726167 : input[51] > 1e-35 ? input[18] > 1e-35 ? var92 = .07015276907667169 : var92 = -.03981801316250594 : input[152] > 1e-35 ? input[12] > 1e-35 ? input[7] > .9811887196001154 ? var92 = .025342984951627335 : input[56] > 1e-35 ? var92 = -.039652717595259894 : var92 = -.003499774006708361 : input[4] > 3.676220550121792 ? var92 = .026612369959601385 : input[0] > 1e-35 ? input[2] > 2.012675845367575 ? var92 = .012259156005894655 : var92 = .04466570041636591 : var92 = .002369030228609974 : input[50] > 1e-35 ? var92 = -.02625338435100237 : input[198] > 1e-35 ? input[5] > 3.156774023138548 ? input[4] > 2.602003343538398 ? var92 = .004706524615587467 : var92 = .03172381727140614 : var92 = -.08877100979833137 : input[19] > 1e-35 ? input[156] > 1e-35 ? var92 = .047690620764284854 : var92 = .004980692597287184 : input[188] > 1e-35 ? var92 = -.10330323519600788 : input[108] > 1e-35 ? var92 = .006389080836282864 : input[217] > 1e-35 ? var92 = .0034861135133741716 : var92 = -.0005184951270632008;
  let var93;
  input[150] > 1e-35 ? var93 = -.03083355660591381 : input[6] > 8.681774988134558 ? input[0] > 1e-35 ? var93 = .0032708551521722813 : input[3] > 2.970085626360216 ? var93 = -.0008773771112515323 : var93 = -.008194765714031488 : input[1] > 1e-35 ? input[42] > 1e-35 ? var93 = -.0544661644610188 : input[114] > 1e-35 ? var93 = .014743200719322279 : input[25] > 1e-35 ? var93 = -.03415156332118204 : input[121] > 1e-35 ? input[0] > 1e-35 ? var93 = -.012241568524042012 : var93 = -.08332027167107449 : input[119] > 1e-35 ? var93 = .02487058944439717 : input[210] > 1e-35 ? input[4] > 2.602003343538398 ? var93 = .003409540133128587 : input[7] > .985694415330804 ? var93 = .014360134818665793 : var93 = -.029939754177999198 : input[140] > 1e-35 ? input[30] > 1e-35 ? var93 = -.07017324311241228 : var93 = -.00954038893956995 : input[32] > 1e-35 ? var93 = -.0321895511220355 : var93 = .0018389054792352236 : input[3] > .8958797346140276 ? input[138] > 1e-35 ? var93 = .014210083256713822 : input[3] > 2.970085626360216 ? input[56] > 1e-35 ? var93 = .03179391063657913 : input[132] > 1e-35 ? var93 = .044860161753142676 : input[122] > 1e-35 ? var93 = .056053352587009365 : input[44] > 1e-35 ? var93 = .011126140459263092 : input[217] > 1e-35 ? var93 = .015177735064648389 : input[30] > 1e-35 ? var93 = .00292550151642784 : input[0] > 1e-35 ? var93 = -.01370614277688821 : var93 = -.00467240699644943 : input[30] > 1e-35 ? input[17] > 1e-35 ? var93 = .06455607454604466 : var93 = -.018525791968354337 : input[127] > 1e-35 ? var93 = .058525937257934674 : var93 = .004550050432870272 : var93 = -.024273015893662056;
  let var94;
  input[57] > 1e-35 ? var94 = -.03433295479723807 : input[35] > 1e-35 ? var94 = -.039185287251387806 : input[2] > 8.18910569469239 ? var94 = -.01005594457537474 : input[2] > 8.136957041085973 ? var94 = .006899889609485921 : input[2] > 5.6542404955442525 ? input[156] > 1e-35 ? var94 = -.021428903659715646 : var94 = -.003794036359277691 : input[6] > 4.3882378946731615 ? input[125] > 1e-35 ? var94 = -.012625422706971806 : input[0] > 1e-35 ? input[2] > .8958797346140276 ? input[32] > 1e-35 ? var94 = .024078606665492636 : input[6] > 6.9309832857755405 ? input[2] > 2.012675845367575 ? var94 = .00015676395930232578 : var94 = .008324926956588046 : var94 = -.0031526636810443134 : input[156] > 1e-35 ? var94 = .053603289446623514 : input[6] > 5.912149824839399 ? var94 = .022861200347258755 : input[128] > 1e-35 ? input[9] > 1e-35 ? var94 = -.44322676747225076 : var94 = -.07989645752877887 : var94 = .005736631305989689 : input[6] > 9.286096980078398 ? var94 = -.005302861539231229 : input[133] > 1e-35 ? var94 = -.011410750972764748 : input[2] > 1e-35 ? input[139] > 1e-35 ? var94 = -.01695599188677891 : input[12] > 1e-35 ? input[129] > 1e-35 ? var94 = -.029257180272820173 : input[106] > 1e-35 ? var94 = .03593102425808264 : input[59] > 1e-35 ? var94 = .03336711951593411 : input[114] > 1e-35 ? var94 = .021293721644930708 : var94 = .0031644417228525465 : input[140] > 1e-35 ? input[2] > 2.802901033147999 ? var94 = .005338088459754211 : var94 = -.018863893195455395 : input[59] > 1e-35 ? input[20] > 1e-35 ? var94 = -.2145461556048109 : var94 = -.013833058686928565 : var94 = .0010745795613665528 : var94 = -.003974960846380726 : var94 = -.004018386137909663;
  let var95;
  input[55] > 1e-35 ? var95 = -.038436881673730244 : input[49] > 1e-35 ? input[1] > 1e-35 ? var95 = .013340924551504776 : var95 = -.04038081752369706 : input[135] > 1e-35 ? input[17] > 1e-35 ? var95 = .02160784630817418 : input[6] > 4.722943345003718 ? input[2] > 3.9981586158983733 ? var95 = -.012347824466576033 : var95 = -.000545766507983511 : input[4] > 3.0201273556387074 ? input[2] > 1e-35 ? var95 = -.0252070573488502 : var95 = -.13173630032620282 : var95 = .009893647988200364 : input[6] > 1e-35 ? input[73] > 1e-35 ? var95 = -.05384174968342247 : input[52] > 1e-35 ? input[1] > 1e-35 ? var95 = .02326718288961822 : var95 = -.04799167043714381 : input[7] > .8453853180651066 ? input[4] > 3.481121732133104 ? input[12] > 1e-35 ? input[59] > 1e-35 ? var95 = .061286381265316374 : input[3] > 3.481121732133104 ? var95 = .005424469650470853 : input[6] > 4.310776603370241 ? var95 = .014609485744972962 : var95 = .06126754321077295 : input[156] > 1e-35 ? input[2] > 8.898092196194755 ? var95 = -.2427431056579565 : var95 = .018014774163852717 : var95 = .0018695162213364096 : input[61] > 1e-35 ? var95 = -.07802947082997094 : input[45] > 1e-35 ? var95 = -.024426413301391545 : input[140] > 1e-35 ? input[4] > .8958797346140276 ? var95 = -.021126260874271455 : input[6] > 4.03420147928485 ? var95 = -.08415757514826445 : input[3] > 1e-35 ? var95 = .10708927158160722 : var95 = -.24178647896179492 : var95 = .0008522369825914582 : input[218] > 1e-35 ? var95 = .02373187641553724 : input[57] > 1e-35 ? var95 = -.04729470896114382 : input[6] > 4.135134555718313 ? var95 = -.00014270136560779048 : var95 = -.007024429214918294 : var95 = -.08338039048086893;
  let var96;
  input[72] > 1e-35 ? var96 = .056415744834310104 : input[102] > 1e-35 ? var96 = .010312560108512227 : input[109] > 1e-35 ? var96 = .007457767681676636 : input[208] > 1e-35 ? input[4] > 3.0677824455408698 ? input[18] > 1e-35 ? var96 = -.06595581480202953 : var96 = .0010087955639505731 : var96 = .010976237400105874 : input[4] > 2.4414009612931857 ? input[123] > 1e-35 ? input[2] > 4.5900436644025815 ? var96 = -.05474288807524913 : var96 = -.010369052951168002 : input[47] > 1e-35 ? input[18] > 1e-35 ? var96 = .06670108938458437 : input[20] > 1e-35 ? var96 = .08555144132474565 : var96 = -.021968528557862133 : input[48] > 1e-35 ? input[18] > 1e-35 ? var96 = .06392608504748652 : var96 = -.02321056177872842 : input[54] > 1e-35 ? var96 = -.03592967725793262 : input[6] > 5.519456907163478 ? var96 = .0008682946366782881 : input[133] > 1e-35 ? var96 = -.029370515479889298 : input[4] > 3.0201273556387074 ? var96 = -.004567764283497172 : input[12] > 1e-35 ? var96 = -.008355751724201374 : input[113] > 1e-35 ? var96 = .04158028065835193 : var96 = .005544170962219649 : input[141] > 1e-35 ? var96 = -.01706283616408152 : input[186] > 1e-35 ? var96 = -.08075713781164345 : input[196] > 1e-35 ? input[4] > 2.012675845367575 ? var96 = -.004591551989937031 : input[4] > .8958797346140276 ? input[18] > 1e-35 ? var96 = -.1239344826496822 : var96 = .026355647530608275 : var96 = -.07955511774996737 : input[41] > 1e-35 ? var96 = -.10181506412232362 : input[42] > 1e-35 ? var96 = -.0453542732395041 : input[116] > 1e-35 ? var96 = -.040407946567398226 : input[158] > 1e-35 ? var96 = .027239009428531448 : var96 = -.002118967070037752;
  let var97;
  input[174] > 1e-35 ? var97 = -.02339144841300339 : input[173] > 1e-35 ? var97 = -.02466576607302462 : input[60] > 1e-35 ? var97 = -.014400177078045 : input[187] > 1e-35 ? var97 = -.009580909976967153 : input[6] > 8.681774988134558 ? var97 = -.0018832004566674773 : input[1] > 1e-35 ? input[42] > 1e-35 ? input[10] > 1e-35 ? var97 = -.13287881120130746 : var97 = -.03759084751116859 : input[25] > 1e-35 ? var97 = -.029737667621816583 : input[119] > 1e-35 ? var97 = .022639692376110337 : input[98] > 1e-35 ? var97 = .014991063146855506 : input[195] > 1e-35 ? input[6] > 3.417592293073651 ? var97 = .008961268500787772 : var97 = -.023240187732927162 : input[61] > 1e-35 ? input[7] > .428769371249852 ? var97 = -.08413653233956772 : var97 = .0010489731231787087 : input[140] > 1e-35 ? input[3] > .8958797346140276 ? input[5] > 4.855921334140645 ? input[44] > 1e-35 ? var97 = -.009299863216357543 : var97 = -.0613782065666655 : var97 = -.06705655672927394 : input[5] > 3.772694874805912 ? var97 = .0008635593500817348 : var97 = .08361268069705163 : var97 = .001087642897550713 : input[98] > 1e-35 ? var97 = -.021712258264119783 : input[3] > .8958797346140276 ? input[105] > 1e-35 ? var97 = -.039681509263849626 : input[195] > 1e-35 ? input[18] > 1e-35 ? var97 = -.07079074829049314 : var97 = -.008109353986158243 : input[210] > 1e-35 ? input[18] > 1e-35 ? var97 = -.10610285355896108 : var97 = -.009292320249100847 : input[157] > 1e-35 ? var97 = .03507595269407085 : input[97] > 1e-35 ? var97 = .0249669535461336 : input[48] > 1e-35 ? var97 = -.027595291123779366 : var97 = .0011643902717306173 : var97 = -.0211420439263067;
  let var98;
  input[138] > 1e-35 ? input[1] > 1e-35 ? input[42] > 1e-35 ? input[3] > 3.5114340430413216 ? var98 = -.022448598781455772 : var98 = -.07031164685918086 : input[2] > 1e-35 ? input[2] > 2.740319461670996 ? var98 = .00894455632762117 : var98 = -.003454709734759444 : input[0] > 1e-35 ? var98 = .060858110677215166 : var98 = -.03435493609374257 : input[3] > 2.602003343538398 ? input[2] > .8958797346140276 ? var98 = .0168978378983998 : var98 = -.009237748165804088 : var98 = -.016931758267026403 : input[3] > 4.424828703319957 ? var98 = -.005659352703826067 : input[24] > 1e-35 ? input[113] > 1e-35 ? input[6] > 4.460127707454046 ? var98 = -.023722482692479133 : var98 = .10064484300766507 : input[6] > 4.03420147928485 ? var98 = .007526717802235146 : input[209] > 1e-35 ? input[4] > 2.970085626360216 ? var98 = .11711852031495243 : var98 = -.15067622815741855 : var98 = -.011085192149895408 : input[108] > 1e-35 ? var98 = .0059255171206349135 : input[19] > 1e-35 ? input[156] > 1e-35 ? var98 = .04454460743043898 : input[37] > 1e-35 ? var98 = -.14161163738926447 : input[4] > 1.4978661367769956 ? input[4] > 1.7005986908310777 ? input[217] > 1e-35 ? var98 = -.020705364221039385 : var98 = .006460529078997639 : input[0] > 1e-35 ? input[98] > 1e-35 ? var98 = .10347448218504114 : var98 = -.04090123141769794 : input[6] > 5.636572136251498 ? var98 = -.001212671493834005 : input[2] > 1.8688348091416842 ? var98 = -.15821279618670178 : var98 = -.03563734739460456 : var98 = .027924859655082585 : input[57] > 1e-35 ? var98 = -.03743904649648422 : input[35] > 1e-35 ? var98 = -.0414066369468363 : input[46] > 1e-35 ? var98 = -.011240341460759123 : var98 = -.0003091959047563666;
  let var99;
  input[14] > 1e-35 ? input[5] > 7.841296344941067 ? input[141] > 1e-35 ? var99 = -.04382809259971909 : input[217] > 1e-35 ? input[4] > 3.417592293073651 ? var99 = -.05008164665262682 : var99 = .0007032387608254502 : input[190] > 1e-35 ? var99 = -.19371592847895003 : var99 = .0017489801221668277 : input[129] > 1e-35 ? var99 = -.24591656603456258 : var99 = .011026730387591234 : input[72] > 1e-35 ? var99 = .05658163433406649 : input[90] > 1e-35 ? input[4] > 3.5114340430413216 ? var99 = .017141361021852975 : input[28] > 1e-35 ? var99 = .07243997319099477 : var99 = -.08677988948169385 : input[138] > 1e-35 ? var99 = .0038201430289573884 : input[23] > 1e-35 ? input[4] > 2.917405368531303 ? var99 = .014990462643385919 : var99 = -.013592080985068531 : input[217] > 1e-35 ? input[4] > 1.8688348091416842 ? var99 = .0022421195021632245 : input[4] > 1.2424533248940002 ? var99 = .03891295508085918 : input[4] > .8958797346140276 ? var99 = -.08902318396862074 : var99 = .02476911275463073 : input[2] > 3.1132683346437333 ? input[29] > 1e-35 ? input[19] > 1e-35 ? var99 = .023731839695418987 : input[5] > 7.366761104104307 ? input[4] > 3.417592293073651 ? input[6] > 6.633975895571033 ? input[8] > 1e-35 ? var99 = .016171629088047517 : input[134] > 1e-35 ? var99 = .03196373735768742 : var99 = -.006820341969572339 : var99 = -.02712238491085242 : var99 = -.016309188486296804 : var99 = -.0019386576944297078 : input[156] > 1e-35 ? var99 = -.03079416196682616 : input[123] > 1e-35 ? var99 = -.020888866054988395 : input[4] > 3.238486181444842 ? var99 = -.0027078359220281674 : input[141] > 1e-35 ? var99 = -.029581214969996845 : var99 = .002299670778244013 : var99 = .0001804027795430786;
  let var100 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10 + var11 + var12 + var13 + var14 + var15 + var16 + var17 + var18 + var19 + var20 + var21 + var22 + var23 + var24 + var25 + var26 + var27 + var28 + var29 + var30 + var31 + var32 + var33 + var34 + var35 + var36 + var37 + var38 + var39 + var40 + var41 + var42 + var43 + var44 + var45 + var46 + var47 + var48 + var49 + var50 + var51 + var52 + var53 + var54 + var55 + var56 + var57 + var58 + var59 + var60 + var61 + var62 + var63 + var64 + var65 + var66 + var67 + var68 + var69 + var70 + var71 + var72 + var73 + var74 + var75 + var76 + var77 + var78 + var79 + var80 + var81 + var82 + var83 + var84 + var85 + var86 + var87 + var88 + var89 + var90 + var91 + var92 + var93 + var94 + var95 + var96 + var97 + var98 + var99);
  return [1 - var100, var100];
}
__name(treeScore, "treeScore");
function sigmoid(x) {
  if (x < 0) {
    let z = Math.exp(x);
    return z / (1 + z);
  }
  return 1 / (1 + Math.exp(-x));
}
__name(sigmoid, "sigmoid");
var ContextualFilterManager = class {
  static {
    __name(this, "ContextualFilterManager");
  }
  constructor() {
    this.previousLabel = 0, this.previousLabelTimestamp = Date.now() - 3600, this.probabilityAccept = 0;
  }
};
function getLastLineLength(source) {
  let lines = source.split(`
`);
  return lines[lines.length - 1].length;
}
__name(getLastLineLength, "getLastLineLength");
function contextualFilterScore(ctx, telemetryData, prompt, contextualFilterEnableTree) {
  let cfManager = ctx.get(ContextualFilterManager),
    yt_1 = cfManager.previousLabel,
    acw = 0;
  "afterCursorWhitespace" in telemetryData.properties && telemetryData.properties.afterCursorWhitespace === "true" && (acw = 1);
  let dt_1 = (Date.now() - cfManager.previousLabelTimestamp) / 1e3,
    ln_dt_1 = Math.log(1 + dt_1),
    ln_promptLastLineLength = 0,
    promptLastCharIndex = 0,
    promptPrefix = prompt.prefix;
  if (promptPrefix) {
    ln_promptLastLineLength = Math.log(1 + getLastLineLength(promptPrefix));
    let promptLastChar = promptPrefix.slice(-1);
    contextualFilterCharacterMap[promptLastChar] !== void 0 && (promptLastCharIndex = contextualFilterCharacterMap[promptLastChar]);
  }
  let ln_promptLastLineRstripLength = 0,
    promptLastRstripCharIndex = 0,
    promptPrefixRstrip = promptPrefix.trimEnd();
  if (promptPrefixRstrip) {
    ln_promptLastLineRstripLength = Math.log(1 + getLastLineLength(promptPrefixRstrip));
    let promptLastRstripChar = promptPrefixRstrip.slice(-1);
    contextualFilterCharacterMap[promptLastRstripChar] !== void 0 && (promptLastRstripCharIndex = contextualFilterCharacterMap[promptLastRstripChar]);
  }
  let ln_documentLength = 0;
  if ("documentLength" in telemetryData.measurements) {
    let documentLength = telemetryData.measurements.documentLength;
    ln_documentLength = Math.log(1 + documentLength);
  }
  let ln_promptEndPos = 0;
  if ("promptEndPos" in telemetryData.measurements) {
    let promptEndPos = telemetryData.measurements.promptEndPos;
    ln_promptEndPos = Math.log(1 + promptEndPos);
  }
  let relativeEndPos = 0;
  if ("promptEndPos" in telemetryData.measurements && "documentLength" in telemetryData.measurements) {
    let documentLength = telemetryData.measurements.documentLength;
    relativeEndPos = (telemetryData.measurements.promptEndPos + .5) / (1 + documentLength);
  }
  let languageIndex = 0;
  contextualFilterLanguageMap[telemetryData.properties.languageId] !== void 0 && (languageIndex = contextualFilterLanguageMap[telemetryData.properties.languageId]);
  let probabilityAccept = 0;
  if (contextualFilterEnableTree) {
    let features = new Array(221).fill(0);
    features[0] = yt_1, features[1] = acw, features[2] = ln_dt_1, features[3] = ln_promptLastLineLength, features[4] = ln_promptLastLineRstripLength, features[5] = ln_documentLength, features[6] = ln_promptEndPos, features[7] = relativeEndPos, features[8 + languageIndex] = 1, features[29 + promptLastCharIndex] = 1, features[125 + promptLastRstripCharIndex] = 1, probabilityAccept = treeScore(features)[1];
  } else {
    let sum = contextualFilterIntercept;
    sum += contextualFilterWeights[0] * yt_1, sum += contextualFilterWeights[1] * acw, sum += contextualFilterWeights[2] * ln_dt_1, sum += contextualFilterWeights[3] * ln_promptLastLineLength, sum += contextualFilterWeights[4] * ln_promptLastLineRstripLength, sum += contextualFilterWeights[5] * ln_documentLength, sum += contextualFilterWeights[6] * ln_promptEndPos, sum += contextualFilterWeights[7] * relativeEndPos, sum += contextualFilterWeights[8 + languageIndex], sum += contextualFilterWeights[29 + promptLastCharIndex], sum += contextualFilterWeights[125 + promptLastRstripCharIndex], probabilityAccept = 1 / (1 + Math.exp(-sum));
  }
  return ctx.get(ContextualFilterManager).probabilityAccept = probabilityAccept, probabilityAccept;
}
__name(contextualFilterScore, "contextualFilterScore");
var import_copilot_promptlib = Ns(Dc()),
  import_crypto_js = Ns(o8());
async function* asyncIterableMap(source, selector) {
  for await (let item of source) yield selector(item);
}
__name(asyncIterableMap, "asyncIterableMap");
async function* asyncIterableFilter(source, predicate) {
  for await (let item of source) (await predicate(item)) && (yield item);
}
__name(asyncIterableFilter, "asyncIterableFilter");
async function* asyncIterableMapFilter(source, selector) {
  for await (let item of source) {
    let result = await selector(item);
    result !== void 0 && (yield result);
  }
}
__name(asyncIterableMapFilter, "asyncIterableMapFilter");
async function* asyncIterableFromArray(source) {
  for (let item of source) yield item;
}
__name(asyncIterableFromArray, "asyncIterableFromArray");
var knownTemplateLanguageExtensions = [".ejs", ".erb", ".haml", ".hbs", ".j2", ".jinja", ".jinja2", ".liquid", ".mustache", ".njk", ".php", ".pug", ".slim", ".webc"],
  templateLanguageLimitations = {
    ".php": [".blade"]
  },
  knownFileExtensions = Object.keys(knownLanguages).flatMap(language => knownLanguages[language].extensions);
var path = require("path"),
  Language = class {
    constructor(languageId, isGuess, fileExtension) {
      this.languageId = languageId;
      this.isGuess = isGuess;
      this.fileExtension = fileExtension;
    }
    static {
      __name(this, "Language");
    }
  },
  LanguageDetection = class {
    static {
      __name(this, "LanguageDetection");
    }
  };
function primeLanguageDetectionCache(ctx, doc) {
  ctx.get(LanguageDetection).detectLanguage(doc);
}
__name(primeLanguageDetectionCache, "primeLanguageDetectionCache");
function getLanguageDetection(ctx) {
  return new CachingLanguageDetection(new FilenameAndExensionLanguageDetection(), new NotebookLanguageDetection(ctx));
}
__name(getLanguageDetection, "getLanguageDetection");
var CachingLanguageDetection = class extends LanguageDetection {
  constructor(delegate, notebookDelegate) {
    super();
    this.delegate = delegate;
    this.notebookDelegate = notebookDelegate;
    this.cache = new LRUCacheMap(100);
  }
  static {
    __name(this, "CachingLanguageDetection");
  }
  async detectLanguage(doc) {
    let filename = path.basename(doc.uri.path);
    return isNotebook(filename) ? this.notebookDelegate.detectLanguage(doc) : this.detectLanguageForRegularFile(filename, doc);
  }
  async detectLanguageForRegularFile(filename, doc) {
    let language = this.cache.get(filename);
    return language || (language = await this.delegate.detectLanguage(doc), language.isGuess || this.cache.set(filename, language)), language;
  }
};
function isNotebook(filename) {
  return filename.endsWith(".ipynb");
}
__name(isNotebook, "isNotebook");
var NotebookLanguageDetection = class extends LanguageDetection {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "NotebookLanguageDetection");
    }
    async detectLanguage(doc) {
      let notebook = this.ctx.get(TextDocumentManager).findNotebook(doc);
      return notebook ? this.detectCellLanguage(doc, notebook) : new Language("python", !1, ".ipynb");
    }
    detectCellLanguage(doc, notebook) {
      let activeCell = notebook.getCells().find(cell => cell.document.uri.toString() === doc.uri.toString());
      if (activeCell) {
        let metadata = activeCell.metadata;
        return metadata?.custom?.metadata?.vscode?.languageId ? new Language(metadata.custom.metadata.vscode.languageId, !1, ".ipynb") : activeCell.kind === 2 ? new Language("python", !1, ".ipynb") : new Language("markdown", !1, ".ipynb");
      }
      return new Language("unknown", !1, ".ipynb");
    }
  },
  FilenameAndExensionLanguageDetection = class extends LanguageDetection {
    constructor() {
      super(...arguments);
      this.languageIdByExtensionTracker = new LanguageIdTracker();
    }
    static {
      __name(this, "FilenameAndExensionLanguageDetection");
    }
    async detectLanguage(doc) {
      let filename = path.basename(doc.uri.path),
        extension = path.extname(filename).toLowerCase(),
        extensionWithoutTemplate = this.extensionWithoutTemplateLanguage(filename, extension),
        languageIdWithGuessing = this.detectLanguageId(filename, extensionWithoutTemplate);
      return new Language(languageIdWithGuessing.languageId, languageIdWithGuessing.isGuess, this.computeFullyQualifiedExtension(extension, extensionWithoutTemplate));
    }
    extensionWithoutTemplateLanguage(filename, extension) {
      if (knownTemplateLanguageExtensions.includes(extension)) {
        let filenameWithoutExtension = filename.substring(0, filename.lastIndexOf(".")),
          extensionWithoutTemplate = path.extname(filenameWithoutExtension).toLowerCase();
        if (extensionWithoutTemplate.length > 0 && knownFileExtensions.includes(extensionWithoutTemplate) && this.isExtensionValidForTemplateLanguage(extension, extensionWithoutTemplate)) return extensionWithoutTemplate;
      }
      return extension;
    }
    isExtensionValidForTemplateLanguage(extension, extensionWithoutTemplate) {
      let limitations = templateLanguageLimitations[extension];
      return !limitations || limitations.includes(extensionWithoutTemplate);
    }
    detectLanguageId(filename, extension) {
      let candidatesByExtension = [];
      for (let language in knownLanguages) {
        let info = knownLanguages[language];
        if (info.filenames && info.filenames.includes(filename)) return {
          languageId: language,
          isGuess: !1
        };
        info.extensions.includes(extension) && candidatesByExtension.push(language);
      }
      return this.determineLanguageIdByCandidates(candidatesByExtension);
    }
    determineLanguageIdByCandidates(candidates) {
      return candidates.length === 1 ? (this.languageIdByExtensionTracker.track(candidates[0]), {
        languageId: candidates[0],
        isGuess: !1
      }) : candidates.length > 1 ? this.determineMostSeenLanguages(candidates) : {
        languageId: "unknown",
        isGuess: !0
      };
    }
    determineMostSeenLanguages(candidates) {
      let mostSeenLanguageId = this.languageIdByExtensionTracker.mostRecentLanguageId(candidates);
      return mostSeenLanguageId ? {
        languageId: mostSeenLanguageId,
        isGuess: !0
      } : {
        languageId: candidates[0],
        isGuess: !0
      };
    }
    computeFullyQualifiedExtension(extension, extensionWithoutTemplate) {
      return extension !== extensionWithoutTemplate ? extensionWithoutTemplate + extension : extension;
    }
  },
  LanguageIdTracker = class {
    constructor() {
      this.seenLanguages = new LRUCacheMap(25);
    }
    static {
      __name(this, "LanguageIdTracker");
    }
    track(languageId) {
      this.seenLanguages.set(languageId, this.preciseTimestamp());
    }
    preciseTimestamp() {
      return process.hrtime.bigint();
    }
    mostRecentLanguageId(candidates) {
      let mostRecentIds = candidates.map(languageId => ({
        id: languageId,
        seen: this.seenLanguages.get(languageId)
      })).filter(candidate => candidate.seen).sort((a, b) => Number(b.seen) - Number(a.seen)).map(candidate => candidate.id);
      if (mostRecentIds.length > 0) return mostRecentIds[0];
    }
  };
var OPENAI_PROXY_HOST = "https://copilot-proxy.githubusercontent.com";
var V1_ENGINES_COPILOT_CODEX = "/v1/engines/copilot-codex";
function _getOverrideProxyURL(ctx) {
  return isRunningInTest(ctx) ? getConfig(ctx, ConfigKey.DebugTestOverrideProxyUrl) : getConfig(ctx, ConfigKey.DebugOverrideProxyUrl);
}
__name(_getOverrideProxyURL, "_getOverrideProxyURL");
function getProxyURLWithPath(ctx, path) {
  let proxyUrl = _getOverrideProxyURL(ctx);
  return proxyUrl.length == 0 && (proxyUrl = OPENAI_PROXY_HOST), `${proxyUrl}${path}`;
}
__name(getProxyURLWithPath, "getProxyURLWithPath");
async function _getEnginePath(ctx, repoNwo, fileType, dogFood, userKind, customModel, retrievalOrg, telemetryData) {
  let engineOverride = getConfig(ctx, ConfigKey.DebugOverrideEngine);
  if (engineOverride) return `/v1/engines/${engineOverride}`;
  let customEngine = await ctx.get(Features).customEngine({
    repoNwo: repoNwo,
    fileType: fileType,
    userKind: userKind,
    dogFood: dogFood,
    customModel: customModel,
    retrievalOrg: retrievalOrg
  }, telemetryData);
  return customEngine !== "" ? `/v1/engines/${customEngine}` : V1_ENGINES_COPILOT_CODEX;
}
__name(_getEnginePath, "_getEnginePath");
async function getEngineURL(ctx, nwo, fileType, dogfood, userKind, customModel, retrievalOrg, telemetryData) {
  return getProxyURLWithPath(ctx, await _getEnginePath(ctx, nwo, fileType, dogfood, userKind, customModel, retrievalOrg, telemetryData));
}
__name(getEngineURL, "getEngineURL");
var util = Ns(require("util"));
var StatusReporter = class {
  static {
    __name(this, "StatusReporter");
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_git_url_parse = Ns(Kee()),
  import_path = require("path"),
  import_vscode_uri = Ns(B1());
async function getUserKind(ctx) {
  let orgs = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).organization_list ?? [];
  return ["a5db0bcaae94032fe715fb34a5e4bce2", "7184f66dfcee98cb5f08a1cb936d5225", "4535c7beffc844b46bb1ed4aa04d759a"].find(org => orgs.includes(org)) ?? "";
}
__name(getUserKind, "getUserKind");
async function getFtFlag(ctx) {
  return (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).getTokenValue("ft") ?? "";
}
__name(getFtFlag, "getFtFlag");
async function getRagFlag(ctx) {
  return (await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !1)).getTokenValue("rag") ?? "";
}
__name(getRagFlag, "getRagFlag");
function getDogFood(repoInfo) {
  if (repoInfo === void 0 || repoInfo === 0) return "";
  let ghnwo = tryGetGitHubNWO(repoInfo);
  if (ghnwo === "github/github") return ghnwo;
  let adoNwo = tryGetADONWO(repoInfo)?.toLowerCase();
  return adoNwo !== void 0 ? adoNwo : "";
}
__name(getDogFood, "getDogFood");
function tryGetGitHubNWO(repoInfo) {
  if (repoInfo !== void 0 && repoInfo !== 0 && repoInfo.hostname === "github.com") return repoInfo.owner + "/" + repoInfo.repo;
}
__name(tryGetGitHubNWO, "tryGetGitHubNWO");
function tryGetADONWO(repoInfo) {
  if (repoInfo !== void 0 && repoInfo !== 0 && (repoInfo.hostname.endsWith("azure.com") || repoInfo.hostname.endsWith("visualstudio.com"))) return repoInfo.owner + "/" + repoInfo.repo;
}
__name(tryGetADONWO, "tryGetADONWO");
function extractRepoInfoInBackground(ctx, uri) {
  let baseFolder = Yee.Utils.dirname(uri);
  return backgroundRepoInfo(ctx, baseFolder);
}
__name(extractRepoInfoInBackground, "extractRepoInfoInBackground");
var backgroundRepoInfo = computeInBackgroundAndMemoize(extractRepoInfo, 1e4);
async function extractRepoInfo(ctx, uri) {
  if (uri.scheme !== "file") return;
  let baseFolder = await getRepoBaseFolder(ctx, uri.fsPath);
  if (!baseFolder) return;
  let fs = ctx.get(xO.FileSystem),
    configPath = (0, Z4.join)(baseFolder, ".git", "config"),
    gitConfig;
  try {
    gitConfig = await fs.readFile(configPath);
  } catch {
    return;
  }
  let url = getRepoUrlFromConfigText(gitConfig.toString()) ?? "",
    parsedResult = parseRepoUrl(url);
  return parsedResult === void 0 ? {
    baseFolder: baseFolder,
    url: url,
    hostname: "",
    owner: "",
    repo: "",
    pathname: ""
  } : {
    baseFolder: baseFolder,
    url: url,
    ...parsedResult
  };
}
__name(extractRepoInfo, "extractRepoInfo");
function parseRepoUrl(url) {
  let parsedUrl = {};
  try {
    if (parsedUrl = (0, Xee.GitUrlParse)(url), parsedUrl.host == "" || parsedUrl.owner == "" || parsedUrl.name == "" || parsedUrl.pathname == "") return;
  } catch {
    return;
  }
  return {
    hostname: parsedUrl.host,
    owner: parsedUrl.owner,
    repo: parsedUrl.name,
    pathname: parsedUrl.pathname
  };
}
__name(parseRepoUrl, "parseRepoUrl");
async function getRepoBaseFolder(ctx, uri) {
  let previousUri = uri + "_add_to_make_longer",
    fs = ctx.get(xO.FileSystem);
  for (; uri.length > 1 && uri.length < previousUri.length;) {
    let configPath = (0, Z4.join)(uri, ".git", "config"),
      result = !1;
    try {
      await fs.stat(configPath), result = !0;
    } catch {
      result = !1;
    }
    if (result) return uri;
    previousUri = uri, uri = (0, Z4.dirname)(uri);
  }
}
__name(getRepoBaseFolder, "getRepoBaseFolder");
function getRepoUrlFromConfigText(gitConfig) {
  let remoteSectionRegex = /^\s*\[\s*remote\s+"((\\\\|\\"|[^\\"])+)"/,
    deprecatedRemoteSectionRegex = /^\s*\[remote.([^"\s]+)/,
    setUrlRegex = /^\s*url\s*=\s*([^\s#;]+)/,
    newSectionRegex = /^\s*\[/,
    remoteUrl,
    remoteSection,
    isWithinMultilineUrl = !1;
  for (let line of gitConfig.split(`
`)) if (isWithinMultilineUrl && remoteUrl !== void 0) {
    if (remoteUrl += line, line.endsWith("\\")) remoteUrl = remoteUrl.substring(0, remoteUrl.length - 1);else if (isWithinMultilineUrl = !1, remoteSection === "origin") return remoteUrl;
  } else {
    let remoteSectionMatch = line.match(remoteSectionRegex) ?? line.match(deprecatedRemoteSectionRegex);
    if (remoteSectionMatch) remoteSection = remoteSectionMatch[1];else if (line.match(newSectionRegex)) remoteSection = void 0;else {
      if (remoteUrl && remoteSection !== "origin") continue;
      {
        let urlMatch = line.match(setUrlRegex);
        if (urlMatch) {
          if (remoteUrl = urlMatch[1], remoteUrl.endsWith("\\")) remoteUrl = remoteUrl.substring(0, remoteUrl.length - 1), isWithinMultilineUrl = !0;else if (remoteSection === "origin") return remoteUrl;
        }
      }
    }
  }
  return remoteUrl;
}
__name(getRepoUrlFromConfigText, "getRepoUrlFromConfigText");
var CompletedComputation = class {
  static {
    __name(this, "CompletedComputation");
  }
  constructor(result) {
    this.result = result;
  }
};
function computeInBackgroundAndMemoize(fct, cacheSize) {
  let resultsCache = new LRUCacheMap(cacheSize),
    inComputation = new Set();
  return (ctx, ...args) => {
    let key = JSON.stringify(args),
      memorizedComputation = resultsCache.get(key);
    if (memorizedComputation) return memorizedComputation.result;
    if (inComputation.has(key)) return 0;
    let computation = fct(ctx, ...args);
    return inComputation.add(key), computation.then(computedResult => {
      resultsCache.set(key, new CompletedComputation(computedResult)), inComputation.delete(key);
    }), 0;
  };
}
__name(computeInBackgroundAndMemoize, "computeInBackgroundAndMemoize");
function convertToAPIChoice(ctx, completionText, jsonData, choiceIndex, requestId, blockFinished, telemetryData, modelInfo) {
  return logEngineCompletion(ctx, completionText, jsonData, requestId, choiceIndex), {
    completionText: completionText,
    meanLogProb: calculateMeanLogProb(ctx, jsonData),
    meanAlternativeLogProb: calculateMeanAlternativeLogProb(ctx, jsonData),
    choiceIndex: choiceIndex,
    requestId: requestId,
    modelInfo: modelInfo,
    blockFinished: blockFinished,
    tokens: jsonData.tokens,
    numTokens: jsonData.tokens.length,
    telemetryData: telemetryData
  };
}
__name(convertToAPIChoice, "convertToAPIChoice");
async function* cleanupIndentChoices(choices, indentation) {
  for await (let choice of choices) {
    let choiceCopy = {
        ...choice
      },
      completionLines = choiceCopy.completionText.split(`
`);
    for (let i = 0; i < completionLines.length; ++i) {
      let newLine = completionLines[i].trimLeft();
      newLine === "" ? completionLines[i] = newLine : completionLines[i] = indentation + newLine;
    }
    choiceCopy.completionText = completionLines.join(`
`), yield choiceCopy;
  }
}
__name(cleanupIndentChoices, "cleanupIndentChoices");
function calculateMeanLogProb(ctx, jsonData) {
  if (jsonData?.logprobs?.token_logprobs) try {
    let logProbSum = 0,
      numTokens = 0,
      iterLimit = 50;
    for (let i = 0; i < jsonData.logprobs.token_logprobs.length - 1 && iterLimit > 0; i++, iterLimit--) logProbSum += jsonData.logprobs.token_logprobs[i], numTokens += 1;
    return numTokens > 0 ? logProbSum / numTokens : void 0;
  } catch (e) {
    logger.exception(ctx, e, "Error calculating mean prob");
  }
}
__name(calculateMeanLogProb, "calculateMeanLogProb");
function calculateMeanAlternativeLogProb(ctx, jsonData) {
  if (jsonData?.logprobs?.top_logprobs) try {
    let logProbSum = 0,
      numTokens = 0,
      iterLimit = 50;
    for (let i = 0; i < jsonData.logprobs.token_logprobs.length - 1 && iterLimit > 0; i++, iterLimit--) {
      let options = {
        ...jsonData.logprobs.top_logprobs[i]
      };
      delete options[jsonData.logprobs.tokens[i]], logProbSum += Math.max(...Object.values(options)), numTokens += 1;
    }
    return numTokens > 0 ? logProbSum / numTokens : void 0;
  } catch (e) {
    logger.exception(ctx, e, "Error calculating mean prob");
  }
}
__name(calculateMeanAlternativeLogProb, "calculateMeanAlternativeLogProb");
function getTemperatureForSamples(ctx, numShots) {
  if (isRunningInTest(ctx)) return 0;
  let configTemp = parseFloat(getConfig(ctx, ConfigKey.Temperature));
  return configTemp >= 0 && configTemp <= 1 ? configTemp : numShots <= 1 ? 0 : numShots < 10 ? .2 : numShots < 20 ? .4 : .8;
}
__name(getTemperatureForSamples, "getTemperatureForSamples");
var streamChoicesLogger = new Logger(1, "streamChoices"),
  APIJsonDataStreaming = class {
    constructor() {
      this.logprobs = [];
      this.top_logprobs = [];
      this.text = [];
      this.tokens = [];
      this.text_offset = [];
    }
    static {
      __name(this, "APIJsonDataStreaming");
    }
    append(choice) {
      choice.text && this.text.push(choice.text), choice.delta?.content && this.text.push(choice.delta.content), choice.logprobs && (this.tokens.push(choice.logprobs.tokens ?? []), this.text_offset.push(choice.logprobs.text_offset ?? []), this.logprobs.push(choice.logprobs.token_logprobs ?? []), this.top_logprobs.push(choice.logprobs.top_logprobs ?? []));
    }
  };
function splitChunk(chunk) {
  let dataLines = chunk.split(`
`),
    newExtra = dataLines.pop();
  return [dataLines.filter(line => line != ""), newExtra];
}
__name(splitChunk, "splitChunk");
var SSEProcessor = class _SSEProcessor {
  constructor(ctx, expectedNumChoices, response, body, telemetryData, dropCompletionReasons, fastCancellation, cancellationToken) {
    this.ctx = ctx;
    this.expectedNumChoices = expectedNumChoices;
    this.response = response;
    this.body = body;
    this.telemetryData = telemetryData;
    this.dropCompletionReasons = dropCompletionReasons;
    this.fastCancellation = fastCancellation;
    this.cancellationToken = cancellationToken;
    this.requestId = getRequestId(this.response);
    this.stats = new ChunkStats(this.expectedNumChoices);
    this.solutions = {};
  }
  static {
    __name(this, "SSEProcessor");
  }
  static async create(ctx, expectedNumChoices, response, telemetryData, dropCompletionReasons, cancellationToken) {
    let body = await response.body();
    body.setEncoding("utf8");
    let fastCancellation = await ctx.get(Features).fastCancellation();
    return new _SSEProcessor(ctx, expectedNumChoices, response, body, telemetryData, dropCompletionReasons ?? ["content_filter"], fastCancellation, cancellationToken);
  }
  async *processSSE(finishedCb = async () => {}) {
    try {
      yield* this.processSSEInner(finishedCb);
    } finally {
      this.fastCancellation && this.cancel(), streamChoicesLogger.info(this.ctx, `request done: headerRequestId: [${this.requestId.headerRequestId}] model deployment ID: [${this.requestId.deploymentId}]`), streamChoicesLogger.debug(this.ctx, `request stats: ${this.stats}`);
    }
  }
  async *processSSEInner(finishedCb) {
    let extraData = "";
    networkRead: for await (let chunk of this.body) {
      if (this.maybeCancel("after awaiting body chunk")) return;
      streamChoicesLogger.debug(this.ctx, "chunk", chunk.toString());
      let [dataLines, remainder] = splitChunk(extraData + chunk.toString());
      extraData = remainder;
      for (let dataLine of dataLines) {
        let lineWithoutData = dataLine.slice(5).trim();
        if (lineWithoutData == "[DONE]") {
          yield* this.finishSolutions();
          return;
        }
        let json;
        try {
          json = JSON.parse(lineWithoutData);
        } catch {
          streamChoicesLogger.error(this.ctx, "Error parsing JSON stream data", dataLine);
          continue;
        }
        if (json.choices === void 0) {
          json.error !== void 0 ? streamChoicesLogger.error(this.ctx, "Error in response:", json.error.message) : streamChoicesLogger.error(this.ctx, "Unexpected response with no choices or error: " + lineWithoutData);
          continue;
        }
        if (this.requestId.created == 0 && (this.requestId = getRequestId(this.response, json), this.requestId.created == 0 && streamChoicesLogger.error(this.ctx, `Request id invalid, should have "completionId" and "created": ${this.requestId}`, this.requestId)), this.allSolutionsDone() && this.fastCancellation) break networkRead;
        for (let i = 0; i < json.choices.length; i++) {
          let choice = json.choices[i];
          streamChoicesLogger.debug(this.ctx, "choice", choice), this.stats.add(choice.index), choice.index in this.solutions || (this.solutions[choice.index] = new APIJsonDataStreaming());
          let solution = this.solutions[choice.index];
          if (solution == null) continue;
          solution.append(choice);
          let finishOffset,
            hasNewLine = choice.text?.indexOf(`
`) > -1 || choice.delta?.content?.indexOf(`
`) > -1;
          if ((choice.finish_reason || hasNewLine) && (finishOffset = await finishedCb(solution.text.join("")), this.maybeCancel("after awaiting finishedCb"))) return;
          if (!(choice.finish_reason || finishOffset !== void 0)) continue;
          let loggedReason = choice.finish_reason ?? "client-trimmed";
          if (telemetry(this.ctx, "completion.finishReason", this.telemetryData.extendedBy({
            completionChoiceFinishReason: loggedReason
          })), this.dropCompletionReasons.includes(choice.finish_reason) ? this.solutions[choice.index] = null : (this.stats.markYielded(choice.index), yield {
            solution: solution,
            finishOffset: finishOffset,
            reason: choice.finish_reason,
            requestId: this.requestId,
            index: choice.index
          }), this.maybeCancel("after yielding finished choice")) return;
          this.solutions[choice.index] = null;
        }
      }
    }
    for (let [index, solution] of Object.entries(this.solutions)) {
      let solutionIndex = Number(index);
      if (solution != null && (this.stats.markYielded(solutionIndex), yield {
        solution: solution,
        finishOffset: void 0,
        reason: "Iteration Done",
        requestId: this.requestId,
        index: solutionIndex
      }, this.maybeCancel("after yielding after iteration done"))) return;
    }
    if (extraData.length > 0) try {
      let extraDataJson = JSON.parse(extraData);
      extraDataJson.error !== void 0 && streamChoicesLogger.error(this.ctx, `Error in response: ${extraDataJson.error.message}`, extraDataJson.error);
    } catch {
      streamChoicesLogger.error(this.ctx, `Error parsing extraData: ${extraData}`);
    }
  }
  async *finishSolutions() {
    for (let [index, solution] of Object.entries(this.solutions)) {
      let solutionIndex = Number(index);
      if (solution != null && (this.stats.markYielded(solutionIndex), yield {
        solution: solution,
        finishOffset: void 0,
        reason: "DONE",
        requestId: this.requestId,
        index: solutionIndex
      }, this.maybeCancel("after yielding on DONE"))) return;
    }
  }
  maybeCancel(description) {
    return this.cancellationToken?.isCancellationRequested ? (streamChoicesLogger.debug(this.ctx, "Cancelled: " + description), this.cancel(), !0) : !1;
  }
  cancel() {
    this.body.destroy();
  }
  allSolutionsDone() {
    let solutions = Object.values(this.solutions);
    return solutions.length == this.expectedNumChoices && solutions.every(s => s == null);
  }
};
function prepareSolutionForReturn(ctx, c, telemetryData) {
  let completionText = c.solution.text.join(""),
    blockFinished = !1;
  c.finishOffset !== void 0 && (streamChoicesLogger.debug(ctx, `solution ${c.index}: early finish at offset ${c.finishOffset}`), completionText = completionText.substring(0, c.finishOffset), blockFinished = !0), streamChoicesLogger.info(ctx, `solution ${c.index} returned. finish reason: [${c.reason}]`), streamChoicesLogger.debug(ctx, `solution ${c.index} details: finishOffset: [${c.finishOffset}] completionId: [{${c.requestId.completionId}}] created: [{${c.requestId.created}}]`);
  let jsonData = convertToAPIJsonData(ctx, c.solution);
  return convertToAPIChoice(ctx, completionText, jsonData, c.index, c.requestId, blockFinished, telemetryData);
}
__name(prepareSolutionForReturn, "prepareSolutionForReturn");
function convertToAPIJsonData(ctx, streamingData) {
  let out = {
    text: streamingData.text.join(""),
    tokens: streamingData.text
  };
  if (streamingData.logprobs.length === 0) return out;
  let flattenedLogprobs = streamingData.logprobs.reduce((acc, cur) => acc.concat(cur), []),
    flattenedTopLogprobs = streamingData.top_logprobs.reduce((acc, cur) => acc.concat(cur), []),
    flattenedOffsets = streamingData.text_offset.reduce((acc, cur) => acc.concat(cur), []),
    flattenedTokens = streamingData.tokens.reduce((acc, cur) => acc.concat(cur), []);
  return {
    ...out,
    logprobs: {
      token_logprobs: flattenedLogprobs,
      top_logprobs: flattenedTopLogprobs,
      text_offset: flattenedOffsets,
      tokens: flattenedTokens
    }
  };
}
__name(convertToAPIJsonData, "convertToAPIJsonData");
var ChunkStats = class {
    constructor(expectedNumChoices) {
      this.choices = new Map();
      for (let i = 0; i < expectedNumChoices; i++) this.choices.set(i, new ChoiceStats());
    }
    static {
      __name(this, "ChunkStats");
    }
    add(choiceIndex) {
      this.choices.get(choiceIndex).increment();
    }
    markYielded(choiceIndex) {
      this.choices.get(choiceIndex).markYielded();
    }
    toString() {
      return Array.from(this.choices.entries()).map(([index, stats]) => `${index}: ${stats.yieldedTokens} -> ${stats.seenTokens}`).join(", ");
    }
  },
  ChoiceStats = class {
    constructor() {
      this.yieldedTokens = -1;
      this.seenTokens = 0;
    }
    static {
      __name(this, "ChoiceStats");
    }
    increment() {
      this.seenTokens++;
    }
    markYielded() {
      this.yieldedTokens = this.seenTokens;
    }
  };
var fetchLogger = new Logger(1, "fetch");
function getRequestId(response, json) {
  return {
    headerRequestId: response.headers.get("x-request-id") || "",
    completionId: json && json.id ? json.id : "",
    created: json && json.created ? json.created : 0,
    serverExperiments: response.headers.get("X-Copilot-Experiment") || "",
    deploymentId: response.headers.get("azureml-model-deployment") || ""
  };
}
__name(getRequestId, "getRequestId");
function getProcessingTime(response) {
  let reqIdStr = response.headers.get("openai-processing-ms");
  return reqIdStr ? parseInt(reqIdStr, 10) : 0;
}
__name(getProcessingTime, "getProcessingTime");
function extractEngineName(ctx, engineUrl) {
  let engineName = engineUrl.split("/").pop();
  return engineName || (fetchLogger.error(ctx, "Malformed engine URL: " + engineUrl), engineUrl);
}
__name(extractEngineName, "extractEngineName");
function uiKindToIntent(uiKind) {
  switch (uiKind) {
    case "ghostText":
      return "copilot-ghost";
    case "synthesize":
      return "copilot-panel";
  }
}
__name(uiKindToIntent, "uiKindToIntent");
var OpenAIFetcher = class {
  static {
    __name(this, "OpenAIFetcher");
  }
};
function fetchWithInstrumentation(ctx, prompt, engineUrl, endpoint, ourRequestId, request, secretKey, uiKind, cancel, telemetryProperties) {
  let statusReporter = ctx.get(StatusReporter),
    uri = tte.format("%s/%s", engineUrl, endpoint);
  if (!secretKey) {
    logger.error(ctx, `Failed to send request to ${uri} due to missing key`);
    return;
  }
  let telemetryData = TelemetryData.createAndMarkAsIssued({
    endpoint: endpoint,
    engineName: extractEngineName(ctx, engineUrl),
    uiKind: uiKind
  }, telemetrizePromptLength(prompt));
  telemetryProperties && (telemetryData = telemetryData.extendedBy(telemetryProperties));
  for (let [key, value] of Object.entries(request)) key == "prompt" || key == "suffix" || (telemetryData.properties[`request.option.${key}`] = JSON.stringify(value) ?? "undefined");
  telemetryData.properties.headerRequestId = ourRequestId, telemetry(ctx, "request.sent", telemetryData);
  let requestStart = now(),
    intent = uiKindToIntent(uiKind);
  return postRequest(ctx, uri, secretKey, intent, ourRequestId, request, cancel).then(response => {
    let modelRequestId = getRequestId(response, void 0);
    telemetryData.extendWithRequestId(modelRequestId);
    let totalTimeMs = now() - requestStart;
    return telemetryData.measurements.totalTimeMs = totalTimeMs, logger.info(ctx, `request.response: [${uri}] took ${totalTimeMs} ms`), logger.debug(ctx, "request.response properties", telemetryData.properties), logger.debug(ctx, "request.response measurements", telemetryData.measurements), logger.debug(ctx, `prompt: ${JSON.stringify(prompt)}`), telemetry(ctx, "request.response", telemetryData), response;
  }).catch(error => {
    if (isAbortError(error)) throw error;
    statusReporter.setWarning(error.message);
    let warningTelemetry = telemetryData.extendedBy({
      error: "Network exception"
    });
    telemetry(ctx, "request.shownWarning", warningTelemetry), telemetryData.properties.message = String(error.name ?? ""), telemetryData.properties.code = String(error.code ?? ""), telemetryData.properties.errno = String(error.errno ?? ""), telemetryData.properties.type = String(error.type ?? "");
    let totalTimeMs = now() - requestStart;
    throw telemetryData.measurements.totalTimeMs = totalTimeMs, logger.debug(ctx, `request.response: [${uri}] took ${totalTimeMs} ms`), logger.debug(ctx, "request.error properties", telemetryData.properties), logger.debug(ctx, "request.error measurements", telemetryData.measurements), telemetry(ctx, "request.error", telemetryData), error;
  }).finally(() => {
    logEnginePrompt(ctx, prompt, telemetryData);
  });
}
__name(fetchWithInstrumentation, "fetchWithInstrumentation");
function postProcessChoices(choices, allowEmptyChoices) {
  return allowEmptyChoices ?? !1 ? choices : asyncIterableFilter(choices, async choice => choice.completionText.trim().length > 0);
}
__name(postProcessChoices, "postProcessChoices");
var LiveOpenAIFetcher = class extends OpenAIFetcher {
  static {
    __name(this, "LiveOpenAIFetcher");
  }
  async fetchAndStreamCompletions(ctx, params, baseTelemetryData, finishedCb, cancel, telemetryProperties) {
    let statusReporter = ctx.get(StatusReporter),
      endpoint = "completions",
      response = await this.fetchWithParameters(ctx, endpoint, params, cancel, telemetryProperties);
    if (response === "not-sent") return {
      type: "canceled",
      reason: "before fetch request"
    };
    if (cancel?.isCancellationRequested) {
      let body = await response.body();
      try {
        body.destroy();
      } catch (e) {
        logger.exception(ctx, e, "Error destroying stream");
      }
      return {
        type: "canceled",
        reason: "after fetch request"
      };
    }
    if (response === void 0) {
      let telemetryData = this.createTelemetryData(endpoint, ctx, params);
      return statusReporter.setWarning(), telemetryData.properties.error = "Response was undefined", telemetry(ctx, "request.shownWarning", telemetryData), {
        type: "failed",
        reason: "fetch response was undefined"
      };
    }
    if (response.status !== 200) {
      let telemetryData = this.createTelemetryData(endpoint, ctx, params);
      return this.handleError(ctx, statusReporter, telemetryData, response);
    }
    let dropCompletionReasons = await ctx.get(Features).dropCompletionReasons(),
      finishedCompletions = (await SSEProcessor.create(ctx, params.count, response, baseTelemetryData, dropCompletionReasons, cancel)).processSSE(finishedCb),
      choices = asyncIterableMap(finishedCompletions, async solution => prepareSolutionForReturn(ctx, solution, baseTelemetryData));
    return {
      type: "success",
      choices: postProcessChoices(choices, params.allowEmptyChoices),
      getProcessingTime: () => getProcessingTime(response)
    };
  }
  createTelemetryData(endpoint, ctx, params) {
    return TelemetryData.createAndMarkAsIssued({
      endpoint: endpoint,
      engineName: extractEngineName(ctx, params.engineUrl),
      uiKind: params.uiKind,
      headerRequestId: params.ourRequestId
    });
  }
  async fetchWithParameters(ctx, endpoint, params, cancel, telemetryProperties) {
    let stops = getLanguageConfig(ctx, ConfigKey.Stops),
      disableLogProb = await ctx.get(Features).disableLogProb(),
      request = {
        prompt: params.prompt.prefix,
        suffix: params.prompt.suffix,
        max_tokens: getConfig(ctx, ConfigKey.SolutionLength),
        temperature: getTemperatureForSamples(ctx, params.count),
        top_p: getConfig(ctx, ConfigKey.TopP),
        n: params.count,
        stop: stops
      };
    (params.requestLogProbs || !disableLogProb) && (request.logprobs = 2);
    let githubNWO = tryGetGitHubNWO(params.repoInfo);
    return githubNWO !== void 0 && (request.nwo = githubNWO), params.postOptions && Object.assign(request, params.postOptions), cancel?.isCancellationRequested ? "not-sent" : (logger.info(ctx, `[fetchCompletions] engine ${params.engineUrl}`), await fetchWithInstrumentation(ctx, params.prompt, params.engineUrl, endpoint, params.ourRequestId, request, (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token, params.uiKind, cancel, telemetryProperties));
  }
  async handleError(ctx, statusReporter, telemetryData, response) {
    if (statusReporter.setWarning(), telemetryData.properties.error = `Response status was ${response.status}`, telemetryData.properties.status = String(response.status), telemetry(ctx, "request.shownWarning", telemetryData), response.status === 401 || response.status === 403) return ctx.get(CopilotTokenManager).resetCopilotToken(ctx, response.status), {
      type: "failed",
      reason: `token expired or invalid: ${response.status}`
    };
    if (response.status === 499) return fetchLogger.info(ctx, "Cancelled by server"), {
      type: "failed",
      reason: "canceled by server"
    };
    let text = await response.text();
    return response.status === 466 ? (statusReporter.setError(text), fetchLogger.info(ctx, text), {
      type: "failed",
      reason: `client not supported: ${text}`
    }) : (fetchLogger.error(ctx, "Unhandled status from server:", response.status, text), {
      type: "failed",
      reason: `unhandled status from server: ${response.status} ${text}`
    });
  }
};
var LocationFactory = class {
  static {
    __name(this, "LocationFactory");
  }
};
var promptlib = Ns(Dc());
var worker = null,
  handlers = new Map(),
  nextHandlerId = 0;
function init(ctx, use_worker_threads, logger) {
  if (!use_worker_threads) {
    let localPromptlib = (uL(), nT(Pre));
    for (let fn of allFuns) updatePromptLibProxyFunction(fn, localPromptlib[fn]);
    return;
  }
  for (let fn of workerFuns) updatePromptLibProxyFunction(fn, proxy(ctx, logger, fn));
  promptLibProxy.getPrompt = getPromptProxy(ctx, logger), worker = X0.createWorker(), handlers.clear(), nextHandlerId = 0, worker.on("message", ({
    id: id,
    err: err,
    code: code,
    res: res
  }) => {
    let handler = handlers.get(id);
    logger.debug(ctx, `Response ${id} - ${res}, ${err}`), handler && (handlers.delete(id), err ? (err.code = code, handler.reject(err)) : handler.resolve(res));
  });
  function handleError(maybeError) {
    let err;
    if (maybeError instanceof Error) {
      err = maybeError, err.code === "MODULE_NOT_FOUND" && err.message?.endsWith("worker.js'") && (err = new Error("Failed to load worker.js"), err.code = "CopilotPromptLoadFailure");
      let ourStack = new Error().stack;
      err.stack && ourStack?.match(/^Error\n/) && (err.stack += ourStack.replace(/^Error/, ""));
    } else maybeError?.name === "ExitStatus" && typeof maybeError.status == "number" ? (err = new Error(`worker.js exited with status ${maybeError.status}`), err.code = `CopilotPromptWorkerExit${maybeError.status}`) : err = new Error(`Non-error thrown: ${maybeError}`);
    for (let handler of handlers.values()) handler.reject(err);
    handlers.clear();
  }
  __name(handleError, "handleError"), worker.on("error", handleError);
}
__name(init, "init");
function terminate() {
  worker && (worker.removeAllListeners(), worker.terminate(), worker = null, handlers.clear());
}
__name(terminate, "terminate");
var workerFuns = ["getFunctionPositions", "isEmptyBlockStart", "isBlockBodyFinished", "getNodeStart", "getCallSites", "parsesWithoutError"],
  directFuns = ["isSupportedLanguageId", "getBlockCloseToken", "getPrompt"],
  allFuns = [...workerFuns, ...directFuns];
function proxy(ctx, logger, fn) {
  return function (...args) {
    let id = nextHandlerId++;
    return new Promise((resolve, reject) => {
      handlers.set(id, {
        resolve: resolve,
        reject: reject
      }), logger.debug(ctx, `Proxy ${fn}`), worker?.postMessage({
        id: id,
        fn: fn,
        args: args
      });
    });
  };
}
__name(proxy, "proxy");
function getPromptProxy(ctx, logger) {
  return function (_fileSystem, ...args) {
    let id = nextHandlerId++;
    return new Promise((resolve, reject) => {
      handlers.set(id, {
        resolve: resolve,
        reject: reject
      }), logger.debug(ctx, `Proxy getPrompt - ${id}`), worker?.postMessage({
        id: id,
        fn: "getPrompt",
        args: args
      });
    });
  };
}
__name(getPromptProxy, "getPromptProxy");
function updatePromptLibProxyFunction(fn, impl) {
  promptLibProxy[fn] = impl;
}
__name(updatePromptLibProxyFunction, "updatePromptLibProxyFunction");
var promptLibProxy = {
  isEmptyBlockStart: X0.isEmptyBlockStart,
  isBlockBodyFinished: X0.isBlockBodyFinished,
  isSupportedLanguageId: X0.isSupportedLanguageId,
  getBlockCloseToken: X0.getBlockCloseToken,
  getFunctionPositions: X0.getFunctionPositions,
  getNodeStart: X0.getNodeStart,
  getPrompt: X0.getPrompt,
  getCallSites: X0.getCallSites,
  parsesWithoutError: X0.parsesWithoutError
};
function isEmptyBlockStart(doc, position) {
  return promptLibProxy.isEmptyBlockStart(doc.languageId, doc.getText(), doc.offsetAt(position));
}
__name(isEmptyBlockStart, "isEmptyBlockStart");
function parsingBlockFinished(ctx, doc, position) {
  let locationFactory = ctx.get(LocationFactory),
    prefix = doc.getText(locationFactory.range(locationFactory.position(0, 0), position)),
    offset = doc.offsetAt(position),
    languageId = doc.languageId;
  return completion => promptLibProxy.isBlockBodyFinished(languageId, prefix, completion, offset);
}
__name(parsingBlockFinished, "parsingBlockFinished");
async function getNodeStart(ctx, doc, position, completion) {
  let locationFactory = ctx.get(LocationFactory),
    text = doc.getText(locationFactory.range(locationFactory.position(0, 0), position)) + completion,
    offset = await promptLibProxy.getNodeStart(doc.languageId, text, doc.offsetAt(position));
  if (offset) return doc.positionAt(offset);
}
__name(getNodeStart, "getNodeStart");
var continuations = ["\\{", "\\}", "\\[", "\\]", "\\(", "\\)"].concat(["then", "else", "elseif", "elif", "catch", "finally", "fi", "done", "end", "loop", "until", "where", "when"].map(s => s + "\\b")),
  continuationRegex = new RegExp(`^(${continuations.join("|")})`);
function isContinuationLine(line) {
  return continuationRegex.test(line.trimLeft().toLowerCase());
}
__name(isContinuationLine, "isContinuationLine");
function indentationOfLine(line) {
  let match = /^(\s*)([^]*)$/.exec(line);
  if (match && match[2] && match[2].length > 0) return match[1].length;
}
__name(indentationOfLine, "indentationOfLine");
function contextIndentation(doc, position) {
  let source = doc.getText(),
    offset = doc.offsetAt(position);
  return contextIndentationFromText(source, offset, doc.languageId);
}
__name(contextIndentation, "contextIndentation");
function contextIndentationFromText(source, offset, languageId) {
  let prevLines = source.slice(0, offset).split(`
`),
    nextLines = source.slice(offset).split(`
`);
  function seekNonBlank(lines, start, direction) {
    let i = start,
      ind,
      indIdx;
    for (; ind === void 0 && i >= 0 && i < lines.length;) ind = indentationOfLine(lines[i]), indIdx = i, i += direction;
    if (languageId === "python" && direction === -1) {
      i++;
      let trimmedLine = lines[i].trim();
      if (trimmedLine.endsWith('"""')) {
        if (!(trimmedLine.startsWith('"""') && trimmedLine !== '"""')) for (i--; i >= 0 && !lines[i].trim().startsWith('"""');) i--;
        if (i >= 0) for (ind = void 0, i--; ind === void 0 && i >= 0;) ind = indentationOfLine(lines[i]), indIdx = i, i--;
      }
    }
    return [ind, indIdx];
  }
  __name(seekNonBlank, "seekNonBlank");
  let [current, currentIdx] = seekNonBlank(prevLines, prevLines.length - 1, -1),
    prev = (() => {
      if (!(current === void 0 || currentIdx === void 0)) for (let i = currentIdx - 1; i >= 0; i--) {
        let ind = indentationOfLine(prevLines[i]);
        if (ind !== void 0 && ind < current) return ind;
      }
    })(),
    [next] = seekNonBlank(nextLines, 1, 1);
  return {
    prev: prev,
    current: current ?? 0,
    next: next
  };
}
__name(contextIndentationFromText, "contextIndentationFromText");
var OfferNextLineCompletion = !1;
function completionCutOrContinue(completion, contextIndentation, previewText) {
  let completionLines = completion.split(`
`),
    isContinuation = previewText !== void 0,
    lastLineOfPreview = previewText?.split(`
`).pop(),
    startLine = 0;
  if (isContinuation && lastLineOfPreview?.trim() != "" && completionLines[0].trim() !== "" && startLine++, !isContinuation && OfferNextLineCompletion && completionLines[0].trim() === "" && startLine++, isContinuation || startLine++, completionLines.length === startLine) return "continue";
  let breakIndentation = Math.max(contextIndentation.current, contextIndentation.next ?? 0);
  for (let i = startLine; i < completionLines.length; i++) {
    let line = completionLines[i];
    i == 0 && lastLineOfPreview !== void 0 && (line = lastLineOfPreview + line);
    let ind = indentationOfLine(line);
    if (ind !== void 0 && (ind < breakIndentation || ind === breakIndentation && !isContinuationLine(line))) return completionLines.slice(0, i).join(`
`).length;
  }
  return "continue";
}
__name(completionCutOrContinue, "completionCutOrContinue");
function indentationBlockFinished(contextIndentation, previewText) {
  return async completion => {
    let res = completionCutOrContinue(completion, contextIndentation, previewText);
    return res === "continue" ? void 0 : res;
  };
}
__name(indentationBlockFinished, "indentationBlockFinished");
var import_copilot_promptlib = Ns(Dc());
function telemetryShown(ctx, insertionCategory, telemetryData, fromCache) {
  telemetryData.markAsDisplayed();
  let eventName = fromCache ? `${insertionCategory}.shownFromCache` : `${insertionCategory}.shown`;
  telemetry(ctx, eventName, telemetryData);
}
__name(telemetryShown, "telemetryShown");
function telemetryAccepted(ctx, insertionCategory, telemetryData) {
  let telemetryName = insertionCategory + ".accepted",
    cfManager = ctx.get(ContextualFilterManager);
  cfManager.previousLabel = 1, cfManager.previousLabelTimestamp = Date.now(), telemetry(ctx, telemetryName, telemetryData);
}
__name(telemetryAccepted, "telemetryAccepted");
function telemetryRejected(ctx, insertionCategory, telemetryData) {
  let telemetryName = insertionCategory + ".rejected",
    cfManager = ctx.get(ContextualFilterManager);
  cfManager.previousLabel = 0, cfManager.previousLabelTimestamp = Date.now(), telemetry(ctx, telemetryName, telemetryData);
}
__name(telemetryRejected, "telemetryRejected");
function mkCanceledResultTelemetry(telemetryBlob, extraFlags = {}) {
  return {
    ...extraFlags,
    telemetryBlob: telemetryBlob
  };
}
__name(mkCanceledResultTelemetry, "mkCanceledResultTelemetry");
function mkBasicResultTelemetry(telemetryBlob) {
  let result = {
    headerRequestId: telemetryBlob.properties.headerRequestId,
    copilot_trackingId: telemetryBlob.properties.copilot_trackingId
  };
  return telemetryBlob.properties.sku !== void 0 && (result.sku = telemetryBlob.properties.sku), telemetryBlob.properties.organizations_list !== void 0 && (result.organizations_list = telemetryBlob.properties.organizations_list), telemetryBlob.properties.enterprise_list !== void 0 && (result.enterprise_list = telemetryBlob.properties.enterprise_list), result;
}
__name(mkBasicResultTelemetry, "mkBasicResultTelemetry");
async function handleGhostTextResultTelemetry(ctx, result) {
  if (result.type === "success") return telemetryRaw(ctx, "ghostText.produced", result.telemetryData, {}), result.value;
  if (result.type !== "abortedBeforeIssued") {
    if (result.type === "canceled") {
      telemetry(ctx, "ghostText.canceled", result.telemetryData.telemetryBlob.extendedBy({
        reason: result.reason,
        cancelledNetworkRequest: result.telemetryData.cancelledNetworkRequest ? "true" : "false"
      }));
      return;
    }
    telemetryRaw(ctx, `ghostText.${result.type}`, {
      ...result.telemetryData,
      reason: result.reason
    }, {});
  }
}
__name(handleGhostTextResultTelemetry, "handleGhostTextResultTelemetry");
var POLICY_ENDPOINT = "https://repositorypolicy.azurewebsites.net/GetPolicy/v1";
var NOT_BLOCKED_RESPONSE = {
    isBlocked: !1,
    reason: "VALID_FILE"
  },
  NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE = {
    isBlocked: !1,
    reason: "NO_MATCHING_POLICY"
  },
  BLOCKED_REPO_RESPONSE = {
    isBlocked: !0,
    reason: "REPO_BLOCKED",
    message: "Your organization has disabled Copilot for this repository"
  },
  BLOCKED_FILE_RESPONSE = {
    isBlocked: !0,
    reason: "FILE_BLOCKED",
    message: "Your organization has disabled Copilot for this file"
  },
  BLOCKED_POLICY_ERROR_RESPONSE = {
    isBlocked: !0,
    reason: "POLICY_ERROR",
    message: "Copilot is disabled because we could not fetch the repository policy"
  };
var PolicyEvaluator = class {
  static {
    __name(this, "PolicyEvaluator");
  }
};
var import_typebox = Ns(ou());
var e = new WeakMap();
function t(r, o) {
  if (r == null || typeof r != "object") return String(r);
  let a,
    c = "",
    n = 0,
    s = Object.prototype.toString.call(r);
  if (s !== "[object RegExp]" && s !== "[object Date]" && e.has(r)) return e.get(r);
  switch (e.set(r, "~" + ++o), s) {
    case "[object Set]":
      a = Array.from(r);
    case "[object Array]":
      for (a || (a = r), c += "a"; n < a.length; c += t(a[n++], o));
      break;
    case "[object Object]":
      for (c += "o", a = Object.keys(r).sort(); n < a.length; c += a[n] + t(r[a[n++]], o));
      break;
    case "[object Map]":
      for (c += "o", a = Array.from(r.keys()).sort(); n < a.length; c += a[n] + t(r.get(a[n++]), o));
      break;
    case "[object Date]":
      return "d" + +r;
    case "[object RegExp]":
      return "r" + r.source + r.flags;
    default:
      throw new Error(`Unsupported value ${r}`);
  }
  return e.set(r, c), c;
}
__name(t, "t");
function r(e) {
  return t(e, 0);
}
__name(r, "r");
var t = new WeakMap();
function n(n, r, o = r(r)) {
  let i,
    u,
    f = t.get(n);
  f || (t.set(n, f = [[], u = [], i = []]), queueMicrotask(function () {
    let e,
      r = 0;
    function o(t) {
      for (; e = i[r++]; e.r(t));
    }
    __name(o, "o"), t.delete(n), n(u).then(function (t) {
      if (t.length !== i.length) return o(new Error("loader value length mismatch"));
      for (; e = t[r++], r <= t.length; e instanceof Error ? i[r - 1].r(e) : i[r - 1].s(e));
    }, o);
  }));
  let c = f[0].indexOf(o);
  if (~c) return f[2][c].p;
  let l = f[0].push(o) - 1,
    a = f[2][l] = {};
  return f[1][l] = r, a.p = new Promise(function (e, t) {
    a.s = e, a.r = t;
  });
}
__name(n, "n");
var r = new WeakMap();
function n(n, o, i, a = r(i)) {
  if (o || (o = r.get(n)), o || r.set(n, o = new Map()), o.has(a)) return Promise.resolve(o.get(a));
  let c = n(n, i, a);
  return o.set(a, c), c.catch(() => o.delete(a)), c;
}
__name(n, "n");
function o(e, t) {
  return function (r, o) {
    return n(e, t, r, o);
  };
}
__name(o, "o");
var import_brace_expansion = Ns(nne(), 1);
var assertValidPattern = __name(pattern => {
  if (typeof pattern != "string") throw new TypeError("invalid pattern");
  if (pattern.length > 65536) throw new TypeError("pattern is too long");
}, "assertValidPattern");
var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
    "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
    "[:ascii:]": ["\\x00-\\x7f", !1],
    "[:blank:]": ["\\p{Zs}\\t", !0],
    "[:cntrl:]": ["\\p{Cc}", !0],
    "[:digit:]": ["\\p{Nd}", !0],
    "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
    "[:lower:]": ["\\p{Ll}", !0],
    "[:print:]": ["\\p{C}", !0],
    "[:punct:]": ["\\p{P}", !0],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
    "[:upper:]": ["\\p{Lu}", !0],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
    "[:xdigit:]": ["A-Fa-f0-9", !1]
  },
  braceEscape = __name(s => s.replace(/[[\]\\-]/g, "\\$&"), "braceEscape"),
  regexpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regexpEscape"),
  rangesToString = __name(ranges => ranges.join(""), "rangesToString"),
  parseClass = __name((glob, position) => {
    let pos = position;
    if (glob.charAt(pos) !== "[") throw new Error("not in a brace expression");
    let ranges = [],
      negs = [],
      i = pos + 1,
      sawStart = !1,
      uflag = !1,
      escaping = !1,
      negate = !1,
      endPos = pos,
      rangeStart = "";
    WHILE: for (; i < glob.length;) {
      let c = glob.charAt(i);
      if ((c === "!" || c === "^") && i === pos + 1) {
        negate = !0, i++;
        continue;
      }
      if (c === "]" && sawStart && !escaping) {
        endPos = i + 1;
        break;
      }
      if (sawStart = !0, c === "\\" && !escaping) {
        escaping = !0, i++;
        continue;
      }
      if (c === "[" && !escaping) {
        for (let [cls, [unip, u, neg]] of Object.entries(posixClasses)) if (glob.startsWith(cls, i)) {
          if (rangeStart) return ["$.", !1, glob.length - pos, !0];
          i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
          continue WHILE;
        }
      }
      if (escaping = !1, rangeStart) {
        c > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c)) : c === rangeStart && ranges.push(braceEscape(c)), rangeStart = "", i++;
        continue;
      }
      if (glob.startsWith("-]", i + 1)) {
        ranges.push(braceEscape(c + "-")), i += 2;
        continue;
      }
      if (glob.startsWith("-", i + 1)) {
        rangeStart = c, i += 2;
        continue;
      }
      ranges.push(braceEscape(c)), i++;
    }
    if (endPos < i) return ["", !1, 0, !1];
    if (!ranges.length && !negs.length) return ["$.", !1, glob.length - pos, !0];
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      let r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), !1, endPos - pos, !1];
    }
    let sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]",
      snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos, !0];
  }, "parseClass");
var unescape = __name((s, {
  windowsPathsNoEscape = !1
} = {}) => windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1"), "unescape");
var types = new Set(["!", "?", "+", "*", "@"]),
  isExtglobType = __name(c => types.has(c), "isExtglobType"),
  startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))",
  startNoDot = "(?!\\.)",
  addPatternStart = new Set(["[", "."]),
  justDots = new Set(["..", "."]),
  reSpecials = new Set("().*{}+?[]^$\\!"),
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  qmark = "[^/]",
  star = qmark + "*?",
  starNoEmpty = qmark + "+?",
  AST = class _AST {
    static {
      __name(this, "AST");
    }
    type;
    ##root;
    ##hasMagic;
    ##uflag = !1;
    ##parts = [];
    ##parent;
    ##parentIndex;
    ##negs;
    ##filledNegs = !1;
    ##options;
    ##toString;
    ##emptyExt = !1;
    constructor(type, parent, options = {}) {
      this.type = type, type && (this.##hasMagic = !0), this.##parent = parent, this.##root = this.##parent ? this.##parent.##root : this, this.##options = this.##root === this ? options : this.##root.##options, this.##negs = this.##root === this ? [] : this.##root.##negs, type === "!" && !this.##root.##filledNegs && this.##negs.push(this), this.##parentIndex = this.##parent ? this.##parent.##parts.length : 0;
    }
    get hasMagic() {
      if (this.##hasMagic !== void 0) return this.##hasMagic;
      for (let p of this.##parts) if (typeof p != "string" && (p.type || p.hasMagic)) return this.##hasMagic = !0;
      return this.##hasMagic;
    }
    toString() {
      return this.##toString !== void 0 ? this.##toString : this.type ? this.##toString = this.type + "(" + this.##parts.map(p => String(p)).join("|") + ")" : this.##toString = this.##parts.map(p => String(p)).join("");
    }
    ##fillNegs() {
      if (this !== this.##root) throw new Error("should only call on root");
      if (this.##filledNegs) return this;
      this.toString(), this.##filledNegs = !0;
      let n;
      for (; n = this.##negs.pop();) {
        if (n.type !== "!") continue;
        let p = n,
          pp = p.##parent;
        for (; pp;) {
          for (let i = p.##parentIndex + 1; !pp.type && i < pp.##parts.length; i++) for (let part of n.##parts) {
            if (typeof part == "string") throw new Error("string part in extglob AST??");
            part.copyIn(pp.##parts[i]);
          }
          p = pp, pp = p.##parent;
        }
      }
      return this;
    }
    push(...parts) {
      for (let p of parts) if (p !== "") {
        if (typeof p != "string" && !(p instanceof _AST && p.##parent === this)) throw new Error("invalid part: " + p);
        this.##parts.push(p);
      }
    }
    toJSON() {
      let ret = this.type === null ? this.##parts.slice().map(p => typeof p == "string" ? p : p.toJSON()) : [this.type, ...this.##parts.map(p => p.toJSON())];
      return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === this.##root || this.##root.##filledNegs && this.##parent?.type === "!") && ret.push({}), ret;
    }
    isStart() {
      if (this.##root === this) return !0;
      if (!this.##parent?.isStart()) return !1;
      if (this.##parentIndex === 0) return !0;
      let p = this.##parent;
      for (let i = 0; i < this.##parentIndex; i++) {
        let pp = p.##parts[i];
        if (!(pp instanceof _AST && pp.type === "!")) return !1;
      }
      return !0;
    }
    isEnd() {
      if (this.##root === this || this.##parent?.type === "!") return !0;
      if (!this.##parent?.isEnd()) return !1;
      if (!this.type) return this.##parent?.isEnd();
      let pl = this.##parent ? this.##parent.##parts.length : 0;
      return this.##parentIndex === pl - 1;
    }
    copyIn(part) {
      typeof part == "string" ? this.push(part) : this.push(part.clone(this));
    }
    clone(parent) {
      let c = new _AST(this.type, parent);
      for (let p of this.##parts) c.copyIn(p);
      return c;
    }
    static ##parseAST(str, ast, pos, opt) {
      let escaping = !1,
        inBrace = !1,
        braceStart = -1,
        braceNeg = !1;
      if (ast.type === null) {
        let i = pos,
          acc = "";
        for (; i < str.length;) {
          let c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping, acc += c;
            continue;
          }
          if (inBrace) {
            i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
            continue;
          } else if (c === "[") {
            inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
            ast.push(acc), acc = "";
            let ext = new _AST(c, ast);
            i = _AST.##parseAST(str, ext, i, opt), ast.push(ext);
            continue;
          }
          acc += c;
        }
        return ast.push(acc), i;
      }
      let i = pos + 1,
        part = new _AST(null, ast),
        parts = [],
        acc = "";
      for (; i < str.length;) {
        let c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping, acc += c;
          continue;
        }
        if (inBrace) {
          i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
          continue;
        } else if (c === "[") {
          inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc), acc = "";
          let ext = new _AST(c, part);
          part.push(ext), i = _AST.##parseAST(str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc), acc = "", parts.push(part), part = new _AST(null, ast);
          continue;
        }
        if (c === ")") return acc === "" && ast.##parts.length === 0 && (ast.##emptyExt = !0), part.push(acc), acc = "", ast.push(...parts, part), i;
        acc += c;
      }
      return ast.type = null, ast.##hasMagic = void 0, ast.##parts = [str.substring(pos - 1)], i;
    }
    static fromGlob(pattern, options = {}) {
      let ast = new _AST(null, void 0, options);
      return _AST.##parseAST(pattern, ast, 0, options), ast;
    }
    toMMPattern() {
      if (this !== this.##root) return this.##root.toMMPattern();
      let glob = this.toString(),
        [re, body, hasMagic, uflag] = this.toRegExpSource();
      if (!(hasMagic || this.##hasMagic || this.##options.nocase && !this.##options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase())) return body;
      let flags = (this.##options.nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    toRegExpSource(allowDot) {
      let dot = allowDot ?? !!this.##options.dot;
      if (this.##root === this && this.##fillNegs(), !this.type) {
        let noEmpty = this.isStart() && this.isEnd(),
          src = this.##parts.map(p => {
            let [re, _, hasMagic, uflag] = typeof p == "string" ? _AST.##parseGlob(p, this.##hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            return this.##hasMagic = this.##hasMagic || hasMagic, this.##uflag = this.##uflag || uflag, re;
          }).join(""),
          start = "";
        if (this.isStart() && typeof this.##parts[0] == "string" && !(this.##parts.length === 1 && justDots.has(this.##parts[0]))) {
          let aps = addPatternStart,
            needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4)),
            needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
          start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
        }
        let end = "";
        return this.isEnd() && this.##root.##filledNegs && this.##parent?.type === "!" && (end = "(?:$|\\/)"), [start + src + end, unescape(src), this.##hasMagic = !!this.##hasMagic, this.##uflag];
      }
      let repeated = this.type === "*" || this.type === "+",
        start = this.type === "!" ? "(?:(?!(?:" : "(?:",
        body = this.##partsToRegExp(dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        let s = this.toString();
        return this.##parts = [s], this.type = null, this.##hasMagic = void 0, [s, unescape(this.toString()), !1, !1];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.##partsToRegExp(!0);
      bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
      let final = "";
      if (this.type === "!" && this.##emptyExt) final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;else {
        let close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
        final = start + body + close;
      }
      return [final, unescape(body), this.##hasMagic = !!this.##hasMagic, this.##uflag];
    }
    ##partsToRegExp(dot) {
      return this.##parts.map(p => {
        if (typeof p == "string") throw new Error("string type in extglob ast??");
        let [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
        return this.##uflag = this.##uflag || uflag, re;
      }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join("|");
    }
    static ##parseGlob(glob, hasMagic, noEmpty = !1) {
      let escaping = !1,
        re = "",
        uflag = !1;
      for (let i = 0; i < glob.length; i++) {
        let c = glob.charAt(i);
        if (escaping) {
          escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          i === glob.length - 1 ? re += "\\\\" : escaping = !0;
          continue;
        }
        if (c === "[") {
          let [src, needUflag, consumed, magic] = parseClass(glob, i);
          if (consumed) {
            re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          noEmpty && glob === "*" ? re += starNoEmpty : re += star, hasMagic = !0;
          continue;
        }
        if (c === "?") {
          re += qmark, hasMagic = !0;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, unescape(glob), !!hasMagic, uflag];
    }
  };
var escape = __name((s, {
  windowsPathsNoEscape = !1
} = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&"), "escape");
var minimatch = __name((p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p)), "minimatch"),
  starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/,
  starDotExtTest = __name(ext => f => !f.startsWith(".") && f.endsWith(ext), "starDotExtTest"),
  starDotExtTestDot = __name(ext => f => f.endsWith(ext), "starDotExtTestDot"),
  starDotExtTestNocase = __name(ext => (ext = ext.toLowerCase(), f => !f.startsWith(".") && f.toLowerCase().endsWith(ext)), "starDotExtTestNocase"),
  starDotExtTestNocaseDot = __name(ext => (ext = ext.toLowerCase(), f => f.toLowerCase().endsWith(ext)), "starDotExtTestNocaseDot"),
  starDotStarRE = /^\*+\.\*+$/,
  starDotStarTest = __name(f => !f.startsWith(".") && f.includes("."), "starDotStarTest"),
  starDotStarTestDot = __name(f => f !== "." && f !== ".." && f.includes("."), "starDotStarTestDot"),
  dotStarRE = /^\.\*+$/,
  dotStarTest = __name(f => f !== "." && f !== ".." && f.startsWith("."), "dotStarTest"),
  starRE = /^\*+$/,
  starTest = __name(f => f.length !== 0 && !f.startsWith("."), "starTest"),
  starTestDot = __name(f => f.length !== 0 && f !== "." && f !== "..", "starTestDot"),
  qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/,
  qmarksTestNocase = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocase"),
  qmarksTestNocaseDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? (ext = ext.toLowerCase(), f => noext(f) && f.toLowerCase().endsWith(ext)) : noext;
  }, "qmarksTestNocaseDot"),
  qmarksTestDot = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTestDot"),
  qmarksTest = __name(([$0, ext = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return ext ? f => noext(f) && f.endsWith(ext) : noext;
  }, "qmarksTest"),
  qmarksTestNoExt = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && !f.startsWith(".");
  }, "qmarksTestNoExt"),
  qmarksTestNoExtDot = __name(([$0]) => {
    let len = $0.length;
    return f => f.length === len && f !== "." && f !== "..";
  }, "qmarksTestNoExtDot"),
  defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix",
  path = {
    win32: {
      sep: "\\"
    },
    posix: {
      sep: "/"
    }
  },
  sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark = "[^/]",
  star = qmark + "*?",
  twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
  twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?",
  filter = __name((pattern, options = {}) => p => minimatch(p, pattern, options), "filter");
minimatch.filter = filter;
var ext = __name((a, b = {}) => Object.assign({}, a, b), "ext"),
  defaults = __name(def => {
    if (!def || typeof def != "object" || !Object.keys(def).length) return minimatch;
    let orig = minimatch;
    return Object.assign(__name((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), "m"), {
      Minimatch: class extends orig.Minimatch {
        static {
          __name(this, "Minimatch");
        }
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class extends orig.AST {
        static {
          __name(this, "AST");
        }
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: options => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR: GLOBSTAR
    });
  }, "defaults");
minimatch.defaults = defaults;
var braceExpand = __name((pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : (0, fne.expand)(pattern)), "braceExpand");
minimatch.braceExpand = braceExpand;
var makeRe = __name((pattern, options = {}) => new Minimatch(pattern, options).makeRe(), "makeRe");
minimatch.makeRe = makeRe;
var match = __name((list, pattern, options = {}) => {
  let mm = new Minimatch(pattern, options);
  return list = list.filter(f => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
}, "match");
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/,
  regExpEscape = __name(s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "regExpEscape"),
  Minimatch = class {
    static {
      __name(this, "Minimatch");
    }
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) return !0;
      for (let pattern of this.set) for (let part of pattern) if (typeof part != "string") return !0;
      return !1;
    }
    debug(..._) {}
    make() {
      let pattern = this.pattern,
        options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
      let rawGlobParts = this.globSet.map(s => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]),
            isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
          if (isDrive) return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
        }
        return s.map(ss => this.parse(ss));
      });
      if (this.debug(this.pattern, set), this.set = set.filter(s => s.indexOf(!1) === -1), this.isWindows) for (let i = 0; i < this.set.length; i++) {
        let p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) for (let i = 0; i < globParts.length; i++) for (let j = 0; j < globParts[i].length; j++) globParts[i][j] === "**" && (globParts[i][j] = "*");
      let {
        optimizationLevel = 1
      } = this.options;
      return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map(parts => {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
          let i = gs;
          for (; parts[i + 1] === "**";) i++;
          i !== gs && parts.splice(gs, i - gs);
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map(parts => (parts = parts.reduce((set, part) => {
        let prev = set[set.length - 1];
        return part === "**" && prev === "**" ? set : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set.pop(), set) : (set.push(part), set);
      }, []), parts.length === 0 ? [""] : parts));
    }
    levelTwoFileOptimize(parts) {
      Array.isArray(parts) || (parts = this.slashSplit(parts));
      let didSomething = !1;
      do {
        if (didSomething = !1, !this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            let p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
          let p = parts[dd - 1];
          p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = !1;
      do {
        didSomething = !1;
        for (let parts of globParts) {
          let gs = -1;
          for (; (gs = parts.indexOf("**", gs + 1)) !== -1;) {
            let gss = gs;
            for (; parts[gss + 1] === "**";) gss++;
            gss > gs && parts.splice(gs + 1, gss - gs);
            let next = parts[gs + 1],
              p = parts[gs + 2],
              p2 = parts[gs + 3];
            if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") continue;
            didSomething = !0, parts.splice(gs, 1);
            let other = parts.slice(0);
            other[gs] = "**", globParts.push(other), gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              let p = parts[i];
              i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
            }
            parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
          }
          let dd = 0;
          for (; (dd = parts.indexOf("..", dd + 1)) !== -1;) {
            let p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = !0;
              let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) for (let j = i + 1; j < globParts.length; j++) {
        let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        matched && (globParts[i] = matched, globParts[j] = []);
      }
      return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = !1) {
      let ai = 0,
        bi = 0,
        result = [],
        which = "";
      for (; ai < a.length && bi < b.length;) if (a[ai] === b[bi]) result.push(which === "b" ? b[bi] : a[ai]), ai++, bi++;else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) result.push(a[ai]), ai++;else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) result.push(b[bi]), bi++;else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which === "b") return !1;
        which = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which === "a") return !1;
        which = "b", result.push(b[bi]), ai++, bi++;
      } else return !1;
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate) return;
      let pattern = this.pattern,
        negate = !1,
        negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) negate = !negate, negateOffset++;
      negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
    }
    matchOne(file, pattern, partial = !1) {
      let options = this.options;
      if (this.isWindows) {
        let fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]),
          fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]),
          patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]),
          patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]),
          fdi = fileUNC ? 3 : fileDrive ? 0 : void 0,
          pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi == "number" && typeof pdi == "number") {
          let [fd, pd] = [file[fdi], pattern[pdi]];
          fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
        }
      }
      let {
        optimizationLevel = 1
      } = this.options;
      optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, {
        file: file,
        pattern: pattern
      }), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi],
          f = file[fi];
        if (this.debug(pattern, p, f), p === !1) return !1;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi,
            pr = pi + 1;
          if (pr === pl) {
            for (this.debug("** at the end"); fi < fl; fi++) if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return !1;
            return !0;
          }
          for (; fr < fl;) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial)) return this.debug("globstar found match!", fr, fl, swallowee), !0;
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), fr++;
          }
          return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
        }
        let hit;
        if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit) return !1;
      }
      if (fi === fl && pi === pl) return !0;
      if (fi === fl) return partial;
      if (pi === pl) return fi === fl - 1 && file[fi] === "";
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      let options = this.options;
      if (pattern === "**") return GLOBSTAR;
      if (pattern === "") return "";
      let m,
        fastTest = null;
      (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
      let re = AST.fromGlob(pattern, this.options).toMMPattern();
      return fastTest ? Object.assign(re, {
        test: fastTest
      }) : re;
    }
    makeRe() {
      if (this.regexp || this.regexp === !1) return this.regexp;
      let set = this.set;
      if (!set.length) return this.regexp = !1, this.regexp;
      let options = this.options,
        twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot,
        flags = new Set(options.nocase ? ["i"] : []),
        re = set.map(pattern => {
          let pp = pattern.map(p => {
            if (p instanceof RegExp) for (let f of p.flags.split("")) flags.add(f);
            return typeof p == "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
          });
          return pp.forEach((p, i) => {
            let next = pp[i + 1],
              prev = pp[i - 1];
            p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
          }), pp.filter(p => p !== GLOBSTAR).join("/");
        }).join("|"),
        [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch {
        this.regexp = !1;
      }
      return this.regexp;
    }
    slashSplit(p) {
      return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment) return !1;
      if (this.empty) return f === "";
      if (f === "/" && partial) return !0;
      let options = this.options;
      this.isWindows && (f = f.split("\\").join("/"));
      let ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      let set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename) for (let i = ff.length - 2; !filename && i >= 0; i--) filename = ff[i];
      for (let i = 0; i < set.length; i++) {
        let pattern = set[i],
          file = ff;
        if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial)) return options.flipNegate ? !0 : !this.negate;
      }
      return options.flipNegate ? !1 : this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape;
var import_value = Ns(OL());
var assertShape = __name((schema, payload) => {
  if (LL.Value.Check(schema, payload)) return payload;
  let error = `Typebox schema validation failed:
${[...LL.Value.Errors(schema, payload)].map(i => `${i.path} ${i.message}`).join(`
`)}`;
  throw new Error(error);
}, "assertShape");
var TELEMETRY_NAME = "contentExclusion",
  CopilotContentRestrictions = class extends PolicyEvaluator {
    static {
      __name(this, "CopilotContentRestrictions");
    }
    ##context;
    ##evaluateResultCache = new LRUCacheMap(1e4);
    ##ruleLoaderCache = new LRUCacheMap(200);
    constructor(context) {
      super(), this.##context = context;
    }
    async evaluate(uri) {
      let cacheKey = uri.fsPath;
      if (this.##evaluateResultCache.has(cacheKey)) return this.##evaluateResultCache.get(cacheKey);
      try {
        let repo = await extractRepoInfo(this.##context, uri);
        if (!repo || !repo.url) return NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE;
        let fileNameToCompare = uri.fsPath.replace(repo.baseFolder, "");
        var result = await this.evaluateFileFromRepo(fileNameToCompare, repo.url);
      } catch (err) {
        return telemetryException(this.##context, err, `${TELEMETRY_NAME}.evaluate`), BLOCKED_POLICY_ERROR_RESPONSE;
      }
      return this.##evaluateResultCache.set(cacheKey, result), result;
    }
    async evaluateFileFromRepo(fileName, repoUrl) {
      let rules = await this.##rulesForRepo(repoUrl);
      if (!rules) return NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE;
      for (let rule of rules) for (let pattern of rule.paths) if (minimatch(fileName, pattern, {
        nocase: !0,
        matchBase: !0,
        nonegate: !0
      })) return fileBlockedEvaluationResult(rule);
      return NOT_BLOCKED_RESPONSE;
    }
    async refresh() {
      try {
        let existingUrls = [...this.##ruleLoaderCache.keys()];
        this.reset(), await Promise.all(existingUrls.map(url => this.##ruleLoader(url)));
      } catch (err) {
        telemetryException(this.##context, err, `${TELEMETRY_NAME}.refresh`);
      }
    }
    reset() {
      this.##ruleLoaderCache.clear(), this.##evaluateResultCache.clear();
    }
    async ##rulesForRepo(repoUrl) {
      let rules = await this.##ruleLoader(repoUrl.toLowerCase());
      if (rules.length !== 0) return rules;
    }
    ##ruleLoader = o(async urls => {
      let session = await this.##context.get(CopilotTokenManager).getGitHubSession(this.##context);
      if (!session) throw new CopilotAuthError("No token found");
      let endpoint = this.##context.get(NetworkConfiguration).getContentRestrictionsUrl(session),
        url = new URL(endpoint);
      url.searchParams.set("repos", urls.join(","));
      let result = await this.##context.get(Fetcher).fetch(url.href, {
          method: "GET",
          headers: {
            Authorization: `token ${session.token}`
          }
        }),
        data = await result.json();
      if (!result.ok) {
        if (result.status === 404) return Array.from(urls, () => []);
        this.##telemetry("fetch.error", {
          message: data.message
        });
        let error = new Error(`HTTP ${result.status}`);
        throw error.code = `HTTP${result.status}`, error;
      }
      return this.##telemetry("fetch.success"), assertShape(ContentRestrictionsResponseSchema, data).map(r => r.rules);
    }, this.##ruleLoaderCache);
    ##telemetry(event, properties, measurements) {
      telemetry(this.##context, `${TELEMETRY_NAME}.${event}`, TelemetryData.createAndMarkAsIssued(properties, measurements));
    }
  };
function fileBlockedEvaluationResult(rule) {
  return {
    isBlocked: !0,
    reason: "FILE_BLOCKED",
    message: `Your ${rule.source.type.toLowerCase()} '${rule.source.name}' has disabled Copilot for this file`
  };
}
__name(fileBlockedEvaluationResult, "fileBlockedEvaluationResult");
var SourceSchema = eu.Type.Object({
    name: eu.Type.String(),
    type: eu.Type.Union([eu.Type.Literal("Organization"), eu.Type.Literal("Repository")])
  }),
  RuleSchema = eu.Type.Object({
    paths: eu.Type.Array(eu.Type.String()),
    source: SourceSchema
  }),
  RulesSchema = eu.Type.Array(RuleSchema),
  RepoRuleSchema = eu.Type.Object({
    rules: RulesSchema,
    last_updated_at: eu.Type.String()
  }),
  ContentRestrictionsResponseSchema = eu.Type.Array(RepoRuleSchema);
var nodePath = Ns(require("path"));
var CopilotRepositoryControl = class extends PolicyEvaluator {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.repoUriToPolicyMap = new Map();
    this.requestStatus = {
      status: "initial"
    };
    this.initialWaitMs = 30 * 1e3;
    this.maxRetryCount = 3;
  }
  static {
    __name(this, "CopilotRepositoryControl");
  }
  async refresh() {
    try {
      this.reset(), this.requestStatus.status !== "retrying" && (this.requestStatus = {
        status: "initial"
      }, await this.fetchControlData());
    } catch (err) {
      telemetryException(this.ctx, err, "repositoryControl.refresh");
    }
  }
  reset() {
    this.repoUriToPolicyMap.clear();
  }
  async fetchControlData() {
    if (this.requestStatus.status === "retrying" || this.requestStatus.status === "maxRetries") return "POLICY_NOT_AVAILABLE";
    if (this.requestStatus.status === "cached") return this.requestStatus.data;
    this.requestStatus.status !== "fetching" && (this.requestStatus = {
      status: "fetching",
      data: this._fetchControlData()
    });
    let data = await this.requestStatus.data;
    return data || "POLICY_NOT_AVAILABLE";
  }
  async _fetchControlData() {
    if (this.requestStatus.status === "retrying") {
      let _waitMs = this.requestStatus.waitMs;
      await new Promise(resolve => setTimeout(resolve, _waitMs));
    }
    try {
      let githubToken = await this.ctx.get(CopilotTokenManager).getGitHubToken(this.ctx),
        editorSession = this.ctx.get(EditorSession),
        editorInfo = this.ctx.get(EditorAndPluginInfo),
        telemetryConfig = this.ctx.get(TelemetryUserConfig);
      if (!githubToken) throw new CopilotAuthError("No github token found");
      let fetcher = this.ctx.get(Fetcher),
        headers = {
          trackingid: `${telemetryConfig.trackingId}`,
          githubtoken: `${githubToken}`,
          machineid: `${editorSession.machineId}`,
          sessionid: `${editorSession.sessionId}`,
          extname: `${editorInfo.getEditorPluginInfo().name}`,
          extversion: `${editorInfo.getEditorPluginInfo().version}`
        },
        response = await fetcher.fetch(POLICY_ENDPOINT, {
          headers: headers,
          method: "GET"
        });
      if (response.ok) {
        let content = await response.json(),
          lowercaseConfig = {};
        for (let key in content.config) lowercaseConfig[key.toLowerCase()] = content.config[key];
        return content.config = lowercaseConfig, logger.info(this.ctx, "repositoryControl.fetch", "success", Object.keys(content.config).length + " repos"), telemetry(this.ctx, "repositoryControl.fetch.success"), this.requestStatus = {
          status: "cached",
          data: content
        }, content;
      }
      throw new Error(`API returned ${response.status}`);
    } catch (err) {
      telemetry(this.ctx, "repositoryControl.fetch.error"), telemetryException(this.ctx, err, "repositoryControl.fetch");
      let _retryCount = this.requestStatus.status === "retrying" ? this.requestStatus.retryCount + 1 : 0,
        _waitMs = this.requestStatus.status === "retrying" ? this.requestStatus.waitMs * 2 : this.initialWaitMs;
      if (_retryCount >= this.maxRetryCount) {
        telemetry(this.ctx, "repositoryControl.fetch.maxRetries"), this.requestStatus = {
          status: "maxRetries"
        };
        return;
      }
      this.requestStatus = {
        status: "retrying",
        retryCount: _retryCount,
        waitMs: _waitMs
      }, this._fetchControlData();
    }
  }
  async evaluate(uri, fileContent) {
    try {
      let policy = await this.getRepositoryPolicy(uri);
      return policy === "POLICY_NOT_AVAILABLE" ? BLOCKED_POLICY_ERROR_RESPONSE : policy === "NO_MATCHING_POLICY" ? NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE : {
        ...(await this._evaluate(uri, fileContent, policy)),
        providerRepoKey: policy.providerRepoKey
      };
    } catch (err) {
      return telemetryException(this.ctx, err, "repositoryControl.evaluate"), BLOCKED_POLICY_ERROR_RESPONSE;
    }
  }
  async _evaluate(uri, fileContent, policy) {
    if (policy?.blocked) return BLOCKED_REPO_RESPONSE;
    if (policy?.rule && policy.rule.fileContent && fileContent) {
      let mustInclude = policy.rule.fileContent.includes;
      if (fileContent && mustInclude && mustInclude.length > 0 && !new RegExp(mustInclude.join("|"), "i").test(fileContent)) return BLOCKED_FILE_RESPONSE;
      let mustExclude = policy.rule.fileContent.excludes;
      if (fileContent && mustExclude && mustExclude.length > 0 && new RegExp(mustExclude.join("|"), "i").test(fileContent)) return BLOCKED_FILE_RESPONSE;
    }
    return NOT_BLOCKED_RESPONSE;
  }
  async fetchRepositoryPolicy(providerRepoKey) {
    let data = await this.fetchControlData();
    if (data === "POLICY_NOT_AVAILABLE") return "POLICY_NOT_AVAILABLE";
    let config = data.config[providerRepoKey];
    if (!config) return "NO_MATCHING_POLICY";
    let result = {
      providerRepoKey: providerRepoKey,
      blocked: config.blocked
    };
    return config.ruleId && (result.rule = data.rule[config.ruleId]), result;
  }
  async getRepositoryPolicy(uri) {
    let cachedPolicy = this.repoUriToPolicyMap.get(uri.fsPath);
    if (cachedPolicy) return cachedPolicy;
    let matchingKey = getFilePathChunks(uri.fsPath).find(chunk => this.repoUriToPolicyMap.has(chunk));
    if (matchingKey) return this.repoUriToPolicyMap.get(matchingKey) ?? "NO_MATCHING_POLICY";
    let repositoryInfo = await extractRepoInfo(this.ctx, uri);
    if (!repositoryInfo || !repositoryInfo.url) {
      let parentFolder = R_.dirname(uri.fsPath);
      return this.repoUriToPolicyMap.set(parentFolder, "NO_MATCHING_POLICY"), this.repoUriToPolicyMap.set(uri.fsPath, "NO_MATCHING_POLICY"), "NO_MATCHING_POLICY";
    }
    let providerRepoKey = this.getProviderRepoKey(repositoryInfo);
    if (!providerRepoKey) return "NO_MATCHING_POLICY";
    let policy = await this.fetchRepositoryPolicy(providerRepoKey);
    return policy === "POLICY_NOT_AVAILABLE" || (this.repoUriToPolicyMap.set(repositoryInfo.baseFolder, policy), this.repoUriToPolicyMap.set(uri.fsPath, policy)), policy;
  }
  getProviderRepoKey(repoInfo) {
    if (repoInfo !== void 0) {
      if (repoInfo.hostname === "github.com") return `github.com:${repoInfo.owner}/${repoInfo.repo}`.toLowerCase();
      if (repoInfo.hostname.endsWith("azure.com") || repoInfo.hostname.endsWith("visualstudio.com")) return `dev.azure.com:${repoInfo.owner}/${repoInfo.repo}`.toLowerCase();
    }
  }
};
function getFilePathChunks(filepath) {
  let chunks = [],
    currentPath = "";
  for (let part of filepath.split(R_.sep)) currentPath += part + R_.sep, chunks.push(currentPath.slice(0, -1));
  return chunks;
}
__name(getFilePathChunks, "getFilePathChunks");
var logger = new Logger(1, "CopilotContentExclusion");
var CopilotRepositoryControlManager = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.##featureEnabled = !1;
    this.##repositoryControl = null;
    this.##contentRestrictions = new CopilotContentRestrictions(this.ctx);
    this.evaluateResultCache = new Map();
    this.onDidChangeActiveTextEditor = async e => {
      if (!this.##featureEnabled || !e) return;
      let result = await this.ctx.get(TextDocumentManager).getTextDocumentWithValidation(e.document.uri),
        isBlocked = result.status === "invalid",
        reason = result.status === "invalid" ? result.reason : void 0;
      this.updateStatusIcon(isBlocked, reason);
    };
    this.ctx.get(TextDocumentManager).onDidFocusTextDocument(this.onDidChangeActiveTextEditor), this.ctx.get(CopilotTokenNotifier).on("onCopilotToken", (token, tokenEnvelope) => {
      this.##featureEnabled = tokenEnvelope?.copilotignore_enabled ?? !1, tokenEnvelope?.copilotignore_enabled && logger.info(this.ctx, "feature flag is enabled for user"), this.evaluateResultCache.clear(), this.##contentRestrictions.refresh();
      let orgs = token.organization_list ?? [];
      this.##refreshMSFTRepoControl(orgs);
    });
  }
  static {
    __name(this, "CopilotRepositoryControlManager");
  }
  ##featureEnabled;
  ##repositoryControl;
  ##contentRestrictions;
  get enabled() {
    return this.##featureEnabled;
  }
  async evaluate(uri, fileContent, shouldUpdateStatusBar) {
    if (!this.##featureEnabled || uri.scheme !== "file") return {
      isBlocked: !1
    };
    let events = [],
      track = __name(async (key, ev) => {
        let startTimeMs = Date.now(),
          result = await ev.evaluate(uri, fileContent),
          endTimeMs = Date.now();
        return events.push({
          key: key,
          result: result,
          elapsedMs: endTimeMs - startTimeMs
        }), result;
      }, "track"),
      result = (await Promise.all([this.##repositoryControl && track("repositoryControl.evaluate", this.##repositoryControl), track("contentExclusion.evaluate", this.##contentRestrictions)])).find(r => r?.isBlocked) ?? {
        isBlocked: !1
      };
    try {
      for (let event of events) this.##trackEvaluationResult(event.key, uri, event.result, event.elapsedMs);
    } catch (e) {
      console.log("Error tracking telemetry", e);
    }
    return shouldUpdateStatusBar === "UPDATE" && this.updateStatusIcon(result.isBlocked, result.message), result;
  }
  updateStatusIcon(isBlocked, reason) {
    this.##featureEnabled && (isBlocked ? this.ctx.get(StatusReporter).setInactive(reason ?? "Copilot is disabled") : this.ctx.get(StatusReporter).forceNormal());
  }
  ##trackEvaluationResult(key, uri, result, elapsedMs) {
    let cacheKey = uri.path + key;
    if (this.evaluateResultCache.get(cacheKey) === result.reason) return !1;
    if (this.evaluateResultCache.set(cacheKey, result.reason ?? "UNKNOWN"), result.reason === NOT_BLOCKED_NO_MATCHING_POLICY_RESPONSE.reason) return logger.info(this.ctx, key, ` No matching policy for this repository. uri: ${uri.path}`), !1;
    let properties = {
        isBlocked: result.isBlocked ? "true" : "false",
        reason: result.reason ?? "UNKNOWN"
      },
      measurements = {
        elapsedMs: elapsedMs
      };
    return telemetry(this.ctx, key, TelemetryData.createAndMarkAsIssued(properties, measurements)), telemetry(this.ctx, key, TelemetryData.createAndMarkAsIssued({
      ...properties,
      path: uri.path
    }, measurements), 1), logger.info(this.ctx, key, uri.path, JSON.stringify(result)), !0;
  }
  ##refreshMSFTRepoControl(user_orgs) {
    let knownOrg = ["a5db0bcaae94032fe715fb34a5e4bce2", "7184f66dfcee98cb5f08a1cb936d5225"].find(org => user_orgs.includes(org));
    this.##featureEnabled && knownOrg ? (this.##repositoryControl ||= new CopilotRepositoryControl(this.ctx), this.##repositoryControl.refresh()) : this.##repositoryControl = null;
  }
  set __repositoryControl(repoControl) {
    this.##repositoryControl = repoControl;
  }
  get __repositoryControl() {
    return this.##repositoryControl;
  }
  set __contentRestrictions(contentRestrictions) {
    this.##contentRestrictions = contentRestrictions;
  }
  get __contentRestrictions() {
    return this.##contentRestrictions;
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_crypto = require("crypto");
function editDistance(haystack, needle, compare = (h, n) => h === n ? 0 : 1) {
  if (needle.length === 0 || haystack.length === 0) return {
    distance: needle.length,
    startOffset: 0,
    endOffset: 0
  };
  let curRow = new Array(needle.length + 1).fill(0),
    curStart = new Array(needle.length + 1).fill(0),
    prevRow = new Array(haystack.length + 1).fill(0),
    prevStart = new Array(haystack.length + 1).fill(0),
    c = needle[0];
  for (let i = 0; i < haystack.length + 1; i++) i === 0 ? curRow[i] = 1 : curRow[i] = compare(haystack[i - 1], c, i - 1, 0), curStart[i] = i > 0 ? i - 1 : 0;
  for (let j = 1; j < needle.length; j++) {
    let swap = prevRow;
    prevRow = curRow, curRow = swap, swap = prevStart, prevStart = curStart, curStart = swap, c = needle[j], curRow[0] = j + 1;
    for (let i = 1; i < haystack.length + 1; i++) {
      let inserted = 1 + prevRow[i],
        deleted = 1 + curRow[i - 1],
        substituted = compare(haystack[i - 1], c, i - 1, j) + prevRow[i - 1];
      curRow[i] = Math.min(deleted, inserted, substituted), curRow[i] === substituted ? curStart[i] = prevStart[i - 1] : curRow[i] === inserted ? curStart[i] = prevStart[i] : curStart[i] = curStart[i - 1];
    }
  }
  let best = 0;
  for (let i = 0; i < haystack.length + 1; i++) curRow[i] < curRow[best] && (best = i);
  return {
    distance: curRow[best],
    startOffset: curStart[best],
    endOffset: best
  };
}
__name(editDistance, "editDistance");
function emptyLexDictionary() {
  return new Map();
}
__name(emptyLexDictionary, "emptyLexDictionary");
function reverseLexDictionary(d) {
  let lookup = new Array(d.size);
  for (let [lexeme, idx] of d) lookup[idx] = lexeme;
  return lookup;
}
__name(reverseLexDictionary, "reverseLexDictionary");
function* lexGeneratorWords(s) {
  let buffer = "",
    State;
  (c => (State[c.Word = 0] = "Word", State[c.Space = 1] = "Space", State[c.Other = 2] = "Other"))(State ||= {});
  let state = 0;
  for (let c of s) {
    let newState;
    /(\p{L}|\p{Nd}|_)/u.test(c) ? newState = 0 : c === " " ? newState = 1 : newState = 2, newState === state && newState !== 2 ? buffer += c : (buffer.length > 0 && (yield buffer), buffer = c, state = newState);
  }
  buffer.length > 0 && (yield buffer);
}
__name(lexGeneratorWords, "lexGeneratorWords");
function lexicalAnalyzer(s, d, lexGenerator, lexFilter) {
  let lexed = [],
    offset = 0;
  for (let lexeme of lexGenerator(s)) lexFilter(lexeme) && (d.has(lexeme) || d.set(lexeme, d.size), lexed.push([d.get(lexeme), offset])), offset += lexeme.length;
  return [lexed, d];
}
__name(lexicalAnalyzer, "lexicalAnalyzer");
function notSingleSpace(s) {
  return s !== " ";
}
__name(notSingleSpace, "notSingleSpace");
function lexEditDistance(haystack, needle, lexGenerator = lexGeneratorWords) {
  let [haystackLexed, d] = lexicalAnalyzer(haystack, emptyLexDictionary(), lexGenerator, notSingleSpace),
    [needleLexed, dBoth] = lexicalAnalyzer(needle, d, lexGenerator, notSingleSpace);
  if (needleLexed.length === 0 || haystackLexed.length === 0) return {
    lexDistance: needleLexed.length,
    startOffset: 0,
    endOffset: 0,
    haystackLexLength: haystackLexed.length,
    needleLexLength: needleLexed.length
  };
  let lookupId = reverseLexDictionary(dBoth),
    needleLexedLength = needleLexed.length,
    needleFirst = lookupId[needleLexed[0][0]],
    needleLast = lookupId[needleLexed[needleLexedLength - 1][0]];
  function compare(hLexId, nLexId, hIndex, nIndex) {
    if (nIndex === 0 || nIndex === needleLexedLength - 1) {
      let haystackLexeme = lookupId[haystackLexed[hIndex][0]];
      return nIndex == 0 && haystackLexeme.endsWith(needleFirst) || nIndex == needleLexedLength - 1 && haystackLexeme.startsWith(needleLast) ? 0 : 1;
    } else return hLexId === nLexId ? 0 : 1;
  }
  __name(compare, "compare");
  let alignment = editDistance(haystackLexed.map(x => x[0]), needleLexed.map(x => x[0]), compare),
    startOffset = haystackLexed[alignment.startOffset][1],
    endOffset = alignment.endOffset < haystackLexed.length ? haystackLexed[alignment.endOffset][1] : haystack.length;
  return endOffset > 0 && haystack[endOffset - 1] === " " && --endOffset, {
    lexDistance: alignment.distance,
    startOffset: startOffset,
    endOffset: endOffset,
    haystackLexLength: haystackLexed.length,
    needleLexLength: needleLexed.length
  };
}
__name(lexEditDistance, "lexEditDistance");
var equal = Vne(),
  logger = new Logger(0, "retrieval");
function snippetFromRetrievalResult(result) {
  return {
    snippet: result.text.before + result.text.snippet + result.text.after,
    score: result.distance,
    startLine: result.line_info.before_start_line,
    endLine: result.line_info.after_end_line,
    relativePath: result.file,
    restrictedTelemetry: {
      corpusId: result.corpus_config.corpus_id,
      repoNwo: result.corpus_config.repo_nwo,
      repoSha: result.corpus_config.repo_sha,
      indexTimestamp: result.corpus_config.index_timestamp
    }
  };
}
__name(snippetFromRetrievalResult, "snippetFromRetrievalResult");
function buildSnippetMatcher(matcherName, matcherThreshold) {
  switch (matcherName) {
    case "exact":
      return exactSnippetMatcher;
    case "editDistanceRelative":
      if (matcherThreshold === void 0 || matcherThreshold < 0 || matcherThreshold > 100) throw new Error("Invalid threshold for editDistanceRelative matcher");
      return editDistanceSnippetMatcher(matcherThreshold / 100, "relative");
    case "editDistanceAbsolute":
      if (matcherThreshold === void 0 || matcherThreshold < 0) throw new Error("Invalid threshold for editDistanceAbsolute matcher");
      return editDistanceSnippetMatcher(matcherThreshold, "absolute");
    case "lineBasedRelative":
      if (matcherThreshold === void 0 || matcherThreshold < 0 || matcherThreshold > 100) throw new Error("Invalid threshold for lineBasedRelative matcher");
      return lineBasedSnippetMatcher(matcherThreshold / 100, "relative", 100);
    case "lineBasedAbsolute":
      if (matcherThreshold === void 0 || matcherThreshold < 0) throw new Error("Invalid threshold for lineBasedAbsolute matcher");
      return lineBasedSnippetMatcher(matcherThreshold, "absolute", 100);
    default:
      return exactSnippetMatcher;
  }
}
__name(buildSnippetMatcher, "buildSnippetMatcher");
function exactSnippetMatcher(queryKey, cacheKey) {
  return queryKey.querySnippet === cacheKey.querySnippet;
}
__name(exactSnippetMatcher, "exactSnippetMatcher");
function breakUpLongLines(text, maxLineCharLength) {
  let lines = new Set();
  for (let line of text.split(`
`)) {
    if (line.length <= maxLineCharLength) {
      lines.add(line);
      continue;
    }
    let i = 0;
    for (; i < line.length;) lines.add(line.substring(i, i + maxLineCharLength)), i += maxLineCharLength;
  }
  return lines;
}
__name(breakUpLongLines, "breakUpLongLines");
function lineBasedSnippetMatcher(threshold, thresholdType, maxLineCharLength) {
  return (queryKey, cacheKey) => {
    let queryLines = breakUpLongLines(queryKey.querySnippet, maxLineCharLength),
      cacheLines = breakUpLongLines(cacheKey.querySnippet, maxLineCharLength),
      intersection = new Set([...queryLines].filter(line => cacheLines.has(line)));
    return thresholdType === "relative" ? 1 - intersection.size / (queryLines.size + cacheLines.size - intersection.size) <= threshold : Math.max(queryLines.size, cacheLines.size) - intersection.size <= threshold;
  };
}
__name(lineBasedSnippetMatcher, "lineBasedSnippetMatcher");
function editDistanceSnippetMatcher(threshold, thresholdType) {
  return (queryKey, cacheKey) => {
    let res = editDistance(queryKey.querySnippet, cacheKey.querySnippet);
    return thresholdType === "relative" ? res.distance <= threshold * Math.max(queryKey.querySnippet.length, cacheKey.querySnippet.length) : res.distance <= threshold;
  };
}
__name(editDistanceSnippetMatcher, "editDistanceSnippetMatcher");
function getRetrievalContext(docInfo, options) {
  let contextInfo = (0, z5.getCursorContext)(docInfo, options);
  return {
    querySnippet: contextInfo.context,
    offset: docInfo.offset,
    tokenLength: contextInfo.tokenLength,
    lineCount: contextInfo.lineCount
  };
}
__name(getRetrievalContext, "getRetrievalContext");
var RetrievalCache = class {
  constructor(matcher, maxUriCacheSize) {
    this.uriToCache = new Map();
    this.matcher = matcher, this.maxUriCacheSize = maxUriCacheSize;
  }
  static {
    __name(this, "RetrievalCache");
  }
  hashContext(context) {
    return (0, Yne.createHash)("sha1").update(context.querySnippet).digest("hex");
  }
  get(uri, queryContext) {
    let uriCache = this.uriToCache.get(uri);
    if (uriCache !== void 0) for (let hash of uriCache.keys()) {
      let {
        context: context,
        retrievalId: retrievalId,
        snippets: snippets
      } = uriCache.get(hash);
      if (this.matcher(queryContext, context)) return {
        retrievalId: retrievalId,
        snippets: snippets
      };
    }
  }
  put(uri, retrievalId, retrievalContext, snippets) {
    let uriCache = this.uriToCache.get(uri);
    uriCache === void 0 && (uriCache = new LRUCacheMap(this.maxUriCacheSize), this.uriToCache.set(uri, uriCache)), uriCache.set(this.hashContext(retrievalContext), {
      context: retrievalContext,
      retrievalId: retrievalId,
      snippets: snippets
    });
  }
};
function lookupCache(ctx, retrievalCache, docInfo, retrievalContext, telemetryData) {
  let cacheLookupStart = Date.now(),
    cacheHit = retrievalCache.get(docInfo.uri, retrievalContext),
    cacheLookupElapsed = Date.now() - cacheLookupStart;
  return telemetrizeCacheLookup(ctx, cacheHit !== void 0, cacheLookupElapsed, telemetryData), cacheHit;
}
__name(lookupCache, "lookupCache");
function telemetrizeCacheLookup(ctx, cacheHit, cacheLookupElapsed, telemetryData) {
  telemetry(ctx, "retrieval.cacheLookup", telemetryData.extendedBy({
    cacheHit: cacheHit ? "true" : "false"
  }, {
    cacheLookupElapsed: cacheLookupElapsed
  }), 0);
}
__name(telemetrizeCacheLookup, "telemetrizeCacheLookup");
function telemetrizeTooShortContext(ctx, docInfo, retrievalContext, telemetryData) {
  let commonMeasurements = {
    retrievalContextTokens: retrievalContext.tokenLength,
    retrievalLineCount: retrievalContext.lineCount,
    cursorPos: docInfo.offset
  };
  telemetry(ctx, "retrieval.tooShortContext", telemetryData.extendedBy({}, commonMeasurements), 0), telemetry(ctx, "retrieval.tooShortContext", telemetryData.extendedBy({
    file: docInfo.uri,
    retrievalContext: retrievalContext.querySnippet
  }, commonMeasurements), 1);
}
__name(telemetrizeTooShortContext, "telemetrizeTooShortContext");
function telemetrizePostRetrievalRequest(ctx, docInfo, retrievalId, retrievalContext, retrievalOptions, telemetryData) {
  let commonMeasurements = {
    retrievalContextTokens: retrievalContext.tokenLength,
    retrievalLineCount: retrievalContext.lineCount,
    cursorPos: docInfo.offset
  };
  telemetry(ctx, "retrieval.issued", telemetryData.extendedBy({
    retrievalId: retrievalId
  }, commonMeasurements), 0), telemetry(ctx, "retrieval.issued", telemetryData.extendedBy({
    retrievalId: retrievalId,
    file: docInfo.uri,
    retrievalContext: retrievalContext.querySnippet
  }, commonMeasurements), 1);
}
__name(telemetrizePostRetrievalRequest, "telemetrizePostRetrievalRequest");
function telemetrizePostRetrievalResponse(ctx, retrievalId, response, telemetryData) {
  telemetry(ctx, "retrieval.response", telemetryData.extendedBy({
    retrievalId: retrievalId
  }), 0);
}
__name(telemetrizePostRetrievalResponse, "telemetrizePostRetrievalResponse");
function telemetrizePostRetrievalRequestError(ctx, retrievalId, error, telemetryData) {
  telemetry(ctx, "retrieval.error", telemetryData.extendedBy({
    retrievalId: retrievalId,
    error: JSON.stringify(error) ?? "unknown"
  }), 0);
}
__name(telemetrizePostRetrievalRequestError, "telemetrizePostRetrievalRequestError");
function telemetrizeProcessRetrievalResponse(ctx, retrievalId, body, snippets, telemetryData) {
  let commonMeasurements = {
    numSnippetsFromServer: body?.results?.length || -1,
    numFilteredSnippets: snippets.length
  };
  telemetry(ctx, "retrieval.retrieved", telemetryData.extendedBy({
    retrievalId: retrievalId
  }, {
    ...commonMeasurements,
    elapsedEmbeddingNs: body?.metadata?.elapsed_embedding_ns || -1,
    elapsedKnnNs: body?.metadata?.elapsed_knn_ns || -1,
    elapsedFindSourceNs: body?.metadata?.elapsed_find_source_ns || -1
  }), 0), telemetry(ctx, "retrieval.retrieved", telemetryData.extendedBy({
    retrievalId: retrievalId,
    snippets: JSON.stringify(snippets.map(snippet => {
      let {
        restrictedTelemetry: restrictedTelemetry,
        ...rest
      } = snippet;
      return {
        ...rest,
        ...restrictedTelemetry
      };
    }))
  }, {
    ...commonMeasurements
  }), 1);
}
__name(telemetrizeProcessRetrievalResponse, "telemetrizeProcessRetrievalResponse");
function telemetrizeProcessRetrievalError(ctx, retrievalId, body, error, telemetryData) {
  telemetry(ctx, "retrieval.errorProcess", telemetryData.extendedBy({
    retrievalId: retrievalId
  }), 0), telemetry(ctx, "retrieval.errorProcess", telemetryData.extendedBy({
    retrievalId: retrievalId,
    body: JSON.stringify(body) ?? "unknown",
    error: JSON.stringify(error) ?? "unknown"
  }), 1);
}
__name(telemetrizeProcessRetrievalError, "telemetrizeProcessRetrievalError");
function telemetrizeQueryRetrievalDebounce(ctx, pendingRetrievalId, telemetryData) {
  telemetry(ctx, "retrieval.debounced", telemetryData.extendedBy({
    pendingRetrievalId: pendingRetrievalId
  }), 0);
}
__name(telemetrizeQueryRetrievalDebounce, "telemetrizeQueryRetrievalDebounce");
function telemetrizeQueryRetrievalFromCache(ctx, cachedRetrievalId, cachedSnippets, telemetryData) {
  telemetry(ctx, "retrieval.cacheHit", telemetryData.extendedBy({
    cachedRetrievalId: cachedRetrievalId
  }, {
    numSnippetsReturned: cachedSnippets.length
  }), 0);
}
__name(telemetrizeQueryRetrievalFromCache, "telemetrizeQueryRetrievalFromCache");
var documentRequestStates = new Map();
function retrievalRequestUrl(repoNwo, serverRouteImpl) {
  return OPENAI_PROXY_HOST + `/v0/retrieval?repo=${repoNwo}&impl=${serverRouteImpl}`;
}
__name(retrievalRequestUrl, "retrievalRequestUrl");
function filterQuerySnippets(docInfo) {
  return snippet => snippet.relativePath === void 0 ? !0 : !(docInfo.uri.endsWith(snippet.relativePath) || snippet.relativePath.endsWith(docInfo.uri));
}
__name(filterQuerySnippets, "filterQuerySnippets");
async function postRetrievalRequest(ctx, docInfo, retrievalContext, retrievalOptions, telemetryData) {
  let retrievalId = v4_default();
  documentRequestStates.set(docInfo.uri, {
    state: "pending",
    retrievalId: retrievalId
  });
  let secretKey = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token;
  telemetrizePostRetrievalRequest(ctx, docInfo, retrievalId, retrievalContext, retrievalOptions, telemetryData), postRequest(ctx, retrievalRequestUrl(retrievalOptions.repoNwo, retrievalOptions.serverRouteImpl), secretKey, void 0, v4_default(), {
    query: retrievalContext.querySnippet,
    options: {
      ...retrievalOptions.server
    }
  }).then(async response => {
    if (logger.info(ctx, `Retrieval request for ${docInfo.uri} finished`), response.status === 200) documentRequestStates.set(docInfo.uri, {
      state: "response",
      retrievalId: retrievalId,
      retrievalContext: retrievalContext,
      response: response,
      retrievalOptions: retrievalOptions
    }), telemetrizePostRetrievalResponse(ctx, retrievalId, response, telemetryData);else throw new Error(`Retrieval request failed with status ${response.status}`);
  }).catch(error => {
    logger.info(ctx, `Retrieval request for ${docInfo.uri} failed. Error: ${error}`), telemetrizePostRetrievalRequestError(ctx, retrievalId, error, telemetryData), documentRequestStates.set(docInfo.uri, {
      state: "idle"
    });
  });
}
__name(postRetrievalRequest, "postRetrievalRequest");
async function processRetrievalResponse(ctx, docInfo, retrievalId, retrievalContext, response, retrievalOptions, telemetryData) {
  if (documentRequestStates.set(docInfo.uri, {
    state: "idle"
  }), !equal(retrievalOptions, currentRetrievalOptions)) return;
  let {
      data: unparsedData,
      impl: impl
    } = await response.json(),
    data = JSON.parse(unparsedData);
  try {
    if (impl !== retrievalOptions.serverRouteImpl) throw new Error(`Wrong retrieval implementation returned from the proxy: expected ${retrievalOptions.serverRouteImpl}, got ${impl}`);
    if (data === null) throw new Error("Retrieval response body is null");
    logger.info(ctx, `Retrieval request for ${docInfo.uri} processed. Got ${data?.results?.length} snippets back`);
    let snippets = data.results.map(snippetFromRetrievalResult).filter(filterQuerySnippets(docInfo));
    logger.info(ctx, `There were ${snippets.length} after filtering`), retrievalCache?.put(docInfo.uri, retrievalId, retrievalContext, snippets.map(snippet => {
      let {
        restrictedTelemetry: restrictedTelemetry,
        ...rest
      } = snippet;
      return rest;
    })), telemetrizeProcessRetrievalResponse(ctx, retrievalId, data, snippets, telemetryData);
  } catch (error) {
    logger.exception(ctx, error, "Error while processing retrieval response"), telemetrizeProcessRetrievalError(ctx, retrievalId, data, error, telemetryData);
  }
}
__name(processRetrievalResponse, "processRetrievalResponse");
var retrievalCache, currentRetrievalOptions;
async function queryRetrievalSnippets(ctx, docInfo, retrievalOptions, telemetryData) {
  if (retrievalCache === void 0 || !equal(currentRetrievalOptions, retrievalOptions)) {
    let matcher = buildSnippetMatcher(retrievalOptions.cache.snippetMatcherName, retrievalOptions.cache.snippetMatcherThreshold);
    currentRetrievalOptions = retrievalOptions, retrievalCache = new RetrievalCache(matcher, retrievalOptions.cache.maxUriCacheSize);
  }
  let requestState = documentRequestStates.get(docInfo.uri) ?? {
    state: "idle"
  };
  if (requestState.state === "pending") return telemetrizeQueryRetrievalDebounce(ctx, requestState.retrievalId, telemetryData), [];
  requestState.state === "response" && (await processRetrievalResponse(ctx, docInfo, requestState.retrievalId, requestState.retrievalContext, requestState.response, requestState.retrievalOptions, telemetryData));
  let retrievalContext = getRetrievalContext(docInfo, retrievalOptions.context);
  if (retrievalContext.lineCount < (retrievalOptions.context.minLineCount ?? 0) || retrievalContext.tokenLength < (retrievalOptions.context.minTokenLength ?? 0)) return telemetrizeTooShortContext(ctx, docInfo, retrievalContext, telemetryData), [];
  let cacheHit = lookupCache(ctx, retrievalCache, docInfo, retrievalContext, telemetryData);
  return cacheHit === void 0 ? (await postRetrievalRequest(ctx, docInfo, retrievalContext, retrievalOptions, telemetryData), []) : (telemetrizeQueryRetrievalFromCache(ctx, cacheHit.retrievalId, cacheHit.snippets, telemetryData), logger.debug(ctx, `Retrieval cache hit for ${docInfo.uri}`), cacheHit.snippets.map(snippet => ({
    provider: z5.SnippetProviderType.Retrieval,
    semantics: z5.SnippetSemantics.Snippet,
    ...snippet
  })));
}
__name(queryRetrievalSnippets, "queryRetrievalSnippets");
async function getRetrievalOptions(ctx, featuresFilterArgs, telemetryData) {
  if (!(await ctx.get(Features).retrievalStrategy(featuresFilterArgs, telemetryData))) return;
  let serverRouteImpl = await ctx.get(Features).retrievalServerRoute(featuresFilterArgs, telemetryData),
    repoNwo;
  return featuresFilterArgs.repoNwo && featuresFilterArgs.repoNwo.length > 0 ? repoNwo = featuresFilterArgs.repoNwo : featuresFilterArgs.dogFood && featuresFilterArgs.dogFood.length > 0 ? repoNwo = featuresFilterArgs.dogFood : repoNwo = "", {
    repoNwo: repoNwo,
    serverRouteImpl: serverRouteImpl,
    context: {
      maxLineCount: 30,
      maxTokenLength: 1e3,
      minLineCount: 8,
      minTokenLength: 30
    },
    server: {
      results: 10,
      language: featuresFilterArgs.fileType,
      range_from: -10,
      range_to: 10,
      max_length: 192
    },
    cache: {
      snippetMatcherName: "lineBasedRelative",
      snippetMatcherThreshold: 40,
      maxUriCacheSize: 5
    }
  };
}
__name(getRetrievalOptions, "getRetrievalOptions");
function defaultHash(...args) {
  return JSON.stringify(args, (_, v) => typeof v == "object" ? v : String(v));
}
__name(defaultHash, "defaultHash");
function memoize(fn, opts = {}) {
  let {
    hash = defaultHash,
    cache = new Map()
  } = opts;
  return function (...args) {
    let id = hash.apply(this, args);
    if (cache.has(id)) return cache.get(id);
    let result = fn.apply(this, args);
    return result instanceof Promise && (result = result.catch(error => {
      throw cache.delete(id), error;
    })), cache.set(id, result), result;
  };
}
__name(memoize, "memoize");
function shortCircuit(fn, shortCircuitMs, shortCircuitReturn) {
  return async function (...args) {
    return await Promise.race([fn.apply(this, args), new Promise(resolve => {
      setTimeout(resolve, shortCircuitMs, shortCircuitReturn);
    })]);
  };
}
__name(shortCircuit, "shortCircuit");
var logger = new Logger(1, "symbol_def"),
  lruCacheSize = 1e3,
  SymbolDefinitionProvider = class {
    static {
      __name(this, "SymbolDefinitionProvider");
    }
  },
  getSymbolDefinition = __name(async function (ctx, symbolName, docInfo, symbolDefinitionProvider) {
    try {
      return await symbolDefinitionProvider.getSymbolDefinition(docInfo);
    } catch (error) {
      return logger.exception(ctx, error, "Error retrieving definitions"), [];
    }
  }, "getSymbolDefinition");
getSymbolDefinition = memoize(getSymbolDefinition, {
  cache: new LRUCacheMap(lruCacheSize),
  hash: (ctx, symbolName, docInfo, symbolDefinitionProvider) => `${docInfo.uri}#${symbolName}`
});
getSymbolDefinition = shortCircuit(getSymbolDefinition, 100, []);
async function getSymbolDefSnippets(ctx, docInfo) {
  let symbolDefinitionProvider = ctx.get(SymbolDefinitionProvider),
    callerFunctions = await promptLibProxy.getCallSites(docInfo);
  if (callerFunctions.length == 0) return [];
  let symbolDefinitionPromises = [];
  for (let callerFunc of callerFunctions) {
    let docInfoSnippet = {
        ...docInfo,
        position: callerFunc.position
      },
      symbolDefPromises = getSymbolDefinition(ctx, callerFunc.name, docInfoSnippet, symbolDefinitionProvider);
    symbolDefinitionPromises.push(symbolDefPromises);
  }
  return (await Promise.all(symbolDefinitionPromises)).flat();
}
__name(getSymbolDefSnippets, "getSymbolDefSnippets");
var MIN_PROMPT_CHARS = 10,
  _contextTooShort = {
    type: "contextTooShort"
  },
  _copilotNotAvailable = {
    type: "copilotNotAvailable"
  };
async function getPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData) {
  let docInfo = {
      uri: uri.toString(),
      source: source,
      offset: offset,
      relativePath: relativePath,
      languageId: languageId
    },
    repoInfo = extractRepoInfoInBackground(ctx, uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    userKind = await getUserKind(ctx),
    dogFood = getDogFood(repoInfo),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: languageId,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    },
    tokenizerName = M0.TokenizerName.cl100k,
    defaultPromptCompletionTokens = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).getTokenValue("8kp") === "1" ? 8192 : 2048,
    maxPromptLength = (await ctx.get(Features).maxPromptCompletionTokens(featuresFilterArgs, defaultPromptCompletionTokens)) - getConfig(ctx, ConfigKey.SolutionLength),
    neighboringTabs = await ctx.get(Features).neighboringTabsOption(featuresFilterArgs),
    neighboringSnippetTypes = await ctx.get(Features).neighboringSnippetTypes(featuresFilterArgs),
    numberOfSnippets = await ctx.get(Features).numberOfSnippets(featuresFilterArgs),
    snippetPercent = await ctx.get(Features).snippetPercent(featuresFilterArgs),
    suffixStartMode = await ctx.get(Features).suffixStartMode(featuresFilterArgs),
    cursorSnippetsPickingStrategy = await ctx.get(Features).cursorSnippetsPickingStrategy(featuresFilterArgs),
    promptOptions = {
      maxPromptLength: maxPromptLength,
      neighboringTabs: neighboringTabs,
      suffixStartMode: suffixStartMode,
      tokenizerName: tokenizerName,
      neighboringSnippetTypes: neighboringSnippetTypes,
      cursorSnippetsPickingStrategy: cursorSnippetsPickingStrategy,
      numberOfSnippets: numberOfSnippets,
      snippetPercent: snippetPercent
    },
    suffixPercent = await ctx.get(Features).suffixPercent(featuresFilterArgs),
    suffixMatchThreshold = await ctx.get(Features).suffixMatchThreshold(featuresFilterArgs),
    fimSuffixLengthThreshold = await ctx.get(Features).fimSuffixLengthThreshold(featuresFilterArgs),
    localImportContextEnabled = await ctx.get(Features).localImportContext(featuresFilterArgs);
  suffixPercent > 0 && (promptOptions = {
    ...promptOptions,
    suffixPercent: suffixPercent,
    suffixMatchThreshold: suffixMatchThreshold,
    fimSuffixLengthThreshold: fimSuffixLengthThreshold,
    localImportContext: localImportContextEnabled
  });
  let fileSystem = ctx.get(M0.FileSystem),
    promptInfo,
    history = new Map();
  for (let key of cursorHistoryManager.lineCursorHistory.keys()) history.set(key, cursorHistoryManager.lineCursorHistory.get(key) ?? new Map());
  let snippets = [];
  telemetryData || (telemetryData = TelemetryData.createAndMarkAsIssued());
  let retrievalOptions = await getRetrievalOptions(ctx, featuresFilterArgs, telemetryData);
  if (retrievalOptions && (snippets = await queryRetrievalSnippets(ctx, docInfo, retrievalOptions, telemetryData)), await ctx.get(Features).symbolDefinitionStrategy(featuresFilterArgs)) {
    let symbolDefSnippets = await getSymbolDefSnippets(ctx, docInfo);
    snippets.push(...symbolDefSnippets);
  }
  let docs = [],
    neighborSource = new Map();
  try {
    let files = await NeighborSource.getNeighborFiles(ctx, uri, featuresFilterArgs);
    docs = files.docs, neighborSource = files.neighborSource;
  } catch (e) {
    telemetryException(ctx, e, "prompt.getPromptForSource.exception");
  }
  try {
    let spContext = {
        currentFile: docInfo,
        neighborFiles: docs,
        options: new M0.PromptOptions(fileSystem, promptOptions),
        lineCursorHistory: history
      },
      snippetProviderResults = await ctx.get(M0.SnippetOrchestrator).getSnippets(spContext),
      orchestratorSnippets = (0, M0.providersSnippets)(snippetProviderResults),
      errors = (0, M0.providersErrors)(snippetProviderResults),
      {
        runtimes: runtimes,
        timeouts: timeouts
      } = (0, M0.providersPerformance)(snippetProviderResults);
    telemetryData.extendWithConfigProperties(ctx), telemetryData.sanitizeKeys(), await telemetryRaw(ctx, "prompt.stat", {
      ...mkBasicResultTelemetry(telemetryData),
      ...(timeouts[M0.SnippetProviderType.NeighboringTabs] && {
        neighborFilesTimeout: "true"
      })
    }, {
      ...(typeof runtimes[M0.SnippetProviderType.NeighboringTabs] == "number" && {
        neighborFilesRuntimeMs: runtimes[M0.SnippetProviderType.NeighboringTabs]
      })
    });
    for (let e of errors) e.error instanceof M0.ProviderTimeoutError || (await telemetryException(ctx, e.error, "getSnippets"));
    snippets.push(...orchestratorSnippets);
  } catch (e) {
    throw await telemetryException(ctx, e, "prompt.orchestrator.getSnippets.exception"), e;
  }
  try {
    promptInfo = await promptLibProxy.getPrompt(fileSystem, docInfo, promptOptions, snippets);
  } catch (e) {
    throw await telemetryException(ctx, e, "prompt.getPromptForSource.exception"), e;
  }
  return {
    neighborSource: neighborSource,
    ...promptInfo
  };
}
__name(getPromptForSource, "getPromptForSource");
function trimLastLine(source) {
  let lines = source.split(`
`),
    lastLine = lines[lines.length - 1],
    extraSpace = lastLine.length - lastLine.trimRight().length,
    promptTrim = source.slice(0, source.length - extraSpace),
    trailingWs = source.slice(promptTrim.length);
  return [lastLine.length == extraSpace ? promptTrim : source, trailingWs];
}
__name(trimLastLine, "trimLastLine");
async function extractPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData) {
  if ((await ctx.get(CopilotRepositoryControlManager).evaluate(uri, source, "UPDATE")).isBlocked) return _copilotNotAvailable;
  let repoInfo = extractRepoInfoInBackground(ctx, uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    userKind = await getUserKind(ctx),
    dogFood = getDogFood(repoInfo),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: languageId,
      retrievalOrg: retrievalOrg,
      customModel: customModel
    },
    suffixPercent = await ctx.get(Features).suffixPercent(featuresFilterArgs),
    fimSuffixLengthThreshold = await ctx.get(Features).fimSuffixLengthThreshold(featuresFilterArgs);
  if ((suffixPercent > 0 ? source.length : offset) < MIN_PROMPT_CHARS) return _contextTooShort;
  let startTime = Date.now(),
    {
      prefix: prefix,
      suffix: suffix,
      prefixLength: prefixLength,
      suffixLength: suffixLength,
      promptChoices: promptChoices,
      promptBackground: promptBackground,
      promptElementRanges: promptElementRanges,
      neighborSource: neighborSource
    } = await getPromptForSource(ctx, source, offset, relativePath, uri, languageId, telemetryData),
    [resPrompt, trailingWs] = trimLastLine(prefix),
    endTime = Date.now();
  return {
    type: "prompt",
    prompt: {
      prefix: resPrompt,
      suffix: suffix,
      prefixTokens: prefixLength,
      suffixTokens: suffixLength,
      isFimEnabled: suffixPercent > 0 && suffix.length > fimSuffixLengthThreshold,
      promptElementRanges: promptElementRanges.ranges
    },
    trailingWs: trailingWs,
    promptChoices: promptChoices,
    computeTimeMs: endTime - startTime,
    promptBackground: promptBackground,
    neighborSource: neighborSource
  };
}
__name(extractPromptForSource, "extractPromptForSource");
async function extractPromptForDocument(ctx, doc, position, telemetryData) {
  let relativePath = await ctx.get(TextDocumentManager).getRelativePath(doc);
  return extractPromptForSource(ctx, doc.getText(), doc.offsetAt(position), relativePath, doc.uri, doc.languageId, telemetryData);
}
__name(extractPromptForDocument, "extractPromptForDocument");
function addNeighboringCellsToPrompt(neighboringCell, activeCellLanguageId) {
  let languageId = neighboringCell.document.languageId,
    text = neighboringCell.document.getText();
  return languageId === activeCellLanguageId ? text : (0, M0.commentBlockAsSingles)(text, activeCellLanguageId);
}
__name(addNeighboringCellsToPrompt, "addNeighboringCellsToPrompt");
async function extractPromptForNotebook(ctx, doc, notebook, position, telemetryData) {
  let activeCell = notebook.getCells().find(cell => cell.document.uri.toString() === doc.uri.toString());
  if (activeCell) {
    let beforeCells = notebook.getCells().filter(cell => cell.index < activeCell.index && considerNeighborFile(activeCell.document.languageId, cell.document.languageId)),
      beforeSource = beforeCells.length > 0 ? beforeCells.map(cell => addNeighboringCellsToPrompt(cell, activeCell.document.languageId)).join(`

`) + `

` : "",
      source = beforeSource + doc.getText(),
      offset = beforeSource.length + doc.offsetAt(position),
      relativePath = await ctx.get(TextDocumentManager).getRelativePath(doc);
    return extractPromptForSource(ctx, source, offset, relativePath, doc.uri, activeCell.document.languageId, telemetryData);
  } else return extractPromptForDocument(ctx, doc, position, telemetryData);
}
__name(extractPromptForNotebook, "extractPromptForNotebook");
function extractPrompt(ctx, doc, position, telemetryData) {
  let notebook = ctx.get(TextDocumentManager).findNotebook(doc);
  return notebook === void 0 ? extractPromptForDocument(ctx, doc, position, telemetryData) : extractPromptForNotebook(ctx, doc, notebook, position, telemetryData);
}
__name(extractPrompt, "extractPrompt");
var ghostTextDisplayInterceptParameter = 2.98410452738298,
  ghostTextDisplayLog1pcompCharLenParameter = -.838732736843507,
  ghostTextDisplayMeanLogProbParameter = 1.50314646255716,
  ghostTextDisplayMeanAlternativeLogProbParameter = -.237798634012662,
  ghostTextDisplayLanguageParameters = {
    python: .314368072478742
  },
  ghostTextDisplayQuantiles = {
    "0.01": .225800751784931,
    "0.02": .290204307767402,
    "0.03": .333153496466045,
    "0.05": .404516749849559,
    "0.1": .513216040545626,
    "0.2": .626904979128674,
    "0.3": .694880719658273,
    "0.4": .743100684947291,
    "0.5": .782524520571946,
    "0.6": .816856186092243,
    "0.7": .84922977716585,
    "0.8": .883694877241999,
    "0.9": .921859050950077,
    "0.95": .944571268106974,
    "0.99": .969535563141733
  };
var restraintLogger = new Logger(1, "restraint"),
  Logit = {
    link: x => Math.exp(x) / (1 + Math.exp(x)),
    unlink: p => Math.log(p / (1 - p))
  };
function linearInterpolation(x0, points) {
  let x_after = Math.min(...Array.from(points.keys()).filter(x => x >= x0)),
    x_before = Math.max(...Array.from(points.keys()).filter(x => x < x0)),
    y_after = points.get(x_after),
    y_before = points.get(x_before);
  return y_before + (y_after - y_before) * (x0 - x_before) / (x_after - x_before);
}
__name(linearInterpolation, "linearInterpolation");
var Regressor = class {
    static {
      __name(this, "Regressor");
    }
    constructor(name, coefficient, transformation) {
      this.name = name, this.coefficient = coefficient, this.transformation = transformation || (x => x);
    }
    contribution(value) {
      return this.coefficient * this.transformation(value);
    }
  },
  LogisticRegression = class {
    constructor(intercept, coefficients, quantiles) {
      this.link = Logit;
      if (this.intercept = intercept, this.coefficients = coefficients, this.logitsToQuantiles = new Map(), this.logitsToQuantiles.set(0, 0), this.logitsToQuantiles.set(1, 1), quantiles) for (let key in quantiles) this.logitsToQuantiles.set(quantiles[key], Number(key));
    }
    static {
      __name(this, "LogisticRegression");
    }
    predict(ctx, values) {
      let sum = this.intercept;
      for (let regressor of this.coefficients) {
        let value = values[regressor.name];
        if (value === void 0) return NaN;
        sum += regressor.contribution(value);
      }
      return this.link.link(sum);
    }
    quantile(ctx, values) {
      let logit = this.predict(ctx, values);
      return linearInterpolation(logit, this.logitsToQuantiles);
    }
  },
  ghostTextRetentionModel = new LogisticRegression(ghostTextDisplayInterceptParameter, [new Regressor("compCharLen", ghostTextDisplayLog1pcompCharLenParameter, x => Math.log(1 + x)), new Regressor("meanLogProb", ghostTextDisplayMeanLogProbParameter), new Regressor("meanAlternativeLogProb", ghostTextDisplayMeanAlternativeLogProbParameter)].concat(Object.entries(ghostTextDisplayLanguageParameters).map(value => new Regressor(value[0], value[1]))), ghostTextDisplayQuantiles);
function ghostTextScoreConfidence(ctx, telemetryData) {
  let values = {
    ...telemetryData.measurements
  };
  return Object.keys(ghostTextDisplayLanguageParameters).forEach(lang => {
    values[lang] = telemetryData.properties["customDimensions.languageId"] == lang ? 1 : 0;
  }), ghostTextRetentionModel.predict(ctx, values);
}
__name(ghostTextScoreConfidence, "ghostTextScoreConfidence");
function ghostTextScoreQuantile(ctx, telemetryData) {
  let values = {
    ...telemetryData.measurements
  };
  return Object.keys(ghostTextDisplayLanguageParameters).forEach(lang => {
    values[lang] = telemetryData.properties["customDimensions.languageId"] == lang ? 1 : 0;
  }), ghostTextRetentionModel.quantile(ctx, values);
}
__name(ghostTextScoreQuantile, "ghostTextScoreQuantile");
var configs = [{
  max_token_sequence_length: 1,
  last_tokens_to_consider: 10
}, {
  max_token_sequence_length: 10,
  last_tokens_to_consider: 30
}, {
  max_token_sequence_length: 20,
  last_tokens_to_consider: 45
}, {
  max_token_sequence_length: 30,
  last_tokens_to_consider: 60
}];
function isRepetitive(tokens) {
  let tokensBackwards = tokens.slice();
  return tokensBackwards.reverse(), isRepeatedPattern(tokensBackwards) || isRepeatedPattern(tokensBackwards.filter(token => token.trim().length > 0));
}
__name(isRepetitive, "isRepetitive");
function isRepeatedPattern(s) {
  let prefix = kmp_prefix_function(s);
  for (let config of configs) {
    if (s.length < config.last_tokens_to_consider) continue;
    if (config.last_tokens_to_consider - 1 - prefix[config.last_tokens_to_consider - 1] <= config.max_token_sequence_length) return !0;
  }
  return !1;
}
__name(isRepeatedPattern, "isRepeatedPattern");
function kmp_prefix_function(s) {
  let pi = Array(s.length).fill(0);
  pi[0] = -1;
  let k = -1;
  for (let q = 1; q < s.length; q++) {
    for (; k >= 0 && s[k + 1] !== s[q];) k = pi[k];
    s[k + 1] === s[q] && k++, pi[q] = k;
  }
  return pi;
}
__name(kmp_prefix_function, "kmp_prefix_function");
function maybeSnipCompletion(ctx, doc, position, completion, isMiddleOfTheLineSuggestion) {
  let blockCloseToken = "}";
  try {
    blockCloseToken = promptLibProxy.getBlockCloseToken(doc.languageId) ?? "}";
  } catch {}
  if (getHiddenConfig(ctx, ConfigKey.DebugTruncationKiwi, {
    default: !0
  })) return maybeSnipCompletionImpl({
    getLineText: lineIdx => doc.lineAt(lineIdx).text,
    getLineCount: () => doc.lineCount
  }, position, completion, blockCloseToken);
  {
    if (completion == "") return completion;
    let nextLineStart = completion.length;
    do {
      let thisLineStart = completion.lastIndexOf(`
`, nextLineStart - 2) + 1,
        line = completion.substring(thisLineStart, nextLineStart);
      if (line.trim() === blockCloseToken) {
        for (let i = position.line; i < doc.lineCount; i++) {
          let lineText = doc.lineAt(i).text;
          if (i === position.line && (lineText = lineText.substr(position.character)), lineText.startsWith(line.trimRight())) return completion.substring(0, Math.max(0, isMiddleOfTheLineSuggestion ? thisLineStart : thisLineStart - 1));
          if (lineText.trim() !== "") break;
        }
        break;
      }
      if (nextLineStart === thisLineStart) {
        if (shouldFailForDebugPurposes(ctx)) throw Error(`Aborting: maybeSnipCompletion would have looped on completion: ${completion}`);
        break;
      }
      nextLineStart = thisLineStart;
    } while (nextLineStart > 1);
    return completion;
  }
}
__name(maybeSnipCompletion, "maybeSnipCompletion");
function maybeSnipCompletionImpl(doc, position, completion, blockCloseToken) {
  let completionLinesInfo = splitByNewLine(completion),
    completionLines = completionLinesInfo.lines;
  if (completionLines.length === 1) return completion;
  for (let completionLineStartIdx = 1; completionLineStartIdx < completionLines.length; completionLineStartIdx++) {
    let matched = !0,
      docSkippedEmptyLineCount = 0,
      completionSkippedEmptyLineCount = 0;
    for (let offset = 0; offset + completionLineStartIdx + completionSkippedEmptyLineCount < completionLines.length; offset++) {
      let docLine;
      do {
        let docLineIdx = position.line + 1 + offset + docSkippedEmptyLineCount;
        if (docLine = docLineIdx >= doc.getLineCount() ? void 0 : doc.getLineText(docLineIdx), docLine !== void 0 && docLine.trim() === "") docSkippedEmptyLineCount++;else break;
      } while (!0);
      let completionLineIdx, completionLine;
      do if (completionLineIdx = completionLineStartIdx + offset + completionSkippedEmptyLineCount, completionLine = completionLineIdx >= completionLines.length ? void 0 : completionLines[completionLineIdx], completionLine !== void 0 && completionLine.trim() === "") completionSkippedEmptyLineCount++;else break; while (!0);
      let isLastCompletionLine = completionLineIdx === completionLines.length - 1;
      if (!completionLine || !(docLine && completionLine.trim() === blockCloseToken && (isLastCompletionLine ? docLine.startsWith(completionLine) : docLine === completionLine))) {
        matched = !1;
        break;
      }
    }
    if (matched) return completionLines.slice(0, completionLineStartIdx).join(completionLinesInfo.newLineCharacter);
  }
  return completion;
}
__name(maybeSnipCompletionImpl, "maybeSnipCompletionImpl");
function splitByNewLine(text) {
  let newLineCharacter = text.includes(`\r
`) ? `\r
` : `
`;
  return {
    lines: text.split(newLineCharacter),
    newLineCharacter: newLineCharacter
  };
}
__name(splitByNewLine, "splitByNewLine");
function matchesNextLine(document, position, text) {
  let nextLine = "",
    lineNo = position.line + 1;
  for (; nextLine === "" && lineNo < document.lineCount;) {
    if (nextLine = document.lineAt(lineNo).text.trim(), nextLine === text.trim()) return !0;
    lineNo++;
  }
  return !1;
}
__name(matchesNextLine, "matchesNextLine");
async function postProcessChoice(ctx, insertionCategory, document, position, choice, isMiddleOfTheLineSuggestion, logger, prompt, actualSuffix) {
  if (isRepetitive(choice.tokens)) {
    let telemetryData = TelemetryData.createAndMarkAsIssued();
    telemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, "repetition.detected", telemetryData, 1), logger.info(ctx, "Filtered out repetitive solution");
    return;
  }
  let postProcessedChoice = {
    ...choice
  };
  if (matchesNextLine(document, position, postProcessedChoice.completionText)) {
    let baseTelemetryData = TelemetryData.createAndMarkAsIssued();
    baseTelemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, "completion.alreadyInDocument", baseTelemetryData), telemetry(ctx, "completion.alreadyInDocument", baseTelemetryData.extendedBy({
      completionTextJson: JSON.stringify(postProcessedChoice.completionText)
    }), 1), logger.info(ctx, "Filtered out solution matching next line");
    return;
  }
  return getHiddenConfig(ctx, ConfigKey.DebugTruncationKiwi, {
    default: !0
  }) && (postProcessedChoice.completionText = removeDifferenceOfCachedVsActualPromptSuffix(postProcessedChoice.completionText, actualSuffix, prompt)), postProcessedChoice.completionText = maybeSnipCompletion(ctx, document, position, postProcessedChoice.completionText, isMiddleOfTheLineSuggestion), postProcessedChoice.completionText ? postProcessedChoice : void 0;
}
__name(postProcessChoice, "postProcessChoice");
function removeDifferenceOfCachedVsActualPromptSuffix(completionText, actualSuffix, prompt) {
  actualSuffix = actualSuffix.trim();
  let idxOfCachedSuffixInActualSuffix = actualSuffix.indexOf(prompt.suffix);
  if (idxOfCachedSuffixInActualSuffix <= 0) return completionText;
  let missing = actualSuffix.substring(0, idxOfCachedSuffixInActualSuffix).trim();
  return removeSuffix(completionText, missing);
}
__name(removeDifferenceOfCachedVsActualPromptSuffix, "removeDifferenceOfCachedVsActualPromptSuffix");
function removeSuffix(str, suffix) {
  return str.endsWith(suffix) ? str.substring(0, str.length - suffix.length) : str;
}
__name(removeSuffix, "removeSuffix");
function checkSuffix(document, position, choice) {
  let restOfLine = document.lineAt(position.line).text.substring(position.character);
  if (restOfLine.length > 0) {
    if (choice.completionText.indexOf(restOfLine) !== -1) return !0;
    {
      let lastIndex = 0;
      for (let c of restOfLine) {
        let idx = choice.completionText.indexOf(c, lastIndex + 1);
        if (idx > lastIndex) lastIndex = idx;else {
          lastIndex = -1;
          break;
        }
      }
      return lastIndex !== -1;
    }
  }
  return !1;
}
__name(checkSuffix, "checkSuffix");
async function getDebounceLimit(ctx, telemetryData) {
  let expDebounce;
  if ((await ctx.get(Features).debouncePredict()) && telemetryData.measurements.contextualFilterScore) {
    let acceptProbability = telemetryData.measurements.contextualFilterScore,
      sigmoidMin = 25,
      sigmoidRange = 250,
      sigmoidShift = .3475,
      sigmoidSlope = 7;
    expDebounce = sigmoidMin + sigmoidRange / (1 + Math.pow(acceptProbability / sigmoidShift, sigmoidSlope));
  } else expDebounce = await ctx.get(Features).debounceMs();
  return expDebounce > 0 ? expDebounce : 75;
}
__name(getDebounceLimit, "getDebounceLimit");
function multilineModelPredict(input) {
  let var0;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 427.50000000000006 ? input[9] > 13.500000000000002 ? input[121] > 1e-35 ? var0 = -.3793786744885956 : input[149] > 1e-35 ? var0 = -.34717430705356905 : var0 = -.26126834451035963 : var0 = -.2431318366096852 : input[5] > 888.5000000000001 ? var0 = -.20600463586387135 : var0 = -.2568037008471491 : input[308] > 1e-35 ? var0 = -.2363064824497454 : input[8] > 370.50000000000006 ? var0 = -.37470755210284723 : var0 = -.321978453730494 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var0 = -.26259136509758885 : var0 = -.3096719634039438 : input[4] > 30.500000000000004 ? input[9] > 18.500000000000004 ? var0 = -.34254903852890883 : input[2] > 98.50000000000001 ? var0 = -.41585250791146294 : var0 = -.3673574858887241 : input[9] > 6.500000000000001 ? var0 = -.31688079287876225 : input[31] > 1e-35 ? var0 = -.29110977864003823 : input[308] > 1e-35 ? var0 = -.3201411739040839 : var0 = -.36874023066055506 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var0 = -.41318393149040566 : input[133] > 1e-35 ? var0 = -.3741272613525161 : input[32] > 1e-35 ? var0 = -.4112378041027121 : input[227] > 1e-35 ? var0 = -.37726615155719356 : input[10] > 3.5000000000000004 ? var0 = -.3164502293560397 : var0 = -.2930071546509045 : input[9] > 13.500000000000002 ? var0 = -.277366858539218 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var0 = -.30975610686807187 : input[4] > 1.5000000000000002 ? var0 = -.2549142136728043 : var0 = -.3271325650785176 : input[127] > 1e-35 ? input[0] > 1937.5000000000002 ? var0 = -.2533046188098832 : var0 = -.325520883579 : var0 = -.331628896481776;
  let var1;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? input[9] > 13.500000000000002 ? var1 = .031231253521808708 : var1 = .05380836288014532 : input[5] > 423.00000000000006 ? input[8] > 114.50000000000001 ? var1 = .06751619128429062 : var1 = .09625089153176467 : var1 = .027268163053989804 : input[308] > 1e-35 ? var1 = .060174483556283756 : var1 = -.049062854038919135 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var1 = -.03969241799174589 : var1 = .01086816842550381 : input[31] > 1e-35 ? var1 = -.003284694817583201 : input[9] > 6.500000000000001 ? input[4] > 30.500000000000004 ? var1 = -.04224490699947552 : var1 = -.011834162944360616 : input[308] > 1e-35 ? input[32] > 1e-35 ? var1 = -.13448447971850278 : var1 = -.019569456707046823 : input[19] > 1e-35 ? input[9] > 1.5000000000000002 ? var1 = -.07256260662659254 : input[4] > 60.50000000000001 ? var1 = -.08227503453609311 : var1 = -.020596416747563847 : var1 = -.07396549241564149 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var1 = -.10046536995362734 : input[133] > 1e-35 ? var1 = -.06407649822752297 : input[225] > 1e-35 ? var1 = .08035785003303324 : input[92] > 1e-35 ? var1 = .018901360933204676 : input[20] > 1e-35 ? var1 = .05252546973665552 : input[8] > 2592.5000000000005 ? var1 = -.040543705016462955 : var1 = -.011236043818320725 : input[9] > 17.500000000000004 ? var1 = .025560632674895334 : input[308] > 1e-35 ? input[0] > 1847.5000000000002 ? var1 = .03527165701669741 : var1 = -.0071847350825815035 : input[127] > 1e-35 ? var1 = .024373016379595405 : input[9] > 2.5000000000000004 ? var1 = -.0035090719709448288 : var1 = -.03514829488063766;
  let var2;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? var2 = .03848674861536988 : input[5] > 423.00000000000006 ? input[8] > 114.50000000000001 ? input[9] > 56.50000000000001 ? var2 = -.003764520033319488 : var2 = .06570817919969299 : input[4] > 61.50000000000001 ? var2 = .028346156293069538 : var2 = .0908154644362606 : var2 = .02445594243234816 : input[308] > 1e-35 ? input[8] > 65.50000000000001 ? var2 = .0019305229020073053 : var2 = .09279357295883772 : var2 = -.04458984161917124 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? var2 = .0027405390271277013 : input[4] > 29.500000000000004 ? input[52] > 1e-35 ? var2 = .044727478132905285 : input[115] > 1e-35 ? var2 = .10245804828855934 : input[9] > 17.500000000000004 ? var2 = -.03353173647469207 : input[2] > 98.50000000000001 ? var2 = -.10048106638102179 : var2 = -.05484231104348874 : input[31] > 1e-35 ? var2 = .016807537467116516 : input[9] > 6.500000000000001 ? var2 = -.012113620535295137 : input[4] > 8.500000000000002 ? input[308] > 1e-35 ? var2 = -.01882594250504289 : var2 = -.05585658862796076 : var2 = .04279591277938338 : input[8] > 691.5000000000001 ? input[82] > 1e-35 ? var2 = -.09262278043707878 : input[133] > 1e-35 ? var2 = -.058454257768893625 : input[32] > 1e-35 ? var2 = -.09769348447126434 : input[25] > 1e-35 ? var2 = -.0725430043727677 : input[122] > 1e-35 ? var2 = -.10047841601578077 : var2 = -.00580671054458958 : input[9] > 13.500000000000002 ? var2 = .021399199032818294 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var2 = -.0076376731757173515 : var2 = .03394923033036848 : input[127] > 1e-35 ? var2 = .02070489091204209 : var2 = -.02290162726126496;
  let var3;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[9] > 21.500000000000004 ? var3 = .010230295672324606 : var3 = .038540509248742805 : input[8] > 125.50000000000001 ? input[1] > 49.50000000000001 ? var3 = .03086356292895467 : var3 = .057128750867458604 : input[5] > 888.5000000000001 ? var3 = .07861602941396924 : var3 = .030523262699070908 : input[308] > 1e-35 ? var3 = .048236117667577356 : input[8] > 370.50000000000006 ? var3 = -.05642125069212264 : var3 = -.007232836777168195 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var3 = .03640661467213915 : var3 = -.005889820723907028 : input[31] > 1e-35 ? var3 = -.0009007166998276938 : input[9] > 6.500000000000001 ? var3 = -.022590340093882378 : input[308] > 1e-35 ? input[32] > 1e-35 ? var3 = -.1215445089091064 : var3 = -.01435612266219722 : input[19] > 1e-35 ? input[9] > 1.5000000000000002 ? var3 = -.061555513040777825 : input[4] > 60.50000000000001 ? var3 = -.07053475504569347 : var3 = -.013733369453963092 : var3 = -.06302097189114152 : input[227] > 1e-35 ? var3 = -.05820440333190048 : input[8] > 683.5000000000001 ? input[82] > 1e-35 ? var3 = -.08466979526809346 : input[10] > 24.500000000000004 ? var3 = -.017092159721119944 : input[92] > 1e-35 ? var3 = .03592901452463749 : var3 = -.00359310519524756 : input[5] > 1809.5000000000002 ? input[243] > 1e-35 ? var3 = -.03963116207386097 : input[118] > 1e-35 ? var3 = -.09483996283536394 : input[217] > 1e-35 ? var3 = -.03394542089519989 : input[242] > 1e-35 ? var3 = -.07985899422287938 : var3 = .019706602160656964 : input[9] > 12.500000000000002 ? var3 = .014072998937735146 : var3 = -.021156294523894684;
  let var4;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[9] > 21.500000000000004 ? var4 = .009197756540516563 : var4 = .03458896869535166 : input[5] > 5082.500000000001 ? var4 = .08265545468131008 : input[131] > 1e-35 ? var4 = .0740738432473315 : var4 = .045159136632942756 : input[8] > 319.50000000000006 ? var4 = -.04653401534465376 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var4 = -.011400839766681709 : var4 = .11149800187510031 : var4 = -.08683250977599462 : var4 = .08355310136724753 : input[4] > 23.500000000000004 ? input[23] > 1e-35 ? input[131] > 1e-35 ? var4 = .040389083779932555 : var4 = -.009887614274108602 : input[52] > 1e-35 ? var4 = .03705353499757327 : input[9] > 6.500000000000001 ? var4 = -.025401260429257562 : input[2] > 98.50000000000001 ? var4 = -.09237673187534504 : var4 = -.04298556869281803 : input[222] > 1e-35 ? var4 = -.045221965895986184 : input[8] > 691.5000000000001 ? input[133] > 1e-35 ? var4 = -.05435318330148897 : input[128] > 1e-35 ? var4 = -.08672907303184191 : input[227] > 1e-35 ? var4 = -.05568304584186561 : input[122] > 1e-35 ? var4 = -.09623059693538563 : input[225] > 1e-35 ? var4 = .07558331642202279 : input[82] > 1e-35 ? var4 = -.07360566227233566 : var4 = -.005646164647395919 : input[242] > 1e-35 ? var4 = -.08203758341228108 : input[9] > 13.500000000000002 ? var4 = .018726123829696042 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var4 = -.011153942154062704 : var4 = .03132858912391067 : input[127] > 1e-35 ? var4 = .021455228822345174 : input[23] > 1e-35 ? var4 = .01959966745346997 : var4 = -.021764790177579325;
  let var5;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 284.50000000000006 ? input[121] > 1e-35 ? input[18] > 1e-35 ? var5 = .07547602514276922 : var5 = -.08529678832140396 : var5 = .030314822344598043 : input[5] > 888.5000000000001 ? input[4] > 61.50000000000001 ? var5 = .011143589009415464 : var5 = .0654700456802118 : var5 = .021794712646632755 : input[308] > 1e-35 ? var5 = .04231872551095028 : var5 = -.034381999950549455 : input[4] > 23.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var5 = -.03678981254332261 : var5 = .010518160384496255 : input[8] > 825.5000000000001 ? var5 = -.04506534842082387 : input[9] > 38.50000000000001 ? var5 = .01004983052203438 : var5 = -.030580958620701027 : input[39] > 1e-35 ? var5 = -.12802435021505382 : input[8] > 691.5000000000001 ? input[23] > 1e-35 ? input[203] > 1e-35 ? input[4] > 6.500000000000001 ? var5 = .030426957004611704 : var5 = -.0726407693060581 : var5 = .017395521646964375 : input[4] > 7.500000000000001 ? input[0] > 93.50000000000001 ? input[9] > 7.500000000000001 ? var5 = -.008024349629981291 : input[31] > 1e-35 ? var5 = .01296539930850471 : input[308] > 1e-35 ? var5 = -.012855016509024084 : var5 = -.04564527976851505 : var5 = -.15681420504058596 : input[10] > 4.500000000000001 ? input[243] > 1e-35 ? var5 = -.1012064426380198 : var5 = -.0062808850924854194 : var5 = .030706323726162416 : input[9] > 13.500000000000002 ? var5 = .017081636133736405 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? var5 = -.009306613091760644 : input[4] > 1.5000000000000002 ? var5 = .03655523200850989 : var5 = -.02671654212893341 : input[127] > 1e-35 ? var5 = .019261510468604387 : var5 = -.017627818570628936;
  let var6;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 892.5000000000001 ? input[308] > 1e-35 ? var6 = .036100405995889276 : var6 = .011709313297015793 : input[0] > 119.50000000000001 ? input[8] > 125.50000000000001 ? var6 = .03622542297472574 : var6 = .05595579157301536 : var6 = -.02234751038146796 : input[8] > 319.50000000000006 ? var6 = -.040132029478400735 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var6 = -.009306153573847916 : var6 = .10058509567064988 : var6 = -.0785668890966017 : input[9] > 28.500000000000004 ? var6 = -.04781977604130416 : var6 = .09753292614937459 : input[4] > 23.500000000000004 ? input[131] > 1e-35 ? var6 = .02372493254975127 : input[148] > 1e-35 ? var6 = .028103095989516644 : input[4] > 58.50000000000001 ? input[10] > 1e-35 ? var6 = -.05000852203469597 : var6 = .02922366846119705 : input[23] > 1e-35 ? var6 = -.0026335076988151292 : var6 = -.03073993752935585 : input[222] > 1e-35 ? var6 = -.03867374428185713 : input[32] > 1e-35 ? var6 = -.07220729365053084 : input[39] > 1e-35 ? var6 = -.11624524614351733 : input[8] > 691.5000000000001 ? input[133] > 1e-35 ? var6 = -.04836360271198036 : input[8] > 4968.500000000001 ? var6 = -.10873681915578029 : input[149] > 1e-35 ? var6 = -.11847484033769298 : input[122] > 1e-35 ? var6 = -.08916172460307559 : input[82] > 1e-35 ? var6 = -.06774726602152634 : var6 = -.0033469147714351327 : input[126] > 1e-35 ? var6 = -.09474445392080015 : input[8] > 131.50000000000003 ? input[118] > 1e-35 ? var6 = -.09002547031023511 : var6 = .015475385187009489 : input[25] > 1e-35 ? var6 = -.08175501232759151 : var6 = -.000429679055394914;
  let var7;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 546.5000000000001 ? var7 = .021942996005324917 : var7 = .042349138084484074 : input[308] > 1e-35 ? var7 = .036507270845732874 : var7 = -.028981850556764995 : input[3] > 24.500000000000004 ? input[23] > 1e-35 ? var7 = .00210930790963475 : input[31] > 1e-35 ? var7 = .006825358293027163 : input[9] > 6.500000000000001 ? var7 = -.013772084269062394 : input[308] > 1e-35 ? var7 = -.008307929099892574 : input[19] > 1e-35 ? var7 = -.027706313312904487 : var7 = -.04891108984170914 : input[134] > 1e-35 ? var7 = -.0605730733844732 : input[25] > 1e-35 ? var7 = -.05347926493253117 : input[227] > 1e-35 ? var7 = -.049415829249003666 : input[32] > 1e-35 ? var7 = -.06807799662179595 : input[308] > 1e-35 ? input[4] > 10.500000000000002 ? input[2] > 13.500000000000002 ? var7 = -.00016302718260794637 : var7 = -.10247095758122947 : input[210] > 1e-35 ? var7 = -.022149002072787024 : input[95] > 1e-35 ? var7 = .15222631630626304 : var7 = .027393884520465712 : input[9] > 7.500000000000001 ? input[225] > 1e-35 ? var7 = .13483346577752245 : input[3] > 9.500000000000002 ? input[243] > 1e-35 ? var7 = -.045352728133789516 : input[8] > 683.5000000000001 ? var7 = .00474372227519902 : var7 = .02635476098707525 : input[92] > 1e-35 ? var7 = .05659380819933452 : input[105] > 1e-35 ? var7 = .07431443210341222 : input[186] > 1e-35 ? var7 = .0915821133384904 : var7 = -.016414750130401053 : input[127] > 1e-35 ? var7 = .011824693641866162 : input[23] > 1e-35 ? var7 = .0228468674288774 : input[284] > 1e-35 ? var7 = .06606936863302432 : var7 = -.02872463273902358;
  let var8;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[8] > 125.50000000000001 ? input[288] > 1e-35 ? var8 = -.019844363904157558 : input[1] > 50.50000000000001 ? input[131] > 1e-35 ? var8 = .044961338592245194 : var8 = .003659599513761676 : input[121] > 1e-35 ? var8 = -.04057103630479994 : var8 = .03158560697078578 : input[0] > 421.50000000000006 ? input[4] > 61.50000000000001 ? var8 = -.0003708603406529278 : var8 = .05331312264472391 : var8 = .0006575958601218936 : input[8] > 319.50000000000006 ? var8 = -.034654694051901545 : input[7] > 3.5000000000000004 ? input[0] > 1230.5000000000002 ? input[0] > 2579.5000000000005 ? var8 = -.0076053515916517005 : var8 = .09116695486305336 : var8 = -.07137458699162028 : var8 = .06633130654035282 : input[4] > 29.500000000000004 ? input[23] > 1e-35 ? input[4] > 63.50000000000001 ? var8 = -.0308520802187302 : var8 = .013156423968295541 : input[115] > 1e-35 ? var8 = .11581171687488252 : input[52] > 1e-35 ? input[10] > 22.500000000000004 ? var8 = .12264179915175587 : var8 = -.021905727233873535 : input[8] > 799.5000000000001 ? var8 = -.04181869575935412 : var8 = -.023695901673350575 : input[222] > 1e-35 ? var8 = -.034612899265371776 : input[8] > 691.5000000000001 ? input[9] > 98.50000000000001 ? var8 = -.06892116536821917 : input[149] > 1e-35 ? var8 = -.11194586444154514 : input[133] > 1e-35 ? var8 = -.04269583234000504 : input[128] > 1e-35 ? var8 = -.0644631966969502 : input[8] > 4968.500000000001 ? var8 = -.09650726096330133 : var8 = -.004219129180139438 : input[126] > 1e-35 ? var8 = -.08038306745347751 : input[5] > 1809.5000000000002 ? var8 = .009265335288169993 : input[9] > 2.5000000000000004 ? var8 = .006447645462117438 : var8 = -.021047132609551503;
  let var9;
  input[13] > 1e-35 ? input[3] > 1.5000000000000002 ? input[9] > 21.500000000000004 ? input[121] > 1e-35 ? var9 = -.08436540015142402 : input[8] > 1861.5000000000002 ? var9 = -.01621425699342421 : var9 = .01878613821895428 : var9 = .031052879158242532 : input[8] > 319.50000000000006 ? var9 = -.031536619360997865 : input[7] > 3.5000000000000004 ? var9 = -.004510586962343298 : var9 = .0596524941011746 : input[4] > 18.500000000000004 ? input[23] > 1e-35 ? var9 = .004757490541310808 : input[9] > 6.500000000000001 ? var9 = -.008842393772207996 : input[31] > 1e-35 ? var9 = .0010536183837006993 : input[308] > 1e-35 ? var9 = -.008145882815435419 : input[2] > 98.50000000000001 ? var9 = -.08404937622173021 : input[276] > 1e-35 ? var9 = .0020072791321856663 : input[19] > 1e-35 ? var9 = -.023031820639490178 : var9 = -.04553314326377875 : input[8] > 2134.5000000000005 ? var9 = -.02244583113572251 : input[134] > 1e-35 ? var9 = -.05592137394753121 : input[308] > 1e-35 ? input[49] > 1e-35 ? var9 = .09989109704064947 : input[4] > 10.500000000000002 ? input[2] > 13.500000000000002 ? var9 = -.00447733056482096 : var9 = -.10191061664873849 : var9 = .021765308380331864 : input[9] > 7.500000000000001 ? input[118] > 1e-35 ? var9 = -.07570059131536411 : input[243] > 1e-35 ? var9 = -.040983393346598646 : input[3] > 9.500000000000002 ? var9 = .014763759061483812 : input[92] > 1e-35 ? var9 = .05136368898963024 : var9 = -.008162398981149495 : input[127] > 1e-35 ? var9 = .013999119696708346 : input[23] > 1e-35 ? input[20] > 1e-35 ? var9 = .14138985500120907 : var9 = .008668274102844162 : input[284] > 1e-35 ? var9 = .06356484011042893 : var9 = -.024781304572706303;
  let var10;
  input[13] > 1e-35 ? input[3] > 8.500000000000002 ? input[8] > 892.5000000000001 ? input[0] > 384.50000000000006 ? var10 = .014387526569215037 : input[8] > 2266.5000000000005 ? var10 = -.1397298649743087 : var10 = .007953931014097788 : input[0] > 119.50000000000001 ? input[4] > 61.50000000000001 ? var10 = .0029819092211896296 : input[218] > 1e-35 ? var10 = .08450459375645737 : var10 = .031646488019280654 : var10 = -.03544960151460596 : input[9] > 9.500000000000002 ? var10 = -.026002317735915183 : input[7] > 1.5000000000000002 ? var10 = .005074258810794793 : var10 = .0745247650477651 : input[4] > 29.500000000000004 ? input[131] > 1e-35 ? var10 = .023269218675640847 : input[148] > 1e-35 ? var10 = .03812942399144545 : input[115] > 1e-35 ? var10 = .10512283476967227 : var10 = -.02607307479736138 : input[227] > 1e-35 ? var10 = -.036576708299046294 : input[101] > 1e-35 ? var10 = .027948683650881864 : input[149] > 1e-35 ? var10 = -.08195628451594297 : input[50] > 1e-35 ? var10 = -.16997544922278504 : input[8] > 691.5000000000001 ? input[9] > 101.50000000000001 ? var10 = -.06860333850762075 : input[225] > 1e-35 ? var10 = .06066641950951723 : input[10] > 22.500000000000004 ? input[1] > 29.500000000000004 ? input[127] > 1e-35 ? var10 = .028599705845427533 : var10 = -.010746719511640914 : input[0] > 4877.500000000001 ? var10 = -.07251187886096228 : var10 = -.021299712241446785 : input[118] > 1e-35 ? var10 = -.11902023760964736 : var10 = 15874469526809387e-21 : input[8] > 267.50000000000006 ? var10 = .01317292185402293 : input[148] > 1e-35 ? input[9] > 20.500000000000004 ? var10 = .09614842415142123 : var10 = .006049073167176467 : input[189] > 1e-35 ? var10 = .05562696451900713 : var10 = -.006257541923837303;
  let var11;
  input[13] > 1e-35 ? input[9] > 14.500000000000002 ? input[2] > 11.500000000000002 ? input[1] > 71.50000000000001 ? input[8] > 1252.5000000000002 ? var11 = -.10069846585436666 : var11 = -.010577995535809317 : input[146] > 1e-35 ? var11 = -.008877238274428668 : input[280] > 1e-35 ? var11 = .10076055897012692 : input[6] > 70.50000000000001 ? var11 = -.020603523042565547 : input[7] > 1.5000000000000002 ? var11 = .02819095420813202 : var11 = -.1223354167911277 : var11 = -.025073583348334844 : input[8] > 416.50000000000006 ? var11 = .01718560189149466 : input[230] > 1e-35 ? var11 = .12281803224342265 : var11 = .03281276971308565 : input[4] > 14.500000000000002 ? input[23] > 1e-35 ? input[21] > 1e-35 ? var11 = -.13070568109867683 : input[4] > 63.50000000000001 ? var11 = -.027221825262496814 : var11 = .01530862490082352 : input[9] > 6.500000000000001 ? input[5] > 4320.500000000001 ? input[2] > 31.500000000000004 ? var11 = -.00605574271293711 : var11 = .04739407327741249 : var11 = -.012537528620315956 : input[31] > 1e-35 ? input[20] > 1e-35 ? var11 = .1252215087035768 : var11 = .003905888677601057 : input[52] > 1e-35 ? var11 = .045466299731038815 : input[2] > 100.50000000000001 ? var11 = -.07815624550168065 : input[308] > 1e-35 ? var11 = -.007715815250508057 : input[276] > 1e-35 ? input[9] > 1.5000000000000002 ? var11 = -.03538265083203445 : input[18] > 1e-35 ? var11 = .1591211669800727 : var11 = .015151475408241136 : input[8] > 557.5000000000001 ? var11 = -.04225569725456342 : var11 = -.022455546324243267 : input[308] > 1e-35 ? var11 = .01325441736085826 : input[197] > 1e-35 ? var11 = .03752194600682512 : input[225] > 1e-35 ? var11 = .06583712394533976 : var11 = -.005205289866839043;
  let var12;
  input[13] > 1e-35 ? input[9] > 21.500000000000004 ? input[2] > 12.500000000000002 ? var12 = .010264022580774884 : var12 = -.02335958814489217 : input[8] > 416.50000000000006 ? input[3] > 4.500000000000001 ? input[295] > 1e-35 ? var12 = -.0936747137352166 : input[0] > 384.50000000000006 ? var12 = .019846244507320695 : var12 = -.0751102554077272 : var12 = -.026885329334203723 : input[0] > 966.5000000000001 ? input[10] > 48.50000000000001 ? var12 = .11654906890054273 : var12 = .0346250587613322 : input[4] > 39.50000000000001 ? var12 = -.08568002378645614 : input[9] > 16.500000000000004 ? var12 = -.12010535752923689 : var12 = .021321923389033808 : input[4] > 14.500000000000002 ? input[23] > 1e-35 ? input[21] > 1e-35 ? var12 = -.12056431231412057 : input[131] > 1e-35 ? var12 = .03652965550568472 : var12 = .002563006128791669 : input[9] > 6.500000000000001 ? input[30] > 1e-35 ? var12 = -.10141481732178981 : var12 = -.003936457893178248 : input[31] > 1e-35 ? var12 = .008215898756249477 : input[52] > 1e-35 ? input[0] > 4188.500000000001 ? var12 = .12972828769588213 : var12 = -.003137412232297087 : input[2] > 100.50000000000001 ? var12 = -.0730872929087944 : input[308] > 1e-35 ? var12 = -.006958622747243333 : input[35] > 1e-35 ? input[0] > 3707.5000000000005 ? var12 = .07934620723812878 : var12 = -.018598568353702116 : var12 = -.030635505446410763 : input[128] > 1e-35 ? var12 = -.06962290453843294 : input[84] > 1e-35 ? var12 = -.15290337844960322 : input[308] > 1e-35 ? input[8] > 2543.5000000000005 ? var12 = -.034938657503885584 : var12 = .016339322898966915 : input[197] > 1e-35 ? var12 = .03358907965870046 : input[18] > 1e-35 ? var12 = -.01754013791515288 : var12 = -.0004944586067698557;
  let var13;
  input[13] > 1e-35 ? input[308] > 1e-35 ? input[210] > 1e-35 ? var13 = .005888790687820524 : var13 = .0429676533834978 : input[2] > 7.500000000000001 ? input[0] > 119.50000000000001 ? input[6] > 79.50000000000001 ? var13 = -.0224319889201976 : input[212] > 1e-35 ? var13 = .06249587051783863 : input[8] > 963.5000000000001 ? input[8] > 1156.5000000000002 ? var13 = .010357273289123324 : var13 = -.029749145161304082 : input[218] > 1e-35 ? var13 = .06449336340743606 : var13 = .018047654539345502 : var13 = -.07350502390293116 : var13 = -.019594829995832414 : input[4] > 39.50000000000001 ? var13 = -.019338083179859314 : input[39] > 1e-35 ? var13 = -.10427066919173111 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? var13 = -.019197415255018464 : var13 = -.0836562507048181 : input[149] > 1e-35 ? var13 = -.07679624472577429 : input[32] > 1e-35 ? var13 = -.05097506748590604 : input[191] > 1e-35 ? var13 = .04670476485250936 : input[30] > 1e-35 ? var13 = -.05313073892148652 : input[8] > 691.5000000000001 ? input[23] > 1e-35 ? input[203] > 1e-35 ? input[4] > 8.500000000000002 ? var13 = .03930363008271334 : var13 = -.06029171685615689 : var13 = .016203086182431294 : input[4] > 7.500000000000001 ? var13 = -.013824248237085224 : input[10] > 4.500000000000001 ? input[94] > 1e-35 ? var13 = -.09817668643367765 : input[10] > 40.50000000000001 ? var13 = -.023558078753593125 : var13 = .0065113494780482326 : input[8] > 809.5000000000001 ? input[297] > 1e-35 ? var13 = -.1352063548573715 : var13 = .058203900441270634 : var13 = -.035243959159285736 : input[10] > 59.50000000000001 ? input[1] > 43.50000000000001 ? var13 = -.012552876807800442 : var13 = .05991247777734298 : var13 = .0035893102109330177;
  let var14;
  input[13] > 1e-35 ? input[9] > 21.500000000000004 ? input[145] > 1e-35 ? var14 = .03507251990078782 : input[2] > 14.500000000000002 ? var14 = .004905698363309292 : input[8] > 2421.5000000000005 ? var14 = -.10306119951984316 : var14 = -.018951037816654928 : input[8] > 416.50000000000006 ? input[3] > 4.500000000000001 ? input[295] > 1e-35 ? var14 = -.08503171085833393 : var14 = .015130974593044409 : var14 = -.024425267075198206 : var14 = .02624054905103126 : input[4] > 19.500000000000004 ? input[131] > 1e-35 ? var14 = .02100191580704534 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var14 = .09908783187786288 : var14 = -.06920877329925636 : input[8] > 241.50000000000003 ? var14 = -.016756131804203496 : input[9] > 33.50000000000001 ? var14 = .04903179955263626 : input[217] > 1e-35 ? var14 = -.047416847619291644 : var14 = -.0017200891991431119 : input[39] > 1e-35 ? var14 = -.10389927604977028 : input[134] > 1e-35 ? var14 = -.050480365434872866 : input[178] > 1e-35 ? var14 = -.05167855791556937 : input[8] > 2134.5000000000005 ? var14 = -.01663197335585307 : input[242] > 1e-35 ? var14 = -.05361323756615453 : input[118] > 1e-35 ? var14 = -.05299780866211368 : input[10] > 24.500000000000004 ? input[10] > 55.50000000000001 ? input[8] > 764.5000000000001 ? var14 = -.0016544848369620534 : var14 = .04494144460483587 : var14 = -.009283616456736156 : input[121] > 1e-35 ? input[0] > 4463.500000000001 ? var14 = .051166688553608355 : var14 = -.06623908820705383 : input[84] > 1e-35 ? var14 = -.12990936092409747 : input[306] > 1e-35 ? var14 = -.07020596855118943 : input[49] > 1e-35 ? var14 = .06272964802556856 : input[192] > 1e-35 ? var14 = .06540204627162581 : var14 = .008277910531592885;
  let var15;
  input[13] > 1e-35 ? input[308] > 1e-35 ? input[210] > 1e-35 ? var15 = .003325460510319164 : var15 = .037153108286272905 : input[2] > 12.500000000000002 ? input[1] > 124.50000000000001 ? var15 = -.09880713344892134 : input[7] > 60.50000000000001 ? input[10] > 71.50000000000001 ? var15 = .0697359767152808 : input[230] > 1e-35 ? var15 = .06513506845651572 : var15 = -.02826625276613455 : input[5] > 246.50000000000003 ? input[8] > 95.50000000000001 ? var15 = .013616385013146277 : var15 = .04171540100223404 : var15 = -.04360396575094823 : input[212] > 1e-35 ? var15 = .025945477945627522 : var15 = -.019793208261535442 : input[4] > 39.50000000000001 ? input[25] > 1e-35 ? var15 = -.07856453318384411 : var15 = -.014803893522351739 : input[39] > 1e-35 ? var15 = -.09185452630751932 : input[149] > 1e-35 ? var15 = -.07122426086157027 : input[134] > 1e-35 ? var15 = -.04231052091434186 : input[227] > 1e-35 ? var15 = -.029815824273994197 : input[50] > 1e-35 ? var15 = -.15736496271211153 : input[222] > 1e-35 ? var15 = -.02360285356956629 : input[128] > 1e-35 ? var15 = -.03922080193836443 : input[136] > 1e-35 ? var15 = -.07219685327698587 : input[10] > 24.500000000000004 ? input[1] > 8.500000000000002 ? var15 = -.0029736170756835783 : var15 = -.06482902102259112 : input[84] > 1e-35 ? var15 = -.11340924635708383 : input[94] > 1e-35 ? var15 = -.03635703457792193 : input[118] > 1e-35 ? var15 = -.058181913914186034 : input[126] > 1e-35 ? var15 = -.062030576241517366 : input[116] > 1e-35 ? var15 = -.045086301850604006 : input[25] > 1e-35 ? var15 = -.031665223656767286 : input[203] > 1e-35 ? var15 = -.009444685731407691 : var15 = .0112265153772187;
  let var16;
  input[13] > 1e-35 ? input[1] > 64.50000000000001 ? input[9] > 14.500000000000002 ? input[9] > 54.50000000000001 ? var16 = .022717227245241684 : var16 = -.049700413274686266 : var16 = .007175776918589741 : input[5] > 50.50000000000001 ? input[8] > 61.50000000000001 ? input[21] > 1e-35 ? var16 = -.07927556792063156 : input[3] > 8.500000000000002 ? input[4] > 23.500000000000004 ? input[281] > 1e-35 ? var16 = -.12263724050601095 : var16 = .0070743478891288035 : input[288] > 1e-35 ? var16 = -.050439138582109 : var16 = .0255701593657891 : var16 = -.005812703740580558 : input[6] > 49.50000000000001 ? var16 = -.008542694147899113 : var16 = .035147383686665 : var16 = -.0960461939274094 : input[32] > 1e-35 ? var16 = -.04555453745517765 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? var16 = -.01800870272656664 : var16 = -.07817304234604389 : input[30] > 1e-35 ? var16 = -.05227061750368981 : input[25] > 1e-35 ? input[0] > 4449.500000000001 ? input[217] > 1e-35 ? var16 = .08778416018479411 : var16 = -.026563982720830256 : var16 = -.05296139548112329 : input[50] > 1e-35 ? var16 = -.14926464875852247 : input[8] > 779.5000000000001 ? input[133] > 1e-35 ? var16 = -.036572140520852024 : input[183] > 1e-35 ? var16 = -.10766853736801459 : var16 = -.003966794968701808 : input[217] > 1e-35 ? input[5] > 5237.500000000001 ? var16 = .09513215942486053 : var16 = -.03641865277445567 : input[10] > 59.50000000000001 ? var16 = .03177172388687933 : input[39] > 1e-35 ? var16 = -.10234241303898953 : input[243] > 1e-35 ? var16 = -.02966738115984321 : input[190] > 1e-35 ? var16 = -.04312785336449181 : input[118] > 1e-35 ? var16 = -.05808521194081524 : var16 = .006720381600740378;
  let var17;
  input[308] > 1e-35 ? input[5] > 423.00000000000006 ? input[133] > 1e-35 ? var17 = -.046284053681928526 : input[210] > 1e-35 ? var17 = 49778070699847876e-21 : input[13] > 1e-35 ? var17 = .03328070054739309 : input[128] > 1e-35 ? var17 = -.054790214922938896 : input[126] > 1e-35 ? var17 = -.08524792218532945 : var17 = .014414055975542446 : input[1] > 38.50000000000001 ? var17 = -.07287851335872973 : var17 = .005263371501687163 : input[9] > 7.500000000000001 ? input[21] > 1e-35 ? input[10] > 4.500000000000001 ? var17 = -.12459748864088374 : var17 = -.004626323021331593 : input[298] > 1e-35 ? input[4] > 64.50000000000001 ? var17 = .13044981041138526 : input[9] > 71.50000000000001 ? var17 = -.056068402282406865 : input[9] > 12.500000000000002 ? var17 = .038957722962512764 : var17 = -.04598815982492169 : input[8] > 691.5000000000001 ? input[126] > 1e-35 ? var17 = -.0852126122372075 : input[225] > 1e-35 ? var17 = .10082066771689505 : input[1] > 161.50000000000003 ? var17 = -.11609832500613824 : input[3] > 8.500000000000002 ? input[8] > 1685.5000000000002 ? var17 = -.010835400874777133 : var17 = .004607419973807752 : var17 = -.016989075258564062 : var17 = .009205417251698097 : input[23] > 1e-35 ? input[20] > 1e-35 ? var17 = .10184317139657878 : input[0] > 5724.500000000001 ? var17 = -.1163666496650542 : input[1] > 106.50000000000001 ? var17 = .1303850608190687 : input[129] > 1e-35 ? var17 = .10745031509534769 : var17 = .006166901738036226 : input[31] > 1e-35 ? var17 = .010177092833155127 : input[13] > 1e-35 ? input[0] > 213.50000000000003 ? var17 = .005004582564506611 : var17 = -.10481581731668346 : input[19] > 1e-35 ? var17 = -.009850706427306281 : var17 = -.02608226348051303;
  let var18;
  input[13] > 1e-35 ? input[1] > 64.50000000000001 ? input[2] > 4.500000000000001 ? var18 = -.0024117174588695603 : var18 = -.058339700513831916 : input[212] > 1e-35 ? input[0] > 2215.5000000000005 ? input[8] > 847.5000000000001 ? input[10] > 21.500000000000004 ? input[1] > 39.50000000000001 ? var18 = .04575380761203418 : var18 = -.10025595041353463 : input[15] > 1e-35 ? var18 = .17705790384964004 : var18 = .0073813837628615014 : var18 = .07676373681392407 : var18 = -.027167992693885996 : input[3] > 11.500000000000002 ? input[280] > 1e-35 ? var18 = .07078572910026419 : input[4] > 23.500000000000004 ? var18 = .005513918674164821 : var18 = .0206586476926392 : input[0] > 5269.500000000001 ? var18 = .07706773525822633 : var18 = -.010233826953776122 : input[148] > 1e-35 ? input[8] > 1622.5000000000002 ? var18 = -.03204783603215824 : var18 = .027405418223981973 : input[4] > 14.500000000000002 ? input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? input[0] > 5026.500000000001 ? var18 = -.0930246911392012 : var18 = .011173087289703683 : input[3] > 24.500000000000004 ? var18 = .03281421918878597 : var18 = .12449335091369843 : input[204] > 1e-35 ? var18 = .06634531187326123 : var18 = -.011522999669353388 : input[92] > 1e-35 ? input[10] > 42.50000000000001 ? var18 = -.041196758517013515 : input[4] > 7.500000000000001 ? var18 = -2942718111029724e-20 : input[4] > 6.500000000000001 ? var18 = .11953909558532852 : var18 = .03188615019450534 : input[122] > 1e-35 ? var18 = -.0616037324662157 : input[101] > 1e-35 ? var18 = .027230889593349412 : input[8] > 4968.500000000001 ? var18 = -.1113986516540856 : input[3] > 2.5000000000000004 ? var18 = -.002045140426885727 : input[129] > 1e-35 ? var18 = .12641163374304432 : var18 = .014909826232873194;
  let var19;
  input[308] > 1e-35 ? input[0] > 7277.500000000001 ? var19 = -.09337446795435 : input[5] > 423.00000000000006 ? input[133] > 1e-35 ? var19 = -.040884836258675006 : input[210] > 1e-35 ? var19 = -.0003719413278428804 : input[13] > 1e-35 ? var19 = .030287610160818174 : var19 = .011174130013595384 : input[1] > 38.50000000000001 ? var19 = -.0662442170185784 : var19 = .004332185707008564 : input[9] > 7.500000000000001 ? input[145] > 1e-35 ? input[285] > 1e-35 ? var19 = -.08092286307197555 : var19 = .029866363328584986 : input[21] > 1e-35 ? input[10] > 4.500000000000001 ? var19 = -.1155211149523894 : var19 = -.0032903546638958538 : input[149] > 1e-35 ? var19 = -.03632198993199768 : input[3] > 9.500000000000002 ? input[8] > 999.5000000000001 ? var19 = -.003507023626534306 : input[128] > 1e-35 ? input[4] > 13.500000000000002 ? input[0] > 3459.5000000000005 ? var19 = -.025416927789760076 : var19 = .02777568919793122 : var19 = -.10310351509769732 : var19 = .013549608903688785 : input[186] > 1e-35 ? var19 = .08513865847420551 : var19 = -.009306721292510369 : input[31] > 1e-35 ? var19 = .009780833952582307 : input[23] > 1e-35 ? var19 = .011143773934157629 : input[210] > 1e-35 ? var19 = .025354797285173356 : input[17] > 1e-35 ? input[10] > 3.5000000000000004 ? var19 = -.04846287537743046 : var19 = -.014647271080376757 : input[2] > 5.500000000000001 ? input[7] > 57.50000000000001 ? var19 = -.034224938681445764 : input[8] > 1641.5000000000002 ? var19 = -.027298372075800673 : input[191] > 1e-35 ? input[10] > 18.500000000000004 ? var19 = -.027950103994861836 : var19 = .14575930827829034 : var19 = -.007124740389354946 : input[10] > 22.500000000000004 ? var19 = .013173304107866726 : var19 = -.11119620042551365;
  let var20;
  input[131] > 1e-35 ? var20 = .01892225243240137 : input[308] > 1e-35 ? input[5] > 691.5000000000001 ? input[133] > 1e-35 ? var20 = -.037118314390013646 : input[1] > 51.50000000000001 ? input[5] > 3749.5000000000005 ? input[8] > 58.50000000000001 ? var20 = -.022305242912035072 : var20 = .024792895826340516 : var20 = .013666137278072166 : input[88] > 1e-35 ? input[10] > 27.500000000000004 ? var20 = .2080083584805785 : var20 = .04247197078083379 : input[10] > 40.50000000000001 ? input[18] > 1e-35 ? input[1] > 27.500000000000004 ? var20 = .060783227455868206 : var20 = -.056904865557409035 : var20 = -.03278952553107572 : input[192] > 1e-35 ? var20 = .13117402617043625 : var20 = .01647119888257836 : var20 = -.01825870445636398 : input[9] > 6.500000000000001 ? input[298] > 1e-35 ? var20 = .026536210945939682 : input[8] > 691.5000000000001 ? input[126] > 1e-35 ? var20 = -.07927319604548912 : input[10] > 3.5000000000000004 ? input[21] > 1e-35 ? var20 = -.11083976837572328 : input[146] > 1e-35 ? var20 = -.03359294484446772 : var20 = -.0042815953591236475 : input[190] > 1e-35 ? var20 = -.09264239592903775 : input[10] > 1e-35 ? var20 = .022282638485105657 : var20 = -.0205994057928458 : input[5] > 4918.500000000001 ? var20 = .03430715695199153 : input[243] > 1e-35 ? input[2] > 57.50000000000001 ? var20 = .08935072241972036 : var20 = -.03781647876237494 : var20 = .0062655753179671515 : input[31] > 1e-35 ? var20 = .008603500300349887 : input[230] > 1e-35 ? var20 = .03350056932774173 : input[23] > 1e-35 ? input[241] > 1e-35 ? var20 = .10277555508503314 : var20 = .0017901817172993888 : input[2] > 98.50000000000001 ? var20 = -.05920081229672715 : var20 = -.015722173275739208;
  let var21;
  input[13] > 1e-35 ? input[118] > 1e-35 ? var21 = .07957905150112207 : input[1] > 125.50000000000001 ? var21 = -.0662620579858685 : input[145] > 1e-35 ? var21 = .029682040828779843 : input[19] > 1e-35 ? input[6] > 15.500000000000002 ? var21 = -.0009597832580977798 : var21 = -.081474760755753 : input[212] > 1e-35 ? var21 = .03637001492325179 : var21 = .006912305498963309 : input[32] > 1e-35 ? var21 = -.03919900630910754 : input[134] > 1e-35 ? var21 = -.036225295529777886 : input[4] > 4.500000000000001 ? input[5] > 384.50000000000006 ? input[204] > 1e-35 ? var21 = .06671440854602108 : input[136] > 1e-35 ? var21 = -.07577364230133474 : input[148] > 1e-35 ? input[4] > 7.500000000000001 ? var21 = .026430947016830915 : var21 = -.04075501264495112 : input[9] > 93.50000000000001 ? var21 = -.04353169430417609 : input[50] > 1e-35 ? var21 = -.1411224537622882 : input[17] > 1e-35 ? input[49] > 1e-35 ? var21 = .068392679163672 : input[10] > 1.5000000000000002 ? var21 = -.0209659792007492 : var21 = -.0004393235559249831 : input[133] > 1e-35 ? input[9] > 64.50000000000001 ? var21 = .07254524592323175 : var21 = -.0319087835282534 : var21 = .00037444813327793425 : var21 = -.025138768151370408 : input[243] > 1e-35 ? var21 = -.050010891710502096 : input[94] > 1e-35 ? var21 = -.0817513550778599 : input[122] > 1e-35 ? var21 = -.061038875809822285 : input[19] > 1e-35 ? input[8] > 1085.5000000000002 ? var21 = -.008408408775061623 : input[2] > 5.500000000000001 ? input[218] > 1e-35 ? var21 = .1454877641381946 : var21 = .053787998331240316 : input[9] > 33.50000000000001 ? var21 = .08602629796680285 : var21 = -.03895127455803038 : var21 = .008830878042315722;
  let var22;
  input[131] > 1e-35 ? var22 = .01687979707990516 : input[8] > 2915.5000000000005 ? input[297] > 1e-35 ? var22 = .07473600489975568 : input[0] > 93.50000000000001 ? var22 = -.021596848506011502 : var22 = -.13840802327735696 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[0] > 4977.500000000001 ? var22 = .10264284346448256 : var22 = .031042487183181262 : var22 = -.016653982936827776 : input[4] > 60.50000000000001 ? input[10] > 75.50000000000001 ? var22 = .04226403420647408 : input[10] > 1e-35 ? input[0] > 4733.500000000001 ? var22 = .006271403149804702 : var22 = -.030013637555715046 : input[0] > 4449.500000000001 ? var22 = -.06556876058654929 : var22 = .06437994816903034 : input[32] > 1e-35 ? var22 = -.043814577251655815 : input[308] > 1e-35 ? input[0] > 7277.500000000001 ? var22 = -.09349726304052086 : input[210] > 1e-35 ? var22 = -.0035960132209098003 : input[5] > 691.5000000000001 ? input[133] > 1e-35 ? var22 = -.029188394315052574 : var22 = .017219308333820193 : var22 = -.017378928852189585 : input[9] > 6.500000000000001 ? input[0] > 2653.5000000000005 ? input[149] > 1e-35 ? var22 = -.04428555753857688 : var22 = .0001456106867817353 : input[5] > 213.50000000000003 ? var22 = .01740292726636365 : var22 = -.011361718115556464 : input[7] > 4.500000000000001 ? input[0] > 316.50000000000006 ? input[19] > 1e-35 ? input[10] > 54.50000000000001 ? var22 = .03410288911259329 : input[121] > 1e-35 ? var22 = -.06056527462120627 : input[8] > 2592.5000000000005 ? var22 = .12166808844363577 : input[191] > 1e-35 ? var22 = .11669879218998758 : var22 = -.001664858391716235 : var22 = -.01262927450503166 : var22 = -.04506589951879664 : input[227] > 1e-35 ? var22 = -.08548904959752329 : var22 = .02156080776537726;
  let var23;
  input[306] > 1e-35 ? input[149] > 1e-35 ? var23 = -.1389218965136736 : var23 = -.032218642644416894 : input[13] > 1e-35 ? var23 = .006465035217331847 : input[50] > 1e-35 ? var23 = -.1381687930130022 : input[179] > 1e-35 ? var23 = -.13112784985951215 : input[148] > 1e-35 ? input[8] > 1726.5000000000002 ? var23 = -.03262719498763048 : var23 = .023342916702125613 : input[191] > 1e-35 ? var23 = .030005484947580197 : input[4] > 4.500000000000001 ? input[204] > 1e-35 ? var23 = .047767773119269434 : input[136] > 1e-35 ? input[0] > 1937.5000000000002 ? var23 = -.09989343595668776 : var23 = .06533942033334243 : input[15] > 1e-35 ? input[9] > 86.50000000000001 ? var23 = -.10577989354150097 : input[8] > 668.5000000000001 ? input[126] > 1e-35 ? var23 = -.09165257825246746 : input[9] > 32.50000000000001 ? var23 = .02484870392366004 : var23 = -.008499493096971395 : input[8] > 24.500000000000004 ? var23 = .02459679192828244 : var23 = -.010527978013140512 : input[25] > 1e-35 ? input[217] > 1e-35 ? var23 = .0015644546318714849 : var23 = -.06579524865022705 : var23 = -.0060233890975120614 : input[122] > 1e-35 ? input[1] > 36.50000000000001 ? var23 = .03331853632960164 : var23 = -.09482264761126993 : input[19] > 1e-35 ? input[8] > 1430.5000000000002 ? var23 = -.019091477207111116 : var23 = .037878468575478504 : input[94] > 1e-35 ? var23 = -.08013082284576584 : input[4] > 2.5000000000000004 ? input[186] > 1e-35 ? var23 = .16919658785098224 : input[243] > 1e-35 ? var23 = -.06580584936754524 : var23 = .01567555159935563 : input[129] > 1e-35 ? var23 = .06721746994993226 : input[10] > 32.50000000000001 ? var23 = -.046394462507797975 : var23 = -.006436180519584767;
  let var24;
  input[131] > 1e-35 ? var24 = .015039096856208693 : input[8] > 779.5000000000001 ? input[145] > 1e-35 ? var24 = .019122095523977856 : input[298] > 1e-35 ? var24 = .023828936462317443 : input[1] > 23.500000000000004 ? input[5] > 384.50000000000006 ? input[7] > 59.50000000000001 ? var24 = -.026094309429557913 : input[204] > 1e-35 ? var24 = .09163404305658318 : input[1] > 27.500000000000004 ? input[149] > 1e-35 ? input[6] > 34.50000000000001 ? var24 = .012643810980689466 : var24 = -.07884161741497837 : var24 = -.0025267379810891104 : input[2] > 43.50000000000001 ? input[0] > 2860.5000000000005 ? var24 = .04493082949897325 : var24 = .18046359750455776 : input[7] > 18.500000000000004 ? var24 = -.018667348656891496 : var24 = .02584325784698236 : var24 = -.045696524897545915 : input[0] > 3321.5000000000005 ? input[201] > 1e-35 ? var24 = .04749240016989375 : var24 = -.0333334578246718 : input[5] > 3276.5000000000005 ? var24 = .11330554740098908 : input[7] > 94.50000000000001 ? var24 = .1296600395033268 : var24 = -.003576436308940934 : input[15] > 1e-35 ? input[183] > 1e-35 ? var24 = -.13787130789142835 : input[0] > 1847.5000000000002 ? var24 = .017915229729920556 : input[10] > 23.500000000000004 ? input[10] > 31.500000000000004 ? input[6] > 7.500000000000001 ? var24 = .028856848462727104 : var24 = -.11197632885851168 : var24 = .08169801342016791 : input[1] > 22.500000000000004 ? var24 = -.021052888644970163 : var24 = .019048604298876753 : input[7] > 4.500000000000001 ? var24 = -.002603328695276418 : input[7] > 1.5000000000000002 ? input[2] > 5.500000000000001 ? var24 = .03432638833359197 : var24 = -.0036767863082454973 : input[1] > 48.50000000000001 ? var24 = .03087375270128195 : input[2] > 3.5000000000000004 ? var24 = -.04219917149740248 : var24 = .018818493993207935;
  let var25;
  input[306] > 1e-35 ? var25 = -.04076858123502297 : input[13] > 1e-35 ? input[1] > 67.50000000000001 ? input[9] > 14.500000000000002 ? input[9] > 53.50000000000001 ? input[8] > 1971.5000000000002 ? var25 = -.09091897542577475 : var25 = .04042943082645558 : input[218] > 1e-35 ? var25 = .056254985867151 : var25 = -.053848117950183044 : var25 = .003881630017086845 : input[5] > 5152.500000000001 ? input[8] > 857.5000000000001 ? input[6] > 28.500000000000004 ? var25 = .021581808008986944 : var25 = -.05639286496176611 : var25 = .052838875036198954 : input[5] > 50.50000000000001 ? input[5] > 4082.5000000000005 ? input[17] > 1e-35 ? var25 = .023061479860228728 : input[145] > 1e-35 ? input[9] > 10.500000000000002 ? var25 = .023885302967553288 : var25 = .1617794086125622 : input[212] > 1e-35 ? var25 = .04504545345658806 : input[3] > 17.500000000000004 ? input[4] > 45.50000000000001 ? var25 = -.03948072448245435 : input[1] > 47.50000000000001 ? input[9] > 18.500000000000004 ? var25 = .01894935813286188 : var25 = -.06449356357429188 : var25 = .012297239104320094 : input[1] > 26.500000000000004 ? input[8] > 33.50000000000001 ? var25 = -.034718828212885515 : var25 = .0898976288814321 : input[1] > 17.500000000000004 ? var25 = -.15440137451988326 : var25 = -.03864183216821465 : var25 = .009988507307006308 : var25 = -.08540311947043305 : input[50] > 1e-35 ? var25 = -.13323659732101975 : input[134] > 1e-35 ? var25 = -.031820386486894385 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var25 = .08082476177379844 : var25 = -.041665761903645876 : input[179] > 1e-35 ? var25 = -.12405023987936657 : input[39] > 1e-35 ? var25 = -.06247416524997478 : input[138] > 1e-35 ? var25 = -.10724031753676487 : var25 = -.0005423122305122404;
  let var26;
  input[308] > 1e-35 ? var26 = .006160742906729798 : input[190] > 1e-35 ? input[0] > 2461.5000000000005 ? input[10] > 22.500000000000004 ? var26 = .023223358334607133 : var26 = -.04383410185346742 : var26 = -.08542395045055405 : input[297] > 1e-35 ? input[8] > 51.50000000000001 ? input[1] > 13.500000000000002 ? var26 = .023406489302867494 : var26 = -.085521220804058 : var26 = -.02921899554854833 : input[298] > 1e-35 ? input[9] > 12.500000000000002 ? var26 = .028120059780969632 : var26 = -.04211009474298743 : input[294] > 1e-35 ? var26 = -.05040415676618239 : input[86] > 1e-35 ? input[1] > 36.50000000000001 ? var26 = -.0993035220737934 : var26 = -.0005384930611060366 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? var26 = .029770210551187937 : var26 = -.016272917551655715 : input[4] > 60.50000000000001 ? input[280] > 1e-35 ? var26 = .06421359317599738 : var26 = -.01963732469244167 : input[218] > 1e-35 ? input[3] > 3.5000000000000004 ? var26 = .024368404612215164 : var26 = -.04045232374803373 : input[131] > 1e-35 ? var26 = .017372701982485795 : input[120] > 1e-35 ? var26 = .08812710275150198 : input[18] > 1e-35 ? input[90] > 1e-35 ? var26 = .18451364351180236 : input[7] > 33.50000000000001 ? var26 = -.03850813130183531 : input[195] > 1e-35 ? var26 = .06966114053446336 : input[3] > 16.500000000000004 ? var26 = -.0012869181693341211 : input[0] > 4242.500000000001 ? var26 = -.054625548611291035 : var26 = -.014431095117473881 : input[5] > 4558.500000000001 ? input[8] > 1.5000000000000002 ? var26 = .006302103427145562 : var26 = .13967622319898698 : input[121] > 1e-35 ? var26 = -.038798585213145644 : input[5] > 4544.500000000001 ? var26 = -.08050498033009466 : var26 = -.002986974112681435;
  let var27;
  input[0] > 384.50000000000006 ? input[2] > 101.50000000000001 ? input[1] > 16.500000000000004 ? var27 = -.03461119351456781 : var27 = .05659026566680352 : input[306] > 1e-35 ? input[2] > 14.500000000000002 ? input[149] > 1e-35 ? var27 = -.12404435523286539 : var27 = -.0034376913880382956 : var27 = -.09821622245095822 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var27 = .0037507103585310234 : var27 = .03610387965829944 : input[8] > 999.5000000000001 ? input[9] > 137.50000000000003 ? var27 = -.11985021663179699 : input[0] > 1847.5000000000002 ? input[126] > 1e-35 ? var27 = -.04832024079663151 : input[37] > 1e-35 ? var27 = -.037103393468366934 : var27 = -.004248086592531705 : input[8] > 3084.0000000000005 ? input[9] > 43.50000000000001 ? var27 = .032539071163832034 : input[5] > 1643.5000000000002 ? var27 = .036408625378035665 : input[0] > 1500.5000000000002 ? var27 = -.1346358322854993 : var27 = -.027586559522081014 : input[3] > 1e-35 ? input[190] > 1e-35 ? var27 = -.1133991164577881 : input[9] > 52.50000000000001 ? var27 = -.024478640359723122 : var27 = .03673777861098756 : var27 = -.1037451237591819 : input[230] > 1e-35 ? input[9] > 48.50000000000001 ? input[10] > 20.500000000000004 ? var27 = .002583438691776944 : var27 = .10773520810108106 : input[9] > 12.500000000000002 ? input[1] > 16.500000000000004 ? var27 = -.02141222346712401 : var27 = .06392462314316179 : input[4] > 12.500000000000002 ? var27 = .08700122294434816 : input[8] > 267.50000000000006 ? var27 = .056923170082743224 : var27 = -.07716309825583327 : input[32] > 1e-35 ? var27 = -.03961343943752142 : var27 = .002674914122888783 : input[1] > 42.50000000000001 ? var27 = -.05217539654421676 : input[145] > 1e-35 ? var27 = .09553630282946368 : var27 = -.009424791262477729;
  let var28;
  input[183] > 1e-35 ? var28 = -.05753337139158443 : input[308] > 1e-35 ? var28 = .00562436671450989 : input[9] > 7.500000000000001 ? input[21] > 1e-35 ? input[10] > 8.500000000000002 ? var28 = -.10477869875380448 : var28 = -.0070301869937306055 : input[3] > 9.500000000000002 ? input[8] > 1765.5000000000002 ? input[0] > 4571.500000000001 ? var28 = -.12526505173232894 : input[10] > 1e-35 ? input[9] > 71.50000000000001 ? var28 = -.04442302951713574 : var28 = .00012409888451734224 : var28 = -.092199119633697 : input[225] > 1e-35 ? var28 = .13773072450201831 : input[0] > 2882.5000000000005 ? var28 = .0028540012229920533 : input[298] > 1e-35 ? var28 = .07134486044361629 : var28 = .014297412329837425 : input[145] > 1e-35 ? var28 = .05608385321902638 : input[92] > 1e-35 ? var28 = .038298413603926135 : input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var28 = -.0039957800609801315 : var28 = .0776927564241081 : input[203] > 1e-35 ? var28 = -.05502900859432093 : input[105] > 1e-35 ? var28 = .06062892720841595 : var28 = -.009574839629252128 : input[31] > 1e-35 ? var28 = .009488858841144216 : input[23] > 1e-35 ? input[20] > 1e-35 ? var28 = .08818126313644752 : input[8] > 161.50000000000003 ? var28 = .014353968957885408 : var28 = -.022240738532827903 : input[210] > 1e-35 ? var28 = .024648862719806694 : input[2] > 5.500000000000001 ? input[4] > 4.500000000000001 ? input[17] > 1e-35 ? input[10] > 16.500000000000004 ? var28 = -.043902062079383485 : var28 = -.014741559220396223 : var28 = -.00934935734853194 : input[6] > 32.50000000000001 ? var28 = .1514593126307404 : var28 = .010771222510801532 : input[10] > 22.500000000000004 ? var28 = .01412495209334078 : var28 = -.08576940379502533;
  let var29;
  input[0] > 384.50000000000006 ? input[84] > 1e-35 ? var29 = -.06647690967306838 : input[2] > 101.50000000000001 ? var29 = -.024451334501552457 : input[306] > 1e-35 ? var29 = -.034517188927733505 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var29 = .0031858381443673127 : var29 = .032574927024450646 : input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var29 = -.08601340441214533 : input[1] > 29.500000000000004 ? var29 = .10487598629539963 : input[8] > 597.5000000000001 ? var29 = -.0786529133673238 : var29 = .08689436600511559 : input[8] > 779.5000000000001 ? input[10] > 2.5000000000000004 ? input[9] > 100.50000000000001 ? var29 = -.04883600353740688 : input[126] > 1e-35 ? var29 = -.03794042763348827 : var29 = -.003358871967539988 : input[210] > 1e-35 ? var29 = .054991356498447566 : input[6] > 19.500000000000004 ? var29 = -.007418396981635549 : var29 = .018032606049498613 : input[18] > 1e-35 ? input[7] > 35.50000000000001 ? input[2] > 44.50000000000001 ? var29 = -.02143003429501711 : var29 = -.09016000554055564 : input[1] > 19.500000000000004 ? input[1] > 42.50000000000001 ? input[8] > 17.500000000000004 ? var29 = -.006636355416244082 : var29 = -.06483095743431454 : input[4] > 21.500000000000004 ? var29 = -.028975965946833545 : var29 = .022012264796522657 : var29 = -.06653648243193663 : input[5] > 4593.500000000001 ? var29 = .01753551428088607 : input[217] > 1e-35 ? var29 = -.028864824937700297 : input[94] > 1e-35 ? var29 = -.04885192273020658 : input[279] > 1e-35 ? var29 = .08105715462329498 : input[121] > 1e-35 ? var29 = -.04576676034750651 : var29 = .004795141324949362 : input[1] > 42.50000000000001 ? var29 = -.047446619702809195 : input[145] > 1e-35 ? var29 = .08400495571952321 : var29 = -.00854528836489364;
  let var30;
  input[294] > 1e-35 ? var30 = -.042529778074638265 : input[266] > 1e-35 ? var30 = -.1180276669679798 : input[134] > 1e-35 ? var30 = -.026818144353279623 : input[183] > 1e-35 ? var30 = -.05120747503479363 : input[227] > 1e-35 ? input[8] > 1641.5000000000002 ? var30 = -.07265906898294434 : input[4] > 12.500000000000002 ? input[17] > 1e-35 ? var30 = -.027516137530797014 : input[0] > 4331.500000000001 ? input[1] > 64.50000000000001 ? var30 = -.03049646619610203 : input[1] > 50.50000000000001 ? var30 = .20634590755061122 : var30 = .06956378103625731 : input[0] > 3770.5000000000005 ? var30 = -.07946414366134913 : input[19] > 1e-35 ? var30 = .17083312065604694 : input[2] > 21.500000000000004 ? var30 = -.02327981978127724 : var30 = .129717297518715 : input[145] > 1e-35 ? var30 = .006891245076133524 : var30 = -.0789123467863741 : input[3] > 99.50000000000001 ? var30 = -.02022281202803071 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var30 = .06447639919732716 : var30 = -.05457561977645972 : input[306] > 1e-35 ? var30 = -.029995903305383882 : input[191] > 1e-35 ? var30 = .030596508110850414 : input[242] > 1e-35 ? var30 = -.024085578702020216 : input[8] > 3198.5000000000005 ? input[297] > 1e-35 ? var30 = .09518584795377832 : var30 = -.018197744600833596 : input[13] > 1e-35 ? var30 = .006751790086127549 : input[148] > 1e-35 ? var30 = .01904174573618417 : input[99] > 1e-35 ? var30 = .025287735102561926 : input[4] > 14.500000000000002 ? var30 = -.004364337681643273 : input[1] > 15.500000000000002 ? input[35] > 1e-35 ? var30 = -.09467943982430241 : input[243] > 1e-35 ? var30 = -.02521824751996268 : var30 = .005437570718352172 : var30 = -.022476214821960674;
  let var31;
  input[0] > 384.50000000000006 ? input[84] > 1e-35 ? var31 = -.06088131453064195 : input[147] > 1e-35 ? var31 = -.05332792965930566 : input[135] > 1e-35 ? input[9] > 32.50000000000001 ? var31 = .04219361472548491 : var31 = -.07227529211725771 : input[10] > 4.500000000000001 ? input[21] > 1e-35 ? var31 = -.0787279848043689 : input[17] > 1e-35 ? input[3] > 18.500000000000004 ? input[188] > 1e-35 ? var31 = -.054347604504400286 : input[0] > 3544.5000000000005 ? input[0] > 5850.500000000001 ? var31 = -.11431764534511478 : var31 = .013549717238356157 : var31 = -.020987333767091276 : input[6] > 2.5000000000000004 ? var31 = -.02914877855133127 : var31 = .08483464900160231 : input[8] > 58.50000000000001 ? input[183] > 1e-35 ? var31 = -.10087072787978416 : input[37] > 1e-35 ? var31 = -.030467397753331196 : input[229] > 1e-35 ? var31 = -.1017559811057469 : input[4] > 20.500000000000004 ? var31 = -.00413177742240167 : input[20] > 1e-35 ? var31 = .05213315982685969 : var31 = .0037921635866823133 : input[8] > 51.50000000000001 ? var31 = .07327913092421544 : input[6] > 49.50000000000001 ? var31 = -.03457694284156811 : input[6] > 18.500000000000004 ? input[7] > 17.500000000000004 ? var31 = .02744420891894289 : var31 = .11288946357194463 : var31 = .003482908820966248 : input[18] > 1e-35 ? input[1] > 20.500000000000004 ? input[7] > 4.500000000000001 ? var31 = -.012329314369909049 : var31 = .026816658655600168 : var31 = -.0872405354618811 : var31 = .007872673500247845 : input[1] > 42.50000000000001 ? var31 = -.04309044198258254 : input[145] > 1e-35 ? var31 = .07572529147860785 : input[7] > 5.500000000000001 ? var31 = -.013837187093264945 : input[1] > 17.500000000000004 ? var31 = .04208698439539668 : var31 = -.06284346769019863;
  let var32;
  input[294] > 1e-35 ? var32 = -.0384794324818203 : input[266] > 1e-35 ? var32 = -.1087205883821061 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var32 = .07432960094940501 : var32 = -.035248735855751855 : input[134] > 1e-35 ? var32 = -.02456191365284949 : input[121] > 1e-35 ? input[0] > 4720.500000000001 ? input[1] > 39.50000000000001 ? var32 = -.01706896375068821 : var32 = .08212247914968074 : input[2] > 59.50000000000001 ? var32 = -.09546478958824225 : input[6] > 53.50000000000001 ? var32 = .12317082897575611 : input[1] > 56.50000000000001 ? input[4] > 7.500000000000001 ? input[0] > 3560.5000000000005 ? var32 = .02816463285971267 : var32 = .15449139016588445 : var32 = -.10199787406123524 : var32 = -.038068684323297096 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var32 = -.13924786681478077 : var32 = -.0072772442570213335 : input[39] > 1e-35 ? var32 = -.05392786531177836 : input[0] > 93.50000000000001 ? input[40] > 1e-35 ? var32 = -.054059371343144036 : input[306] > 1e-35 ? input[2] > 14.500000000000002 ? input[149] > 1e-35 ? var32 = -.11174465335620831 : var32 = .00013144040097180107 : var32 = -.08493919336681105 : input[42] > 1e-35 ? var32 = -.11078582572836196 : input[84] > 1e-35 ? input[4] > 17.500000000000004 ? var32 = -.015540659878839153 : var32 = -.14442609417300142 : input[21] > 1e-35 ? var32 = -.025251979447574083 : var32 = .0023698372645272847 : input[18] > 1e-35 ? var32 = .07269739695712212 : input[8] > 2592.5000000000005 ? var32 = -.1460388776448558 : input[9] > 30.500000000000004 ? input[1] > 23.500000000000004 ? var32 = -.01835130329646532 : input[9] > 45.50000000000001 ? var32 = .02023047454629885 : var32 = .16469378262221102 : var32 = -.042975030085836426;
  let var33;
  input[8] > 2915.5000000000005 ? input[297] > 1e-35 ? var33 = .06257393915394144 : input[0] > 93.50000000000001 ? input[4] > 1.5000000000000002 ? var33 = -.01034964686484714 : var33 = -.07357437440667927 : var33 = -.11987794734779106 : input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[0] > 3370.5000000000005 ? input[8] > 155.50000000000003 ? input[8] > 660.5000000000001 ? input[8] > 2134.5000000000005 ? var33 = -.09476398869062203 : input[9] > 72.50000000000001 ? var33 = -.0757383854264379 : var33 = .02806542779508718 : var33 = -.05147742568418084 : var33 = .10212721564444344 : var33 = .0518263760642861 : var33 = -.08743405377022222 : input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var33 = -.10669213185972036 : var33 = .027050434286384796 : input[302] > 1e-35 ? var33 = -.0407832394672723 : input[116] > 1e-35 ? input[10] > 38.50000000000001 ? var33 = .06354599160071946 : input[1] > 67.50000000000001 ? var33 = .05317447949011187 : var33 = -.059138165935307165 : input[212] > 1e-35 ? input[19] > 1e-35 ? var33 = -.09369289448773599 : input[0] > 2215.5000000000005 ? var33 = .04077965380363924 : input[0] > 807.5000000000001 ? var33 = -.0591771776458298 : var33 = .057315736906679376 : input[308] > 1e-35 ? input[1] > 52.50000000000001 ? input[5] > 3749.5000000000005 ? var33 = -.016323380219241672 : var33 = .007291062979527741 : input[210] > 1e-35 ? input[8] > 1641.5000000000002 ? var33 = .03720704290087811 : var33 = -.008730548158766654 : input[4] > 80.50000000000001 ? var33 = -.05346644687473197 : var33 = .014596824736762107 : input[218] > 1e-35 ? input[3] > 3.5000000000000004 ? var33 = .019984510398089086 : var33 = -.03917825025861855 : input[9] > 170.50000000000003 ? var33 = -.09759719821334525 : var33 = -.0023586682752856298;
  let var34;
  input[183] > 1e-35 ? input[17] > 1e-35 ? var34 = .030100940443356424 : input[10] > 1.5000000000000002 ? var34 = -.10861112216742408 : var34 = .017680668976453255 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[2] > 16.500000000000004 ? var34 = -.032062878390325456 : var34 = -.10808232631806887 : input[8] > 1641.5000000000002 ? var34 = -.06147013392655731 : input[4] > 12.500000000000002 ? var34 = .03324767551088266 : input[145] > 1e-35 ? var34 = .028851633810612017 : var34 = -.054871239091792784 : input[134] > 1e-35 ? var34 = -.023813968121342108 : input[266] > 1e-35 ? var34 = -.10037039667146351 : input[222] > 1e-35 ? input[0] > 612.5000000000001 ? input[10] > 1e-35 ? input[8] > 1939.5000000000002 ? var34 = -.055566877553100726 : input[2] > 24.500000000000004 ? input[8] > 182.50000000000003 ? input[10] > 43.50000000000001 ? input[10] > 55.50000000000001 ? var34 = -.025350325484720576 : var34 = .1579024598549572 : input[9] > 2.5000000000000004 ? input[0] > 3746.5000000000005 ? var34 = .056817276537534815 : var34 = -.07674158463557636 : var34 = -.06335553143454145 : input[1] > 56.50000000000001 ? var34 = .16390494217299284 : var34 = -.0027330160430847177 : input[10] > 36.50000000000001 ? input[8] > 1067.5000000000002 ? var34 = .041717597065890205 : var34 = -.10357913492269129 : input[10] > 29.500000000000004 ? var34 = .1365512866715726 : var34 = .020600048310575665 : var34 = .09708785634773187 : var34 = -.060427658852305666 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[6] > 24.500000000000004 ? input[8] > 1146.5000000000002 ? var34 = -.03146213719547347 : var34 = .11784024316238083 : var34 = -.050940520532045355 : var34 = -.047988344143075616 : input[191] > 1e-35 ? var34 = .028764654731460032 : var34 = .0011911575567860023;
  let var35;
  input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var35 = -.11630092297244568 : input[0] > 2432.5000000000005 ? input[0] > 4199.500000000001 ? var35 = -.05103908560370243 : var35 = .05002066201169583 : var35 = -.09976646725732496 : input[32] > 1e-35 ? input[0] > 4242.500000000001 ? var35 = -.0648838712201258 : input[5] > 3721.5000000000005 ? input[9] > 4.500000000000001 ? var35 = .127983140816313 : var35 = -.05436534163636867 : var35 = -.024514536544596455 : input[121] > 1e-35 ? input[0] > 4449.500000000001 ? input[4] > 9.500000000000002 ? var35 = -.009504203657088933 : input[8] > 819.5000000000001 ? var35 = .18689664822602375 : var35 = .03635576744011826 : var35 = -.029862411809998525 : input[223] > 1e-35 ? var35 = -.06474496692999487 : input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 46.50000000000001 ? var35 = -.09405026597863717 : input[0] > 4153.500000000001 ? var35 = .053577663326799765 : var35 = -.05062127873995668 : var35 = .06512222894425874 : input[39] > 1e-35 ? var35 = -.04985311717827547 : input[51] > 1e-35 ? var35 = -.04541229517934797 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[2] > 30.500000000000004 ? input[0] > 2151.5000000000005 ? var35 = -.02860634573675884 : var35 = .08863753005590103 : var35 = .11158892111063744 : input[0] > 655.5000000000001 ? var35 = -.031005736641654926 : var35 = -.1439827004505974 : input[222] > 1e-35 ? input[1] > 11.500000000000002 ? input[0] > 612.5000000000001 ? var35 = -.00843386136334982 : var35 = -.05273594615999777 : var35 = .1060183822015004 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[8] > 719.5000000000001 ? var35 = -.015774115523598486 : var35 = .10147367091236065 : var35 = -.048307000563071016 : var35 = .002118376117677254;
  let var36;
  input[8] > 1014.5000000000001 ? input[9] > 137.50000000000003 ? var36 = -.10279096288817871 : input[0] > 93.50000000000001 ? input[8] > 1067.5000000000002 ? input[227] > 1e-35 ? var36 = -.03544332389470493 : input[285] > 1e-35 ? input[9] > 64.50000000000001 ? var36 = .07211107542565391 : var36 = -.041556776020476104 : input[145] > 1e-35 ? input[1] > 66.50000000000001 ? var36 = -.0751486415451188 : input[1] > 59.50000000000001 ? var36 = .13459005084554104 : var36 = .024184371850147466 : input[0] > 3072.5000000000005 ? input[95] > 1e-35 ? var36 = .06715575425741895 : var36 = -.005895690393702183 : input[8] > 2915.5000000000005 ? var36 = -.010205039411753762 : input[9] > 33.50000000000001 ? input[9] > 47.50000000000001 ? var36 = -.00029068886245881074 : var36 = .0613467393188786 : input[148] > 1e-35 ? var36 = -.06074463294936236 : input[3] > 1.5000000000000002 ? input[5] > 1849.5000000000002 ? input[1] > 15.500000000000002 ? var36 = .003887223773199377 : var36 = -.08553893131979015 : var36 = .025654192706396767 : var36 = -.05651733979610658 : var36 = -.02039913645229667 : input[2] > 7.500000000000001 ? var36 = -.1058450646728524 : var36 = .02267192191610376 : input[1] > 120.50000000000001 ? input[2] > 60.50000000000001 ? var36 = -.12304707569000428 : input[1] > 132.50000000000003 ? input[6] > 41.50000000000001 ? var36 = .1283258201586378 : var36 = -.01718135372229775 : var36 = -.07702452408491414 : input[125] > 1e-35 ? var36 = -.0804612900572707 : input[178] > 1e-35 ? input[0] > 4533.500000000001 ? var36 = .04273051857848212 : var36 = -.04533122948101463 : input[2] > 196.50000000000003 ? var36 = -.10543331044088727 : input[94] > 1e-35 ? input[5] > 4532.500000000001 ? var36 = .0231032972703664 : var36 = -.04807386814498683 : var36 = .002729435991332102;
  let var37;
  input[179] > 1e-35 ? var37 = -.08065315471211375 : input[183] > 1e-35 ? input[17] > 1e-35 ? var37 = .026484626664041125 : input[10] > 1.5000000000000002 ? var37 = -.10187000872941615 : var37 = .015274190652133752 : input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var37 = .09574540795390041 : var37 = -.06454986703691233 : var37 = -.11411849349353141 : input[266] > 1e-35 ? var37 = -.09281838517322076 : input[32] > 1e-35 ? input[8] > 2302.5000000000005 ? var37 = .06685250330182936 : input[4] > 67.50000000000001 ? input[2] > 97.50000000000001 ? var37 = -.04403391373512386 : var37 = .1132928075412222 : input[2] > 47.50000000000001 ? var37 = -.09700191391838056 : var37 = -.02147184357182825 : input[10] > 4.500000000000001 ? input[21] > 1e-35 ? var37 = -.0735617817957859 : input[17] > 1e-35 ? input[3] > 18.500000000000004 ? var37 = -.001668912999010927 : var37 = -.02363511102970245 : input[8] > 58.50000000000001 ? var37 = -.00035213368294640616 : input[3] > 17.500000000000004 ? input[2] > 28.500000000000004 ? input[10] > 23.500000000000004 ? input[1] > 38.50000000000001 ? var37 = .0911011436534449 : input[1] > 28.500000000000004 ? var37 = -.07192390493729035 : var37 = .06913818091291246 : var37 = -.012312625373699222 : var37 = .06784496312307986 : var37 = -167756936027735e-19 : input[18] > 1e-35 ? input[8] > 302.50000000000006 ? var37 = .0026564453057705273 : var37 = -.025425772389361445 : input[122] > 1e-35 ? var37 = -.12046786388602149 : input[0] > 3183.5000000000005 ? var37 = .01162092842804907 : input[91] > 1e-35 ? var37 = .07000265526928563 : input[1] > 22.500000000000004 ? input[0] > 576.5000000000001 ? var37 = -.0001647792543020228 : var37 = -.023664538532907665 : var37 = .01609078206180752;
  let var38;
  input[294] > 1e-35 ? input[1] > 26.500000000000004 ? input[0] > 4141.500000000001 ? var38 = -.051473645433684705 : input[0] > 3030.5000000000005 ? input[1] > 51.50000000000001 ? var38 = -.017696526862422682 : var38 = .1450050954613223 : var38 = -.05406930069823832 : var38 = -.08308700260259043 : input[120] > 1e-35 ? var38 = .058316269489189415 : input[297] > 1e-35 ? input[94] > 1e-35 ? var38 = -.07425512495167255 : input[8] > 51.50000000000001 ? input[1] > 13.500000000000002 ? input[1] > 33.50000000000001 ? input[19] > 1e-35 ? input[0] > 4498.500000000001 ? var38 = .038431826961746934 : var38 = -.05937462906539856 : input[9] > 65.50000000000001 ? var38 = .10814845712507865 : input[4] > 9.500000000000002 ? input[2] > 22.500000000000004 ? input[1] > 39.50000000000001 ? input[1] > 44.50000000000001 ? input[10] > 44.50000000000001 ? var38 = .12297945639231944 : input[0] > 3796.5000000000005 ? input[4] > 26.500000000000004 ? var38 = -.09579030954062734 : var38 = .025064711572811746 : var38 = .02579440518821548 : var38 = .1044440128091862 : var38 = -.058348633139536844 : var38 = .07766788227934436 : var38 = -.01021229539092708 : input[2] > 2.5000000000000004 ? input[10] > 29.500000000000004 ? input[0] > 3770.5000000000005 ? input[0] > 4438.500000000001 ? var38 = .07463684068207214 : var38 = .18244269035484484 : input[6] > 39.50000000000001 ? var38 = -.06050050067471004 : var38 = .05787759066913493 : var38 = .010783225857972171 : var38 = .1674891243602606 : input[4] > 9.500000000000002 ? var38 = -.004814132027475892 : var38 = -.14543299413454813 : var38 = -.02935093398687923 : input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[8] > 1218.5000000000002 ? var38 = -.07634466313617769 : var38 = .0287825335169114 : var38 = -.06894721943300268 : var38 = -.00023988459059521937;
  let var39;
  input[131] > 1e-35 ? input[1] > 93.50000000000001 ? var39 = -.05706887458825395 : input[2] > 1.5000000000000002 ? var39 = .011446637886629108 : var39 = -.10616119878749211 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[0] > 4977.500000000001 ? var39 = .08424281276381033 : input[3] > 17.500000000000004 ? input[20] > 1e-35 ? var39 = .11146885439601915 : input[8] > 61.50000000000001 ? input[0] > 3530.5000000000005 ? input[9] > 48.50000000000001 ? input[9] > 61.50000000000001 ? var39 = .026278724448495064 : var39 = .17053138400480508 : input[0] > 4463.500000000001 ? var39 = -.06482289890096041 : var39 = .03026516489536295 : var39 = -.031785170717683144 : var39 = .1312690622980455 : input[13] > 1e-35 ? var39 = .14336922540461444 : var39 = .03523850945454039 : var39 = -.015407465968975714 : input[39] > 1e-35 ? var39 = -.054809635385158186 : input[32] > 1e-35 ? input[0] > 4242.500000000001 ? var39 = -.0659975068798723 : var39 = -.008386582621403979 : input[4] > 60.50000000000001 ? input[10] > 75.50000000000001 ? input[3] > 107.50000000000001 ? var39 = -.04225314193574262 : input[3] > 70.50000000000001 ? input[1] > 29.500000000000004 ? var39 = .057409156184759516 : var39 = .2024322059866388 : var39 = -.030670938454461245 : input[10] > 1e-35 ? input[0] > 4733.500000000001 ? var39 = .010648654146284154 : input[308] > 1e-35 ? var39 = .008728141696325391 : input[4] > 64.50000000000001 ? input[298] > 1e-35 ? var39 = .12364025998551711 : var39 = -.02247495081065243 : input[1] > 22.500000000000004 ? var39 = -.0726295464624251 : var39 = .03481895086048152 : input[0] > 4331.500000000001 ? var39 = -.04775443357020673 : var39 = .07172377425057568 : input[2] > 89.50000000000001 ? var39 = -.11782645274716962 : var39 = .00010092665257989378;
  let var40;
  input[147] > 1e-35 ? var40 = -.041560228567115574 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var40 = .062292114082780084 : input[10] > 5.500000000000001 ? input[7] > 22.500000000000004 ? var40 = -.016101990375700172 : input[0] > 2579.5000000000005 ? var40 = -.13045089661551845 : var40 = -.02874367814784938 : var40 = .025835149631944995 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var40 = .17084176915326055 : var40 = -.019195947948312853 : input[222] > 1e-35 ? input[30] > 1e-35 ? input[1] > 36.50000000000001 ? input[8] > 45.50000000000001 ? input[8] > 578.5000000000001 ? input[1] > 67.50000000000001 ? var40 = .10591712319944074 : var40 = -.024082167264285 : var40 = .16497698867036126 : var40 = -.04985066326861431 : input[0] > 1937.5000000000002 ? input[2] > 16.500000000000004 ? var40 = -.021012910475524206 : var40 = -.13058422554298485 : input[0] > 1102.5000000000002 ? var40 = .10955864175201457 : var40 = -.03566689354348996 : input[1] > 11.500000000000002 ? var40 = -.02093884208606101 : var40 = .09107244766183857 : input[126] > 1e-35 ? input[10] > 32.50000000000001 ? input[8] > 719.5000000000001 ? var40 = -.013861861436128482 : var40 = .09756849802202777 : input[224] > 1e-35 ? input[1] > 51.50000000000001 ? var40 = .10163873449625677 : var40 = -.02779270277623805 : input[1] > 26.500000000000004 ? var40 = -.08035058228527389 : var40 = .0005719695099064484 : input[191] > 1e-35 ? input[9] > 9.500000000000002 ? var40 = -.007028075523033826 : var40 = .0489470913925288 : input[1] > 61.50000000000001 ? input[132] > 1e-35 ? var40 = .11230846723576784 : input[0] > 350.50000000000006 ? input[2] > 1.5000000000000002 ? var40 = -.0032075580718124892 : var40 = -.04442829143298883 : var40 = -.06597073245775804 : var40 = .0015594090939337751;
  let var41;
  input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var41 = -.12803889879260094 : var41 = .002171373740016862 : input[121] > 1e-35 ? input[0] > 4720.500000000001 ? input[217] > 1e-35 ? var41 = .08967966612917375 : input[1] > 39.50000000000001 ? var41 = -.059791671514498074 : var41 = .05648934961902822 : input[2] > 59.50000000000001 ? var41 = -.08633234097449628 : input[6] > 53.50000000000001 ? var41 = .11140345067444689 : input[1] > 56.50000000000001 ? input[4] > 7.500000000000001 ? input[0] > 3560.5000000000005 ? var41 = .025606129643140924 : var41 = .13835395886271978 : var41 = -.09361630641448024 : input[4] > 7.500000000000001 ? input[1] > 26.500000000000004 ? input[1] > 49.50000000000001 ? var41 = -.09975506556937946 : input[10] > 36.50000000000001 ? var41 = -.09427724661655643 : input[10] > 24.500000000000004 ? var41 = .07329330653410447 : var41 = -.02271182965807972 : var41 = -.09767874967639482 : input[6] > 13.500000000000002 ? input[10] > 23.500000000000004 ? var41 = -.05082091374050816 : var41 = .1687114435254966 : input[0] > 2314.5000000000005 ? var41 = -.06422664016383926 : var41 = .0636688376664789 : input[298] > 1e-35 ? input[9] > 12.500000000000002 ? input[133] > 1e-35 ? var41 = -.06857762517406195 : input[9] > 71.50000000000001 ? input[0] > 4188.500000000001 ? var41 = -.1274167728754332 : var41 = .01308079126447365 : input[4] > 73.50000000000001 ? var41 = .13854015371106546 : input[4] > 48.50000000000001 ? var41 = -.03684255740123261 : input[6] > 45.50000000000001 ? var41 = .10329912215813097 : input[10] > 77.50000000000001 ? var41 = -.08630788656925215 : var41 = .031022006843800853 : input[1] > 25.500000000000004 ? var41 = -.08278381528048026 : var41 = .06664374548141594 : input[84] > 1e-35 ? var41 = -.05624227409079396 : var41 = .00012184182357340415;
  let var42;
  input[179] > 1e-35 ? var42 = -.07443348719246982 : input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var42 = -.07595415373151816 : var42 = .054065040429292326 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[2] > 13.500000000000002 ? input[0] > 1187.5000000000002 ? var42 = .022822510448266862 : var42 = .17491569312933697 : var42 = -.058362287133533565 : input[2] > 2.5000000000000004 ? var42 = -.03633895806364428 : var42 = .06397808186120692 : input[8] > 4968.500000000001 ? input[1] > 31.500000000000004 ? var42 = -.07294848747514579 : var42 = .025053613105805606 : input[230] > 1e-35 ? input[4] > 6.500000000000001 ? input[107] > 1e-35 ? var42 = -.07009535282685533 : input[8] > 2640.0000000000005 ? var42 = -.051761240111316276 : input[131] > 1e-35 ? var42 = -.06245774419231631 : var42 = .03495606662854905 : var42 = -.013863522184803188 : input[131] > 1e-35 ? input[1] > 93.50000000000001 ? input[1] > 105.50000000000001 ? var42 = .0015036626973581122 : var42 = -.12505706794835883 : input[1] > 48.50000000000001 ? input[276] > 1e-35 ? var42 = .10435171369790015 : input[0] > 5026.500000000001 ? input[0] > 5308.500000000001 ? var42 = .022343994371919224 : var42 = -.14087991797693533 : input[8] > 1323.5000000000002 ? input[10] > 49.50000000000001 ? var42 = .07724450228328664 : input[0] > 3853.5000000000005 ? var42 = -.15671707454435677 : input[10] > 28.500000000000004 ? var42 = -.10179090671841723 : var42 = .014878216919760927 : var42 = .03967665658164865 : input[8] > 2696.5000000000005 ? input[15] > 1e-35 ? var42 = .14054154485273487 : var42 = .01821247272493051 : input[2] > 5.500000000000001 ? input[2] > 100.50000000000001 ? var42 = -.08632985141410315 : var42 = .005524157938954954 : var42 = -.08802502622523681 : var42 = -.0004649168897260341;
  let var43;
  input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 32.50000000000001 ? input[4] > 16.500000000000004 ? var43 = -.007458687464321174 : var43 = -.09444966249102484 : input[1] > 23.500000000000004 ? var43 = .08564129697360716 : var43 = -.07105002902845851 : var43 = .05688756955238231 : input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var43 = -.10326216566705966 : input[1] > 26.500000000000004 ? var43 = .0050539832484585365 : var43 = -.07080395606126953 : input[306] > 1e-35 ? input[149] > 1e-35 ? var43 = -.10399433201474328 : input[2] > 14.500000000000002 ? input[9] > 6.500000000000001 ? var43 = .05783632021087773 : input[10] > 17.500000000000004 ? var43 = -.06720598671764105 : input[1] > 47.50000000000001 ? var43 = .097495825172558 : var43 = -.013372242800584872 : var43 = -.06463226787713715 : input[42] > 1e-35 ? var43 = -.0885725817597767 : input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var43 = -.07496598696848249 : input[1] > 29.500000000000004 ? input[8] > 446.50000000000006 ? var43 = .11051270080118503 : var43 = .027719462817590454 : input[8] > 597.5000000000001 ? var43 = -.08441503592016869 : var43 = .05534229430302502 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var43 = -.12190088985091102 : var43 = -.0067442838156576345 : input[148] > 1e-35 ? input[9] > 79.50000000000001 ? var43 = .09225972475904022 : input[2] > 10.500000000000002 ? input[1] > 102.50000000000001 ? var43 = .11805676536334647 : input[8] > 1726.5000000000002 ? input[9] > 10.500000000000002 ? var43 = .016585157185448045 : var43 = -.11032043771149425 : var43 = .01586986028570486 : input[8] > 388.50000000000006 ? var43 = -.10592413013261853 : var43 = .04930703248769364 : input[13] > 1e-35 ? var43 = .003621937787920821 : var43 = -.0013786331198611841;
  let var44;
  input[145] > 1e-35 ? input[1] > 32.50000000000001 ? input[1] > 38.50000000000001 ? input[10] > 55.50000000000001 ? input[1] > 54.50000000000001 ? var44 = .009769895322846493 : var44 = -.10620052926943656 : input[9] > 19.500000000000004 ? var44 = .03781202525403449 : input[9] > 14.500000000000002 ? var44 = -.11485785321365344 : input[9] > 6.500000000000001 ? var44 = .07677177833073881 : input[0] > 4342.500000000001 ? var44 = -.07079285609687631 : input[49] > 1e-35 ? var44 = .06156814809246001 : var44 = -.014788509042554625 : var44 = -.032659201618470655 : input[5] > 5207.500000000001 ? var44 = -.09013500825185713 : input[3] > 10.500000000000002 ? input[8] > 1787.5000000000002 ? var44 = -.03094160322187924 : input[1] > 29.500000000000004 ? var44 = .09474646043921069 : var44 = .023445783928231618 : var44 = .09342846694174194 : input[0] > 533.5000000000001 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var44 = -.07164443768784848 : input[1] > 29.500000000000004 ? var44 = .089473622509272 : input[8] > 597.5000000000001 ? var44 = -.08155349903101317 : var44 = .07098423265024251 : input[8] > 691.5000000000001 ? input[5] > 2252.5000000000005 ? var44 = -.004003900679358653 : input[190] > 1e-35 ? var44 = -.09236113461485262 : input[8] > 3198.5000000000005 ? var44 = -.0124130160451179 : var44 = .018453070064009328 : input[15] > 1e-35 ? var44 = .012013209112857824 : input[7] > 4.500000000000001 ? input[7] > 5.500000000000001 ? var44 = -.0009580759587680961 : var44 = -.03227283036698222 : var44 = .01369287669536875 : input[1] > 50.50000000000001 ? var44 = -.04213060332500437 : input[35] > 1e-35 ? var44 = -.11508095777767471 : input[190] > 1e-35 ? var44 = -.08611884672400155 : input[297] > 1e-35 ? var44 = .05723551879433584 : var44 = -.004829340082311461;
  let var45;
  input[183] > 1e-35 ? var45 = -.037994150023203555 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[3] > 20.500000000000004 ? input[10] > 36.50000000000001 ? var45 = -.11753465135886734 : var45 = -.007515490299047085 : var45 = -.08576941990777916 : input[8] > 1641.5000000000002 ? input[10] > 37.50000000000001 ? var45 = -.12371142493530439 : input[1] > 36.50000000000001 ? var45 = .032189417575190435 : var45 = -.10339125953022954 : input[3] > 32.50000000000001 ? input[4] > 27.500000000000004 ? input[1] > 59.50000000000001 ? var45 = -.0784518658439288 : input[2] > 54.50000000000001 ? var45 = .12477882322370665 : var45 = .000313468482399738 : var45 = .12261955132611434 : input[8] > 81.50000000000001 ? input[23] > 1e-35 ? var45 = .04969252946760318 : input[8] > 511.50000000000006 ? input[8] > 1146.5000000000002 ? var45 = .0353146070135579 : var45 = -.06327619611098285 : var45 = .02813577701641991 : var45 = -.12354390728506215 : input[34] > 1e-35 ? var45 = -.07664408516055397 : input[3] > 99.50000000000001 ? input[1] > 16.500000000000004 ? input[1] > 26.500000000000004 ? var45 = -.01245803535276381 : var45 = -.07169472553475001 : input[1] > 11.500000000000002 ? var45 = .12989984824561698 : var45 = -.01201544398886606 : input[6] > 91.50000000000001 ? input[1] > 22.500000000000004 ? var45 = .010390226893521422 : input[10] > 14.500000000000002 ? var45 = .16790888126487719 : var45 = .010614982228955577 : input[4] > 79.50000000000001 ? input[9] > 44.50000000000001 ? input[0] > 3853.5000000000005 ? var45 = -.043398307129729134 : var45 = .09963544907820426 : input[9] > 30.500000000000004 ? var45 = -.13540713124984502 : input[9] > 17.500000000000004 ? var45 = .0509435850590757 : var45 = -.04761897852404613 : input[4] > 78.50000000000001 ? var45 = .09197086656470652 : var45 = .0006771050176682337;
  let var46;
  input[122] > 1e-35 ? input[6] > 36.50000000000001 ? var46 = .05686884451670743 : var46 = -.05334759543084309 : input[266] > 1e-35 ? var46 = -.08603579519816038 : input[157] > 1e-35 ? var46 = -.06736746113382097 : input[302] > 1e-35 ? input[0] > 2579.5000000000005 ? var46 = -.0499592651503952 : input[0] > 725.5000000000001 ? var46 = .11780353905132664 : var46 = -.05232097173108943 : input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var46 = -.11398297342629615 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var46 = -.03190157229022304 : var46 = .07985197845805492 : var46 = -.0763078988943886 : input[4] > 41.50000000000001 ? input[280] > 1e-35 ? var46 = .05162933940904835 : input[11] > 1e-35 ? input[0] > 460.50000000000006 ? var46 = -.027174047777029083 : var46 = .057117284879796476 : input[3] > 43.50000000000001 ? var46 = -.0016147040913107311 : var46 = -.05856597304613519 : input[2] > 45.50000000000001 ? input[0] > 4663.500000000001 ? input[18] > 1e-35 ? var46 = -.04779247091640426 : input[10] > 25.500000000000004 ? input[9] > 22.500000000000004 ? input[22] > 1e-35 ? var46 = -.01466076988151239 : var46 = .13375695925484857 : var46 = -.04885873081899647 : input[0] > 5566.500000000001 ? var46 = .11086813028591343 : input[8] > 992.5000000000001 ? var46 = -.07622304217072383 : var46 = .04316019272026325 : input[10] > 12.500000000000002 ? input[9] > 36.50000000000001 ? input[9] > 45.50000000000001 ? var46 = .03285858361708423 : var46 = -.12354858211764992 : var46 = .0672788301823281 : input[15] > 1e-35 ? var46 = .08658836986585006 : var46 = -.02741484278509758 : input[290] > 1e-35 ? var46 = -.08161310335133287 : input[135] > 1e-35 ? var46 = -.04824156054814152 : var46 = .0009156904299554183;
  let var47;
  input[3] > 7.500000000000001 ? var47 = .0006791852818377787 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var47 = .03642374718166293 : var47 = .16379973756366603 : var47 = -.03946685266127979 : input[186] > 1e-35 ? var47 = .07618896623420895 : input[96] > 1e-35 ? var47 = .0680272261319657 : input[107] > 1e-35 ? input[1] > 48.50000000000001 ? var47 = -.022822371600847505 : var47 = .0501405836324949 : input[203] > 1e-35 ? input[1] > 77.50000000000001 ? var47 = .044416424920571296 : var47 = -.0648450593196238 : input[5] > 3921.5000000000005 ? input[1] > 110.50000000000001 ? var47 = -.11110466767595227 : input[9] > 5.500000000000001 ? input[9] > 52.50000000000001 ? input[1] > 50.50000000000001 ? var47 = .1061937286809567 : input[7] > 54.50000000000001 ? var47 = .11487507743121311 : input[8] > 819.5000000000001 ? var47 = -.07181278009001418 : input[10] > 25.500000000000004 ? var47 = .13499019430369633 : input[1] > 31.500000000000004 ? var47 = .09032979489780704 : var47 = -.12754166393372374 : input[9] > 37.50000000000001 ? var47 = -.05093963635361407 : var47 = -.005026651151683848 : input[9] > 2.5000000000000004 ? var47 = .07619735785573735 : var47 = .012363301341532136 : input[26] > 1e-35 ? var47 = -.10685800454968203 : input[8] > 125.50000000000001 ? input[8] > 446.50000000000006 ? input[0] > 3842.5000000000005 ? var47 = -.08783796894105043 : input[282] > 1e-35 ? input[1] > 47.50000000000001 ? input[9] > 40.50000000000001 ? var47 = -.10764172927882483 : var47 = .01890760098464703 : var47 = .06573095405846417 : input[8] > 634.5000000000001 ? var47 = -.00783575973273707 : var47 = -.050612689680229306 : input[1] > 22.500000000000004 ? var47 = -.0016842490401359626 : var47 = .0738227088444087 : var47 = -.02663970950432175;
  let var48;
  input[31] > 1e-35 ? input[8] > 17.500000000000004 ? var48 = .013678038624884814 : input[1] > 35.50000000000001 ? input[1] > 51.50000000000001 ? var48 = .007191286124908192 : var48 = -.09347881647636902 : input[10] > 1.5000000000000002 ? var48 = .07938758708008091 : var48 = -.008702935600305113 : input[224] > 1e-35 ? input[149] > 1e-35 ? input[13] > 1e-35 ? var48 = .12321804057595996 : var48 = -.018281109320672437 : input[23] > 1e-35 ? input[4] > 62.50000000000001 ? var48 = -.04644244754790671 : var48 = .024546310702263208 : input[8] > 862.5000000000001 ? input[0] > 3429.5000000000005 ? input[4] > 9.500000000000002 ? input[52] > 1e-35 ? var48 = .0706108609273337 : input[2] > 40.50000000000001 ? var48 = -.028046629962303716 : var48 = -.06497613993109329 : var48 = .01076489668586676 : input[1] > 33.50000000000001 ? input[0] > 966.5000000000001 ? input[2] > 14.500000000000002 ? input[1] > 38.50000000000001 ? var48 = -.03056331974267756 : var48 = -.11886389712497057 : var48 = .053364962175658184 : input[8] > 2233.5000000000005 ? var48 = -.0448152521157682 : var48 = .1508651602190868 : input[2] > 33.50000000000001 ? input[0] > 2882.5000000000005 ? input[0] > 3183.5000000000005 ? var48 = .03818796510453344 : var48 = .23673992112982362 : var48 = .02858814226507374 : input[10] > 44.50000000000001 ? var48 = -.1125863771551199 : var48 = .009129996952394916 : input[1] > 7.500000000000001 ? var48 = -.004374525302461639 : var48 = -.07858519434925451 : input[149] > 1e-35 ? input[6] > 23.500000000000004 ? var48 = .0005231594491642136 : input[0] > 4053.5000000000005 ? input[8] > 660.5000000000001 ? var48 = -.13677189943034931 : input[10] > 2.5000000000000004 ? var48 = .039591891437078086 : var48 = -.09312596849507347 : var48 = -.02423172142089822 : var48 = .0009836986075266283;
  let var49;
  input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var49 = -.103183298350443 : input[2] > 51.50000000000001 ? var49 = .09784373530929913 : input[10] > 26.500000000000004 ? input[8] > 764.5000000000001 ? var49 = -.05186168947388339 : var49 = .0496996365539082 : input[10] > 23.500000000000004 ? var49 = .1404445738719 : input[93] > 1e-35 ? var49 = .0027146310074558505 : input[5] > 3821.5000000000005 ? var49 = .002153033152069652 : input[4] > 2.5000000000000004 ? var49 = .007663539551317215 : var49 = .13902616832015402 : input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[4] > 64.50000000000001 ? var49 = .11498405722487515 : input[2] > 23.500000000000004 ? input[0] > 2815.5000000000005 ? input[2] > 44.50000000000001 ? input[4] > 42.50000000000001 ? var49 = -.021479467709980358 : var49 = .09336868994327292 : input[1] > 22.500000000000004 ? input[15] > 1e-35 ? var49 = .021660293256233334 : var49 = -.0927396152303864 : var49 = .0665074081601698 : input[0] > 1550.5000000000002 ? var49 = .08972407105958534 : var49 = -.0380796411182682 : input[6] > 13.500000000000002 ? input[10] > 2.5000000000000004 ? var49 = .06761927942466854 : var49 = -.015762168112653286 : input[17] > 1e-35 ? var49 = .10311304131145381 : var49 = -.017672785252336027 : var49 = -.08629805732772755 : input[1] > 24.500000000000004 ? input[138] > 1e-35 ? var49 = -.10638321435298535 : var49 = .0007073011744385905 : input[18] > 1e-35 ? var49 = -.027056185501334325 : input[145] > 1e-35 ? var49 = .023191199677450886 : input[9] > 33.50000000000001 ? input[201] > 1e-35 ? var49 = .09762140519655171 : input[9] > 110.50000000000001 ? var49 = -.06581942957595835 : input[6] > 54.50000000000001 ? var49 = .04959634035251596 : var49 = .0022616298654554207 : var49 = -.007437620924990854;
  let var50;
  input[179] > 1e-35 ? var50 = -.06961998209988884 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var50 = .1470294450403005 : var50 = -.01671476793947083 : input[187] > 1e-35 ? input[6] > 13.500000000000002 ? input[4] > 30.500000000000004 ? input[13] > 1e-35 ? var50 = .07448480853603114 : input[0] > 1012.5000000000001 ? input[5] > 2883.5000000000005 ? input[0] > 3682.5000000000005 ? input[5] > 4031.5000000000005 ? input[23] > 1e-35 ? var50 = .07965955447707423 : input[10] > 10.500000000000002 ? var50 = -.09236156404262426 : var50 = .03396273196231458 : var50 = -.13246465021467432 : var50 = .07092822261735353 : var50 = -.08753829085942 : var50 = .09409024840640956 : input[1] > 40.50000000000001 ? input[8] > 984.5000000000001 ? input[8] > 1514.5000000000002 ? input[8] > 2134.5000000000005 ? var50 = .004705878789890202 : var50 = .13775378964952867 : var50 = -.04770928980587811 : input[10] > 29.500000000000004 ? var50 = .011221519891071544 : input[0] > 3853.5000000000005 ? var50 = .06365381191628273 : var50 = .15506252245336827 : input[1] > 37.50000000000001 ? var50 = -.07254777021042061 : var50 = .026514587757252385 : input[308] > 1e-35 ? var50 = .04115804816617256 : input[10] > 26.500000000000004 ? var50 = .02077721353011946 : input[5] > 3548.5000000000005 ? var50 = -.1280907116663952 : var50 = -.021974774274438 : input[306] > 1e-35 ? var50 = -.02700446558079895 : input[297] > 1e-35 ? input[212] > 1e-35 ? var50 = .07794139136748461 : input[7] > 5.500000000000001 ? input[19] > 1e-35 ? var50 = -.005710865560475598 : input[94] > 1e-35 ? var50 = -.06751507982853555 : var50 = .027250040757588703 : input[9] > 52.50000000000001 ? var50 = .07060357924595577 : var50 = -.030297760713011795 : var50 = -.0006005400085266517;
  let var51;
  input[113] > 1e-35 ? var51 = -.07311041707507712 : input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var51 = -.06996356565314456 : var51 = .04780211300352931 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var51 = -.08317707559926495 : input[21] > 1e-35 ? var51 = -.0817284654645976 : input[15] > 1e-35 ? input[2] > 3.5000000000000004 ? var51 = -.010538203005984922 : var51 = .08454819465349446 : input[9] > 124.50000000000001 ? var51 = .09015659250299132 : input[7] > 15.500000000000002 ? input[5] > 5732.500000000001 ? var51 = -.08542251249346582 : input[9] > 50.50000000000001 ? var51 = -.023428882537657472 : var51 = .010042500833979073 : var51 = .020697210754240154 : input[10] > 28.500000000000004 ? input[5] > 423.00000000000006 ? input[148] > 1e-35 ? var51 = .03006025206979096 : input[9] > 108.50000000000001 ? var51 = -.09153851322499747 : input[145] > 1e-35 ? input[5] > 4814.500000000001 ? input[2] > 38.50000000000001 ? var51 = .04222035773042132 : var51 = -.09078149053947535 : input[8] > 568.5000000000001 ? input[1] > 64.50000000000001 ? var51 = -.07209095448054853 : var51 = .028065954981903313 : var51 = .08714651929917122 : var51 = -.006678820669279169 : input[10] > 40.50000000000001 ? var51 = .006982396294941626 : var51 = -.07889649792011418 : input[94] > 1e-35 ? input[4] > 30.500000000000004 ? var51 = -.09351114982645548 : input[4] > 3.5000000000000004 ? var51 = -.004837550129223451 : var51 = -.08324141237464677 : input[303] > 1e-35 ? var51 = .10703037493990825 : input[9] > 156.50000000000003 ? var51 = -.10803018621648303 : input[116] > 1e-35 ? var51 = -.03208302566598311 : input[212] > 1e-35 ? input[243] > 1e-35 ? var51 = .10261721665006701 : var51 = .018994509090668264 : var51 = .0011244262442038839;
  let var52;
  input[86] > 1e-35 ? input[8] > 65.50000000000001 ? input[1] > 46.50000000000001 ? var52 = -.08404263465005328 : input[0] > 3682.5000000000005 ? var52 = .041259223920298876 : input[1] > 29.500000000000004 ? var52 = -.09541257493441671 : var52 = .001482192721625409 : var52 = .051541427372951004 : input[3] > 7.500000000000001 ? input[157] > 1e-35 ? var52 = -.08268996098437432 : input[230] > 1e-35 ? var52 = .015749498159959817 : input[4] > 7.500000000000001 ? input[3] > 11.500000000000002 ? var52 = -913218977737457e-19 : input[4] > 10.500000000000002 ? var52 = -.056334165674005156 : input[127] > 1e-35 ? var52 = -.0784634021824036 : input[2] > 9.500000000000002 ? input[1] > 62.50000000000001 ? var52 = -.04231200150318989 : input[10] > 42.50000000000001 ? var52 = .10182973257894812 : var52 = .015934763950068445 : var52 = -.03130938805859397 : input[92] > 1e-35 ? input[4] > 6.500000000000001 ? input[1] > 51.50000000000001 ? input[9] > 19.500000000000004 ? var52 = -.041117068322885315 : var52 = .1167767830037126 : var52 = .13611206992387337 : input[10] > 41.50000000000001 ? var52 = -.07120286010564107 : var52 = .022032788063345417 : input[8] > 1.5000000000000002 ? input[1] > 51.50000000000001 ? input[9] > 72.50000000000001 ? var52 = -.07702290997669524 : input[198] > 1e-35 ? var52 = .08776558554437136 : var52 = -.008290740324975692 : input[2] > 32.50000000000001 ? var52 = .07198457624219955 : var52 = .005463113714361629 : var52 = .09414099512900526 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var52 = .03295785445437507 : var52 = .15140250150674536 : var52 = -.035613213948910254 : input[186] > 1e-35 ? var52 = .06849425535860769 : input[96] > 1e-35 ? var52 = .06028225812727254 : var52 = -.007582543288662308;
  let var53;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var53 = .08396556264106572 : var53 = -.0562516995099192 : var53 = -.10593011018789432 : input[183] > 1e-35 ? input[15] > 1e-35 ? var53 = -.09705176473553752 : input[7] > 18.500000000000004 ? input[2] > 37.50000000000001 ? var53 = .0052017514017035915 : var53 = -.11194119432743639 : var53 = .03724337696163019 : input[227] > 1e-35 ? input[17] > 1e-35 ? input[2] > 16.500000000000004 ? var53 = -.025692451287403446 : var53 = -.09511862672123193 : input[8] > 1661.5000000000002 ? input[10] > 37.50000000000001 ? var53 = -.11892250746801664 : input[10] > 22.500000000000004 ? var53 = .07548493166973796 : var53 = -.05973048107712209 : input[4] > 12.500000000000002 ? input[0] > 4319.500000000001 ? input[10] > 4.500000000000001 ? input[10] > 37.50000000000001 ? var53 = .13750699058082427 : input[18] > 1e-35 ? var53 = .06535408879552801 : var53 = -.054118179035040674 : var53 = .1344282838979622 : input[0] > 3982.5000000000005 ? var53 = -.10409582202467015 : input[19] > 1e-35 ? var53 = .12672850705810795 : input[8] > 587.5000000000001 ? input[1] > 35.50000000000001 ? var53 = .012705935670766466 : var53 = .14149359442527545 : var53 = -.047977876173706004 : input[20] > 1e-35 ? var53 = .057945228080337946 : input[0] > 3642.5000000000005 ? var53 = -.008726535792122467 : var53 = -.08424769891378858 : input[34] > 1e-35 ? var53 = -.0699329538228602 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[4] > 15.500000000000002 ? input[0] > 1187.5000000000002 ? var53 = .01196849566739346 : var53 = .1614642278429876 : var53 = -.043022338150701625 : input[3] > 5.500000000000001 ? var53 = -.03907848255033881 : var53 = .018280601026175593 : var53 = .0006654540402589085;
  let var54;
  input[31] > 1e-35 ? input[2] > 58.50000000000001 ? input[9] > 1.5000000000000002 ? var54 = -.01386103677247845 : var54 = .11386694333005128 : input[4] > 27.500000000000004 ? var54 = -.021862617610091336 : input[2] > 31.500000000000004 ? var54 = .0828858469030438 : var54 = .006483353475830127 : input[224] > 1e-35 ? input[149] > 1e-35 ? input[13] > 1e-35 ? var54 = .11303635767048735 : var54 = -.01645525128352694 : input[23] > 1e-35 ? input[4] > 62.50000000000001 ? var54 = -.04238798044549342 : var54 = .022091190130494303 : input[5] > 5082.500000000001 ? var54 = -.04287166152163786 : input[8] > 862.5000000000001 ? input[19] > 1e-35 ? var54 = .000660344696244351 : input[4] > 9.500000000000002 ? input[0] > 1277.5000000000002 ? var54 = -.04291104140431434 : input[17] > 1e-35 ? var54 = .11256797532342613 : var54 = -.017206916368289193 : var54 = .026482035265709743 : input[1] > 8.500000000000002 ? input[11] > 1e-35 ? var54 = .04060606971664621 : input[0] > 4733.500000000001 ? input[8] > 214.50000000000003 ? input[5] > 4814.500000000001 ? var54 = .03581712466863222 : var54 = .14770264307668884 : input[8] > 73.50000000000001 ? var54 = -.13093289429740068 : var54 = .042461737442702936 : input[52] > 1e-35 ? var54 = .0501831919044939 : var54 = -.010450249720465756 : var54 = -.0753365425372656 : input[149] > 1e-35 ? input[6] > 23.500000000000004 ? var54 = .0005381332165438493 : var54 = -.04549431717503909 : input[133] > 1e-35 ? input[2] > 5.500000000000001 ? input[8] > 698.5000000000001 ? input[282] > 1e-35 ? var54 = .04849637311285226 : var54 = -.036671377119808564 : input[0] > 421.50000000000006 ? var54 = .00020968499911058945 : var54 = .11636422423182405 : var54 = -.12687837788222575 : var54 = .0012774367867215346;
  let var55;
  input[120] > 1e-35 ? var55 = .04776057572434719 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[0] > 3904.5000000000005 ? var55 = -.042799574885345304 : var55 = .07412430171193245 : var55 = -.11248270469336048 : input[193] > 1e-35 ? var55 = -.060694220820603384 : input[121] > 1e-35 ? input[217] > 1e-35 ? input[0] > 4449.500000000001 ? input[4] > 8.500000000000002 ? var55 = .028911612178122104 : var55 = .12326369727728437 : input[0] > 4091.5000000000005 ? var55 = -.09370267064141052 : input[0] > 3519.5000000000005 ? input[8] > 668.5000000000001 ? var55 = .1159839898100149 : var55 = -.01924880886585737 : input[8] > 501.50000000000006 ? input[10] > 16.500000000000004 ? var55 = -.0216343737351583 : var55 = -.1220272260878369 : input[2] > 18.500000000000004 ? var55 = .09152924475072398 : input[8] > 55.50000000000001 ? var55 = .039508716651005665 : var55 = -.11714436880423203 : input[18] > 1e-35 ? input[9] > 2.5000000000000004 ? var55 = .06793009902674053 : var55 = -.024060578029812988 : input[4] > 2.5000000000000004 ? input[2] > 16.500000000000004 ? input[4] > 11.500000000000002 ? var55 = -.04391068849624096 : var55 = .04009967593394672 : input[8] > 1085.5000000000002 ? var55 = -.024773826356034825 : var55 = -.13919707884246582 : var55 = .06659278075192335 : input[223] > 1e-35 ? input[8] > 668.5000000000001 ? var55 = -.11567917501901476 : var55 = -.006813640337684114 : input[3] > 7.500000000000001 ? var55 = .0010671269682548076 : input[7] > 3.5000000000000004 ? input[1] > 33.50000000000001 ? input[0] > 1597.5000000000002 ? input[10] > 1.5000000000000002 ? var55 = -.001754586408351048 : var55 = -.055422422450722056 : var55 = -.06090032532532226 : input[0] > 5269.500000000001 ? var55 = .11787981735983527 : var55 = -.00198119768540783 : var55 = .00210412924303036;
  let var56;
  input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var56 = -.09738558653332406 : input[0] > 2432.5000000000005 ? input[0] > 4533.500000000001 ? var56 = -.06063239096209816 : var56 = .03317022411417386 : var56 = -.08607562321324262 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var56 = -.013608609329298802 : var56 = .09078000157330264 : input[99] > 1e-35 ? var56 = .014828708581964632 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var56 = -.07536137260189814 : var56 = .006253266595455118 : input[10] > 28.500000000000004 ? var56 = -.006106041147592768 : input[9] > 156.50000000000003 ? var56 = -.11828932797811101 : input[94] > 1e-35 ? var56 = -.02566078479505714 : input[303] > 1e-35 ? var56 = .09544850289775349 : input[15] > 1e-35 ? input[224] > 1e-35 ? input[4] > 56.50000000000001 ? var56 = -.08401252789168523 : input[5] > 4244.500000000001 ? var56 = .026372887658499107 : input[1] > 16.500000000000004 ? var56 = -.027836756345634026 : var56 = .09205362097909099 : var56 = .00934612788718244 : input[203] > 1e-35 ? var56 = -.016371658366767253 : input[7] > 26.500000000000004 ? input[0] > 966.5000000000001 ? input[1] > 38.50000000000001 ? input[146] > 1e-35 ? input[9] > 21.500000000000004 ? var56 = -.09580979052540028 : input[1] > 50.50000000000001 ? var56 = -.06402211827281554 : var56 = .08342858760095972 : input[2] > 36.50000000000001 ? var56 = .008114897658204584 : input[92] > 1e-35 ? var56 = .09541587072672864 : var56 = -.022342147210555434 : var56 = -.01660492519175128 : var56 = .014721622240945446 : input[4] > 25.500000000000004 ? input[11] > 1e-35 ? var56 = .15846731118501817 : var56 = .039498507912023195 : input[245] > 1e-35 ? var56 = .07008718676813333 : var56 = .0019806389728814727;
  let var57;
  input[32] > 1e-35 ? input[8] > 90.50000000000001 ? input[4] > 67.50000000000001 ? input[0] > 4188.500000000001 ? var57 = -.01192072916082109 : var57 = .13888590840802637 : input[1] > 16.500000000000004 ? input[8] > 2302.5000000000005 ? var57 = .06874032717466054 : input[4] > 40.50000000000001 ? var57 = -.07752510020707537 : input[1] > 76.50000000000001 ? var57 = -.09944032260703917 : input[8] > 1381.5000000000002 ? var57 = -.054466635810800745 : input[1] > 32.50000000000001 ? var57 = .05974084520839573 : var57 = -.0384718740755954 : var57 = -.11374190719134032 : input[0] > 2151.5000000000005 ? var57 = -.13703645155803298 : var57 = .004833344758654556 : input[297] > 1e-35 ? input[212] > 1e-35 ? var57 = .06954747264544993 : input[7] > 9.500000000000002 ? input[19] > 1e-35 ? input[1] > 30.500000000000004 ? input[0] > 4242.500000000001 ? var57 = .013539805885738608 : var57 = -.0692740641801559 : input[0] > 2653.5000000000005 ? input[10] > 57.50000000000001 ? var57 = .09941880179344399 : var57 = -.01608127391210995 : var57 = .08025226531247417 : input[9] > 67.50000000000001 ? var57 = .13525448212444113 : input[6] > 61.50000000000001 ? var57 = -.05511099182158894 : input[94] > 1e-35 ? var57 = -.06821509831783572 : input[128] > 1e-35 ? var57 = .11361314817714643 : var57 = .030160785008575566 : input[1] > 13.500000000000002 ? input[8] > 17.500000000000004 ? input[16] > 1e-35 ? var57 = -.09954181329804547 : input[197] > 1e-35 ? var57 = .10102833149755386 : input[188] > 1e-35 ? var57 = .05584490988313965 : input[9] > 49.50000000000001 ? input[4] > 5.500000000000001 ? var57 = -.03781554214742005 : var57 = .09927933385592314 : var57 = -.020006000056720083 : var57 = -.10520473615957895 : var57 = -.12006990846253787 : var57 = -.00026111570975317574;
  let var58;
  input[8] > 2830.5000000000005 ? input[1] > 31.500000000000004 ? input[9] > 32.50000000000001 ? input[5] > 1234.5000000000002 ? input[0] > 1725.5000000000002 ? input[7] > 14.500000000000002 ? input[2] > 38.50000000000001 ? var58 = -.019188245509744628 : var58 = -.13354864350075848 : input[0] > 2461.5000000000005 ? var58 = .051885477468354396 : var58 = -.0833581968852119 : var58 = .08233441701532287 : var58 = -.10865584951212362 : input[8] > 2992.5000000000005 ? input[10] > 49.50000000000001 ? input[10] > 56.50000000000001 ? input[1] > 45.50000000000001 ? input[0] > 2041.5000000000002 ? var58 = .09926337893072812 : var58 = -.027753610497327715 : input[0] > 1972.5000000000002 ? var58 = -.09780045823152517 : var58 = .032380915168504935 : var58 = .11502632261226381 : input[17] > 1e-35 ? var58 = -.06094965899579662 : input[10] > 40.50000000000001 ? var58 = -.07500475582440802 : var58 = .006499832113084677 : input[10] > 4.500000000000001 ? input[4] > 10.500000000000002 ? var58 = -.09584538995220808 : var58 = -.00908705814304442 : var58 = .03203281520813893 : input[10] > 49.50000000000001 ? var58 = -.03146271513986384 : input[2] > 63.50000000000001 ? var58 = .13172001315536286 : input[224] > 1e-35 ? var58 = .08945777550527927 : input[0] > 2282.5000000000005 ? input[4] > 4.500000000000001 ? var58 = .09521549382082259 : var58 = -.04414925613522197 : input[0] > 1847.5000000000002 ? var58 = -.09118580379557353 : var58 = .009206744918282364 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[1] > 31.500000000000004 ? var58 = .03525144509943896 : var58 = -.053340750721609057 : input[0] > 1057.5000000000002 ? input[10] > 2.5000000000000004 ? var58 = -.04766112322938157 : input[2] > 10.500000000000002 ? var58 = .0728516504357201 : var58 = -.05049625965272536 : var58 = -.10868663055825774 : var58 = .0005382613419948969;
  let var59;
  input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var59 = -.10615739288764095 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var59 = -.030504020655417463 : var59 = .07102458639110094 : var59 = -.07058131985243714 : input[302] > 1e-35 ? input[10] > 47.50000000000001 ? var59 = .055304563442710876 : input[1] > 53.50000000000001 ? var59 = .033723409577443623 : input[8] > 175.50000000000003 ? input[0] > 2628.5000000000005 ? input[9] > 40.50000000000001 ? var59 = -.1568835288372895 : var59 = -.0279829124400056 : var59 = .04493843959601833 : var59 = -.11637042729644327 : input[191] > 1e-35 ? input[282] > 1e-35 ? var59 = -.054133834303687026 : input[9] > 48.50000000000001 ? var59 = .11263810289007213 : input[9] > 9.500000000000002 ? var59 = -.02202034562838259 : input[4] > 45.50000000000001 ? var59 = -.03410927569045158 : var59 = .04381615166534081 : input[242] > 1e-35 ? input[0] > 3615.5000000000005 ? input[3] > 19.500000000000004 ? input[1] > 56.50000000000001 ? input[4] > 28.500000000000004 ? var59 = -.029687297407295893 : var59 = .10673602850001934 : input[4] > 42.50000000000001 ? var59 = .0036275562945108117 : var59 = -.0760789221330622 : var59 = -.10385623431741903 : input[2] > 34.50000000000001 ? input[2] > 44.50000000000001 ? input[4] > 51.50000000000001 ? var59 = .08274426793676076 : var59 = -.07076234425516396 : var59 = .13890177606150175 : var59 = -.019863286503635686 : input[53] > 1e-35 ? input[18] > 1e-35 ? var59 = -.09250637750836187 : var59 = -.0031531727902009026 : input[2] > 107.50000000000001 ? input[4] > 91.50000000000001 ? input[1] > 16.500000000000004 ? var59 = -.01897867921812603 : var59 = .04890781705365262 : var59 = -.11569892307597907 : input[2] > 106.50000000000001 ? var59 = .09032697440623969 : var59 = .00047935919155035045;
  let var60;
  input[115] > 1e-35 ? var60 = .05338335681275557 : input[242] > 1e-35 ? input[0] > 3615.5000000000005 ? input[4] > 42.50000000000001 ? input[4] > 75.50000000000001 ? var60 = -.10131179514695865 : input[8] > 938.5000000000001 ? var60 = .10203729808015481 : var60 = -.015357944186835289 : input[1] > 56.50000000000001 ? input[2] > 22.500000000000004 ? var60 = .03574015165562999 : var60 = -.07763042506449493 : var60 = -.0813323116215548 : input[2] > 34.50000000000001 ? input[2] > 44.50000000000001 ? input[4] > 51.50000000000001 ? var60 = .0665706259130275 : var60 = -.06586817559309924 : var60 = .11925564412287476 : var60 = -.014170019267143326 : input[1] > 124.50000000000001 ? input[2] > 30.500000000000004 ? input[8] > 533.5000000000001 ? input[4] > 41.50000000000001 ? input[8] > 977.5000000000001 ? var60 = .046017146627455346 : var60 = -.08623321630086885 : input[8] > 1765.5000000000002 ? var60 = -.017990564319859934 : input[10] > 25.500000000000004 ? input[10] > 48.50000000000001 ? var60 = .11143827902215087 : var60 = -.01817808730473413 : var60 = .16980985030210127 : var60 = -.09357806298740017 : input[10] > 7.500000000000001 ? input[10] > 54.50000000000001 ? var60 = .010168994879727824 : var60 = -.09099594488792513 : input[9] > 1.5000000000000002 ? var60 = .0533459678147928 : var60 = -.06886854808370108 : input[99] > 1e-35 ? input[17] > 1e-35 ? input[9] > 22.500000000000004 ? var60 = -.062346959148773695 : input[1] > 47.50000000000001 ? var60 = -.0021578343835599316 : input[2] > 27.500000000000004 ? var60 = .19567373210166172 : var60 = .07851555379116423 : input[18] > 1e-35 ? var60 = .03711549097804649 : input[8] > 359.50000000000006 ? var60 = .012492346746905587 : input[4] > 20.500000000000004 ? var60 = .047511695735697544 : var60 = -.07999269063948773 : var60 = 6802045404471004e-20;
  let var61;
  input[222] > 1e-35 ? input[0] > 612.5000000000001 ? input[10] > 1e-35 ? input[8] > 2167.5000000000005 ? input[4] > 25.500000000000004 ? var61 = .0011484728213539738 : var61 = -.0936582904650763 : input[2] > 25.500000000000004 ? input[8] > 182.50000000000003 ? input[10] > 22.500000000000004 ? input[0] > 5026.500000000001 ? var61 = -.09828874964938798 : input[8] > 1586.5000000000002 ? var61 = .13726397438080162 : input[4] > 48.50000000000001 ? input[2] > 63.50000000000001 ? var61 = .011938269926919522 : var61 = .17541983715953954 : input[19] > 1e-35 ? var61 = .023002786011088672 : var61 = -.06221461272461431 : input[9] > 2.5000000000000004 ? input[0] > 3818.5000000000005 ? var61 = .06508934844183291 : var61 = -.10168553534835639 : var61 = -.07755626499024171 : input[2] > 51.50000000000001 ? input[4] > 65.50000000000001 ? var61 = .021140806225203937 : var61 = -.1167833342453639 : input[2] > 33.50000000000001 ? var61 = .13163585734056618 : var61 = -.00203273890889717 : input[10] > 36.50000000000001 ? input[8] > 1067.5000000000002 ? var61 = .06314479201263888 : var61 = -.09639088327091713 : input[10] > 29.500000000000004 ? var61 = .09225469303582386 : input[0] > 3129.5000000000005 ? input[0] > 4091.5000000000005 ? input[0] > 4354.500000000001 ? var61 = 40577156464836036e-21 : var61 = .12322387121810757 : var61 = -.03697224045046014 : input[1] > 22.500000000000004 ? var61 = .016474835887320276 : var61 = .16919298733903063 : var61 = .07633203630214054 : var61 = -.047438037934250644 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var61 = .14150493354700563 : var61 = -.01831155354975749 : input[1] > 28.500000000000004 ? var61 = -.07952557178685365 : input[10] > 28.500000000000004 ? var61 = .0665695554984927 : var61 = -.053640139319277094 : var61 = .0004754840665898665;
  let var62;
  input[76] > 1e-35 ? var62 = -.06814884255939921 : input[179] > 1e-35 ? var62 = -.06325743795510681 : input[122] > 1e-35 ? input[6] > 36.50000000000001 ? var62 = .05052338063261613 : input[8] > 626.5000000000001 ? input[1] > 38.50000000000001 ? var62 = .004193658608848433 : var62 = -.1066968975983452 : input[8] > 302.50000000000006 ? var62 = .05476730110440451 : var62 = -.06382970920394895 : input[218] > 1e-35 ? input[2] > 3.5000000000000004 ? input[6] > 13.500000000000002 ? input[2] > 19.500000000000004 ? input[0] > 3200.5000000000005 ? input[4] > 91.50000000000001 ? var62 = -.12156071809840739 : input[9] > 21.500000000000004 ? input[5] > 3883.5000000000005 ? input[8] > 919.5000000000001 ? input[8] > 1085.5000000000002 ? var62 = .013555772109446666 : var62 = -.09856116699770784 : var62 = .0284329611813383 : input[2] > 52.50000000000001 ? var62 = .04008708444763762 : input[9] > 29.500000000000004 ? var62 = -.1289599546008197 : var62 = -.018566534248335896 : input[8] > 747.5000000000001 ? var62 = .02236484980076122 : var62 = .1148871655157582 : input[8] > 3084.0000000000005 ? var62 = -.05573875952902531 : input[10] > 17.500000000000004 ? input[2] > 51.50000000000001 ? var62 = .03164751204281298 : var62 = .11752140436184891 : input[9] > 42.50000000000001 ? var62 = -.07180559595410106 : input[22] > 1e-35 ? var62 = .09325040416256854 : var62 = -.016041122807939914 : var62 = -.02765708954618808 : input[1] > 30.500000000000004 ? input[1] > 66.50000000000001 ? var62 = -.010718250133458515 : var62 = .09818827994853763 : var62 = .010180038981174032 : var62 = -.039472162599295535 : input[9] > 170.50000000000003 ? var62 = -.08536729235976731 : input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var62 = -.08674788057474031 : var62 = .02077653508548371 : var62 = -.0003536561382007414;
  let var63;
  input[86] > 1e-35 ? input[10] > 6.500000000000001 ? input[0] > 4376.500000000001 ? var63 = .018337297491457794 : var63 = -.05926206443180149 : var63 = .024026520855881126 : input[288] > 1e-35 ? input[184] > 1e-35 ? var63 = .10747078482128616 : input[126] > 1e-35 ? var63 = -.10550625192391357 : input[7] > 71.50000000000001 ? var63 = -.07698346027863572 : input[8] > 302.50000000000006 ? input[6] > 49.50000000000001 ? input[4] > 47.50000000000001 ? input[1] > 38.50000000000001 ? input[15] > 1e-35 ? var63 = .1317396472229434 : var63 = -.025035791351328947 : var63 = -.0728334305864372 : input[8] > 963.5000000000001 ? var63 = .023642201723096064 : var63 = .183010326734258 : input[128] > 1e-35 ? var63 = .04228920135648387 : input[2] > 34.50000000000001 ? input[15] > 1e-35 ? var63 = .002801782941492993 : input[3] > 40.50000000000001 ? input[4] > 39.50000000000001 ? var63 = -.1088876900335281 : var63 = .02758317023002635 : var63 = -.11886771300807207 : input[9] > 59.50000000000001 ? input[1] > 33.50000000000001 ? var63 = -.01928020117446408 : var63 = .10193718474139135 : input[1] > 48.50000000000001 ? input[4] > 9.500000000000002 ? input[8] > 932.5000000000001 ? var63 = .07893723375925096 : var63 = -.009878929627026153 : input[10] > 2.5000000000000004 ? input[9] > 20.500000000000004 ? var63 = -.10301657587280551 : var63 = .005787463140224318 : var63 = .07421364314695046 : input[0] > 2840.5000000000005 ? input[10] > 29.500000000000004 ? var63 = -.019296977889522397 : var63 = -.07274529751752634 : input[1] > 30.500000000000004 ? var63 = -.050368901143148286 : var63 = .029630869489466655 : input[2] > 6.500000000000001 ? input[4] > 9.500000000000002 ? var63 = .0015332402792773946 : var63 = .09930153676749967 : var63 = -.06370844564357069 : var63 = .00042272155209927616;
  let var64;
  input[71] > 1e-35 ? input[4] > 17.500000000000004 ? var64 = .12586844370423247 : var64 = -.006791999603126354 : input[222] > 1e-35 ? input[1] > 10.500000000000002 ? input[30] > 1e-35 ? input[1] > 36.50000000000001 ? input[9] > 1.5000000000000002 ? input[10] > 25.500000000000004 ? var64 = -.08474891624263797 : input[8] > 125.50000000000001 ? var64 = .08125086980439704 : var64 = -.04082085238068532 : input[0] > 3863.5000000000005 ? var64 = .020481535807469208 : var64 = .14810819386202126 : input[0] > 1937.5000000000002 ? input[2] > 16.500000000000004 ? var64 = -.019110200161573936 : var64 = -.12387719685855114 : input[0] > 1102.5000000000002 ? var64 = .08376595701957407 : var64 = -.031821919580524834 : input[9] > 4.500000000000001 ? var64 = -.08116383486497568 : input[7] > 8.500000000000002 ? input[2] > 24.500000000000004 ? var64 = -.02154820850475448 : input[0] > 3863.5000000000005 ? input[8] > 902.5000000000001 ? var64 = .1349841206807871 : var64 = .011864053595560297 : input[1] > 41.50000000000001 ? var64 = -.08203662486612544 : input[2] > 18.500000000000004 ? var64 = -.009541865642346947 : var64 = .08345043168501759 : input[2] > 10.500000000000002 ? var64 = -.09585031818030947 : var64 = .019432330487099865 : var64 = .08399259524715129 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var64 = .11951517733981365 : var64 = -.016651014735738538 : input[1] > 28.500000000000004 ? var64 = -.07410922545030711 : input[10] > 28.500000000000004 ? var64 = .05886430683844788 : var64 = -.04929626605117184 : input[191] > 1e-35 ? input[9] > 9.500000000000002 ? input[9] > 48.50000000000001 ? var64 = .04802269879144705 : var64 = -.026208212831796737 : input[4] > 45.50000000000001 ? var64 = -.03227476944664786 : var64 = .05124575625622705 : var64 = .00020506696916003137;
  let var65;
  input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[9] > 17.500000000000004 ? var65 = -.03042091758483443 : input[10] > 14.500000000000002 ? var65 = .09816619204768777 : var65 = .01332124067720947 : input[8] > 8.500000000000002 ? input[4] > 15.500000000000002 ? var65 = -.02381165060401718 : var65 = -.10950361804974783 : var65 = .03538211665111128 : input[212] > 1e-35 ? input[19] > 1e-35 ? var65 = -.09940014650006174 : input[0] > 2215.5000000000005 ? input[5] > 5056.500000000001 ? input[3] > 5.500000000000001 ? input[10] > 25.500000000000004 ? var65 = -.06371052144380579 : var65 = .0835500621252692 : var65 = -.10408255929333915 : input[1] > 74.50000000000001 ? var65 = .13208968122712403 : input[1] > 64.50000000000001 ? var65 = -.04778844603644965 : input[8] > 51.50000000000001 ? input[8] > 201.50000000000003 ? input[8] > 660.5000000000001 ? input[6] > 4.500000000000001 ? input[9] > 5.500000000000001 ? input[1] > 29.500000000000004 ? input[0] > 3830.5000000000005 ? var65 = .09922816902423433 : var65 = .016366955328796718 : var65 = .1592412560903584 : input[1] > 39.50000000000001 ? var65 = .05409467990258923 : var65 = -.08260633210459611 : var65 = -.06307205775247567 : input[9] > 36.50000000000001 ? var65 = .040253940015648144 : var65 = .14202568969471283 : var65 = -.028761848341594044 : var65 = .08994073058773508 : input[0] > 807.5000000000001 ? var65 = -.043427848826323195 : var65 = .04573516446846493 : input[20] > 1e-35 ? input[188] > 1e-35 ? var65 = -.0758877731600639 : input[23] > 1e-35 ? var65 = .05913923322043199 : input[8] > 155.50000000000003 ? input[128] > 1e-35 ? var65 = .08124700978741987 : var65 = .013296063087086852 : input[7] > 5.500000000000001 ? var65 = -.01640196088612987 : var65 = -.12685498840146067 : var65 = -.0004940792382459551;
  let var66;
  input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 61.50000000000001 ? input[17] > 1e-35 ? var66 = -.05584993681929434 : input[9] > 27.500000000000004 ? input[0] > 3916.5000000000005 ? var66 = .08513773825688947 : var66 = -.1184664832315282 : var66 = .05676963535893477 : var66 = .14263843210340613 : var66 = .0005795003292924202 : input[18] > 1e-35 ? input[0] > 5453.500000000001 ? input[1] > 11.500000000000002 ? var66 = -.10669720555606924 : var66 = .029016613003137307 : input[2] > 46.50000000000001 ? input[10] > 9.500000000000002 ? var66 = .0664744575868955 : var66 = -.08469256188890871 : var66 = -.026746678040592144 : input[281] > 1e-35 ? var66 = -.07408427239006925 : input[145] > 1e-35 ? input[4] > 6.500000000000001 ? input[9] > 16.500000000000004 ? input[4] > 18.500000000000004 ? var66 = .012131807587207655 : var66 = -.12776015795398743 : var66 = .04320472481083551 : var66 = .08390980661550446 : input[10] > 227.50000000000003 ? var66 = -.09771783809101153 : input[10] > 130.50000000000003 ? var66 = .11175201938704937 : input[8] > 779.5000000000001 ? input[5] > 3325.5000000000005 ? input[128] > 1e-35 ? var66 = -.07610698254064358 : input[8] > 902.5000000000001 ? var66 = -.03136381213599649 : input[131] > 1e-35 ? var66 = .0704821739127936 : input[224] > 1e-35 ? var66 = -.056961477774953785 : input[10] > 30.500000000000004 ? input[9] > 43.50000000000001 ? var66 = .10431473040024908 : input[8] > 841.5000000000001 ? var66 = .07304745320500514 : var66 = -.038011541882439825 : var66 = -.01679746695007364 : input[0] > 3129.5000000000005 ? var66 = .05589952587431965 : input[210] > 1e-35 ? var66 = .06227198085800842 : var66 = -.0011341890997947812 : input[8] > 740.5000000000001 ? var66 = .04817300084412584 : var66 = -.000577001010789238;
  let var67;
  input[187] > 1e-35 ? input[6] > 12.500000000000002 ? input[10] > 8.500000000000002 ? input[10] > 16.500000000000004 ? input[8] > 234.50000000000003 ? input[4] > 43.50000000000001 ? input[0] > 4476.500000000001 ? var67 = -.10504730480402079 : input[5] > 3341.5000000000005 ? var67 = .11087894671081754 : var67 = -.0406668834674614 : var67 = .03308382165616109 : input[8] > 104.50000000000001 ? var67 = -.10431436764549162 : var67 = .0073928337244891455 : input[4] > 34.50000000000001 ? var67 = -.10571751512748416 : var67 = -.006081128814142983 : input[13] > 1e-35 ? var67 = .1299673566095023 : input[4] > 60.50000000000001 ? var67 = -.06587492443829139 : input[0] > 2604.5000000000005 ? input[3] > 19.500000000000004 ? var67 = .04857126072645073 : var67 = -.03431365358104773 : input[4] > 16.500000000000004 ? var67 = .04101865986596709 : var67 = .16480274980378218 : input[10] > 26.500000000000004 ? var67 = .03673978504199255 : input[10] > 9.500000000000002 ? var67 = -.10996402743800027 : input[308] > 1e-35 ? var67 = .0553693735082498 : var67 = -.041600136235644125 : input[306] > 1e-35 ? input[8] > 1156.5000000000002 ? input[4] > 14.500000000000002 ? input[10] > 21.500000000000004 ? var67 = .010902983761213922 : var67 = .1325118659895645 : var67 = -.064362945508595 : input[1] > 66.50000000000001 ? var67 = .033416767779331176 : var67 = -.054080316225040496 : input[42] > 1e-35 ? var67 = -.07762364337810815 : input[10] > 1089.5000000000002 ? var67 = -.08465599849125216 : input[31] > 1e-35 ? input[8] > 30.500000000000004 ? var67 = .012788520036013586 : input[1] > 32.50000000000001 ? input[1] > 51.50000000000001 ? var67 = .0220102041325908 : var67 = -.06516708740003069 : var67 = .012833498905748267 : input[224] > 1e-35 ? var67 = -.007038418272997865 : var67 = .00037666304316290967;
  let var68;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var68 = .07554189644995735 : var68 = -.052089349455904946 : var68 = -.10148206848169845 : input[113] > 1e-35 ? var68 = -.06666678653225779 : input[39] > 1e-35 ? input[9] > 3.5000000000000004 ? input[0] > 3670.5000000000005 ? var68 = .07172653627995676 : var68 = -.07602959317610998 : var68 = -.08790686271287523 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[0] > 3904.5000000000005 ? var68 = -.0399322883690891 : var68 = .06523495517476098 : var68 = -.10358715295743802 : input[193] > 1e-35 ? var68 = -.05551414334329124 : input[134] > 1e-35 ? input[11] > 1e-35 ? input[2] > 13.500000000000002 ? input[10] > 1.5000000000000002 ? var68 = .015928764772252406 : var68 = .1341513061552287 : var68 = -.04975001987586173 : input[10] > 2.5000000000000004 ? input[3] > 5.500000000000001 ? input[9] > 2.5000000000000004 ? input[8] > 310.50000000000006 ? var68 = -.033592997607280156 : var68 = -.12432458028446665 : input[1] > 32.50000000000001 ? input[217] > 1e-35 ? var68 = -.08402551858097379 : var68 = .017401984506038796 : input[1] > 25.500000000000004 ? var68 = .13337205393591278 : var68 = -.01160208350090984 : var68 = .06708317942315471 : input[8] > 227.50000000000003 ? var68 = -.08486943882418681 : var68 = -.013970104864235007 : input[8] > 4968.500000000001 ? input[1] > 31.500000000000004 ? input[9] > 4.500000000000001 ? var68 = -.10496268177586783 : var68 = -.020921489532370493 : var68 = .02629915927247642 : input[7] > 20.500000000000004 ? input[8] > 251.50000000000003 ? input[115] > 1e-35 ? var68 = .11639296062157028 : var68 = -.004275784356569115 : input[32] > 1e-35 ? var68 = -.07297384970166025 : var68 = .006026841626381599 : var68 = .002034611134960428;
  let var69;
  input[248] > 1e-35 ? var69 = .06091438745093315 : input[0] > 384.50000000000006 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var69 = -.06455513326540585 : input[1] > 29.500000000000004 ? var69 = .07718474591552532 : input[4] > 7.500000000000001 ? var69 = .040139336931404826 : var69 = -.09685734690563386 : var69 = .00015327283570347363 : input[9] > 88.50000000000001 ? var69 = .10079017954199324 : input[1] > 47.50000000000001 ? input[2] > 20.500000000000004 ? input[2] > 27.500000000000004 ? var69 = -.04077257804338707 : var69 = .0739963982640615 : input[9] > 1.5000000000000002 ? input[17] > 1e-35 ? var69 = .03778141591008941 : var69 = -.06459919920634845 : var69 = -.11193190957880604 : input[7] > 6.500000000000001 ? input[11] > 1e-35 ? input[18] > 1e-35 ? var69 = .14063930759326346 : input[0] > 179.50000000000003 ? var69 = .07287482250668585 : input[8] > 1180.5000000000002 ? var69 = -.14419393112726253 : input[10] > 28.500000000000004 ? var69 = -.07993142770099469 : input[17] > 1e-35 ? var69 = -.04702595410391655 : input[7] > 21.500000000000004 ? input[2] > 26.500000000000004 ? var69 = .05527969663610186 : var69 = -.10824385941441346 : input[3] > 11.500000000000002 ? var69 = .12358502961047915 : var69 = -.017509147119622873 : input[0] > 74.50000000000001 ? var69 = -.014907705458730486 : input[8] > 95.50000000000001 ? var69 = -.02225118168342062 : var69 = -.1222374623708485 : input[8] > 1.5000000000000002 ? input[8] > 950.5000000000001 ? var69 = .06946188930925638 : input[3] > 6.500000000000001 ? input[10] > 2.5000000000000004 ? input[19] > 1e-35 ? var69 = .04962819555610421 : var69 = -.07213577821855309 : var69 = .09139529824708481 : input[19] > 1e-35 ? var69 = .013439401088345224 : var69 = -.049274647207292056 : var69 = .10531673719686951;
  let var70;
  input[40] > 1e-35 ? input[0] > 1937.5000000000002 ? var70 = -.06421671152073961 : var70 = .04235421241226177 : input[294] > 1e-35 ? input[10] > 50.50000000000001 ? var70 = -.09100102290316286 : input[0] > 3030.5000000000005 ? input[0] > 4177.500000000001 ? var70 = -.03520420769287065 : input[8] > 1085.5000000000002 ? var70 = -.019817352506127633 : var70 = .11444439424520964 : var70 = -.06854631664538167 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var70 = -.010490117519863269 : var70 = .08104430117757461 : input[121] > 1e-35 ? input[243] > 1e-35 ? var70 = .16408304891242204 : input[217] > 1e-35 ? input[0] > 4449.500000000001 ? var70 = .06619344145920268 : input[0] > 4091.5000000000005 ? var70 = -.08813353450871053 : input[0] > 3519.5000000000005 ? input[8] > 668.5000000000001 ? var70 = .10016091391222309 : var70 = -.017407607199427293 : input[8] > 501.50000000000006 ? input[10] > 16.500000000000004 ? var70 = -.019511460451434884 : var70 = -.11643672465055221 : input[2] > 18.500000000000004 ? var70 = .07848228087333317 : input[8] > 55.50000000000001 ? var70 = .032583027899956235 : var70 = -.11209832692153521 : input[11] > 1e-35 ? var70 = .027482174104412567 : input[10] > 1.5000000000000002 ? input[6] > 26.500000000000004 ? input[4] > 19.500000000000004 ? input[9] > 31.500000000000004 ? var70 = -.09996887746328006 : input[9] > 2.5000000000000004 ? var70 = .02157682011863397 : var70 = -.05247727848991843 : var70 = .07409150201483244 : input[1] > 38.50000000000001 ? var70 = -.11378466075449625 : input[224] > 1e-35 ? var70 = -.10741749127732923 : input[1] > 26.500000000000004 ? var70 = .07343136534146562 : var70 = -.07013573628594773 : input[25] > 1e-35 ? var70 = -.04626669734164317 : var70 = .05518333197956482 : var70 = .00032434010867555516;
  let var71;
  input[183] > 1e-35 ? input[10] > 1.5000000000000002 ? input[17] > 1e-35 ? var71 = .026313251010808853 : var71 = -.08997339150292381 : var71 = .025062509535227952 : input[227] > 1e-35 ? input[1] > 6.500000000000001 ? input[2] > 9.500000000000002 ? input[210] > 1e-35 ? var71 = .08071107515789745 : input[23] > 1e-35 ? input[1] > 75.50000000000001 ? var71 = .0905155504503746 : input[8] > 1049.5000000000002 ? var71 = -.062312558183394054 : input[8] > 719.5000000000001 ? var71 = .09583836191410239 : input[0] > 3719.5000000000005 ? var71 = -.0778097309430818 : var71 = .04012012419054895 : input[4] > 12.500000000000002 ? input[8] > 1496.5000000000002 ? input[10] > 42.50000000000001 ? var71 = -.12920865648544927 : input[0] > 2699.5000000000005 ? var71 = -.07086587879041864 : var71 = .022614182502461846 : input[4] > 15.500000000000002 ? input[8] > 55.50000000000001 ? input[1] > 60.50000000000001 ? input[8] > 652.5000000000001 ? var71 = -.11377786322600797 : var71 = -.009486325820117998 : input[1] > 55.50000000000001 ? var71 = .12430248795958142 : input[0] > 2952.5000000000005 ? input[0] > 4331.500000000001 ? input[1] > 38.50000000000001 ? var71 = -.07938291201004219 : input[2] > 36.50000000000001 ? var71 = .01520046732530246 : var71 = .13649854049662832 : var71 = -.07145015938528873 : input[8] > 407.50000000000006 ? var71 = -.00350257360822279 : var71 = .11332047082193297 : var71 = -.10060624458629897 : var71 = .05429496612497562 : input[8] > 1446.5000000000002 ? var71 = .006073419197482838 : var71 = -.08718676350883998 : var71 = -.11532497988252638 : var71 = .10766270463068293 : input[34] > 1e-35 ? var71 = -.06345912440611544 : input[131] > 1e-35 ? input[9] > 1.5000000000000002 ? var71 = -.0004109812623829506 : var71 = .021601073497455662 : var71 = -7343540098965853e-20;
  let var72;
  input[298] > 1e-35 ? input[9] > 12.500000000000002 ? input[133] > 1e-35 ? var72 = -.06107663265515864 : input[9] > 70.50000000000001 ? input[10] > 37.50000000000001 ? var72 = .05995640200798119 : input[0] > 3443.5000000000005 ? var72 = -.14698883458733583 : var72 = -.030039164579240187 : input[189] > 1e-35 ? var72 = -.06086763220538141 : input[1] > 86.50000000000001 ? var72 = -.05096727866142538 : input[4] > 64.50000000000001 ? var72 = .11240554253834577 : input[4] > 45.50000000000001 ? var72 = -.030279760168394117 : input[6] > 45.50000000000001 ? var72 = .10161088917815142 : input[10] > 77.50000000000001 ? var72 = -.0792333078055653 : input[7] > 23.500000000000004 ? input[0] > 2882.5000000000005 ? var72 = -.06672020005240323 : var72 = .08831457502630258 : input[8] > 2592.5000000000005 ? var72 = -.052617701047376654 : input[10] > 29.500000000000004 ? var72 = .08499327690298047 : input[2] > 12.500000000000002 ? input[9] > 41.50000000000001 ? var72 = .12880460816709416 : input[9] > 25.500000000000004 ? input[4] > 11.500000000000002 ? var72 = -.064099222705728 : var72 = .044332487521538365 : input[0] > 2882.5000000000005 ? var72 = .031099546885005065 : var72 = .12938467051623853 : input[0] > 4221.500000000001 ? var72 = -.0928676413498701 : input[9] > 30.500000000000004 ? var72 = -.05781824812803708 : var72 = .07561268901778094 : input[8] > 711.5000000000001 ? input[2] > 22.500000000000004 ? var72 = -.06648105454098469 : var72 = .05985487552383097 : var72 = -.13070190291919334 : input[116] > 1e-35 ? input[10] > 38.50000000000001 ? var72 = .05282385499619401 : input[1] > 66.50000000000001 ? var72 = .048802929108006314 : input[2] > 4.500000000000001 ? input[0] > 4593.500000000001 ? var72 = .027885690791379255 : var72 = -.08407126408362446 : var72 = .014432924125571093 : var72 = -9903435845205118e-20;
  let var73;
  input[76] > 1e-35 ? var73 = -.06307875292162934 : input[21] > 1e-35 ? input[7] > 10.500000000000002 ? input[10] > 4.500000000000001 ? input[8] > 944.5000000000001 ? input[0] > 3655.5000000000005 ? var73 = .013633653464240465 : var73 = -.10164319411983509 : var73 = -.1228424374328996 : input[1] > 26.500000000000004 ? input[2] > 28.500000000000004 ? var73 = .00632864847804078 : var73 = -.08393000368134668 : var73 = .07870508617440916 : input[284] > 1e-35 ? var73 = .1092302727710421 : var73 = -.0025505047582483234 : input[248] > 1e-35 ? var73 = .07101822393621864 : input[274] > 1e-35 ? var73 = -.06621099406425579 : input[1] > 26.500000000000004 ? input[1] > 28.500000000000004 ? var73 = .0003077044909372931 : input[10] > 2.5000000000000004 ? input[0] > 3770.5000000000005 ? var73 = .025081789181021243 : var73 = -.014813325803582618 : input[9] > 33.50000000000001 ? var73 = -.033466921233840194 : input[3] > 12.500000000000002 ? input[23] > 1e-35 ? var73 = .11926990418060353 : var73 = .01852125513565268 : var73 = .0975367595927343 : input[5] > 3325.5000000000005 ? input[8] > 892.5000000000001 ? input[133] > 1e-35 ? var73 = -.1178464984373743 : input[283] > 1e-35 ? var73 = .043370859226927405 : input[5] > 4320.500000000001 ? var73 = -.01103141226366587 : input[8] > 1104.5000000000002 ? var73 = -.023053423988095886 : var73 = -.0734238953804657 : input[6] > 18.500000000000004 ? input[8] > 85.50000000000001 ? var73 = .000579145585864887 : var73 = .03389152834202143 : input[128] > 1e-35 ? var73 = -.14527722052568462 : input[210] > 1e-35 ? var73 = -.08915971541902741 : input[7] > 9.500000000000002 ? var73 = -.03307314577076116 : input[18] > 1e-35 ? var73 = -.05521712302023565 : var73 = .009315605032770029 : var73 = .0036332551852289933;
  let var74;
  input[0] > 689.5000000000001 ? input[5] > 768.5000000000001 ? input[20] > 1e-35 ? input[5] > 4368.500000000001 ? var74 = -.07583539600416284 : input[188] > 1e-35 ? var74 = -.07042659515500142 : input[23] > 1e-35 ? input[0] > 3807.5000000000005 ? var74 = -.011038193049597113 : var74 = .08154028164397753 : input[1] > 85.50000000000001 ? var74 = .10259361975201933 : var74 = .011640408330521594 : var74 = -.00023319159023748508 : input[92] > 1e-35 ? var74 = .13771692859530546 : var74 = .022860029819654806 : input[1] > 22.500000000000004 ? input[1] > 24.500000000000004 ? input[2] > 96.50000000000001 ? var74 = .09967230141007705 : input[30] > 1e-35 ? var74 = -.08888529037551285 : var74 = -.008615931385397808 : input[10] > 5.500000000000001 ? input[4] > 36.50000000000001 ? var74 = .08284665960761373 : var74 = -.029292565021289504 : input[7] > 7.500000000000001 ? var74 = -.09945093355204493 : var74 = -.008381393701708593 : input[20] > 1e-35 ? var74 = -.04218678460370465 : input[10] > 6.500000000000001 ? input[9] > 2.5000000000000004 ? input[1] > 13.500000000000002 ? input[8] > 143.50000000000003 ? input[4] > 7.500000000000001 ? input[2] > 36.50000000000001 ? var74 = .07585582641438211 : input[8] > 284.50000000000006 ? var74 = -.029387993239886723 : var74 = .07716738177321587 : input[1] > 18.500000000000004 ? var74 = .026745348497993746 : var74 = .1427429617069753 : input[9] > 16.500000000000004 ? input[9] > 33.50000000000001 ? var74 = .02337306890530338 : var74 = -.10390355904767366 : var74 = .07390521199638532 : var74 = -.06788247515155237 : var74 = -.04201446383470994 : input[2] > 25.500000000000004 ? input[2] > 29.500000000000004 ? input[8] > 227.50000000000003 ? var74 = -.06360325615644084 : var74 = .04342192339836601 : var74 = -.10598779152030145 : var74 = .05253384605768211;
  let var75;
  input[3] > 7.500000000000001 ? input[157] > 1e-35 ? var75 = -.07514182877923786 : var75 = .000636205502279271 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var75 = .028692053800951845 : var75 = .14081686716133598 : var75 = -.03316566526940354 : input[186] > 1e-35 ? input[0] > 2653.5000000000005 ? var75 = .0037139292567243084 : var75 = .12662311031652707 : input[107] > 1e-35 ? input[0] > 612.5000000000001 ? var75 = .01202688580305612 : var75 = .0993509141454483 : input[203] > 1e-35 ? input[1] > 77.50000000000001 ? var75 = .043935495082738626 : var75 = -.05639305759669704 : input[247] > 1e-35 ? var75 = -.06770766046891649 : input[105] > 1e-35 ? input[19] > 1e-35 ? var75 = .10331836202616368 : var75 = .0006926658459781341 : input[96] > 1e-35 ? var75 = .05361846065599475 : input[127] > 1e-35 ? input[0] > 2723.5000000000005 ? input[1] > 54.50000000000001 ? var75 = -.0741403257305367 : var75 = .022900127535540854 : input[7] > 3.5000000000000004 ? var75 = .038110741403836294 : var75 = .14618649985842758 : input[5] > 3921.5000000000005 ? input[1] > 110.50000000000001 ? var75 = -.09552842289807008 : input[1] > 27.500000000000004 ? var75 = .012505935885798007 : var75 = -.020509603428689526 : input[282] > 1e-35 ? input[9] > 45.50000000000001 ? input[6] > 5.500000000000001 ? var75 = -.1046104767723845 : var75 = .031388606992301074 : input[8] > 114.50000000000001 ? input[9] > 17.500000000000004 ? input[9] > 22.500000000000004 ? input[1] > 32.50000000000001 ? var75 = .023466328488582572 : var75 = .11730925774586994 : var75 = -.04771965631104874 : var75 = .17059689880751394 : var75 = -.08181850955999449 : input[26] > 1e-35 ? var75 = -.12727482696678769 : var75 = -.014343123272734182;
  let var76;
  input[147] > 1e-35 ? input[1] > 53.50000000000001 ? var76 = -.0993064321015924 : input[0] > 2604.5000000000005 ? input[0] > 3629.5000000000005 ? var76 = -.02763546051134888 : var76 = .06423344777499343 : var76 = -.064606430904295 : input[302] > 1e-35 ? input[10] > 2.5000000000000004 ? input[10] > 47.50000000000001 ? var76 = .049825139823021586 : input[7] > 22.500000000000004 ? var76 = -.01131680751379858 : input[0] > 2579.5000000000005 ? var76 = -.10673674485369694 : var76 = -.015387212937189957 : var76 = .04347325151148724 : input[179] > 1e-35 ? var76 = -.05788885608624092 : input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var76 = .0650355590939066 : var76 = -.0473332870892226 : var76 = -.09699315983340703 : input[288] > 1e-35 ? input[88] > 1e-35 ? var76 = .11139543329789044 : input[126] > 1e-35 ? var76 = -.09726928633696198 : input[8] > 149.50000000000003 ? input[9] > 46.50000000000001 ? input[4] > 1.5000000000000002 ? input[8] > 1861.5000000000002 ? var76 = .06370903833231022 : input[10] > 29.500000000000004 ? var76 = .03415223859607161 : input[10] > 3.5000000000000004 ? var76 = -.07415518117873297 : var76 = -.0014119203473324082 : var76 = .12617652343819508 : input[9] > 41.50000000000001 ? var76 = -.10311145857176976 : input[8] > 2757.5000000000005 ? var76 = -.08106484219011428 : input[7] > 71.50000000000001 ? var76 = -.09783384432091176 : input[1] > 88.50000000000001 ? var76 = .06249739709782831 : input[3] > 9.500000000000002 ? input[5] > 1601.5000000000002 ? var76 = -.008884084501608536 : var76 = .061339437777743616 : var76 = -.042490992675121846 : input[2] > 6.500000000000001 ? input[3] > 10.500000000000002 ? var76 = .01526664064166223 : var76 = .13534828515415498 : var76 = -.06985484465894776 : var76 = .0005758961943178744;
  let var77;
  input[86] > 1e-35 ? input[1] > 23.500000000000004 ? input[1] > 29.500000000000004 ? input[4] > 16.500000000000004 ? input[2] > 31.500000000000004 ? var77 = -.029152732370514342 : var77 = .07173628916139178 : input[1] > 36.50000000000001 ? var77 = -.08859111297255318 : var77 = .0018030071815630785 : var77 = .13652461563759322 : var77 = -.07550137680349367 : input[10] > 52.50000000000001 ? input[49] > 1e-35 ? var77 = -.07145140450454163 : input[21] > 1e-35 ? var77 = -.07422841663493233 : var77 = .006289319702780104 : input[10] > 40.50000000000001 ? input[9] > 59.50000000000001 ? input[19] > 1e-35 ? input[13] > 1e-35 ? var77 = .11864240653986852 : input[3] > 33.50000000000001 ? var77 = -.08821209591953476 : var77 = .05706392280054726 : var77 = -.03600088051578915 : input[18] > 1e-35 ? input[1] > 24.500000000000004 ? var77 = .01953613016837112 : var77 = -.059781039130025006 : input[148] > 1e-35 ? var77 = .052668447861325476 : input[3] > 30.500000000000004 ? input[9] > 49.50000000000001 ? var77 = .07207826841738371 : input[202] > 1e-35 ? var77 = .08163917539410503 : var77 = -.01319846363832958 : input[9] > 35.50000000000001 ? input[5] > 4134.500000000001 ? input[10] > 44.50000000000001 ? var77 = -.06858280496900336 : var77 = -.1781828899516648 : var77 = -.04024620133969553 : input[9] > 10.500000000000002 ? input[1] > 22.500000000000004 ? input[1] > 37.50000000000001 ? var77 = .018232649414147116 : var77 = -.04419781124222661 : var77 = .05145485182416554 : input[1] > 23.500000000000004 ? input[0] > 655.5000000000001 ? input[5] > 4901.500000000001 ? input[10] > 45.50000000000001 ? var77 = .11452368095776105 : var77 = -.036496437259924026 : var77 = -.040445338739465486 : var77 = .0816572651001145 : var77 = -.08968914517368663 : var77 = .0002826343082585516;
  let var78;
  input[189] > 1e-35 ? input[0] > 5269.500000000001 ? var78 = -.08839493050459957 : input[10] > 85.50000000000001 ? var78 = .10046908365702462 : input[8] > 2592.5000000000005 ? var78 = -.09632233975926387 : input[8] > 2000.5000000000002 ? var78 = .10282992953871627 : input[8] > 1266.5000000000002 ? input[9] > 34.50000000000001 ? var78 = .035504970430426296 : input[1] > 31.500000000000004 ? var78 = -.1133764813142531 : var78 = -.01138280942244812 : input[8] > 1125.5000000000002 ? var78 = .09800530246229806 : var78 = .016170419267589393 : input[218] > 1e-35 ? input[9] > 99.50000000000001 ? input[9] > 101.50000000000001 ? input[9] > 124.50000000000001 ? var78 = .07316772160107896 : var78 = -.059095014819051765 : var78 = .17859437315769733 : input[2] > 1.5000000000000002 ? input[9] > 86.50000000000001 ? var78 = -.09150209066166894 : input[8] > 3084.0000000000005 ? var78 = -.05443972593168094 : input[1] > 65.50000000000001 ? input[10] > 11.500000000000002 ? input[9] > 33.50000000000001 ? var78 = -.04449234460408263 : var78 = .05568837973347338 : var78 = -.12362324875024472 : input[1] > 41.50000000000001 ? input[10] > 12.500000000000002 ? input[8] > 1336.5000000000002 ? var78 = .12741077850267066 : var78 = .007372371864985329 : input[2] > 39.50000000000001 ? var78 = .02295917234617787 : var78 = .14966532083907075 : input[1] > 39.50000000000001 ? var78 = -.06685557815340279 : input[10] > 22.500000000000004 ? input[2] > 52.50000000000001 ? var78 = -.02511861881285652 : input[1] > 27.500000000000004 ? var78 = .08683660011672288 : var78 = .02956214835267301 : input[9] > 15.500000000000002 ? var78 = -.016538805462996232 : var78 = .04352738094981517 : var78 = -.05561856645643868 : input[9] > 170.50000000000003 ? var78 = -.07996752635874248 : input[179] > 1e-35 ? var78 = -.09065975936933919 : var78 = -.00042817975060427177;
  let var79;
  input[39] > 1e-35 ? input[4] > 25.500000000000004 ? var79 = .03443173196222934 : var79 = -.06554248341270724 : input[32] > 1e-35 ? input[8] > 90.50000000000001 ? input[4] > 67.50000000000001 ? input[4] > 86.50000000000001 ? var79 = -.0013415395759330318 : var79 = .12950978489563347 : input[1] > 22.500000000000004 ? input[10] > 19.500000000000004 ? input[4] > 30.500000000000004 ? input[9] > 41.50000000000001 ? var79 = .002297618040307216 : var79 = -.12522800128774994 : input[4] > 8.500000000000002 ? input[8] > 1075.5000000000002 ? var79 = -.015297257305397608 : var79 = .09651828834062742 : var79 = -.06636003334371929 : input[10] > 11.500000000000002 ? var79 = .17631616138309397 : input[0] > 1639.5000000000002 ? var79 = 3804386478092585e-20 : var79 = -.09099296398683193 : var79 = -.06874415876172972 : input[0] > 2151.5000000000005 ? var79 = -.1311264883406766 : var79 = .00809052010141122 : input[253] > 1e-35 ? var79 = -.06338558211939296 : input[178] > 1e-35 ? input[2] > 25.500000000000004 ? input[2] > 30.500000000000004 ? input[0] > 2151.5000000000005 ? input[10] > 10.500000000000002 ? input[0] > 3615.5000000000005 ? var79 = .045038497754638605 : var79 = -.07770167665661752 : var79 = -.08596294280650517 : var79 = .08538655727027213 : var79 = .09829076418590559 : input[1] > 39.50000000000001 ? input[9] > 1.5000000000000002 ? var79 = .054627956617973275 : input[1] > 61.50000000000001 ? var79 = -.11994465088415499 : input[4] > 8.500000000000002 ? var79 = .06676200239406452 : var79 = -.027503148069376867 : input[8] > 676.5000000000001 ? var79 = -.10363964928357075 : input[4] > 8.500000000000002 ? var79 = -.07589816227175682 : var79 = .034664436544646814 : input[1] > 159.50000000000003 ? input[6] > 25.500000000000004 ? var79 = .009093153189012338 : var79 = -.06119765876605404 : var79 = .0004668642103528348;
  let var80;
  input[223] > 1e-35 ? input[1] > 31.500000000000004 ? input[8] > 711.5000000000001 ? var80 = -.10100794502567233 : var80 = .08000205636470442 : var80 = -.11945419826856896 : input[113] > 1e-35 ? var80 = -.06105445938688056 : input[167] > 1e-35 ? input[0] > 3928.5000000000005 ? var80 = .1224302423880318 : var80 = -.01875566982911468 : input[222] > 1e-35 ? input[1] > 8.500000000000002 ? input[1] > 24.500000000000004 ? input[4] > 3.5000000000000004 ? input[0] > 725.5000000000001 ? input[0] > 1682.5000000000002 ? input[0] > 2860.5000000000005 ? var80 = .0019277012166729114 : input[1] > 28.500000000000004 ? var80 = -.054445821715687494 : var80 = .045645722976713245 : input[30] > 1e-35 ? var80 = .13402660155331655 : var80 = .008921176001777645 : var80 = -.058547426505451076 : var80 = .08841202222426625 : input[1] > 22.500000000000004 ? input[10] > 9.500000000000002 ? var80 = -.13526418192218206 : var80 = -.03266013432583145 : input[1] > 20.500000000000004 ? input[4] > 27.500000000000004 ? var80 = .0007263224246135398 : var80 = .12450043268647056 : input[1] > 17.500000000000004 ? input[9] > 1.5000000000000002 ? var80 = -.11575657261278308 : var80 = -.01530376565862095 : input[4] > 13.500000000000002 ? input[4] > 22.500000000000004 ? var80 = -.01995960178292952 : var80 = .11216586049153021 : var80 = -.10050961087149474 : var80 = .08848063368485726 : input[30] > 1e-35 ? input[224] > 1e-35 ? input[1] > 52.50000000000001 ? var80 = .10303451081526649 : var80 = -.01375730267020699 : input[1] > 28.500000000000004 ? input[2] > 20.500000000000004 ? var80 = -.043799548968209395 : var80 = -.12451444314954115 : input[4] > 12.500000000000002 ? var80 = -.03838117361958468 : var80 = .06504990789767144 : input[57] > 1e-35 ? var80 = .06890006938293915 : var80 = .0003914274695562949;
  let var81;
  input[53] > 1e-35 ? input[4] > 11.500000000000002 ? input[8] > 617.5000000000001 ? input[2] > 41.50000000000001 ? var81 = .004271749009686975 : var81 = -.10523878297127605 : var81 = .04633982158107851 : var81 = -.10349713975483057 : input[183] > 1e-35 ? input[15] > 1e-35 ? var81 = -.08655730561951676 : input[8] > 919.5000000000001 ? var81 = -.0676453705610183 : input[7] > 18.500000000000004 ? var81 = -.027787974193650575 : var81 = .08012784576991301 : input[227] > 1e-35 ? input[1] > 6.500000000000001 ? input[3] > 8.500000000000002 ? input[210] > 1e-35 ? var81 = .07185850683316512 : input[8] > 201.50000000000003 ? input[8] > 348.50000000000006 ? input[23] > 1e-35 ? input[8] > 1049.5000000000002 ? var81 = -.03473877164537313 : input[8] > 719.5000000000001 ? var81 = .10471053866934404 : var81 = .008236107678382981 : input[4] > 57.50000000000001 ? var81 = .09412219478825269 : input[10] > 66.50000000000001 ? var81 = -.13884338641811986 : input[10] > 19.500000000000004 ? input[10] > 22.500000000000004 ? input[0] > 2490.5000000000005 ? var81 = -.040681323751002293 : var81 = .06374650297561021 : var81 = .12884615227401788 : input[10] > 5.500000000000001 ? var81 = -.0887517295786972 : input[8] > 597.5000000000001 ? input[18] > 1e-35 ? var81 = -.05474068967150784 : var81 = .03744700650806603 : var81 = -.07846396348680855 : input[1] > 42.50000000000001 ? var81 = .018972315810821302 : var81 = .10953621007604744 : input[5] > 4439.500000000001 ? var81 = .010999776705494586 : input[1] > 40.50000000000001 ? var81 = -.12394200059775967 : input[10] > 2.5000000000000004 ? var81 = .013528093962849453 : var81 = -.09222088417048682 : var81 = -.12662967149701485 : var81 = .09327296405849603 : input[3] > 99.50000000000001 ? var81 = -.013581954439986752 : var81 = .0005526498251862075;
  let var82;
  input[187] > 1e-35 ? input[243] > 1e-35 ? var82 = -.08392792551692502 : input[10] > 68.50000000000001 ? var82 = .07871769409454053 : input[10] > 8.500000000000002 ? input[10] > 16.500000000000004 ? input[2] > 17.500000000000004 ? input[3] > 31.500000000000004 ? input[91] > 1e-35 ? input[10] > 21.500000000000004 ? input[10] > 33.50000000000001 ? input[10] > 48.50000000000001 ? var82 = -.0825306209711224 : var82 = .049559996084532945 : var82 = -.1064938580886302 : var82 = .03353240732240275 : var82 = .045985370399163464 : input[1] > 42.50000000000001 ? input[4] > 20.500000000000004 ? var82 = .16966001471529374 : input[1] > 57.50000000000001 ? var82 = -.005772777673676247 : var82 = .09383677041525058 : input[8] > 747.5000000000001 ? var82 = .054068175469351235 : var82 = -.049968216310277036 : input[8] > 753.5000000000001 ? var82 = -.0679383555784074 : input[4] > 8.500000000000002 ? var82 = -.059757341189735386 : var82 = .05701083682780414 : var82 = -.052497281448921164 : input[6] > 12.500000000000002 ? input[8] > 969.5000000000001 ? input[4] > 23.500000000000004 ? var82 = .05820296128730006 : var82 = -.1063042385102475 : input[1] > 49.50000000000001 ? input[8] > 302.50000000000006 ? var82 = .15340611616954566 : var82 = .04385036188666874 : input[0] > 4449.500000000001 ? var82 = -.02110897605541555 : input[1] > 24.500000000000004 ? input[2] > 17.500000000000004 ? var82 = .004840354641006495 : var82 = .09967827580276283 : var82 = .11605363537391578 : input[9] > 19.500000000000004 ? var82 = -.0735831692725717 : var82 = .019973331823355176 : input[306] > 1e-35 ? input[149] > 1e-35 ? var82 = -.08968948874343531 : input[8] > 1094.5000000000002 ? input[10] > 15.500000000000002 ? var82 = -.02442182361342386 : var82 = .10334853004243093 : var82 = -.030431948680167104 : var82 = -956078595250818e-19;
  let var83;
  input[294] > 1e-35 ? input[1] > 26.500000000000004 ? input[0] > 4078.5000000000005 ? var83 = -.040232505718244854 : input[0] > 3030.5000000000005 ? var83 = .0634109586813073 : var83 = -.04043617034245621 : var83 = -.06385323610738443 : input[120] > 1e-35 ? input[4] > 18.500000000000004 ? var83 = -.007859096946435131 : var83 = .07282728486115758 : input[229] > 1e-35 ? input[0] > 2952.5000000000005 ? input[17] > 1e-35 ? var83 = .05515771679628051 : var83 = -.04214471312668263 : var83 = -.09589322222261765 : input[193] > 1e-35 ? var83 = -.05056345906812831 : input[121] > 1e-35 ? input[243] > 1e-35 ? var83 = .14857706653119385 : input[4] > 9.500000000000002 ? input[1] > 26.500000000000004 ? input[2] > 59.50000000000001 ? var83 = -.08152604001147906 : input[11] > 1e-35 ? var83 = .09132936522356462 : input[15] > 1e-35 ? input[4] > 23.500000000000004 ? var83 = .13100930780107503 : input[10] > 25.500000000000004 ? var83 = .05921074710011526 : var83 = -.07226005736695183 : input[0] > 3304.5000000000005 ? input[0] > 3707.5000000000005 ? input[0] > 4053.5000000000005 ? var83 = .0009447118243153454 : var83 = -.09820565036865991 : var83 = .057146909749745546 : input[0] > 2115.5000000000005 ? var83 = -.12331216726611678 : var83 = .007281983677694285 : input[2] > 56.50000000000001 ? var83 = .012310154675612615 : var83 = -.08873665774670461 : input[6] > 25.500000000000004 ? var83 = .134708740821879 : input[9] > 5.500000000000001 ? var83 = -.0805901581148979 : input[224] > 1e-35 ? var83 = -.063684477784257 : input[7] > 2.5000000000000004 ? input[19] > 1e-35 ? var83 = .10842593386554122 : input[2] > 13.500000000000002 ? var83 = .06466798320378395 : var83 = -.08578130788886655 : var83 = -.03590892078300114 : var83 = .0003499894043880708;
  let var84;
  input[134] > 1e-35 ? input[6] > 50.50000000000001 ? input[0] > 3601.5000000000005 ? var84 = .10839808814624702 : var84 = -.028043875308180352 : input[7] > 30.500000000000004 ? input[8] > 932.5000000000001 ? var84 = -.007478368069393829 : var84 = -.09066751344326617 : input[0] > 3588.5000000000005 ? input[5] > 4748.500000000001 ? var84 = .04035247751736232 : input[0] > 4255.500000000001 ? var84 = -.1310865624507367 : input[0] > 4004.5000000000005 ? var84 = .06647367311982634 : var84 = -.08339693352955757 : input[4] > 10.500000000000002 ? input[1] > 34.50000000000001 ? var84 = -.011618902907510411 : var84 = .1114646660406691 : input[10] > 2.5000000000000004 ? input[0] > 3072.5000000000005 ? var84 = .09356028223727986 : var84 = -.03811765057032162 : var84 = -.09456215497345526 : input[280] > 1e-35 ? input[7] > 70.50000000000001 ? var84 = .10322956436499003 : input[2] > 22.500000000000004 ? input[1] > 83.50000000000001 ? var84 = .1146142460964847 : input[1] > 62.50000000000001 ? var84 = -.09679869865322362 : input[9] > 71.50000000000001 ? var84 = -.07377580769927583 : input[4] > 19.500000000000004 ? input[0] > 4571.500000000001 ? var84 = -.039046426387852974 : var84 = .04558778688367152 : var84 = .11220830937352602 : input[7] > 5.500000000000001 ? input[9] > 17.500000000000004 ? input[8] > 1067.5000000000002 ? var84 = .03261697816211156 : input[15] > 1e-35 ? var84 = .02586252542264368 : input[2] > 14.500000000000002 ? var84 = -.016420452667484604 : var84 = -.1011799626006976 : var84 = -.13787471318963773 : input[6] > 4.500000000000001 ? input[8] > 427.50000000000006 ? input[10] > 36.50000000000001 ? var84 = .010193588102560583 : var84 = .11748729525930773 : var84 = -.04468162226743652 : var84 = -.028365274393617957 : input[71] > 1e-35 ? var84 = .05115139346588793 : var84 = -.0001510425316936658;
  let var85;
  input[298] > 1e-35 ? input[8] > 81.50000000000001 ? input[8] > 119.50000000000001 ? input[4] > 64.50000000000001 ? var85 = .09072192054181037 : input[9] > 72.50000000000001 ? input[8] > 1094.5000000000002 ? var85 = .020637047900190317 : var85 = -.1017300802134141 : input[1] > 23.500000000000004 ? input[9] > 12.500000000000002 ? input[0] > 2815.5000000000005 ? input[0] > 3183.5000000000005 ? input[3] > 23.500000000000004 ? input[3] > 45.50000000000001 ? input[4] > 48.50000000000001 ? var85 = -.04632587527094407 : var85 = .08603684785510396 : var85 = -.05101401015448496 : var85 = .025466432054358498 : var85 = -.07897811963329214 : input[6] > 13.500000000000002 ? input[10] > 26.500000000000004 ? var85 = .020385355430046367 : var85 = .12032592051335252 : var85 = -.012387370292173013 : input[2] > 23.500000000000004 ? var85 = -.12568545484492677 : var85 = -.022261190943521976 : input[8] > 634.5000000000001 ? input[8] > 857.5000000000001 ? var85 = .043528764484784536 : var85 = .14352071657196003 : var85 = -.009332833816977268 : var85 = .11186782227735846 : var85 = -.0737365712425554 : input[136] > 1e-35 ? input[0] > 1937.5000000000002 ? var85 = -.05649104643152564 : var85 = .03884200719305747 : input[42] > 1e-35 ? var85 = -.07191700385792335 : input[116] > 1e-35 ? input[9] > 2.5000000000000004 ? input[9] > 17.500000000000004 ? var85 = -.04103416502526736 : var85 = .04881823954656287 : input[4] > 15.500000000000002 ? var85 = .009342724662897898 : input[0] > 3969.5000000000005 ? var85 = -.025637309961309498 : var85 = -.12574492012987865 : input[212] > 1e-35 ? input[19] > 1e-35 ? var85 = -.08185697075265091 : input[0] > 2215.5000000000005 ? var85 = .030063975892297354 : input[0] > 807.5000000000001 ? var85 = -.03924325550733229 : var85 = .0415330999189793 : var85 = -.00024374664461674863;
  let var86;
  input[3] > 7.500000000000001 ? var86 = .0005117490419655908 : input[129] > 1e-35 ? input[0] > 2904.5000000000005 ? input[0] > 4004.5000000000005 ? var86 = .025798416259686565 : var86 = .13251610353146012 : var86 = -.029900559552677654 : input[1] > 81.50000000000001 ? input[1] > 110.50000000000001 ? input[0] > 4242.500000000001 ? var86 = -.11098564237775424 : var86 = 25960925309712775e-21 : input[0] > 4177.500000000001 ? input[9] > 35.50000000000001 ? var86 = .15347826616466054 : input[3] > 4.500000000000001 ? var86 = .10379320730958941 : var86 = -.008896303020010654 : input[0] > 3415.5000000000005 ? input[0] > 3830.5000000000005 ? var86 = .03159791088468647 : var86 = -.10612873364104258 : var86 = .05059856107348746 : input[133] > 1e-35 ? input[2] > 5.500000000000001 ? var86 = -.02335760775001469 : var86 = -.1379386577903324 : input[1] > 62.50000000000001 ? input[3] > 2.5000000000000004 ? var86 = -.011164334474672973 : var86 = -.06594044410501655 : input[207] > 1e-35 ? var86 = -.1014214372326535 : input[8] > 3.5000000000000004 ? input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var86 = -.01725821503981916 : var86 = .05594086838700241 : input[203] > 1e-35 ? input[1] > 44.50000000000001 ? input[1] > 51.50000000000001 ? var86 = -.04226531631656534 : var86 = -.14409800530171432 : var86 = -.03245576341206398 : input[8] > 4214.500000000001 ? var86 = .0895409165534886 : input[247] > 1e-35 ? var86 = -.06506383629143335 : input[118] > 1e-35 ? var86 = -.07214270121257443 : input[8] > 546.5000000000001 ? var86 = -.004385020865473831 : var86 = .009321812545248529 : input[0] > 1639.5000000000002 ? input[13] > 1e-35 ? var86 = .046278501133958524 : var86 = -.030835570926968044 : input[0] > 493.50000000000006 ? var86 = -.12794504651610425 : var86 = .009415039807550776;
  let var87;
  input[304] > 1e-35 ? var87 = -.04717777269217453 : input[76] > 1e-35 ? var87 = -.05813439142128324 : input[1] > 59.50000000000001 ? input[0] > 350.50000000000006 ? input[53] > 1e-35 ? var87 = -.09648224457374217 : input[132] > 1e-35 ? var87 = .07089308107910267 : input[0] > 2248.5000000000005 ? input[5] > 2525.5000000000005 ? input[9] > 1.5000000000000002 ? input[114] > 1e-35 ? var87 = -.08595213071749083 : input[9] > 14.500000000000002 ? input[9] > 33.50000000000001 ? input[285] > 1e-35 ? var87 = .10838431695638147 : input[230] > 1e-35 ? var87 = .06458713915750626 : input[0] > 3219.5000000000005 ? input[3] > 23.500000000000004 ? input[9] > 69.50000000000001 ? var87 = .050071316251979 : var87 = -.006356941111525215 : input[6] > 8.500000000000002 ? var87 = -.0384814076434817 : input[1] > 73.50000000000001 ? input[0] > 3746.5000000000005 ? var87 = .10217402850540398 : var87 = -.048840949025349197 : var87 = -.03668313197909846 : input[7] > 39.50000000000001 ? var87 = -.0562642841496003 : input[10] > 2.5000000000000004 ? var87 = .09749777369987417 : var87 = -.04848223121417616 : input[0] > 5453.500000000001 ? var87 = .08316648226133942 : var87 = -.0261979698267618 : input[212] > 1e-35 ? var87 = .09565573198318654 : input[5] > 4814.500000000001 ? input[8] > 963.5000000000001 ? input[8] > 1514.5000000000002 ? var87 = .04837009746506856 : var87 = -.09184360565631328 : var87 = .0032411047845613606 : input[0] > 4733.500000000001 ? var87 = .0977378556864798 : var87 = .010776545559325588 : var87 = -.012483310473120218 : var87 = -.049284121449103935 : var87 = .011962641341789565 : input[1] > 67.50000000000001 ? input[1] > 77.50000000000001 ? var87 = -.08380361910948711 : var87 = .07375088778585813 : var87 = -.1084864186071348 : var87 = .0007819503469605476;
  let var88;
  input[7] > 17.500000000000004 ? input[115] > 1e-35 ? var88 = .08741852531696623 : input[167] > 1e-35 ? var88 = .10078975495600809 : var88 = -.0018324767784017562 : input[290] > 1e-35 ? var88 = -.0850089851255888 : input[74] > 1e-35 ? input[10] > 16.500000000000004 ? var88 = .1379733311640402 : var88 = -.0038500648529631075 : input[6] > 29.500000000000004 ? input[8] > 876.5000000000001 ? input[0] > 3129.5000000000005 ? input[9] > 5.500000000000001 ? input[8] > 1765.5000000000002 ? var88 = -.09360083033774169 : var88 = .061471353193188374 : input[10] > 11.500000000000002 ? input[10] > 31.500000000000004 ? var88 = -.015599362579530679 : input[0] > 4593.500000000001 ? var88 = -.12029549262691491 : var88 = -.018917032256501397 : var88 = .04632831686576592 : var88 = .06892347785444271 : input[4] > 8.500000000000002 ? input[10] > 33.50000000000001 ? var88 = -.05894883236412263 : var88 = .05213944998315824 : var88 = .12621779223564986 : input[243] > 1e-35 ? input[6] > 16.500000000000004 ? input[0] > 4141.500000000001 ? input[0] > 5850.500000000001 ? var88 = .07577412405680808 : var88 = -.053144737214742235 : input[1] > 29.500000000000004 ? input[9] > 16.500000000000004 ? var88 = -.0277076900736147 : input[1] > 65.50000000000001 ? var88 = -.023587471585763506 : var88 = .10184896592433082 : var88 = -.057699270527916825 : var88 = -.041191811945739454 : input[114] > 1e-35 ? input[2] > 23.500000000000004 ? var88 = .06566902102799584 : input[10] > 25.500000000000004 ? var88 = -.07033633753181047 : var88 = -.01599120398351932 : input[242] > 1e-35 ? input[0] > 2402.5000000000005 ? var88 = -.08108035861059537 : var88 = .04184690010531078 : input[35] > 1e-35 ? input[0] > 2904.5000000000005 ? var88 = -.12431182772561139 : var88 = .01886235886984271 : var88 = .0025579594894418116;
  let var89;
  input[8] > 2915.5000000000005 ? input[101] > 1e-35 ? var89 = .08648323956719083 : input[0] > 93.50000000000001 ? input[196] > 1e-35 ? var89 = -.09509320772734361 : input[4] > 1.5000000000000002 ? input[5] > 1106.5000000000002 ? input[5] > 1191.5000000000002 ? input[283] > 1e-35 ? var89 = -.11268313808648661 : input[10] > 12.500000000000002 ? input[131] > 1e-35 ? var89 = .0687641681341721 : input[10] > 102.50000000000001 ? var89 = -.09667920080214842 : input[4] > 15.500000000000002 ? input[8] > 2992.5000000000005 ? input[1] > 24.500000000000004 ? input[1] > 71.50000000000001 ? var89 = -.06762578396473291 : input[10] > 65.50000000000001 ? var89 = -.05226727783610509 : input[282] > 1e-35 ? var89 = .09911438410640917 : input[19] > 1e-35 ? var89 = .06915156336429933 : var89 = -.006565637886508241 : var89 = -.08344300251849307 : var89 = -.0928863907927501 : input[1] > 60.50000000000001 ? input[2] > 17.500000000000004 ? var89 = .19428463865406298 : var89 = .016073883020956765 : input[13] > 1e-35 ? var89 = .06864077097923665 : var89 = -.01388867527034731 : input[0] > 1847.5000000000002 ? var89 = .004655280608161356 : input[1] > 40.50000000000001 ? var89 = .031406054057765996 : var89 = .12798062439212832 : var89 = .09859670536264255 : input[10] > 2.5000000000000004 ? input[9] > 68.50000000000001 ? var89 = .08821759640665892 : input[9] > 32.50000000000001 ? input[8] > 3960.0000000000005 ? input[1] > 31.500000000000004 ? var89 = -.0706095614785733 : var89 = .04227164041372561 : var89 = -.1056906923176064 : input[2] > 8.500000000000002 ? input[19] > 1e-35 ? var89 = -.07139533369873902 : var89 = .008952586782921625 : var89 = .06086212582180936 : var89 = -.0816938490403437 : var89 = -.051224901945956025 : var89 = -.10525399124186095 : var89 = .000270924147208224;
  let var90;
  input[122] > 1e-35 ? input[0] > 2461.5000000000005 ? input[2] > 36.50000000000001 ? var90 = .029186512383291244 : input[7] > 1.5000000000000002 ? var90 = -.14984127276725573 : input[1] > 40.50000000000001 ? var90 = .032757060730648144 : var90 = -.07675575422749602 : input[6] > 8.500000000000002 ? var90 = .10599766037117893 : var90 = -.0541423394552156 : input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 61.50000000000001 ? input[17] > 1e-35 ? var90 = -.051394622947855385 : var90 = .03237141302699347 : var90 = .12526173027943244 : var90 = .000579473126472788 : input[18] > 1e-35 ? input[3] > 4.500000000000001 ? input[3] > 6.500000000000001 ? input[0] > 5453.500000000001 ? var90 = -.07383912482657777 : input[0] > 5147.500000000001 ? var90 = .07008813937042091 : input[10] > 38.50000000000001 ? var90 = -.06779203808365307 : var90 = -.013782769999524498 : var90 = .0880038869117715 : var90 = -.12846294176070952 : input[281] > 1e-35 ? var90 = -.06810806903850834 : input[10] > 227.50000000000003 ? var90 = -.08937977001661111 : input[10] > 130.50000000000003 ? var90 = .10538920632708033 : input[145] > 1e-35 ? input[4] > 6.500000000000001 ? input[9] > 16.500000000000004 ? input[4] > 18.500000000000004 ? var90 = .011036530162093841 : var90 = -.11500797478569702 : var90 = .03702229366129399 : var90 = .07242026683784307 : input[189] > 1e-35 ? var90 = .03331407112090286 : input[9] > 33.50000000000001 ? input[201] > 1e-35 ? var90 = .08979610115743614 : input[7] > 57.50000000000001 ? input[1] > 20.500000000000004 ? var90 = -.02608892716555304 : var90 = .09609599320761308 : input[9] > 105.50000000000001 ? var90 = -.06848127135991534 : var90 = .0023675721254089715 : input[86] > 1e-35 ? var90 = -.11049635625500497 : var90 = -.004847764219432233;
  let var91;
  input[125] > 1e-35 ? input[0] > 3969.5000000000005 ? var91 = -.09462233499115416 : var91 = .05235324508465096 : input[17] > 1e-35 ? input[49] > 1e-35 ? input[10] > 19.500000000000004 ? var91 = -.030700661288166148 : var91 = .0870883677166864 : input[10] > 3.5000000000000004 ? input[3] > 18.500000000000004 ? input[0] > 3544.5000000000005 ? input[188] > 1e-35 ? input[9] > 7.500000000000001 ? var91 = .03149547314036763 : var91 = -.08166208257451366 : input[0] > 5850.500000000001 ? var91 = -.10228136324773157 : input[102] > 1e-35 ? var91 = -.10572585290676295 : input[8] > 726.5000000000001 ? input[5] > 3657.5000000000005 ? var91 = .01782894842128785 : input[13] > 1e-35 ? var91 = .002680190260979968 : var91 = .1773965720476949 : input[2] > 72.50000000000001 ? var91 = .09090831938627947 : input[1] > 59.50000000000001 ? var91 = -.12297206702816128 : input[0] > 4977.500000000001 ? var91 = .09899015653118268 : var91 = -.022207141540838887 : input[4] > 32.50000000000001 ? input[1] > 34.50000000000001 ? var91 = -.0675900954187773 : var91 = .012336403425364092 : var91 = -.0017002325391924573 : input[6] > 7.500000000000001 ? input[1] > 17.500000000000004 ? var91 = -.02671721777458802 : var91 = -.09242452991958029 : input[284] > 1e-35 ? var91 = -.08585691288582491 : var91 = .013332890564324447 : input[4] > 14.500000000000002 ? var91 = -.005245022074799553 : input[23] > 1e-35 ? var91 = -.020036720167235768 : input[1] > 29.500000000000004 ? input[114] > 1e-35 ? var91 = -.09289852307936758 : input[116] > 1e-35 ? var91 = -.09686573010015055 : input[8] > 804.5000000000001 ? var91 = .03812547148215318 : var91 = .005162744968176633 : input[9] > 43.50000000000001 ? var91 = -.059246106396159376 : var91 = .050370113808135275 : var91 = .000794041852811028;
  let var92;
  input[3] > 7.500000000000001 ? var92 = .0004981426543104341 : input[9] > 114.50000000000001 ? var92 = .05666010099424601 : input[129] > 1e-35 ? input[6] > 3.5000000000000004 ? var92 = -.019061766497948867 : var92 = .07193491146561211 : input[186] > 1e-35 ? input[0] > 2653.5000000000005 ? var92 = -.006044199577160493 : var92 = .1147136801028133 : input[6] > 85.50000000000001 ? input[8] > 847.5000000000001 ? var92 = .11486607015912494 : input[9] > 16.500000000000004 ? var92 = -.08686820858087294 : var92 = .06119632492911875 : input[127] > 1e-35 ? input[0] > 2723.5000000000005 ? input[0] > 3682.5000000000005 ? input[1] > 38.50000000000001 ? var92 = -.022230207980026437 : var92 = .1056683690528792 : var92 = -.05859530800943035 : var92 = .06970608927597141 : input[7] > 3.5000000000000004 ? input[105] > 1e-35 ? var92 = .08073568184886762 : input[107] > 1e-35 ? input[2] > 6.500000000000001 ? var92 = -.05177544573528314 : var92 = .05370469772149028 : input[1] > 35.50000000000001 ? input[0] > 4106.500000000001 ? input[9] > 46.50000000000001 ? input[0] > 4633.500000000001 ? var92 = .15159657923771555 : var92 = -.0060542654587671055 : input[9] > 5.500000000000001 ? var92 = -.042808028205051786 : input[1] > 48.50000000000001 ? var92 = -.010449538258110742 : var92 = .10026907521968294 : var92 = -.04249349329714756 : input[9] > 42.50000000000001 ? input[1] > 19.500000000000004 ? input[8] > 852.5000000000001 ? var92 = -.02272452389409874 : var92 = -.11202691218244319 : input[5] > 1809.5000000000002 ? var92 = -.04460413584255906 : var92 = .08196329474205256 : input[10] > 69.50000000000001 ? var92 = .10221481166238167 : var92 = .0004063052701699382 : input[243] > 1e-35 ? var92 = -.07563941678849846 : input[18] > 1e-35 ? var92 = .02563513231103432 : var92 = -.004740081147303786;
  let var93;
  input[84] > 1e-35 ? input[9] > 6.500000000000001 ? input[2] > 43.50000000000001 ? var93 = .057446442918106 : var93 = -.04404018270156349 : var93 = -.09282976714550464 : input[0] > 384.50000000000006 ? input[204] > 1e-35 ? input[1] > 62.50000000000001 ? var93 = -.05930486238817954 : input[1] > 29.500000000000004 ? var93 = .06955866121256543 : input[8] > 597.5000000000001 ? var93 = -.06538593556505168 : var93 = .06212512595497445 : var93 = .00021102929959182257 : input[9] > 90.50000000000001 ? var93 = .0958061289119631 : input[102] > 1e-35 ? var93 = .07172059675638813 : input[1] > 47.50000000000001 ? var93 = -.03879798603977766 : input[297] > 1e-35 ? var93 = .054948234271956144 : input[282] > 1e-35 ? input[2] > 6.500000000000001 ? var93 = .003805910996312012 : var93 = .09304295674749524 : input[11] > 1e-35 ? input[18] > 1e-35 ? var93 = .11252376801858695 : input[288] > 1e-35 ? var93 = -.10293901912180432 : var93 = .014669268837893872 : input[1] > 42.50000000000001 ? var93 = -.05988274123836837 : input[145] > 1e-35 ? var93 = .06142784665288495 : input[3] > 1.5000000000000002 ? input[4] > 4.500000000000001 ? input[1] > 21.500000000000004 ? input[1] > 27.500000000000004 ? input[9] > 24.500000000000004 ? var93 = .038791154988529926 : input[10] > 22.500000000000004 ? input[2] > 19.500000000000004 ? var93 = -.03366718308159971 : var93 = .11936550608549797 : input[1] > 31.500000000000004 ? var93 = -.07454716789539667 : var93 = .027859650621164217 : input[10] > 10.500000000000002 ? var93 = -.11806374092321247 : var93 = -.03506042229223101 : var93 = -.0007080765837654515 : input[10] > 6.500000000000001 ? var93 = -.028077713664996503 : input[2] > 7.500000000000001 ? var93 = .15803724124216814 : var93 = .0351381284833169 : var93 = -.07877953381054767;
  let var94;
  input[131] > 1e-35 ? input[282] > 1e-35 ? input[4] > 23.500000000000004 ? var94 = .14144941521975005 : var94 = .0007727806714190652 : input[9] > 1.5000000000000002 ? input[8] > 2134.5000000000005 ? input[2] > 34.50000000000001 ? var94 = .10514088112381886 : input[7] > 18.500000000000004 ? var94 = -.10370643555956745 : var94 = .04093594315421388 : input[6] > 15.500000000000002 ? input[4] > 9.500000000000002 ? input[10] > 27.500000000000004 ? input[10] > 71.50000000000001 ? var94 = -.0508129468802936 : input[224] > 1e-35 ? var94 = -.037816066368733595 : input[10] > 43.50000000000001 ? var94 = .07793408602607932 : var94 = .017646166646099453 : input[9] > 3.5000000000000004 ? input[9] > 29.500000000000004 ? input[17] > 1e-35 ? var94 = .036972453794202324 : var94 = -.08727431092411866 : input[8] > 427.50000000000006 ? input[8] > 1278.5000000000002 ? var94 = .09475302525132188 : var94 = -.03580104945898193 : var94 = .08349488283861875 : input[10] > 3.5000000000000004 ? input[0] > 1847.5000000000002 ? input[0] > 4280.500000000001 ? input[2] > 27.500000000000004 ? var94 = -.1282448778804823 : var94 = -.014395808269207212 : var94 = -.008940927190750592 : var94 = -.1459118815453748 : input[0] > 4897.500000000001 ? var94 = -.09733068457286576 : input[1] > 57.50000000000001 ? var94 = .06575271409540207 : var94 = -.019556422817450115 : var94 = -.10623959222984136 : input[18] > 1e-35 ? var94 = .11280940901275241 : input[8] > 319.50000000000006 ? input[2] > 6.500000000000001 ? var94 = .008125645893104896 : var94 = -.11084368630465868 : var94 = .0584398731508786 : input[0] > 350.50000000000006 ? input[3] > 83.50000000000001 ? var94 = -.05854904579626861 : input[4] > 5.500000000000001 ? var94 = .02985784951394175 : var94 = -.03247600140149334 : var94 = -.11152899295304973 : var94 = -.00035424577714215764;
  let var95;
  input[32] > 1e-35 ? input[17] > 1e-35 ? input[8] > 359.50000000000006 ? input[8] > 804.5000000000001 ? var95 = -.06563670567578264 : var95 = .067656954313663 : var95 = -.10388217548685377 : input[8] > 2302.5000000000005 ? var95 = .07190621943790435 : input[4] > 67.50000000000001 ? var95 = .060020507643618604 : input[4] > 38.50000000000001 ? var95 = -.08707253184321638 : input[2] > 11.500000000000002 ? input[2] > 16.500000000000004 ? input[1] > 31.500000000000004 ? input[1] > 59.50000000000001 ? var95 = -.06568134366461277 : input[8] > 1075.5000000000002 ? var95 = -.004768057709758692 : var95 = .11785959165999467 : var95 = -.05080221682879267 : var95 = .14814206127494542 : var95 = -.07241946332311736 : input[253] > 1e-35 ? var95 = -.058893562861261274 : input[4] > 61.50000000000001 ? input[283] > 1e-35 ? input[10] > 23.500000000000004 ? var95 = -.02471195342450034 : var95 = .11866056464409412 : input[10] > 44.50000000000001 ? input[1] > 16.500000000000004 ? input[8] > 2640.0000000000005 ? var95 = -.10741850739482771 : var95 = .010051635824944 : var95 = .12502069436017124 : input[8] > 1971.5000000000002 ? input[1] > 23.500000000000004 ? input[308] > 1e-35 ? var95 = .10511236013756364 : input[10] > 10.500000000000002 ? input[1] > 53.50000000000001 ? var95 = -.08992396138178163 : var95 = .010944365997007212 : var95 = .06221307021813793 : var95 = .1286024087559141 : input[127] > 1e-35 ? var95 = .06568148624531012 : input[10] > 40.50000000000001 ? var95 = -.07567979134643352 : input[5] > 5647.500000000001 ? var95 = .07594672895572069 : var95 = -.018158016446439187 : input[6] > 55.50000000000001 ? var95 = .009293422430111872 : input[4] > 45.50000000000001 ? var95 = -.017749818406964022 : input[2] > 46.50000000000001 ? var95 = .01714136511113982 : var95 = -724762291423549e-19;
  let var96;
  input[1] > 24.500000000000004 ? input[103] > 1e-35 ? input[8] > 48.50000000000001 ? input[17] > 1e-35 ? var96 = -.048689215588703864 : input[9] > 27.500000000000004 ? input[0] > 3916.5000000000005 ? var96 = .07084726276890757 : var96 = -.11232323677722932 : var96 = .04812773089510436 : var96 = .11757502216780046 : input[5] > 1464.5000000000002 ? input[5] > 1505.5000000000002 ? input[167] > 1e-35 ? var96 = .07470606002425358 : input[1] > 53.50000000000001 ? input[132] > 1e-35 ? var96 = .0879462816013881 : var96 = -.002966662093626573 : input[306] > 1e-35 ? var96 = -.04588085188342676 : var96 = .0031910005157084823 : input[3] > 10.500000000000002 ? input[10] > 20.500000000000004 ? var96 = -.006600332774461143 : var96 = .1272481351557754 : var96 = -.09030973597154808 : input[284] > 1e-35 ? input[1] > 38.50000000000001 ? input[10] > 2.5000000000000004 ? var96 = .011884312066620044 : var96 = .11678751052403374 : input[4] > 8.500000000000002 ? var96 = .03627129613273813 : var96 = -.12132783497902287 : var96 = -.006784372643244717 : input[18] > 1e-35 ? input[3] > 4.500000000000001 ? input[3] > 6.500000000000001 ? input[0] > 5453.500000000001 ? var96 = -.06830131718398992 : input[0] > 5147.500000000001 ? var96 = .062360406249609306 : input[4] > 4.500000000000001 ? var96 = -.013162203864592055 : var96 = -.07153029184927609 : var96 = .07628618062271557 : var96 = -.12085065687320373 : input[190] > 1e-35 ? var96 = -.045816889524231186 : input[137] > 1e-35 ? var96 = -.07956001795911584 : input[199] > 1e-35 ? input[0] > 3853.5000000000005 ? var96 = .025895337822752502 : var96 = -.06503949350616421 : input[10] > 227.50000000000003 ? var96 = -.09989456525790491 : input[10] > 130.50000000000003 ? var96 = .08616651057030683 : var96 = .0001234981796706021;
  let var97;
  input[8] > 1014.5000000000001 ? input[9] > 137.50000000000003 ? var97 = -.08778879924617534 : input[8] > 1022.5000000000001 ? input[285] > 1e-35 ? input[9] > 64.50000000000001 ? var97 = .04955806187281689 : input[0] > 3670.5000000000005 ? input[10] > 32.50000000000001 ? var97 = -.141732381961068 : var97 = -.0317152307496497 : var97 = -.02074638849097191 : input[0] > 93.50000000000001 ? input[0] > 3072.5000000000005 ? input[10] > 100.50000000000001 ? input[4] > 24.500000000000004 ? input[8] > 1336.5000000000002 ? var97 = .12191801556691254 : var97 = -.0003444689085397977 : var97 = .005739668504631604 : input[146] > 1e-35 ? input[308] > 1e-35 ? var97 = .015237524791728777 : input[6] > 61.50000000000001 ? input[4] > 63.50000000000001 ? var97 = -.05676033995381961 : var97 = .10933961076803381 : input[4] > 26.500000000000004 ? var97 = -.11667582544549814 : input[8] > 1765.5000000000002 ? var97 = .032174455312047705 : var97 = -.0755016390126608 : input[293] > 1e-35 ? var97 = -.08234885407658332 : input[9] > 41.50000000000001 ? input[0] > 3830.5000000000005 ? var97 = .026571311956824436 : input[15] > 1e-35 ? var97 = .06175459479851121 : var97 = -.018778084411148754 : input[9] > 40.50000000000001 ? var97 = -.09420232889965811 : var97 = -.004578248021263184 : input[2] > 1.5000000000000002 ? var97 = .005453714644971445 : var97 = -.03907138175699279 : var97 = -.055296364182154736 : input[23] > 1e-35 ? var97 = .036555134842143476 : input[0] > 4188.500000000001 ? input[6] > 29.500000000000004 ? var97 = -.09358146510580179 : var97 = .060524657996178094 : var97 = -.11245101144669545 : input[125] > 1e-35 ? input[9] > 1.5000000000000002 ? var97 = -.12698331085931538 : var97 = .006059605604079918 : input[2] > 196.50000000000003 ? var97 = -.09451315810804783 : var97 = .0011390147031687425;
  let var98;
  input[8] > 2830.5000000000005 ? input[1] > 31.500000000000004 ? input[9] > 32.50000000000001 ? input[5] > 1234.5000000000002 ? input[8] > 3794.5000000000005 ? var98 = .05517359070460923 : var98 = -.04758751221404857 : var98 = -.09482078194138792 : input[8] > 2992.5000000000005 ? input[1] > 101.50000000000001 ? var98 = .1040436595565776 : input[9] > 21.500000000000004 ? var98 = .04032250517675179 : input[107] > 1e-35 ? var98 = .05978752253058374 : input[210] > 1e-35 ? input[4] > 37.50000000000001 ? var98 = .1192453009230486 : input[1] > 51.50000000000001 ? var98 = .0443376336292195 : var98 = -.07967674833321865 : input[5] > 2117.5000000000005 ? input[9] > 10.500000000000002 ? var98 = -.10025078607591283 : input[0] > 2882.5000000000005 ? input[18] > 1e-35 ? var98 = -.08999822408398037 : var98 = .017533219253893447 : input[9] > 1.5000000000000002 ? input[4] > 12.500000000000002 ? var98 = -.061850439226075 : var98 = .08849196353361093 : var98 = .10536348167793089 : input[92] > 1e-35 ? var98 = .04894947712119185 : input[9] > 16.500000000000004 ? var98 = .05900227903883853 : input[9] > 5.500000000000001 ? var98 = -.11946594348916476 : var98 = -.03652096348071964 : input[1] > 41.50000000000001 ? var98 = -.07411603110840567 : var98 = -.00021033247574340914 : input[10] > 22.500000000000004 ? input[9] > 68.50000000000001 ? var98 = .08493634342741495 : input[11] > 1e-35 ? var98 = -.10899097825564363 : var98 = -.006156708838964173 : input[8] > 3198.5000000000005 ? input[2] > 41.50000000000001 ? var98 = .08356655906359918 : input[7] > 25.500000000000004 ? var98 = -.09475076526194888 : input[10] > 5.500000000000001 ? var98 = -.01999406228763778 : var98 = .06696212545889428 : input[6] > 20.500000000000004 ? var98 = .14713592661393468 : var98 = .0459917279002218 : var98 = .00027445928493734093;
  let var99;
  input[223] > 1e-35 ? input[1] > 31.500000000000004 ? input[8] > 634.5000000000001 ? var99 = -.06904501553217077 : var99 = .05696231672035904 : var99 = -.1124703178077813 : input[99] > 1e-35 ? input[1] > 89.50000000000001 ? var99 = -.05074261170009721 : input[1] > 57.50000000000001 ? input[8] > 969.5000000000001 ? var99 = -.011419256378538392 : input[0] > 3830.5000000000005 ? var99 = .140315841503076 : var99 = .02403434913963024 : input[1] > 31.500000000000004 ? input[8] > 65.50000000000001 ? input[2] > 10.500000000000002 ? var99 = -.04027822909411164 : var99 = .03176085103667189 : var99 = .06779515865838849 : input[4] > 15.500000000000002 ? var99 = .0762878389015175 : input[8] > 175.50000000000003 ? input[0] > 3030.5000000000005 ? input[8] > 1041.5000000000002 ? var99 = .06124039747298539 : var99 = -.04312732764434027 : var99 = .09161522761808062 : var99 = -.09663512235460074 : input[280] > 1e-35 ? input[6] > 45.50000000000001 ? input[1] > 46.50000000000001 ? var99 = .11211681010488772 : input[13] > 1e-35 ? var99 = .06725735814960367 : var99 = -.046744031455827846 : input[10] > 44.50000000000001 ? input[0] > 3400.5000000000005 ? input[0] > 4004.5000000000005 ? input[2] > 22.500000000000004 ? var99 = .11743605068905603 : var99 = -.011309033539148687 : var99 = -.07896094707523052 : var99 = .12862714793172117 : input[10] > 1.5000000000000002 ? input[8] > 455.50000000000006 ? input[0] > 4706.500000000001 ? var99 = -.09218756798869711 : input[10] > 19.500000000000004 ? input[0] > 1894.5000000000002 ? input[0] > 3719.5000000000005 ? var99 = .02836295848998302 : var99 = .12210680366745175 : var99 = -.058302317470509096 : input[5] > 4144.500000000001 ? var99 = .06123341960495106 : var99 = -.03840046906926525 : var99 = -.05221474543453495 : var99 = .03988215485860711 : var99 = -.00033074684693083496;
  let var100 = sigmoid(var0 + var1 + var2 + var3 + var4 + var5 + var6 + var7 + var8 + var9 + var10 + var11 + var12 + var13 + var14 + var15 + var16 + var17 + var18 + var19 + var20 + var21 + var22 + var23 + var24 + var25 + var26 + var27 + var28 + var29 + var30 + var31 + var32 + var33 + var34 + var35 + var36 + var37 + var38 + var39 + var40 + var41 + var42 + var43 + var44 + var45 + var46 + var47 + var48 + var49 + var50 + var51 + var52 + var53 + var54 + var55 + var56 + var57 + var58 + var59 + var60 + var61 + var62 + var63 + var64 + var65 + var66 + var67 + var68 + var69 + var70 + var71 + var72 + var73 + var74 + var75 + var76 + var77 + var78 + var79 + var80 + var81 + var82 + var83 + var84 + var85 + var86 + var87 + var88 + var89 + var90 + var91 + var92 + var93 + var94 + var95 + var96 + var97 + var98 + var99);
  return [1 - var100, var100];
}
__name(multilineModelPredict, "multilineModelPredict");
function sigmoid(x) {
  if (x < 0) {
    let z = Math.exp(x);
    return z / (1 + z);
  }
  return 1 / (1 + Math.exp(-x));
}
__name(sigmoid, "sigmoid");
var commentMap = {
    javascript: ["//"],
    typescript: ["//"],
    typescriptreact: ["//"],
    javascriptreact: ["//"],
    vue: ["//", "-->"],
    php: ["//", "#"],
    dart: ["//"],
    go: ["//"],
    cpp: ["//"],
    scss: ["//"],
    csharp: ["//"],
    java: ["//"],
    c: ["//"],
    rust: ["//"],
    python: ["#"],
    markdown: ["#", "-->"],
    css: ["*/"]
  },
  languageMap = {
    javascript: 1,
    javascriptreact: 2,
    typescript: 3,
    typescriptreact: 4,
    python: 5,
    go: 6,
    ruby: 7
  };
function hasComment(text, lineNumber, language, ignoreEmptyLines = !0) {
  let lines = text.split(`
`);
  if (ignoreEmptyLines && (lines = lines.filter(line => line.trim().length > 0)), Math.abs(lineNumber) > lines.length || lineNumber >= lines.length) return !1;
  lineNumber < 0 && (lineNumber = lines.length + lineNumber);
  let line = lines[lineNumber];
  return (commentMap[language] ?? []).some(commentChar => line.includes(commentChar));
}
__name(hasComment, "hasComment");
var PromptFeatures = class {
    static {
      __name(this, "PromptFeatures");
    }
    constructor(promptComponentText, language) {
      let [firstLine, lastLine] = this.firstAndLast(promptComponentText),
        firstAndLastTrimEnd = this.firstAndLast(promptComponentText.trimEnd());
      this.language = language, this.length = promptComponentText.length, this.firstLineLength = firstLine.length, this.lastLineLength = lastLine.length, this.lastLineRstripLength = lastLine.trimEnd().length, this.lastLineStripLength = lastLine.trim().length, this.rstripLength = promptComponentText.trimEnd().length, this.stripLength = promptComponentText.trim().length, this.rstripLastLineLength = firstAndLastTrimEnd[1].length, this.rstripLastLineStripLength = firstAndLastTrimEnd[1].trim().length, this.secondToLastLineHasComment = hasComment(promptComponentText, -2, language), this.rstripSecondToLastLineHasComment = hasComment(promptComponentText.trimEnd(), -2, language), this.prefixEndsWithNewline = promptComponentText.endsWith(`
`), this.lastChar = promptComponentText.slice(-1), this.rstripLastChar = promptComponentText.trimEnd().slice(-1), this.firstChar = promptComponentText[0], this.lstripFirstChar = promptComponentText.trimStart().slice(0, 1);
    }
    firstAndLast(text) {
      let lines = text.split(`
`),
        numLines = lines.length,
        firstLine = lines[0],
        lastLine = lines[numLines - 1];
      return lastLine == "" && numLines > 1 && (lastLine = lines[numLines - 2]), [firstLine, lastLine];
    }
  },
  MultilineModelFeatures = class {
    static {
      __name(this, "MultilineModelFeatures");
    }
    constructor(prefix, suffix, language) {
      this.language = language, this.prefixFeatures = new PromptFeatures(prefix, language), this.suffixFeatures = new PromptFeatures(suffix, language);
    }
    constructFeatures() {
      let numFeatures = new Array(14).fill(0);
      numFeatures[0] = this.prefixFeatures.length, numFeatures[1] = this.prefixFeatures.firstLineLength, numFeatures[2] = this.prefixFeatures.lastLineLength, numFeatures[3] = this.prefixFeatures.lastLineRstripLength, numFeatures[4] = this.prefixFeatures.lastLineStripLength, numFeatures[5] = this.prefixFeatures.rstripLength, numFeatures[6] = this.prefixFeatures.rstripLastLineLength, numFeatures[7] = this.prefixFeatures.rstripLastLineStripLength, numFeatures[8] = this.suffixFeatures.length, numFeatures[9] = this.suffixFeatures.firstLineLength, numFeatures[10] = this.suffixFeatures.lastLineLength, numFeatures[11] = this.prefixFeatures.secondToLastLineHasComment ? 1 : 0, numFeatures[12] = this.prefixFeatures.rstripSecondToLastLineHasComment ? 1 : 0, numFeatures[13] = this.prefixFeatures.prefixEndsWithNewline ? 1 : 0;
      let langFeatures = new Array(Object.keys(languageMap).length + 1).fill(0);
      langFeatures[languageMap[this.language] ?? 0] = 1;
      let prefixLastCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      prefixLastCharFeatures[contextualFilterCharacterMap[this.prefixFeatures.lastChar] ?? 0] = 1;
      let prefixRstripLastCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      prefixRstripLastCharFeatures[contextualFilterCharacterMap[this.prefixFeatures.rstripLastChar] ?? 0] = 1;
      let suffixFirstCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      suffixFirstCharFeatures[contextualFilterCharacterMap[this.suffixFeatures.firstChar] ?? 0] = 1;
      let suffixLstripFirstCharFeatures = new Array(Object.keys(contextualFilterCharacterMap).length + 1).fill(0);
      return suffixLstripFirstCharFeatures[contextualFilterCharacterMap[this.suffixFeatures.lstripFirstChar] ?? 0] = 1, numFeatures.concat(langFeatures, prefixLastCharFeatures, prefixRstripLastCharFeatures, suffixFirstCharFeatures, suffixLstripFirstCharFeatures);
    }
  };
function constructMultilineFeatures(prompt, language) {
  return new MultilineModelFeatures(prompt.prefix, prompt.suffix, language);
}
__name(constructMultilineFeatures, "constructMultilineFeatures");
function requestMultilineScore(prompt, language) {
  let features = constructMultilineFeatures(prompt, language).constructFeatures();
  return multilineModelPredict(features)[1];
}
__name(requestMultilineScore, "requestMultilineScore");
var ghostTextLogger = new Logger(1, "ghostText");
var lastPrefix, lastSuffix, lastPromptHash;
async function genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, what, processChoices) {
  ghostTextLogger.debug(ctx, `Getting ${what} from network`), baseTelemetryData = baseTelemetryData.extendedBy();
  let numGhostCompletions = await getNumGhostCompletions(ctx, requestContext),
    temperature = getTemperatureForSamples(ctx, numGhostCompletions),
    postOptions = {
      stream: !0,
      n: numGhostCompletions,
      temperature: temperature,
      extra: {
        language: requestContext.languageId,
        next_indent: requestContext.indentation.next ?? 0,
        trim_by_indentation: shouldDoServerTrimming(requestContext.blockMode),
        prompt_tokens: requestContext.prompt.prefixTokens ?? 0,
        suffix_tokens: requestContext.prompt.suffixTokens ?? 0
      }
    };
  requestContext.multiline || (postOptions.stop = [`
`]), requestContext.multiline && requestContext.multiLogitBias && (postOptions.logit_bias = {
    50256: -100
  });
  let requestStart = Date.now(),
    newProperties = {
      endpoint: "completions",
      uiKind: "ghostText",
      isCycling: JSON.stringify(requestContext.isCycling),
      temperature: JSON.stringify(temperature),
      n: JSON.stringify(numGhostCompletions),
      stop: JSON.stringify(postOptions.stop) ?? "unset",
      logit_bias: JSON.stringify(postOptions.logit_bias ?? null)
    },
    newMeasurements = telemetrizePromptLength(requestContext.prompt);
  Object.assign(baseTelemetryData.properties, newProperties), Object.assign(baseTelemetryData.measurements, newMeasurements);
  try {
    let completionParams = {
      prompt: requestContext.prompt,
      languageId: requestContext.languageId,
      repoInfo: requestContext.repoInfo,
      ourRequestId: requestContext.ourRequestId,
      engineUrl: requestContext.engineURL,
      count: numGhostCompletions,
      uiKind: "ghostText",
      postOptions: postOptions
    };
    requestContext.delayMs > 0 && (await new Promise(resolve => setTimeout(resolve, requestContext.delayMs)));
    let res = await ctx.get(OpenAIFetcher).fetchAndStreamCompletions(ctx, completionParams, baseTelemetryData, finishedCb, cancellationToken);
    return res.type === "failed" ? {
      type: "failed",
      reason: res.reason,
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    } : res.type === "canceled" ? (ghostTextLogger.debug(ctx, "Cancelled after awaiting fetchCompletions"), {
      type: "canceled",
      reason: res.reason,
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
    }) : processChoices(numGhostCompletions, requestStart, res.getProcessingTime(), res.choices);
  } catch (err) {
    if (isAbortError(err)) return {
      type: "canceled",
      reason: "network request aborted",
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData, {
        cancelledNetworkRequest: !0
      })
    };
    if (ghostTextLogger.exception(ctx, err, "Error on ghost text request"), ctx.get(UserErrorNotifier).notifyUser(ctx, err), shouldFailForDebugPurposes(ctx)) throw err;
    return {
      type: "failed",
      reason: "non-abort error on ghost text request",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
  }
}
__name(genericGetCompletionsFromNetwork, "genericGetCompletionsFromNetwork");
async function getCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb) {
  return genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, "completions", async (numGhostCompletions, requestStart, processingTime, choicesStream) => {
    let choicesIterator = choicesStream[Symbol.asyncIterator](),
      firstRes = await choicesIterator.next();
    if (firstRes.done) return ghostTextLogger.debug(ctx, "All choices redacted"), {
      type: "empty",
      reason: "all choices redacted",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
    if (cancellationToken?.isCancellationRequested) return ghostTextLogger.debug(ctx, "Cancelled after awaiting redactedChoices iterator"), {
      type: "canceled",
      reason: "after awaiting redactedChoices iterator",
      telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
    };
    let firstChoice = firstRes.value;
    if (firstChoice === void 0) return ghostTextLogger.debug(ctx, "Got undefined choice from redactedChoices iterator"), {
      type: "empty",
      reason: "got undefined choice from redactedChoices iterator",
      telemetryData: mkBasicResultTelemetry(baseTelemetryData)
    };
    telemetryPerformance(ctx, "performance", firstChoice, requestStart, processingTime);
    let remainingChoices = numGhostCompletions - 1;
    ghostTextLogger.debug(ctx, `Awaited first result, id:  ${firstChoice.choiceIndex}`), addToCache(ctx, requestContext, {
      multiline: requestContext.multiline,
      choices: [firstChoice]
    });
    let remainingPromise = [];
    for (let index = 0; index < remainingChoices; index++) remainingPromise.push(choicesIterator.next());
    let cacheDone = Promise.all(remainingPromise).then(async results => {
      (await ctx.get(Features).fastCancellation()) && choicesIterator.next(), ghostTextLogger.debug(ctx, `Awaited remaining results, number of results: ${results.length}`);
      let apiChoices = [];
      for (let innerChoice of results) {
        let redactedChoice = innerChoice.value;
        if (redactedChoice !== void 0 && (ghostTextLogger.info(ctx, `GhostText later completion: [${redactedChoice.completionText}]`), redactedChoice.completionText.trimEnd())) {
          if (apiChoices.findIndex(v => v.completionText.trim() === redactedChoice.completionText.trim()) !== -1 || redactedChoice.completionText.trim() === firstChoice.completionText.trim()) continue;
          apiChoices.push(redactedChoice);
        }
      }
      apiChoices.length > 0 && appendToCache(ctx, requestContext, {
        multiline: requestContext.multiline,
        choices: apiChoices
      });
    });
    return isRunningInTest(ctx) && (await cacheDone), {
      type: "success",
      value: makeGhostAPIChoice(firstRes.value, {
        forceSingleLine: !1
      }),
      telemetryData: mkBasicResultTelemetry(baseTelemetryData),
      telemetryBlob: baseTelemetryData
    };
  });
}
__name(getCompletionsFromNetwork, "getCompletionsFromNetwork");
async function getAllCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb) {
  return genericGetCompletionsFromNetwork(ctx, requestContext, baseTelemetryData, cancellationToken, finishedCb, "all completions", async (numGhostCompletions, requestStart, processingTime, choicesStream) => {
    let apiChoices = [];
    for await (let choice of choicesStream) {
      if (cancellationToken?.isCancellationRequested) return ghostTextLogger.debug(ctx, "Cancelled after awaiting choices iterator"), {
        type: "canceled",
        reason: "after awaiting choices iterator",
        telemetryData: mkCanceledResultTelemetry(baseTelemetryData)
      };
      if (choice.completionText.trimEnd()) {
        if (apiChoices.findIndex(v => v.completionText.trim() === choice.completionText.trim()) !== -1) continue;
        apiChoices.push(choice);
      }
    }
    return apiChoices.length > 0 && (appendToCache(ctx, requestContext, {
      multiline: requestContext.multiline,
      choices: apiChoices
    }), telemetryPerformance(ctx, "cyclingPerformance", apiChoices[0], requestStart, processingTime)), {
      type: "success",
      value: apiChoices,
      telemetryData: mkBasicResultTelemetry(baseTelemetryData),
      telemetryBlob: baseTelemetryData
    };
  });
}
__name(getAllCompletionsFromNetwork, "getAllCompletionsFromNetwork");
function makeGhostAPIChoice(choice, options) {
  let ghostChoice = {
    ...choice
  };
  return ghostChoice.completionText = choice.completionText.trimEnd(), options.forceSingleLine && (ghostChoice.completionText = ghostChoice.completionText.split(`
`)[0]), ghostChoice;
}
__name(makeGhostAPIChoice, "makeGhostAPIChoice");
async function getNumGhostCompletions(ctx, requestContext) {
  let override = await ctx.get(Features).overrideNumGhostCompletions();
  return override ? requestContext.isCycling ? Math.max(0, 3 - override) : override : shouldDoParsingTrimming(requestContext.blockMode) && requestContext.multiline ? getConfig(ctx, ConfigKey.InlineSuggestCount) : requestContext.isCycling ? 2 : 1;
}
__name(getNumGhostCompletions, "getNumGhostCompletions");
async function getGhostTextStrategy(ctx, document, position, prompt, isCycling, inlineSuggestion, preIssuedTelemetryData, requestMultilineExploration = !1, requestMultilineOnNewLine = !0, requestMultiModel = !0, requestMultiModelThreshold = .5) {
  let blockMode = await ctx.get(BlockModeConfig).forLanguage(ctx, document.languageId);
  switch (blockMode) {
    case "server":
      return {
        blockMode: "server",
        requestMultiline: !0,
        isCyclingRequest: isCycling,
        finishedCb: async text => {}
      };
    case "parsing":
    case "parsingandserver":
    default:
      {
        if (await shouldRequestMultiline(ctx, document, position, inlineSuggestion, preIssuedTelemetryData, prompt, requestMultilineExploration, requestMultilineOnNewLine, requestMultiModel, requestMultiModelThreshold)) {
          let adjustedPosition;
          return prompt.trailingWs.length > 0 && !prompt.prompt.prefix.endsWith(prompt.trailingWs) ? adjustedPosition = ctx.get(LocationFactory).position(position.line, Math.max(position.character - prompt.trailingWs.length, 0)) : adjustedPosition = position, {
            blockMode: blockMode,
            requestMultiline: !0,
            isCyclingRequest: !1,
            finishedCb: parsingBlockFinished(ctx, document, adjustedPosition)
          };
        }
        return {
          blockMode: blockMode,
          requestMultiline: !1,
          isCyclingRequest: isCycling,
          finishedCb: async text => {}
        };
      }
  }
}
__name(getGhostTextStrategy, "getGhostTextStrategy");
var ghostTextDebouncer = new Debouncer();
async function getGhostText(ctx, document, position, isCycling, preIssuedTelemetryData, cancellationToken) {
  let ourRequestId = v4_default();
  preIssuedTelemetryData = preIssuedTelemetryData.extendedBy({
    headerRequestId: ourRequestId
  });
  let documentSource = document.getText(),
    positionOffset = document.offsetAt(position),
    actualSuffix = documentSource.substring(positionOffset),
    prompt = await extractPrompt(ctx, document, position, preIssuedTelemetryData);
  if (prompt.type === "copilotNotAvailable") return ghostTextLogger.debug(ctx, "Copilot not available, due to content exclusion"), {
    type: "abortedBeforeIssued",
    reason: "Copilot not available due to content exclusion"
  };
  if (prompt.type === "contextTooShort") return ghostTextLogger.debug(ctx, "Breaking, not enough context"), {
    type: "abortedBeforeIssued",
    reason: "Not enough context"
  };
  if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after extractPrompt"), {
    type: "abortedBeforeIssued",
    reason: "Cancelled after extractPrompt"
  };
  let inlineSuggestion = isInlineSuggestion(document, position);
  if (inlineSuggestion === void 0) return ghostTextLogger.debug(ctx, "Breaking, invalid middle of the line"), {
    type: "abortedBeforeIssued",
    reason: "Invalid middle of the line"
  };
  let statusBarItem = ctx.get(StatusReporter),
    locationFactory = ctx.get(LocationFactory),
    repoInfo = extractRepoInfoInBackground(ctx, document.uri),
    repoNwo = tryGetGitHubNWO(repoInfo) ?? "",
    dogFood = getDogFood(repoInfo),
    userKind = await getUserKind(ctx),
    customModel = await getFtFlag(ctx),
    retrievalOrg = await getRagFlag(ctx),
    featuresFilterArgs = {
      repoNwo: repoNwo,
      userKind: userKind,
      dogFood: dogFood,
      fileType: document.languageId,
      customModel: customModel,
      retrievalOrg: retrievalOrg
    },
    ghostTextStrategy = await getGhostTextStrategy(ctx, document, position, prompt, isCycling, inlineSuggestion, preIssuedTelemetryData);
  if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after requestMultiline"), {
    type: "abortedBeforeIssued",
    reason: "Cancelled after requestMultiline"
  };
  let [prefix] = trimLastLine(document.getText(locationFactory.range(locationFactory.position(0, 0), position))),
    choices = getLocalInlineSuggestion(ctx, prefix, prompt.prompt, ghostTextStrategy.requestMultiline),
    engineURL = await getEngineURL(ctx, repoNwo, document.languageId, dogFood, userKind, customModel, retrievalOrg, preIssuedTelemetryData),
    delayMs = await ctx.get(Features).beforeRequestWaitMs(featuresFilterArgs, preIssuedTelemetryData),
    multiLogitBias = await ctx.get(Features).multiLogitBias(featuresFilterArgs, preIssuedTelemetryData),
    requestContext = {
      blockMode: ghostTextStrategy.blockMode,
      languageId: document.languageId,
      repoInfo: repoInfo,
      engineURL: engineURL,
      ourRequestId: ourRequestId,
      prefix: prefix,
      prompt: prompt.prompt,
      multiline: ghostTextStrategy.requestMultiline,
      indentation: contextIndentation(document, position),
      isCycling: isCycling,
      delayMs: delayMs,
      multiLogitBias: multiLogitBias
    },
    debouncePredict = await ctx.get(Features).debouncePredict(),
    contextualFilterEnable = await ctx.get(Features).contextualFilterEnable(),
    contextualFilterAcceptThreshold = await ctx.get(Features).contextualFilterAcceptThreshold(),
    contextualFilterEnableTree = await ctx.get(Features).contextualFilterEnableTree(),
    contextualFilterExplorationTraffic = await ctx.get(Features).contextualFilterExplorationTraffic(),
    computeContextualFilterScore = !1;
  (debouncePredict || contextualFilterEnable) && (computeContextualFilterScore = !0);
  let detectedLanguage = await ctx.get(LanguageDetection).detectLanguage(document),
    telemetryData = telemetryIssued(ctx, document, detectedLanguage, requestContext, position, prompt, preIssuedTelemetryData, computeContextualFilterScore, contextualFilterEnableTree);
  if (ghostTextStrategy.isCyclingRequest && (choices?.[0].length ?? 0) > 1 || !ghostTextStrategy.isCyclingRequest && choices !== void 0) ghostTextLogger.info(ctx, "Found inline suggestions locally");else {
    if (statusBarItem?.setProgress(), ghostTextStrategy.isCyclingRequest) {
      let networkChoices = await getAllCompletionsFromNetwork(ctx, requestContext, telemetryData, cancellationToken, ghostTextStrategy.finishedCb);
      if (networkChoices.type === "success") {
        let resultChoices = choices?.[0] ?? [];
        networkChoices.value.forEach(c => {
          resultChoices.findIndex(v => v.completionText.trim() === c.completionText.trim()) === -1 && resultChoices.push(c);
        }), choices = [resultChoices, 3];
      } else if (choices === void 0) return statusBarItem?.removeProgress(), networkChoices;
    } else {
      let debounceLimit = await getDebounceLimit(ctx, telemetryData);
      try {
        await ghostTextDebouncer.debounce(debounceLimit);
      } catch {
        return {
          type: "canceled",
          reason: "by debouncer",
          telemetryData: mkCanceledResultTelemetry(telemetryData)
        };
      }
      if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled during debounce"), {
        type: "canceled",
        reason: "during debounce",
        telemetryData: mkCanceledResultTelemetry(telemetryData)
      };
      if (contextualFilterEnable && telemetryData.measurements.contextualFilterScore && telemetryData.measurements.contextualFilterScore < contextualFilterAcceptThreshold / 100 && Math.random() < 1 - contextualFilterExplorationTraffic / 100) return ghostTextLogger.info(ctx, "Cancelled by contextual filter"), {
        type: "canceled",
        reason: "contextualFilterScore below threshold",
        telemetryData: mkCanceledResultTelemetry(telemetryData)
      };
      let c = await getCompletionsFromNetwork(ctx, requestContext, telemetryData, cancellationToken, ghostTextStrategy.finishedCb);
      if (c.type !== "success") return statusBarItem?.removeProgress(), c;
      choices = [[c.value], 0];
    }
    statusBarItem?.removeProgress();
  }
  if (choices === void 0) return {
    type: "failed",
    reason: "internal error: choices should be defined after network call",
    telemetryData: mkBasicResultTelemetry(telemetryData)
  };
  let [choicesArray, resultType] = choices,
    postProcessedChoices = asyncIterableMapFilter(asyncIterableFromArray(choicesArray), async choice => postProcessChoice(ctx, "ghostText", document, position, choice, inlineSuggestion, ghostTextLogger, prompt.prompt, actualSuffix)),
    results = [];
  for await (let choice of postProcessedChoices) {
    let hasSuffix = inlineSuggestion && checkSuffix(document, position, choice);
    if (cancellationToken?.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after post processing completions"), {
      type: "canceled",
      reason: "after post processing completions",
      telemetryData: mkCanceledResultTelemetry(telemetryData)
    };
    let choiceTelemetryData = telemetryWithAddData(ctx, choice),
      res = {
        completion: adjustLeadingWhitespace(choice.choiceIndex, choice.completionText, prompt.trailingWs),
        telemetry: choiceTelemetryData,
        isMiddleOfTheLine: inlineSuggestion,
        coversSuffix: hasSuffix
      };
    results.push(res);
  }
  return {
    type: "success",
    value: [results, resultType],
    telemetryData: mkBasicResultTelemetry(telemetryData),
    telemetryBlob: telemetryData
  };
}
__name(getGhostText, "getGhostText");
function getLocalInlineSuggestion(ctx, prefix, prompt, requestMultiline) {
  let choicesTyping = getCompletionsForUserTyping(ctx, prefix, prompt, requestMultiline);
  if (choicesTyping && choicesTyping.length > 0) return [choicesTyping, 2];
  let choicesCache = getCompletionsFromCache(ctx, prefix, prompt, requestMultiline);
  if (choicesCache && choicesCache.length > 0) return [choicesCache, 1];
}
__name(getLocalInlineSuggestion, "getLocalInlineSuggestion");
function isInlineSuggestion(document, position) {
  let isMiddleOfLine = isMiddleOfTheLine(position, document),
    isValidMiddleOfLine = isValidMiddleOfTheLinePosition(position, document);
  return isMiddleOfLine && !isValidMiddleOfLine ? void 0 : isMiddleOfLine && isValidMiddleOfLine;
}
__name(isInlineSuggestion, "isInlineSuggestion");
function isMiddleOfTheLine(selectionPosition, doc) {
  return doc.lineAt(selectionPosition).text.substr(selectionPosition.character).trim().length != 0;
}
__name(isMiddleOfTheLine, "isMiddleOfTheLine");
function isValidMiddleOfTheLinePosition(selectionPosition, doc) {
  let endOfLine = doc.lineAt(selectionPosition).text.substr(selectionPosition.character).trim();
  return /^\s*[)}\]"'`]*\s*[:{;,]?\s*$/.test(endOfLine);
}
__name(isValidMiddleOfTheLinePosition, "isValidMiddleOfTheLinePosition");
function isNewLine(selectionPosition, doc) {
  return doc.lineAt(selectionPosition).text.trim().length === 0;
}
__name(isNewLine, "isNewLine");
function exploreMultilineRandom() {
  return Math.random() > .5;
}
__name(exploreMultilineRandom, "exploreMultilineRandom");
var ForceMultiLine = class _ForceMultiLine {
  constructor(requestMultilineOverride = !1) {
    this.requestMultilineOverride = requestMultilineOverride;
  }
  static {
    __name(this, "ForceMultiLine");
  }
  static {
    this.default = new _ForceMultiLine();
  }
};
async function requestMultilineExperiment(requestMultilineExploration, requestMultiModel, requestMultiModelThreshold, document, prompt, preIssuedTelemetryData) {
  let requestMultiline = !1;
  return requestMultilineExploration ? requestMultiline = exploreMultilineRandom() : requestMultiModel && ["javascript", "javascriptreact", "python"].includes(document.languageId) && (requestMultiline = requestMultilineScore(prompt.prompt, document.languageId) > requestMultiModelThreshold), requestMultiline;
}
__name(requestMultilineExperiment, "requestMultilineExperiment");
async function shouldRequestMultiline(ctx, document, position, inlineSuggestion, preIssuedTelemetryData, prompt, requestMultilineExploration, requestMultilineOnNewLine, requestMultiModel, requestMultiModelThreshold) {
  if (ctx.get(ForceMultiLine).requestMultilineOverride) return !0;
  if (requestMultilineExploration) {
    let isEmptyBlockStartDocumentPosition = await isEmptyBlockStart(document, position),
      isEmptyBlockStartDocumentPositionRangeEnd = await isEmptyBlockStart(document, document.lineAt(position).range.end);
    preIssuedTelemetryData.properties.isEmptyBlockStartDocumentPosition = isEmptyBlockStartDocumentPosition.toString(), preIssuedTelemetryData.properties.isEmptyBlockStartDocumentPositionRangeEnd = isEmptyBlockStartDocumentPositionRangeEnd.toString(), preIssuedTelemetryData.properties.inlineSuggestion = inlineSuggestion.toString(), preIssuedTelemetryData.measurements.documentLineCount = document.lineCount, preIssuedTelemetryData.measurements.positionLine = position.line;
  }
  if (document.lineCount >= 8e3) telemetry(ctx, "ghostText.longFileMultilineSkip", TelemetryData.createAndMarkAsIssued({
    languageId: document.languageId,
    lineCount: String(document.lineCount),
    currentLine: String(position.line)
  }));else {
    if (requestMultilineOnNewLine && ["typescript", "typescriptreact"].includes(document.languageId) && isNewLine(position, document)) return !0;
    let requestMultiline = !1;
    return !inlineSuggestion && (0, qL.isSupportedLanguageId)(document.languageId) ? requestMultiline = await isEmptyBlockStart(document, position) : inlineSuggestion && (0, qL.isSupportedLanguageId)(document.languageId) && (requestMultiline = (await isEmptyBlockStart(document, position)) || (await isEmptyBlockStart(document, document.lineAt(position).range.end))), requestMultiline || (requestMultiline = await requestMultilineExperiment(requestMultilineExploration, requestMultiModel, requestMultiModelThreshold, document, prompt, preIssuedTelemetryData)), requestMultiline;
  }
  return !1;
}
__name(shouldRequestMultiline, "shouldRequestMultiline");
function recordLastSuccessfulCompletionContext(prefix, suffix, promptHash) {
  lastPrefix = prefix, lastSuffix = suffix, lastPromptHash = promptHash;
}
__name(recordLastSuccessfulCompletionContext, "recordLastSuccessfulCompletionContext");
function addToCache(ctx, requestContext, contents) {
  let promptHash = keyForPrompt(requestContext.prompt);
  recordLastSuccessfulCompletionContext(requestContext.prefix, requestContext.prompt.suffix, promptHash), ctx.get(CompletionsCache).set(promptHash, contents), ghostTextLogger.debug(ctx, `Cached ghost text for key: ${promptHash}, multiline: ${contents.multiline}, number of suggestions: ${contents.choices.length}`);
}
__name(addToCache, "addToCache");
function appendToCache(ctx, requestContext, newContents) {
  let promptHash = keyForPrompt(requestContext.prompt),
    existing = ctx.get(CompletionsCache).get(promptHash);
  existing && existing.multiline === newContents.multiline ? ctx.get(CompletionsCache).set(promptHash, {
    multiline: existing.multiline,
    choices: existing.choices.concat(newContents.choices)
  }) : ctx.get(CompletionsCache).set(promptHash, newContents), ghostTextLogger.debug(ctx, `Appended cached ghost text for key: ${promptHash}, multiline: ${newContents.multiline}, number of suggestions: ${newContents.choices.length}`);
}
__name(appendToCache, "appendToCache");
function getCachedChoices(ctx, promptHash, multiline) {
  let contents = ctx.get(CompletionsCache).get(promptHash);
  if (contents && !(multiline && !contents.multiline)) return contents.choices;
}
__name(getCachedChoices, "getCachedChoices");
function adjustLeadingWhitespace(index, text, ws) {
  if (ws.length > 0) {
    if (text.startsWith(ws)) return {
      completionIndex: index,
      completionText: text,
      displayText: text.substr(ws.length),
      displayNeedsWsOffset: !1
    };
    {
      let textLeftWs = text.substr(0, text.length - text.trimLeft().length);
      return ws.startsWith(textLeftWs) ? {
        completionIndex: index,
        completionText: text,
        displayText: text.trimLeft(),
        displayNeedsWsOffset: !0
      } : {
        completionIndex: index,
        completionText: text,
        displayText: text,
        displayNeedsWsOffset: !1
      };
    }
  } else return {
    completionIndex: index,
    completionText: text,
    displayText: text,
    displayNeedsWsOffset: !1
  };
}
__name(adjustLeadingWhitespace, "adjustLeadingWhitespace");
function getCompletionsForUserTyping(ctx, prefix, prompt, multiline) {
  let prefixMatches = lastPrefix ? prefix.startsWith(lastPrefix) : !1,
    suffixMatches = lastSuffix != null ? prompt.suffix == lastSuffix : !1;
  if (!lastPrefix || !lastPromptHash || !prefixMatches || !suffixMatches) return;
  let lastCachedCompletion = getCachedChoices(ctx, lastPromptHash, multiline);
  if (!lastCachedCompletion) return;
  let remainingPrefix = prefix.substring(lastPrefix.length);
  ghostTextLogger.debug(ctx, `Getting completions for user-typing flow - remaining prefix: ${remainingPrefix}`);
  let completionsToReturn = [];
  return lastCachedCompletion.forEach(element => {
    let completionToReturn = makeGhostAPIChoice(element, {
      forceSingleLine: !1
    });
    completionToReturn.completionText.startsWith(remainingPrefix) && (completionToReturn.completionText = completionToReturn.completionText.substring(remainingPrefix.length), completionsToReturn.push(completionToReturn));
  }), completionsToReturn;
}
__name(getCompletionsForUserTyping, "getCompletionsForUserTyping");
function clearUserTypingState() {
  lastPrefix = void 0, lastSuffix = void 0, lastPromptHash = void 0;
}
__name(clearUserTypingState, "clearUserTypingState");
function getCompletionsFromCache(ctx, prefix, prompt, multiline) {
  let promptHash = keyForPrompt(prompt);
  ghostTextLogger.debug(ctx, `Trying to get completions from cache for key: ${promptHash}`);
  let cachedChoice = getCachedChoices(ctx, promptHash, multiline);
  if (cachedChoice) {
    ghostTextLogger.debug(ctx, `Got completions from cache for key: ${promptHash}`);
    let completionsToReturn = [];
    cachedChoice.forEach(element => {
      let completionToReturn = makeGhostAPIChoice(element, {
        forceSingleLine: !multiline
      });
      completionsToReturn.push(completionToReturn);
    });
    let result = completionsToReturn.filter(e => e.completionText);
    return result.length > 0 && recordLastSuccessfulCompletionContext(prefix, prompt.suffix, promptHash), result;
  }
}
__name(getCompletionsFromCache, "getCompletionsFromCache");
function telemetryWithAddData(ctx, choice) {
  let requestId = choice.requestId,
    properties = {
      choiceIndex: choice.choiceIndex.toString()
    },
    measurements = {
      numTokens: choice.numTokens,
      compCharLen: choice.completionText.length,
      numLines: choice.completionText.split(`
`).length
    };
  choice.meanLogProb && (measurements.meanLogProb = choice.meanLogProb), choice.meanAlternativeLogProb && (measurements.meanAlternativeLogProb = choice.meanAlternativeLogProb);
  let extendedTelemetry = choice.telemetryData.extendedBy(properties, measurements);
  return extendedTelemetry.extendWithRequestId(requestId), extendedTelemetry.measurements.confidence = ghostTextScoreConfidence(ctx, extendedTelemetry), extendedTelemetry.measurements.quantile = ghostTextScoreQuantile(ctx, extendedTelemetry), ghostTextLogger.debug(ctx, `Extended telemetry for ${choice.telemetryData.properties.headerRequestId} with retention confidence ${extendedTelemetry.measurements.confidence} (expected as good or better than about ${extendedTelemetry.measurements.quantile} of all suggestions)`), extendedTelemetry;
}
__name(telemetryWithAddData, "telemetryWithAddData");
function telemetryIssued(ctx, document, detectedLanguage, requestContext, position, prompt, baseTelemetryData, computeContextualFilterScore, contextualFilterEnableTree) {
  let locationFactory = ctx.get(LocationFactory),
    currentLine = document.lineAt(position.line),
    lineBeforeCursor = document.getText(locationFactory.range(currentLine.range.start, position)),
    restOfLine = document.getText(locationFactory.range(position, currentLine.range.end)),
    properties = {
      languageId: document.languageId,
      beforeCursorWhitespace: JSON.stringify(lineBeforeCursor.trim() === ""),
      afterCursorWhitespace: JSON.stringify(restOfLine.trim() === "")
    };
  document.languageId !== detectedLanguage.languageId && (properties.detectedLanguageId = detectedLanguage.languageId, properties.fileExtension = detectedLanguage.fileExtension);
  let measurements = {
      ...telemetrizePromptLength(prompt.prompt),
      promptEndPos: document.offsetAt(position),
      documentLength: document.getText().length,
      delayMs: requestContext.delayMs
    },
    telemetryData = baseTelemetryData.extendedBy(properties, measurements);
  telemetryData.properties.promptChoices = JSON.stringify(prompt.promptChoices, (key, value) => value instanceof Map ? Array.from(value.entries()).reduce((acc, [k, v]) => ({
    ...acc,
    [k]: v
  }), {}) : value), telemetryData.properties.promptBackground = JSON.stringify(prompt.promptBackground, (key, value) => value instanceof Map ? Array.from(value.values()) : value);
  let typeFileHashCode = Array.from(prompt.neighborSource.entries()).map(typeFiles => [typeFiles[0], typeFiles[1].map(f => (0, vie.SHA256)(f).toString())]);
  telemetryData.properties.neighborSource = JSON.stringify(typeFileHashCode), telemetryData.measurements.promptComputeTimeMs = prompt.computeTimeMs, computeContextualFilterScore && (telemetryData.measurements.contextualFilterScore = contextualFilterScore(ctx, telemetryData, prompt.prompt, contextualFilterEnableTree));
  let repoInfo = requestContext.repoInfo;
  return telemetryData.properties.gitRepoInformation = repoInfo === void 0 ? "unavailable" : repoInfo === 0 ? "pending" : "available", repoInfo !== void 0 && repoInfo !== 0 && (telemetryData.properties.gitRepoUrl = repoInfo.url, telemetryData.properties.gitRepoHost = repoInfo.hostname, telemetryData.properties.gitRepoOwner = repoInfo.owner, telemetryData.properties.gitRepoName = repoInfo.repo, telemetryData.properties.gitRepoPath = repoInfo.pathname), telemetryData.properties.engineName = extractEngineName(ctx, requestContext.engineURL), telemetryData.properties.isMultiline = JSON.stringify(requestContext.multiline), telemetryData.properties.blockMode = requestContext.blockMode, telemetryData.properties.isCycling = JSON.stringify(requestContext.isCycling), telemetry(ctx, "ghostText.issued", telemetryData), telemetryData;
}
__name(telemetryIssued, "telemetryIssued");
function telemetryPerformance(ctx, performanceKind, choice, requestStart, processingTimeMs) {
  let requestTimeMs = Date.now() - requestStart,
    deltaMs = requestTimeMs - processingTimeMs,
    telemetryData = choice.telemetryData.extendedBy({}, {
      completionCharLen: choice.completionText.length,
      requestTimeMs: requestTimeMs,
      processingTimeMs: processingTimeMs,
      deltaMs: deltaMs,
      meanLogProb: choice.meanLogProb || NaN,
      meanAlternativeLogProb: choice.meanAlternativeLogProb || NaN,
      numTokens: choice.numTokens
    });
  telemetryData.extendWithRequestId(choice.requestId), telemetry(ctx, `ghostText.${performanceKind}`, telemetryData);
}
__name(telemetryPerformance, "telemetryPerformance");
var CertificateReaderCache = class {
  constructor() {
    this.cache = new Map();
  }
  static {
    __name(this, "CertificateReaderCache");
  }
  get(platform) {
    return this.cache.get(platform);
  }
  set(platform, reader) {
    this.cache.set(platform, reader);
  }
};
var fs = Ns(require("fs")),
  import_tls = require("tls");
var certLogger = new Logger(1, "certificates"),
  RootCertificateReader = class {
    static {
      __name(this, "RootCertificateReader");
    }
  },
  getRootCertificateReader = __name((ctx, platform = process.platform) => new FeatureAwareCertificateReader(ctx.get(CopilotTokenNotifier), createRealReader(ctx, platform), new EmptyRootCertificateReader()), "getRootCertificateReader"),
  FeatureAwareCertificateReader = class extends RootCertificateReader {
    constructor(notifier, realReader, noopReader) {
      super();
      this.realReader = realReader;
      this.noopReader = noopReader;
      this.delegate = realReader, notifier.on("onCopilotToken", token => {
        this.delegate = token.getTokenValue("ssc") === "1" ? this.realReader : this.noopReader;
      });
    }
    static {
      __name(this, "FeatureAwareCertificateReader");
    }
    getAllRootCAs() {
      return this.delegate.getAllRootCAs();
    }
  };
function createRealReader(ctx, platform) {
  let cachedReader = ctx.get(CertificateReaderCache).get(platform);
  if (cachedReader) return cachedReader;
  let realReader = new ErrorHandlingCertificateReader(ctx, createPlatformReader(ctx, platform), Yoe.rootCertificates),
    envReader = new ErrorHandlingCertificateReader(ctx, new EnvironmentVariableRootCertificateReader()),
    cachingReader = new CachingRootCertificateReader([envReader, realReader]);
  return ctx.get(CertificateReaderCache).set(platform, cachingReader), cachingReader;
}
__name(createRealReader, "createRealReader");
function createPlatformReader(ctx, platform) {
  switch (platform) {
    case "linux":
      return new LinuxRootCertificateReader(ctx);
    case "darwin":
      return new MacRootCertificateReader(ctx);
    case "win32":
      return new WindowsRootCertificateReader(ctx);
    default:
      return new UnsupportedPlatformRootCertificateReader();
  }
}
__name(createPlatformReader, "createPlatformReader");
var ErrorHandlingCertificateReader = class extends RootCertificateReader {
    constructor(ctx, delegate, fallbackCerts = []) {
      super();
      this.ctx = ctx;
      this.delegate = delegate;
      this.fallbackCerts = fallbackCerts;
    }
    static {
      __name(this, "ErrorHandlingCertificateReader");
    }
    async getAllRootCAs() {
      try {
        return await this.delegate.getAllRootCAs();
      } catch (ex) {
        return certLogger.warn(this.ctx, `Failed to read root certificates: ${ex}`), this.fallbackCerts;
      }
    }
  },
  CachingRootCertificateReader = class extends RootCertificateReader {
    constructor(delegates) {
      super();
      this.delegates = delegates;
    }
    static {
      __name(this, "CachingRootCertificateReader");
    }
    async getAllRootCAs() {
      return this.certificates || (this.certificates = (await Promise.all(this.delegates.map(d => d.getAllRootCAs()))).flat()), this.certificates;
    }
  },
  EnvironmentVariableRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "EnvironmentVariableRootCertificateReader");
    }
    async getAllRootCAs() {
      let extraCertsFile = process.env.NODE_EXTRA_CA_CERTS;
      return extraCertsFile ? await readCertsFromFile(extraCertsFile) : [];
    }
  },
  LinuxRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "LinuxRootCertificateReader");
    }
    async getAllRootCAs() {
      let rootCAs = [];
      for (let certPath of ["/etc/ssl/certs/ca-certificates.crt", "/etc/ssl/certs/ca-bundle.crt"]) {
        let certs = await readCertsFromFile(certPath);
        certLogger.debug(this.ctx, `Read ${certs.length} certificates from ${certPath}`), rootCAs = rootCAs.concat(certs);
      }
      return rootCAs;
    }
  },
  MacRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "MacRootCertificateReader");
    }
    async getAllRootCAs() {
      let macCa = Woe(),
        certs = macCa.all(macCa.der2.pem).filter(c => c !== void 0);
      return certLogger.debug(this.ctx, `Read ${certs.length} certificates from Mac keychain`), certs;
    }
  },
  WindowsRootCertificateReader = class extends RootCertificateReader {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "WindowsRootCertificateReader");
    }
    async getAllRootCAs() {
      let certs = Koe().all();
      return certLogger.debug(this.ctx, `Read ${certs.length} certificates from Windows store`), certs;
    }
  },
  UnsupportedPlatformRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "UnsupportedPlatformRootCertificateReader");
    }
    async getAllRootCAs() {
      throw new Error("No certificate reader available for unsupported platform");
    }
  },
  EmptyRootCertificateReader = class extends RootCertificateReader {
    static {
      __name(this, "EmptyRootCertificateReader");
    }
    async getAllRootCAs() {
      return [];
    }
  };
async function readCertsFromFile(certFilePath) {
  try {
    let nonEmptyCerts = (await Xoe.promises.readFile(certFilePath, {
        encoding: "utf8"
      })).split(/(?=-----BEGIN CERTIFICATE-----)/g).filter(pem => pem.length > 0),
      uniqueCerts = new Set(nonEmptyCerts);
    return Array.from(uniqueCerts);
  } catch (err) {
    if (err?.code !== "ENOENT") throw err;
  }
  return [];
}
__name(readCertsFromFile, "readCertsFromFile");
var tls = Ns(require("tls"));
var RootCertificateConfigurator = class {
  static {
    __name(this, "RootCertificateConfigurator");
  }
  constructor(ctx) {
    this._certificateReader = ctx.get(RootCertificateReader);
  }
  async enhanceProxySettings(proxySettings) {
    let certs = await this.getCertificates();
    return {
      ...proxySettings,
      ca: certs
    };
  }
  async getCertificates() {
    let certificates = await this._certificateReader.getAllRootCAs();
    if (certificates.length !== 0) return certificates;
  }
  async applyToRequestOptions(requestOptions) {
    let certs = await this._certificateReader.getAllRootCAs(),
      options = {
        _vscodeAdditionalCaCerts: certs
      };
    requestOptions.secureContext = Joe.createSecureContext(options), requestOptions.ca = certs, requestOptions.cert = certs, certs.map(cert => {
      requestOptions.secureContext.context.addCACert(cert);
    });
  }
};
var http = Ns(require("http"));
var PROXY_AUTHORIZATION_REQUIRED = 407,
  logger = new Logger(0, "proxy-socket-factory"),
  ProxySocketFactory = class {
    static {
      __name(this, "ProxySocketFactory");
    }
  },
  ProxySocketError = class extends Error {
    constructor(message, cause, code) {
      super(message);
      this.code = cause?.code, this.syscall = cause?.syscall, this.errno = cause?.errno, /^Failed to establish a socket connection to proxies:/.test(cause?.message ?? "") ? this.code = "ProxyFailedToEstablishSocketConnection" : /^InitializeSecurityContext:/.test(cause?.message ?? "") ? this.code = "ProxyInitializeSecurityContext" : cause?.message === "Miscellaneous failure (see text): Server not found in Kerberos database" ? this.code = "ProxyKerberosServerNotFound" : /^Unspecified GSS failure. {2}Minor code may provide more information: No Kerberos credentials available/.test(cause?.message ?? "") && (this.code = "ProxyGSSFailureNoKerberosCredentialsAvailable"), code !== void 0 && (this.code = code);
    }
    static {
      __name(this, "ProxySocketError");
    }
  };
function getProxySocketFactory(ctx) {
  return new KerberosProxySocketFactory(ctx, new TunnelingProxySocketFactory(ctx));
}
__name(getProxySocketFactory, "getProxySocketFactory");
var KerberosProxySocketFactory = class extends ProxySocketFactory {
    constructor(ctx, delegate, kerberosLoader = new KerberosLoader(), platform = process.platform) {
      super();
      this.ctx = ctx;
      this.delegate = delegate;
      this.kerberosLoader = kerberosLoader;
      this.platform = platform;
      this.successfullyAuthorized = new LRUCacheMap(20);
    }
    static {
      __name(this, "KerberosProxySocketFactory");
    }
    async createSocket(requestOptions, proxySettings) {
      this.successfullyAuthorized.get(this.getProxyCacheKey(proxySettings)) && (logger.debug(this.ctx, "Proxy authorization already successful once, skipping 407 rountrip"), await this.reauthorize(requestOptions, proxySettings));
      try {
        return await this.delegate.createSocket(requestOptions, proxySettings);
      } catch (error) {
        if (error instanceof ProxySocketError && error.code === `ProxyStatusCode${PROXY_AUTHORIZATION_REQUIRED}`) {
          logger.debug(this.ctx, "Proxy authorization required, trying to authorize first time");
          let socket = await this.authorizeAndCreateSocket(requestOptions, proxySettings);
          if (socket) return logger.debug(this.ctx, "Proxy authorization successful, caching result"), this.successfullyAuthorized.set(this.getProxyCacheKey(proxySettings), !0), socket;
        }
        throw error;
      }
    }
    async reauthorize(requestOptions, proxySettings) {
      let proxyAuthorization = await this.authorize(proxySettings);
      proxyAuthorization && (logger.debug(this.ctx, "Proxy re-authorization successful, received token"), requestOptions.headers["Proxy-Authorization"] = "Negotiate " + proxyAuthorization);
    }
    async authorizeAndCreateSocket(requestOptions, proxySettings) {
      let proxyAuthorization = await this.authorize(proxySettings);
      if (logger.debug(this.ctx, "Proxy authorization successful, received token"), proxyAuthorization) return logger.debug(this.ctx, "Trying to create socket with proxy authorization"), requestOptions.headers["Proxy-Authorization"] = "Negotiate " + proxyAuthorization, await this.delegate.createSocket(requestOptions, proxySettings);
    }
    async authorize(proxySettings) {
      logger.debug(this.ctx, "Loading kerberos module");
      let kerberos = this.kerberosLoader.load(),
        spn = this.computeSpn(proxySettings);
      logger.debug(this.ctx, "Initializing kerberos client using spn", spn);
      let client = await kerberos.initializeClient(spn);
      logger.debug(this.ctx, "Perform client side kerberos step");
      let response = await client.step("");
      return logger.debug(this.ctx, "Received kerberos server response"), response;
    }
    computeSpn(proxySettings) {
      let configuredSpn = getHiddenConfig(this.ctx, ConfigKey.KerberosServicePrincipal, {
        default: proxySettings.kerberosServicePrincipal
      });
      if (configuredSpn) return logger.debug(this.ctx, "Using configured kerberos spn", configuredSpn), configuredSpn;
      let defaultSpn = this.platform === "win32" ? `HTTP/${proxySettings.host}` : `HTTP@${proxySettings.host}`;
      return logger.debug(this.ctx, "Using default kerberos spn", defaultSpn), defaultSpn;
    }
    getProxyCacheKey(proxySettings) {
      return proxySettings.host + ":" + proxySettings.port;
    }
  },
  TunnelingProxySocketFactory = class extends ProxySocketFactory {
    constructor(ctx) {
      super();
      this.ctx = ctx;
    }
    static {
      __name(this, "TunnelingProxySocketFactory");
    }
    async createSocket(requestOptions, proxySettings) {
      let connectOptions = this.createConnectRequestOptions(requestOptions, proxySettings);
      return new Promise((resolve, reject) => {
        logger.debug(this.ctx, "Attempting to establish connection to proxy");
        let connectRequest = yae.request(connectOptions);
        connectRequest.useChunkedEncodingByDefault = !1, connectRequest.once("connect", (res, socket, head) => {
          logger.debug(this.ctx, "Socket Connect returned status code", res.statusCode), connectRequest.removeAllListeners(), socket.removeAllListeners(), res.statusCode !== 200 ? (socket.destroy(), reject(new ProxySocketError(`tunneling socket could not be established, statusCode=${res.statusCode}`, void 0, `ProxyStatusCode${res.statusCode}`))) : head.length > 0 ? (socket.destroy(), reject(new ProxySocketError(`got non-empty response body from proxy, length=${head.length}`, void 0, "ProxyNonEmptyResponseBody"))) : (logger.debug(this.ctx, "Successfully established tunneling connection to proxy"), resolve(socket));
        }), connectRequest.once("error", cause => {
          logger.debug(this.ctx, "Proxy socket connection error", cause.message), connectRequest.removeAllListeners(), reject(new ProxySocketError(`tunneling socket could not be established, cause=${cause.message}`, cause));
        }), connectRequest.on("timeout", () => {
          logger.debug(this.ctx, "Proxy socket connection timeout"), reject(new ProxySocketError(`tunneling socket could not be established, proxy socket connection timeout while connecting to ${connectOptions.host}:${connectOptions.port}`, void 0, "ProxyTimeout"));
        }), connectRequest.end();
      });
    }
    createConnectRequestOptions(requestOptions, proxySettings) {
      let path = `${requestOptions.hostname}:${requestOptions.port}`,
        connectOptions = {
          ...proxySettings,
          method: "CONNECT",
          path: path,
          agent: !1,
          headers: {
            host: path,
            "Proxy-Connection": "keep-alive"
          },
          timeout: requestOptions.timeout
        };
      return requestOptions.localAddress && (connectOptions.localAddress = requestOptions.localAddress), this.configureProxyAuthorization(connectOptions, requestOptions), connectOptions;
    }
    configureProxyAuthorization(connectOptions, requestOptions) {
      connectOptions.headers["Proxy-Authorization"] = [], connectOptions.proxyAuth && connectOptions.headers["Proxy-Authorization"].push("Basic " + Buffer.from(connectOptions.proxyAuth).toString("base64")), requestOptions.headers && requestOptions.headers["Proxy-Authorization"] && connectOptions.headers["Proxy-Authorization"].push(requestOptions.headers["Proxy-Authorization"]);
    }
  },
  KerberosLoader = class {
    static {
      __name(this, "KerberosLoader");
    }
    load() {
      return _ae();
    }
  };
var HelixFetcher = class extends Fetcher {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.createSocketFactory = (userSettings, rejectUnauthorized) => async requestOptions => {
      requestOptions.rejectUnauthorized = rejectUnauthorized, requestOptions.timeout = userSettings.connectionTimeoutInMs, await this.certificateConfigurator.applyToRequestOptions(requestOptions);
      let proxySettings = await this.certificateConfigurator.enhanceProxySettings(userSettings);
      return await this.proxySocketFactory.createSocket(requestOptions, proxySettings);
    };
    this.fetchApi = this.createFetchApi(ctx), this.certificateConfigurator = new RootCertificateConfigurator(ctx), this.proxySocketFactory = ctx.get(ProxySocketFactory);
  }
  static {
    __name(this, "HelixFetcher");
  }
  set proxySettings(value) {
    this._proxySettings = value, this.fetchApi = this.createFetchApi(this.ctx);
  }
  get proxySettings() {
    return this._proxySettings;
  }
  set rejectUnauthorized(value) {
    super.rejectUnauthorized = value, this.fetchApi = this.createFetchApi(this.ctx);
  }
  get rejectUnauthorized() {
    return super.rejectUnauthorized;
  }
  createFetchApi(ctx) {
    let buildInfo = ctx.get(BuildInfo);
    return super.rejectUnauthorized === !1 && (process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"), context({
      userAgent: `GithubCopilot/${buildInfo.getVersion()}`,
      socketFactory: this._proxySettings ? this.createSocketFactory(this._proxySettings, super.rejectUnauthorized) : void 0,
      rejectUnauthorized: super.rejectUnauthorized
    });
  }
  async fetch(url, options) {
    let helixOptions = {
      ...options,
      body: options.body ? options.body : options.json,
      signal: options.signal
    };
    await this.certificateConfigurator.applyToRequestOptions(helixOptions);
    let certs = await this.certificateConfigurator.getCertificates();
    this.fetchApi.setCA(certs);
    let resp = await this.fetchApi.fetch(url, helixOptions);
    return new Response(resp.status, resp.statusText, resp.headers, () => resp.text(), async () => resp.body);
  }
  disconnectAll() {
    return this.fetchApi.reset();
  }
  makeAbortController() {
    return new AbortController();
  }
};
var import_events = require("events");
var PostInsertionNotifier = class extends xae.EventEmitter {
  static {
    __name(this, "PostInsertionNotifier");
  }
};
function createProductionContext(configProvider) {
  let ctx = new Context();
  return ctx.set(ConfigProvider, configProvider), ctx.set(Clock, new Clock()), ctx.set(BuildInfo, new BuildInfo()), setupRudimentaryLogging(ctx), logger.debug(ctx, "Initializing main context"), ctx.set(CompletionsCache, new CompletionsCache()), ctx.set(CopilotTokenNotifier, new CopilotTokenNotifier()), ctx.set(CertificateReaderCache, new CertificateReaderCache()), ctx.set(RootCertificateReader, getRootCertificateReader(ctx)), ctx.set(ProxySocketFactory, getProxySocketFactory(ctx)), ctx.set(Fetcher, new HelixFetcher(ctx)), ctx.set(LanguageDetection, getLanguageDetection(ctx)), ctx.set(Features, new Features(ctx)), ctx.set(PostInsertionNotifier, new PostInsertionNotifier()), ctx.set(TelemetryUserConfig, new TelemetryUserConfig(ctx)), ctx.set(TelemetryEndpointUrl, new TelemetryEndpointUrl()), ctx.set(TelemetryReporters, new TelemetryReporters()), ctx.set(HeaderContributors, new HeaderContributors()), ctx.set(UserErrorNotifier, new UserErrorNotifier(ctx)), ctx.set(ContextualFilterManager, new ContextualFilterManager()), ctx.set(OpenAIFetcher, new LiveOpenAIFetcher()), ctx.set(BlockModeConfig, new ConfigBlockModeConfig()), ctx.set(UrlOpener, new RealUrlOpener()), ctx.set(ExpConfigMaker, new ExpConfigNone()), ctx.set(PromiseQueue, new PromiseQueue()), ctx.set(uD.SnippetOrchestrator, new uD.SnippetOrchestrator()), ctx.set(ForceMultiLine, ForceMultiLine.default), ctx;
}
__name(createProductionContext, "createProductionContext");
function setupRudimentaryLogging(ctx) {
  ctx.set(RuntimeMode, RuntimeMode.fromEnvironment(!1)), ctx.set(LogVerbose, new LogVerbose(isVerboseLoggingEnabled(ctx))), ctx.set(LogTarget, new ConsoleLog(console));
}
__name(setupRudimentaryLogging, "setupRudimentaryLogging");
var logger = new Logger(0, "context");
var logger = new Logger(1, "Exp"),
  EditorExperimentFilters = class {
    static {
      __name(this, "EditorExperimentFilters");
    }
  };
function setupExperimentationService(ctx) {
  let features = ctx.get(Features);
  features.registerStaticFilters(createAllFilters(ctx)), features.registerDynamicFilter("X-Copilot-OverrideEngine", () => getConfig(ctx, ConfigKey.DebugOverrideEngine));
}
__name(setupExperimentationService, "setupExperimentationService");
function createAllFilters(ctx) {
  let defaultFilters = createDefaultFilters(ctx),
    specificFilters = ctx.get(EditorExperimentFilters).addEditorSpecificFilters();
  return {
    ...defaultFilters,
    ...specificFilters
  };
}
__name(createAllFilters, "createAllFilters");
function createDefaultFilters(ctx) {
  let buildInfo = ctx.get(BuildInfo),
    editorInfo = ctx.get(EditorAndPluginInfo).getEditorInfo(),
    editorSession = ctx.get(EditorSession);
  return {
    "X-VSCode-AppVersion": trimVersionSuffix(editorInfo.version),
    "X-MSEdge-ClientId": editorSession.machineId,
    "X-VSCode-ExtensionName": buildInfo.getName(),
    "X-VSCode-ExtensionVersion": trimVersionSuffix(buildInfo.getVersion()),
    "X-VSCode-TargetPopulation": "public"
  };
}
__name(createDefaultFilters, "createDefaultFilters");
function trimVersionSuffix(version) {
  return version.split("-")[0];
}
__name(trimVersionSuffix, "trimVersionSuffix");
var fs = Ns(require("fs"));
var FakeCopilotTokenManagerFromGitHubToken = class extends CopilotTokenManagerFromGitHubTokenBase {
    constructor(githubToken) {
      super();
      this.githubToken = githubToken;
    }
    static {
      __name(this, "FakeCopilotTokenManagerFromGitHubToken");
    }
    getGitHubSession(ctx) {
      return Promise.resolve(this.githubToken);
    }
  },
  FixedCopilotTokenManager = class extends CopilotTokenManager {
    constructor(token) {
      super();
      this.token = token;
      this.wasReset = !1;
    }
    static {
      __name(this, "FixedCopilotTokenManager");
    }
    async getGitHubSession(ctx) {
      return Promise.resolve({
        token: "token"
      });
    }
    async getCopilotToken(ctx, force) {
      return new CopilotToken(this.token);
    }
    resetCopilotToken(ctx, httpError) {
      this.wasReset = !0;
    }
    async checkCopilotToken(ctx) {
      return {
        status: "OK"
      };
    }
  };
var tokenFileName = `${process.env.HOME}/.copilot-testing-gh-token`,
  tokenManager;
function getTestingCopilotTokenManager() {
  return tokenManager || (tokenManager = createTokenManager()), tokenManager;
}
__name(getTestingCopilotTokenManager, "getTestingCopilotTokenManager");
var createTokenManager = __name(() => {
  let tokenStr = readTestingGitHubToken();
  if (tokenStr) return new FakeCopilotTokenManagerFromGitHubToken({
    token: tokenStr
  });
  if (process.env.GH_COPILOT_TOKEN) return new FixedCopilotTokenManager(process.env.GH_COPILOT_TOKEN);
  if (process.env.GITHUB_TOKEN) return new FakeCopilotTokenManagerFromGitHubToken({
    token: process.env.GITHUB_TOKEN
  });
  throw new Error(`Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${tokenFileName}. Run "npm run get_token" to get one.`);
}, "createTokenManager");
function readTestingGitHubToken() {
  if (mC.existsSync(tokenFileName)) return mC.readFileSync(tokenFileName).toString();
}
__name(readTestingGitHubToken, "readTestingGitHubToken");
var TestUrlOpener = class extends UrlOpener {
  constructor() {
    super(...arguments);
    this.openedUrls = [];
  }
  static {
    __name(this, "TestUrlOpener");
  }
  open(target) {
    this.openedUrls.push(target);
  }
};
function errorMessageForUnsupportedNodeVersion(version = process.versions.node) {
  let [major, minor, _] = version.split(".").map(v => parseInt(v, 10));
  if (major < 16 || major === 16 && minor < 14 || major == 17 && minor < 3) return `Node.js 18.x is required to run GitHub Copilot but found ${version}`;
}
__name(errorMessageForUnsupportedNodeVersion, "errorMessageForUnsupportedNodeVersion");
var import_vscode = require("vscode");
function normalizeIndentCharacter(options, completion, isEmptyLine) {
  function replace(text, toReplace, replacer) {
    let regex = new RegExp(`^(${toReplace})+`, "g");
    return text.split(`
`).map(line => {
      let trimmed = line.replace(regex, ""),
        removedCharacters = line.length - trimmed.length;
      return replacer(removedCharacters) + trimmed;
    }).join(`
`);
  }
  __name(replace, "replace");
  let indentSize;
  if (options.tabSize === void 0 || typeof options.tabSize == "string" ? indentSize = 4 : indentSize = options.tabSize, options.insertSpaces === !1) {
    let r = __name(txt => replace(txt, " ", n => "	".repeat(Math.floor(n / indentSize)) + " ".repeat(n % indentSize)), "r");
    completion.displayText = r(completion.displayText), completion.completionText = r(completion.completionText);
  } else if (options.insertSpaces === !0) {
    let r = __name(txt => replace(txt, "	", n => " ".repeat(n * indentSize)), "r");
    if (completion.displayText = r(completion.displayText), completion.completionText = r(completion.completionText), isEmptyLine) {
      let re = __name(txt => {
        let spacesAtStart = txt.length - txt.trimLeft().length,
          remainder = spacesAtStart % indentSize;
        if (remainder !== 0 && spacesAtStart > 0) {
          let toReplace = " ".repeat(remainder);
          return replace(txt, toReplace, n => " ".repeat((Math.floor(n / indentSize) + 1) * indentSize));
        } else return txt;
      }, "re");
      completion.displayText = re(completion.displayText), completion.completionText = re(completion.completionText);
    }
  }
  return completion;
}
__name(normalizeIndentCharacter, "normalizeIndentCharacter");
function completionsFromGhostTextResults(ctx, completionResults, resultType, document, position, textEditorOptions, lastShownCompletionIndex) {
  let locationFactory = ctx.get(LocationFactory),
    currentLine = document.lineAt(position),
    completions = completionResults.map(result => {
      let range,
        text = "";
      if (textEditorOptions && (result.completion = normalizeIndentCharacter(textEditorOptions, result.completion, currentLine.isEmptyOrWhitespace)), result.completion.displayNeedsWsOffset && currentLine.isEmptyOrWhitespace) range = locationFactory.range(locationFactory.position(position.line, 0), position), text = result.completion.completionText;else if (currentLine.isEmptyOrWhitespace && result.completion.completionText.startsWith(currentLine.text)) range = locationFactory.range(locationFactory.position(position.line, 0), position), text = result.completion.completionText;else {
        let wordRange = document.getWordRangeAtPosition(position);
        if (result.isMiddleOfTheLine) {
          let line = document.lineAt(position),
            rangeFromStart = locationFactory.range(locationFactory.position(position.line, 0), position),
            textBefore = document.getText(rangeFromStart);
          range = result.coversSuffix ? line.range : rangeFromStart, text = textBefore + result.completion.displayText;
        } else if (wordRange) {
          let word = document.getText(wordRange);
          range = locationFactory.range(wordRange.start, position), text = word + result.completion.completionText;
        } else {
          let rangeFromStart = locationFactory.range(locationFactory.position(position.line, 0), position),
            textBefore = document.getText(rangeFromStart);
          range = rangeFromStart, text = textBefore + result.completion.displayText;
        }
      }
      return {
        uuid: v4_default(),
        text: text,
        range: range,
        file: document.uri,
        index: result.completion.completionIndex,
        telemetry: result.telemetry,
        displayText: result.completion.displayText,
        position: position,
        offset: document.offsetAt(position),
        resultType: resultType
      };
    });
  if (resultType === 2 && lastShownCompletionIndex !== void 0) {
    let lastShownCompletion = completions.find(predicate => predicate.index === lastShownCompletionIndex);
    if (lastShownCompletion) {
      let restCompletions = completions.filter(predicate => predicate.index !== lastShownCompletionIndex);
      completions = [lastShownCompletion, ...restCompletions];
    }
  }
  return completions;
}
__name(completionsFromGhostTextResults, "completionsFromGhostTextResults");
var ChangeTracker = class {
  constructor(ctx, fileURI, insertionOffset) {
    this._referenceCount = 0;
    this._isDisposed = !1;
    this._offset = insertionOffset;
    let documentManager = ctx.get(TextDocumentManager);
    this._tracker = documentManager.onDidChangeTextDocument(async e => {
      if (e.document.uri.toString() === fileURI.toString()) {
        for (let cc of e.contentChanges) if (cc.rangeOffset + cc.rangeLength <= this.offset) {
          let delta = cc.text.length - cc.rangeLength;
          this._offset = this._offset + delta;
        }
      }
    });
  }
  static {
    __name(this, "ChangeTracker");
  }
  get offset() {
    return this._offset;
  }
  push(action, timeout) {
    if (this._isDisposed) throw new Error("Unable to push new actions to a disposed ChangeTracker");
    this._referenceCount++, setTimeout(() => {
      action(), this._referenceCount--, this._referenceCount === 0 && (this._tracker.dispose(), this._isDisposed = !0);
    }, timeout);
  }
};
var postInsertionLogger = new Logger(1, "post-insertion"),
  captureTimeouts = [{
    seconds: 15,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 30,
    captureCode: !0,
    captureRejection: !0
  }, {
    seconds: 120,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 300,
    captureCode: !1,
    captureRejection: !1
  }, {
    seconds: 600,
    captureCode: !1,
    captureRejection: !1
  }],
  stillInCodeNearMargin = 50,
  stillInCodeFarMargin = 1500,
  stillInCodeFraction = .5,
  captureCodeMargin = 500,
  postInsertConfiguration = {
    triggerPostInsertionSynchroneously: !1,
    captureCode: !1,
    captureRejection: !1
  };
async function captureCode(ctx, fileURI, offset, suffixOffset) {
  let document = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
  if (!document) return postInsertionLogger.info(ctx, `Could not get document for ${fileURI.fsPath}. Maybe it was closed by the editor.`), {
    prompt: {
      prefix: "",
      suffix: "",
      isFimEnabled: !1,
      promptElementRanges: []
    },
    capturedCode: "",
    terminationOffset: 0
  };
  let documentText = document.getText(),
    documentTextBefore = documentText.substring(0, offset),
    position = document.positionAt(offset),
    hypotheticalPromptResponse = await extractPrompt(ctx, document, position),
    hypotheticalPrompt = hypotheticalPromptResponse.type === "prompt" ? hypotheticalPromptResponse.prompt : {
      prefix: documentTextBefore,
      suffix: "",
      isFimEnabled: !1,
      promptElementRanges: []
    };
  if (hypotheticalPrompt.isFimEnabled && suffixOffset !== void 0) {
    let capturedCode = documentText.substring(offset, suffixOffset);
    return hypotheticalPrompt.suffix = documentText.substring(suffixOffset), {
      prompt: hypotheticalPrompt,
      capturedCode: capturedCode,
      terminationOffset: 0
    };
  } else {
    let hypotheticalResponse = documentText.substring(offset),
      contextIndent = contextIndentationFromText(documentTextBefore, offset, document.languageId),
      terminationResult = await indentationBlockFinished(contextIndent, void 0)(hypotheticalResponse),
      maxOffset = Math.min(documentText.length, offset + (terminationResult ? terminationResult * 2 : captureCodeMargin)),
      capturedCode = documentText.substring(offset, maxOffset);
    return {
      prompt: hypotheticalPrompt,
      capturedCode: capturedCode,
      terminationOffset: terminationResult ?? -1
    };
  }
}
__name(captureCode, "captureCode");
function postRejectionTasks(ctx, insertionCategory, insertionOffset, fileURI, completions) {
  completions.forEach(({
    completionText: completionText,
    completionTelemetryData: completionTelemetryData
  }) => {
    postInsertionLogger.debug(ctx, `${insertionCategory}.rejected choiceIndex: ${completionTelemetryData.properties.choiceIndex}`), telemetryRejected(ctx, insertionCategory, completionTelemetryData);
  });
  let positionTracker = new ChangeTracker(ctx, fileURI, insertionOffset - 1),
    suffixTracker = new ChangeTracker(ctx, fileURI, insertionOffset);
  captureTimeouts.filter(t => t.captureRejection).map(t => {
    positionTracker.push(async () => {
      postInsertionLogger.debug(ctx, `Original offset: ${insertionOffset}, Tracked offset: ${positionTracker.offset}`);
      let {
          completionTelemetryData: completionTelemetryData
        } = completions[0],
        {
          prompt: prompt,
          capturedCode: capturedCode,
          terminationOffset: terminationOffset
        } = await captureCode(ctx, fileURI, positionTracker.offset + 1, suffixTracker.offset),
        promptTelemetry;
      prompt.isFimEnabled ? promptTelemetry = {
        hypotheticalPromptPrefixJson: JSON.stringify(prompt.prefix),
        hypotheticalPromptSuffixJson: JSON.stringify(prompt.suffix)
      } : promptTelemetry = {
        hypotheticalPromptJson: JSON.stringify(prompt.prefix)
      };
      let customTelemetryData = completionTelemetryData.extendedBy({
        ...promptTelemetry,
        capturedCodeJson: JSON.stringify(capturedCode)
      }, {
        timeout: t.seconds,
        insertionOffset: insertionOffset,
        trackedOffset: positionTracker.offset,
        terminationOffsetInCapturedCode: terminationOffset
      });
      postInsertionLogger.debug(ctx, `${insertionCategory}.capturedAfterRejected choiceIndex: ${completionTelemetryData.properties.choiceIndex}`, customTelemetryData), telemetry(ctx, insertionCategory + ".capturedAfterRejected", customTelemetryData, 1);
    }, t.seconds * 1e3);
  });
}
__name(postRejectionTasks, "postRejectionTasks");
async function postInsertionTasks(ctx, insertionCategory, completionText, insertionOffset, fileURI, telemetryData, completionId, start) {
  postInsertionLogger.debug(ctx, `${insertionCategory}.accepted choiceIndex: ${telemetryData.properties.choiceIndex}`), telemetryAccepted(ctx, insertionCategory, telemetryData);
  let trimmedCompletion = completionText.trim(),
    tracker = new ChangeTracker(ctx, fileURI, insertionOffset),
    suffixTracker = new ChangeTracker(ctx, fileURI, insertionOffset + completionText.length),
    stillInCodeCheck = __name(async timeout => {
      await checkStillInCode(ctx, insertionCategory, trimmedCompletion, insertionOffset, fileURI, timeout, telemetryData, tracker, suffixTracker);
    }, "stillInCodeCheck");
  postInsertConfiguration.triggerPostInsertionSynchroneously && isRunningInTest(ctx) ? await stillInCodeCheck({
    seconds: 0,
    captureCode: postInsertConfiguration.captureCode,
    captureRejection: postInsertConfiguration.captureRejection
  }) : captureTimeouts.map(timeout => tracker.push(() => stillInCodeCheck(timeout), timeout.seconds * 1e3)), ctx.get(PostInsertionNotifier).emit("onPostInsertion", {
    ctx: ctx,
    insertionCategory: insertionCategory,
    insertionOffset: insertionOffset,
    fileURI: fileURI,
    completionText: completionText,
    telemetryData: telemetryData,
    completionId: completionId,
    start: start
  });
}
__name(postInsertionTasks, "postInsertionTasks");
function find(documentText, completion, margin, offset) {
  let window = documentText.substring(Math.max(0, offset - margin), Math.min(documentText.length, offset + completion.length + margin)),
    lexAlignment = lexEditDistance(window, completion),
    fraction = lexAlignment.lexDistance / lexAlignment.needleLexLength,
    {
      distance: charEditDistance
    } = editDistance(window.substring(lexAlignment.startOffset, lexAlignment.endOffset), completion);
  return {
    relativeLexEditDistance: fraction,
    charEditDistance: charEditDistance,
    completionLexLength: lexAlignment.needleLexLength,
    foundOffset: lexAlignment.startOffset + Math.max(0, offset - margin),
    lexEditDistance: lexAlignment.lexDistance,
    stillInCodeHeuristic: fraction <= stillInCodeFraction ? 1 : 0
  };
}
__name(find, "find");
async function checkStillInCode(ctx, insertionCategory, completion, insertionOffset, fileURI, timeout, telemetryData, tracker, suffixTracker) {
  let document = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
  if (document) {
    let documentText = document.getText(),
      finding = find(documentText, completion, stillInCodeNearMargin, tracker.offset);
    finding.stillInCodeHeuristic || (finding = find(documentText, completion, stillInCodeFarMargin, tracker.offset)), postInsertionLogger.debug(ctx, `stillInCode: ${finding.stillInCodeHeuristic ? "Found" : "Not found"}! Completion '${completion}' in file ${fileURI.fsPath}. lexEditDistance fraction was ${finding.relativeLexEditDistance}. Char edit distance was ${finding.charEditDistance}. Inserted at ${insertionOffset}, tracked at ${tracker.offset}, found at ${finding.foundOffset}. choiceIndex: ${telemetryData.properties.choiceIndex}`);
    let customTelemetryData = telemetryData.extendedBy({}, {
      timeout: timeout.seconds,
      insertionOffset: insertionOffset,
      trackedOffset: tracker.offset
    }).extendedBy({}, finding);
    if (telemetry(ctx, insertionCategory + ".stillInCode", customTelemetryData), timeout.captureCode) {
      let {
          prompt: prompt,
          capturedCode: capturedCode,
          terminationOffset: terminationOffset
        } = await captureCode(ctx, fileURI, tracker.offset, suffixTracker.offset),
        promptTelemetry;
      prompt.isFimEnabled ? promptTelemetry = {
        hypotheticalPromptPrefixJson: JSON.stringify(prompt.prefix),
        hypotheticalPromptSuffixJson: JSON.stringify(prompt.suffix)
      } : promptTelemetry = {
        hypotheticalPromptJson: JSON.stringify(prompt.prefix)
      };
      let afterAcceptedTelemetry = telemetryData.extendedBy({
        ...promptTelemetry,
        capturedCodeJson: JSON.stringify(capturedCode)
      }, {
        timeout: timeout.seconds,
        insertionOffset: insertionOffset,
        trackedOffset: tracker.offset,
        terminationOffsetInCapturedCode: terminationOffset
      });
      postInsertionLogger.debug(ctx, `${insertionCategory}.capturedAfterAccepted choiceIndex: ${telemetryData.properties.choiceIndex}`, customTelemetryData), telemetry(ctx, insertionCategory + ".capturedAfterAccepted", afterAcceptedTelemetry, 1);
    }
  }
}
__name(checkStillInCode, "checkStillInCode");
function isDocumentTooLarge(document) {
  try {
    return document.getText(), !1;
  } catch (e) {
    if (e instanceof RangeError) return !0;
    throw e;
  }
}
__name(isDocumentTooLarge, "isDocumentTooLarge");
async function isDocumentValid(ctx, document) {
  if (isDocumentTooLarge(document)) return {
    status: "invalid",
    reason: "Document is too large"
  };
  let rcmResult = await ctx.get(CopilotRepositoryControlManager).evaluate(document.uri, document.getText());
  return rcmResult.isBlocked ? {
    status: "invalid",
    reason: rcmResult.message ?? "Document is blocked by repository policy"
  } : {
    status: "valid",
    document: document
  };
}
__name(isDocumentValid, "isDocumentValid");
var import_vscode_uri = Ns(B1());
var CopilotPanelScheme = "copilot";
function completionTypeToString(type) {
  switch (type) {
    case 2:
      return "open copilot";
    default:
      return "unknown";
  }
}
__name(completionTypeToString, "completionTypeToString");
var CompletionContext = class _CompletionContext {
  constructor(ctx, insertPosition, completionType) {
    this.prependToCompletion = "";
    this.appendToCompletion = "";
    this.indentation = null;
    this.completionType = 2;
    this.insertPosition = ctx.get(LocationFactory).position(insertPosition.line, insertPosition.character), this.completionType = completionType;
  }
  static {
    __name(this, "CompletionContext");
  }
  static fromJSONParse(ctx, contextObj) {
    let insertPosition = ctx.get(LocationFactory).position(contextObj.insertPosition.line, contextObj.insertPosition.character),
      context = new _CompletionContext(ctx, insertPosition, contextObj.completionType);
    return context.prependToCompletion = contextObj.prependToCompletion, context.appendToCompletion = contextObj.appendToCompletion, context.indentation = contextObj.indentation, context;
  }
};
function completionContextForDocument(ctx, document, insertPosition) {
  let returnPosition = insertPosition,
    line = document.lineAt(insertPosition.line);
  return line.isEmptyOrWhitespace || (returnPosition = line.range.end), new CompletionContext(ctx, returnPosition, 2);
}
__name(completionContextForDocument, "completionContextForDocument");
var seq = 0;
function encodeLocation(targetUri, completionContext) {
  let panelFileName = "GitHub Copilot Suggestions",
    target = targetUri.toString().split("#"),
    remain = target.length > 1 ? target[1] : "",
    query = JSON.stringify([target[0], completionContext, remain]),
    targetFileName = ey.Utils.basename(targetUri);
  return targetFileName.length > 0 && (panelFileName += ` for ${targetFileName}`), ey.URI.from({
    scheme: CopilotPanelScheme,
    path: panelFileName,
    query: query,
    fragment: `${seq++}`
  });
}
__name(encodeLocation, "encodeLocation");
function decodeLocation(ctx, uri) {
  let [target, completionContextPrimer, remain] = JSON.parse(uri.query),
    targetUri = ey.URI.parse(remain.length > 0 ? target + "#" + remain : target),
    completionContext = CompletionContext.fromJSONParse(ctx, completionContextPrimer);
  return [targetUri, completionContext];
}
__name(decodeLocation, "decodeLocation");
function ignoreDocument(ctx, document) {
  let language = document.languageId;
  return !!(!getEnabledConfig(ctx, language) || [CopilotPanelScheme, "output", "search-editor"].includes(document.uri.scheme));
}
__name(ignoreDocument, "ignoreDocument");
var import_vscode = require("vscode");
var oomCodes = new Set(["ERR_WORKER_OUT_OF_MEMORY", "ENOMEM"]);
function isOomError(error) {
  return oomCodes.has(error.code ?? "") || error.name === "RangeError" && error.message === "WebAssembly.Memory(): could not allocate memory";
}
__name(isOomError, "isOomError");
function handleException(ctx, err, origin) {
  if (!isAbortError(err)) {
    if (err instanceof Error) {
      let error = err;
      isOomError(error) ? ctx.get(StatusReporter).setError("Out of memory") : error.code === "EMFILE" || error.code === "ENFILE" ? ctx.get(StatusReporter).setError("Too many open files") : error.code === "CopilotPromptLoadFailure" ? ctx.get(StatusReporter).setError("Corrupted Copilot installation") : `${error.code}`.startsWith("CopilotPromptWorkerExit") ? ctx.get(StatusReporter).setError("Worker unexpectedly exited") : error.syscall === "uv_cwd" && error.code === "ENOENT" && ctx.get(StatusReporter).setError("Current working directory does not exist");
    }
    console.error(origin, err), telemetryException(ctx, err, origin);
  }
}
__name(handleException, "handleException");
function exception(ctx, error, origin) {
  error instanceof Error && error.name === "Canceled" || error instanceof Error && error.name === "CodeExpectedError" || handleException(ctx, error, origin);
}
__name(exception, "exception");
function registerCommandWithTelemetry(ctx, command, fn) {
  let disposable = Uae.commands.registerCommand(command, async (...args) => {
    try {
      return await fn(...args);
    } catch (error) {
      exception(ctx, error, command);
    }
  });
  ctx.get(Extension).register(disposable);
}
__name(registerCommandWithTelemetry, "registerCommandWithTelemetry");
function cleanupTelemetryReporters(ctx) {
  let container = ctx.get(TelemetryReporters);
  disposeIfNeccessary(ctx, container.getReporter(ctx)), disposeIfNeccessary(ctx, container.getRestrictedReporter(ctx));
}
__name(cleanupTelemetryReporters, "cleanupTelemetryReporters");
function disposeIfNeccessary(ctx, reporter) {
  reporter && ctx.get(Extension).register(reporter);
}
__name(disposeIfNeccessary, "disposeIfNeccessary");
var postInsertCmdName = "_ghostTextPostInsert",
  VersionMismatchError = class extends Error {
    constructor(oldVersion, newVersion) {
      super(`Document version changed from ${oldVersion} to ${newVersion}`);
      this.oldVersion = oldVersion;
      this.newVersion = newVersion;
      this.name = "VersionMismatchError";
    }
    static {
      __name(this, "VersionMismatchError");
    }
  },
  ExtensionTextDocument = class {
    static {
      __name(this, "ExtensionTextDocument");
    }
    constructor(textDocument) {
      this._textDocument = textDocument, this._originalVersion = textDocument.version;
    }
    get textDocument() {
      if (this._originalVersion !== this._textDocument.version) throw new VersionMismatchError(this._originalVersion, this._textDocument.version);
      return this._textDocument;
    }
    get uri() {
      return this.textDocument.uri;
    }
    get languageId() {
      return this.textDocument.languageId;
    }
    get version() {
      return this.textDocument.version;
    }
    get lineCount() {
      return this.textDocument.lineCount;
    }
    get relativePath() {
      return this.textDocument.uri.path;
    }
    getText(range) {
      return this.textDocument.getText(range);
    }
    positionAt(offset) {
      return this.textDocument.positionAt(offset);
    }
    offsetAt(position) {
      return this.textDocument.offsetAt(position);
    }
    lineAt(position) {
      let lineNumber = typeof position == "number" ? position : position.line;
      return this.textDocument.lineAt(lineNumber);
    }
    getWordRangeAtPosition(position) {
      return this.textDocument.getWordRangeAtPosition(position);
    }
  };
function getInsertionTextFromCompletion(completion) {
  return completion.insertText;
}
__name(getInsertionTextFromCompletion, "getInsertionTextFromCompletion");
var ghostTextLogger = new Logger(1, "ghostText");
function ghostTextEnabled(ctx) {
  return getConfig(ctx, ConfigKey.InlineSuggestEnable);
}
__name(ghostTextEnabled, "ghostTextEnabled");
function getTextEditorOptions(document) {
  return Ol.window.visibleTextEditors.find(editor => editor.document === document)?.options;
}
__name(getTextEditorOptions, "getTextEditorOptions");
var lastPosition,
  lastUri,
  lastShownCompletions = [],
  lastShownCompletionIndex,
  lastPartiallyAcceptedLength;
async function calculateInlineCompletions(ctx, vscodeDocument, position, context, token) {
  let document = new ExtensionTextDocument(vscodeDocument),
    textEditorOptions = getTextEditorOptions(vscodeDocument),
    telemetryData = TelemetryData.createAndMarkAsIssued();
  if (!ghostTextEnabled(ctx)) return {
    type: "abortedBeforeIssued",
    reason: "ghost text is disabled"
  };
  if (ignoreDocument(ctx, document)) return {
    type: "abortedBeforeIssued",
    reason: "document is ignored"
  };
  if (isDocumentTooLarge(document)) return {
    type: "abortedBeforeIssued",
    reason: "document is too large"
  };
  if (ghostTextLogger.debug(ctx, `Ghost text called at [${position.line}, ${position.character}], with triggerKind ${context.triggerKind}`), token.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled before extractPrompt"), {
    type: "abortedBeforeIssued",
    reason: "cancelled before extractPrompt"
  };
  let result = await getGhostText(ctx, document, position, context.triggerKind === Ol.InlineCompletionTriggerKind.Invoke, telemetryData, token);
  if (result.type !== "success") return ghostTextLogger.debug(ctx, "Breaking, no results from getGhostText -- " + result.type + ": " + result.reason), result;
  let [resultArray, resultType] = result.value;
  if (lastPosition && lastUri && !(lastPosition.isEqual(position) && lastUri.toString() === document.uri.toString()) && resultType !== 2) {
    let rejectedCompletions = computeRejectedCompletions();
    rejectedCompletions.length > 0 && postRejectionTasks(ctx, "ghostText", document.offsetAt(lastPosition), lastUri, rejectedCompletions), lastPartiallyAcceptedLength = void 0;
  }
  if (lastPosition = position, lastUri = document.uri, lastShownCompletions = [], token.isCancellationRequested) return ghostTextLogger.info(ctx, "Cancelled after getGhostText"), {
    type: "canceled",
    reason: "after getGhostText",
    telemetryData: {
      telemetryBlob: result.telemetryBlob
    }
  };
  let inlineCompletions = completionsFromGhostTextResults(ctx, resultArray, resultType, document, position, textEditorOptions, lastShownCompletionIndex).map(completion => {
    let {
        text: text,
        range: range
      } = completion,
      newRange = new Ol.Range(new Ol.Position(range.start.line, range.start.character), new Ol.Position(range.end.line, range.end.character)),
      completionItem = new Ol.InlineCompletionItem(text, newRange);
    return completionItem.index = completion.index, completionItem.telemetry = completion.telemetry, completionItem.displayText = completion.displayText, completionItem.resultType = completion.resultType, completionItem.id = completion.uuid, completionItem.uri = document.uri, completionItem.insertPosition = new Ol.Position(completion.position.line, completion.position.character), completionItem.insertOffset = document.offsetAt(completionItem.insertPosition), completionItem.command = {
      title: "PostInsertTask",
      command: postInsertCmdName,
      arguments: [completionItem]
    }, completionItem;
  });
  return inlineCompletions.length === 0 ? {
    type: "empty",
    reason: "no completions in final result",
    telemetryData: result.telemetryData
  } : {
    ...result,
    value: inlineCompletions
  };
}
__name(calculateInlineCompletions, "calculateInlineCompletions");
function computeRejectedCompletions() {
  let rejectedCompletions = [];
  return lastShownCompletions.forEach(c => {
    if (c.displayText && c.telemetry) {
      let completionText, completionTelemetryData;
      lastPartiallyAcceptedLength ? (completionText = c.displayText.substring(lastPartiallyAcceptedLength - 1), completionTelemetryData = c.telemetry.extendedBy({
        compType: "partial"
      }, {
        compCharLen: completionText.length
      })) : (completionText = c.displayText, completionTelemetryData = c.telemetry);
      let rejection = {
        completionText: completionText,
        completionTelemetryData: completionTelemetryData
      };
      rejectedCompletions.push(rejection);
    }
  }), rejectedCompletions;
}
__name(computeRejectedCompletions, "computeRejectedCompletions");
async function provideInlineCompletions(ctx, document, position, context, token) {
  let result;
  try {
    result = await calculateInlineCompletions(ctx, document, position, context, token);
  } catch (e) {
    if (!(e instanceof VersionMismatchError)) throw e;
    let data = TelemetryData.createAndMarkAsIssued({
      languageId: String(document.languageId),
      requestedDocumentVersion: String(e.oldVersion),
      actualDocumentVersion: String(e.newVersion)
    });
    telemetry(ctx, "ghostText.docVersionMismatch", data);
    return;
  }
  return await handleGhostTextResultTelemetry(ctx, result);
}
__name(provideInlineCompletions, "provideInlineCompletions");
var Provider = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "Provider");
  }
  async provideInlineCompletionItems(doc, cursorPos, context, token) {
    if (!(context.triggerKind === Ol.InlineCompletionTriggerKind.Automatic && !isAutoCompletionsEnabled(this.ctx))) try {
      let items = await provideInlineCompletions(this.ctx, doc, cursorPos, context, token);
      return items ? {
        items: items
      } : void 0;
    } catch (e) {
      exception(this.ctx, e, "ghostText.provideInlineCompletionItems");
    }
  }
  handleDidShowCompletionItem(completionItem) {
    try {
      handleGhostTextShown(this.ctx, completionItem);
    } catch (e) {
      exception(this.ctx, e, "ghostText.handleGhostTextShown");
    }
  }
  handleDidPartiallyAcceptCompletionItem(completionItem, acceptedLength) {
    try {
      handlePartialGhostTextPostInsert(this.ctx, completionItem, acceptedLength);
    } catch (e) {
      exception(this.ctx, e, "ghostText.handleDidPartiallyAcceptCompletionItem");
    }
  }
};
function isAutoCompletionsEnabled(ctx) {
  return getConfig(ctx, ConfigKey.EnableAutoCompletions);
}
__name(isAutoCompletionsEnabled, "isAutoCompletionsEnabled");
async function handlePartialGhostTextPostInsert(ctx, ci, acceptedLength) {
  if (acceptedLength === getInsertionTextFromCompletion(ci).length && resetStateForLastCompletion(), ghostTextLogger.debug(ctx, "Ghost text partial post insert"), ci.telemetry && ci.uri && ci.displayText && ci.insertOffset && ci.range && ci.id) {
    let partialAcceptanceLength = computePartialLength(ci, acceptedLength);
    if (partialAcceptanceLength) {
      let partialTelemetryData = ci.telemetry.extendedBy({
        compType: "partial"
      }, {
        compCharLen: partialAcceptanceLength
      });
      lastPartiallyAcceptedLength = acceptedLength;
      let completionText = ci.displayText.substring(0, partialAcceptanceLength);
      await postInsertionTasks(ctx, "ghostText", completionText, ci.insertOffset, ci.uri, partialTelemetryData, ci.id, ci.range.start);
    }
  }
}
__name(handlePartialGhostTextPostInsert, "handlePartialGhostTextPostInsert");
function resetStateForLastCompletion() {
  lastShownCompletions = [], lastUri = void 0, lastPosition = void 0;
}
__name(resetStateForLastCompletion, "resetStateForLastCompletion");
function resetPartialAcceptanceState() {
  lastPartiallyAcceptedLength = void 0;
}
__name(resetPartialAcceptanceState, "resetPartialAcceptanceState");
function computePartialLength(ci, acceptedLength) {
  if (!ci.range || !ci.range.start || !ci.range.end) return;
  let insertText = getInsertionTextFromCompletion(ci);
  return ci.displayText !== insertText && insertText.trim() === ci.displayText ? acceptedLength : acceptedLength - ci.range.end.character + ci.range.start.character;
}
__name(computePartialLength, "computePartialLength");
function handleGhostTextShown(ctx, ci) {
  if (lastShownCompletionIndex = ci.index, !lastShownCompletions.find(c => c.index === ci.index) && (`${ci.uri}` == `${lastUri}` && lastPosition?.isEqual(ci.insertPosition) && lastShownCompletions.push(ci), ci.telemetry && ci.displayText)) {
    let fromCache = ci.resultType !== 0;
    ghostTextLogger.debug(ctx, `[${ci.telemetry.properties.headerRequestId}] shown choiceIndex: ${ci.telemetry.properties.choiceIndex}, fromCache ${fromCache}`), ci.telemetry.measurements.compCharLen = ci.displayText.length, telemetryShown(ctx, "ghostText", ci.telemetry, fromCache);
  }
}
__name(handleGhostTextShown, "handleGhostTextShown");
async function handleGhostTextPostInsert(ctx, e) {
  if (resetStateForLastCompletion(), ghostTextLogger.debug(ctx, "Ghost text post insert"), e.telemetry && e.uri && e.displayText && e.insertOffset !== void 0 && e.range && e.id) {
    let completionTelemetryData = e.telemetry.extendedBy({
      compType: lastPartiallyAcceptedLength ? "partial" : "full"
    }, {
      compCharLen: e.displayText.length
    });
    resetPartialAcceptanceState(), await postInsertionTasks(ctx, "ghostText", e.displayText, e.insertOffset, e.uri, completionTelemetryData, e.id, e.range.start);
  }
}
__name(handleGhostTextPostInsert, "handleGhostTextPostInsert");
function registerGhostText(ctx) {
  let provider = new Provider(ctx),
    providerHandler = Ol.languages.registerInlineCompletionItemProvider({
      pattern: "**"
    }, provider),
    postCmdHandler = Ol.commands.registerCommand(postInsertCmdName, async e => handleGhostTextPostInsert(ctx, e));
  ctx.get(Extension).register(providerHandler, postCmdHandler);
}
__name(registerGhostText, "registerGhostText");
var import_vscode = require("vscode");
async function telemetryAuthNotifyShown(ctx, authSource) {
  let data = TelemetryData.createAndMarkAsIssued({
    authSource: authSource
  });
  await telemetry(ctx, "auth.auth_notify_shown", data);
}
__name(telemetryAuthNotifyShown, "telemetryAuthNotifyShown");
async function telemetryAuthNotifyDismissed(ctx) {
  await telemetry(ctx, "auth.auth_notify_dismissed");
}
__name(telemetryAuthNotifyDismissed, "telemetryAuthNotifyDismissed");
async function telemetryNewGitHubLogin(ctx, authSource, authType) {
  let data = TelemetryData.createAndMarkAsIssued({
    authSource: authSource,
    authType: authType
  });
  await telemetry(ctx, "auth.new_github_login", data);
}
__name(telemetryNewGitHubLogin, "telemetryNewGitHubLogin");
async function telemetryGitHubLoginFailed(ctx) {
  await telemetryError(ctx, "auth.github_login_failed");
}
__name(telemetryGitHubLoginFailed, "telemetryGitHubLoginFailed");
var import_vscode = require("vscode");
var GITHUB_SCOPE_READ_USER = ["read:user"],
  GITHUB_SCOPE_USER_EMAIL = ["user:email"],
  SESSION_LOGIN_MESSAGE = "You are not signed in to GitHub. Please sign in to use Copilot.",
  shownSignInMessage = !1;
function permitOneSignIn() {
  shownSignInMessage = !1;
}
__name(permitOneSignIn, "permitOneSignIn");
function authProviderId() {
  return N1.workspace.getConfiguration(CopilotConfigPrefix).get("advanced")?.authProvider === "github-enterprise" ? "github-enterprise" : "github";
}
__name(authProviderId, "authProviderId");
async function onDidChangeSessionsHandler(event, ctx) {
  let provider = event.provider,
    providerId = authProviderId();
  if (provider.id === providerId) {
    let statusReporter = ctx.get(StatusReporter);
    (await N1.authentication.getSession(providerId, GITHUB_SCOPE_USER_EMAIL)) ? (statusReporter.forceNormal(), await ctx.get(CopilotTokenManager).getCopilotToken(ctx, !0)) : (ctx.get(CopilotTokenManager).resetCopilotToken(ctx), statusReporter.setWarning(SESSION_LOGIN_MESSAGE));
  }
}
__name(onDidChangeSessionsHandler, "onDidChangeSessionsHandler");
function getSessionHelper(createIfNone) {
  let providerId = authProviderId();
  return N1.authentication.getSession(providerId, GITHUB_SCOPE_READ_USER, {
    silent: !0
  }).then(session => session || N1.authentication.getSession(providerId, GITHUB_SCOPE_USER_EMAIL, {
    createIfNone: createIfNone
  }));
}
__name(getSessionHelper, "getSessionHelper");
async function getSession(ctx, fromCommand = !1) {
  let session = await getSessionHelper(!1);
  if (!session) if (shownSignInMessage) fromCommand && (telemetryAuthNotifyShown(ctx, "command"), telemetryNewGitHubLogin(ctx, "command", "editorAuth"), session = await getSessionHelper(!0));else {
    shownSignInMessage = !0, telemetryAuthNotifyShown(ctx, "toast");
    let choice = await N1.window.showInformationMessage("Sign in to use GitHub Copilot.", "Sign in to GitHub");
    if (session = await getSessionHelper(!1), !session) if (choice === "Sign in to GitHub") telemetryNewGitHubLogin(ctx, "toast", "editorAuth"), session = await getSessionHelper(!0);else throw telemetryAuthNotifyDismissed(ctx), new CopilotAuthError("GitHubLoginFailed");
  }
  return session;
}
__name(getSession, "getSession");
async function hasExistingSession() {
  return (await getSessionHelper(!1)) !== void 0;
}
__name(hasExistingSession, "hasExistingSession");
var authLogger = new Logger(1, "auth"),
  shown401Message = !1,
  everActivated = !1;
async function auth(ctx) {
  let session = await getSession(ctx);
  if (!session) {
    let message = "GitHub login failed";
    return authLogger.info(ctx, message), telemetryGitHubLoginFailed(ctx), {
      kind: "failure",
      reason: "GitHubLoginFailed",
      message: message
    };
  }
  authLogger.debug(ctx, `Logged in as ${session.account.label}, oauth token ${session.accessToken}`);
  let tokenResult = await authFromGitHubToken(ctx, {
    token: session.accessToken
  });
  if (tokenResult.kind == "success") {
    let token = tokenResult.token;
    authLogger.debug(ctx, `Copilot HMAC for ${session.account.label}: ${token}`);
  }
  return tokenResult;
}
__name(auth, "auth");
var ExtensionNotificationSender = class extends NotificationSender {
  static {
    __name(this, "ExtensionNotificationSender");
  }
  async showWarningMessage(message, ...actions) {
    return {
      title: await ED.window.showWarningMessage(message, ...actions.map(action => action.title))
    };
  }
};
async function authShowWarnings(ctx) {
  let tokenResult = await auth(ctx);
  if (tokenResult.kind === "failure" && tokenResult.reason === "HTTP401") {
    let message = "Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.";
    everActivated && !shown401Message && (shown401Message = !0, ED.window.showWarningMessage(message));
  }
  if (tokenResult.kind === "failure" && tokenResult.message) throw new CopilotAuthError(tokenResult.message);
  if (tokenResult.kind === "failure") {
    let error = new Error(`Unexpected error getting Copilot token: ${tokenResult.reason ?? "no reason given"}`);
    throw error.code = `CopilotToken.${tokenResult.reason}`, error;
  }
  return everActivated = !0, tokenResult;
}
__name(authShowWarnings, "authShowWarnings");
var VSCodeCopilotTokenManager = class extends CopilotTokenManager {
  constructor() {
    super();
    this.copilotToken = void 0;
  }
  static {
    __name(this, "VSCodeCopilotTokenManager");
  }
  async getGitHubSession(ctx) {
    let session = await getSession(ctx);
    return session ? {
      token: session.accessToken
    } : void 0;
  }
  async getCopilotToken(ctx, force) {
    return (!this.copilotToken || this.copilotToken.expires_at < nowSeconds() || force) && (this.copilotToken = await authShowWarnings(ctx), refreshToken(ctx, this, this.copilotToken.refresh_in)), new CopilotToken(this.copilotToken.token, this.copilotToken.organization_list);
  }
  resetCopilotToken(ctx, httpError) {
    httpError !== void 0 && telemetry(ctx, "auth.reset_token_" + httpError), authLogger.debug(ctx, `Resetting copilot token on HTTP error ${httpError || "unknown"}`), this.copilotToken = void 0;
  }
};
var import_vscode = require("vscode");
var import_vscode = require("vscode");
var OutputPaneShowCommand = "codereferencing.showOutputPane",
  FeatureName = "code-referencing",
  ProdSnippyDomain = "https://origin-tracker.githubusercontent.com";
var codeReferenceLogger = new Logger(1, FeatureName);
var statusCodeRe = /^[1-6][0-9][0-9]$/,
  capitalsRe = /([A-Z][a-z]+)/,
  NAMESPACE = "code_referencing",
  CodeQuoteTelemetry = class {
    constructor(baseKey) {
      this.baseKey = baseKey;
    }
    static {
      __name(this, "CodeQuoteTelemetry");
    }
    buildKey(...keys) {
      return [NAMESPACE, this.baseKey, ...keys].join(".");
    }
  },
  CopilotOutputLogTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "CopilotOutputLogTelemetry");
    }
    constructor() {
      super("github_copilot_log");
    }
    handleOpen({
      context: context
    }) {
      let key = this.buildKey("open", "count"),
        data = TelemetryData.createAndMarkAsIssued();
      telemetry(context, key, data);
    }
    handleFocus({
      context: context
    }) {
      let data = TelemetryData.createAndMarkAsIssued(),
        key = this.buildKey("focus", "count");
      telemetry(context, key, data);
    }
    handleWrite({
      context: context
    }) {
      let data = TelemetryData.createAndMarkAsIssued(),
        key = this.buildKey("write", "count");
      telemetry(context, key, data);
    }
  },
  copilotOutputLogTelemetry = new CopilotOutputLogTelemetry(),
  MatchNotificationTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "MatchNotificationTelemetry");
    }
    constructor() {
      super("match_notification");
    }
    handleDoAction({
      context: context,
      actor: actor
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
          actor: actor
        }),
        key = this.buildKey("acknowledge", "count");
      telemetry(context, key, data);
    }
    handleDismiss({
      context: context,
      actor: actor
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
          actor: actor
        }),
        key = this.buildKey("ignore", "count");
      telemetry(context, key, data);
    }
  },
  matchNotificationTelemetry = new MatchNotificationTelemetry(),
  SnippyTelemetry = class extends CodeQuoteTelemetry {
    static {
      __name(this, "SnippyTelemetry");
    }
    constructor() {
      super("snippy");
    }
    handleUnexpectedError({
      context: context,
      origin: origin,
      reason: reason
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        reason: reason
      });
      telemetryError(context, this.buildKey("unexpectedError"), data);
    }
    handleCompletionMissing({
      context: context,
      origin: origin,
      reason: reason
    }) {
      let data = TelemetryData.createAndMarkAsIssued({
        origin: origin,
        reason: reason
      });
      telemetryError(context, this.buildKey("completionMissing"), data);
    }
    handleSnippyNetworkError({
      context: context,
      origin: origin,
      reason: reason,
      message: message
    }) {
      if (!origin.match(statusCodeRe)) {
        codeReferenceLogger.debug(context, "Invalid status code, not sending telemetry", {
          origin: origin
        });
        return;
      }
      let errorType = reason.split(capitalsRe).filter(part => !!part).join("_").toLowerCase(),
        data = TelemetryData.createAndMarkAsIssued({
          message: message
        });
      telemetryError(context, this.buildKey(errorType, origin), data);
    }
  },
  snippyTelemetry = new SnippyTelemetry();
var CopilotOutputLogFilename = "GitHub Copilot Log",
  CodeRefEngagementTracker = class {
    constructor(ctx) {
      this.ctx = ctx;
      this.activeLog = !1;
      this.subscriptions = [];
      this.onActiveEditorChange = editor => {
        this.isOutputLog(editor) && copilotOutputLogTelemetry.handleFocus({
          context: this.ctx
        });
      };
      this.onVisibleEditorsChange = currEditors => {
        let copilotLog = currEditors.find(this.isOutputLog);
        this.activeLog ? copilotLog || (this.activeLog = !1) : copilotLog && (this.activeLog = !0, copilotOutputLogTelemetry.handleOpen({
          context: this.ctx
        }));
      };
      this.isOutputLog = editor => editor && editor.document.uri.scheme === "output" && editor.document.uri.path.includes(CopilotOutputLogFilename);
    }
    static {
      __name(this, "CodeRefEngagementTracker");
    }
    register() {
      let activeEditorChangeSub = ay.window.onDidChangeActiveTextEditor(this.onActiveEditorChange),
        visibleEditorsSub = ay.window.onDidChangeVisibleTextEditors(this.onVisibleEditorsChange);
      this.subscriptions.push(visibleEditorsSub), this.subscriptions.push(activeEditorChangeSub);
    }
    dispose() {
      return ay.Disposable.from(...this.subscriptions);
    }
    get logVisible() {
      return this.activeLog;
    }
  };
function registerCodeRefEngagementTracker(ctx) {
  let engagementTracker = new CodeRefEngagementTracker(ctx);
  return engagementTracker.register(), engagementTracker;
}
__name(registerCodeRefEngagementTracker, "registerCodeRefEngagementTracker");
var InitialTimeout = 3e3,
  BaseRetryTime = 2,
  MaxRetryTime = 256,
  MaxAttempts = Math.log(MaxRetryTime) / Math.log(BaseRetryTime) / BaseRetryTime,
  state = {
    connection: "disabled",
    maxAttempts: MaxAttempts,
    retryAttempts: 0,
    initialWait: !1
  },
  stateAPI,
  handlers = [];
function registerConnectionState() {
  if (stateAPI) return stateAPI;
  function subscribe(cb) {
    return handlers.push(cb), () => {
      let index = handlers.indexOf(cb);
      index !== -1 && handlers.splice(index, 1);
    };
  }
  __name(subscribe, "subscribe");
  function afterUpdateConnection() {
    for (let handler of handlers) handler();
  }
  __name(afterUpdateConnection, "afterUpdateConnection");
  function updateConnection(status) {
    state.connection !== status && (state.connection = status, afterUpdateConnection());
  }
  __name(updateConnection, "updateConnection");
  function isConnected() {
    return state.connection === "connected";
  }
  __name(isConnected, "isConnected");
  function isDisconnected() {
    return state.connection === "disconnected";
  }
  __name(isDisconnected, "isDisconnected");
  function isRetrying() {
    return state.connection === "retry";
  }
  __name(isRetrying, "isRetrying");
  function isDisabled() {
    return state.connection === "disabled";
  }
  __name(isDisabled, "isDisabled");
  function setConnected() {
    updateConnection("connected"), setInitialWait(!1);
  }
  __name(setConnected, "setConnected");
  function setDisconnected() {
    updateConnection("disconnected");
  }
  __name(setDisconnected, "setDisconnected");
  function setRetrying() {
    updateConnection("retry");
  }
  __name(setRetrying, "setRetrying");
  function setDisabled() {
    updateConnection("disabled");
  }
  __name(setDisabled, "setDisabled");
  function setInitialWait(enabled) {
    state.initialWait !== enabled && (state.initialWait = enabled);
  }
  __name(setInitialWait, "setInitialWait");
  async function enableRetry(ctx, initialTimeout = InitialTimeout) {
    isRetrying() || (setRetrying(), setInitialWait(!0), attemptToPing(ctx, initialTimeout));
  }
  __name(enableRetry, "enableRetry");
  function isInitialWait() {
    return state.initialWait;
  }
  __name(isInitialWait, "isInitialWait");
  async function attemptToPing(ctx, initialTimeout) {
    codeReferenceLogger.info(ctx, `Attempting to reconnect in ${initialTimeout}ms.`), await timeout(initialTimeout), setInitialWait(!1);
    let fetcher = ctx.get(Fetcher);
    async function succeedOrRetry(time, ctx) {
      if (time > MaxRetryTime) {
        codeReferenceLogger.info(ctx, "Max retry time reached, disabling."), setDisabled();
        return;
      }
      setTimeout(async () => {
        state.retryAttempts = Math.min(state.retryAttempts + 1, MaxAttempts);
        try {
          codeReferenceLogger.info(ctx, `Pinging service after ${time} second(s)`);
          let response = await fetcher.fetch(ProdSnippyDomain + "/_ping", {
            method: "GET",
            headers: {
              "content-type": "application/json"
            }
          });
          if (response.status !== 200 || !response.ok) await succeedOrRetry(time ** 2, ctx);else {
            codeReferenceLogger.info(ctx, "Successfully reconnected."), setConnected();
            return;
          }
        } catch {
          await succeedOrRetry(time ** 2, ctx);
        }
      }, time * 1e3);
    }
    __name(succeedOrRetry, "succeedOrRetry"), codeReferenceLogger.info(ctx, "Attempting to reconnect."), await succeedOrRetry(BaseRetryTime, ctx);
  }
  __name(attemptToPing, "attemptToPing");
  let timeout = __name(ms => new Promise(resolve => setTimeout(resolve, ms)), "timeout");
  function listen(cb) {
    return {
      dispose: subscribe(cb)
    };
  }
  return __name(listen, "listen"), stateAPI = {
    setConnected: setConnected,
    setDisconnected: setDisconnected,
    setRetrying: setRetrying,
    setDisabled: setDisabled,
    enableRetry: enableRetry,
    listen: listen,
    isConnected: isConnected,
    isDisconnected: isDisconnected,
    isRetrying: isRetrying,
    isDisabled: isDisabled,
    isInitialWait: isInitialWait
  }, stateAPI;
}
__name(registerConnectionState, "registerConnectionState");
var ConnectionState = registerConnectionState();
var import_vscode = require("vscode");
var CodeQuoteHeaderContributor = class {
    static {
      __name(this, "CodeQuoteHeaderContributor");
    }
    constructor(codequoteEnabled) {
      this.codequoteEnabled = codequoteEnabled ?? !1;
    }
    updateCodeQuoteEnabled(codequoteEnabled) {
      this.codequoteEnabled = codequoteEnabled ?? !1;
    }
    contributeHeaderValues(headers) {
      headers["Code-Quote-Enabled"] = String(this.codequoteEnabled);
    }
  },
  AnnotationsHeaderContributor = class {
    static {
      __name(this, "AnnotationsHeaderContributor");
    }
    constructor(annotationsEnabled) {
      this.annotationsEnabled = annotationsEnabled ?? !1;
    }
    updateAnnotationsEnabled(annotationsEnabled) {
      this.annotationsEnabled = annotationsEnabled ?? !1;
    }
    contributeHeaderValues(headers) {
      headers["Annotations-Enabled"] = String(this.annotationsEnabled);
    }
  };
function registerCopilotEnvelopeListener(ctx) {
  function updateFromEnvelopeState() {
    let codeQuoteEnabled = !ConnectionState.isDisabled();
    codequoteHeaderContributor.updateCodeQuoteEnabled(codeQuoteEnabled);
  }
  __name(updateFromEnvelopeState, "updateFromEnvelopeState");
  let disposer = ConnectionState.listen(updateFromEnvelopeState),
    codequoteHeaderContributor = new CodeQuoteHeaderContributor(),
    headerContributors = ctx.get(HeaderContributors);
  return headerContributors.add(codequoteHeaderContributor), updateFromEnvelopeState(), new s0e.Disposable(() => {
    headerContributors.remove(codequoteHeaderContributor), disposer.dispose();
  });
}
__name(registerCopilotEnvelopeListener, "registerCopilotEnvelopeListener");
var import_value = Ns(OL()),
  import_vscode = require("vscode");
var SnippyLexemeRegex = new RegExp("[_\\p{L}\\p{Nd}]+|====+|----+|####+|////+|\\*\\*\\*\\*+|[\\p{P}\\p{S}]", "gu"),
  MinTokenLength = 65;
function lexemeLength(text) {
  let i = 0,
    m;
  SnippyLexemeRegex.lastIndex = 0;
  do if (m = SnippyLexemeRegex.exec(text), m && (i += 1), i >= MinTokenLength) break; while (m);
  return i;
}
__name(lexemeLength, "lexemeLength");
function offsetFirstLexemes(text, n) {
  let i = 0,
    m;
  SnippyLexemeRegex.lastIndex = 0;
  do if (m = SnippyLexemeRegex.exec(text), m && (i += 1, i >= n)) return SnippyLexemeRegex.lastIndex; while (m);
  return text.length;
}
__name(offsetFirstLexemes, "offsetFirstLexemes");
function offsetLastLexemes(text, n) {
  let textRev = text.split("").reverse().join(""),
    offsetRev = offsetFirstLexemes(textRev, n);
  return textRev.length - offsetRev;
}
__name(offsetLastLexemes, "offsetLastLexemes");
function hasMinLexemeLength(text) {
  return lexemeLength(text) >= MinTokenLength;
}
__name(hasMinLexemeLength, "hasMinLexemeLength");
var import_vscode = require("vscode");
var matchCodeMessage = "We found a reference to public code in a recent suggestion.",
  MatchAction = "View log",
  CodeReferenceKey = "codeReference.notified";
function notify(ctx) {
  let extension = ctx.get(Extension);
  if (extension.context.globalState.get(CodeReferenceKey)) return;
  ctx.get(NotificationSender).showWarningMessage(matchCodeMessage, {
    title: MatchAction
  }).then(action => {
    let event = {
      context: ctx,
      actor: "user"
    };
    switch (action?.title) {
      case MatchAction:
        {
          matchNotificationTelemetry.handleDoAction(event), u0e.commands.executeCommand(OutputPaneShowCommand);
          break;
        }
      case void 0:
        {
          matchNotificationTelemetry.handleDismiss(event);
          break;
        }
    }
  }), extension.context.globalState.update(CodeReferenceKey, !0);
}
__name(notify, "notify");
var import_vscode = require("vscode");
var GitHubCopilotChannelName = "GitHub Copilot Log";
function getCurrentTimestamp() {
  let toTwoDigits = __name(v => v < 10 ? `0${v}` : v, "toTwoDigits"),
    toThreeDigits = __name(v => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v, "toThreeDigits"),
    currentTime = new Date();
  return `${currentTime.getFullYear()}-${toTwoDigits(currentTime.getMonth() + 1)}-${toTwoDigits(currentTime.getDate())} ${toTwoDigits(currentTime.getHours())}:${toTwoDigits(currentTime.getMinutes())}:${toTwoDigits(currentTime.getSeconds())}.${toThreeDigits(currentTime.getMilliseconds())}`;
}
__name(getCurrentTimestamp, "getCurrentTimestamp");
var CodeReferenceOutputChannel = class {
    constructor(output) {
      this.output = output;
    }
    static {
      __name(this, "CodeReferenceOutputChannel");
    }
    info(...messages) {
      this.output.appendLine(`${getCurrentTimestamp()} [info] ${messages.join(" ")}`);
    }
    show(preserveFocus) {
      this.output.show(preserveFocus);
    }
    dispose() {
      this.output.dispose();
    }
  },
  GitHubCopilotLogger = class _GitHubCopilotLogger {
    constructor(ctx) {
      this.ctx = ctx;
      this.tokenManager = void 0;
      this.checkCopilotToken = (_, env) => {
        env.code_quote_enabled ? this.output = this.createChannel() : this.output?.dispose();
      };
      this.tokenManager = this.ctx.get(CopilotTokenNotifier), this.tokenManager.on("onCopilotToken", this.checkCopilotToken), this.output = this.createChannel();
    }
    static {
      __name(this, "GitHubCopilotLogger");
    }
    static create(ctx) {
      return new _GitHubCopilotLogger(ctx);
    }
    createChannel() {
      return this.output ? this.output : new CodeReferenceOutputChannel(d0e.window.createOutputChannel(GitHubCopilotChannelName, "code-referencing"));
    }
    async log(type, ...messages) {
      this.output || (this.output = this.createChannel());
      let [base, ...rest] = messages;
      this.output[type](base, ...rest);
    }
    info(...messages) {
      this.log("info", ...messages);
    }
    forceShow() {
      this.output?.show(!0);
    }
    dispose() {
      this.output?.dispose();
    }
  };
var ErrorReasons = {
    BadArguments: "BadArgumentsError",
    Unauthorized: "NotAuthorized",
    NotFound: "NotFoundError",
    RateLimit: "RateLimitError",
    InternalError: "InternalError",
    ConnectionError: "ConnectionError",
    Unknown: "UnknownError"
  },
  ErrorMessages = {
    [ErrorReasons.Unauthorized]: "Invalid GitHub token. Please sign out from your GitHub account using VSCode UI and try again",
    [ErrorReasons.InternalError]: "Internal error: matches to public code will not be detected. It is advised to disable Copilot completions until the service is reconnected.",
    [ErrorReasons.RateLimit]: "You've reached your quota and limit, code matching will be unavailable until the limit resets"
  };
function getErrorType(code) {
  return code === 401 ? ErrorReasons.Unauthorized : code === 400 ? ErrorReasons.BadArguments : code === 404 ? ErrorReasons.NotFound : code === 429 ? ErrorReasons.RateLimit : code >= 500 && code < 600 ? ErrorReasons.InternalError : code >= 600 ? ErrorReasons.ConnectionError : ErrorReasons.Unknown;
}
__name(getErrorType, "getErrorType");
function createErrorResponse(code, msg, meta = {}) {
  return {
    kind: "failure",
    reason: getErrorType(Number(code)),
    code: Number(code),
    msg: msg,
    meta: meta
  };
}
__name(createErrorResponse, "createErrorResponse");
var TWIRP_URL = "twirp/github.snippy.v1.SnippyAPI";
function getSnippyDomain(ctx) {
  if (isProduction(ctx)) return ProdSnippyDomain;
  let overrideUrl;
  try {
    overrideUrl = getConfig(ctx, ConfigKey.DebugSnippyOverrideUrl);
  } catch {
    return ProdSnippyDomain;
  }
  return overrideUrl || ProdSnippyDomain;
}
__name(getSnippyDomain, "getSnippyDomain");
async function call(ctx, endpoint, config, signal) {
  let SNIPPY_BASE_URL = `${getSnippyDomain(ctx)}/${TWIRP_URL}`,
    token;
  try {
    token = (await ctx.get(CopilotTokenManager).getCopilotToken(ctx)).token;
  } catch {
    return ConnectionState.setDisconnected(), createErrorResponse(401, ErrorMessages[ErrorReasons.Unauthorized]);
  }
  if (codeReferenceLogger.info(ctx, `Calling ${endpoint}`), ConnectionState.isRetrying()) return createErrorResponse(600, "Attempting to reconnect to the public code matching service.");
  if (ConnectionState.isDisconnected()) return createErrorResponse(601, "The public code matching service is offline.");
  let res;
  try {
    res = await ctx.get(Fetcher).fetch(`${SNIPPY_BASE_URL}/${endpoint}`, {
      method: config.method,
      body: config.method === "POST" ? JSON.stringify(config.body) : void 0,
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${token}`,
        ...editorVersionHeaders(ctx)
      },
      signal: signal
    });
  } catch {
    return ConnectionState.enableRetry(ctx), createErrorResponse(602, "Network error detected. Check your internet connection.");
  }
  let payload;
  try {
    payload = await res.json();
  } catch (e) {
    let message = e.message;
    throw snippyTelemetry.handleUnexpectedError({
      context: ctx,
      origin: "snippyNetwork",
      reason: message
    }), e;
  }
  if (res.ok) return {
    kind: "success",
    ...payload
  };
  let errorPayload = {
      ...payload,
      code: Number(res.status)
    },
    {
      code: code,
      msg: msg,
      meta: meta
    } = errorPayload,
    formattedCode = Number(code),
    errorTypeFromCode = getErrorType(formattedCode),
    fallbackMsg = msg || "unknown error";
  switch (errorTypeFromCode) {
    case ErrorReasons.Unauthorized:
      return createErrorResponse(code, ErrorMessages[ErrorReasons.Unauthorized], meta);
    case ErrorReasons.BadArguments:
      return createErrorResponse(code, fallbackMsg, meta);
    case ErrorReasons.RateLimit:
      return ConnectionState.enableRetry(ctx, 60 * 1e3), createErrorResponse(code, ErrorMessages.RateLimitError, meta);
    case ErrorReasons.InternalError:
      return ConnectionState.enableRetry(ctx), createErrorResponse(code, ErrorMessages[ErrorReasons.InternalError], meta);
    default:
      return createErrorResponse(code, fallbackMsg, meta);
  }
}
__name(call, "call");
var import_typebox = Ns(ou()),
  MatchError = ba.Type.Object({
    kind: ba.Type.Literal("failure"),
    reason: ba.Type.String(),
    code: ba.Type.Number(),
    msg: ba.Type.String(),
    meta: ba.Type.Optional(ba.Type.Any())
  }),
  Snippet = ba.Type.Object({
    matched_source: ba.Type.String(),
    occurrences: ba.Type.String(),
    capped: ba.Type.Boolean(),
    cursor: ba.Type.String(),
    github_url: ba.Type.String()
  }),
  MatchRequest = ba.Type.Object({
    source: ba.Type.String()
  }),
  MatchSuccess = ba.Type.Object({
    snippets: ba.Type.Array(Snippet)
  }),
  MatchResponse = ba.Type.Union([MatchSuccess, MatchError]),
  FileMatchRequest = ba.Type.Object({
    cursor: ba.Type.String()
  }),
  FileMatch = ba.Type.Object({
    commit_id: ba.Type.String(),
    license: ba.Type.String(),
    nwo: ba.Type.String(),
    path: ba.Type.String(),
    url: ba.Type.String()
  }),
  PageInfo = ba.Type.Object({
    has_next_page: ba.Type.Boolean(),
    cursor: ba.Type.String()
  }),
  LicenseStats = ba.Type.Object({
    count: ba.Type.Record(ba.Type.String(), ba.Type.String())
  }),
  FileMatchSuccess = ba.Type.Object({
    file_matches: ba.Type.Array(FileMatch),
    page_info: PageInfo,
    license_stats: LicenseStats
  }),
  FileMatchResponse = ba.Type.Union([FileMatchSuccess, MatchError]);
async function Match(ctx, source, signal) {
  let result = await call(ctx, "Match", {
    method: "POST",
    body: assertShape(MatchRequest, {
      source: source
    })
  }, signal);
  return assertShape(MatchResponse, result);
}
__name(Match, "Match");
async function FilesForMatch(ctx, {
  cursor: cursor
}, signal) {
  let result = await call(ctx, "FilesForMatch", {
    method: "POST",
    body: assertShape(FileMatchRequest, {
      cursor: cursor
    })
  }, signal);
  return assertShape(FileMatchResponse, result);
}
__name(FilesForMatch, "FilesForMatch");
var pluralize = __name((count, noun, suffix = "s") => `${count} ${noun}${count !== 1 ? suffix : ""}`, "pluralize");
function isError(payload) {
  return x0e.Value.Check(MatchError, payload);
}
__name(isError, "isError");
async function snippyRequest(ctx, requestFn) {
  let res = await requestFn();
  if (isError(res)) {
    snippyTelemetry.handleSnippyNetworkError({
      context: ctx,
      origin: String(res.code),
      reason: res.reason,
      message: res.msg
    });
    return;
  }
  return res;
}
__name(snippyRequest, "snippyRequest");
function handlePostInsertion(githubLogger) {
  return async event => {
    let {
        ctx: ctx,
        completionText: completionText,
        completionId: completionId,
        start: start,
        fileURI: fileURI,
        insertionOffset: insertionOffset
      } = event,
      insertionDoc = await ctx.get(TextDocumentManager).getTextDocument(fileURI);
    if (!insertionDoc) {
      codeReferenceLogger.debug(ctx, `Expected document matching ${fileURI}, got nothing.`);
      return;
    }
    if (!completionId || !start) {
      snippyTelemetry.handleCompletionMissing({
        context: ctx,
        origin: "onPostInsertion",
        reason: "No completion metadata found."
      });
      return;
    }
    let docText = insertionDoc.getText();
    if (!hasMinLexemeLength(docText)) return;
    let potentialMatchContext = completionText;
    if (!hasMinLexemeLength(completionText)) {
      let textWithoutCompletion = docText.slice(0, insertionOffset),
        minLexemeStartOffset = offsetLastLexemes(textWithoutCompletion, MinTokenLength);
      potentialMatchContext = docText.slice(minLexemeStartOffset, insertionOffset + completionText.length);
    }
    if (!hasMinLexemeLength(potentialMatchContext)) return;
    let matchResponse = await snippyRequest(ctx, () => Match(ctx, potentialMatchContext));
    if (!matchResponse || !matchResponse.snippets.length) {
      codeReferenceLogger.info(ctx, "No match found");
      return;
    }
    codeReferenceLogger.info(ctx, "Match found");
    let {
        snippets: snippets
      } = matchResponse,
      citationPromises = snippets.map(async snippet => {
        let response = await snippyRequest(ctx, () => FilesForMatch(ctx, {
          cursor: snippet.cursor
        }));
        if (!response) return;
        let files = response.file_matches,
          licenseStats = response.license_stats;
        return {
          match: snippet,
          files: files,
          licenseStats: licenseStats
        };
      });
    notify(ctx), Promise.all(citationPromises).then(citations => citations.filter(Boolean)).then(filtered => {
      if (filtered.length) for (let citation of filtered) {
        let licensesSet = new Set(Object.keys(citation.licenseStats?.count ?? {}));
        licensesSet.has("NOASSERTION") && (licensesSet.delete("NOASSERTION"), licensesSet.add("unknown"));
        let allLicenses = Array.from(licensesSet).sort(),
          matchLocation = `[Ln ${start.line}, Col ${start.character}]`,
          shortenedMatchText = `${citation.match.matched_source.slice(0, 100).replace(/[\r\n\t]+|^[ \t]+/gm, " ").trim()}...`,
          workspaceFolders = y3.workspace.workspaceFolders ?? [],
          fileName = fileURI.fsPath;
        for (let folder of workspaceFolders) if (fileURI.fsPath.startsWith(folder.uri.fsPath)) {
          fileName = fileURI.fsPath.replace(folder.uri.fsPath, "");
          break;
        }
        githubLogger.info(`'${fileName}'`, `Similar code with ${pluralize(allLicenses.length, "license type")}`, `[${allLicenses.join(", ")}]`, `${citation.match.github_url.replace(/,\s*$/, "")}&editor=vscode`, matchLocation, shortenedMatchText), copilotOutputLogTelemetry.handleWrite({
          context: ctx
        });
      }
    });
  };
}
__name(handlePostInsertion, "handlePostInsertion");
function registerPostInsertionListener(ctx) {
  let logger = GitHubCopilotLogger.create(ctx),
    initialNotificationCommand = y3.commands.registerCommand(OutputPaneShowCommand, () => logger.forceShow()),
    insertionNotificationHandler = handlePostInsertion(logger),
    notifier = ctx.get(PostInsertionNotifier);
  return notifier.on("onPostInsertion", insertionNotificationHandler), new y3.Disposable(() => {
    notifier.off("onPostInsertion", insertionNotificationHandler), initialNotificationCommand.dispose();
  });
}
__name(registerPostInsertionListener, "registerPostInsertionListener");
var CodeReference = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.onCopilotToken = (_, tokenEnvelope) => {
      if (!tokenEnvelope.code_quote_enabled) {
        ConnectionState.setDisabled(), this.subscriptions?.dispose(), this.subscriptions = void 0, codeReferenceLogger.debug(this.ctx, "Public code references are disabled.");
        return;
      }
      this.annotationsHeaderContributor.updateAnnotationsEnabled(tokenEnvelope.annotations_enabled), ConnectionState.setConnected(), codeReferenceLogger.info(this.ctx, "Public code references are enabled."), this.subscriptions || (this.subscriptions = E0e.Disposable.from(registerCopilotEnvelopeListener(this.ctx), registerPostInsertionListener(this.ctx), registerCodeRefEngagementTracker(this.ctx)));
    };
    this.tokenNotifier = ctx.get(CopilotTokenNotifier), this.annotationsHeaderContributor = new AnnotationsHeaderContributor();
  }
  static {
    __name(this, "CodeReference");
  }
  dispose() {
    this.subscriptions?.dispose(), this.ctx.get(HeaderContributors).remove(this.annotationsHeaderContributor), this.tokenNotifier.off("onCopilotToken", this.onCopilotToken);
  }
  register() {
    return isRunningInTest(this.ctx) || this.tokenNotifier.on("onCopilotToken", this.onCopilotToken), this.ctx.get(HeaderContributors).add(this.annotationsHeaderContributor), this;
  }
};
var vscode = Ns(require("vscode"));
var packageJson = rO();
function stringOrStringify(value) {
  return typeof value == "string" ? value : JSON.stringify(value);
}
__name(stringOrStringify, "stringOrStringify");
var VSCodeConfigProvider = class extends ConfigProvider {
    constructor() {
      super();
      this.config = Lc.workspace.getConfiguration(CopilotConfigPrefix), Lc.workspace.onDidChangeConfiguration(changeEvent => {
        changeEvent.affectsConfiguration(CopilotConfigPrefix) && (this.config = Lc.workspace.getConfiguration(CopilotConfigPrefix));
      });
    }
    static {
      __name(this, "VSCodeConfigProvider");
    }
    getConfigKeyFromObject(key, objectKey) {
      let value = this.config[key][objectKey];
      return value === void 0 ? getConfigDefaultForObjectKey(key, objectKey) : value;
    }
    getConfig(key) {
      if (Array.isArray(key)) return this.getConfigKeyFromObject(key[0], key[1]);
      let value = this.config.get(key);
      if (value === void 0) throw new Error(`Missing config default value: ${CopilotConfigPrefix}.${key}`);
      return value;
    }
    isDefaultSettingOverwritten(key) {
      if (Array.isArray(key)) return this.config[key[0]][key[1]] !== void 0;
      let inspection = this.config.inspect(key);
      return inspection ? !!inspection.globalValue || !!inspection.workspaceValue || !!inspection.workspaceFolderValue || !!inspection.defaultLanguageValue || !!inspection.globalLanguageValue || !!inspection.workspaceLanguageValue || !!inspection.workspaceFolderLanguageValue : !1;
    }
    dumpConfig() {
      let configProperties = {};
      try {
        let extensionConfigProps = packageJson.contributes.configuration[0].properties;
        for (let key in extensionConfigProps) {
          let value = key.replace(`${CopilotConfigPrefix}.`, "").split(".").reduce((o, i) => o[i], this.config);
          typeof value == "object" && value !== null ? Object.keys(value).filter(k => k !== "secret_key").forEach(k => configProperties[`${key}.${k}`] = stringOrStringify(value[k])) : configProperties[key] = stringOrStringify(value);
        }
      } catch (ex) {
        console.error(`Failed to retrieve configuration properties ${ex}`);
      }
      return configProperties;
    }
    getLanguageConfig(key, language) {
      let obj = this.getConfig(key);
      if (language === void 0) {
        let editor = Lc.window.activeTextEditor;
        language = editor && editor.document.languageId;
      }
      return obj?.[language ?? "*"] ?? obj?.["*"];
    }
    updateEnabledConfig(ctx, language, enabled) {
      let updatedConfig = ctx.get(ConfigProvider).getConfig(ConfigKey.Enable);
      return updatedConfig[language] = enabled, this.config.update(ConfigKey.Enable, updatedConfig, !0);
    }
  },
  telemetryAllowedAuthorities = new Set(["ssh-remote", "dev-container", "attached-container", "wsl", "tunnel", "codespaces", "amlext"]),
  VSCodeEditorInfo = class extends EditorAndPluginInfo {
    static {
      __name(this, "VSCodeEditorInfo");
    }
    getEditorInfo() {
      let remoteName = Lc.env.remoteName;
      return {
        name: "vscode",
        version: Lc.version,
        root: Lc.env.appRoot,
        remoteName: remoteName && (telemetryAllowedAuthorities.has(remoteName) ? remoteName : "other")
      };
    }
    getEditorPluginInfo() {
      return {
        name: "copilot",
        version: packageJson.version
      };
    }
  };
async function toggleCopilotEnablement(ctx, scope) {
  let configProvider = ctx.get(ConfigProvider),
    isEnabled = getEnabledConfig(ctx) || !1,
    currentLanguage = Lc.window.activeTextEditor?.document.languageId;
  isEnabled && Lc.commands.executeCommand("editor.action.inlineSuggest.hide"), scope === "global" ? await configProvider.updateEnabledConfig(ctx, "*", !getEnabledConfig(ctx, "*")) : await configProvider.updateEnabledConfig(ctx, currentLanguage || "*", !isEnabled);
}
__name(toggleCopilotEnablement, "toggleCopilotEnablement");
var CMDOpenPanel = "github.copilot.generate",
  CMDOpenPanelForRange = "github.copilot.openPanelForRange",
  CMDAcceptPanelSolution = "github.copilot.acceptPanelSolution",
  CMDToggleCopilot = "github.copilot.toggleCopilot",
  CMDToggleStatusMenu = "github.copilot.toggleStatusMenu",
  CMDSendFeedback = "github.copilot.sendFeedback",
  CMDOpenDocumentation = "github.copilot.openDocs",
  CMDCollectDiagnostics = "github.copilot.collectDiagnostics",
  CMDSignIn = "github.copilot.signIn",
  CMDOpenLogs = "github.copilot.openLogs",
  CMDAcceptCursorPanelSolution = "github.copilot.acceptCursorPanelSolution",
  CMDNavigatePreviousPanelSolution = "github.copilot.previousPanelSolution",
  CMDNavigateNextPanelSolution = "github.copilot.nextPanelSolution",
  CopilotPanelVisible = "github.copilot.panelVisible";
var import_vscode = require("vscode");
var import_vscode = require("vscode");
var solutionsLogger = new Logger(1, "solutions");
async function* prependChoices(choices, prefix) {
  for await (let choice of choices) {
    let choiceCopy = {
      ...choice
    };
    choiceCopy.completionText = prefix + choiceCopy.completionText.trimRight(), yield choiceCopy;
  }
}
__name(prependChoices, "prependChoices");
function normalizeCompletionText(text) {
  return text.replace(/\s+/g, "");
}
__name(normalizeCompletionText, "normalizeCompletionText");
async function launchSolutions(ctx, solutionManager) {
  let insertPosition = solutionManager.completionContext.insertPosition,
    prependToCompletion = solutionManager.completionContext.prependToCompletion,
    indentation = solutionManager.completionContext.indentation,
    locationFactory = ctx.get(LocationFactory),
    document = await solutionManager.getDocument(),
    documentSource = document.getText(),
    positionOffset = document.offsetAt(insertPosition),
    actualSuffix = documentSource.substring(positionOffset),
    promptResponse = await extractPrompt(ctx, document, insertPosition);
  if (promptResponse.type === "copilotNotAvailable") return solutionManager.reportCancelled(), {
    status: "FinishedNormally"
  };
  if (promptResponse.type === "contextTooShort") return solutionManager.reportCancelled(), {
    status: "FinishedWithError",
    error: "Context too short"
  };
  let prompt = promptResponse.prompt,
    trailingWs = promptResponse.trailingWs;
  trailingWs.length > 0 && (solutionManager.startPosition = locationFactory.position(solutionManager.startPosition.line, solutionManager.startPosition.character - trailingWs.length));
  let cancellationToken = solutionManager.getCancellationToken(),
    ourRequestId = v4_default();
  solutionManager.savedTelemetryData = TelemetryData.createAndMarkAsIssued({
    headerRequestId: ourRequestId,
    languageId: document.languageId,
    source: completionTypeToString(solutionManager.completionContext.completionType)
  }, {
    ...telemetrizePromptLength(prompt),
    solutionCount: solutionManager.solutionCountTarget,
    promptEndPos: document.offsetAt(insertPosition)
  }), solutionsLogger.info(ctx, `prompt: ${JSON.stringify(prompt)}`), solutionsLogger.debug(ctx, `prependToCompletion: ${prependToCompletion}`), telemetry(ctx, "solution.requested", solutionManager.savedTelemetryData);
  let blockMode = await ctx.get(BlockModeConfig).forLanguage(ctx, document.languageId),
    isSupportedLanguage = promptLibProxy.isSupportedLanguageId(document.languageId),
    contextIndent = contextIndentation(document, insertPosition),
    postOptions = {
      stream: !0,
      extra: {
        language: document.languageId,
        next_indent: contextIndent.next ?? 0,
        prompt_tokens: prompt.prefixTokens ?? 0,
        suffix_tokens: prompt.suffixTokens ?? 0
      }
    };
  blockMode === "parsing" && !isSupportedLanguage && (postOptions.stop = [`

`, `\r
\r
`]);
  let repoInfo = extractRepoInfoInBackground(ctx, document.uri),
    completionParams = {
      prompt: prompt,
      languageId: document.languageId,
      repoInfo: repoInfo,
      ourRequestId: ourRequestId,
      engineUrl: await getEngineURL(ctx, tryGetGitHubNWO(repoInfo) ?? "", document.languageId, getDogFood(repoInfo), await getUserKind(ctx), await getFtFlag(ctx), await getRagFlag(ctx), solutionManager.savedTelemetryData),
      count: solutionManager.solutionCountTarget,
      uiKind: "synthesize",
      postOptions: postOptions,
      requestLogProbs: !0
    },
    finishedCb;
  switch (blockMode) {
    case "server":
      finishedCb = __name(async text => {}, "finishedCb"), postOptions.extra.force_indent = contextIndent.prev ?? -1, postOptions.extra.trim_by_indentation = !0;
      break;
    case "parsingandserver":
      finishedCb = isSupportedLanguage ? parsingBlockFinished(ctx, document, solutionManager.startPosition) : async text => {}, postOptions.extra.force_indent = contextIndent.prev ?? -1, postOptions.extra.trim_by_indentation = !0;
      break;
    case "parsing":
    default:
      finishedCb = isSupportedLanguage ? parsingBlockFinished(ctx, document, solutionManager.startPosition) : async text => {};
      break;
  }
  ctx.get(StatusReporter).setProgress();
  let res = await ctx.get(OpenAIFetcher).fetchAndStreamCompletions(ctx, completionParams, TelemetryData.createAndMarkAsIssued(), finishedCb, cancellationToken);
  if (res.type === "failed" || res.type === "canceled") return solutionManager.reportCancelled(), ctx.get(StatusReporter).removeProgress(), {
    status: "FinishedWithError",
    error: `${res.type}: ${res.reason}`
  };
  let choices = res.choices;
  choices = prependChoices(choices, prependToCompletion), indentation !== null && (choices = cleanupIndentChoices(choices, indentation)), choices = asyncIterableMapFilter(choices, async choice => postProcessChoice(ctx, "solution", document, insertPosition, choice, !1, solutionsLogger, promptResponse.prompt, actualSuffix));
  let solutions = asyncIterableMapFilter(choices, async apiChoice => {
    let display = apiChoice.completionText;
    if (solutionsLogger.info(ctx, `Open Copilot completion: [${apiChoice.completionText}]`), solutionManager.completionContext.completionType === 2) {
      let displayBefore = "",
        displayStartPos = await getNodeStart(ctx, document, insertPosition, apiChoice.completionText);
      if (displayStartPos) [displayBefore] = trimLastLine(document.getText(locationFactory.range(locationFactory.position(displayStartPos.line, displayStartPos.character), insertPosition)));else {
        let displayStartPos = locationFactory.position(insertPosition.line, 0);
        displayBefore = document.getText(locationFactory.range(displayStartPos, insertPosition));
      }
      display = displayBefore + display;
    }
    let completionText = apiChoice.completionText;
    trailingWs.length > 0 && completionText.startsWith(trailingWs) && (completionText = completionText.substring(trailingWs.length));
    let meanLogProb = apiChoice.meanLogProb,
      meanProb = meanLogProb !== void 0 ? Math.exp(meanLogProb) : 0,
      docVersion = (await solutionManager.getDocument()).version;
    return {
      displayText: display,
      meanProb: meanProb,
      meanLogProb: meanLogProb || 0,
      completionText: completionText,
      requestId: apiChoice.requestId,
      choiceIndex: apiChoice.choiceIndex,
      prependToCompletion: prependToCompletion,
      docVersion: docVersion
    };
  });
  return generateSolutionsStream(ctx.get(StatusReporter), cancellationToken, solutions[Symbol.asyncIterator]());
}
__name(launchSolutions, "launchSolutions");
async function generateSolutionsStream(statusReporter, cancellationToken, solutions) {
  if (cancellationToken.isCancellationRequested) return statusReporter.removeProgress(), {
    status: "FinishedWithError",
    error: "Cancelled"
  };
  let nextResult = await solutions.next();
  return nextResult.done === !0 ? (statusReporter.removeProgress(), {
    status: "FinishedNormally"
  }) : {
    status: "Solution",
    solution: nextResult.value,
    next: generateSolutionsStream(statusReporter, cancellationToken, solutions)
  };
}
__name(generateSolutionsStream, "generateSolutionsStream");
var CopilotListDocument = class _CopilotListDocument {
  constructor(ctx, uri, targetDocument, completionContext, solutionCount, token) {
    this.targetDocument = targetDocument;
    this.completionContext = completionContext;
    this.token = token;
    this._solutionCount = 0;
    this.solutionCountTarget = 0;
    this._solutions = [];
    this._wasCancelled = !1;
    this._updateHandlers = new Set();
    this.savedTelemetryData = TelemetryData.createAndMarkAsIssued();
    this.debouncedEventFire = debounce(10, () => this._updateHandlers.forEach(handler => handler(this._uri)));
    this.onDidResultUpdated = listener => (this._updateHandlers.add(listener), {
      dispose: () => {
        this._updateHandlers.delete(listener);
      }
    });
    this.solutionCountTarget = solutionCount, this._ctx = ctx, this._uri = uri, this._showLogprobs = getConfig(ctx, ConfigKey.DebugShowScores), this.startPosition = this.completionContext.insertPosition;
  }
  static {
    __name(this, "CopilotListDocument");
  }
  static {
    this.separator = `
=======`;
  }
  static {
    this.suggestionHeaderPrefix = "Suggestion ";
  }
  async getDocument() {
    return this.targetDocument;
  }
  get targetUri() {
    return this.targetDocument.uri;
  }
  get numberHeaderLines() {
    return this.header().split(`
`).length + 1;
  }
  header() {
    if (this._wasCancelled) return "No synthesized solutions found.";
    {
      let suffix = this._solutionCount - this._solutions.length > 0 ? " (Duplicates hidden)" : "";
      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${suffix}`;
    }
  }
  areSolutionsDuplicates(solutionA, solutionB) {
    let stripA = normalizeCompletionText(solutionA.completionText),
      stripB = normalizeCompletionText(solutionB.completionText);
    return stripA === stripB;
  }
  insertSorted(list, newItem, keyFn) {
    if (!/^\s*$/.test(newItem.completionText)) {
      for (let i = 0; i < list.length; i++) {
        let item = list[i];
        if (this.areSolutionsDuplicates(item, newItem)) if (keyFn(item) < keyFn(newItem)) {
          list.splice(i, 1);
          break;
        } else return;
      }
      for (let i = 0; i < list.length; i++) {
        let item = list[i];
        if (keyFn(item) < keyFn(newItem)) {
          list.splice(i, 0, newItem);
          return;
        }
      }
      list.push(newItem);
    }
  }
  reportCancelled() {
    this._wasCancelled = !0, this.debouncedEventFire();
  }
  getCancellationToken() {
    return this.token;
  }
  insertSolution(unformatted) {
    let newItem = {
        displayLines: this.formatDisplayLines(unformatted.displayText, unformatted.meanProb, unformatted.meanLogProb),
        completionText: unformatted.completionText,
        meanLogProb: unformatted.meanLogProb,
        meanProb: unformatted.meanProb,
        prependToCompletion: unformatted.prependToCompletion,
        requestId: unformatted.requestId,
        choiceIndex: unformatted.choiceIndex
      },
      keyFn = __name(item => item.meanProb, "keyFn");
    this.insertSorted(this._solutions, newItem, keyFn), this._solutionCount++, this.debouncedEventFire();
  }
  formatDisplayLines(displayText, meanProb, meanLogProb) {
    let optionalPrefix = "";
    return this._showLogprobs && (meanLogProb = meanLogProb || 0, optionalPrefix += `
	# mean prob: ${meanProb}`), `${_CopilotListDocument.separator}${optionalPrefix}
${_CopilotListDocument.suggestionHeaderPrefix}

${displayText}`.split(`
`);
  }
  async runQuery() {
    let firstSolution = await this.launchSolutions();
    this.processNextSolution(firstSolution);
  }
  launchSolutions() {
    return launchSolutions(this._ctx, this);
  }
  async processNextSolution(nextSolution) {
    switch (nextSolution.status) {
      case "FinishedNormally":
      case "FinishedWithError":
        return;
      case "Solution":
        this.insertSolution(nextSolution.solution), this.processNextSolution(await nextSolution.next);
        break;
    }
  }
  solutionsReceived() {
    return this._solutionCount;
  }
  solutions() {
    return this._solutions;
  }
  get value() {
    let solutionsWithItemHeaders = this._solutions.flatMap((solution, index) => {
      let displayLines = solution.displayLines,
        sepIndex = displayLines.findIndex(line => line === _CopilotListDocument.separator.trim());
      if (sepIndex === -1) return displayLines;
      let itemHeader = `Suggestion ${index + 1}`,
        hasHeader = displayLines[sepIndex + 1].startsWith(_CopilotListDocument.suggestionHeaderPrefix);
      return displayLines.splice(sepIndex + 1, hasHeader ? 1 : 0, itemHeader), displayLines;
    });
    return [this.header()].concat(solutionsWithItemHeaders).concat("").join(`
`);
  }
};
var CopilotPanel = class {
  constructor(ctx) {
    this._onDidChange = new T0.EventEmitter();
    this._documents = new Map();
    this.panelSolutions = new Map();
    this._previousPositions = [];
    this._ctx = ctx, this._closeSubscription = T0.workspace.onDidCloseTextDocument(doc => {
      doc.isClosed && doc.uri.scheme == CopilotPanelScheme && (this._documents.delete(doc.uri.toString()), this.panelSolutions.delete(doc.uri.toString()));
    }), this._changeSubscription = T0.window.onDidChangeVisibleTextEditors(editors => {
      editors.some(editor => editor.document.uri.scheme == CopilotPanelScheme) || T0.commands.executeCommand("setContext", CopilotPanelVisible, !1);
    }), this._didChangeEditorSelection = T0.window.onDidChangeTextEditorSelection(event => {
      if (event.textEditor.document.uri.scheme == CopilotPanelScheme) {
        let currentPosition = event.textEditor.selection.active;
        this._previousPositions.push(currentPosition), this._previousPositions.length > 2 && this._previousPositions.shift();
      }
    }), this._didChangeVisibleRanges = T0.window.onDidChangeTextEditorVisibleRanges(event => {
      if (event.textEditor.document.uri.scheme == CopilotPanelScheme) {
        let positionBeforeChange = this._previousPositions[0];
        if (!positionBeforeChange) return;
        this.resetCursorPositionToEndOfFirstLine(positionBeforeChange);
      }
    });
  }
  static {
    __name(this, "CopilotPanel");
  }
  dispose() {
    this._closeSubscription.dispose(), this._changeSubscription.dispose(), this._documents.clear(), this.panelSolutions.clear(), this._onDidChange.dispose(), this._didChangeVisibleRanges.dispose(), this._didChangeEditorSelection.dispose();
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  async provideTextDocumentContent(uri) {
    let document = this._documents.get(uri.toString()),
      model = document?.model;
    if (document && model) return this.getTextDocumentContent(document, uri);
    let cts = new T0.CancellationTokenSource(),
      [targetUri, completionContext] = decodeLocation(this._ctx, uri),
      targetDocument = await T0.workspace.openTextDocument(targetUri);
    return model = new CopilotListDocument(this._ctx, uri, targetDocument, completionContext, getConfig(this._ctx, ConfigKey.ListCount), cts.token), model.onDidResultUpdated(uri => {
      this._onDidChange.fire(uri);
    }), document = {
      model: model,
      cts: cts
    }, this._documents.set(uri.toString(), document), model.runQuery(), this.getTextDocumentContent(document, uri);
  }
  getTextDocumentContent(document, uri) {
    return this.generatePanelSolutionInfo(document, uri), document.model.value;
  }
  generatePanelSolutionInfo(info, uri) {
    let model = info.model,
      lineCount = model.numberHeaderLines,
      insertPosition = model.completionContext.insertPosition,
      separatorLineCount = CopilotListDocument.separator.split(`
`).length - 1,
      panelSolutions = model.solutions().map((solution, index) => {
        let startPos = new T0.Position(lineCount + separatorLineCount - 1, 0),
          endPos = new T0.Position(startPos.line + solution.displayLines.length, 0),
          telemetryData = model.savedTelemetryData.extendedBy({
            choiceIndex: solution.choiceIndex.toString()
          }, {
            compCharLen: solution.completionText.length,
            meanProb: solution.meanProb,
            rank: index
          });
        telemetryData.extendWithRequestId(solution.requestId), telemetryData.markAsDisplayed();
        let postInsertionCallback = __name(async () => {
            let offset = (await T0.workspace.openTextDocument(model.targetUri)).offsetAt(insertPosition);
            info.cts.cancel(), await postInsertionTasks(this._ctx, "solution", solution.completionText, offset, model.targetUri, telemetryData, `${solution.requestId.headerRequestId}-${index}`, insertPosition);
          }, "postInsertionCallback"),
          range = new T0.Range(startPos, endPos);
        return lineCount = endPos.line, {
          targetUri: model.targetUri,
          range: range,
          insertPosition: insertPosition,
          completionText: solution.completionText,
          postInsertionCallback: postInsertionCallback
        };
      });
    return this.panelSolutions.set(uri.toString(), panelSolutions), panelSolutions;
  }
  getCodeLens(info, uri) {
    return (this.panelSolutions.get(uri.toString()) ?? this.generatePanelSolutionInfo(info, uri)).map(solution => new T0.CodeLens(solution.range, {
      title: "Accept Solution",
      tooltip: "Replace code with this solution",
      command: CMDAcceptPanelSolution,
      arguments: [solution.targetUri, solution.insertPosition, solution.completionText, solution.postInsertionCallback]
    }));
  }
  provideCodeLenses(document, token) {
    let doc = this._documents.get(document.uri.toString());
    if (doc) return this.getCodeLens(doc, document.uri);
  }
  resetCursorPositionToEndOfFirstLine(previousPosition) {
    let activeEditor = T0.window.activeTextEditor;
    if (activeEditor === void 0) return;
    let document = activeEditor.document,
      endFirstLinePosition = document.lineAt(0).range.end,
      onSecondLine = !1;
    if (document.lineCount > 1) {
      let endSecondLinePosition = document.lineAt(1).range.end;
      onSecondLine = previousPosition.line == endSecondLinePosition?.line && previousPosition.character == endSecondLinePosition?.character;
    }
    (previousPosition.line == endFirstLinePosition.line && previousPosition.character == endFirstLinePosition.character || onSecondLine) && (activeEditor.selection = new T0.Selection(previousPosition, previousPosition));
  }
};
function completionContextForEditor(ctx, editor, completionContext) {
  return completionContext || completionContextForDocument(ctx, editor.document, editor.selection.active);
}
__name(completionContextForEditor, "completionContextForEditor");
function registerPanelSupport(ctx) {
  registerCommandWithTelemetry(ctx, CMDOpenPanel, () => {
    za.commands.executeCommand("editor.action.inlineSuggest.hide"), commandOpenPanel(ctx);
  }), registerCommandWithTelemetry(ctx, CMDAcceptCursorPanelSolution, () => {
    commandAcceptPanelSolution(ctx);
  }), registerCommandWithTelemetry(ctx, CMDNavigatePreviousPanelSolution, () => {
    commandNavigateToPanelSolution(ctx, "previous");
  }), registerCommandWithTelemetry(ctx, CMDNavigateNextPanelSolution, () => {
    commandNavigateToPanelSolution(ctx, "next");
  }), registerCommandWithTelemetry(ctx, CMDOpenPanelForRange, completionContext => {
    commandOpenPanel(ctx, completionContext);
  }), registerCommandWithTelemetry(ctx, CMDAcceptPanelSolution, async (targetUri, insertPosition, solution, postInsertionCallback) => {
    let edit = new za.WorkspaceEdit();
    edit.insert(targetUri, insertPosition, solution), await za.workspace.applyEdit(edit), postInsertionCallback(), await za.commands.executeCommand("workbench.action.closeActiveEditor");
  });
  let contentProvider = new CopilotPanel(ctx);
  ctx.get(Extension).register(za.workspace.registerTextDocumentContentProvider(CopilotPanelScheme, contentProvider), za.languages.registerCodeLensProvider({
    scheme: CopilotPanelScheme
  }, contentProvider)), ctx.set(CopilotPanel, contentProvider);
}
__name(registerPanelSupport, "registerPanelSupport");
function commandOpenPanel(ctx, completionContext) {
  let editor = za.window.activeTextEditor;
  if (!editor) return;
  if (!za.workspace.getConfiguration("editor", editor.document.uri).get("codeLens")) {
    za.window.showInformationMessage("GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.", "Open Settings").then(selection => {
      selection === "Open Settings" && za.commands.executeCommand("workbench.action.openSettings", "editor.codeLens");
    });
    return;
  }
  completionContext = completionContextForEditor(ctx, editor, completionContext);
  let uri = encodeLocation(editor.document.uri, completionContext),
    languageId = editor.document.languageId;
  za.workspace.openTextDocument(uri).then(doc => {
    za.languages.setTextDocumentLanguage(doc, languageId), za.window.showTextDocument(doc, za.ViewColumn.Beside), za.commands.executeCommand("setContext", CopilotPanelVisible, !0);
  });
}
__name(commandOpenPanel, "commandOpenPanel");
function shouldExecutePanelCommand(ctx) {
  let editor = za.window.activeTextEditor;
  if (!editor) return !1;
  let document = editor.document;
  if (!document.uri.scheme.startsWith(CopilotPanelScheme)) return !1;
  let solutions = ctx.get(CopilotPanel).panelSolutions.get(document.uri.toString());
  return !(!solutions || solutions?.length === 0);
}
__name(shouldExecutePanelCommand, "shouldExecutePanelCommand");
function commandAcceptPanelSolution(ctx) {
  if (!shouldExecutePanelCommand(ctx)) return;
  let editor = za.window.activeTextEditor,
    solutions = ctx.get(CopilotPanel).panelSolutions.get(editor.document.uri.toString()) ?? [],
    cursorPosition = editor.selection.active,
    chosenSolution = solutions.find(solution => solution.range.contains(cursorPosition));
  chosenSolution && za.commands.executeCommand(CMDAcceptPanelSolution, chosenSolution.targetUri, chosenSolution.insertPosition, chosenSolution.completionText, chosenSolution.postInsertionCallback);
}
__name(commandAcceptPanelSolution, "commandAcceptPanelSolution");
function commandNavigateToPanelSolution(ctx, navigationType) {
  if (!shouldExecutePanelCommand(ctx)) return;
  let editor = za.window.activeTextEditor,
    solutions = ctx.get(CopilotPanel).panelSolutions.get(editor.document.uri.toString()) ?? [],
    cursorPosition = editor.selection.active,
    chosenSolution = findPrevNextSolution(solutions, cursorPosition, navigationType),
    headerLine = chosenSolution.range.start.line + 1,
    {
      text: text
    } = editor.document.lineAt(headerLine);
  editor.selection = new za.Selection(new za.Position(headerLine, 0), new za.Position(headerLine, text.length)), editor.revealRange(chosenSolution.range);
}
__name(commandNavigateToPanelSolution, "commandNavigateToPanelSolution");
function findPrevNextSolution(solutions, cursorPosition, navigationType) {
  let navPrevious = navigationType === "previous",
    currentSolutionIndex = solutions.findIndex(solution => solution.range.contains(cursorPosition)),
    prevNextSolutionIndex = navPrevious ? currentSolutionIndex - 1 : currentSolutionIndex + 1;
  return currentSolutionIndex === -1 && (prevNextSolutionIndex = navPrevious ? -1 : 0), solutions.at(prevNextSolutionIndex) ?? solutions[0];
}
__name(findPrevNextSolution, "findPrevNextSolution");
var import_vscode = require("vscode");
var os = Ns(require("os")),
  tls = Ns(require("tls"));
async function collectDiagnostics(ctx) {
  return {
    sections: [collectCopilotSection(ctx), collectEnvironmentSection(), await collectFeatureFlagsSection(ctx), collectNodeSection(), collectNetworkConfigSection(ctx), await collectReachabilitySection(ctx)]
  };
}
__name(collectDiagnostics, "collectDiagnostics");
function formatDiagnosticsAsMarkdown(data) {
  return data.sections.map(formatSectionAsMarkdown).join(Hu.EOL + Hu.EOL);
}
__name(formatDiagnosticsAsMarkdown, "formatDiagnosticsAsMarkdown");
function collectCopilotSection(ctx) {
  return {
    name: "Copilot",
    items: {
      Version: getVersion(ctx),
      Build: getBuildType(ctx),
      Editor: editorVersionHeaders(ctx)["Editor-Version"]
    }
  };
}
__name(collectCopilotSection, "collectCopilotSection");
function collectEnvironmentSection() {
  return {
    name: "Environment",
    items: {
      http_proxy: findEnvironmentVariable("http_proxy"),
      https_proxy: findEnvironmentVariable("https_proxy"),
      no_proxy: findEnvironmentVariable("no_proxy"),
      SSL_CERT_FILE: findEnvironmentVariable("SSL_CERT_FILE"),
      SSL_CERT_DIR: findEnvironmentVariable("SSL_CERT_DIR"),
      OPENSSL_CONF: findEnvironmentVariable("OPENSSL_CONF")
    }
  };
}
__name(collectEnvironmentSection, "collectEnvironmentSection");
function collectNodeSection() {
  return {
    name: "Node setup",
    items: {
      "Number of root certificates": b3.rootCertificates.length,
      "Operating system": Hu.type(),
      "Operating system version": Hu.release(),
      "Operating system architecture": Hu.arch(),
      NODE_OPTIONS: findEnvironmentVariable("NODE_OPTIONS"),
      NODE_EXTRA_CA_CERTS: findEnvironmentVariable("NODE_EXTRA_CA_CERTS"),
      NODE_TLS_REJECT_UNAUTHORIZED: findEnvironmentVariable("NODE_TLS_REJECT_UNAUTHORIZED"),
      "tls default min version": b3.DEFAULT_MIN_VERSION,
      "tls default max version": b3.DEFAULT_MAX_VERSION
    }
  };
}
__name(collectNodeSection, "collectNodeSection");
async function collectFeatureFlagsSection(ctx) {
  let ssc = "",
    rt = "";
  try {
    let token = await ctx.get(CopilotTokenManager).getCopilotToken(ctx);
    ssc = token.getTokenValue("ssc") === "1" ? "enabled" : "disabled", rt = token.getTokenValue("rt") === "1" ? "enabled" : "disabled";
  } catch {
    ssc = rt = "unable to determine";
  }
  return {
    name: "Feature Flags",
    items: {
      "Custom Certificates": ssc,
      "Send Restricted Telemetry": rt
    }
  };
}
__name(collectFeatureFlagsSection, "collectFeatureFlagsSection");
function collectNetworkConfigSection(ctx) {
  let fetcher = ctx.get(Fetcher);
  return {
    name: "Network Configuration",
    items: {
      "Proxy host": fetcher.proxySettings?.host,
      "Proxy port": fetcher.proxySettings?.port,
      "Proxy auth": fetcher.proxySettings?.proxyAuth,
      "Kerberos SPN": fetcher.proxySettings?.kerberosServicePrincipal,
      "Reject unauthorized": fetcher.rejectUnauthorized ? "enabled" : "disabled"
    }
  };
}
__name(collectNetworkConfigSection, "collectNetworkConfigSection");
async function collectReachabilitySection(ctx) {
  return {
    name: "Reachability",
    items: {
      "github.com": await determineReachability(ctx, "https://github.com"),
      "copilot-proxy.githubusercontent.com": await determineReachability(ctx, "https://copilot-proxy.githubusercontent.com/_ping"),
      "default.exp-tas.com": await determineReachability(ctx, "https://default.exp-tas.com/vscode/ab")
    }
  };
}
__name(collectReachabilitySection, "collectReachabilitySection");
async function determineReachability(ctx, url) {
  try {
    let response = await ctx.get(Fetcher).fetch(url, {});
    return `HTTP ${response.status} - ${response.statusText}`;
  } catch (err) {
    return err.message;
  }
}
__name(determineReachability, "determineReachability");
function findEnvironmentVariable(name) {
  let key = Object.keys(process.env).find(k => k.toLowerCase() === name.toLowerCase());
  return key ? process.env[key] : void 0;
}
__name(findEnvironmentVariable, "findEnvironmentVariable");
function formatSectionAsMarkdown(s) {
  return `## ${s.name}` + Hu.EOL + Hu.EOL + Object.keys(s.items).filter(k => k !== "name").map(k => `- ${k}: ${s.items[k] ?? "n/a"}`).join(Hu.EOL);
}
__name(formatSectionAsMarkdown, "formatSectionAsMarkdown");
async function openDiagnosticReport(ctx) {
  let installationCheck = __name(name => wh.extensions.getExtension(name) !== void 0, "installationCheck"),
    reportData = await new DiagnosticReport(installationCheck).collectData(ctx),
    report = formatDiagnosticsAsMarkdown(reportData),
    doc = await wh.workspace.openTextDocument({
      language: "markdown",
      content: report
    });
  await wh.window.showTextDocument(doc);
}
__name(openDiagnosticReport, "openDiagnosticReport");
var DiagnosticReport = class {
  static {
    __name(this, "DiagnosticReport");
  }
  constructor(installationCheck) {
    this.isExtensionInstalled = installationCheck;
  }
  async collectData(ctx) {
    return {
      sections: [...(await collectDiagnostics(ctx)).sections, this.collectConfigurationSection(), this.collectExtensionSection(ctx)]
    };
  }
  collectConfigurationSection() {
    return {
      name: "VS Code Configuration",
      items: {
        "HTTP proxy": this.findVsCodeConfiguration("http", "proxy"),
        "HTTP proxy autentication": this.findVsCodeConfiguration("http", "proxyAuthorization"),
        "Proxy Strict SSL": this.findVsCodeConfiguration("http", "proxyStrictSSL"),
        "Extension HTTP proxy support": this.findVsCodeConfiguration("http", "proxySupport")
      }
    };
  }
  collectExtensionSection(ctx) {
    return {
      name: "Extensions",
      items: {
        "Is `win-ca` installed?": this.isExtensionInstalled("ukoloff.win-ca"),
        "Is `mac-ca` installed?": this.isExtensionInstalled("linhmtran168.mac-ca-vscode")
      }
    };
  }
  findVsCodeConfiguration(section, name) {
    return wh.workspace.getConfiguration(section).get(name);
  }
};
var vscode = Ns(require("vscode"));
var VSCodeEditorExperimentFilters = class extends EditorExperimentFilters {
  static {
    __name(this, "VSCodeEditorExperimentFilters");
  }
  addEditorSpecificFilters() {
    return {
      "X-VSCode-Build": DD.env.appName,
      "X-VSCode-Language": DD.env.language
    };
  }
};
var CopilotExtensionStatus = class {
  constructor(status = "Normal", errorMessage) {
    this.status = status;
    this.errorMessage = errorMessage;
  }
  static {
    __name(this, "CopilotExtensionStatus");
  }
};
var import_vscode = require("vscode");
var import_copilot_promptlib = Ns(Dc());
function fakeAPIChoice(headerRequestId, choiceIndex, completionText, telemetryData = TelemetryData.createAndMarkAsIssued()) {
  let tokenizer = (0, j0e.getTokenizer)();
  return {
    completionText: completionText,
    meanLogProb: .5,
    meanAlternativeLogProb: .5,
    modelInfo: void 0,
    numTokens: -1,
    choiceIndex: choiceIndex,
    requestId: {
      headerRequestId: headerRequestId,
      completionId: v4_default(),
      created: 0,
      serverExperiments: "dummy",
      deploymentId: "dummy"
    },
    telemetryData: telemetryData,
    tokens: tokenizer.tokenize(completionText).map(token => tokenizer.detokenize([token])).concat()
  };
}
__name(fakeAPIChoice, "fakeAPIChoice");
async function* fakeAPIChoices(postOptions, finishedCb, completions, telemetryData) {
  let fakeHeaderRequestId = v4_default(),
    choiceIndex = 0;
  for (let completion of completions) {
    let stopOffset = -1;
    if (postOptions?.stop !== void 0) for (let stopToken of postOptions.stop) {
      let thisStopOffset = completion.indexOf(stopToken);
      thisStopOffset !== -1 && (stopOffset === -1 || thisStopOffset < stopOffset) && (stopOffset = thisStopOffset);
    }
    stopOffset !== -1 && (completion = completion.substring(0, stopOffset));
    let finishOffset = await finishedCb(completion);
    finishOffset !== void 0 && (completion = completion.substring(0, finishOffset));
    let choice = fakeAPIChoice(fakeHeaderRequestId, choiceIndex++, completion, telemetryData);
    choice.blockFinished = finishOffset !== void 0, yield choice;
  }
}
__name(fakeAPIChoices, "fakeAPIChoices");
function fakeResponse(completions, finishedCb, postOptions, allowEmptyChoices, telemetryData) {
  return {
    type: "success",
    choices: postProcessChoices(fakeAPIChoices(postOptions, finishedCb, completions, telemetryData), allowEmptyChoices),
    getProcessingTime: () => 0
  };
}
__name(fakeResponse, "fakeResponse");
var SyntheticCompletions = class extends OpenAIFetcher {
  constructor(_completions) {
    super();
    this._completions = _completions;
    this._wasCalled = !1;
  }
  static {
    __name(this, "SyntheticCompletions");
  }
  async fetchAndStreamCompletions(ctx, params, baseTelemetryData, finishedCb, cancel, teletryProperties, allowEmptyChoices) {
    if (ctx.get(CopilotTokenManager).getCopilotToken(ctx), cancel?.isCancellationRequested) return {
      type: "canceled",
      reason: "canceled during test"
    };
    if (this._wasCalled) {
      let emptyCompletions = this._completions.map(completion => "");
      return fakeResponse(emptyCompletions, finishedCb, params.postOptions, allowEmptyChoices, baseTelemetryData);
    } else return this._wasCalled = !0, fakeResponse(this._completions, finishedCb, params.postOptions, allowEmptyChoices, baseTelemetryData);
  }
};
var FixedBlockModeConfig = class extends BlockModeConfig {
  constructor(blockMode) {
    super();
    this.blockMode = blockMode;
  }
  static {
    __name(this, "FixedBlockModeConfig");
  }
  async forLanguage(ctx, languageId) {
    return this.blockMode;
  }
};
var CopilotExtensionApi = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "CopilotExtensionApi");
  }
  captureExtensionTelemetry(work) {
    return withInlineTelemetryCapture(this.ctx, work);
  }
  setupNextCompletion(completions) {
    this.clearCompletionsCache(), this.ctx.forceSet(OpenAIFetcher, new SyntheticCompletions(completions)), this.ctx.forceSet(BlockModeConfig, new FixedBlockModeConfig("parsing"));
  }
  clearCompletionsCache() {
    this.ctx.get(CompletionsCache).clear(), clearUserTypingState();
  }
};
var import_copilot_promptlib = Ns(Dc()),
  import_vscode = require("vscode");
var ExtensionFileSystem = class extends H0e.FileSystem {
    static {
      __name(this, "ExtensionFileSystem");
    }
    async readFile(uri) {
      return await E3.workspace.fs.readFile(E3.Uri.file(uri));
    }
    async stat(uri) {
      return await E3.workspace.fs.stat(E3.Uri.file(uri));
    }
  },
  extensionFileSystem = new ExtensionFileSystem();
var import_semver = Ns(XS());
var InstallationManager = class {
  static {
    __name(this, "InstallationManager");
  }
  async startup(ctx) {
    (await this.isNewInstall(ctx)) ? (await this.handleInstall(ctx, await this.wasPreviouslyInstalled(ctx)), await this.markInstalled(ctx)) : (await this.isNewUpgrade(ctx)) && (await this.handleUpgrade(ctx), await this.markUpgraded(ctx));
  }
  async uninstall(ctx) {
    return await this.handleUninstall(ctx);
  }
  async handleInstall(ctx, previouslyInstalled) {
    previouslyInstalled ? telemetry(ctx, "installed.reinstall") : telemetry(ctx, "installed.new");
  }
  async handleUpgrade(ctx) {
    telemetry(ctx, "installed.upgrade");
  }
  async handleUninstall(ctx) {
    telemetry(ctx, "uninstalled");
  }
};
var VsCodeInstallationManager = class extends InstallationManager {
  static {
    __name(this, "VsCodeInstallationManager");
  }
  async isNewInstall(ctx) {
    return !ctx.get(Extension).context.globalState.get("installedVersion") && !(await hasExistingSession());
  }
  async markInstalled(ctx) {
    let info = ctx.get(EditorAndPluginInfo).getEditorPluginInfo();
    ctx.get(Extension).context.globalState.update("installedVersion", info.version);
  }
  async wasPreviouslyInstalled(ctx) {
    return !1;
  }
  async isNewUpgrade(ctx) {
    let current = ctx.get(EditorAndPluginInfo).getEditorPluginInfo(),
      last = ctx.get(Extension).context.globalState.get("installedVersion");
    if (last === void 0) return !0;
    try {
      return (0, py.gt)((0, py.coerce)(current.version), (0, py.coerce)(last));
    } catch {
      return !1;
    }
  }
  async markUpgraded(ctx) {
    await this.markInstalled(ctx);
  }
};
var import_vscode = require("vscode");
var EnterpriseConfigPrefix = "github-enterprise",
  DotComUrl = "https://github.com";
function configuredBaseUrl() {
  return BD.workspace.getConfiguration(CopilotConfigPrefix).get("advanced")?.authProvider === "github-enterprise" ? BD.workspace.getConfiguration(EnterpriseConfigPrefix).get("uri") ?? DotComUrl : DotComUrl;
}
__name(configuredBaseUrl, "configuredBaseUrl");
var VSCodeNetworkConfiguration = class extends DefaultNetworkConfiguration {
  static {
    __name(this, "VSCodeNetworkConfiguration");
  }
  constructor() {
    super(configuredBaseUrl(), {});
  }
  updateBaseUrl(ctx, newUrl) {
    super.updateBaseUrl(ctx, configuredBaseUrl());
  }
};
function onDidChangeConfigurationHandler(event, ctx) {
  (event.affectsConfiguration(`${CopilotConfigPrefix}.advanced`) || event.affectsConfiguration(`${EnterpriseConfigPrefix}.uri`)) && ctx.get(NetworkConfiguration).updateBaseUrl(ctx);
}
__name(onDidChangeConfigurationHandler, "onDidChangeConfigurationHandler");
var import_vscode = require("vscode");
var import_net = require("net");
function getProxyFromEnvironment(env) {
  return env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy;
}
__name(getProxyFromEnvironment, "getProxyFromEnvironment");
function proxySettingFromUrl(proxyUrl) {
  (0, K0e.isIPv6)(proxyUrl) ? proxyUrl = "https://[" + proxyUrl + "]" : /:\/\//.test(proxyUrl) || (proxyUrl = `https://${proxyUrl}`);
  let {
    hostname: hostname,
    port: port,
    username: username,
    password: password
  } = new URL(proxyUrl);
  return {
    host: hostname,
    port: parsePort(port),
    proxyAuth: getAuth(username, password),
    headers: {}
  };
}
__name(proxySettingFromUrl, "proxySettingFromUrl");
function parsePort(port) {
  if (!port) return 80;
  let portNumber = Number(port);
  if (isNaN(portNumber)) throw new TypeError("Invalid proxy port");
  return portNumber;
}
__name(parsePort, "parsePort");
function getAuth(username, password) {
  return !username || !password ? "" : `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
}
__name(getAuth, "getAuth");
function initProxyEnvironment(fetcher, env) {
  C3.workspace.onDidChangeConfiguration(event => {
    let hasProxyUrlChanged = event.affectsConfiguration("http.proxy");
    (event.affectsConfiguration("http.proxyStrictSSL") || event.affectsConfiguration("http.proxyAuthorization") || event.affectsConfiguration("http.proxyKerberosServicePrincipal") || hasProxyUrlChanged) && updateProxyEnvironment(fetcher, env, hasProxyUrlChanged);
  }), updateProxyEnvironment(fetcher, env);
}
__name(initProxyEnvironment, "initProxyEnvironment");
var updateProxyEnvironment = __name((fetcher, env, hasProxyUrlChanged) => {
  let proxyUrl = C3.workspace.getConfiguration("http").get("proxy") || getProxyFromEnvironment(env);
  if (proxyUrl) {
    let proxyAuthorization = C3.workspace.getConfiguration("http").get("proxyAuthorization"),
      proxyStrictSSL = C3.workspace.getConfiguration("http").get("proxyStrictSSL", !0),
      proxySettings = proxySettingFromUrl(proxyUrl);
    proxyAuthorization && (proxySettings.headers["Proxy-Authorization"] = proxyAuthorization);
    let spn = C3.workspace.getConfiguration("http").get("proxyKerberosServicePrincipal");
    spn && (proxySettings.kerberosServicePrincipal = spn), fetcher.proxySettings = proxySettings, fetcher.rejectUnauthorized = proxyStrictSSL;
  } else hasProxyUrlChanged && !proxyUrl && (fetcher.proxySettings = void 0);
}, "updateProxyEnvironment");
var import_vscode = require("vscode");
var CopilotStatusBar = class extends StatusReporter {
  constructor(ctx, outputChannel) {
    super();
    this.ctx = ctx;
    this.outputChannel = outputChannel;
    this.showingMessage = !1;
    this.delayedUpdateDisplay = debounce(100, () => {
      this.updateStatusBarIndicator();
    });
    this.item = ld.window.createStatusBarItem("status", ld.StatusBarAlignment.Right, 1), this.item.name = "Copilot Status", this.state = ctx.get(CopilotExtensionStatus), this.updateStatusBarIndicator(), this.item.show(), ld.window.onDidChangeActiveTextEditor(() => {
      this.updateStatusBarIndicator();
    }), ld.workspace.onDidCloseTextDocument(() => {
      !ld.window.activeTextEditor && this.state.status === "Inactive" && (this.state.status = "Normal"), this.updateStatusBarIndicator();
    }), ld.workspace.onDidOpenTextDocument(() => {
      this.updateStatusBarIndicator();
    });
  }
  static {
    __name(this, "CopilotStatusBar");
  }
  checkEnabledForLanguage() {
    return getEnabledConfig(this.ctx) || !1;
  }
  updateStatusBarIndicator() {
    switch (this.state.status) {
      case "Error":
        this.item.text = "$(copilot-notconnected)", this.item.command = CMDToggleStatusMenu, this.item.tooltip = "Copilot error (click for details)";
        break;
      case "Warning":
        this.item.text = "$(copilot-warning)", this.item.command = this.state.errorMessage ? CMDToggleStatusMenu : void 0, this.item.tooltip = "Copilot is encountering temporary issues (click for details)";
        break;
      case "InProgress":
        this.item.text = "$(loading~spin)";
        break;
      case "Inactive":
        this.item.text = "$(copilot-notconnected)", this.item.tooltip = this.state.errorMessage || "Copilot is currently inactive";
        break;
      case "Normal":
        this.item.text = this.checkEnabledForLanguage() ? "$(copilot-logo)" : "$(copilot-notconnected)", this.item.command = CMDToggleStatusMenu, this.item.tooltip = "Show Copilot status menu";
    }
  }
  getStatusBarItem() {
    return this.item;
  }
  setProgress() {
    this.state.status !== "Error" && (this.state.status = "InProgress", this.delayedUpdateDisplay());
  }
  removeProgress() {
    this.state.status !== "Error" && this.state.status !== "Warning" && (this.state.status = "Normal", this.delayedUpdateDisplay());
  }
  setWarning(warningMessage) {
    this.state.status !== "Error" && (this.state.status = "Warning", warningMessage && (this.state.errorMessage = warningMessage), this.updateStatusBarIndicator());
  }
  setError(errorMessage, errorRetry) {
    this.state.status = "Error", this.state.errorMessage = errorMessage, this.errorRetry = errorRetry, this.updateStatusBarIndicator(), this.showErrorMessage();
  }
  setInactive(message) {
    this.state.status = "Inactive", this.state.errorMessage = message || "", this.errorRetry = void 0, this.updateStatusBarIndicator();
  }
  forceNormal() {
    this.state.status = "Normal", this.state.errorMessage = "", this.errorRetry = void 0, this.updateStatusBarIndicator();
  }
  showErrorMessage() {
    if (this.showingMessage) return;
    this.showingMessage = !0;
    let showOutputOption = "Show Output Log",
      options = [showOutputOption];
    this.errorRetry && options.push("Retry"), ld.window.showWarningMessage(this.state.errorMessage, ...options).then(res => {
      this.showingMessage = !1, res === showOutputOption && this.outputChannel.show(), res === "Retry" && this.errorRetry && this.errorRetry();
    });
  }
};
var import_vscode = require("vscode");
var CopilotStatusBarPickMenu = class {
    constructor(ctx, afterCommandCallback) {
      this.ctx = ctx;
      this.afterCommandCallback = afterCommandCallback;
      this.state = ctx.get(CopilotExtensionStatus);
    }
    static {
      __name(this, "CopilotStatusBarPickMenu");
    }
    showStatusMenu() {
      let quickpickList = Ih.window.createQuickPick();
      return quickpickList.items = this.collectQuickPickItems(), quickpickList.onDidAccept(() => {
        this.handleItemSelection(quickpickList);
      }), quickpickList.show(), quickpickList;
    }
    async handleItemSelection(quickpickList) {
      return new Promise((resolve, reject) => {
        let selection = quickpickList.selectedItems[0];
        if (selection !== void 0) if ("command" in selection) {
          let commandSelection = selection;
          Ih.commands.executeCommand(commandSelection.command, ...commandSelection.commandArgs).then(() => {
            this.afterCommandCallback(), quickpickList.hide(), resolve();
          });
        } else reject("Unexpected selection");
      });
    }
    collectQuickPickItems() {
      return this.state.status == "Normal" || this.state.status == "InProgress" ? [this.newStatusItem(), this.newSeparator(), this.newChatItem(), this.newSeparator(), ...this.collectLanguageSpecificItems(), this.newSeparator(), this.newKeyboardItem(), this.newSettingsItem(), this.newDiagnosticsItem(), this.newOpenLogsItem(), this.newSeparator(), this.newDocsItem(), this.newForumItem()] : [this.newStatusItem(), this.newSeparator(), this.newSettingsItem(), this.newDiagnosticsItem(), this.newOpenLogsItem(), this.newSeparator(), this.newDocsItem(), this.newForumItem(), this.newSeparator(), this.newSignInItem()];
    }
    collectLanguageSpecificItems() {
      let currentLanguage = Ih.window.activeTextEditor?.document.languageId;
      return currentLanguage ? [this.newPanelItem(), this.newGlobalEnablementItem(), ...this.newEnableLanguageItem(currentLanguage)] : [this.newGlobalEnablementItem()];
    }
    newEnableLanguageItem(currentLanguage) {
      let isEnabled = getEnabledConfig(this.ctx);
      if (isEnabled === void 0) return [];
      let enablementLabelPrefix = isEnabled ? "Disable" : "Enable";
      return [this.newCommandItem(enablementLabelPrefix + " Completions for '" + currentLanguage + "'", CMDToggleCopilot, [currentLanguage])];
    }
    newGlobalEnablementItem() {
      let prefix = getEnabledConfig(this.ctx, "*") ? "Disable" : "Enable";
      return this.newCommandItem(prefix + " Completions", CMDToggleCopilot);
    }
    newStatusItem() {
      let statusText;
      return this.state.status == "Normal" || this.state.status == "InProgress" ? (statusText = "Ready", getEnabledConfig(this.ctx) || (statusText += " (Disabled)")) : statusText = this.state.errorMessage || "Copilot is currently inactive", this.newCommandItem("$(copilot-logo) Status: " + statusText, CMDOpenLogs);
    }
    newSignInItem() {
      return this.newCommandItem("Sign in to GitHub", CMDSignIn);
    }
    newOpenLogsItem() {
      return this.newCommandItem("Open Logs...", CMDOpenLogs);
    }
    newDiagnosticsItem() {
      return this.newCommandItem("Show Diagnostics...", CMDCollectDiagnostics);
    }
    newKeyboardItem() {
      return this.newCommandItem("$(keyboard) Edit Keyboard Shortcuts...", "workbench.action.openGlobalKeybindings", ["copilot"]);
    }
    newChatItem() {
      return this.newCommandItem("$(copilot-chat) GitHub Copilot Chat", "workbench.panel.chat.view.copilot.focus");
    }
    newSettingsItem() {
      return this.newCommandItem("$(settings-gear) Edit Settings...", "workbench.action.openSettings", ["GitHub Copilot"]);
    }
    newPanelItem() {
      return this.newCommandItem("Open Completions Panel...", CMDOpenPanel);
    }
    newForumItem() {
      return this.newCommandItem("$(comments-view-icon) View Copilot Forum...", CMDSendFeedback);
    }
    newDocsItem() {
      return this.newCommandItem("$(remote-explorer-documentation) View Copilot Documentation...", CMDOpenDocumentation);
    }
    newCommandItem(label, command, commandArgs) {
      return new CommandQuickItem(label, command, commandArgs || []);
    }
    newSeparator() {
      return {
        label: "",
        kind: Ih.QuickPickItemKind.Separator
      };
    }
  },
  CommandQuickItem = class {
    constructor(label, command, commandArgs) {
      this.label = label;
      this.command = command;
      this.commandArgs = commandArgs;
    }
    static {
      __name(this, "CommandQuickItem");
    }
  };
var import_copilot_promptlib = Ns(Dc()),
  vscode = Ns(require("vscode")),
  import_vscode = require("vscode");
var ExtensionSymbolDefinitionProvider = class extends SymbolDefinitionProvider {
  static {
    __name(this, "ExtensionSymbolDefinitionProvider");
  }
  async getSymbolDefinition(docInfo) {
    let location = {
        line: docInfo.position.line,
        character: docInfo.position.character,
        uri: T3.Uri.parse(docInfo.uri)
      },
      [signature, semantics] = await this.getHoverTextAndDecompose(location);
    return signature === "" ? [] : [{
      snippet: signature,
      score: 1,
      startLine: location.line,
      endLine: location.line,
      semantics: semantics,
      provider: pc.SnippetProviderType.SymbolDef
    }];
  }
  async getHoverTextAndDecompose(uriLineCol) {
    let hoverText = await T3.commands.executeCommand("vscode.executeHoverProvider", uriLineCol.uri, new J0e.Position(uriLineCol.line, uriLineCol.character));
    return hoverText[0] && hoverText[0].contents[0] instanceof T3.MarkdownString ? decomposeHoverText(hoverText[0].contents[0].value) : ["", pc.SnippetSemantics.Snippet];
  }
};
function decomposeHoverText(hoverText) {
  let regex = /```\w+\n(class|\(\w+\))\s([^`]*)```.*/m,
    match = hoverText.match(regex);
  if (match != null) {
    let codeTypeString = match[1],
      semantics = getSemantics(codeTypeString);
    return [match[2].trim(), semantics];
  } else return ["", pc.SnippetSemantics.Snippet];
}
__name(decomposeHoverText, "decomposeHoverText");
function getSemantics(codeTypeString) {
  switch (codeTypeString = codeTypeString.replace("(", "").replace(")", ""), codeTypeString) {
    case "function":
      return pc.SnippetSemantics.Function;
    case "variable":
      return pc.SnippetSemantics.Variable;
    case "parameter":
      return pc.SnippetSemantics.Parameter;
    case "method":
      return pc.SnippetSemantics.Method;
    case "class":
      return pc.SnippetSemantics.Class;
    case "module":
      return pc.SnippetSemantics.Module;
    case "alias":
      return pc.SnippetSemantics.Alias;
    case "enum":
      return pc.SnippetSemantics.Enum;
    case "interface":
      return pc.SnippetSemantics.Interface;
    default:
      return pc.SnippetSemantics.Snippet;
  }
}
__name(getSemantics, "getSemantics");
function escapeForRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeForRegExp, "escapeForRegExp");
var rootDirRegExp = new RegExp(escapeForRegExp(__dirname.replace(/[\\/]extension[\\/]src$|[\\/]dist$/, "")) + `[\\\\/]?([^:)'"\\s]*)`, "gi"),
  irrelevantStackPaths = new Set(["node_modules/diagnostic-channel/dist/src/patchRequire.js"]),
  TelemetryDelegator = class {
    constructor(handler) {
      this.handler = handler;
    }
    static {
      __name(this, "TelemetryDelegator");
    }
    sendEventData() {}
    sendErrorData(error) {
      let relevant = !1;
      for (let match of (error.stack ?? "").matchAll(rootDirRegExp)) if (!irrelevantStackPaths.has(match[1].replace(/\\/g, "/"))) {
        relevant = !0;
        break;
      }
      relevant && this.handler(error);
    }
  };
var import_vscode = require("vscode");
var ExtensionLocationFactory = class extends LocationFactory {
  static {
    __name(this, "ExtensionLocationFactory");
  }
  range(x1, y1, x2, y2) {
    return x2 !== void 0 && y2 !== void 0 ? new my.Range(x1, y1, x2, y2) : new my.Range(x1, y1);
  }
  position(line, character) {
    return new my.Position(line, character);
  }
};
var import_vscode = require("vscode");
var ExtensionTextDocumentManager = class extends TextDocumentManager {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.onDidFocusTextDocument = ap.window.onDidChangeActiveTextEditor;
    this.onDidChangeTextDocument = ap.workspace.onDidChangeTextDocument;
    this.onDidChangeCursor = ap.window.onDidChangeTextEditorSelection;
  }
  static {
    __name(this, "ExtensionTextDocumentManager");
  }
  async textDocuments() {
    let documents = ap.workspace.textDocuments,
      filteredDocuments = [];
    for (let doc of documents) (await isDocumentValid(this.ctx, doc)).status === "valid" && filteredDocuments.push(doc);
    return filteredDocuments;
  }
  async getTextDocumentWithValidation(uri) {
    try {
      let doc = await ap.workspace.openTextDocument(uri);
      return isDocumentValid(this.ctx, doc);
    } catch {
      return {
        status: "notfound",
        message: `Document for URI could not be found: ${uri}`
      };
    }
  }
  async getTextDocument(uri) {
    let result = await this.getTextDocumentWithValidation(uri);
    if (result.status === "valid") return result.document;
  }
  findNotebook(doc) {
    return ap.workspace.notebookDocuments.find(notebook => notebook.getCells().some(cell => cell.document.uri.toString() === doc.uri.toString()));
  }
  getWorkspaceFolders() {
    return ap.workspace.workspaceFolders?.map(f => f.uri) ?? [];
  }
};
var path = Ns(require("path")),
  vscode = Ns(require("vscode"));
var import_vscode = require("vscode");
var ExtensionCommitFileResolver = class extends CommitFileResolver {
  static {
    __name(this, "ExtensionCommitFileResolver");
  }
  async getCoCommitResult(targetURI, maxFiles) {
    if (targetURI.scheme !== "file") return [];
    let targetPath = targetURI.fsPath,
      gitExtension = ele.extensions.getExtension("vscode.git");
    if (gitExtension === void 0) return [];
    let api = gitExtension.exports.getAPI(1);
    if (api === void 0) return [];
    if (api.repositories.length === 0) return [];
    let repos = api.repositories,
      touchedFiles = [],
      visited = new Set(),
      deleteStatus = new Set([6, 12, 13, 2, 15]);
    visited.add(targetPath);
    let logOption = {
      path: targetPath
    };
    for (let repo of repos) {
      let relative = eT.relative(repo.rootUri.fsPath, targetPath);
      if (!(relative && !relative.startsWith("..") && !eT.isAbsolute(relative))) continue;
      let logResults = await repo.log(logOption);
      for (let logResult of logResults) {
        let parents = logResult.parents;
        for (let parent of parents) {
          let changes = await repo.diffBetween(parent, logResult.hash);
          for (let change of changes) if (!(deleteStatus.has(change.status) || visited.has(change.uri.fsPath)) && (visited.add(change.uri.fsPath), touchedFiles.push(change.uri), touchedFiles.length >= maxFiles)) return touchedFiles;
        }
      }
    }
    return touchedFiles;
  }
};
var import_vscode = require("vscode");
var ExtensionWorkspaceFileSystem = class extends WorkspaceFileSystem {
  static {
    __name(this, "ExtensionWorkspaceFileSystem");
  }
  async findFiles(include, exclude, maxResults) {
    return await UD.workspace.findFiles(include, exclude, maxResults);
  }
  async getWorkspaceFolder(uri) {
    let folder = UD.workspace.getWorkspaceFolder(uri);
    if (folder !== void 0) return folder.uri;
  }
};
var outputChannel = ja.window.createOutputChannel("GitHub Copilot");
function registerStatusBar(ctx, outputChannel) {
  let copilotStatusBarItem = new CopilotStatusBar(ctx, outputChannel);
  registerCommandWithTelemetry(ctx, CMDToggleCopilot, async language => {
    await toggleCopilotEnablement(ctx, language === void 0 ? "global" : "language"), copilotStatusBarItem.updateStatusBarIndicator();
  }), registerCommandWithTelemetry(ctx, CMDToggleStatusMenu, () => {
    new CopilotStatusBarPickMenu(ctx, () => {
      debounce(100, () => {
        copilotStatusBarItem.updateStatusBarIndicator();
      });
    }).showStatusMenu();
  }), ctx.get(Extension).register(copilotStatusBarItem.getStatusBarItem()), ctx.set(StatusReporter, copilotStatusBarItem);
}
__name(registerStatusBar, "registerStatusBar");
async function activate(context) {
  let activationTelemetry = TelemetryData.createAndMarkAsIssued(),
    ctx = await createExtensionContext(context);
  registerStatusBar(ctx, outputChannel), ctx.set(CopilotRepositoryControlManager, new CopilotRepositoryControlManager(ctx)), registerDiagnosticCommands(ctx), registerCommandWithTelemetry(ctx, CMDSignIn, () => getSession(ctx, !0)), context.subscriptions.push(new CodeReference(ctx).register()), context.subscriptions.push(onDeactivate(ctx));
  let tryActivation = __name(async () => {
    let statusBar = ctx.get(StatusReporter);
    statusBar.setProgress(), permitOneSignIn();
    let rejectionHandler = __name((error, allowRetry = !0) => {
        let reason = error.message || error;
        telemetryError(ctx, "activationFailed", TelemetryData.createAndMarkAsIssued({
          reason: reason
        })), ctx.get(TelemetryReporters).deactivate();
        let message = reason === "GitHubLoginFailed" ? SESSION_LOGIN_MESSAGE : `Extension activation failed: "${reason}"`;
        statusBar.setError(message, allowRetry ? tryActivation : void 0), logger.error(ctx, message), ja.commands.executeCommand("setContext", "github.copilot.activated", !1);
      }, "rejectionHandler"),
      nodeVersionError = errorMessageForUnsupportedNodeVersion();
    if (nodeVersionError) {
      rejectionHandler(nodeVersionError, !1);
      return;
    }
    ctx.get(CopilotTokenManager).getCopilotToken(ctx).then(() => {
      statusBar.forceNormal(), ja.commands.executeCommand("setContext", "github.copilot.activated", !0), registerPanelSupport(ctx), registerGhostTextSupport(ctx), context.subscriptions.push(registerDocumentTracker(ctx)), context.subscriptions.push(registerCursorTracker(ctx)), context.subscriptions.push(ja.window.onDidChangeActiveTextEditor(e => e && extractRepoInfoInBackground(ctx, e.document.uri))), context.subscriptions.push(ja.workspace.onDidOpenTextDocument(doc => primeLanguageDetectionCache(ctx, doc))), context.subscriptions.push(ja.workspace.onDidChangeConfiguration(e => onDidChangeConfigurationHandler(e, ctx)));
      let isDevMode = context.extensionMode === ja.ExtensionMode.Development;
      init(ctx, !isDevMode, new Logger(1, "promptlib proxy")), isDevMode || ctx.get(hy.SnippetOrchestrator).startThreading(), telemetry(ctx, "extension.activate", activationTelemetry), ja.window?.activeTextEditor && ctx.get(CopilotRepositoryControlManager).evaluate(ja.window.activeTextEditor.document?.uri, ja.window.activeTextEditor.document.getText(), "UPDATE");
    }).catch(ex => {
      rejectionHandler(ex);
    });
  }, "tryActivation");
  return ja.authentication.onDidChangeSessions(async event => {
    await onDidChangeSessionsHandler(event, ctx);
  }), new VsCodeInstallationManager().startup(ctx), await tryActivation(), new CopilotExtensionApi(ctx);
}
__name(activate, "activate");
function registerGhostTextSupport(ctx) {
  try {
    registerGhostText(ctx);
    let inspect = ja.workspace.getConfiguration().inspect("editor.inlineSuggest.enabled");
    (inspect?.globalValue === !1 || inspect?.workspaceValue === !1) && logger.warn(ctx, "editor.inlineSuggest.enabled is disabled. Enabling recommended to use Copilot.");
  } catch (e) {
    telemetryException(ctx, e, "registerGhostTextSupport");
  }
}
__name(registerGhostTextSupport, "registerGhostTextSupport");
function registerDiagnosticCommands(ctx) {
  registerCommandWithTelemetry(ctx, CMDCollectDiagnostics, () => openDiagnosticReport(ctx)), registerCommandWithTelemetry(ctx, CMDSendFeedback, () => {
    ja.env.openExternal(ja.Uri.parse("https://github.com/orgs/community/discussions/categories/copilot"));
  }), registerCommandWithTelemetry(ctx, CMDOpenDocumentation, () => {
    ja.env.openExternal(ja.Uri.parse("https://docs.github.com/en/copilot/getting-started-with-github-copilot?tool=vscode"));
  }), registerCommandWithTelemetry(ctx, CMDOpenLogs, () => {
    outputChannel.show();
  });
}
__name(registerDiagnosticCommands, "registerDiagnosticCommands");
async function createExtensionContext(extensionContext) {
  let ctx = createProductionContext(new VSCodeConfigProvider()),
    logTarget = new MultiLog([new ConsoleLog(console), new OutputChannelLog(outputChannel)]);
  return ctx.forceSet(LogTarget, logTarget), ctx.set(EditorAndPluginInfo, new VSCodeEditorInfo()), initProxyEnvironment(ctx.get(Fetcher), process.env), ctx.set(NotificationSender, new ExtensionNotificationSender()), ctx.set(EditorSession, new EditorSession(ja.env.sessionId, ja.env.machineId)), ctx.set(Extension, new Extension(extensionContext)), ctx.set(EditorExperimentFilters, new VSCodeEditorExperimentFilters()), setupExperimentationService(ctx), ctx.set(SymbolDefinitionProvider, new ExtensionSymbolDefinitionProvider()), ctx.set(CopilotExtensionStatus, new CopilotExtensionStatus()), extensionContext.extensionMode === ja.ExtensionMode.Test ? (ctx.forceSet(RuntimeMode, RuntimeMode.fromEnvironment(!0)), ctx.set(CopilotTokenManager, getTestingCopilotTokenManager()), ctx.forceSet(UrlOpener, new TestUrlOpener()), await setupTelemetry(ctx, extensionContext, "copilot-test", !0)) : (ctx.set(CopilotTokenManager, new VSCodeCopilotTokenManager()), ctx.forceSet(ExpConfigMaker, new ExpConfigFromTAS()), await setupTelemetry(ctx, extensionContext, extensionContext.extension.packageJSON.name, ja.env.isTelemetryEnabled)), ctx.set(LocationFactory, new ExtensionLocationFactory()), ctx.set(TextDocumentManager, new ExtensionTextDocumentManager(ctx)), ctx.set(WorkspaceFileSystem, new ExtensionWorkspaceFileSystem()), ctx.set(CommitFileResolver, new ExtensionCommitFileResolver()), ctx.set(hy.FileSystem, extensionFileSystem), ctx.set(NetworkConfiguration, new VSCodeNetworkConfiguration()), ctx;
}
__name(createExtensionContext, "createExtensionContext");
async function setupTelemetry(ctx, extensionContext, extensionName, enabled) {
  extensionContext.subscriptions.push(ja.env.onDidChangeTelemetryEnabled(async newEnabled => {
    await setupTelemetryReporters(ctx, extensionContext.extension.packageJSON.name, newEnabled && ja.env.isTelemetryEnabled);
  })), await setupTelemetryReporters(ctx, extensionName, enabled), extensionContext.subscriptions.push(ja.env.createTelemetryLogger(new TelemetryDelegator(err => exception(ctx, err, "unhandlederror")))), cleanupTelemetryReporters(ctx);
}
__name(setupTelemetry, "setupTelemetry");
var Extension = class {
  constructor(context) {
    this.context = context;
  }
  static {
    __name(this, "Extension");
  }
  get isProdMode() {
    return this.context.extensionMode === ja.ExtensionMode.Production;
  }
  get isNightlyBuild() {
    return this.context.extension.packageJSON.buildType === "nightly";
  }
  register(...disposables) {
    this.context.subscriptions.push(...disposables);
  }
};
function onDeactivate(ctx) {
  return {
    dispose: async () => {
      await telemetry(ctx, "extension.deactivate"), ctx.get(TelemetryReporters).deactivate(), ctx.get(hy.SnippetOrchestrator).stopThreading(), terminate();
    }
  };
}
__name(onDeactivate, "onDeactivate");
0 && (module.exports = {
  Extension,
  activate,
  createExtensionContext,
  onDeactivate
});
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@microsoft/applicationinsights-web-snippet/dist/node/applicationinsights-web-snippet.js:
  (*!
   * Application Insights JavaScript SDK - Web Snippet, 1.0.1
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

git-url-parse/lib/index.js:
  (*!
   * buildToken
   * Builds OAuth token prefix (helper function)
   *
   * @name buildToken
   * @function
   * @param {GitUrl} obj The parsed Git url object.
   * @return {String} token prefix
   *)
*/
//# sourceMappingURL=extension.js.map