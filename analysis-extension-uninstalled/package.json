var require_package = __commonJSMin((exports, module) => {
  module.exports = {
    name: "copilot",
    displayName: "GitHub Copilot",
    description: "Your AI pair programmer",
    version: "1.186.856",
    build: "856",
    buildType: "nightly",
    publisher: "GitHub",
    preview: !1,
    homepage: "https://github.com/features/copilot?editor=vscode",
    license: "https://docs.github.com/en/site-policy/github-terms/github-terms-for-additional-products-and-features",
    bugs: {
      url: "https://github.com/community/community/discussions/categories/copilot"
    },
    qna: "https://github.com/github-community/community/discussions/categories/copilot",
    icon: "assets/Copilot-App-Icon.png",
    pricing: "Trial",
    extensionPack: ["GitHub.copilot-chat"],
    engines: {
      vscode: "^1.75.0",
      node: ">=16.14.0",
      npm: ">=8.0.0"
    },
    categories: ["Programming Languages", "Machine Learning", "Education", "Snippets"],
    keywords: ["ai", "openai", "codex", "pilot", "snippets", "documentation", "autocomplete", "intellisense", "refactor", "javascript", "python", "typescript", "php", "go", "golang", "ruby", "c++", "c#", "java", "kotlin", "co-pilot"],
    badges: [{
      url: "https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange",
      href: "https://github.com/github-copilot/signup?editor=vscode",
      description: "Sign up for GitHub Copilot"
    }, {
      url: "https://img.shields.io/github/stars/github/copilot-docs?style=social",
      href: "https://github.com/github/copilot-docs",
      description: "Star Copilot on GitHub"
    }, {
      url: "https://img.shields.io/youtube/channel/views/UC7c3Kb6jYCRj4JOHHZTxKsQ?style=social",
      href: "https://www.youtube.com/@GitHub/search?query=copilot",
      description: "Check out GitHub on Youtube"
    }, {
      url: "https://img.shields.io/twitter/follow/github?style=social",
      href: "https://twitter.com/github",
      description: "Follow GitHub on Twitter"
    }],
    activationEvents: ["onStartupFinished"],
    main: "./dist/extension",
    enabledApiProposals: ["inlineCompletionsAdditions"],
    contributes: {
      walkthroughs: [{
        id: "copilotWelcome",
        title: "GitHub Copilot",
        description: "Your AI pair programmer to write code faster and with less work",
        when: "!isWeb",
        steps: [{
          id: "copilot.signin",
          title: "Sign in with GitHub",
          description: `To get started with Copilot, sign in with your GitHub account.
Double-check to use the right GitHub account. You can also sign in later using the account menu.
 
[Sign In](command:github.copilot.signIn)`,
          when: "!github.copilot.activated",
          completionEvents: ["onContext:github.copilot.activated"],
          media: {
            image: "assets/walkthrough/sign-in.svg",
            altText: "Sign in to GitHub via Copilot's notification or VS Code's account menu"
          }
        }, {
          id: "copilot.firstsuggest",
          title: "AI-powered suggestions",
          description: `Copilot suggests lines of code **as you type** and multiple lines for **function signatures**.
  
**Prompts in comments** make suggestions specific to your desired outcome, logic and steps.
  
[Getting started videos](https://github.com/features/copilot/getting-started?utm_source=editor&utm_medium=walkthrough&utm_campaign=2024q3-em-MSFT-videolandingpage)`,
          media: {
            svg: "assets/walkthrough/ai-powered-suggestions.svg",
            altText: "Different types of suggestions visualized"
          }
        }, {
          id: "copilot.chatWin",
          title: "Chat with Copilot",
          description: "Ask Copilot general programming questions with chat. Copilot can also fix problems, scaffold tests, or refactor your code. Type ``/`` to view all available chat commands. Use `ctrl + shift + i` to open inline chat.\n[Chat with Copilot](command:workbench.panel.chat.view.copilot.focus)",
          when: "isWindows && !github.copilot.interactiveSession.disabled",
          media: {
            svg: "assets/walkthrough/copilot-chat.svg",
            altText: "Copilot Chat view in the sidebar"
          }
        }, {
          id: "copilot.chatNonWin",
          title: "Chat with Copilot",
          description: "Ask Copilot general programming questions with chat. Copilot can also fix problems, scaffold tests, or refactor your code. Type ``/`` to view all available chat commands. Use `cmd + shift + i` to open inline chat.\n[Chat with Copilot](command:workbench.panel.chat.view.copilot.focus)",
          when: "!isWindows && !github.copilot.interactiveSession.disabled",
          media: {
            svg: "assets/walkthrough/copilot-chat.svg",
            altText: "Copilot Chat view in the sidebar"
          }
        }, {
          id: "copilot.realfiles.openrecent",
          title: "Harness the power of context",
          description: `The **more specific context** you provide Copilot, the **better** suggestions get! Context is not just current code and comments, but other open files.
  
[Try Copilot in Your Code](command:workbench.action.openRecent)`,
          when: "workspaceFolderCount == 0",
          media: {
            svg: "assets/walkthrough/code-as-context.svg",
            altText: "An editor with code being suggested by Copilot in gray text"
          }
        }, {
          id: "copilot.realfiles.quickopen",
          title: "Harness the power of context",
          description: `The **more context** you give Copilot, the **better** suggestions get! Context is not just the current code, but other open files.
  
[Try Copilot in Your Code](command:workbench.action.quickOpen)`,
          when: "workspaceFolderCount != 0",
          media: {
            svg: "assets/walkthrough/code-as-context.svg",
            altText: "An editor with code being suggested by Copilot in gray text"
          }
        }, {
          id: "copilot.iterate",
          title: "You are in control",
          description: `Just as you would review a colleague's code, you should always assess, analyze, and validate AI-generated code.
  
If the first suggestion doesn't work, Copilot can generate more options. You can edit the Copilot settings and keyboard shortcuts to personalize your experience.
  
[Edit keyboard shortcuts](command:workbench.action.openGlobalKeybindings?%5B%22copilot%22%5D)
  
[Personalize settings](command:workbench.action.openSettings?%5B%22copilot%22%5D)`,
          media: {
            image: "assets/walkthrough/you-are-in-control.svg",
            altText: "An editor with a toolbar widget overlay showing arrows for navigating multiple suggestions from Copilot"
          }
        }, {
          id: "copilot.creativity",
          title: "Powered by your creativity",
          description: `Pair up with AI to outline your idea in a comment, then generate the implementation, and then test suites. Or, work backwards from example output!
Copilot will keep surprising you as you challenge it.
  
[Prompts, tips, and use cases](https://code.visualstudio.com/docs/copilot/prompt-crafting)`,
          media: {
            svg: "assets/walkthrough/powered-by-your-creativity.svg",
            altText: "Metrics showing how much Copilot increases productivity for developers. The metrics read: 74% focus on more satisfying work. 88% feel more productive. 96% are faster with more repetitive tasks."
          }
        }]
      }],
      commands: [{
        command: "github.copilot.acceptCursorPanelSolution",
        title: "Accept panel suggestion at the cursor",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.signIn",
        title: "Sign In",
        category: "GitHub Copilot",
        enablement: "!github.copilot.activated"
      }, {
        command: "github.copilot.previousPanelSolution",
        title: "Navigate to the previous panel suggestion",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.nextPanelSolution",
        title: "Navigate to the next panel suggestion",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.generate",
        title: "Open Completions Panel",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.toggleCopilot",
        title: "Enable/Disable Copilot completions",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.sendFeedback",
        title: "Send Feedback",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.collectDiagnostics",
        title: "Collect Diagnostics",
        category: "GitHub Copilot"
      }, {
        command: "github.copilot.openLogs",
        title: "Open Logs",
        category: "GitHub Copilot"
      }],
      keybindings: [{
        command: "github.copilot.generate",
        key: "ctrl+enter",
        mac: "ctrl+enter",
        when: "editorTextFocus && github.copilot.activated && !inInteractiveInput && !interactiveEditorFocused"
      }, {
        command: "github.copilot.acceptCursorPanelSolution",
        key: "ctrl+/",
        mac: "ctrl+/",
        when: "github.copilot.activated && github.copilot.panelVisible && activeWebviewPanelId == 'GitHub Copilot Suggestions'"
      }, {
        command: "github.copilot.previousPanelSolution",
        key: "alt+[",
        mac: "alt+[",
        when: "github.copilot.activated && github.copilot.panelVisible && activeWebviewPanelId == 'GitHub Copilot Suggestions'"
      }, {
        command: "github.copilot.nextPanelSolution",
        key: "alt+]",
        mac: "alt+]",
        when: "github.copilot.activated && github.copilot.panelVisible && activeWebviewPanelId == 'GitHub Copilot Suggestions'"
      }, {
        command: "editor.action.inlineSuggest.trigger",
        key: "alt+\\",
        when: "editorTextFocus && !editorHasSelection && config.github.copilot.inlineSuggest.enable && !inlineSuggestionsVisible"
      }],
      menus: {
        "editor/inlineCompletions/actions": [{
          command: "github.copilot.generate",
          when: "github.copilot.activated"
        }],
        commandPalette: [{
          command: "github.copilot.generate",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.toggleCopilot",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.sendFeedback",
          when: "github.copilot.activated"
        }, {
          command: "github.copilot.collectDiagnostics"
        }]
      },
      configuration: [{
        title: "Copilot",
        properties: {
          "github.copilot.advanced": {
            type: "object",
            title: "Advanced Settings",
            properties: {
              authProvider: {
                type: "string",
                enum: ["github", "github-enterprise"],
                enumDescriptions: ["GitHub.com", "GitHub Enterprise"],
                default: "github",
                description: "The GitHub identity to use for Copilot"
              },
              "debug.overrideEngine": {
                type: "string",
                default: "",
                description: "Override engine name"
              },
              "debug.overrideProxyUrl": {
                type: "string",
                default: "",
                description: "Override GitHub authentication proxy full URL"
              },
              "debug.testOverrideProxyUrl": {
                type: "string",
                default: "",
                description: "Override GitHub authentication proxy URL when running tests"
              },
              "debug.overrideCapiUrl": {
                type: "string",
                default: "",
                description: "Override GitHub Copilot API full URL"
              },
              "debug.testOverrideCapiUrl": {
                type: "string",
                default: "",
                description: "Override GitHub Copilot API URL when running tests"
              },
              "debug.filterLogCategories": {
                type: "array",
                default: [],
                description: "Show only log categories listed in this setting. If an array is empty, show all loggers"
              }
            }
          },
          "github.copilot.enable": {
            type: "object",
            default: {
              "*": !0,
              plaintext: !1,
              markdown: !1,
              scminput: !1
            },
            additionalProperties: "boolean",
            markdownDescription: "Enable or disable Copilot completions for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)"
          },
          "github.copilot.inlineSuggest.enable": {
            type: "boolean",
            default: !0,
            deprecationMessage: "Deprecated: Please use github.copilot.editor.enableAutoCompletions instead.",
            description: "Show inline suggestions"
          },
          "github.copilot.editor.enableAutoCompletions": {
            type: "boolean",
            scope: "language-overridable",
            default: !0,
            description: "Automatically show inline completions"
          }
        }
      }],
      configurationDefaults: {
        "editor.tokenColorCustomizations": {
          "[*Light*]": {
            textMateRules: [{
              scope: "ref.matchtext",
              settings: {
                foreground: "#000"
              }
            }]
          },
          "[*Dark*]": {
            textMateRules: [{
              scope: "ref.matchtext",
              settings: {
                foreground: "#fff"
              }
            }]
          }
        }
      },
      languages: [{
        id: "code-referencing"
      }],
      grammars: [{
        language: "code-referencing",
        scopeName: "text.ref",
        path: "./syntaxes/ref.tmGrammar.json"
      }],
      icons: {
        "copilot-logo": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0041"
          }
        },
        "copilot-warning": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0042"
          }
        },
        "copilot-notconnected": {
          description: "GitHub Copilot icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0043"
          }
        },
        "copilot-chat": {
          description: "GitHub Copilot chat icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\F101"
          }
        },
        "copilot-blocked": {
          description: "GitHub Copilot blocked icon",
          default: {
            fontPath: "assets/copilot.woff",
            fontCharacter: "\\0045"
          }
        }
      },
      iconFonts: [{
        id: "copilot-font",
        src: [{
          path: "assets/copilot.woff",
          format: "woff"
        }]
      }]
    },
    scripts: {
      build: "run-s build:prompt build:root",
      "build:prompt": "npm -C prompt run build",
      "build:root": "tsx .esbuild.ts",
      clean: "./script/build/clean.sh",
      "forbid-sources-content:extension": "node script/forbid-sources-content.js --extension",
      generate_languages: "ts-node script/generateLanguages.ts && prettier --write lib/src/language/generatedLanguages.ts",
      get_token: "ts-node script/getToken.ts",
      lint: 'run-p --aggregate-output "lint:*"',
      "lint:deps": "depcruise -c .dependency-cruiser.js .",
      "lint:eslint": "eslint -f visualstudio --cache .",
      "lint:prettier": "prettier --check . 2>&1",
      "lint:types": "tsc --noEmit && tsc --noEmit -p extension/src/copilotPanel/webview",
      prebuild: "./script/build/clean-deprecated-modules.sh && npm install",
      pretest: "npm run build",
      "pretest:extension": "npm run build",
      "pretest:lsp-client": "npm run build",
      prewatch: "npm run build",
      start: "npm run watch",
      test: 'npm-run-all "test:* --ignore-scripts" lint',
      "test:agent": 'mocha "agent/src/**/*.test.ts"',
      "test:extension": "tsx extension/test/runTest.ts",
      "test:lib": 'mocha "lib/src/**/*.test.ts"',
      "test:lib-e2e": 'mocha "lib/e2e/src/**/*.test.ts"',
      "test:lsp-client": "npm -C lsp-client run test",
      "test:prompt": "npm -C prompt run test",
      "vscode-dts": "vscode-dts dev && mv vscode.proposed.*.ts extension/src",
      "vscode:prepublish": 'run-s "build --ignore-scripts" forbid-sources-content:extension',
      "vscode:uninstall": "node dist/extensionUninstalled.js",
      vsix: "vsce package",
      watch: "run-p watch:*",
      "watch:prompt": "npm -C prompt run watch",
      "watch:root": "tsx .esbuild.ts --watch",
      "watch:types": "tsc --noEmit --watch --preserveWatchOutput"
    },
    workspaces: ["prompt"],
    devDependencies: {
      "@datadog/datadog-ci": "^2.33.0",
      "@github/prettier-config": "0.0.6",
      "@types/crypto-js": "^4.1.1",
      "@types/git-url-parse": "^9.0.1",
      "@types/js-yaml": "^4.0.6",
      "@types/kerberos": "^1.1.2",
      "@types/mocha": "^10.0.6",
      "@types/node": "^16.18.24",
      "@types/sinon": "^10.0.13",
      "@types/uuid": "^9.0.7",
      "@types/vscode": "^1.75.0",
      "@types/yargs": "^17.0.24",
      "@typescript-eslint/eslint-plugin": "^6.18.0",
      "@typescript-eslint/parser": "^6.18.0",
      "@vscode/test-electron": "^2.3.8",
      "@vscode/vsce": "^2.21.0",
      boxen: "^7.1.1",
      chalk: "^4.1.2",
      "dependency-cruiser": "^13.0.2",
      electron: "^28.1.4",
      esbuild: "^0.19.9",
      "esbuild-plugin-copy": "^2.1.1",
      "esbuild-plugin-summary": "^0.0.2",
      eslint: "^8.56.0",
      "eslint-plugin-no-only-tests": "^3.1.0",
      fantasticon: "^2.0.0",
      glob: "^10.3.4",
      "js-yaml": "^4.1.0",
      mocha: "^10.3.0",
      "mocha-junit-reporter": "^2.2.1",
      "mocha-multi-reporters": "^1.5.1",
      "npm-run-all": "^4.1.5",
      pkg: "^5.8.1",
      prettier: "3.0.1",
      "prettier-plugin-organize-imports": "^3.2.4",
      proxy: "^2.1.1",
      sinon: "^16.0.0",
      "ts-dedent": "^2.2.0",
      "ts-mocha": "^10.0.0",
      "ts-node": "^10.9.1",
      tsx: "^4.7.1",
      "typed-emitter": "^2.1.0",
      typescript: "^5.1.6",
      "vscode-dts": "^0.3.3",
      zlib: "^1.0.5"
    },
    dependencies: {
      "@adobe/helix-fetch": "github:devm33/helix-fetch#1088e599270f36632703f138d88c2100cbe468db",
      "@github/copilot-promptlib": "file:prompt",
      "@github/memoize": "1.1.4",
      "@microsoft/1ds-post-js": "^4.0.5",
      "@microsoft/applicationinsights-web-basic": "^3.1.0",
      "@roamhq/mac-ca": "^1.0.7",
      "@sinclair/typebox": "^0.31.28",
      "@types/vscode-webview": "^1.57.4",
      "@vscode/webview-ui-toolkit": "^1.3.1",
      "crypto-js": "^4.2.0",
      diff: "^5.2.0",
      dldr: "^0.0.10",
      "git-url-parse": "^13.1.0",
      ignore: "^5.2.4",
      jhaystack: "^0.1.8",
      kerberos: "^2.0.1",
      minimatch: "^9.0.3",
      open: "^8.4.2",
      semver: "^7.5.4",
      shiki: "^1.1.2",
      "source-map-support": "^0.5.21",
      uuid: "^9.0.1",
      "vscode-languageserver": "^9.0.0",
      "vscode-languageserver-protocol": "^3.17",
      "vscode-languageserver-textdocument": "~1.0.11",
      "vscode-uri": "^3.0.7",
      "windows-ca-certs": "^0.0.3",
      yargs: "^17.7.2"
    },
    overrides: {
      bindings: "github:devm33/node-bindings#6b57e6883b34dbb6942467a7e49afce99d9d6832"
    }
  };
});,var rk = y0((oy, tk) => {
  (function (e, t) {
    typeof oy == "object" && typeof tk < "u" ? t(oy) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t((e.Microsoft = e.Microsoft || {}, e.Microsoft.ApplicationInsights = e.Microsoft.ApplicationInsights || {})));
  })(oy, function (e) {
    "use strict";

    var UNDEF_VALUE = void 0,
      NULL_VALUE = null,
      EMPTY = "",
      FUNCTION = "function",
      NUMBER = "number",
      OBJECT = "object",
      PROTOTYPE = "prototype",
      __PROTO__ = "__proto__",
      STRING = "string",
      UNDEFINED = "undefined",
      CONSTRUCTOR = "constructor",
      SYMBOL = "Symbol",
      POLYFILL_TAG = "_polyfill",
      INDEX_OF = "indexOf",
      LENGTH = "length",
      VALUE = "value",
      NAME = "name",
      SLICE = "slice",
      CALL = "call",
      TO_STRING = "toString",
      ObjClass = Object,
      ObjProto = ObjClass[PROTOTYPE],
      StrCls = String,
      StrProto = StrCls[PROTOTYPE],
      MathCls = Math,
      ArrCls = Array,
      ArrProto = ArrCls[PROTOTYPE];
    function safe(func, argArray) {
      try {
        return {
          v: func.apply(this, argArray)
        };
      } catch (e) {
        return {
          e: e
        };
      }
    }
    __name(safe, "safe");
    function _createIs(theType) {
      return function (value) {
        return typeof value === theType;
      };
    }
    __name(_createIs, "_createIs");
    function _createObjIs(theName) {
      var theType = "[object " + theName + "]";
      return function (value) {
        return !!(value && objToString(value) === theType);
      };
    }
    __name(_createObjIs, "_createObjIs");
    function objToString(value) {
      return ObjProto.toString.call(value);
    }
    __name(objToString, "objToString");
    function isUndefined(value) {
      return typeof value === UNDEFINED || value === UNDEFINED;
    }
    __name(isUndefined, "isUndefined");
    function isNullOrUndefined(value) {
      return value === NULL_VALUE || isUndefined(value);
    }
    __name(isNullOrUndefined, "isNullOrUndefined");
    function isDefined(arg) {
      return !!arg || arg !== UNDEF_VALUE;
    }
    __name(isDefined, "isDefined");
    var isString = _createIs(STRING),
      isFunction = _createIs(FUNCTION);
    function isObject(value) {
      return !value && isNullOrUndefined(value) ? !1 : !!value && typeof value === OBJECT;
    }
    __name(isObject, "isObject");
    var isArray = ArrCls.isArray,
      isError = _createObjIs("Error"),
      objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;
    function objHasOwnProperty(obj, prop) {
      return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    __name(objHasOwnProperty, "objHasOwnProperty");
    var objHasOwn = ObjClass.hasOwn || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
      return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    __name(polyObjHasOwn, "polyObjHasOwn");
    function objForEachKey(theObject, callbackfn, thisArg) {
      if (theObject && isObject(theObject)) {
        for (var prop in theObject) if (objHasOwn(theObject, prop) && callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) break;
      }
    }
    __name(objForEachKey, "objForEachKey");
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
      var theMap = {};
      return objForEachKey(values, function (key, value) {
        theMap[key] = keyType ? value : key, theMap[value] = valueType ? value : key;
      }), completeFn(theMap);
    }
    __name(_createKeyValueMap, "_createKeyValueMap");
    function throwError(message) {
      throw new Error(message);
    }
    __name(throwError, "throwError");
    function throwTypeError(message) {
      throw new TypeError(message);
    }
    __name(throwTypeError, "throwTypeError");
    var _objFreeze = ObjClass.freeze;
    function _doNothing(value) {
      return value;
    }
    __name(_doNothing, "_doNothing");
    function _getProto(value) {
      return value[__PROTO__] || NULL_VALUE;
    }
    __name(_getProto, "_getProto");
    var objAssign = ObjClass.assign,
      objKeys = ObjClass.keys;
    function objDeepFreeze(value) {
      return _objFreeze && objForEachKey(value, function (key, value) {
        (isArray(value) || isObject(value)) && _objFreeze(value);
      }), objFreeze(value);
    }
    __name(objDeepFreeze, "objDeepFreeze");
    var objFreeze = _objFreeze || _doNothing,
      objGetPrototypeOf = ObjClass.getPrototypeOf || _getProto;
    function createEnum(values) {
      return _createKeyValueMap(values, 1, 0, objDeepFreeze);
    }
    __name(createEnum, "createEnum");
    function createSimpleMap(values) {
      var mapClass = {};
      return objForEachKey(values, function (key, value) {
        mapClass[key] = value[1], mapClass[value[0]] = value[1];
      }), objDeepFreeze(mapClass);
    }
    __name(createSimpleMap, "createSimpleMap");
    function createTypeMap(values) {
      return createSimpleMap(values);
    }
    __name(createTypeMap, "createTypeMap");
    var asString = StrCls,
      GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg",
      _globalCfg;
    function _getGlobalValue() {
      var result;
      return typeof globalThis !== UNDEFINED && (result = globalThis), !result && typeof self !== UNDEFINED && (result = self), !result && typeof window !== UNDEFINED && (result = window), !result && typeof global !== UNDEFINED && (result = global), result;
    }
    __name(_getGlobalValue, "_getGlobalValue");
    function _getGlobalConfig() {
      if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
      }
      return _globalCfg;
    }
    __name(_getGlobalConfig, "_getGlobalConfig");
    var ERROR_TYPE = "[object Error]";
    function dumpObj(object, format) {
      var propertyValueDump = EMPTY,
        objType = ObjProto[TO_STRING][CALL](object);
      objType === ERROR_TYPE && (object = {
        stack: asString(object.stack),
        message: asString(object.message),
        name: asString(object.name)
      });
      try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === NUMBER ? format : 4 : UNDEF_VALUE), propertyValueDump = propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") || asString(object);
      } catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
      }
      return objType + ": " + propertyValueDump;
    }
    __name(dumpObj, "dumpObj");
    var _slice,
      _unwrapInstFunction = _unwrapFunctionWithPoly,
      _unwrapFunction = _unwrapFunctionWithPoly;
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
      _slice = _slice || ArrProto[SLICE];
      var clsFn = clsProto && clsProto[funcName];
      return function (thisArg) {
        var theFunc = thisArg && thisArg[funcName] || clsFn;
        if (theFunc || polyFunc) {
          var theArgs = arguments;
          return (theFunc || polyFunc).apply(thisArg, theFunc ? _slice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError('"' + asString(funcName) + '" not defined for ' + dumpObj(thisArg));
      };
    }
    __name(_unwrapFunctionWithPoly, "_unwrapFunctionWithPoly");
    var mathMax = MathCls.max,
      strSlice = _unwrapFunction(SLICE, StrProto),
      strSubstring = _unwrapFunction("substring", StrProto),
      strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
      return isNullOrUndefined(value) && throwTypeError("'polyStrSubstr called with invalid " + dumpObj(value)), length < 0 ? EMPTY : (start = start || 0, start < 0 && (start = mathMax(start + value[LENGTH], 0)), isUndefined(length) ? strSlice(value, start) : strSlice(value, start, start + length));
    }
    __name(polyStrSubstr, "polyStrSubstr");
    function strLeft(value, count) {
      return strSubstring(value, 0, count);
    }
    __name(strLeft, "strLeft");
    var UNIQUE_REGISTRY_ID = "_urid",
      _polySymbols;
    function _globalSymbolRegistry() {
      if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || {
          k: {},
          s: {}
        };
      }
      return _polySymbols;
    }
    __name(_globalSymbolRegistry, "_globalSymbolRegistry");
    function polyNewSymbol(description) {
      var theSymbol = {
        description: asString(description),
        toString: function () {
          return SYMBOL + "(" + description + ")";
        }
      };
      return theSymbol[POLYFILL_TAG] = !0, theSymbol;
    }
    __name(polyNewSymbol, "polyNewSymbol");
    function polySymbolFor(key) {
      var registry = _globalSymbolRegistry();
      if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key),
          regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () {
          return regId_1 + "_" + newSymbol_1[TO_STRING]();
        }, registry.k[key] = newSymbol_1, registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
      }
      return registry.k[key];
    }
    __name(polySymbolFor, "polySymbolFor");
    var propMap = {
      e: "enumerable",
      c: "configurable",
      v: VALUE,
      w: "writable",
      g: "get",
      s: "set"
    };
    function _createProp(value) {
      var prop = {};
      if (prop[propMap.c] = !0, prop[propMap.e] = !0, value.l) {
        prop.get = function () {
          return value.l.v;
        };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        desc && desc.set && (prop.set = function (newValue) {
          value.l.v = newValue;
        });
      }
      return objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
      }), prop;
    }
    __name(_createProp, "_createProp");
    var objDefineProp = ObjClass.defineProperty;
    function objDefine(target, key, propDesc) {
      return objDefineProp(target, key, _createProp(propDesc));
    }
    __name(objDefine, "objDefine");
    var _globalLazyTestHooks;
    function _initTestHooks() {
      _globalLazyTestHooks = _getGlobalConfig();
    }
    __name(_initTestHooks, "_initTestHooks");
    function getLazy(cb) {
      var lazyValue = {};
      return !_globalLazyTestHooks && _initTestHooks(), lazyValue.b = _globalLazyTestHooks.lzy, objDefineProp(lazyValue, "v", {
        configurable: !0,
        get: function () {
          var result = cb();
          return _globalLazyTestHooks.lzy || objDefineProp(lazyValue, "v", {
            value: result
          }), lazyValue.b = _globalLazyTestHooks.lzy, result;
        }
      }), lazyValue;
    }
    __name(getLazy, "getLazy");
    function safeGetLazy(cb, defValue) {
      return getLazy(function () {
        var result = safe(cb);
        return result.e ? defValue : result.v;
      });
    }
    __name(safeGetLazy, "safeGetLazy");
    function createCachedValue(value) {
      return objDefineProp({
        toJSON: function () {
          return value;
        }
      }, "v", {
        value: value
      });
    }
    __name(createCachedValue, "createCachedValue");
    var WINDOW = "window",
      _cachedGlobal,
      _cachedWindow,
      _cachedDocument,
      _cachedNavigator;
    function lazySafeGetInst(name) {
      return getLazy(function () {
        return safe(getInst, [name]).v || UNDEF_VALUE;
      });
    }
    __name(lazySafeGetInst, "lazySafeGetInst");
    function getGlobal(useCached) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedGlobal || useCached === !1 || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE)), _cachedGlobal.v;
    }
    __name(getGlobal, "getGlobal");
    function getInst(name, useCached) {
      var gbl = !_cachedGlobal || useCached === !1 ? getGlobal(useCached) : _cachedGlobal.v;
      return gbl && gbl[name] ? gbl[name] : name === WINDOW && _cachedWindow ? _cachedWindow.v : NULL_VALUE;
    }
    __name(getInst, "getInst");
    function getDocument() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedDocument || _globalLazyTestHooks.lzy) && (_cachedDocument = createCachedValue(safe(getInst, ["document"]).v)), _cachedDocument.v;
    }
    __name(getDocument, "getDocument");
    function hasWindow() {
      return !!getWindow();
    }
    __name(hasWindow, "hasWindow");
    function getWindow() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedWindow || _globalLazyTestHooks.lzy) && (_cachedWindow = createCachedValue(safe(getInst, [WINDOW]).v)), _cachedWindow.v;
    }
    __name(getWindow, "getWindow");
    function hasNavigator() {
      return !!getNavigator();
    }
    __name(hasNavigator, "hasNavigator");
    function getNavigator() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedNavigator || _globalLazyTestHooks.lzy) && (_cachedNavigator = createCachedValue(safe(getInst, ["navigator"]).v)), _cachedNavigator.v;
    }
    __name(getNavigator, "getNavigator");
    var _symbol, _symbolFor;
    function _initSymbol() {
      (!_symbol || !_symbol.b) && (_symbol = lazySafeGetInst(SYMBOL), _symbolFor = safeGetLazy(function () {
        return _symbol.v ? _symbol.v.for : UNDEF_VALUE;
      }, UNDEF_VALUE));
    }
    __name(_initSymbol, "_initSymbol");
    function newSymbol(description, noPoly) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), _symbol.v ? _symbol.v(description) : noPoly ? NULL_VALUE : polyNewSymbol(description);
    }
    __name(newSymbol, "newSymbol");
    function symbolFor(key) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbolFor || !_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), (_symbolFor.v || polySymbolFor)(key);
    }
    __name(symbolFor, "symbolFor");
    var fnApply = _unwrapInstFunction("apply");
    function arrForEach(theArray, callbackfn, thisArg) {
      if (theArray) for (var len = theArray[LENGTH] >>> 0, idx = 0; idx < len && !(idx in theArray && callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1); idx++);
    }
    __name(arrForEach, "arrForEach");
    var arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto),
      arrMap = _unwrapFunction("map", ArrProto),
      arrReduce = _unwrapFunction("reduce", ArrProto),
      objCreate = ObjClass.create || polyObjCreate;
    function polyObjCreate(obj) {
      if (!obj) return {};
      var type = typeof obj;
      type !== OBJECT && type !== FUNCTION && throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
      function tempFunc() {}
      return __name(tempFunc, "tempFunc"), tempFunc[PROTOTYPE] = obj, new tempFunc();
    }
    __name(polyObjCreate, "polyObjCreate");
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
      var fn = ObjClass.setPrototypeOf || function (d, b) {
        !_isProtoArray && (_isProtoArray = getLazy(function () {
          var _a;
          return _a = {}, _a[__PROTO__] = [], _a instanceof Array;
        })), _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) {
          return d[key] = value;
        });
      };
      return fn(obj, proto);
    }
    __name(objSetPrototypeOf, "objSetPrototypeOf");
    function _createCustomError(name, d, b) {
      safe(objDefine, [d, NAME, {
        v: name,
        c: !0,
        e: !1
      }]), d = objSetPrototypeOf(d, b);
      function __() {
        this.constructor = d, safe(objDefine, [this, NAME, {
          v: name,
          c: !0,
          e: !1
        }]);
      }
      return __name(__, "__"), d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __()), d;
    }
    __name(_createCustomError, "_createCustomError");
    function _setName(baseClass, name) {
      name && (baseClass[NAME] = name);
    }
    __name(_setName, "_setName");
    function createCustomError(name, constructCb, errorBase) {
      var theBaseClass = errorBase || Error,
        orgName = theBaseClass[PROTOTYPE][NAME],
        captureFn = Error.captureStackTrace;
      return _createCustomError(name, function () {
        var _this = this,
          theArgs = arguments;
        try {
          safe(_setName, [theBaseClass, name]);
          var _self = fnApply(theBaseClass, _this, ArrProto[SLICE][CALL](theArgs)) || _this;
          if (_self !== _this) {
            var orgProto = objGetPrototypeOf(_this);
            orgProto !== objGetPrototypeOf(_self) && objSetPrototypeOf(_self, orgProto);
          }
          return captureFn && captureFn(_self, _this[CONSTRUCTOR]), constructCb && constructCb(_self, theArgs), _self;
        } finally {
          safe(_setName, [theBaseClass, orgName]);
        }
      }, theBaseClass);
    }
    __name(createCustomError, "createCustomError");
    function utcNow() {
      return (Date.now || polyUtcNow)();
    }
    __name(utcNow, "utcNow");
    function polyUtcNow() {
      return new Date().getTime();
    }
    __name(polyUtcNow, "polyUtcNow");
    function _createTrimFn(exp) {
      return __name(function (value) {
        return isNullOrUndefined(value) && throwTypeError("strTrim called [" + dumpObj(value) + "]"), value && value.replace && (value = value.replace(exp, EMPTY)), value;
      }, "_doTrim");
    }
    __name(_createTrimFn, "_createTrimFn");
    var polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g),
      strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim),
      _fnToString,
      _objCtrFnString,
      _gblWindow;
    function isPlainObject(value) {
      if (!value || typeof value !== OBJECT) return !1;
      _gblWindow || (_gblWindow = hasWindow() ? getWindow() : !0);
      var result = !1;
      if (value !== _gblWindow) {
        _objCtrFnString || (_fnToString = Function[PROTOTYPE][TO_STRING], _objCtrFnString = _fnToString[CALL](ObjClass));
        try {
          var proto = objGetPrototypeOf(value);
          result = !proto, result || (objHasOwnProperty(proto, CONSTRUCTOR) && (proto = proto[CONSTRUCTOR]), result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
        } catch {}
      }
      return result;
    }
    __name(isPlainObject, "isPlainObject");
    var _perf;
    function getPerformance() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_perf || !_perf.b && _globalLazyTestHooks.lzy) && (_perf = lazySafeGetInst("performance")), _perf.v;
    }
    __name(getPerformance, "getPerformance");
    var strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
      isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
      var searchValue = isString(searchString) ? searchString : asString(searchString),
        end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
      return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    __name(polyStrEndsWith, "polyStrEndsWith");
    var strIndexOf = _unwrapFunction(INDEX_OF, StrProto),
      REF = "ref",
      UNREF = "un" + REF,
      HAS_REF = "hasRef",
      ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
      var _a,
        ref = !0,
        timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE,
        theTimerHandler,
        _unref = __name(function () {
          return ref = !1, timerId && timerId[UNREF] && timerId[UNREF](), theTimerHandler;
        }, "_unref"),
        _ref = __name(function () {
          return ref = !0, timerId && timerId[REF] && timerId[REF](), theTimerHandler;
        }, "_ref"),
        _hasRef = __name(function () {
          return timerId && timerId[HAS_REF] ? timerId[HAS_REF]() : ref;
        }, "_hasRef"),
        _refresh = __name(function () {
          return timerId = refreshFn(timerId), ref || _unref(), theTimerHandler;
        }, "_refresh"),
        _cancel = __name(function () {
          timerId && cancelFn(timerId), timerId = NULL_VALUE;
        }, "_cancel"),
        _setEnabled = __name(function (value) {
          !value && timerId && _cancel(), value && !timerId && _refresh();
        }, "_setEnabled");
      return theTimerHandler = (_a = {
        cancel: _cancel,
        refresh: _refresh
      }, _a[HAS_REF] = _hasRef, _a[REF] = _ref, _a[UNREF] = _unref, _a[ENABLED] = !1, _a), objDefineProp(theTimerHandler, ENABLED, {
        get: function () {
          return !!timerId;
        },
        set: _setEnabled
      }), {
        h: theTimerHandler,
        dn: function () {
          timerId = NULL_VALUE;
        }
      };
    }
    __name(_createTimerHandler, "_createTimerHandler");
    function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
      var isArr = isArray(overrideFn),
        len = isArr ? overrideFn.length : 0,
        setFn = (len > 0 ? overrideFn[0] : isArr ? UNDEF_VALUE : overrideFn) || setTimeout,
        clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout,
        timerFn = theArgs[0];
      theArgs[0] = function () {
        handler.dn(), fnApply(timerFn, self, ArrProto[SLICE][CALL](arguments));
      };
      var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
          if (timerId.refresh) return timerId.refresh(), timerId;
          fnApply(clearFn, self, [timerId]);
        }
        return fnApply(setFn, self, theArgs);
      }, function (timerId) {
        fnApply(clearFn, self, [timerId]);
      });
      return handler.h;
    }
    __name(_createTimeoutWith, "_createTimeoutWith");
    function scheduleTimeout(callback, timeout) {
      return _createTimeoutWith(this, !0, UNDEF_VALUE, ArrProto[SLICE][CALL](arguments));
    }
    __name(scheduleTimeout, "scheduleTimeout");
    var createEnumStyle = createEnum,
      createValueMap = createTypeMap,
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_BLK_VAL = "blkVal",
      _DYN_LENGTH = "length",
      _DYN_RD_ONLY = "rdOnly",
      _DYN_NOTIFY = "notify",
      _DYN_WARN_TO_CONSOLE = "warnToConsole",
      _DYN_THROW_INTERNAL = "throwInternal",
      _DYN_SET_DF = "setDf",
      _DYN_WATCH = "watch",
      _DYN_LOGGER = "logger",
      _DYN_APPLY = "apply",
      _DYN_PUSH = "push",
      _DYN_SPLICE = "splice",
      _DYN_HDLR = "hdlr",
      _DYN_CANCEL = "cancel",
      _DYN_NAME = "name",
      _DYN_UNLOAD = "unload",
      _DYN_VERSION = "version",
      _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole",
      _DYN_MESSAGE_ID = "messageId",
      _DYN_MESSAGE = "message",
      _DYN_DIAG_LOG = "diagLog",
      _DYN_USER_AGENT = "userAgent",
      _DYN_SPLIT = "split",
      _DYN_NODE_TYPE = "nodeType",
      _DYN_REPLACE = "replace",
      _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage",
      _DYN_TYPE = "type",
      _DYN_HANDLER = "handler",
      _DYN_TRACE_ID = "traceId",
      _DYN_SPAN_ID = "spanId",
      _DYN_TRACE_FLAGS = "traceFlags",
      aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
      aggregationErrorType || (aggregationErrorType = createCustomError("AggregationError", function (self, args) {
        args[_DYN_LENGTH] > 1 && (self.errors = args[1]);
      }));
      var theMessage = message || "One or more errors occurred.";
      throw arrForEach(sourceErrors, function (srcError, idx) {
        theMessage += `
`.concat(idx, " > ").concat(dumpObj(srcError));
      }), new aggregationErrorType(theMessage, sourceErrors || []);
    }
    __name(throwAggregationError, "throwAggregationError");
    var strShimFunction = "function",
      strShimObject = "object",
      strShimUndefined = "undefined",
      strShimPrototype = "prototype",
      ObjClass = Object,
      ObjProto = ObjClass[strShimPrototype],
      strHasOwnProperty = "hasOwnProperty",
      __objAssignFnImpl = __name(function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) ObjProto[strHasOwnProperty].call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, "__objAssignFnImpl"),
      __assignFn = objAssign || __objAssignFnImpl,
      extendStaticsFn = __name(function (d, b) {
        return extendStaticsFn = ObjClass.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) b[strHasOwnProperty](p) && (d[p] = b[p]);
        }, extendStaticsFn(d, b);
      }, "extendStaticsFn");
    function __extendsFn(d, b) {
      typeof b !== strShimFunction && b !== null && throwTypeError("Class extends value " + String(b) + " is not a constructor or null"), extendStaticsFn(d, b);
      function __() {
        this.constructor = d;
      }
      __name(__, "__"), d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    __name(__extendsFn, "__extendsFn");
    var _a,
      Constructor = "constructor",
      Prototype = "prototype",
      strFunction = "function",
      DynInstFuncTable = "_dynInstFuncs",
      DynProxyTag = "_isDynProxy",
      DynClassName = "_dynClass",
      DynClassNamePrefix = "_dynCls$",
      DynInstChkTag = "_dynInstChk",
      DynAllowInstChkTag = DynInstChkTag,
      DynProtoDefaultOptions = "_dfOpts",
      UnknownValue = "_unknown_",
      str__Proto = "__proto__",
      DynProtoBaseProto = "_dyn" + str__Proto,
      DynProtoGlobalSettings = "__dynProto$Gbl",
      DynProtoCurrent = "_dynInstProto",
      strUseBaseInst = "useBaseInst",
      strSetInstFuncs = "setInstFuncs",
      Obj = Object,
      _objGetPrototypeOf = Obj.getPrototypeOf,
      _objGetOwnProps = Obj.getOwnPropertyNames,
      _gbl = getGlobal(),
      _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
        n: 1e3
      });
    function _isObjectOrArrayPrototype(target) {
      return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    __name(_isObjectOrArrayPrototype, "_isObjectOrArrayPrototype");
    function _isObjectArrayOrFunctionPrototype(target) {
      return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    __name(_isObjectArrayOrFunctionPrototype, "_isObjectArrayOrFunctionPrototype");
    function _getObjProto(target) {
      var newProto;
      if (target) {
        if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        newProto = target[DynProtoBaseProto] || curProto, objHasOwnProperty(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], target[DynProtoCurrent] = curProto);
      }
      return newProto;
    }
    __name(_getObjProto, "_getObjProto");
    function _forEachProp(target, func) {
      var props = [];
      if (_objGetOwnProps) props = _objGetOwnProps(target);else for (var name_1 in target) typeof name_1 == "string" && objHasOwnProperty(target, name_1) && props.push(name_1);
      if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
    }
    __name(_forEachProp, "_forEachProp");
    function _isDynamicCandidate(target, funcName, skipOwn) {
      return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
    }
    __name(_isDynamicCandidate, "_isDynamicCandidate");
    function _throwTypeError(message) {
      throwTypeError("DynamicProto: " + message);
    }
    __name(_throwTypeError, "_throwTypeError");
    function _getInstanceFuncs(thisTarget) {
      var instFuncs = objCreate(null);
      return _forEachProp(thisTarget, function (name) {
        !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
      }), instFuncs;
    }
    __name(_getInstanceFuncs, "_getInstanceFuncs");
    function _hasVisited(values, value) {
      for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
      return !1;
    }
    __name(_hasVisited, "_hasVisited");
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
      function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFuncTable[DynAllowInstChkTag] !== !1 && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
        }
        return function () {
          return theFunc.apply(target, arguments);
        };
      }
      __name(_instFuncProxy, "_instFuncProxy");
      var baseFuncs = objCreate(null);
      _forEachProp(instFuncs, function (name) {
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
      });
      for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto);) _forEachProp(baseProto, function (name) {
        !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
      }), visited.push(baseProto), baseProto = _getObjProto(baseProto);
      return baseFuncs;
    }
    __name(_getBaseFuncs, "_getBaseFuncs");
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
      var instFunc = null;
      if (target && objHasOwnProperty(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || objCreate(null);
        if (instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName], instFunc || _throwTypeError("Missing [" + funcName + "] " + strFunction), !instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== !1) {
          for (var canAddInst = !objHasOwnProperty(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto);) {
            var protoFunc = objProto[funcName];
            if (protoFunc) {
              canAddInst = protoFunc === currentDynProtoProxy;
              break;
            }
            visited.push(objProto), objProto = _getObjProto(objProto);
          }
          try {
            canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
          } catch {
            instFuncTable[DynAllowInstChkTag] = !1;
          }
        }
      }
      return instFunc;
    }
    __name(_getInstFunc, "_getInstFunc");
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
      var protoFunc = proto[funcName];
      return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), protoFunc;
    }
    __name(_getProtoFunc, "_getProtoFunc");
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
      function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = __name(function () {
          var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
          return instFunc.apply(this, arguments);
        }, "dynProtoProxy");
        return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
      }
      if (__name(_createDynamicPrototype, "_createDynamicPrototype"), !_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
          instFuncTable[DynAllowInstChkTag] !== !1 && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), _isObjectOrArrayPrototype(instFuncs_1) || _forEachProp(target, function (name) {
            _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], delete target[name], (!objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
          });
        }
      }
    }
    __name(_populatePrototype, "_populatePrototype");
    function _checkPrototype(classProto, thisTarget) {
      if (_objGetPrototypeOf) {
        for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto);) {
          if (thisProto === classProto) return !0;
          visited.push(thisProto), thisProto = _getObjProto(thisProto);
        }
        return !1;
      }
      return !0;
    }
    __name(_checkPrototype, "_checkPrototype");
    function _getObjName(target, unknownValue) {
      return objHasOwnProperty(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
    }
    __name(_getObjName, "_getObjName");
    function dynamicProto(theClass, target, delegateFunc, options) {
      objHasOwnProperty(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
      var classProto = theClass[Prototype];
      _checkPrototype(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
      var className = null;
      objHasOwnProperty(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, _gblInst.n++, classProto[DynClassName] = className);
      var perfOptions = dynamicProto[DynProtoDefaultOptions],
        useBaseInst = !!perfOptions[strUseBaseInst];
      useBaseInst && options && options[strUseBaseInst] !== void 0 && (useBaseInst = !!options[strUseBaseInst]);
      var instFuncs = _getInstanceFuncs(target),
        baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
      delegateFunc(target, baseFuncs);
      var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
      setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== !1);
    }
    __name(dynamicProto, "dynamicProto"), dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
    var UNDEFINED_VALUE = void 0,
      STR_EMPTY = "",
      STR_NOT_DYNAMIC_ERROR = "Not dynamic - ",
      rCamelCase = /-([a-z])/g,
      rNormalizeInvalid = /([^\w\d_$])/g,
      rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
      return !isNullOrUndefined(value);
    }
    __name(isNotNullOrUndefined, "isNotNullOrUndefined");
    function normalizeJsName(name) {
      var value = name;
      return value && isString(value) && (value = value[_DYN_REPLACE](rCamelCase, function (_all, letter) {
        return letter.toUpperCase();
      }), value = value[_DYN_REPLACE](rNormalizeInvalid, "_"), value = value[_DYN_REPLACE](rLeadingNumeric, function (_all, match) {
        return "_" + match;
      })), value;
    }
    __name(normalizeJsName, "normalizeJsName");
    function strContains(value, search) {
      return value && search ? strIndexOf(value, search) !== -1 : !1;
    }
    __name(strContains, "strContains");
    function toISOString(date) {
      return date && date.toISOString() || "";
    }
    __name(toISOString, "toISOString");
    function getExceptionName(object) {
      return isError(object) ? object[_DYN_NAME] : STR_EMPTY;
    }
    __name(getExceptionName, "getExceptionName");
    function createClassFromInterface(defaults) {
      return function () {
        function class_1() {
          var _this = this;
          defaults && objForEachKey(defaults, function (field, value) {
            _this[field] = value;
          });
        }
        return __name(class_1, "class_1"), class_1;
      }();
    }
    __name(createClassFromInterface, "createClassFromInterface");
    var strConsole = "console",
      strJSON = "JSON",
      strCrypto = "crypto",
      strMsCrypto = "msCrypto",
      strMsie = "msie",
      strTrident = "trident/",
      _isTrident = null,
      _navUserAgentCheck = null,
      _beaconsSupported = null;
    function getConsole() {
      return typeof console !== strShimUndefined ? console : getInst(strConsole);
    }
    __name(getConsole, "getConsole");
    function hasJSON() {
      return !!(typeof JSON === strShimObject && JSON || getInst(strJSON) !== null);
    }
    __name(hasJSON, "hasJSON");
    function getJSON() {
      return hasJSON() ? JSON || getInst(strJSON) : null;
    }
    __name(getJSON, "getJSON");
    function getCrypto() {
      return getInst(strCrypto);
    }
    __name(getCrypto, "getCrypto");
    function getMsCrypto() {
      return getInst(strMsCrypto);
    }
    __name(getMsCrypto, "getMsCrypto");
    function isIE() {
      var nav = getNavigator();
      if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
        _navUserAgentCheck = nav[_DYN_USER_AGENT];
        var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
      }
      return _isTrident;
    }
    __name(isIE, "isIE");
    function isBeaconsSupported(useCached) {
      return (_beaconsSupported === null || useCached === !1) && (_beaconsSupported = hasNavigator() && !!getNavigator().sendBeacon), _beaconsSupported;
    }
    __name(isBeaconsSupported, "isBeaconsSupported");
    function _getNamedValue(values, name) {
      if (values) for (var i = 0; i < values[_DYN_LENGTH]; i++) {
        var value = values[i];
        if (value[_DYN_NAME] && value[_DYN_NAME] === name) return value;
      }
      return {};
    }
    __name(_getNamedValue, "_getNamedValue");
    function findMetaTag(name) {
      var doc = getDocument();
      return doc && name ? _getNamedValue(doc.querySelectorAll("meta"), name).content : null;
    }
    __name(findMetaTag, "findMetaTag");
    function findNamedServerTiming(name) {
      var value,
        perf = getPerformance();
      if (perf) {
        var navPerf = perf.getEntriesByType("navigation") || [];
        value = _getNamedValue((navPerf[_DYN_LENGTH] > 0 ? navPerf[0] : {}).serverTiming, name).description;
      }
      return value;
    }
    __name(findNamedServerTiming, "findNamedServerTiming");
    var UInt32Mask = 4294967296,
      MaxUInt32 = 4294967295,
      SEED1 = 123456789,
      SEED2 = 987654321,
      _mwcSeeded = !1,
      _mwcW = SEED1,
      _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
      seedValue < 0 && (seedValue >>>= 0), _mwcW = SEED1 + seedValue & MaxUInt32, _mwcZ = SEED2 - seedValue & MaxUInt32, _mwcSeeded = !0;
    }
    __name(_mwcSeed, "_mwcSeed");
    function _autoSeedMwc() {
      try {
        var now = utcNow() & 2147483647;
        _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
      } catch {}
    }
    __name(_autoSeedMwc, "_autoSeedMwc");
    function randomValue(maxValue) {
      return maxValue > 0 ? Math.floor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0 : 0;
    }
    __name(randomValue, "randomValue");
    function random32(signed) {
      var value = 0,
        c = getCrypto() || getMsCrypto();
      return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), value === 0 && isIE() && (_mwcSeeded || _autoSeedMwc(), value = mwcRandom32() & MaxUInt32), value === 0 && (value = Math.floor(UInt32Mask * Math.random() | 0)), signed || (value >>>= 0), value;
    }
    __name(random32, "random32");
    function mwcRandom32(signed) {
      _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32, _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
      var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
      return signed || (value >>>= 0), value;
    }
    __name(mwcRandom32, "mwcRandom32");
    function newId(maxLength) {
      maxLength === void 0 && (maxLength = 22);
      for (var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", number = random32() >>> 0, chars = 0, result = STR_EMPTY; result[_DYN_LENGTH] < maxLength;) chars++, result += base64chars.charAt(number & 63), number >>>= 6, chars === 5 && (number = (random32() << 2 & 4294967295 | number & 3) >>> 0, chars = 0);
      return result;
    }
    __name(newId, "newId");
    var version = "3.0.5",
      instanceName = "." + newId(6),
      _dataUid = 0;
    function _canAcceptData(target) {
      return target[_DYN_NODE_TYPE] === 1 || target[_DYN_NODE_TYPE] === 9 || !+target[_DYN_NODE_TYPE];
    }
    __name(_canAcceptData, "_canAcceptData");
    function _getCache(data, target) {
      var theCache = target[data.id];
      if (!theCache) {
        theCache = {};
        try {
          _canAcceptData(target) && objDefine(target, data.id, {
            e: !1,
            v: theCache
          });
        } catch {}
      }
      return theCache;
    }
    __name(_getCache, "_getCache");
    function createUniqueNamespace(name, includeVersion) {
      return includeVersion === void 0 && (includeVersion = !1), normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
    }
    __name(createUniqueNamespace, "createUniqueNamespace");
    function createElmNodeData(name) {
      var data = {
        id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
        accept: function (target) {
          return _canAcceptData(target);
        },
        get: function (target, name, defValue, addDefault) {
          var theCache = target[data.id];
          return theCache ? theCache[normalizeJsName(name)] : (addDefault && (theCache = _getCache(data, target), theCache[normalizeJsName(name)] = defValue), defValue);
        },
        kill: function (target, name) {
          if (target && target[name]) try {
            delete target[name];
          } catch {}
        }
      };
      return data;
    }
    __name(createElmNodeData, "createElmNodeData");
    function _isConfigDefaults(value) {
      return value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
    }
    __name(_isConfigDefaults, "_isConfigDefaults");
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
      var defValue,
        isDefaultValid = cfgDefaults.dfVal || isDefined;
      if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        isArray(fallbacks) || (fallbacks = [fallbacks]);
        for (var lp = 0; lp < fallbacks[_DYN_LENGTH]; lp++) {
          var fallback = fallbacks[lp],
            fbValue = theConfig[fallback];
          if (isDefaultValid(fbValue) ? defValue = fbValue : dynamicHandler && (fbValue = dynamicHandler.cfg[fallback], isDefaultValid(fbValue) && (defValue = fbValue), dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue)), isDefaultValid(defValue)) break;
        }
      }
      return !isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v) && (defValue = cfgDefaults.v), defValue;
    }
    __name(_getDefault, "_getDefault");
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
      var theValue = cfgDefaults;
      if (cfgDefaults && _isConfigDefaults(cfgDefaults) && (theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)), theValue) {
        _isConfigDefaults(theValue) && (theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue));
        var newValue_1;
        isArray(theValue) ? (newValue_1 = [], newValue_1[_DYN_LENGTH] = theValue[_DYN_LENGTH]) : isPlainObject(theValue) && (newValue_1 = {}), newValue_1 && (objForEachKey(theValue, function (key, value) {
          value && _isConfigDefaults(value) && (value = _resolveDefaultValue(dynamicHandler, theConfig, value)), newValue_1[key] = value;
        }), theValue = newValue_1);
      }
      return theValue;
    }
    __name(_resolveDefaultValue, "_resolveDefaultValue");
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
      var isValid,
        setFn,
        defValue,
        cfgDefaults = defaultValue,
        mergeDf,
        reference,
        readOnly,
        blkDynamicValue;
      _isConfigDefaults(cfgDefaults) ? (isValid = cfgDefaults.isVal, setFn = cfgDefaults.set, readOnly = cfgDefaults[_DYN_RD_ONLY], blkDynamicValue = cfgDefaults[_DYN_BLK_VAL], mergeDf = cfgDefaults.mrg, reference = cfgDefaults.ref, !reference && isUndefined(reference) && (reference = !!mergeDf), defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)) : defValue = defaultValue, blkDynamicValue && dynamicHandler[_DYN_BLK_VAL](theConfig, name);
      var theValue,
        usingDefault = !0,
        cfgValue = theConfig[name];
      (cfgValue || !isNullOrUndefined(cfgValue)) && (theValue = cfgValue, usingDefault = !1, isValid && theValue !== defValue && !isValid(theValue) && (theValue = defValue, usingDefault = !0), setFn && (theValue = setFn(theValue, defValue, theConfig), usingDefault = theValue === defValue)), usingDefault ? defValue ? theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue) : theValue = defValue : (isPlainObject(theValue) || isArray(defValue)) && mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue)) && objForEachKey(defValue, function (dfName, dfValue) {
        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
      }), dynamicHandler.set(theConfig, name, theValue), reference && dynamicHandler.ref(theConfig, name), readOnly && dynamicHandler[_DYN_RD_ONLY](theConfig, name);
    }
    __name(_applyDefaultValue, "_applyDefaultValue");
    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]"),
      BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]"),
      FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
      if (source) {
        var target_1;
        if (isArray(source) ? (target_1 = [], target_1[_DYN_LENGTH] = source[_DYN_LENGTH]) : isPlainObject(source) && (target_1 = {}), target_1) return objForEachKey(source, function (key, value) {
          target_1[key] = _cfgDeepCopy(value);
        }), target_1;
      }
      return source;
    }
    __name(_cfgDeepCopy, "_cfgDeepCopy");
    function getDynamicConfigHandler(value) {
      if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) return handler;
      }
      return null;
    }
    __name(getDynamicConfigHandler, "getDynamicConfigHandler");
    function blockDynamicConversion(value) {
      if (value && (isPlainObject(value) || isArray(value))) try {
        value[BLOCK_DYNAMIC] = !0;
      } catch {}
      return value;
    }
    __name(blockDynamicConversion, "blockDynamicConversion");
    function _canMakeDynamic(getFunc, state, value) {
      var result = !1;
      return value && !getFunc[state.blkVal] && (result = value[FORCE_DYNAMIC], !result && !value[BLOCK_DYNAMIC] && (result = isPlainObject(value) || isArray(value))), result;
    }
    __name(_canMakeDynamic, "_canMakeDynamic");
    function throwInvalidAccess(message) {
      throwTypeError("InvalidAccess:" + message);
    }
    __name(throwInvalidAccess, "throwInvalidAccess");
    var arrayMethodsToPatch = ["push", "pop", "shift", "unshift", "splice"],
      _throwDynamicError = __name(function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
      }, "_throwDynamicError");
    function _patchArray(state, target, name) {
      isArray(target) && arrForEach(arrayMethodsToPatch, function (method) {
        var orgMethod = target[method];
        target[method] = function () {
          for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          var result = orgMethod[_DYN_APPLY](this, args);
          return _makeDynamicObject(state, target, name, "Patching"), result;
        };
      });
    }
    __name(_patchArray, "_patchArray");
    function _getOwnPropGetter(target, name) {
      var propDesc = objGetOwnPropertyDescriptor(target, name);
      return propDesc && propDesc.get;
    }
    __name(_getOwnPropGetter, "_getOwnPropGetter");
    function _createDynamicProperty(state, theConfig, name, value) {
      var detail = {
          n: name,
          h: [],
          trk: function (handler) {
            handler && handler.fn && (arrIndexOf(detail.h, handler) === -1 && detail.h[_DYN_PUSH](handler), state.trk(handler, detail));
          },
          clr: function (handler) {
            var idx = arrIndexOf(detail.h, handler);
            idx !== -1 && detail.h[_DYN_SPLICE](idx, 1);
          }
        },
        checkDynamic = !0,
        isObjectOrArray = !1;
      function _getProperty() {
        checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), value && !value[CFG_HANDLER_LINK] && isObjectOrArray && (value = _makeDynamicObject(state, value, name, "Converting")), checkDynamic = !1);
        var activeHandler = state.act;
        return activeHandler && detail.trk(activeHandler), value;
      }
      __name(_getProperty, "_getProperty"), _getProperty[state.prop] = {
        chng: function () {
          state.add(detail);
        }
      };
      function _setProperty(newValue) {
        if (value !== newValue) {
          _getProperty[state.ro] && !state.upd && throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig)), checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), checkDynamic = !1);
          var isReferenced = isObjectOrArray && _getProperty[state.rf];
          if (isObjectOrArray) if (isReferenced) {
            objForEachKey(value, function (key) {
              value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
            });
            try {
              objForEachKey(newValue, function (key, theValue) {
                _setDynamicProperty(state, value, key, theValue);
              }), newValue = value;
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e), isObjectOrArray = !1;
            }
          } else value && value[CFG_HANDLER_LINK] && objForEachKey(value, function (key) {
            var getter = _getOwnPropGetter(value, key);
            if (getter) {
              var valueState = getter[state.prop];
              valueState && valueState.chng();
            }
          });
          if (newValue !== value) {
            var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
            !isReferenced && newIsObjectOrArray && (newValue = _makeDynamicObject(state, newValue, name, "Converting")), value = newValue, isObjectOrArray = newIsObjectOrArray;
          }
          state.add(detail);
        }
      }
      __name(_setProperty, "_setProperty"), objDefine(theConfig, detail.n, {
        g: _getProperty,
        s: _setProperty
      });
    }
    __name(_createDynamicProperty, "_createDynamicProperty");
    function _setDynamicProperty(state, target, name, value) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop];
        isDynamic ? target[name] = value : _createDynamicProperty(state, target, name, value);
      }
      return target;
    }
    __name(_setDynamicProperty, "_setDynamicProperty");
    function _setDynamicPropertyState(state, target, name, flags) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop],
          inPlace = flags && flags[0],
          rdOnly = flags && flags[1],
          blkProp = flags && flags[2];
        if (!isDynamic) {
          if (blkProp) try {
            blockDynamicConversion(target);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
          }
          try {
            _setDynamicProperty(state, target, name, target[name]), getter = _getOwnPropGetter(target, name);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
          }
        }
        inPlace && (getter[state.rf] = inPlace), rdOnly && (getter[state.ro] = rdOnly), blkProp && (getter[state.blkVal] = !0);
      }
      return target;
    }
    __name(_setDynamicPropertyState, "_setDynamicPropertyState");
    function _makeDynamicObject(state, target, name, desc) {
      try {
        objForEachKey(target, function (key, value) {
          _setDynamicProperty(state, target, key, value);
        }), target[CFG_HANDLER_LINK] || (objDefineProp(target, CFG_HANDLER_LINK, {
          get: function () {
            return state[_DYN_HDLR];
          }
        }), _patchArray(state, target, name));
      } catch (e) {
        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
      }
      return target;
    }
    __name(_makeDynamicObject, "_makeDynamicObject");
    var symPrefix = "[[ai_",
      symPostfix = "]]";
    function _createState(cfgHandler) {
      var _a,
        dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix),
        dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix),
        dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix),
        dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix),
        dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix),
        _waitingHandlers = null,
        _watcherTimer = null,
        theState;
      function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
          theState.act = activeHandler, activeHandler && activeHandler[dynamicPropertyDetail] && (arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
            detail.clr(activeHandler);
          }), activeHandler[dynamicPropertyDetail] = []), callback({
            cfg: cfgHandler.cfg,
            set: cfgHandler.set.bind(cfgHandler),
            setDf: cfgHandler[_DYN_SET_DF].bind(cfgHandler),
            ref: cfgHandler.ref.bind(cfgHandler),
            rdOnly: cfgHandler[_DYN_RD_ONLY].bind(cfgHandler)
          });
        } catch (e) {
          var logger = cfgHandler[_DYN_LOGGER];
          throw logger && logger[_DYN_THROW_INTERNAL](1, 107, dumpObj(e)), e;
        } finally {
          theState.act = prevWatcher || null;
        }
      }
      __name(_useHandler, "_useHandler");
      function _notifyWatchers() {
        if (_waitingHandlers) {
          var notifyHandlers = _waitingHandlers;
          _waitingHandlers = null, _watcherTimer && _watcherTimer[_DYN_CANCEL](), _watcherTimer = null;
          var watcherFailures_1 = [];
          if (arrForEach(notifyHandlers, function (handler) {
            if (handler && (handler[dynamicPropertyDetail] && (arrForEach(handler[dynamicPropertyDetail], function (detail) {
              detail.clr(handler);
            }), handler[dynamicPropertyDetail] = null), handler.fn)) try {
              _useHandler(handler, handler.fn);
            } catch (e) {
              watcherFailures_1[_DYN_PUSH](e);
            }
          }), _waitingHandlers) try {
            _notifyWatchers();
          } catch (e) {
            watcherFailures_1[_DYN_PUSH](e);
          }
          watcherFailures_1[_DYN_LENGTH] > 0 && throwAggregationError("Watcher error(s): ", watcherFailures_1);
        }
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _addWatcher(detail) {
        if (detail && detail.h[_DYN_LENGTH] > 0) {
          _waitingHandlers || (_waitingHandlers = []), _watcherTimer || (_watcherTimer = scheduleTimeout(function () {
            _watcherTimer = null, _notifyWatchers();
          }, 0));
          for (var idx = 0; idx < detail.h[_DYN_LENGTH]; idx++) {
            var handler = detail.h[idx];
            handler && arrIndexOf(_waitingHandlers, handler) === -1 && _waitingHandlers[_DYN_PUSH](handler);
          }
        }
      }
      __name(_addWatcher, "_addWatcher");
      function _trackHandler(handler, detail) {
        if (handler) {
          var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
          arrIndexOf(details, detail) === -1 && details[_DYN_PUSH](detail);
        }
      }
      return __name(_trackHandler, "_trackHandler"), theState = (_a = {
        prop: dynamicPropertySymbol,
        ro: dynamicPropertyReadOnly,
        rf: dynamicPropertyReferenced
      }, _a[_DYN_BLK_VAL] = dynamicPropertyBlockValue, _a[_DYN_HDLR] = cfgHandler, _a.add = _addWatcher, _a[_DYN_NOTIFY] = _notifyWatchers, _a.use = _useHandler, _a.trk = _trackHandler, _a), theState;
    }
    __name(_createState, "_createState");
    function _createAndUseHandler(state, configHandler) {
      var handler = {
        fn: configHandler,
        rm: function () {
          handler.fn = null, state = null, configHandler = null;
        }
      };
      return state.use(handler, configHandler), handler;
    }
    __name(_createAndUseHandler, "_createAndUseHandler");
    function _createDynamicHandler(logger, target, inPlace) {
      var _a,
        dynamicHandler = getDynamicConfigHandler(target);
      if (dynamicHandler) return dynamicHandler;
      var uid = createUniqueNamespace("dyncfg", !0),
        newTarget = target && inPlace !== !1 ? target : _cfgDeepCopy(target),
        theState;
      function _notifyWatchers() {
        theState[_DYN_NOTIFY]();
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _setValue(target, name, value) {
        try {
          target = _setDynamicProperty(theState, target, name, value);
        } catch (e) {
          _throwDynamicError(logger, name, "Setting value", e);
        }
        return target[name];
      }
      __name(_setValue, "_setValue");
      function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
      }
      __name(_watch, "_watch");
      function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
          var prevUpd = theState.upd;
          try {
            isUndefined(allowUpdate) || (theState.upd = allowUpdate), configHandler(details);
          } finally {
            theState.upd = prevUpd;
          }
        });
      }
      __name(_block, "_block");
      function _ref(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0] = !0, _a))[name];
      }
      __name(_ref, "_ref");
      function _rdOnly(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1] = !0, _a))[name];
      }
      __name(_rdOnly, "_rdOnly");
      function _blkPropValue(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2] = !0, _a))[name];
      }
      __name(_blkPropValue, "_blkPropValue");
      function _applyDefaults(theConfig, defaultValues) {
        return defaultValues && objForEachKey(defaultValues, function (name, value) {
          _applyDefaultValue(cfgHandler, theConfig, name, value);
        }), theConfig;
      }
      __name(_applyDefaults, "_applyDefaults");
      var cfgHandler = (_a = {
        uid: null,
        cfg: newTarget
      }, _a[_DYN_LOGGER] = logger, _a[_DYN_NOTIFY] = _notifyWatchers, _a.set = _setValue, _a[_DYN_SET_DF] = _applyDefaults, _a[_DYN_WATCH] = _watch, _a.ref = _ref, _a[_DYN_RD_ONLY] = _rdOnly, _a[_DYN_BLK_VAL] = _blkPropValue, _a._block = _block, _a);
      return objDefine(cfgHandler, "uid", {
        c: !1,
        e: !1,
        w: !1,
        v: uid
      }), theState = _createState(cfgHandler), _makeDynamicObject(theState, newTarget, "config", "Creating"), cfgHandler;
    }
    __name(_createDynamicHandler, "_createDynamicHandler");
    function _logInvalidAccess(logger, message) {
      logger ? (logger[_DYN_WARN_TO_CONSOLE](message), logger[_DYN_THROW_INTERNAL](2, 108, message)) : throwInvalidAccess(message);
    }
    __name(_logInvalidAccess, "_logInvalidAccess");
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
      var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
      return defaultConfig && dynamicHandler[_DYN_SET_DF](dynamicHandler.cfg, defaultConfig), dynamicHandler;
    }
    __name(createDynamicConfig, "createDynamicConfig");
    function onConfigChange(config, configHandler, logger) {
      var handler = config[CFG_HANDLER_LINK] || config;
      return handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler) ? handler[_DYN_WATCH](configHandler) : (_logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config)), createDynamicConfig(config, null, logger)[_DYN_WATCH](configHandler));
    }
    __name(onConfigChange, "onConfigChange");
    var _aiNamespace = null;
    function _getExtensionNamespace() {
      var target = getInst("Microsoft");
      return target && (_aiNamespace = target.ApplicationInsights), _aiNamespace;
    }
    __name(_getExtensionNamespace, "_getExtensionNamespace");
    function getDebugExt(config) {
      var ns = _aiNamespace;
      return !ns && config.disableDbgExt !== !0 && (ns = _aiNamespace || _getExtensionNamespace()), ns ? ns.ChromeDbgExt : null;
    }
    __name(getDebugExt, "getDebugExt");
    var _a,
      STR_WARN_TO_CONSOLE = "warnToConsole",
      AiNonUserActionablePrefix = "AI (Internal): ",
      AiUserActionablePrefix = "AI: ",
      AIInternalMessagePrefix = "AITR_",
      defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: !1
      },
      _logFuncs = (_a = {}, _a[0] = null, _a[1] = "errorToConsole", _a[2] = STR_WARN_TO_CONSOLE, _a[3] = "debugToConsole", _a);
    function _sanitizeDiagnosticText(text) {
      return text ? '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"' : STR_EMPTY;
    }
    __name(_sanitizeDiagnosticText, "_sanitizeDiagnosticText");
    function _logToConsole(func, message) {
      var theConsole = getConsole();
      if (theConsole) {
        var logFunc = "log";
        theConsole[func] && (logFunc = func), isFunction(theConsole[logFunc]) && theConsole[logFunc](message);
      }
    }
    __name(_logToConsole, "_logToConsole");
    var _InternalLogMessage = function () {
      function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        isUserAct === void 0 && (isUserAct = !1);
        var _self = this;
        _self[_DYN_MESSAGE_ID] = msgId, _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
        var strProps = STR_EMPTY;
        hasJSON() && (strProps = getJSON().stringify(properties));
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
        _self[_DYN_MESSAGE] += diagnosticText;
      }
      return __name(_InternalLogMessage, "_InternalLogMessage"), _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
    }();
    function safeGetLogger(core, config) {
      return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
    }
    __name(safeGetLogger, "safeGetLogger");
    var DiagnosticLogger = function () {
      function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger", this.queue = [];
        var _messageCount = 0,
          _messageLogged = {},
          _loggingLevelConsole,
          _loggingLevelTelemetry,
          _maxInternalMessageLimit,
          _enableDebug,
          _unloadHandler;
        dynamicProto(DiagnosticLogger, this, function (_self) {
          _unloadHandler = _setDefaultsFromConfig(config || {}), _self.consoleLoggingLevel = function () {
            return _loggingLevelConsole;
          }, _self[_DYN_THROW_INTERNAL] = function (severity, msgId, msg, properties, isUserAct) {
            isUserAct === void 0 && (isUserAct = !1);
            var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
            if (_enableDebug) throw dumpObj(message);
            var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
            if (isUndefined(message[_DYN_MESSAGE])) _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);else {
              if (isUserAct) {
                var messageKey = +message[_DYN_MESSAGE_ID];
                !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DYN_MESSAGE]), _messageLogged[messageKey] = !0);
              } else _loggingLevelConsole >= severity && _self[logFunc](message[_DYN_MESSAGE]);
              _logInternalMessage(severity, message);
            }
          }, _self.debugToConsole = function (message) {
            _logToConsole("debug", message), _debugExtMsg("warning", message);
          }, _self[_DYN_WARN_TO_CONSOLE] = function (message) {
            _logToConsole("warn", message), _debugExtMsg("warning", message);
          }, _self.errorToConsole = function (message) {
            _logToConsole("error", message), _debugExtMsg("error", message);
          }, _self.resetInternalMessageCount = function () {
            _messageCount = 0, _messageLogged = {};
          }, _self[_DYN_LOG_INTERNAL_MESSAGE] = _logInternalMessage, _self[_DYN_UNLOAD] = function (isAsync) {
            _unloadHandler && _unloadHandler.rm(), _unloadHandler = null;
          };
          function _logInternalMessage(severity, message) {
            if (!_areInternalMessagesThrottled()) {
              var logMessage = !0,
                messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
              if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DYN_PUSH](message), _messageCount++, _debugExtMsg(severity === 1 ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.",
                  throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
                _self.queue[_DYN_PUSH](throttleMessage), severity === 1 ? _self.errorToConsole(throttleLimitMessage) : _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
              }
            }
          }
          __name(_logInternalMessage, "_logInternalMessage");
          function _setDefaultsFromConfig(config) {
            return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {
              var config = details.cfg;
              _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4], _loggingLevelTelemetry = config.loggingLevelTelemetry, _maxInternalMessageLimit = config.maxMessageLimit, _enableDebug = config.enableDebug;
            });
          }
          __name(_setDefaultsFromConfig, "_setDefaultsFromConfig");
          function _areInternalMessagesThrottled() {
            return _messageCount >= _maxInternalMessageLimit;
          }
          __name(_areInternalMessagesThrottled, "_areInternalMessagesThrottled");
          function _debugExtMsg(name, data) {
            var dbgExt = getDebugExt(config || {});
            dbgExt && dbgExt[_DYN_DIAG_LOG] && dbgExt[_DYN_DIAG_LOG](name, data);
          }
          __name(_debugExtMsg, "_debugExtMsg");
        });
      }
      return __name(DiagnosticLogger, "DiagnosticLogger"), DiagnosticLogger.__ieDyn = 1, DiagnosticLogger;
    }();
    function _getLogger(logger) {
      return logger || new DiagnosticLogger();
    }
    __name(_getLogger, "_getLogger");
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
      isUserAct === void 0 && (isUserAct = !1), _getLogger(logger)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
    }
    __name(_throwInternal, "_throwInternal");
    function generateW3CId() {
      for (var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], oct = STR_EMPTY, tmp, a = 0; a < 4; a++) tmp = random32(), oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
      var clockSequenceHi = hexValues[8 + (random32() & 3) | 0];
      return strSubstr(oct, 0, 8) + strSubstr(oct, 9, 4) + "4" + strSubstr(oct, 13, 3) + clockSequenceHi + strSubstr(oct, 16, 3) + strSubstr(oct, 19, 12);
    }
    __name(generateW3CId, "generateW3CId");
    var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]{1,64})?$/i,
      DEFAULT_VERSION = "00",
      INVALID_VERSION = "ff",
      INVALID_TRACE_ID = "00000000000000000000000000000000",
      INVALID_SPAN_ID = "0000000000000000",
      SAMPLED_FLAG = 1;
    function _isValid(value, len, invalidValue) {
      return value && value[_DYN_LENGTH] === len && value !== invalidValue ? !!value.match(/^[\da-f]*$/i) : !1;
    }
    __name(_isValid, "_isValid");
    function _formatValue(value, len, defValue) {
      return _isValid(value, len) ? value : defValue;
    }
    __name(_formatValue, "_formatValue");
    function _formatFlags(value) {
      (isNaN(value) || value < 0 || value > 255) && (value = 1);
      for (var result = value.toString(16); result[_DYN_LENGTH] < 2;) result = "0" + result;
      return result;
    }
    __name(_formatFlags, "_formatFlags");
    function createTraceParent(traceId, spanId, flags, version) {
      var _a;
      return _a = {}, _a[_DYN_VERSION] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION, _a[_DYN_TRACE_ID] = isValidTraceId(traceId) ? traceId : generateW3CId(), _a[_DYN_SPAN_ID] = isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16), _a.traceFlags = flags >= 0 && flags <= 255 ? flags : 1, _a;
    }
    __name(createTraceParent, "createTraceParent");
    function parseTraceParent(value, selectIdx) {
      var _a;
      if (!value || (isArray(value) && (value = value[0] || ""), !value || !isString(value) || value[_DYN_LENGTH] > 8192)) return null;
      if (value.indexOf(",") !== -1) {
        var values = value[_DYN_SPLIT](",");
        value = values[selectIdx > 0 && values[_DYN_LENGTH] > selectIdx ? selectIdx : 0];
      }
      var match = TRACE_PARENT_REGEX.exec(strTrim(value));
      return !match || match[1] === INVALID_VERSION || match[2] === INVALID_TRACE_ID || match[3] === INVALID_SPAN_ID ? null : (_a = {
        version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE](),
        traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE](),
        spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE]()
      }, _a[_DYN_TRACE_FLAGS] = parseInt(match[4], 16), _a);
    }
    __name(parseTraceParent, "parseTraceParent");
    function isValidTraceId(value) {
      return _isValid(value, 32, INVALID_TRACE_ID);
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(value) {
      return _isValid(value, 16, INVALID_SPAN_ID);
    }
    __name(isValidSpanId, "isValidSpanId");
    function isValidTraceParent(value) {
      return !(!value || !_isValid(value[_DYN_VERSION], 2, INVALID_VERSION) || !_isValid(value[_DYN_TRACE_ID], 32, INVALID_TRACE_ID) || !_isValid(value[_DYN_SPAN_ID], 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS]), 2));
    }
    __name(isValidTraceParent, "isValidTraceParent");
    function isSampledFlag(value) {
      return isValidTraceParent(value) ? (value[_DYN_TRACE_FLAGS] & SAMPLED_FLAG) === SAMPLED_FLAG : !1;
    }
    __name(isSampledFlag, "isSampledFlag");
    function formatTraceParent(value) {
      if (value) {
        var flags = _formatFlags(value[_DYN_TRACE_FLAGS]);
        _isValid(flags, 2) || (flags = "01");
        var version = value[_DYN_VERSION] || DEFAULT_VERSION;
        return version !== "00" && version !== "ff" && (version = DEFAULT_VERSION), "".concat(version.toLowerCase(), "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), "-").concat(flags.toLowerCase());
      }
      return "";
    }
    __name(formatTraceParent, "formatTraceParent");
    function findW3cTraceParent(selectIdx) {
      var name = "traceparent",
        traceParent = parseTraceParent(findMetaTag(name), selectIdx);
      return traceParent || (traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx)), traceParent;
    }
    __name(findW3cTraceParent, "findW3cTraceParent");
    var strOnPrefix = "on",
      strAttachEvent = "attachEvent",
      strAddEventHelper = "addEventListener",
      strDetachEvent = "detachEvent",
      strRemoveEventListener = "removeEventListener",
      strEvents = "events";
    createUniqueNamespace("aiEvtPageHide"), createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g,
      rRemoveTrailingEmptyNs = /[\.]+$/,
      _guid = 1,
      elmNodeData = createElmNodeData("events"),
      eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
      return name && name[_DYN_REPLACE] ? name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY) : name;
    }
    __name(_normalizeNamespace, "_normalizeNamespace");
    function _getEvtNamespace(eventName, evtNamespace) {
      var _a;
      if (evtNamespace) {
        var theNamespace_1 = STR_EMPTY;
        isArray(evtNamespace) ? (theNamespace_1 = STR_EMPTY, arrForEach(evtNamespace, function (name) {
          name = _normalizeNamespace(name), name && (name[0] !== "." && (name = "." + name), theNamespace_1 += name);
        })) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && (theNamespace_1[0] !== "." && (theNamespace_1 = "." + theNamespace_1), eventName = (eventName || STR_EMPTY) + theNamespace_1);
      }
      var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
      return _a = {}, _a[_DYN_TYPE] = parsedEvent[1], _a.ns = (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT](".").sort().join("."), _a;
    }
    __name(_getEvtNamespace, "_getEvtNamespace");
    function _getRegisteredEvents(target, evtName, addDefault) {
      addDefault === void 0 && (addDefault = !0);
      var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault),
        registeredEvents = aiEvts[evtName];
      return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
    }
    __name(_getRegisteredEvents, "_getRegisteredEvents");
    function _doDetach(obj, evtName, handlerRef, useCapture) {
      obj && evtName && evtName[_DYN_TYPE] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef));
    }
    __name(_doDetach, "_doDetach");
    function _doAttach(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DYN_TYPE] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture), result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef), result = !0)), result;
    }
    __name(_doAttach, "_doAttach");
    function _doUnregister(target, events, evtName, unRegFn) {
      for (var idx = events[_DYN_LENGTH]; idx--;) {
        var theEvent = events[idx];
        theEvent && (!evtName.ns || evtName.ns === theEvent.evtName.ns) && (!unRegFn || unRegFn(theEvent)) && (_doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER], theEvent.capture), events[_DYN_SPLICE](idx, 1));
      }
    }
    __name(_doUnregister, "_doUnregister");
    function _unregisterEvents(target, evtName, unRegFn) {
      if (evtName[_DYN_TYPE]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        objForEachKey(eventCache, function (evtType, events) {
          _doUnregister(target, events, evtName, unRegFn);
        }), objKeys(eventCache)[_DYN_LENGTH] === 0 && elmNodeData.kill(target, strEvents);
      }
    }
    __name(_unregisterEvents, "_unregisterEvents");
    function mergeEvtNamespace(theNamespace, namespaces) {
      var newNamespaces;
      return namespaces ? (isArray(namespaces) ? newNamespaces = [theNamespace].concat(namespaces) : newNamespaces = [theNamespace, namespaces], newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".")) : newNamespaces = theNamespace, newNamespaces;
    }
    __name(mergeEvtNamespace, "mergeEvtNamespace");
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
      var _a;
      useCapture === void 0 && (useCapture = !1);
      var result = !1;
      if (target) try {
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        if (result = _doAttach(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
          var registeredEvent = (_a = {
            guid: _guid++,
            evtName: evtName
          }, _a[_DYN_HANDLER] = handlerRef, _a.capture = useCapture, _a);
          _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
        }
      } catch {}
      return result;
    }
    __name(eventOn, "eventOn");
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
      if (useCapture === void 0 && (useCapture = !1), target) try {
        var evtName_1 = _getEvtNamespace(eventName, evtNamespace),
          found_1 = !1;
        _unregisterEvents(target, evtName_1, function (regEvent) {
          return evtName_1.ns && !handlerRef || regEvent[_DYN_HANDLER] === handlerRef ? (found_1 = !0, !0) : !1;
        }), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
      } catch {}
    }
    __name(eventOff, "eventOff");
    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation",
      SampleRate = "sampleRate",
      ProcessLegacy = "ProcessLegacy",
      HttpMethod = "http.method",
      DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com",
      DEFAULT_BREEZE_PATH = "/v2/track",
      strNotSpecified = "not_specified",
      strIkey = "iKey",
      RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      }),
      _DYN_SPLIT = "split",
      _DYN_LENGTH = "length",
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_INGESTIONENDPOINT = "ingestionendpoint",
      _DYN_TO_STRING = "toString",
      _DYN_PUSH = "push",
      _DYN_REMOVE_ITEM = "removeItem",
      _DYN_NAME = "name",
      _DYN_MESSAGE = "message",
      _DYN_COUNT = "count",
      _DYN_PRE_TRIGGER_DATE = "preTriggerDate",
      _DYN_DISABLED = "disabled",
      _DYN_INTERVAL = "interval",
      _DYN_DAYS_OF_MONTH = "daysOfMonth",
      _DYN_DATE = "date",
      _DYN_GET_UTCDATE = "getUTCDate",
      _DYN_STRINGIFY = "stringify",
      _DYN_PATHNAME = "pathname",
      _DYN_CORRELATION_HEADER_E0 = "correlationHeaderExcludePatterns",
      _DYN_EXTENSION_CONFIG = "extensionConfig",
      _DYN_EXCEPTIONS = "exceptions",
      _DYN_PARSED_STACK = "parsedStack",
      _DYN_PROPERTIES = "properties",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_SIZE_IN_BYTES = "sizeInBytes",
      _DYN_TYPE_NAME = "typeName",
      _DYN_SEVERITY_LEVEL = "severityLevel",
      _DYN_PROBLEM_GROUP = "problemGroup",
      _DYN_IS_MANUAL = "isManual",
      _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface",
      _DYN_ASSEMBLY = "assembly",
      _DYN_FILE_NAME = "fileName",
      _DYN_HAS_FULL_STACK = "hasFullStack",
      _DYN_LEVEL = "level",
      _DYN_METHOD = "method",
      _DYN_LINE = "line",
      _DYN_DURATION = "duration",
      _DYN_RECEIVED_RESPONSE = "receivedResponse";
    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
      var origLength = key[_DYN_LENGTH],
        field = dataSanitizeKey(logger, key);
      if (field[_DYN_LENGTH] !== origLength) {
        for (var i = 0, uniqueField = field; map[uniqueField] !== void 0;) i++, uniqueField = strSubstring(field, 0, 147) + dsPadNumber(i);
        field = uniqueField;
      }
      return field;
    }
    __name(dataSanitizeKeyAndAddUniqueness, "dataSanitizeKeyAndAddUniqueness");
    function dataSanitizeKey(logger, name) {
      var nameTrunc;
      return name && (name = strTrim(asString(name)), name[_DYN_LENGTH] > 150 && (nameTrunc = strSubstring(name, 0, 150), _throwInternal(logger, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
        name: name
      }, !0))), nameTrunc || name;
    }
    __name(dataSanitizeKey, "dataSanitizeKey");
    function dataSanitizeString(logger, value, maxLength) {
      maxLength === void 0 && (maxLength = 1024);
      var valueTrunc;
      return value && (maxLength = maxLength || 1024, value = strTrim(asString(value)), value[_DYN_LENGTH] > maxLength && (valueTrunc = strSubstring(value, 0, maxLength), _throwInternal(logger, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", {
        value: value
      }, !0))), valueTrunc || value;
    }
    __name(dataSanitizeString, "dataSanitizeString");
    function dataSanitizeUrl(logger, url) {
      return dataSanitizeInput(logger, url, 2048, 66);
    }
    __name(dataSanitizeUrl, "dataSanitizeUrl");
    function dataSanitizeMessage(logger, message) {
      var messageTrunc;
      return message && message[_DYN_LENGTH] > 32768 && (messageTrunc = strSubstring(message, 0, 32768), _throwInternal(logger, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
        message: message
      }, !0)), messageTrunc || message;
    }
    __name(dataSanitizeMessage, "dataSanitizeMessage");
    function dataSanitizeException(logger, exception) {
      var exceptionTrunc;
      if (exception) {
        var value = "" + exception;
        value[_DYN_LENGTH] > 32768 && (exceptionTrunc = strSubstring(value, 0, 32768), _throwInternal(logger, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
          exception: exception
        }, !0));
      }
      return exceptionTrunc || exception;
    }
    __name(dataSanitizeException, "dataSanitizeException");
    function dataSanitizeProperties(logger, properties) {
      if (properties) {
        var tempProps_1 = {};
        objForEachKey(properties, function (prop, value) {
          if (isObject(value) && hasJSON()) try {
            value = getJSON()[_DYN_STRINGIFY](value);
          } catch (e) {
            _throwInternal(logger, 2, 49, "custom property is not valid", {
              exception: e
            }, !0);
          }
          value = dataSanitizeString(logger, value, 8192), prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1), tempProps_1[prop] = value;
        }), properties = tempProps_1;
      }
      return properties;
    }
    __name(dataSanitizeProperties, "dataSanitizeProperties");
    function dataSanitizeMeasurements(logger, measurements) {
      if (measurements) {
        var tempMeasurements_1 = {};
        objForEachKey(measurements, function (measure, value) {
          measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1), tempMeasurements_1[measure] = value;
        }), measurements = tempMeasurements_1;
      }
      return measurements;
    }
    __name(dataSanitizeMeasurements, "dataSanitizeMeasurements");
    function dataSanitizeId(logger, id) {
      return id && dataSanitizeInput(logger, id, 128, 69)[_DYN_TO_STRING]();
    }
    __name(dataSanitizeId, "dataSanitizeId");
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
      var inputTrunc;
      return input && (input = strTrim(asString(input)), input[_DYN_LENGTH] > maxLength && (inputTrunc = strSubstring(input, 0, maxLength), _throwInternal(logger, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", {
        data: input
      }, !0))), inputTrunc || input;
    }
    __name(dataSanitizeInput, "dataSanitizeInput");
    function dsPadNumber(num) {
      var s = "00" + num;
      return strSubstr(s, s[_DYN_LENGTH] - 3);
    }
    __name(dsPadNumber, "dsPadNumber");
    var _document = getDocument() || {},
      _htmlAnchorIdx = 0,
      _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
      var anchorIdx = _htmlAnchorIdx,
        anchorCache = _htmlAnchorElement,
        tempAnchor = anchorCache[anchorIdx];
      return _document.createElement ? anchorCache[anchorIdx] || (tempAnchor = anchorCache[anchorIdx] = _document.createElement("a")) : tempAnchor = {
        host: urlParseHost(url, !0)
      }, tempAnchor.href = url, anchorIdx++, anchorIdx >= anchorCache[_DYN_LENGTH] && (anchorIdx = 0), _htmlAnchorIdx = anchorIdx, tempAnchor;
    }
    __name(urlParseUrl, "urlParseUrl");
    function urlGetAbsoluteUrl(url) {
      var result,
        a = urlParseUrl(url);
      return a && (result = a.href), result;
    }
    __name(urlGetAbsoluteUrl, "urlGetAbsoluteUrl");
    function urlGetPathName(url) {
      var result,
        a = urlParseUrl(url);
      return a && (result = a[_DYN_PATHNAME]), result;
    }
    __name(urlGetPathName, "urlGetPathName");
    function urlGetCompleteUrl(method, absoluteUrl) {
      return method ? method.toUpperCase() + " " + absoluteUrl : absoluteUrl;
    }
    __name(urlGetCompleteUrl, "urlGetCompleteUrl");
    function urlParseHost(url, inclPort) {
      var fullHost = urlParseFullHost(url, inclPort) || "";
      if (fullHost) {
        var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 3 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) return match[2] + (match[3] || "");
      }
      return fullHost;
    }
    __name(urlParseHost, "urlParseHost");
    function urlParseFullHost(url, inclPort) {
      var result = null;
      if (url) {
        var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 2 && isString(match[2]) && match[2][_DYN_LENGTH] > 0 && (result = match[2] || "", inclPort && match[_DYN_LENGTH] > 2)) {
          var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE](),
            port = match[3] || "";
          (protocol === "http" && port === ":80" || protocol === "https" && port === ":443") && (port = ""), result += port;
        }
      }
      return result;
    }
    __name(urlParseFullHost, "urlParseFullHost");
    var _internalEndpoints = [DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH, "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH, "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH],
      _correlationIdPrefix = "cid-v1:";
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
      return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
    }
    __name(isInternalApplicationInsightsEndpoint, "isInternalApplicationInsightsEndpoint");
    function correlationIdSetPrefix(prefix) {
      _correlationIdPrefix = prefix;
    }
    __name(correlationIdSetPrefix, "correlationIdSetPrefix");
    function correlationIdGetPrefix() {
      return _correlationIdPrefix;
    }
    __name(correlationIdGetPrefix, "correlationIdGetPrefix");
    function correlationIdCanIncludeCorrelationHeader(config, requestUrl, currentHost) {
      if (!requestUrl || config && config.disableCorrelationHeaders) return !1;
      if (config && config[_DYN_CORRELATION_HEADER_E0]) {
        for (var i = 0; i < config.correlationHeaderExcludePatterns[_DYN_LENGTH]; i++) if (config[_DYN_CORRELATION_HEADER_E0][i].test(requestUrl)) return !1;
      }
      var requestHost = urlParseUrl(requestUrl).host[_DYN_TO_LOWER_CASE]();
      if (requestHost && (strIndexOf(requestHost, ":443") !== -1 || strIndexOf(requestHost, ":80") !== -1) && (requestHost = (urlParseFullHost(requestUrl, !0) || "")[_DYN_TO_LOWER_CASE]()), (!config || !config.enableCorsCorrelation) && requestHost && requestHost !== currentHost) return !1;
      var includedDomains = config && config.correlationHeaderDomains;
      if (includedDomains) {
        var matchExists_1;
        if (arrForEach(includedDomains, function (domain) {
          var regex = new RegExp(domain.toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
          matchExists_1 = matchExists_1 || regex.test(requestHost);
        }), !matchExists_1) return !1;
      }
      var excludedDomains = config && config.correlationHeaderExcludedDomains;
      if (!excludedDomains || excludedDomains[_DYN_LENGTH] === 0) return !0;
      for (var i = 0; i < excludedDomains[_DYN_LENGTH]; i++) {
        var regex = new RegExp(excludedDomains[i].toLowerCase().replace(/\\/g, "\\\\").replace(/\./g, "\\.").replace(/\*/g, ".*"));
        if (regex.test(requestHost)) return !1;
      }
      return requestHost && requestHost[_DYN_LENGTH] > 0;
    }
    __name(correlationIdCanIncludeCorrelationHeader, "correlationIdCanIncludeCorrelationHeader");
    function correlationIdGetCorrelationContext(responseHeader) {
      if (responseHeader) {
        var correlationId = correlationIdGetCorrelationContextValue(responseHeader, RequestHeaders[1]);
        if (correlationId && correlationId !== _correlationIdPrefix) return correlationId;
      }
    }
    __name(correlationIdGetCorrelationContext, "correlationIdGetCorrelationContext");
    function correlationIdGetCorrelationContextValue(responseHeader, key) {
      if (responseHeader) for (var keyValues = responseHeader[_DYN_SPLIT](","), i = 0; i < keyValues[_DYN_LENGTH]; ++i) {
        var keyValue = keyValues[i][_DYN_SPLIT]("=");
        if (keyValue[_DYN_LENGTH] === 2 && keyValue[0] === key) return keyValue[1];
      }
    }
    __name(correlationIdGetCorrelationContextValue, "correlationIdGetCorrelationContextValue");
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
      var target,
        name = commandName,
        data = commandName;
      if (absoluteUrl && absoluteUrl[_DYN_LENGTH] > 0) {
        var parsedUrl = urlParseUrl(absoluteUrl);
        if (target = parsedUrl.host, !name) if (parsedUrl[_DYN_PATHNAME] != null) {
          var pathName = parsedUrl.pathname[_DYN_LENGTH] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
          pathName.charAt(0) !== "/" && (pathName = "/" + pathName), data = parsedUrl[_DYN_PATHNAME], name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
        } else name = dataSanitizeString(logger, absoluteUrl);
      } else target = commandName, name = commandName;
      return {
        target: target,
        name: name,
        data: data
      };
    }
    __name(AjaxHelperParseDependencyPath, "AjaxHelperParseDependencyPath");
    function dateTimeUtilsNow() {
      var perf = getPerformance();
      if (perf && perf.now && perf.timing) {
        var now = perf.now() + perf.timing.navigationStart;
        if (now > 0) return now;
      }
      return dateNow();
    }
    __name(dateTimeUtilsNow, "dateTimeUtilsNow");
    function dateTimeUtilsDuration(start, end) {
      var result = null;
      return start !== 0 && end !== 0 && !isNullOrUndefined(start) && !isNullOrUndefined(end) && (result = end - start), result;
    }
    __name(dateTimeUtilsDuration, "dateTimeUtilsDuration");
    function createDistributedTraceContextFromTrace(telemetryTrace, parentCtx) {
      var trace = telemetryTrace || {};
      return {
        getName: function () {
          return trace[_DYN_NAME];
        },
        setName: function (newValue) {
          parentCtx && parentCtx.setName(newValue), trace[_DYN_NAME] = newValue;
        },
        getTraceId: function () {
          return trace.traceID;
        },
        setTraceId: function (newValue) {
          parentCtx && parentCtx.setTraceId(newValue), isValidTraceId(newValue) && (trace.traceID = newValue);
        },
        getSpanId: function () {
          return trace.parentID;
        },
        setSpanId: function (newValue) {
          parentCtx && parentCtx.setSpanId(newValue), isValidSpanId(newValue) && (trace.parentID = newValue);
        },
        getTraceFlags: function () {
          return trace.traceFlags;
        },
        setTraceFlags: function (newTraceFlags) {
          parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace.traceFlags = newTraceFlags;
        }
      };
    }
    __name(createDistributedTraceContextFromTrace, "createDistributedTraceContextFromTrace");
    var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      }),
      DistributedTracingModes = createEnumStyle({
        AI: 0,
        AI_AND_W3C: 1,
        W3C: 2
      }),
      EventPersistence = createEnumStyle({
        Normal: 1,
        Critical: 2
      }),
      _canUseLocalStorage = void 0,
      _canUseSessionStorage = void 0,
      _storagePrefix = "";
    function _getLocalStorageObject() {
      return utlCanUseLocalStorage() ? _getVerifiedStorageObject(StorageType.LocalStorage) : null;
    }
    __name(_getLocalStorageObject, "_getLocalStorageObject");
    function _getVerifiedStorageObject(storageType) {
      try {
        if (isNullOrUndefined(getGlobal())) return null;
        var uid = new Date()[_DYN_TO_STRING](),
          storage = getGlobalInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage"),
          name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        if (storage[_DYN_REMOVE_ITEM](name_1), !fail) return storage;
      } catch {}
      return null;
    }
    __name(_getVerifiedStorageObject, "_getVerifiedStorageObject");
    function _getSessionStorageObject() {
      return utlCanUseSessionStorage() ? _getVerifiedStorageObject(StorageType.SessionStorage) : null;
    }
    __name(_getSessionStorageObject, "_getSessionStorageObject");
    function utlDisableStorage() {
      _canUseLocalStorage = !1, _canUseSessionStorage = !1;
    }
    __name(utlDisableStorage, "utlDisableStorage");
    function utlSetStoragePrefix(storagePrefix) {
      _storagePrefix = storagePrefix || "";
    }
    __name(utlSetStoragePrefix, "utlSetStoragePrefix");
    function utlEnableStorage() {
      _canUseLocalStorage = utlCanUseLocalStorage(!0), _canUseSessionStorage = utlCanUseSessionStorage(!0);
    }
    __name(utlEnableStorage, "utlEnableStorage");
    function utlCanUseLocalStorage(reset) {
      return (reset || _canUseLocalStorage === void 0) && (_canUseLocalStorage = !!_getVerifiedStorageObject(StorageType.LocalStorage)), _canUseLocalStorage;
    }
    __name(utlCanUseLocalStorage, "utlCanUseLocalStorage");
    function utlGetLocalStorage(logger, name) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 1, "Browser failed read of local storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetLocalStorage, "utlGetLocalStorage");
    function utlSetLocalStorage(logger, name, data) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 3, "Browser failed write to local storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetLocalStorage, "utlSetLocalStorage");
    function utlRemoveStorage(logger, name) {
      var storage = _getLocalStorageObject();
      if (storage !== null) try {
        return storage[_DYN_REMOVE_ITEM](name), !0;
      } catch (e) {
        _canUseLocalStorage = !1, _throwInternal(logger, 2, 5, "Browser failed removal of local storage item. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlRemoveStorage, "utlRemoveStorage");
    function utlCanUseSessionStorage(reset) {
      return (reset || _canUseSessionStorage === void 0) && (_canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage)), _canUseSessionStorage;
    }
    __name(utlCanUseSessionStorage, "utlCanUseSessionStorage");
    function utlGetSessionStorageKeys() {
      var keys = [];
      return utlCanUseSessionStorage() && objForEachKey(getGlobalInst("sessionStorage"), function (key) {
        keys[_DYN_PUSH](key);
      }), keys;
    }
    __name(utlGetSessionStorageKeys, "utlGetSessionStorageKeys");
    function utlGetSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetSessionStorage, "utlGetSessionStorage");
    function utlSetSessionStorage(logger, name, data) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetSessionStorage, "utlSetSessionStorage");
    function utlRemoveSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage[_DYN_REMOVE_ITEM](name), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 6, "Browser failed removal of session storage item. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlRemoveSessionStorage, "utlRemoveSessionStorage");
    var THROTTLE_STORAGE_PREFIX = "appInsightsThrottle",
      ThrottleMgr = function () {
        function ThrottleMgr(core, namePrefix) {
          var _self = this,
            _canUseLocalStorage,
            _logger,
            _config,
            _localStorageObj,
            _isTriggered,
            _namePrefix,
            _queue,
            _isReady = !1,
            _isSpecificDaysGiven = !1;
          _initConfig(), _self._getDbgPlgTargets = function () {
            return [_queue];
          }, _self.getConfig = function () {
            return _config;
          }, _self.canThrottle = function (msgId) {
            var localObj = _getLocalStorageObjByKey(msgId),
              cfg = _getCfgByKey(msgId);
            return _canThrottle(cfg, _canUseLocalStorage, localObj);
          }, _self.isTriggered = function (msgId) {
            return _isTrigger(msgId);
          }, _self.isReady = function () {
            return _isReady;
          }, _self.flush = function (msgId) {
            try {
              var queue = _getQueueByKey(msgId);
              if (queue && queue[_DYN_LENGTH] > 0) {
                var items = queue.slice(0);
                return _queue[msgId] = [], arrForEach(items, function (item) {
                  _flushMessage(item.msgID, item[_DYN_MESSAGE], item.severity, !1);
                }), !0;
              }
            } catch {}
            return !1;
          }, _self.flushAll = function () {
            try {
              if (_queue) {
                var result_1 = !0;
                return objForEachKey(_queue, function (key) {
                  var isFlushed = _self.flush(parseInt(key));
                  result_1 = result_1 && isFlushed;
                }), result_1;
              }
            } catch {}
            return !1;
          }, _self.onReadyState = function (isReady, flushAll) {
            return flushAll === void 0 && (flushAll = !0), _isReady = isNullOrUndefined(isReady) ? !0 : isReady, _isReady && flushAll ? _self.flushAll() : null;
          }, _self.sendMessage = function (msgID, message, severity) {
            return _flushMessage(msgID, message, severity, !0);
          };
          function _flushMessage(msgID, message, severity, saveUnsentMsg) {
            if (_isReady) {
              var isSampledIn = _canSampledIn(msgID);
              if (!isSampledIn) return;
              var cfg = _getCfgByKey(msgID),
                localStorageObj = _getLocalStorageObjByKey(msgID),
                canThrottle = _canThrottle(cfg, _canUseLocalStorage, localStorageObj),
                throttled = !1,
                number = 0,
                isTriggered = _isTrigger(msgID);
              try {
                canThrottle && !isTriggered ? (number = Math.min(cfg.limit.maxSendNumber, localStorageObj[_DYN_COUNT] + 1), localStorageObj[_DYN_COUNT] = 0, throttled = !0, _isTriggered[msgID] = !0, localStorageObj[_DYN_PRE_TRIGGER_DATE] = new Date()) : (_isTriggered[msgID] = canThrottle, localStorageObj[_DYN_COUNT] += 1);
                var localStorageName = _getLocalStorageName(msgID);
                _resetLocalStorage(_logger, localStorageName, localStorageObj);
                for (var i = 0; i < number; i++) _sendMessage(msgID, _logger, message, severity);
              } catch {}
              return {
                isThrottled: throttled,
                throttleNum: number
              };
            } else if (saveUnsentMsg) {
              var queue = _getQueueByKey(msgID);
              queue[_DYN_PUSH]({
                msgID: msgID,
                message: message,
                severity: severity
              });
            }
            return null;
          }
          __name(_flushMessage, "_flushMessage");
          function _initConfig() {
            _logger = safeGetLogger(core), _isTriggered = {}, _localStorageObj = {}, _queue = {}, _config = {}, _setCfgByKey(109), _namePrefix = isNotNullOrUndefined(namePrefix) ? namePrefix : "", core.addUnloadHook(onConfigChange(core.config, function (details) {
              var coreConfig = details.cfg;
              _canUseLocalStorage = utlCanUseLocalStorage();
              var configMgr = coreConfig.throttleMgrCfg || {};
              objForEachKey(configMgr, function (key, cfg) {
                _setCfgByKey(parseInt(key), cfg);
              });
            }));
          }
          __name(_initConfig, "_initConfig");
          function _getCfgByKey(msgID) {
            return _config[msgID] || _config[109];
          }
          __name(_getCfgByKey, "_getCfgByKey");
          function _setCfgByKey(msgID, config) {
            var _a, _b;
            try {
              var cfg = config || {},
                curCfg = {};
              curCfg[_DYN_DISABLED] = !!cfg[_DYN_DISABLED];
              var configInterval = cfg[_DYN_INTERVAL] || {};
              _isSpecificDaysGiven = (configInterval == null ? void 0 : configInterval.daysOfMonth) && (configInterval == null ? void 0 : configInterval.daysOfMonth[_DYN_LENGTH]) > 0, curCfg[_DYN_INTERVAL] = _getIntervalConfig(configInterval);
              var limit = {
                samplingRate: ((_a = cfg.limit) === null || _a === void 0 ? void 0 : _a.samplingRate) || 100,
                maxSendNumber: ((_b = cfg.limit) === null || _b === void 0 ? void 0 : _b.maxSendNumber) || 1
              };
              curCfg.limit = limit, _config[msgID] = curCfg;
            } catch {}
          }
          __name(_setCfgByKey, "_setCfgByKey");
          function _getIntervalConfig(interval) {
            interval = interval || {};
            var monthInterval = interval == null ? void 0 : interval.monthInterval,
              dayInterval = interval == null ? void 0 : interval.dayInterval;
            return isNullOrUndefined(monthInterval) && isNullOrUndefined(dayInterval) && (interval.monthInterval = 3, _isSpecificDaysGiven || (interval[_DYN_DAYS_OF_MONTH] = [28], _isSpecificDaysGiven = !0)), interval = {
              monthInterval: interval == null ? void 0 : interval.monthInterval,
              dayInterval: interval == null ? void 0 : interval.dayInterval,
              daysOfMonth: interval == null ? void 0 : interval.daysOfMonth
            }, interval;
          }
          __name(_getIntervalConfig, "_getIntervalConfig");
          function _canThrottle(config, canUseLocalStorage, localStorageObj) {
            if (config && !config[_DYN_DISABLED] && canUseLocalStorage && isNotNullOrUndefined(localStorageObj)) {
              var curDate = _getThrottleDate(),
                date = localStorageObj[_DYN_DATE],
                interval = config[_DYN_INTERVAL],
                monthCheck = 1;
              if (interval != null && interval.monthInterval) {
                var monthExpand = (curDate.getUTCFullYear() - date.getUTCFullYear()) * 12 + curDate.getUTCMonth() - date.getUTCMonth();
                monthCheck = _checkInterval(interval.monthInterval, 0, monthExpand);
              }
              var dayCheck = 1;
              if (_isSpecificDaysGiven) dayCheck = arrIndexOf(interval[_DYN_DAYS_OF_MONTH], curDate[_DYN_GET_UTCDATE]());else if (interval != null && interval.dayInterval) {
                var daySpan = Math.floor((curDate.getTime() - date.getTime()) / 864e5);
                dayCheck = _checkInterval(interval.dayInterval, 0, daySpan);
              }
              return monthCheck >= 0 && dayCheck >= 0;
            }
            return !1;
          }
          __name(_canThrottle, "_canThrottle");
          function _getLocalStorageName(msgKey, prefix) {
            var fix = isNotNullOrUndefined(prefix) ? prefix : "";
            return msgKey ? THROTTLE_STORAGE_PREFIX + fix + "-" + msgKey : null;
          }
          __name(_getLocalStorageName, "_getLocalStorageName");
          function _isTriggeredOnCurDate(preTriggerDate) {
            try {
              if (preTriggerDate) {
                var curDate = new Date();
                return preTriggerDate.getUTCFullYear() === curDate.getUTCFullYear() && preTriggerDate.getUTCMonth() === curDate.getUTCMonth() && preTriggerDate[_DYN_GET_UTCDATE]() === curDate[_DYN_GET_UTCDATE]();
              }
            } catch {}
            return !1;
          }
          __name(_isTriggeredOnCurDate, "_isTriggeredOnCurDate");
          function _getLocalStorageObj(value, logger, storageName) {
            try {
              var storageObj = {
                date: _getThrottleDate(),
                count: 0
              };
              if (value) {
                var obj = JSON.parse(value),
                  curObj = {
                    date: _getThrottleDate(obj[_DYN_DATE]) || storageObj[_DYN_DATE],
                    count: obj[_DYN_COUNT] || storageObj[_DYN_COUNT],
                    preTriggerDate: obj.preTriggerDate ? _getThrottleDate(obj[_DYN_PRE_TRIGGER_DATE]) : void 0
                  };
                return curObj;
              } else return _resetLocalStorage(logger, storageName, storageObj), storageObj;
            } catch {}
            return null;
          }
          __name(_getLocalStorageObj, "_getLocalStorageObj");
          function _getThrottleDate(dateStr) {
            try {
              if (dateStr) {
                var date = new Date(dateStr);
                if (!isNaN(date.getDate())) return date;
              } else return new Date();
            } catch {}
            return null;
          }
          __name(_getThrottleDate, "_getThrottleDate");
          function _resetLocalStorage(logger, storageName, obj) {
            try {
              return utlSetLocalStorage(logger, storageName, strTrim(JSON[_DYN_STRINGIFY](obj)));
            } catch {}
            return !1;
          }
          __name(_resetLocalStorage, "_resetLocalStorage");
          function _checkInterval(interval, start, current) {
            return interval <= 0 ? 1 : current >= start && (current - start) % interval == 0 ? Math.floor((current - start) / interval) + 1 : -1;
          }
          __name(_checkInterval, "_checkInterval");
          function _sendMessage(msgID, logger, message, severity) {
            _throwInternal(logger, severity || 1, msgID, message);
          }
          __name(_sendMessage, "_sendMessage");
          function _canSampledIn(msgID) {
            try {
              var cfg = _getCfgByKey(msgID);
              return randomValue(1e6) <= cfg.limit.samplingRate;
            } catch {}
            return !1;
          }
          __name(_canSampledIn, "_canSampledIn");
          function _getLocalStorageObjByKey(key) {
            try {
              var curObj = _localStorageObj[key];
              if (!curObj) {
                var localStorageName = _getLocalStorageName(key, _namePrefix);
                curObj = _getLocalStorageObj(utlGetLocalStorage(_logger, localStorageName), _logger, localStorageName), _localStorageObj[key] = curObj;
              }
              return _localStorageObj[key];
            } catch {}
            return null;
          }
          __name(_getLocalStorageObjByKey, "_getLocalStorageObjByKey");
          function _isTrigger(key) {
            var isTrigger = _isTriggered[key];
            if (isNullOrUndefined(isTrigger)) {
              isTrigger = !1;
              var localStorageObj = _getLocalStorageObjByKey(key);
              localStorageObj && (isTrigger = _isTriggeredOnCurDate(localStorageObj[_DYN_PRE_TRIGGER_DATE])), _isTriggered[key] = isTrigger;
            }
            return _isTriggered[key];
          }
          __name(_isTrigger, "_isTrigger");
          function _getQueueByKey(key) {
            return _queue = _queue || {}, isNullOrUndefined(_queue[key]) && (_queue[key] = []), _queue[key];
          }
          __name(_getQueueByKey, "_getQueueByKey");
        }
        return __name(ThrottleMgr, "ThrottleMgr"), ThrottleMgr;
      }(),
      _FIELDS_SEPARATOR = ";",
      _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
      if (!connectionString) return {};
      var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR),
        result = arrReduce(kvPairs, function (fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE](),
              value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
      if (objKeys(result)[_DYN_LENGTH] > 0) {
        if (result.endpointsuffix) {
          var locationPrefix = result.location ? result.location + "." : "";
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
        }
        result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT, strEndsWith(result[_DYN_INGESTIONENDPOINT], "/") && (result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1));
      }
      return result;
    }
    __name(parseConnectionString, "parseConnectionString");
    var ConnectionStringParser = {
        parse: parseConnectionString
      },
      Envelope = function () {
        function Envelope(logger, data, name) {
          var _this = this,
            _self = this;
          _self.ver = 1, _self.sampleRate = 100, _self.tags = {}, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self.data = data, _self.time = toISOString(new Date()), _self.aiDataContract = {
            time: 1,
            iKey: 1,
            name: 1,
            sampleRate: function () {
              return _this.sampleRate === 100 ? 4 : 1;
            },
            tags: 1,
            data: 1
          };
        }
        return __name(Envelope, "Envelope"), Envelope;
      }(),
      Event = function () {
        function Event(logger, name, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            name: 1,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Event, "Event"), Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", Event.dataType = "EventData", Event;
      }(),
      NoMethod = "<no_method>",
      strError = "error",
      strStack = "stack",
      strStackDetails = "stackDetails",
      strErrorSrc = "errorSrc",
      strMessage = "message",
      strDescription = "description";
    function _stringify(value, convertToString) {
      var result = value;
      return result && !isString(result) && (JSON && JSON[_DYN_STRINGIFY] ? (result = JSON[_DYN_STRINGIFY](value), convertToString && (!result || result === "{}") && (isFunction(value[_DYN_TO_STRING]) ? result = value[_DYN_TO_STRING]() : result = "" + value)) : result = "" + value + " - (Missing JSON.stringify)"), result || "";
    }
    __name(_stringify, "_stringify");
    function _formatMessage(theEvent, errorType) {
      var evtMessage = theEvent;
      return theEvent && (evtMessage && !isString(evtMessage) && (evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage), evtMessage && !isString(evtMessage) && (evtMessage = _stringify(evtMessage, !0)), theEvent.filename && (evtMessage = evtMessage + " @" + (theEvent.filename || "") + ":" + (theEvent.lineno || "?") + ":" + (theEvent.colno || "?"))), errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1 && (evtMessage = errorType + ": " + evtMessage), evtMessage || "";
    }
    __name(_formatMessage, "_formatMessage");
    function _isExceptionDetailsInternal(value) {
      try {
        if (isObject(value)) return "hasFullStack" in value && "typeName" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionDetailsInternal, "_isExceptionDetailsInternal");
    function _isExceptionInternal(value) {
      try {
        if (isObject(value)) return "ver" in value && "exceptions" in value && "properties" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionInternal, "_isExceptionInternal");
    function _isStackDetails(details) {
      return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    __name(_isStackDetails, "_isStackDetails");
    function _convertStackObj(errorStack) {
      var src = errorStack || "";
      isString(src) || (isString(src[strStack]) ? src = src[strStack] : src = "" + src);
      var items = src[_DYN_SPLIT](`
`);
      return {
        src: src,
        obj: items
      };
    }
    __name(_convertStackObj, "_convertStackObj");
    function _getOperaStack(errorMessage) {
      for (var stack = [], lines = errorMessage[_DYN_SPLIT](`
`), lp = 0; lp < lines[_DYN_LENGTH]; lp++) {
        var entry = lines[lp];
        lines[lp + 1] && (entry += "@" + lines[lp + 1], lp++), stack[_DYN_PUSH](entry);
      }
      return {
        src: errorMessage,
        obj: stack
      };
    }
    __name(_getOperaStack, "_getOperaStack");
    function _getStackFromErrorObj(errorObj) {
      var details = null;
      if (errorObj) try {
        if (errorObj[strStack]) details = _convertStackObj(errorObj[strStack]);else if (errorObj[strError] && errorObj[strError][strStack]) details = _convertStackObj(errorObj[strError][strStack]);else if (errorObj.exception && errorObj.exception[strStack]) details = _convertStackObj(errorObj.exception[strStack]);else if (_isStackDetails(errorObj)) details = errorObj;else if (_isStackDetails(errorObj[strStackDetails])) details = errorObj[strStackDetails];else if (getWindow() && getWindow().opera && errorObj[strMessage]) details = _getOperaStack(errorObj[_DYN_MESSAGE]);else if (errorObj.reason && errorObj.reason[strStack]) details = _convertStackObj(errorObj.reason[strStack]);else if (isString(errorObj)) details = _convertStackObj(errorObj);else {
          var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
          isString(errorObj[strErrorSrc]) && (evtMessage && (evtMessage += `
`), evtMessage += " from " + errorObj[strErrorSrc]), evtMessage && (details = _convertStackObj(evtMessage));
        }
      } catch (e) {
        details = _convertStackObj(e);
      }
      return details || {
        src: "",
        obj: null
      };
    }
    __name(_getStackFromErrorObj, "_getStackFromErrorObj");
    function _formatStackTrace(stackDetails) {
      var stack = "";
      return stackDetails && (stackDetails.obj ? arrForEach(stackDetails.obj, function (entry) {
        stack += entry + `
`;
      }) : stack = stackDetails.src || ""), stack;
    }
    __name(_formatStackTrace, "_formatStackTrace");
    function _parseStack(stack) {
      var parsedStack,
        frames = stack.obj;
      if (frames && frames[_DYN_LENGTH] > 0) {
        parsedStack = [];
        var level_1 = 0,
          totalSizeInBytes_1 = 0;
        arrForEach(frames, function (frame) {
          var theFrame = frame[_DYN_TO_STRING]();
          if (_StackFrame.regex.test(theFrame)) {
            var parsedFrame = new _StackFrame(theFrame, level_1++);
            totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES], parsedStack[_DYN_PUSH](parsedFrame);
          }
        });
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) for (var left = 0, right = parsedStack[_DYN_LENGTH] - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right;) {
          var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES],
            rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
          if (size += lSize + rSize, size > exceptionParsedStackThreshold) {
            var howMany = acceptedRight - acceptedLeft + 1;
            parsedStack.splice(acceptedLeft, howMany);
            break;
          }
          acceptedLeft = left, acceptedRight = right, left++, right--;
        }
      }
      return parsedStack;
    }
    __name(_parseStack, "_parseStack");
    function _getErrorType(errorType) {
      var typeName = "";
      if (errorType && (typeName = errorType.typeName || errorType[_DYN_NAME] || "", !typeName)) try {
        var funcNameRegex = /function (.{1,200})\(/,
          results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING]());
        typeName = results && results[_DYN_LENGTH] > 1 ? results[1] : "";
      } catch {}
      return typeName;
    }
    __name(_getErrorType, "_getErrorType");
    function _formatErrorCode(errorObj) {
      if (errorObj) try {
        if (!isString(errorObj)) {
          var errorType = _getErrorType(errorObj),
            result = _stringify(errorObj, !1);
          return (!result || result === "{}") && (errorObj[strError] && (errorObj = errorObj[strError], errorType = _getErrorType(errorObj)), result = _stringify(errorObj, !0)), strIndexOf(result, errorType) !== 0 && errorType !== "String" ? errorType + ":" + result : result;
        }
      } catch {}
      return "" + (errorObj || "");
    }
    __name(_formatErrorCode, "_formatErrorCode");
    var Exception = function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
          this.aiDataContract = {
            ver: 1,
            exceptions: 1,
            severityLevel: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _isExceptionInternal(exception) ? (_self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [], _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES], _self[_DYN_MEASUREMENTS] = exception[_DYN_MEASUREMENTS], exception[_DYN_SEVERITY_LEVEL] && (_self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL]), exception.id && (_self.id = exception.id, exception[_DYN_PROPERTIES].id = exception.id), exception[_DYN_PROBLEM_GROUP] && (_self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP]), isNullOrUndefined(exception[_DYN_IS_MANUAL]) || (_self[_DYN_IS_MANUAL] = exception[_DYN_IS_MANUAL])) : (properties || (properties = {}), id && (properties.id = id), _self[_DYN_EXCEPTIONS] = [new _ExceptionDetails(logger, exception, properties)], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel), id && (_self.id = id));
        }
        return __name(Exception, "Exception"), Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
          var _a,
            errorType = _getErrorType(error || evt || message);
          return _a = {}, _a[_DYN_MESSAGE] = _formatMessage(message, errorType), _a.url = url, _a.lineNumber = lineNumber, _a.columnNumber = columnNumber, _a.error = _formatErrorCode(error || evt || message), _a.evt = _formatErrorCode(evt || message), _a[_DYN_TYPE_NAME] = errorType, _a.stackDetails = _getStackFromErrorObj(stack || error || evt), _a.errorSrc = errorSrc, _a;
        }, Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
          var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function (ex) {
              return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1](logger, ex);
            }),
            exceptionData = new Exception(logger, __assign(__assign({}, exception), {
              exceptions: exceptions
            }), properties, measurements);
          return exceptionData;
        }, Exception.prototype.toInterface = function () {
          var _a,
            _b = this,
            exceptions = _b.exceptions,
            properties = _b.properties,
            measurements = _b.measurements,
            severityLevel = _b.severityLevel,
            problemGroup = _b.problemGroup,
            id = _b.id,
            isManual = _b.isManual,
            exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function (exception) {
              return exception.toInterface();
            }) || void 0;
          return _a = {
            ver: "4.0"
          }, _a[_DYN_EXCEPTIONS] = exceptionDetailsInterface, _a.severityLevel = severityLevel, _a.properties = properties, _a.measurements = measurements, _a.problemGroup = problemGroup, _a.id = id, _a.isManual = isManual, _a;
        }, Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
          var _a;
          return {
            exceptions: [(_a = {}, _a[_DYN_HAS_FULL_STACK] = !0, _a.message = message, _a.stack = details, _a.typeName = typeName, _a)]
          };
        }, Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", Exception.dataType = "ExceptionData", Exception.formatError = _formatErrorCode, Exception;
      }(),
      _ExceptionDetails = function () {
        function _ExceptionDetails(logger, exception, properties) {
          this.aiDataContract = {
            id: 0,
            outerId: 0,
            typeName: 1,
            message: 1,
            hasFullStack: 0,
            stack: 0,
            parsedStack: 2
          };
          var _self = this;
          if (_isExceptionDetailsInternal(exception)) _self[_DYN_TYPE_NAME] = exception[_DYN_TYPE_NAME], _self[_DYN_MESSAGE] = exception[_DYN_MESSAGE], _self[strStack] = exception[strStack], _self[_DYN_PARSED_STACK] = exception[_DYN_PARSED_STACK] || [], _self[_DYN_HAS_FULL_STACK] = exception[_DYN_HAS_FULL_STACK];else {
            var error = exception,
              evt = error && error.evt;
            isError(error) || (error = error[strError] || evt || error), _self[_DYN_TYPE_NAME] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME])) || strNotSpecified;
            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
            _self[_DYN_PARSED_STACK] = _parseStack(stack), isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
              frame[_DYN_ASSEMBLY] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY]), frame[_DYN_FILE_NAME] = dataSanitizeString(logger, frame[_DYN_FILE_NAME]);
            }), _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack)), _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH] > 0, properties && (properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || _self[_DYN_TYPE_NAME]);
          }
        }
        return __name(_ExceptionDetails, "_ExceptionDetails"), _ExceptionDetails.prototype.toInterface = function () {
          var _a,
            _self = this,
            parsedStack = _self[_DYN_PARSED_STACK] instanceof Array && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
              return frame.toInterface();
            }),
            exceptionDetailsInterface = (_a = {
              id: _self.id,
              outerId: _self.outerId,
              typeName: _self[_DYN_TYPE_NAME],
              message: _self[_DYN_MESSAGE],
              hasFullStack: _self[_DYN_HAS_FULL_STACK],
              stack: _self[strStack]
            }, _a[_DYN_PARSED_STACK] = parsedStack || void 0, _a);
          return exceptionDetailsInterface;
        }, _ExceptionDetails.CreateFromInterface = function (logger, exception) {
          var parsedStack = exception[_DYN_PARSED_STACK] instanceof Array && arrMap(exception[_DYN_PARSED_STACK], function (frame) {
              return _StackFrame[_DYN__CREATE_FROM_INTERFA1](frame);
            }) || exception[_DYN_PARSED_STACK],
            exceptionDetails = new _ExceptionDetails(logger, __assign(__assign({}, exception), {
              parsedStack: parsedStack
            }));
          return exceptionDetails;
        }, _ExceptionDetails;
      }(),
      _StackFrame = function () {
        function _StackFrame(sourceFrame, level) {
          this.aiDataContract = {
            level: 1,
            method: 1,
            assembly: 0,
            fileName: 0,
            line: 0
          };
          var _self = this;
          if (_self[_DYN_SIZE_IN_BYTES] = 0, typeof sourceFrame == "string") {
            var frame = sourceFrame;
            _self[_DYN_LEVEL] = level, _self[_DYN_METHOD] = NoMethod, _self[_DYN_ASSEMBLY] = strTrim(frame), _self[_DYN_FILE_NAME] = "", _self[_DYN_LINE] = 0;
            var matches = frame.match(_StackFrame.regex);
            matches && matches[_DYN_LENGTH] >= 5 && (_self[_DYN_METHOD] = strTrim(matches[2]) || _self[_DYN_METHOD], _self[_DYN_FILE_NAME] = strTrim(matches[4]), _self[_DYN_LINE] = parseInt(matches[5]) || 0);
          } else _self[_DYN_LEVEL] = sourceFrame[_DYN_LEVEL], _self[_DYN_METHOD] = sourceFrame[_DYN_METHOD], _self[_DYN_ASSEMBLY] = sourceFrame[_DYN_ASSEMBLY], _self[_DYN_FILE_NAME] = sourceFrame[_DYN_FILE_NAME], _self[_DYN_LINE] = sourceFrame[_DYN_LINE], _self[_DYN_SIZE_IN_BYTES] = 0;
          _self.sizeInBytes += _self.method[_DYN_LENGTH], _self.sizeInBytes += _self.fileName[_DYN_LENGTH], _self.sizeInBytes += _self.assembly[_DYN_LENGTH], _self[_DYN_SIZE_IN_BYTES] += _StackFrame.baseSize, _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH], _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH];
        }
        return __name(_StackFrame, "_StackFrame"), _StackFrame.CreateFromInterface = function (frame) {
          return new _StackFrame(frame, null);
        }, _StackFrame.prototype.toInterface = function () {
          var _self = this;
          return {
            level: _self[_DYN_LEVEL],
            method: _self[_DYN_METHOD],
            assembly: _self[_DYN_ASSEMBLY],
            fileName: _self[_DYN_FILE_NAME],
            line: _self[_DYN_LINE]
          };
        }, _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/, _StackFrame.baseSize = 58, _StackFrame;
      }(),
      DataPoint = function () {
        function DataPoint() {
          this.aiDataContract = {
            name: 1,
            kind: 0,
            value: 1,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0
          }, this.kind = 0;
        }
        return __name(DataPoint, "DataPoint"), DataPoint;
      }(),
      Metric = function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            metrics: 1,
            properties: 0
          };
          var _self = this;
          _self.ver = 2;
          var dataPoint = new DataPoint();
          dataPoint[_DYN_COUNT] = count > 0 ? count : void 0, dataPoint.max = isNaN(max) || max === null ? void 0 : max, dataPoint.min = isNaN(min) || min === null ? void 0 : min, dataPoint[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, dataPoint.value = value, dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev, _self.metrics = [dataPoint], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Metric, "Metric"), Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", Metric.dataType = "MetricData", Metric;
      }(),
      strEmpty = "";
    function stringToBoolOrDefault(str, defaultValue) {
      return defaultValue === void 0 && (defaultValue = !1), str == null ? defaultValue : str.toString()[_DYN_TO_LOWER_CASE]() === "true";
    }
    __name(stringToBoolOrDefault, "stringToBoolOrDefault");
    function msToTimeSpan(totalms) {
      (isNaN(totalms) || totalms < 0) && (totalms = 0), totalms = Math.round(totalms);
      var ms = strEmpty + totalms % 1e3,
        sec = strEmpty + Math.floor(totalms / 1e3) % 60,
        min = strEmpty + Math.floor(totalms / (1e3 * 60)) % 60,
        hour = strEmpty + Math.floor(totalms / (1e3 * 60 * 60)) % 24,
        days = Math.floor(totalms / (1e3 * 60 * 60 * 24));
      return ms = ms[_DYN_LENGTH] === 1 ? "00" + ms : ms[_DYN_LENGTH] === 2 ? "0" + ms : ms, sec = sec[_DYN_LENGTH] < 2 ? "0" + sec : sec, min = min[_DYN_LENGTH] < 2 ? "0" + min : min, hour = hour[_DYN_LENGTH] < 2 ? "0" + hour : hour, (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }
    __name(msToTimeSpan, "msToTimeSpan");
    function getExtensionByName(extensions, identifier) {
      var extension = null;
      return arrForEach(extensions, function (value) {
        if (value.identifier === identifier) return extension = value, -1;
      }), extension;
    }
    __name(getExtensionByName, "getExtensionByName");
    function isCrossOriginError(message, url, lineNumber, columnNumber, error) {
      return !error && isString(message) && (message === "Script error." || message === "Script error");
    }
    __name(isCrossOriginError, "isCrossOriginError");
    var PageView = function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            properties: 0,
            measurements: 0,
            id: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = dataSanitizeId(logger, id), _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, isNaN(durationMs) || (_self[_DYN_DURATION] = msToTimeSpan(durationMs)), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(PageView, "PageView"), PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", PageView.dataType = "PageviewData", PageView;
      }(),
      RemoteDependencyData = function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
          requestAPI === void 0 && (requestAPI = "Ajax"), this.aiDataContract = {
            id: 1,
            ver: 1,
            name: 0,
            resultCode: 0,
            duration: 0,
            success: 0,
            data: 0,
            target: 0,
            type: 0,
            properties: 0,
            measurements: 0,
            kind: 0,
            value: 0,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            dependencyKind: 0,
            dependencySource: 0,
            commandName: 0,
            dependencyTypeName: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = id, _self[_DYN_DURATION] = msToTimeSpan(value), _self.success = success, _self.resultCode = resultCode + "", _self.type = dataSanitizeString(logger, requestAPI);
          var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
          _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data, _self.target = dataSanitizeString(logger, dependencyFields.target), correlationContext && (_self.target = "".concat(_self.target, " | ").concat(correlationContext)), _self[_DYN_NAME] = dataSanitizeString(logger, dependencyFields[_DYN_NAME]), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(RemoteDependencyData, "RemoteDependencyData"), RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", RemoteDependencyData.dataType = "RemoteDependencyData", RemoteDependencyData;
      }(),
      Trace = function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            message: 1,
            severityLevel: 0,
            properties: 0
          };
          var _self = this;
          _self.ver = 2, message = message || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, message), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel);
        }
        return __name(Trace, "Trace"), Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", Trace.dataType = "MessageData", Trace;
      }(),
      PageViewPerformance = function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            perfTotal: 0,
            networkConnect: 0,
            sentRequest: 0,
            receivedResponse: 0,
            domProcessing: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), cs4BaseData && (_self.domProcessing = cs4BaseData.domProcessing, _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION], _self.networkConnect = cs4BaseData.networkConnect, _self.perfTotal = cs4BaseData.perfTotal, _self[_DYN_RECEIVED_RESPONSE] = cs4BaseData[_DYN_RECEIVED_RESPONSE], _self.sentRequest = cs4BaseData.sentRequest);
        }
        return __name(PageViewPerformance, "PageViewPerformance"), PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", PageViewPerformance.dataType = "PageviewPerformanceData", PageViewPerformance;
      }(),
      Data = function () {
        function Data(baseType, data) {
          this.aiDataContract = {
            baseType: 1,
            baseData: 1
          }, this.baseType = baseType, this.baseData = data;
        }
        return __name(Data, "Data"), Data;
      }(),
      SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      }),
      ConfigurationManager = function () {
        function ConfigurationManager() {}
        return __name(ConfigurationManager, "ConfigurationManager"), ConfigurationManager.getConfig = function (config, field, identifier, defaultValue) {
          defaultValue === void 0 && (defaultValue = !1);
          var configValue;
          return identifier && config[_DYN_EXTENSION_CONFIG] && config[_DYN_EXTENSION_CONFIG][identifier] && !isNullOrUndefined(config[_DYN_EXTENSION_CONFIG][identifier][field]) ? configValue = config[_DYN_EXTENSION_CONFIG][identifier][field] : configValue = config[field], isNullOrUndefined(configValue) ? defaultValue : configValue;
        }, ConfigurationManager;
      }();
    function _aiNameFunc(baseName) {
      var aiName = "ai." + baseName + ".";
      return function (name) {
        return aiName + name;
      };
    }
    __name(_aiNameFunc, "_aiNameFunc");
    var _aiApplication = _aiNameFunc("application"),
      _aiDevice = _aiNameFunc("device"),
      _aiLocation = _aiNameFunc("location"),
      _aiOperation = _aiNameFunc("operation"),
      _aiSession = _aiNameFunc("session"),
      _aiUser = _aiNameFunc("user"),
      _aiCloud = _aiNameFunc("cloud"),
      _aiInternal = _aiNameFunc("internal"),
      ContextTagKeys = function (_super) {
        __extends(ContextTagKeys, _super);
        function ContextTagKeys() {
          return _super.call(this) || this;
        }
        return __name(ContextTagKeys, "ContextTagKeys"), ContextTagKeys;
      }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
      }));
    function createTelemetryItem(item, baseType, envelopeName, logger, customProperties, systemProperties) {
      var _a;
      envelopeName = dataSanitizeString(logger, envelopeName) || strNotSpecified, (isNullOrUndefined(item) || isNullOrUndefined(baseType) || isNullOrUndefined(envelopeName)) && throwError("Input doesn't contain all required fields");
      var iKey = "";
      item[strIkey] && (iKey = item[strIkey], delete item[strIkey]);
      var telemetryItem = (_a = {}, _a[_DYN_NAME] = envelopeName, _a.time = toISOString(new Date()), _a.iKey = iKey, _a.ext = systemProperties || {}, _a.tags = [], _a.data = {}, _a.baseType = baseType, _a.baseData = item, _a);
      return isNullOrUndefined(customProperties) || objForEachKey(customProperties, function (prop, value) {
        telemetryItem.data[prop] = value;
      }), telemetryItem;
    }
    __name(createTelemetryItem, "createTelemetryItem");
    var TelemetryItemCreator = function () {
        function TelemetryItemCreator() {}
        return __name(TelemetryItemCreator, "TelemetryItemCreator"), TelemetryItemCreator.create = createTelemetryItem, TelemetryItemCreator;
      }(),
      Extensions = {
        UserExt: "user",
        DeviceExt: "device",
        TraceExt: "trace",
        WebExt: "web",
        AppExt: "app",
        OSExt: "os",
        SessionExt: "ses",
        SDKExt: "sdk"
      },
      CtxTagKeys = new ContextTagKeys();
    function createDomEvent(eventName) {
      var event = null;
      if (isFunction(Event)) event = new Event(eventName);else {
        var doc = getDocument();
        doc && doc.createEvent && (event = doc.createEvent("Event"), event.initEvent(eventName, !0, !0));
      }
      return event;
    }
    __name(createDomEvent, "createDomEvent");
    function _disableEvents(target, evtNamespace) {
      eventOff(target, null, null, evtNamespace);
    }
    __name(_disableEvents, "_disableEvents");
    function createOfflineListener(parentEvtNamespace) {
      var _document = getDocument(),
        _navigator = getNavigator(),
        _isListening = !1,
        listenerList = [],
        rState = 1;
      _navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine && (rState = 2);
      var uState = 0,
        _currentState = calCurrentState(),
        _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
      try {
        if (_enableEvents(getWindow()) && (_isListening = !0), _document) {
          var target = _document.body || _document;
          target.ononline && _enableEvents(target) && (_isListening = !0);
        }
      } catch {
        _isListening = !1;
      }
      function _enableEvents(target) {
        var enabled = !1;
        return target && (enabled = eventOn(target, "online", _setOnline, _evtNamespace), enabled && eventOn(target, "offline", _setOffline, _evtNamespace)), enabled;
      }
      __name(_enableEvents, "_enableEvents");
      function _isOnline() {
        return _currentState;
      }
      __name(_isOnline, "_isOnline");
      function calCurrentState() {
        return !(uState === 2 || rState === 2);
      }
      __name(calCurrentState, "calCurrentState");
      function listnerNoticeCheck() {
        var newState = calCurrentState();
        _currentState !== newState && (_currentState = newState, arrForEach(listenerList, function (callback) {
          var offlineState = {
            isOnline: _currentState,
            rState: rState,
            uState: uState
          };
          try {
            callback(offlineState);
          } catch {}
        }));
      }
      __name(listnerNoticeCheck, "listnerNoticeCheck");
      function setOnlineState(newState) {
        uState = newState, listnerNoticeCheck();
      }
      __name(setOnlineState, "setOnlineState");
      function _setOnline() {
        rState = 1, listnerNoticeCheck();
      }
      __name(_setOnline, "_setOnline");
      function _setOffline() {
        rState = 2, listnerNoticeCheck();
      }
      __name(_setOffline, "_setOffline");
      function _unload() {
        var win = getWindow();
        if (win && _isListening) {
          if (_disableEvents(win, _evtNamespace), _document) {
            var target = _document.body || _document;
            isUndefined(target.ononline) || _disableEvents(target, _evtNamespace);
          }
          _isListening = !1;
        }
      }
      __name(_unload, "_unload");
      function addListener(callback) {
        return listenerList[_DYN_PUSH](callback), {
          rm: function () {
            var index = listenerList.indexOf(callback);
            if (index > -1) return listenerList.splice(index, 1);
          }
        };
      }
      return __name(addListener, "addListener"), {
        isOnline: _isOnline,
        isListening: function () {
          return _isListening;
        },
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
      };
    }
    __name(createOfflineListener, "createOfflineListener");
    var PropertiesPluginIdentifier = "AppInsightsPropertiesPlugin",
      BreezeChannelIdentifier = "AppInsightsChannelPlugin",
      AnalyticsPluginIdentifier = "ApplicationInsightsAnalytics";
    e.AnalyticsPluginIdentifier = nc, e.BreezeChannelIdentifier = n_, e.ConfigurationManager = Qx, e.ConnectionStringParser = Pg, e.ContextTagKeys = Lg, e.CtxTagKeys = rc, e.DEFAULT_BREEZE_ENDPOINT = ph, e.DEFAULT_BREEZE_PATH = v4, e.Data = Uh, e.DisabledPropertyName = Fx, e.DistributedTracingModes = $x, e.Envelope = Rg, e.Event = jx, e.EventPersistence = Hx, e.Exception = Kx, e.Extensions = $h, e.HttpMethod = hg, e.Metric = kg, e.PageView = Jx, e.PageViewPerformance = Bg, e.ProcessLegacy = mh, e.PropertiesPluginIdentifier = r_, e.RemoteDependencyData = Xx, e.RequestHeaders = gg, e.SampleRate = h5, e.SeverityLevel = Zx, e.TelemetryItemCreator = Fg, e.ThrottleMgr = R4, e.Trace = eu, e.correlationIdCanIncludeCorrelationHeader = w4, e.correlationIdGetCorrelationContext = Ux, e.correlationIdGetCorrelationContextValue = bg, e.correlationIdGetPrefix = I4, e.correlationIdSetPrefix = Eh, e.createDistributedTraceContextFromTrace = Eg, e.createDomEvent = e_, e.createOfflineListener = t_, e.createTelemetryItem = qh, e.createTraceParent = ih, e.dataSanitizeException = y2, e.dataSanitizeId = b5, e.dataSanitizeInput = Xc, e.dataSanitizeKey = _5, e.dataSanitizeKeyAndAddUniqueness = _h, e.dataSanitizeMeasurements = lf, e.dataSanitizeMessage = bh, e.dataSanitizeProperties = Rf, e.dataSanitizeString = ba, e.dataSanitizeUrl = Jc, e.dateTimeUtilsDuration = T5, e.dateTimeUtilsNow = qx, e.dsPadNumber = pg, e.findW3cTraceParent = _a, e.formatTraceParent = fh, e.getExtensionByName = Dg, e.isBeaconApiSupported = X7, e.isCrossOriginError = Yx, e.isInternalApplicationInsightsEndpoint = Nf, e.isSampledFlag = lh, e.isValidSpanId = ah, e.isValidTraceId = oh, e.isValidTraceParent = og, e.msToTimeSpan = Mh, e.parseConnectionString = ff, e.parseTraceParent = sh, e.strNotSpecified = vl, e.stringToBoolOrDefault = Wx, e.urlGetAbsoluteUrl = C5, e.urlGetCompleteUrl = xg, e.urlGetPathName = E5, e.urlParseFullHost = Ch, e.urlParseHost = _g, e.urlParseUrl = Ca, e.utlCanUseLocalStorage = I5, e.utlCanUseSessionStorage = C2, e.utlDisableStorage = A4, e.utlEnableStorage = pr, e.utlGetLocalStorage = P4, e.utlGetSessionStorage = Ih, e.utlGetSessionStorageKeys = Sh, e.utlRemoveSessionStorage = wh, e.utlRemoveStorage = Sg, e.utlSetLocalStorage = Q1, e.utlSetSessionStorage = Ig, e.utlSetStoragePrefix = Tg;
  });
});,var ik = y0((ay, nk) => {
  (function (e, t) {
    typeof ay == "object" && typeof nk < "u" ? t(ay) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t((e.Microsoft = e.Microsoft || {}, e.Microsoft.ApplicationInsights = e.Microsoft.ApplicationInsights || {})));
  })(ay, function (e) {
    "use strict";

    var UNDEF_VALUE = void 0,
      NULL_VALUE = null,
      EMPTY = "",
      BOOLEAN = "boolean",
      FUNCTION = "function",
      NUMBER = "number",
      OBJECT = "object",
      PROTOTYPE = "prototype",
      __PROTO__ = "__proto__",
      STRING = "string",
      UNDEFINED = "undefined",
      CONSTRUCTOR = "constructor",
      SYMBOL = "Symbol",
      POLYFILL_TAG = "_polyfill",
      INDEX_OF = "indexOf",
      LENGTH = "length",
      DONE = "done",
      VALUE = "value",
      NAME = "name",
      SLICE = "slice",
      CALL = "call",
      TO_STRING = "toString",
      ObjClass = Object,
      ObjProto = ObjClass[PROTOTYPE],
      StrCls = String,
      StrProto = StrCls[PROTOTYPE],
      MathCls = Math,
      ArrCls = Array,
      ArrProto = ArrCls[PROTOTYPE];
    function safe(func, argArray) {
      try {
        return {
          v: func.apply(this, argArray)
        };
      } catch (e) {
        return {
          e: e
        };
      }
    }
    __name(safe, "safe");
    function safeGet(cb, defValue) {
      var result = safe(cb);
      return result.e ? defValue : result.v;
    }
    __name(safeGet, "safeGet");
    var PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN, UNDEFINED, "symbol", "bigint"];
    function _createIs(theType) {
      return function (value) {
        return typeof value === theType;
      };
    }
    __name(_createIs, "_createIs");
    function _createObjIs(theName) {
      var theType = "[object " + theName + "]";
      return function (value) {
        return !!(value && objToString(value) === theType);
      };
    }
    __name(_createObjIs, "_createObjIs");
    function objToString(value) {
      return ObjProto.toString.call(value);
    }
    __name(objToString, "objToString");
    function isUndefined(value) {
      return typeof value === UNDEFINED || value === UNDEFINED;
    }
    __name(isUndefined, "isUndefined");
    function isNullOrUndefined(value) {
      return value === NULL_VALUE || isUndefined(value);
    }
    __name(isNullOrUndefined, "isNullOrUndefined");
    function isStrictNullOrUndefined(value) {
      return value === NULL_VALUE || !isDefined(value);
    }
    __name(isStrictNullOrUndefined, "isStrictNullOrUndefined");
    function isDefined(arg) {
      return !!arg || arg !== UNDEF_VALUE;
    }
    __name(isDefined, "isDefined");
    function isPrimitiveType(theType) {
      return theType !== OBJECT && PRIMITIVE_TYPES.indexOf(theType) !== -1;
    }
    __name(isPrimitiveType, "isPrimitiveType");
    var isString = _createIs(STRING),
      isFunction = _createIs(FUNCTION);
    function isObject(value) {
      return !value && isNullOrUndefined(value) ? !1 : !!value && typeof value === OBJECT;
    }
    __name(isObject, "isObject");
    var isArray = ArrCls.isArray,
      isDate = _createObjIs("Date"),
      isNumber = _createIs(NUMBER),
      isBoolean = _createIs(BOOLEAN),
      isError = _createObjIs("Error");
    function isPromiseLike(value) {
      return !!(value && value.then && isFunction(value.then));
    }
    __name(isPromiseLike, "isPromiseLike");
    function isTruthy(value) {
      return !(!value || safeGet(function () {
        return !(value && 0 + value);
      }, !value));
    }
    __name(isTruthy, "isTruthy");
    var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;
    function objHasOwnProperty(obj, prop) {
      return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);
    }
    __name(objHasOwnProperty, "objHasOwnProperty");
    var objHasOwn = ObjClass.hasOwn || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
      return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }
    __name(polyObjHasOwn, "polyObjHasOwn");
    function objForEachKey(theObject, callbackfn, thisArg) {
      if (theObject && isObject(theObject)) {
        for (var prop in theObject) if (objHasOwn(theObject, prop) && callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) break;
      }
    }
    __name(objForEachKey, "objForEachKey");
    function _createKeyValueMap(values, keyType, valueType, completeFn) {
      var theMap = {};
      return objForEachKey(values, function (key, value) {
        theMap[key] = keyType ? value : key, theMap[value] = valueType ? value : key;
      }), completeFn(theMap);
    }
    __name(_createKeyValueMap, "_createKeyValueMap");
    function throwError(message) {
      throw new Error(message);
    }
    __name(throwError, "throwError");
    function throwTypeError(message) {
      throw new TypeError(message);
    }
    __name(throwTypeError, "throwTypeError");
    var _objFreeze = ObjClass.freeze;
    function _doNothing(value) {
      return value;
    }
    __name(_doNothing, "_doNothing");
    function _getProto(value) {
      return value[__PROTO__] || NULL_VALUE;
    }
    __name(_getProto, "_getProto");
    var objAssign = ObjClass.assign,
      objKeys = ObjClass.keys;
    function objDeepFreeze(value) {
      return _objFreeze && objForEachKey(value, function (key, value) {
        (isArray(value) || isObject(value)) && _objFreeze(value);
      }), objFreeze(value);
    }
    __name(objDeepFreeze, "objDeepFreeze");
    var objFreeze = _objFreeze || _doNothing,
      objGetPrototypeOf = ObjClass.getPrototypeOf || _getProto;
    function createEnum(values) {
      return _createKeyValueMap(values, 1, 0, objDeepFreeze);
    }
    __name(createEnum, "createEnum");
    function createEnumKeyMap(values) {
      return _createKeyValueMap(values, 0, 0, objDeepFreeze);
    }
    __name(createEnumKeyMap, "createEnumKeyMap");
    function createSimpleMap(values) {
      var mapClass = {};
      return objForEachKey(values, function (key, value) {
        mapClass[key] = value[1], mapClass[value[0]] = value[1];
      }), objDeepFreeze(mapClass);
    }
    __name(createSimpleMap, "createSimpleMap");
    function createTypeMap(values) {
      return createSimpleMap(values);
    }
    __name(createTypeMap, "createTypeMap");
    var _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0,
        hasInstance: 1,
        isConcatSpreadable: 2,
        iterator: 3,
        match: 4,
        matchAll: 5,
        replace: 6,
        search: 7,
        species: 8,
        split: 9,
        toPrimitive: 10,
        toStringTag: 11,
        unscopables: 12
      }),
      asString = StrCls,
      GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg",
      _globalCfg;
    function _getGlobalValue() {
      var result;
      return typeof globalThis !== UNDEFINED && (result = globalThis), !result && typeof self !== UNDEFINED && (result = self), !result && typeof window !== UNDEFINED && (result = window), !result && typeof global !== UNDEFINED && (result = global), result;
    }
    __name(_getGlobalValue, "_getGlobalValue");
    function _getGlobalConfig() {
      if (!_globalCfg) {
        var gbl = safe(_getGlobalValue).v || {};
        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
      }
      return _globalCfg;
    }
    __name(_getGlobalConfig, "_getGlobalConfig");
    var ERROR_TYPE = "[object Error]";
    function dumpObj(object, format) {
      var propertyValueDump = EMPTY,
        objType = ObjProto[TO_STRING][CALL](object);
      objType === ERROR_TYPE && (object = {
        stack: asString(object.stack),
        message: asString(object.message),
        name: asString(object.name)
      });
      try {
        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? typeof format === NUMBER ? format : 4 : UNDEF_VALUE), propertyValueDump = propertyValueDump && propertyValueDump.replace(/"(\w+)"\s*:\s{0,1}/g, "$1: ") || asString(object);
      } catch (e) {
        propertyValueDump = " - " + dumpObj(e, format);
      }
      return objType + ": " + propertyValueDump;
    }
    __name(dumpObj, "dumpObj");
    var _slice,
      _unwrapInstFunction = _unwrapFunctionWithPoly,
      _unwrapFunction = _unwrapFunctionWithPoly;
    function _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {
      _slice = _slice || ArrProto[SLICE];
      var clsFn = clsProto && clsProto[funcName];
      return function (thisArg) {
        var theFunc = thisArg && thisArg[funcName] || clsFn;
        if (theFunc || polyFunc) {
          var theArgs = arguments;
          return (theFunc || polyFunc).apply(thisArg, theFunc ? _slice[CALL](theArgs, 1) : theArgs);
        }
        throwTypeError('"' + asString(funcName) + '" not defined for ' + dumpObj(thisArg));
      };
    }
    __name(_unwrapFunctionWithPoly, "_unwrapFunctionWithPoly");
    function _unwrapProp(propName) {
      return function (thisArg) {
        return thisArg[propName];
      };
    }
    __name(_unwrapProp, "_unwrapProp");
    var mathMax = MathCls.max,
      strSlice = _unwrapFunction(SLICE, StrProto),
      strSubstring = _unwrapFunction("substring", StrProto),
      strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
      return isNullOrUndefined(value) && throwTypeError("'polyStrSubstr called with invalid " + dumpObj(value)), length < 0 ? EMPTY : (start = start || 0, start < 0 && (start = mathMax(start + value[LENGTH], 0)), isUndefined(length) ? strSlice(value, start) : strSlice(value, start, start + length));
    }
    __name(polyStrSubstr, "polyStrSubstr");
    function strLeft(value, count) {
      return strSubstring(value, 0, count);
    }
    __name(strLeft, "strLeft");
    var UNIQUE_REGISTRY_ID = "_urid",
      _polySymbols;
    function _globalSymbolRegistry() {
      if (!_polySymbols) {
        var gblCfg = _getGlobalConfig();
        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || {
          k: {},
          s: {}
        };
      }
      return _polySymbols;
    }
    __name(_globalSymbolRegistry, "_globalSymbolRegistry");
    var _wellKnownSymbolCache;
    function polyNewSymbol(description) {
      var theSymbol = {
        description: asString(description),
        toString: function () {
          return SYMBOL + "(" + description + ")";
        }
      };
      return theSymbol[POLYFILL_TAG] = !0, theSymbol;
    }
    __name(polyNewSymbol, "polyNewSymbol");
    function polySymbolFor(key) {
      var registry = _globalSymbolRegistry();
      if (!objHasOwn(registry.k, key)) {
        var newSymbol_1 = polyNewSymbol(key),
          regId_1 = objKeys(registry.s).length;
        newSymbol_1[UNIQUE_REGISTRY_ID] = function () {
          return regId_1 + "_" + newSymbol_1[TO_STRING]();
        }, registry.k[key] = newSymbol_1, registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
      }
      return registry.k[key];
    }
    __name(polySymbolFor, "polySymbolFor");
    function polyGetKnownSymbol(name) {
      !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});
      var result,
        knownName = _wellKnownSymbolMap[name];
      return knownName && (result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName)), result;
    }
    __name(polyGetKnownSymbol, "polyGetKnownSymbol");
    var propMap = {
      e: "enumerable",
      c: "configurable",
      v: VALUE,
      w: "writable",
      g: "get",
      s: "set"
    };
    function _createProp(value) {
      var prop = {};
      if (prop[propMap.c] = !0, prop[propMap.e] = !0, value.l) {
        prop.get = function () {
          return value.l.v;
        };
        var desc = objGetOwnPropertyDescriptor(value.l, "v");
        desc && desc.set && (prop.set = function (newValue) {
          value.l.v = newValue;
        });
      }
      return objForEachKey(value, function (key, value) {
        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
      }), prop;
    }
    __name(_createProp, "_createProp");
    var objDefineProp = ObjClass.defineProperty;
    function objDefine(target, key, propDesc) {
      return objDefineProp(target, key, _createProp(propDesc));
    }
    __name(objDefine, "objDefine");
    var _globalLazyTestHooks;
    function _initTestHooks() {
      _globalLazyTestHooks = _getGlobalConfig();
    }
    __name(_initTestHooks, "_initTestHooks");
    function getLazy(cb) {
      var lazyValue = {};
      return !_globalLazyTestHooks && _initTestHooks(), lazyValue.b = _globalLazyTestHooks.lzy, objDefineProp(lazyValue, "v", {
        configurable: !0,
        get: function () {
          var result = cb();
          return _globalLazyTestHooks.lzy || objDefineProp(lazyValue, "v", {
            value: result
          }), lazyValue.b = _globalLazyTestHooks.lzy, result;
        }
      }), lazyValue;
    }
    __name(getLazy, "getLazy");
    function safeGetLazy(cb, defValue) {
      return getLazy(function () {
        var result = safe(cb);
        return result.e ? defValue : result.v;
      });
    }
    __name(safeGetLazy, "safeGetLazy");
    function createCachedValue(value) {
      return objDefineProp({
        toJSON: function () {
          return value;
        }
      }, "v", {
        value: value
      });
    }
    __name(createCachedValue, "createCachedValue");
    var WINDOW = "window",
      _cachedGlobal,
      _cachedWindow,
      _cachedDocument,
      _cachedNavigator,
      _isNode;
    function lazySafeGetInst(name) {
      return getLazy(function () {
        return safe(getInst, [name]).v || UNDEF_VALUE;
      });
    }
    __name(lazySafeGetInst, "lazySafeGetInst");
    function getGlobal(useCached) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedGlobal || useCached === !1 || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE)), _cachedGlobal.v;
    }
    __name(getGlobal, "getGlobal");
    function getInst(name, useCached) {
      var gbl = !_cachedGlobal || useCached === !1 ? getGlobal(useCached) : _cachedGlobal.v;
      return gbl && gbl[name] ? gbl[name] : name === WINDOW && _cachedWindow ? _cachedWindow.v : NULL_VALUE;
    }
    __name(getInst, "getInst");
    function hasDocument() {
      return !!getDocument();
    }
    __name(hasDocument, "hasDocument");
    function getDocument() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedDocument || _globalLazyTestHooks.lzy) && (_cachedDocument = createCachedValue(safe(getInst, ["document"]).v)), _cachedDocument.v;
    }
    __name(getDocument, "getDocument");
    function hasWindow() {
      return !!getWindow();
    }
    __name(hasWindow, "hasWindow");
    function getWindow() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedWindow || _globalLazyTestHooks.lzy) && (_cachedWindow = createCachedValue(safe(getInst, [WINDOW]).v)), _cachedWindow.v;
    }
    __name(getWindow, "getWindow");
    function hasNavigator() {
      return !!getNavigator();
    }
    __name(hasNavigator, "hasNavigator");
    function getNavigator() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_cachedNavigator || _globalLazyTestHooks.lzy) && (_cachedNavigator = createCachedValue(safe(getInst, ["navigator"]).v)), _cachedNavigator.v;
    }
    __name(getNavigator, "getNavigator");
    function isNode() {
      return !_isNode && (_isNode = createCachedValue(!!safe(function () {
        return process && (process.versions || {}).node;
      }).v)), _isNode.v;
    }
    __name(isNode, "isNode");
    var _symbol, _symbolFor;
    function _initSymbol() {
      (!_symbol || !_symbol.b) && (_symbol = lazySafeGetInst(SYMBOL), _symbolFor = safeGetLazy(function () {
        return _symbol.v ? _symbol.v.for : UNDEF_VALUE;
      }, UNDEF_VALUE));
    }
    __name(_initSymbol, "_initSymbol");
    function hasSymbol() {
      return !!getSymbol();
    }
    __name(hasSymbol, "hasSymbol");
    function getSymbol() {
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), _symbol.v;
    }
    __name(getSymbol, "getSymbol");
    function getKnownSymbol(name, noPoly) {
      var knownName = _wellKnownSymbolMap[name];
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), _symbol.v ? _symbol.v[knownName || name] : noPoly ? UNDEF_VALUE : polyGetKnownSymbol(name);
    }
    __name(getKnownSymbol, "getKnownSymbol");
    function newSymbol(description, noPoly) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), _symbol.v ? _symbol.v(description) : noPoly ? NULL_VALUE : polyNewSymbol(description);
    }
    __name(newSymbol, "newSymbol");
    function symbolFor(key) {
      return !_globalLazyTestHooks && _initTestHooks(), (!_symbolFor || !_symbol || _globalLazyTestHooks.lzy) && _initSymbol(), (_symbolFor.v || polySymbolFor)(key);
    }
    __name(symbolFor, "symbolFor");
    function isIterator(value) {
      return !!value && isFunction(value.next);
    }
    __name(isIterator, "isIterator");
    function isIterable(value) {
      return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3)]);
    }
    __name(isIterable, "isIterable");
    var _iterSymbol;
    function iterForOf(iter, callbackfn, thisArg) {
      if (iter && (isIterator(iter) || (!_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3))), iter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null), isIterator(iter))) {
        var err = void 0,
          iterResult = void 0;
        try {
          for (var count = 0; !(iterResult = iter.next())[DONE] && callbackfn[CALL](thisArg || iter, iterResult[VALUE], count, iter) !== -1;) count++;
        } catch (failed) {
          err = {
            e: failed
          }, iter.throw && (iterResult = null, iter.throw(err));
        } finally {
          try {
            iterResult && !iterResult[DONE] && iter.return && iter.return(iterResult);
          } finally {
            if (err) throw err.e;
          }
        }
      }
    }
    __name(iterForOf, "iterForOf");
    var fnApply = _unwrapInstFunction("apply");
    function arrAppend(target, elms) {
      return !isUndefined(elms) && target && (isArray(elms) ? fnApply(target.push, target, elms) : isIterator(elms) || isIterable(elms) ? iterForOf(elms, function (elm) {
        target.push(elm);
      }) : target.push(elms)), target;
    }
    __name(arrAppend, "arrAppend");
    function arrForEach(theArray, callbackfn, thisArg) {
      if (theArray) for (var len = theArray[LENGTH] >>> 0, idx = 0; idx < len && !(idx in theArray && callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1); idx++);
    }
    __name(arrForEach, "arrForEach");
    var arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto),
      arrMap = _unwrapFunction("map", ArrProto),
      arrSlice = _unwrapFunction(SLICE, ArrProto),
      arrReduce = _unwrapFunction("reduce", ArrProto),
      objCreate = ObjClass.create || polyObjCreate;
    function polyObjCreate(obj) {
      if (!obj) return {};
      var type = typeof obj;
      type !== OBJECT && type !== FUNCTION && throwTypeError("Prototype must be an Object or function: " + dumpObj(obj));
      function tempFunc() {}
      return __name(tempFunc, "tempFunc"), tempFunc[PROTOTYPE] = obj, new tempFunc();
    }
    __name(polyObjCreate, "polyObjCreate");
    var _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
      var fn = ObjClass.setPrototypeOf || function (d, b) {
        !_isProtoArray && (_isProtoArray = getLazy(function () {
          var _a;
          return _a = {}, _a[__PROTO__] = [], _a instanceof Array;
        })), _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) {
          return d[key] = value;
        });
      };
      return fn(obj, proto);
    }
    __name(objSetPrototypeOf, "objSetPrototypeOf");
    function _createCustomError(name, d, b) {
      safe(objDefine, [d, NAME, {
        v: name,
        c: !0,
        e: !1
      }]), d = objSetPrototypeOf(d, b);
      function __() {
        this.constructor = d, safe(objDefine, [this, NAME, {
          v: name,
          c: !0,
          e: !1
        }]);
      }
      return __name(__, "__"), d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __()), d;
    }
    __name(_createCustomError, "_createCustomError");
    function _setName(baseClass, name) {
      name && (baseClass[NAME] = name);
    }
    __name(_setName, "_setName");
    function createCustomError(name, constructCb, errorBase) {
      var theBaseClass = errorBase || Error,
        orgName = theBaseClass[PROTOTYPE][NAME],
        captureFn = Error.captureStackTrace;
      return _createCustomError(name, function () {
        var _this = this,
          theArgs = arguments;
        try {
          safe(_setName, [theBaseClass, name]);
          var _self = fnApply(theBaseClass, _this, ArrProto[SLICE][CALL](theArgs)) || _this;
          if (_self !== _this) {
            var orgProto = objGetPrototypeOf(_this);
            orgProto !== objGetPrototypeOf(_self) && objSetPrototypeOf(_self, orgProto);
          }
          return captureFn && captureFn(_self, _this[CONSTRUCTOR]), constructCb && constructCb(_self, theArgs), _self;
        } finally {
          safe(_setName, [theBaseClass, orgName]);
        }
      }, theBaseClass);
    }
    __name(createCustomError, "createCustomError");
    function utcNow() {
      return (Date.now || polyUtcNow)();
    }
    __name(utcNow, "utcNow");
    function polyUtcNow() {
      return new Date().getTime();
    }
    __name(polyUtcNow, "polyUtcNow");
    function _createTrimFn(exp) {
      return __name(function (value) {
        return isNullOrUndefined(value) && throwTypeError("strTrim called [" + dumpObj(value) + "]"), value && value.replace && (value = value.replace(exp, EMPTY)), value;
      }, "_doTrim");
    }
    __name(_createTrimFn, "_createTrimFn");
    var polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g),
      strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim),
      _fnToString,
      _objCtrFnString,
      _gblWindow;
    function isPlainObject(value) {
      if (!value || typeof value !== OBJECT) return !1;
      _gblWindow || (_gblWindow = hasWindow() ? getWindow() : !0);
      var result = !1;
      if (value !== _gblWindow) {
        _objCtrFnString || (_fnToString = Function[PROTOTYPE][TO_STRING], _objCtrFnString = _fnToString[CALL](ObjClass));
        try {
          var proto = objGetPrototypeOf(value);
          result = !proto, result || (objHasOwnProperty(proto, CONSTRUCTOR) && (proto = proto[CONSTRUCTOR]), result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString);
        } catch {}
      }
      return result;
    }
    __name(isPlainObject, "isPlainObject");
    var _defaultDeepCopyHandler = __name(function (details) {
        return details.value && plainObjDeepCopyHandler(details), !0;
      }, "_defaultDeepCopyHandler"),
      defaultDeepCopyHandlers = [arrayDeepCopyHandler, plainObjDeepCopyHandler, functionDeepCopyHandler, dateDeepCopyHandler];
    function _getSetVisited(visitMap, source, newPath, cb) {
      var theEntry;
      return arrForEach(visitMap, function (entry) {
        if (entry.k === source) return theEntry = entry, -1;
      }), theEntry || (theEntry = {
        k: source,
        v: source
      }, visitMap.push(theEntry), cb(theEntry)), theEntry.v;
    }
    __name(_getSetVisited, "_getSetVisited");
    function _deepCopy(visitMap, value, ctx, key) {
      var userHandler = ctx.handler,
        newPath = ctx.path ? key ? ctx.path.concat(key) : ctx.path : [],
        newCtx = {
          handler: ctx.handler,
          src: ctx.src,
          path: newPath
        },
        theType = typeof value,
        isPlain = !1,
        isPrim = !1;
      value && theType === OBJECT ? isPlain = isPlainObject(value) : isPrim = value === NULL_VALUE || isPrimitiveType(theType);
      var details = {
        type: theType,
        isPrim: isPrim,
        isPlain: isPlain,
        value: value,
        result: value,
        path: newPath,
        origin: ctx.src,
        copy: function (source, newKey) {
          return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
        },
        copyTo: function (target, source) {
          return _copyProps(visitMap, target, source, newCtx);
        }
      };
      return details.isPrim ? userHandler && userHandler[CALL](ctx, details) ? details.result : value : _getSetVisited(visitMap, value, newPath, function (newEntry) {
        objDefine(details, "result", {
          g: function () {
            return newEntry.v;
          },
          s: function (newValue) {
            newEntry.v = newValue;
          }
        });
        for (var idx = 0, handler = userHandler; !(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details);) handler = NULL_VALUE;
      });
    }
    __name(_deepCopy, "_deepCopy");
    function _copyProps(visitMap, target, source, ctx) {
      if (!isNullOrUndefined(source)) for (var key in source) target[key] = _deepCopy(visitMap, source[key], ctx, key);
      return target;
    }
    __name(_copyProps, "_copyProps");
    function objCopyProps(target, source, handler) {
      var ctx = {
        handler: handler,
        src: source,
        path: []
      };
      return _copyProps([], target, source, ctx);
    }
    __name(objCopyProps, "objCopyProps");
    function objDeepCopy(source, handler) {
      var ctx = {
        handler: handler,
        src: source
      };
      return _deepCopy([], source, ctx);
    }
    __name(objDeepCopy, "objDeepCopy");
    function arrayDeepCopyHandler(details) {
      var value = details.value;
      if (isArray(value)) {
        var target = details.result = [];
        return target.length = value.length, details.copyTo(target, value), !0;
      }
      return !1;
    }
    __name(arrayDeepCopyHandler, "arrayDeepCopyHandler");
    function dateDeepCopyHandler(details) {
      var value = details.value;
      return isDate(value) ? (details.result = new Date(value.getTime()), !0) : !1;
    }
    __name(dateDeepCopyHandler, "dateDeepCopyHandler");
    function functionDeepCopyHandler(details) {
      return details.type === FUNCTION;
    }
    __name(functionDeepCopyHandler, "functionDeepCopyHandler");
    function plainObjDeepCopyHandler(details) {
      var value = details.value;
      if (value && details.isPlain) {
        var target = details.result = {};
        return details.copyTo(target, value), !0;
      }
      return !1;
    }
    __name(plainObjDeepCopyHandler, "plainObjDeepCopyHandler");
    function _doExtend(target, theArgs) {
      return arrForEach(theArgs, function (theArg) {
        objCopyProps(target, theArg);
      }), target;
    }
    __name(_doExtend, "_doExtend");
    function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
      return _doExtend(objDeepCopy(target) || {}, ArrProto[SLICE][CALL](arguments));
    }
    __name(deepExtend, "deepExtend");
    var getLength = _unwrapProp(LENGTH),
      strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
      isString(value) || throwTypeError("'" + dumpObj(value) + "' is not a string");
      var searchValue = isString(searchString) ? searchString : asString(searchString),
        end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];
      return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;
    }
    __name(polyStrEndsWith, "polyStrEndsWith");
    var strIndexOf = _unwrapFunction(INDEX_OF, StrProto),
      REF = "ref",
      UNREF = "un" + REF,
      HAS_REF = "hasRef",
      ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
      var _a,
        ref = !0,
        timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE,
        theTimerHandler,
        _unref = __name(function () {
          return ref = !1, timerId && timerId[UNREF] && timerId[UNREF](), theTimerHandler;
        }, "_unref"),
        _ref = __name(function () {
          return ref = !0, timerId && timerId[REF] && timerId[REF](), theTimerHandler;
        }, "_ref"),
        _hasRef = __name(function () {
          return timerId && timerId[HAS_REF] ? timerId[HAS_REF]() : ref;
        }, "_hasRef"),
        _refresh = __name(function () {
          return timerId = refreshFn(timerId), ref || _unref(), theTimerHandler;
        }, "_refresh"),
        _cancel = __name(function () {
          timerId && cancelFn(timerId), timerId = NULL_VALUE;
        }, "_cancel"),
        _setEnabled = __name(function (value) {
          !value && timerId && _cancel(), value && !timerId && _refresh();
        }, "_setEnabled");
      return theTimerHandler = (_a = {
        cancel: _cancel,
        refresh: _refresh
      }, _a[HAS_REF] = _hasRef, _a[REF] = _ref, _a[UNREF] = _unref, _a[ENABLED] = !1, _a), objDefineProp(theTimerHandler, ENABLED, {
        get: function () {
          return !!timerId;
        },
        set: _setEnabled
      }), {
        h: theTimerHandler,
        dn: function () {
          timerId = NULL_VALUE;
        }
      };
    }
    __name(_createTimerHandler, "_createTimerHandler");
    function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
      var isArr = isArray(overrideFn),
        len = isArr ? overrideFn.length : 0,
        setFn = (len > 0 ? overrideFn[0] : isArr ? UNDEF_VALUE : overrideFn) || setTimeout,
        clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout,
        timerFn = theArgs[0];
      theArgs[0] = function () {
        handler.dn(), fnApply(timerFn, self, ArrProto[SLICE][CALL](arguments));
      };
      var handler = _createTimerHandler(startTimer, function (timerId) {
        if (timerId) {
          if (timerId.refresh) return timerId.refresh(), timerId;
          fnApply(clearFn, self, [timerId]);
        }
        return fnApply(setFn, self, theArgs);
      }, function (timerId) {
        fnApply(clearFn, self, [timerId]);
      });
      return handler.h;
    }
    __name(_createTimeoutWith, "_createTimeoutWith");
    function scheduleTimeout(callback, timeout) {
      return _createTimeoutWith(this, !0, UNDEF_VALUE, ArrProto[SLICE][CALL](arguments));
    }
    __name(scheduleTimeout, "scheduleTimeout");
    function createTimeout(callback, timeout) {
      return _createTimeoutWith(this, !1, UNDEF_VALUE, ArrProto[SLICE][CALL](arguments));
    }
    __name(createTimeout, "createTimeout");
    var _a,
      Constructor = "constructor",
      Prototype = "prototype",
      strFunction = "function",
      DynInstFuncTable = "_dynInstFuncs",
      DynProxyTag = "_isDynProxy",
      DynClassName = "_dynClass",
      DynClassNamePrefix = "_dynCls$",
      DynInstChkTag = "_dynInstChk",
      DynAllowInstChkTag = DynInstChkTag,
      DynProtoDefaultOptions = "_dfOpts",
      UnknownValue = "_unknown_",
      str__Proto = "__proto__",
      DynProtoBaseProto = "_dyn" + str__Proto,
      DynProtoGlobalSettings = "__dynProto$Gbl",
      DynProtoCurrent = "_dynInstProto",
      strUseBaseInst = "useBaseInst",
      strSetInstFuncs = "setInstFuncs",
      Obj = Object,
      _objGetPrototypeOf = Obj.getPrototypeOf,
      _objGetOwnProps = Obj.getOwnPropertyNames,
      _gbl = getGlobal(),
      _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a = {}, _a[strSetInstFuncs] = !0, _a[strUseBaseInst] = !0, _a),
        n: 1e3
      });
    function _isObjectOrArrayPrototype(target) {
      return target && (target === Obj[Prototype] || target === Array[Prototype]);
    }
    __name(_isObjectOrArrayPrototype, "_isObjectOrArrayPrototype");
    function _isObjectArrayOrFunctionPrototype(target) {
      return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
    }
    __name(_isObjectArrayOrFunctionPrototype, "_isObjectArrayOrFunctionPrototype");
    function _getObjProto(target) {
      var newProto;
      if (target) {
        if (_objGetPrototypeOf) return _objGetPrototypeOf(target);
        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
        newProto = target[DynProtoBaseProto] || curProto, objHasOwnProperty(target, DynProtoBaseProto) || (delete target[DynProtoCurrent], newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto], target[DynProtoCurrent] = curProto);
      }
      return newProto;
    }
    __name(_getObjProto, "_getObjProto");
    function _forEachProp(target, func) {
      var props = [];
      if (_objGetOwnProps) props = _objGetOwnProps(target);else for (var name_1 in target) typeof name_1 == "string" && objHasOwnProperty(target, name_1) && props.push(name_1);
      if (props && props.length > 0) for (var lp = 0; lp < props.length; lp++) func(props[lp]);
    }
    __name(_forEachProp, "_forEachProp");
    function _isDynamicCandidate(target, funcName, skipOwn) {
      return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;
    }
    __name(_isDynamicCandidate, "_isDynamicCandidate");
    function _throwTypeError(message) {
      throwTypeError("DynamicProto: " + message);
    }
    __name(_throwTypeError, "_throwTypeError");
    function _getInstanceFuncs(thisTarget) {
      var instFuncs = objCreate(null);
      return _forEachProp(thisTarget, function (name) {
        !instFuncs[name] && _isDynamicCandidate(thisTarget, name, !1) && (instFuncs[name] = thisTarget[name]);
      }), instFuncs;
    }
    __name(_getInstanceFuncs, "_getInstanceFuncs");
    function _hasVisited(values, value) {
      for (var lp = values.length - 1; lp >= 0; lp--) if (values[lp] === value) return !0;
      return !1;
    }
    __name(_hasVisited, "_hasVisited");
    function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
      function _instFuncProxy(target, funcHost, funcName) {
        var theFunc = funcHost[funcName];
        if (theFunc[DynProxyTag] && useBaseInst) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFuncTable[DynAllowInstChkTag] !== !1 && (theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc);
        }
        return function () {
          return theFunc.apply(target, arguments);
        };
      }
      __name(_instFuncProxy, "_instFuncProxy");
      var baseFuncs = objCreate(null);
      _forEachProp(instFuncs, function (name) {
        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);
      });
      for (var baseProto = _getObjProto(classProto), visited = []; baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto);) _forEachProp(baseProto, function (name) {
        !baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf) && (baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name));
      }), visited.push(baseProto), baseProto = _getObjProto(baseProto);
      return baseFuncs;
    }
    __name(_getBaseFuncs, "_getBaseFuncs");
    function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
      var instFunc = null;
      if (target && objHasOwnProperty(proto, DynClassName)) {
        var instFuncTable = target[DynInstFuncTable] || objCreate(null);
        if (instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName], instFunc || _throwTypeError("Missing [" + funcName + "] " + strFunction), !instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== !1) {
          for (var canAddInst = !objHasOwnProperty(target, funcName), objProto = _getObjProto(target), visited = []; canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto);) {
            var protoFunc = objProto[funcName];
            if (protoFunc) {
              canAddInst = protoFunc === currentDynProtoProxy;
              break;
            }
            visited.push(objProto), objProto = _getObjProto(objProto);
          }
          try {
            canAddInst && (target[funcName] = instFunc), instFunc[DynInstChkTag] = 1;
          } catch {
            instFuncTable[DynAllowInstChkTag] = !1;
          }
        }
      }
      return instFunc;
    }
    __name(_getInstFunc, "_getInstFunc");
    function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
      var protoFunc = proto[funcName];
      return protoFunc === currentDynProtoProxy && (protoFunc = _getObjProto(proto)[funcName]), typeof protoFunc !== strFunction && _throwTypeError("[" + funcName + "] is not a " + strFunction), protoFunc;
    }
    __name(_getProtoFunc, "_getProtoFunc");
    function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
      function _createDynamicPrototype(proto, funcName) {
        var dynProtoProxy = __name(function () {
          var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);
          return instFunc.apply(this, arguments);
        }, "dynProtoProxy");
        return dynProtoProxy[DynProxyTag] = 1, dynProtoProxy;
      }
      if (__name(_createDynamicPrototype, "_createDynamicPrototype"), !_isObjectOrArrayPrototype(proto)) {
        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);
        if (!_isObjectOrArrayPrototype(instFuncTable)) {
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null);
          instFuncTable[DynAllowInstChkTag] !== !1 && (instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc), _isObjectOrArrayPrototype(instFuncs_1) || _forEachProp(target, function (name) {
            _isDynamicCandidate(target, name, !1) && target[name] !== baseInstFuncs[name] && (instFuncs_1[name] = target[name], delete target[name], (!objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) && (proto[name] = _createDynamicPrototype(proto, name)));
          });
        }
      }
    }
    __name(_populatePrototype, "_populatePrototype");
    function _checkPrototype(classProto, thisTarget) {
      if (_objGetPrototypeOf) {
        for (var visited = [], thisProto = _getObjProto(thisTarget); thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto);) {
          if (thisProto === classProto) return !0;
          visited.push(thisProto), thisProto = _getObjProto(thisProto);
        }
        return !1;
      }
      return !0;
    }
    __name(_checkPrototype, "_checkPrototype");
    function _getObjName(target, unknownValue) {
      return objHasOwnProperty(target, Prototype) ? target.name || unknownValue || UnknownValue : ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
    }
    __name(_getObjName, "_getObjName");
    function dynamicProto(theClass, target, delegateFunc, options) {
      objHasOwnProperty(theClass, Prototype) || _throwTypeError("theClass is an invalid class definition.");
      var classProto = theClass[Prototype];
      _checkPrototype(classProto, target) || _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
      var className = null;
      objHasOwnProperty(classProto, DynClassName) ? className = classProto[DynClassName] : (className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n, _gblInst.n++, classProto[DynClassName] = className);
      var perfOptions = dynamicProto[DynProtoDefaultOptions],
        useBaseInst = !!perfOptions[strUseBaseInst];
      useBaseInst && options && options[strUseBaseInst] !== void 0 && (useBaseInst = !!options[strUseBaseInst]);
      var instFuncs = _getInstanceFuncs(target),
        baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
      delegateFunc(target, baseFuncs);
      var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
      setInstanceFunc && options && (setInstanceFunc = !!options[strSetInstFuncs]), _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== !1);
    }
    __name(dynamicProto, "dynamicProto"), dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
    var strShimFunction = "function",
      strShimObject = "object",
      strShimUndefined = "undefined",
      strShimPrototype = "prototype",
      ObjClass = Object,
      ObjProto = ObjClass[strShimPrototype],
      strHasOwnProperty = "hasOwnProperty",
      __objAssignFnImpl = __name(function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) ObjProto[strHasOwnProperty].call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, "__objAssignFnImpl"),
      __assignFn = objAssign || __objAssignFnImpl,
      extendStaticsFn = __name(function (d, b) {
        return extendStaticsFn = ObjClass.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) b[strHasOwnProperty](p) && (d[p] = b[p]);
        }, extendStaticsFn(d, b);
      }, "extendStaticsFn");
    function __extendsFn(d, b) {
      typeof b !== strShimFunction && b !== null && throwTypeError("Class extends value " + String(b) + " is not a constructor or null"), extendStaticsFn(d, b);
      function __() {
        this.constructor = d;
      }
      __name(__, "__"), d[strShimPrototype] = b === null ? objCreate(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
    }
    __name(__extendsFn, "__extendsFn");
    function __spreadArrayFn(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
      return to;
    }
    __name(__spreadArrayFn, "__spreadArrayFn");
    var createEnumStyle = createEnum,
      createValueMap = createTypeMap,
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_BLK_VAL = "blkVal",
      _DYN_LENGTH = "length",
      _DYN_RD_ONLY = "rdOnly",
      _DYN_NOTIFY = "notify",
      _DYN_WARN_TO_CONSOLE = "warnToConsole",
      _DYN_THROW_INTERNAL = "throwInternal",
      _DYN_SET_DF = "setDf",
      _DYN_WATCH = "watch",
      _DYN_LOGGER = "logger",
      _DYN_APPLY = "apply",
      _DYN_PUSH = "push",
      _DYN_SPLICE = "splice",
      _DYN_HDLR = "hdlr",
      _DYN_CANCEL = "cancel",
      _DYN_INITIALIZE = "initialize",
      _DYN_IDENTIFIER = "identifier",
      _DYN_IS_INITIALIZED = "isInitialized",
      _DYN_GET_PLUGIN = "getPlugin",
      _DYN_POLL_INTERNAL_LOGS = "pollInternalLogs",
      _DYN_NAME = "name",
      _DYN_TIME = "time",
      _DYN_PROCESS_NEXT = "processNext",
      _DYN_GET_PROCESS_TEL_CONT0 = "getProcessTelContext",
      _DYN_GET_NOTIFY_MGR = "getNotifyMgr",
      _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener",
      _DYN_REMOVE_NOTIFICATION_2 = "removeNotificationListener",
      _DYN_ENABLED = "enabled",
      _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs",
      _DYN_UNLOAD = "unload",
      _DYN_ON_COMPLETE = "onComplete",
      _DYN_VERSION = "version",
      _DYN_LOGGING_LEVEL_CONSOL4 = "loggingLevelConsole",
      _DYN_CREATE_NEW = "createNew",
      _DYN_TEARDOWN = "teardown",
      _DYN_MESSAGE_ID = "messageId",
      _DYN_MESSAGE = "message",
      _DYN_IS_ASYNC = "isAsync",
      _DYN_DIAG_LOG = "diagLog",
      _DYN__DO_TEARDOWN = "_doTeardown",
      _DYN_UPDATE = "update",
      _DYN_GET_NEXT = "getNext",
      _DYN_SET_NEXT_PLUGIN = "setNextPlugin",
      _DYN_USER_AGENT = "userAgent",
      _DYN_SPLIT = "split",
      _DYN_NODE_TYPE = "nodeType",
      _DYN_REPLACE = "replace",
      _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage",
      _DYN_TYPE = "type",
      _DYN_HANDLER = "handler",
      _DYN_IS_CHILD_EVT = "isChildEvt",
      _DYN_GET_CTX = "getCtx",
      _DYN_SET_CTX = "setCtx",
      _DYN_COMPLETE = "complete",
      _DYN_TRACE_ID = "traceId",
      _DYN_SPAN_ID = "spanId",
      _DYN_TRACE_FLAGS = "traceFlags",
      aggregationErrorType;
    function throwAggregationError(message, sourceErrors) {
      aggregationErrorType || (aggregationErrorType = createCustomError("AggregationError", function (self, args) {
        args[_DYN_LENGTH] > 1 && (self.errors = args[1]);
      }));
      var theMessage = message || "One or more errors occurred.";
      throw arrForEach(sourceErrors, function (srcError, idx) {
        theMessage += `
`.concat(idx, " > ").concat(dumpObj(srcError));
      }), new aggregationErrorType(theMessage, sourceErrors || []);
    }
    __name(throwAggregationError, "throwAggregationError");
    function doAwaitResponse(value, cb) {
      return doAwait(value, function (value) {
        return cb ? cb({
          value: value,
          rejected: !1
        }) : value;
      }, function (reason) {
        return cb ? cb({
          rejected: !0,
          reason: reason
        }) : reason;
      });
    }
    __name(doAwaitResponse, "doAwaitResponse");
    function doAwait(value, resolveFn, rejectFn, finallyFn) {
      var result = value;
      return isPromiseLike(value) ? (resolveFn || rejectFn) && (result = value.then(resolveFn, rejectFn)) : resolveFn && (result = resolveFn(value)), finallyFn && doFinally(result, finallyFn), result;
    }
    __name(doAwait, "doAwait");
    function doFinally(value, finallyFn) {
      var result = value;
      return finallyFn && (isPromiseLike(value) ? value.finally ? result = value.finally(finallyFn) : result = value.then(function (value) {
        return finallyFn(), value;
      }, function (reason) {
        throw finallyFn(), reason;
      }) : finallyFn()), result;
    }
    __name(doFinally, "doFinally");
    var STRING_STATES = ["pending", "resolving", "resolved", "rejected"],
      DISPATCH_EVENT = "dispatchEvent",
      _hasInitEvent;
    function emitEvent(target, evtName, populateEvent, useNewEvent) {
      var doc = getDocument();
      !_hasInitEvent && (_hasInitEvent = safeGetLazy(function () {
        var evt;
        return doc && doc.createEvent && (evt = doc.createEvent("Event")), !!evt && evt.initEvent;
      }, null));
      var theEvt = _hasInitEvent.v ? doc.createEvent("Event") : useNewEvent ? new Event(evtName) : {};
      if (populateEvent && populateEvent(theEvt), _hasInitEvent.v && theEvt.initEvent(evtName, !1, !0), theEvt && target[DISPATCH_EVENT]) target[DISPATCH_EVENT](theEvt);else {
        var handler = target["on" + evtName];
        if (handler) handler(theEvt);else {
          var theConsole = getInst("console");
          theConsole && (theConsole.error || theConsole.log)(evtName, dumpObj(theEvt));
        }
      }
    }
    __name(emitEvent, "emitEvent");
    var STR_PROMISE = "Promise",
      NODE_UNHANDLED_REJECTION = "unhandledRejection",
      UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase(),
      _unhandledRejectionTimeout = 10,
      _hasPromiseRejectionEvent;
    function dumpFnObj(value) {
      return isFunction(value) ? value.toString() : dumpObj(value);
    }
    __name(dumpFnObj, "dumpFnObj");
    function _createPromise(newPromise, processor, executor) {
      var additionalArgs = arrSlice(arguments, 3),
        _state = 0,
        _hasResolved = !1,
        _settledValue,
        _queue = [],
        _handled = !1,
        _unHandledRejectionHandler = null,
        _thePromise;
      !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = lazySafeGetInst(STR_PROMISE + "RejectionEvent"));
      var _then = __name(function (onResolved, onRejected) {
          try {
            _handled = !0, _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), _unHandledRejectionHandler = null;
            var thenPromise = newPromise(function (resolve, reject) {
              _queue.push(function () {
                try {
                  var handler = _state === 2 ? onResolved : onRejected,
                    value = isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;
                  isPromiseLike(value) ? value.then(resolve, reject) : handler ? resolve(value) : _state === 3 ? reject(value) : resolve(value);
                } catch (e) {
                  reject(e);
                }
              }), _hasResolved && _processQueue();
            }, additionalArgs);
            return thenPromise;
          } finally {}
        }, "_then"),
        _catch = __name(function (onRejected) {
          return _then(void 0, onRejected);
        }, "_catch"),
        _finally = __name(function (onFinally) {
          var thenFinally = onFinally,
            catchFinally = onFinally;
          return isFunction(onFinally) && (thenFinally = __name(function (value) {
            return onFinally && onFinally(), value;
          }, "thenFinally"), catchFinally = __name(function (reason) {
            throw onFinally && onFinally(), reason;
          }, "catchFinally")), _then(thenFinally, catchFinally);
        }, "_finally"),
        _strState = __name(function () {
          return STRING_STATES[_state];
        }, "_strState"),
        _processQueue = __name(function () {
          if (_queue.length > 0) {
            var pending = _queue.slice();
            _queue = [], _handled = !0, processor(pending), _unHandledRejectionHandler && _unHandledRejectionHandler.cancel(), _unHandledRejectionHandler = null;
          }
        }, "_processQueue"),
        _createSettleIfFn = __name(function (newState, allowState) {
          return function (theValue) {
            if (_state === allowState) {
              if (newState === 2 && isPromiseLike(theValue)) {
                _state = 1, theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));
                return;
              }
              _state = newState, _hasResolved = !0, _settledValue = theValue, _processQueue(), !_handled && newState === 3 && !_unHandledRejectionHandler && (_unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout));
            }
          };
        }, "_createSettleIfFn"),
        _notifyUnhandledRejection = __name(function () {
          if (!_handled) if (isNode()) process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);else {
            var gbl = getWindow() || getGlobal();
            emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {
              return objDefine(theEvt, "promise", {
                g: function () {
                  return _thePromise;
                }
              }), theEvt.reason = _settledValue, theEvt;
            }, !!_hasPromiseRejectionEvent.v);
          }
        }, "_notifyUnhandledRejection");
      _thePromise = {
        then: _then,
        catch: _catch,
        finally: _finally
      }, objDefineProp(_thePromise, "state", {
        get: _strState
      }), hasSymbol() && (_thePromise[getKnownSymbol(11)] = "IPromise");
      var _toString = __name(function () {
        return "IPromise " + _strState() + (_hasResolved ? " - " + dumpFnObj(_settledValue) : "");
      }, "_toString");
      return _thePromise.toString = _toString, __name(function () {
        isFunction(executor) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpFnObj(executor));
        var _rejectFn = _createSettleIfFn(3, 0);
        try {
          executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);
        } catch (e) {
          _rejectFn(e);
        }
      }, "_initialize")(), _thePromise;
    }
    __name(_createPromise, "_createPromise");
    function _createAllPromise(newPromise) {
      return function (input) {
        var additionalArgs = arrSlice(arguments, 1);
        return newPromise(function (resolve, reject) {
          try {
            var values_1 = [],
              pending_1 = 1;
            arrForEach(input, function (item, idx) {
              item && (pending_1++, doAwait(item, function (value) {
                values_1[idx] = value, --pending_1 === 0 && resolve(values_1);
              }, reject));
            }), pending_1--, pending_1 === 0 && resolve(values_1);
          } catch (e) {
            reject(e);
          }
        }, additionalArgs);
      };
    }
    __name(_createAllPromise, "_createAllPromise");
    var _processPendingItems = __name(function (pending) {
      arrForEach(pending, function (fn) {
        try {
          fn();
        } catch {}
      });
    }, "_processPendingItems");
    function timeoutItemProcessor(timeout) {
      var callbackTimeout = isNumber(timeout) ? timeout : 0;
      return function (pending) {
        scheduleTimeout(function () {
          _processPendingItems(pending);
        }, callbackTimeout);
      };
    }
    __name(timeoutItemProcessor, "timeoutItemProcessor");
    function createAsyncPromise(executor, timeout) {
      return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);
    }
    __name(createAsyncPromise, "createAsyncPromise");
    var _isPromiseSupported;
    function createNativePromise(executor, timeout) {
      !_isPromiseSupported && (_isPromiseSupported = lazySafeGetInst(STR_PROMISE));
      var PrmCls = _isPromiseSupported.v;
      if (!PrmCls) return createAsyncPromise(executor);
      isFunction(executor) || throwTypeError(STR_PROMISE + ": executor is not a function - " + dumpObj(executor));
      var _state = 0;
      function _strState() {
        return STRING_STATES[_state];
      }
      __name(_strState, "_strState");
      var thePromise = new PrmCls(function (resolve, reject) {
        function _resolve(value) {
          _state = 2, resolve(value);
        }
        __name(_resolve, "_resolve");
        function _reject(reason) {
          _state = 3, reject(reason);
        }
        __name(_reject, "_reject"), executor(_resolve, _reject);
      });
      return objDefineProp(thePromise, "state", {
        get: _strState
      }), thePromise;
    }
    __name(createNativePromise, "createNativePromise");
    var _promiseCreator;
    function createPromise(executor, timeout) {
      return !_promiseCreator && (_promiseCreator = getLazy(function () {
        return createNativePromise;
      })), _promiseCreator.v.call(this, executor, timeout);
    }
    __name(createPromise, "createPromise");
    var createAllPromise = _createAllPromise(createPromise),
      UNDEFINED_VALUE = void 0,
      STR_EMPTY = "",
      STR_CHANNELS = "channels",
      STR_CORE = "core",
      STR_CREATE_PERF_MGR = "createPerfMgr",
      STR_DISABLED = "disabled",
      STR_EXTENSION_CONFIG = "extensionConfig",
      STR_EXTENSIONS = "extensions",
      STR_PROCESS_TELEMETRY = "processTelemetry",
      STR_PRIORITY = "priority",
      STR_EVENTS_SENT = "eventsSent",
      STR_EVENTS_DISCARDED = "eventsDiscarded",
      STR_EVENTS_SEND_REQUEST = "eventsSendRequest",
      STR_PERF_EVENT = "perfEvent",
      STR_GET_PERF_MGR = "getPerfMgr",
      STR_DOMAIN = "domain",
      STR_PATH = "path",
      STR_NOT_DYNAMIC_ERROR = "Not dynamic - ",
      rCamelCase = /-([a-z])/g,
      rNormalizeInvalid = /([^\w\d_$])/g,
      rLeadingNumeric = /^(\d+[\w\d_$])/;
    function isNotNullOrUndefined(value) {
      return !isNullOrUndefined(value);
    }
    __name(isNotNullOrUndefined, "isNotNullOrUndefined");
    function normalizeJsName(name) {
      var value = name;
      return value && isString(value) && (value = value[_DYN_REPLACE](rCamelCase, function (_all, letter) {
        return letter.toUpperCase();
      }), value = value[_DYN_REPLACE](rNormalizeInvalid, "_"), value = value[_DYN_REPLACE](rLeadingNumeric, function (_all, match) {
        return "_" + match;
      })), value;
    }
    __name(normalizeJsName, "normalizeJsName");
    function strContains(value, search) {
      return value && search ? strIndexOf(value, search) !== -1 : !1;
    }
    __name(strContains, "strContains");
    function toISOString(date) {
      return date && date.toISOString() || "";
    }
    __name(toISOString, "toISOString");
    function getExceptionName(object) {
      return isError(object) ? object[_DYN_NAME] : STR_EMPTY;
    }
    __name(getExceptionName, "getExceptionName");
    function setValue(target, field, value, valChk, srcChk) {
      var theValue = value;
      return target && (theValue = target[field], theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value)) && (theValue = value, target[field] = theValue)), theValue;
    }
    __name(setValue, "setValue");
    function getSetValue(target, field, defValue) {
      var theValue;
      return target ? (theValue = target[field], !theValue && isNullOrUndefined(theValue) && (theValue = isUndefined(defValue) ? {} : defValue, target[field] = theValue)) : theValue = isUndefined(defValue) ? {} : defValue, theValue;
    }
    __name(getSetValue, "getSetValue");
    function _createProxyFunction(source, funcName) {
      var srcFunc = null,
        src = null;
      return isFunction(source) ? srcFunc = source : src = source, function () {
        var originalArguments = arguments;
        if (srcFunc && (src = srcFunc()), src) return src[funcName][_DYN_APPLY](src, originalArguments);
      };
    }
    __name(_createProxyFunction, "_createProxyFunction");
    function proxyFunctionAs(target, name, source, theFunc, overwriteTarget) {
      target && name && source && (overwriteTarget !== !1 || isUndefined(target[name])) && (target[name] = _createProxyFunction(source, theFunc));
    }
    __name(proxyFunctionAs, "proxyFunctionAs");
    function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
      return target && source && isObject(target) && isArray(functionsToProxy) && arrForEach(functionsToProxy, function (theFuncName) {
        isString(theFuncName) && proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
      }), target;
    }
    __name(proxyFunctions, "proxyFunctions");
    function createClassFromInterface(defaults) {
      return function () {
        function class_1() {
          var _this = this;
          defaults && objForEachKey(defaults, function (field, value) {
            _this[field] = value;
          });
        }
        return __name(class_1, "class_1"), class_1;
      }();
    }
    __name(createClassFromInterface, "createClassFromInterface");
    function optimizeObject(theObject) {
      return theObject && ObjAssign && (theObject = ObjClass(ObjAssign({}, theObject))), theObject;
    }
    __name(optimizeObject, "optimizeObject");
    function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
      var theArgs = arguments,
        extended = theArgs[0] || {},
        argLen = theArgs[_DYN_LENGTH],
        deep = !1,
        idx = 1;
      for (argLen > 0 && isBoolean(extended) && (deep = extended, extended = theArgs[idx] || {}, idx++), isObject(extended) || (extended = {}); idx < argLen; idx++) {
        var arg = theArgs[idx],
          isArgArray = isArray(arg),
          isArgObj = isObject(arg);
        for (var prop in arg) {
          var propOk = isArgArray && prop in arg || isArgObj && objHasOwn(arg, prop);
          if (propOk) {
            var newValue = arg[prop],
              isNewArray = void 0;
            if (deep && newValue && ((isNewArray = isArray(newValue)) || isPlainObject(newValue))) {
              var clone = extended[prop];
              isNewArray ? isArray(clone) || (clone = []) : isPlainObject(clone) || (clone = {}), newValue = objExtend(deep, clone, newValue);
            }
            newValue !== void 0 && (extended[prop] = newValue);
          }
        }
      }
      return extended;
    }
    __name(objExtend, "objExtend");
    var strDocumentMode = "documentMode",
      strLocation = "location",
      strConsole = "console",
      strJSON = "JSON",
      strCrypto = "crypto",
      strMsCrypto = "msCrypto",
      strMsie = "msie",
      strTrident = "trident/",
      strXMLHttpRequest = "XMLHttpRequest",
      _isTrident = null,
      _navUserAgentCheck = null,
      _enableMocks = !1,
      _useXDomainRequest = null,
      _beaconsSupported = null;
    function _hasProperty(theClass, property) {
      var supported = !1;
      if (theClass) {
        try {
          if (supported = property in theClass, !supported) {
            var proto = theClass[strShimPrototype];
            proto && (supported = property in proto);
          }
        } catch {}
        if (!supported) try {
          var tmp = new theClass();
          supported = !isUndefined(tmp[property]);
        } catch {}
      }
      return supported;
    }
    __name(_hasProperty, "_hasProperty");
    function getLocation(checkForMock) {
      if (checkForMock && _enableMocks) {
        var mockLocation = getInst("__mockLocation");
        if (mockLocation) return mockLocation;
      }
      return typeof location === strShimObject && location ? location : getInst(strLocation);
    }
    __name(getLocation, "getLocation");
    function getConsole() {
      return typeof console !== strShimUndefined ? console : getInst(strConsole);
    }
    __name(getConsole, "getConsole");
    function hasJSON() {
      return !!(typeof JSON === strShimObject && JSON || getInst(strJSON) !== null);
    }
    __name(hasJSON, "hasJSON");
    function getJSON() {
      return hasJSON() ? JSON || getInst(strJSON) : null;
    }
    __name(getJSON, "getJSON");
    function getCrypto() {
      return getInst(strCrypto);
    }
    __name(getCrypto, "getCrypto");
    function getMsCrypto() {
      return getInst(strMsCrypto);
    }
    __name(getMsCrypto, "getMsCrypto");
    function isIE() {
      var nav = getNavigator();
      if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
        _navUserAgentCheck = nav[_DYN_USER_AGENT];
        var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
      }
      return _isTrident;
    }
    __name(isIE, "isIE");
    function getIEVersion(userAgentStr) {
      if (userAgentStr === void 0 && (userAgentStr = null), !userAgentStr) {
        var navigator_1 = getNavigator() || {};
        userAgentStr = navigator_1 ? (navigator_1.userAgent || STR_EMPTY)[_DYN_TO_LOWER_CASE]() : STR_EMPTY;
      }
      var ua = (userAgentStr || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
      if (strContains(ua, strMsie)) {
        var doc = getDocument() || {};
        return Math.max(parseInt(ua[_DYN_SPLIT](strMsie)[1]), doc[strDocumentMode] || 0);
      } else if (strContains(ua, strTrident)) {
        var tridentVer = parseInt(ua[_DYN_SPLIT](strTrident)[1]);
        if (tridentVer) return tridentVer + 4;
      }
      return null;
    }
    __name(getIEVersion, "getIEVersion");
    function isBeaconsSupported(useCached) {
      return (_beaconsSupported === null || useCached === !1) && (_beaconsSupported = hasNavigator() && !!getNavigator().sendBeacon), _beaconsSupported;
    }
    __name(isBeaconsSupported, "isBeaconsSupported");
    function isFetchSupported(withKeepAlive) {
      var isSupported = !1;
      try {
        isSupported = !!getInst("fetch");
        var request = getInst("Request");
        isSupported && withKeepAlive && request && (isSupported = _hasProperty(request, "keepalive"));
      } catch {}
      return isSupported;
    }
    __name(isFetchSupported, "isFetchSupported");
    function useXDomainRequest() {
      return _useXDomainRequest === null && (_useXDomainRequest = typeof XDomainRequest !== strShimUndefined, _useXDomainRequest && isXhrSupported() && (_useXDomainRequest = _useXDomainRequest && !_hasProperty(getInst(strXMLHttpRequest), "withCredentials"))), _useXDomainRequest;
    }
    __name(useXDomainRequest, "useXDomainRequest");
    function isXhrSupported() {
      var isSupported = !1;
      try {
        var xmlHttpRequest = getInst(strXMLHttpRequest);
        isSupported = !!xmlHttpRequest;
      } catch {}
      return isSupported;
    }
    __name(isXhrSupported, "isXhrSupported");
    var UInt32Mask = 4294967296,
      MaxUInt32 = 4294967295,
      SEED1 = 123456789,
      SEED2 = 987654321,
      _mwcSeeded = !1,
      _mwcW = SEED1,
      _mwcZ = SEED2;
    function _mwcSeed(seedValue) {
      seedValue < 0 && (seedValue >>>= 0), _mwcW = SEED1 + seedValue & MaxUInt32, _mwcZ = SEED2 - seedValue & MaxUInt32, _mwcSeeded = !0;
    }
    __name(_mwcSeed, "_mwcSeed");
    function _autoSeedMwc() {
      try {
        var now = utcNow() & 2147483647;
        _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
      } catch {}
    }
    __name(_autoSeedMwc, "_autoSeedMwc");
    function random32(signed) {
      var value = 0,
        c = getCrypto() || getMsCrypto();
      return c && c.getRandomValues && (value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32), value === 0 && isIE() && (_mwcSeeded || _autoSeedMwc(), value = mwcRandom32() & MaxUInt32), value === 0 && (value = Math.floor(UInt32Mask * Math.random() | 0)), signed || (value >>>= 0), value;
    }
    __name(random32, "random32");
    function mwcRandom32(signed) {
      _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32, _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
      var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
      return signed || (value >>>= 0), value;
    }
    __name(mwcRandom32, "mwcRandom32");
    function newId(maxLength) {
      maxLength === void 0 && (maxLength = 22);
      for (var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", number = random32() >>> 0, chars = 0, result = STR_EMPTY; result[_DYN_LENGTH] < maxLength;) chars++, result += base64chars.charAt(number & 63), number >>>= 6, chars === 5 && (number = (random32() << 2 & 4294967295 | number & 3) >>> 0, chars = 0);
      return result;
    }
    __name(newId, "newId");
    var version = "3.0.5",
      instanceName = "." + newId(6),
      _dataUid = 0;
    function _canAcceptData(target) {
      return target[_DYN_NODE_TYPE] === 1 || target[_DYN_NODE_TYPE] === 9 || !+target[_DYN_NODE_TYPE];
    }
    __name(_canAcceptData, "_canAcceptData");
    function _getCache(data, target) {
      var theCache = target[data.id];
      if (!theCache) {
        theCache = {};
        try {
          _canAcceptData(target) && objDefine(target, data.id, {
            e: !1,
            v: theCache
          });
        } catch {}
      }
      return theCache;
    }
    __name(_getCache, "_getCache");
    function createUniqueNamespace(name, includeVersion) {
      return includeVersion === void 0 && (includeVersion = !1), normalizeJsName(name + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
    }
    __name(createUniqueNamespace, "createUniqueNamespace");
    function createElmNodeData(name) {
      var data = {
        id: createUniqueNamespace("_aiData-" + (name || STR_EMPTY) + "." + version),
        accept: function (target) {
          return _canAcceptData(target);
        },
        get: function (target, name, defValue, addDefault) {
          var theCache = target[data.id];
          return theCache ? theCache[normalizeJsName(name)] : (addDefault && (theCache = _getCache(data, target), theCache[normalizeJsName(name)] = defValue), defValue);
        },
        kill: function (target, name) {
          if (target && target[name]) try {
            delete target[name];
          } catch {}
        }
      };
      return data;
    }
    __name(createElmNodeData, "createElmNodeData");
    function _isConfigDefaults(value) {
      return value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, "v") || objHasOwn(value, "mrg") || objHasOwn(value, "ref") || value.set);
    }
    __name(_isConfigDefaults, "_isConfigDefaults");
    function _getDefault(dynamicHandler, theConfig, cfgDefaults) {
      var defValue,
        isDefaultValid = cfgDefaults.dfVal || isDefined;
      if (theConfig && cfgDefaults.fb) {
        var fallbacks = cfgDefaults.fb;
        isArray(fallbacks) || (fallbacks = [fallbacks]);
        for (var lp = 0; lp < fallbacks[_DYN_LENGTH]; lp++) {
          var fallback = fallbacks[lp],
            fbValue = theConfig[fallback];
          if (isDefaultValid(fbValue) ? defValue = fbValue : dynamicHandler && (fbValue = dynamicHandler.cfg[fallback], isDefaultValid(fbValue) && (defValue = fbValue), dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue)), isDefaultValid(defValue)) break;
        }
      }
      return !isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v) && (defValue = cfgDefaults.v), defValue;
    }
    __name(_getDefault, "_getDefault");
    function _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {
      var theValue = cfgDefaults;
      if (cfgDefaults && _isConfigDefaults(cfgDefaults) && (theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)), theValue) {
        _isConfigDefaults(theValue) && (theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue));
        var newValue_1;
        isArray(theValue) ? (newValue_1 = [], newValue_1[_DYN_LENGTH] = theValue[_DYN_LENGTH]) : isPlainObject(theValue) && (newValue_1 = {}), newValue_1 && (objForEachKey(theValue, function (key, value) {
          value && _isConfigDefaults(value) && (value = _resolveDefaultValue(dynamicHandler, theConfig, value)), newValue_1[key] = value;
        }), theValue = newValue_1);
      }
      return theValue;
    }
    __name(_resolveDefaultValue, "_resolveDefaultValue");
    function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {
      var isValid,
        setFn,
        defValue,
        cfgDefaults = defaultValue,
        mergeDf,
        reference,
        readOnly,
        blkDynamicValue;
      _isConfigDefaults(cfgDefaults) ? (isValid = cfgDefaults.isVal, setFn = cfgDefaults.set, readOnly = cfgDefaults[_DYN_RD_ONLY], blkDynamicValue = cfgDefaults[_DYN_BLK_VAL], mergeDf = cfgDefaults.mrg, reference = cfgDefaults.ref, !reference && isUndefined(reference) && (reference = !!mergeDf), defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults)) : defValue = defaultValue, blkDynamicValue && dynamicHandler[_DYN_BLK_VAL](theConfig, name);
      var theValue,
        usingDefault = !0,
        cfgValue = theConfig[name];
      (cfgValue || !isNullOrUndefined(cfgValue)) && (theValue = cfgValue, usingDefault = !1, isValid && theValue !== defValue && !isValid(theValue) && (theValue = defValue, usingDefault = !0), setFn && (theValue = setFn(theValue, defValue, theConfig), usingDefault = theValue === defValue)), usingDefault ? defValue ? theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue) : theValue = defValue : (isPlainObject(theValue) || isArray(defValue)) && mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue)) && objForEachKey(defValue, function (dfName, dfValue) {
        _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);
      }), dynamicHandler.set(theConfig, name, theValue), reference && dynamicHandler.ref(theConfig, name), readOnly && dynamicHandler[_DYN_RD_ONLY](theConfig, name);
    }
    __name(_applyDefaultValue, "_applyDefaultValue");
    var CFG_HANDLER_LINK = symbolFor("[[ai_dynCfg_1]]"),
      BLOCK_DYNAMIC = symbolFor("[[ai_blkDynCfg_1]]"),
      FORCE_DYNAMIC = symbolFor("[[ai_frcDynCfg_1]]");
    function _cfgDeepCopy(source) {
      if (source) {
        var target_1;
        if (isArray(source) ? (target_1 = [], target_1[_DYN_LENGTH] = source[_DYN_LENGTH]) : isPlainObject(source) && (target_1 = {}), target_1) return objForEachKey(source, function (key, value) {
          target_1[key] = _cfgDeepCopy(value);
        }), target_1;
      }
      return source;
    }
    __name(_cfgDeepCopy, "_cfgDeepCopy");
    function getDynamicConfigHandler(value) {
      if (value) {
        var handler = value[CFG_HANDLER_LINK] || value;
        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) return handler;
      }
      return null;
    }
    __name(getDynamicConfigHandler, "getDynamicConfigHandler");
    function blockDynamicConversion(value) {
      if (value && (isPlainObject(value) || isArray(value))) try {
        value[BLOCK_DYNAMIC] = !0;
      } catch {}
      return value;
    }
    __name(blockDynamicConversion, "blockDynamicConversion");
    function _canMakeDynamic(getFunc, state, value) {
      var result = !1;
      return value && !getFunc[state.blkVal] && (result = value[FORCE_DYNAMIC], !result && !value[BLOCK_DYNAMIC] && (result = isPlainObject(value) || isArray(value))), result;
    }
    __name(_canMakeDynamic, "_canMakeDynamic");
    function throwInvalidAccess(message) {
      throwTypeError("InvalidAccess:" + message);
    }
    __name(throwInvalidAccess, "throwInvalidAccess");
    var arrayMethodsToPatch = ["push", "pop", "shift", "unshift", "splice"],
      _throwDynamicError = __name(function (logger, name, desc, e) {
        logger && logger[_DYN_THROW_INTERNAL](3, 108, "".concat(desc, " [").concat(name, "] failed - ") + dumpObj(e));
      }, "_throwDynamicError");
    function _patchArray(state, target, name) {
      isArray(target) && arrForEach(arrayMethodsToPatch, function (method) {
        var orgMethod = target[method];
        target[method] = function () {
          for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
          var result = orgMethod[_DYN_APPLY](this, args);
          return _makeDynamicObject(state, target, name, "Patching"), result;
        };
      });
    }
    __name(_patchArray, "_patchArray");
    function _getOwnPropGetter(target, name) {
      var propDesc = objGetOwnPropertyDescriptor(target, name);
      return propDesc && propDesc.get;
    }
    __name(_getOwnPropGetter, "_getOwnPropGetter");
    function _createDynamicProperty(state, theConfig, name, value) {
      var detail = {
          n: name,
          h: [],
          trk: function (handler) {
            handler && handler.fn && (arrIndexOf(detail.h, handler) === -1 && detail.h[_DYN_PUSH](handler), state.trk(handler, detail));
          },
          clr: function (handler) {
            var idx = arrIndexOf(detail.h, handler);
            idx !== -1 && detail.h[_DYN_SPLICE](idx, 1);
          }
        },
        checkDynamic = !0,
        isObjectOrArray = !1;
      function _getProperty() {
        checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), value && !value[CFG_HANDLER_LINK] && isObjectOrArray && (value = _makeDynamicObject(state, value, name, "Converting")), checkDynamic = !1);
        var activeHandler = state.act;
        return activeHandler && detail.trk(activeHandler), value;
      }
      __name(_getProperty, "_getProperty"), _getProperty[state.prop] = {
        chng: function () {
          state.add(detail);
        }
      };
      function _setProperty(newValue) {
        if (value !== newValue) {
          _getProperty[state.ro] && !state.upd && throwInvalidAccess("[" + name + "] is read-only:" + dumpObj(theConfig)), checkDynamic && (isObjectOrArray = isObjectOrArray || _canMakeDynamic(_getProperty, state, value), checkDynamic = !1);
          var isReferenced = isObjectOrArray && _getProperty[state.rf];
          if (isObjectOrArray) if (isReferenced) {
            objForEachKey(value, function (key) {
              value[key] = newValue ? newValue[key] : UNDEFINED_VALUE;
            });
            try {
              objForEachKey(newValue, function (key, theValue) {
                _setDynamicProperty(state, value, key, theValue);
              }), newValue = value;
            } catch (e) {
              _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Assigning", e), isObjectOrArray = !1;
            }
          } else value && value[CFG_HANDLER_LINK] && objForEachKey(value, function (key) {
            var getter = _getOwnPropGetter(value, key);
            if (getter) {
              var valueState = getter[state.prop];
              valueState && valueState.chng();
            }
          });
          if (newValue !== value) {
            var newIsObjectOrArray = newValue && _canMakeDynamic(_getProperty, state, newValue);
            !isReferenced && newIsObjectOrArray && (newValue = _makeDynamicObject(state, newValue, name, "Converting")), value = newValue, isObjectOrArray = newIsObjectOrArray;
          }
          state.add(detail);
        }
      }
      __name(_setProperty, "_setProperty"), objDefine(theConfig, detail.n, {
        g: _getProperty,
        s: _setProperty
      });
    }
    __name(_createDynamicProperty, "_createDynamicProperty");
    function _setDynamicProperty(state, target, name, value) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop];
        isDynamic ? target[name] = value : _createDynamicProperty(state, target, name, value);
      }
      return target;
    }
    __name(_setDynamicProperty, "_setDynamicProperty");
    function _setDynamicPropertyState(state, target, name, flags) {
      if (target) {
        var getter = _getOwnPropGetter(target, name),
          isDynamic = getter && !!getter[state.prop],
          inPlace = flags && flags[0],
          rdOnly = flags && flags[1],
          blkProp = flags && flags[2];
        if (!isDynamic) {
          if (blkProp) try {
            blockDynamicConversion(target);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "Blocking", e);
          }
          try {
            _setDynamicProperty(state, target, name, target[name]), getter = _getOwnPropGetter(target, name);
          } catch (e) {
            _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, "State", e);
          }
        }
        inPlace && (getter[state.rf] = inPlace), rdOnly && (getter[state.ro] = rdOnly), blkProp && (getter[state.blkVal] = !0);
      }
      return target;
    }
    __name(_setDynamicPropertyState, "_setDynamicPropertyState");
    function _makeDynamicObject(state, target, name, desc) {
      try {
        objForEachKey(target, function (key, value) {
          _setDynamicProperty(state, target, key, value);
        }), target[CFG_HANDLER_LINK] || (objDefineProp(target, CFG_HANDLER_LINK, {
          get: function () {
            return state[_DYN_HDLR];
          }
        }), _patchArray(state, target, name));
      } catch (e) {
        _throwDynamicError((state.hdlr || {})[_DYN_LOGGER], name, desc, e);
      }
      return target;
    }
    __name(_makeDynamicObject, "_makeDynamicObject");
    var symPrefix = "[[ai_",
      symPostfix = "]]";
    function _createState(cfgHandler) {
      var _a,
        dynamicPropertySymbol = newSymbol(symPrefix + "get" + cfgHandler.uid + symPostfix),
        dynamicPropertyReadOnly = newSymbol(symPrefix + "ro" + cfgHandler.uid + symPostfix),
        dynamicPropertyReferenced = newSymbol(symPrefix + "rf" + cfgHandler.uid + symPostfix),
        dynamicPropertyBlockValue = newSymbol(symPrefix + "blkVal" + cfgHandler.uid + symPostfix),
        dynamicPropertyDetail = newSymbol(symPrefix + "dtl" + cfgHandler.uid + symPostfix),
        _waitingHandlers = null,
        _watcherTimer = null,
        theState;
      function _useHandler(activeHandler, callback) {
        var prevWatcher = theState.act;
        try {
          theState.act = activeHandler, activeHandler && activeHandler[dynamicPropertyDetail] && (arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {
            detail.clr(activeHandler);
          }), activeHandler[dynamicPropertyDetail] = []), callback({
            cfg: cfgHandler.cfg,
            set: cfgHandler.set.bind(cfgHandler),
            setDf: cfgHandler[_DYN_SET_DF].bind(cfgHandler),
            ref: cfgHandler.ref.bind(cfgHandler),
            rdOnly: cfgHandler[_DYN_RD_ONLY].bind(cfgHandler)
          });
        } catch (e) {
          var logger = cfgHandler[_DYN_LOGGER];
          throw logger && logger[_DYN_THROW_INTERNAL](1, 107, dumpObj(e)), e;
        } finally {
          theState.act = prevWatcher || null;
        }
      }
      __name(_useHandler, "_useHandler");
      function _notifyWatchers() {
        if (_waitingHandlers) {
          var notifyHandlers = _waitingHandlers;
          _waitingHandlers = null, _watcherTimer && _watcherTimer[_DYN_CANCEL](), _watcherTimer = null;
          var watcherFailures_1 = [];
          if (arrForEach(notifyHandlers, function (handler) {
            if (handler && (handler[dynamicPropertyDetail] && (arrForEach(handler[dynamicPropertyDetail], function (detail) {
              detail.clr(handler);
            }), handler[dynamicPropertyDetail] = null), handler.fn)) try {
              _useHandler(handler, handler.fn);
            } catch (e) {
              watcherFailures_1[_DYN_PUSH](e);
            }
          }), _waitingHandlers) try {
            _notifyWatchers();
          } catch (e) {
            watcherFailures_1[_DYN_PUSH](e);
          }
          watcherFailures_1[_DYN_LENGTH] > 0 && throwAggregationError("Watcher error(s): ", watcherFailures_1);
        }
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _addWatcher(detail) {
        if (detail && detail.h[_DYN_LENGTH] > 0) {
          _waitingHandlers || (_waitingHandlers = []), _watcherTimer || (_watcherTimer = scheduleTimeout(function () {
            _watcherTimer = null, _notifyWatchers();
          }, 0));
          for (var idx = 0; idx < detail.h[_DYN_LENGTH]; idx++) {
            var handler = detail.h[idx];
            handler && arrIndexOf(_waitingHandlers, handler) === -1 && _waitingHandlers[_DYN_PUSH](handler);
          }
        }
      }
      __name(_addWatcher, "_addWatcher");
      function _trackHandler(handler, detail) {
        if (handler) {
          var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];
          arrIndexOf(details, detail) === -1 && details[_DYN_PUSH](detail);
        }
      }
      return __name(_trackHandler, "_trackHandler"), theState = (_a = {
        prop: dynamicPropertySymbol,
        ro: dynamicPropertyReadOnly,
        rf: dynamicPropertyReferenced
      }, _a[_DYN_BLK_VAL] = dynamicPropertyBlockValue, _a[_DYN_HDLR] = cfgHandler, _a.add = _addWatcher, _a[_DYN_NOTIFY] = _notifyWatchers, _a.use = _useHandler, _a.trk = _trackHandler, _a), theState;
    }
    __name(_createState, "_createState");
    function _createAndUseHandler(state, configHandler) {
      var handler = {
        fn: configHandler,
        rm: function () {
          handler.fn = null, state = null, configHandler = null;
        }
      };
      return state.use(handler, configHandler), handler;
    }
    __name(_createAndUseHandler, "_createAndUseHandler");
    function _createDynamicHandler(logger, target, inPlace) {
      var _a,
        dynamicHandler = getDynamicConfigHandler(target);
      if (dynamicHandler) return dynamicHandler;
      var uid = createUniqueNamespace("dyncfg", !0),
        newTarget = target && inPlace !== !1 ? target : _cfgDeepCopy(target),
        theState;
      function _notifyWatchers() {
        theState[_DYN_NOTIFY]();
      }
      __name(_notifyWatchers, "_notifyWatchers");
      function _setValue(target, name, value) {
        try {
          target = _setDynamicProperty(theState, target, name, value);
        } catch (e) {
          _throwDynamicError(logger, name, "Setting value", e);
        }
        return target[name];
      }
      __name(_setValue, "_setValue");
      function _watch(configHandler) {
        return _createAndUseHandler(theState, configHandler);
      }
      __name(_watch, "_watch");
      function _block(configHandler, allowUpdate) {
        theState.use(null, function (details) {
          var prevUpd = theState.upd;
          try {
            isUndefined(allowUpdate) || (theState.upd = allowUpdate), configHandler(details);
          } finally {
            theState.upd = prevUpd;
          }
        });
      }
      __name(_block, "_block");
      function _ref(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0] = !0, _a))[name];
      }
      __name(_ref, "_ref");
      function _rdOnly(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1] = !0, _a))[name];
      }
      __name(_rdOnly, "_rdOnly");
      function _blkPropValue(target, name) {
        var _a;
        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2] = !0, _a))[name];
      }
      __name(_blkPropValue, "_blkPropValue");
      function _applyDefaults(theConfig, defaultValues) {
        return defaultValues && objForEachKey(defaultValues, function (name, value) {
          _applyDefaultValue(cfgHandler, theConfig, name, value);
        }), theConfig;
      }
      __name(_applyDefaults, "_applyDefaults");
      var cfgHandler = (_a = {
        uid: null,
        cfg: newTarget
      }, _a[_DYN_LOGGER] = logger, _a[_DYN_NOTIFY] = _notifyWatchers, _a.set = _setValue, _a[_DYN_SET_DF] = _applyDefaults, _a[_DYN_WATCH] = _watch, _a.ref = _ref, _a[_DYN_RD_ONLY] = _rdOnly, _a[_DYN_BLK_VAL] = _blkPropValue, _a._block = _block, _a);
      return objDefine(cfgHandler, "uid", {
        c: !1,
        e: !1,
        w: !1,
        v: uid
      }), theState = _createState(cfgHandler), _makeDynamicObject(theState, newTarget, "config", "Creating"), cfgHandler;
    }
    __name(_createDynamicHandler, "_createDynamicHandler");
    function _logInvalidAccess(logger, message) {
      logger ? (logger[_DYN_WARN_TO_CONSOLE](message), logger[_DYN_THROW_INTERNAL](2, 108, message)) : throwInvalidAccess(message);
    }
    __name(_logInvalidAccess, "_logInvalidAccess");
    function createDynamicConfig(config, defaultConfig, logger, inPlace) {
      var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);
      return defaultConfig && dynamicHandler[_DYN_SET_DF](dynamicHandler.cfg, defaultConfig), dynamicHandler;
    }
    __name(createDynamicConfig, "createDynamicConfig");
    function onConfigChange(config, configHandler, logger) {
      var handler = config[CFG_HANDLER_LINK] || config;
      return handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler) ? handler[_DYN_WATCH](configHandler) : (_logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config)), createDynamicConfig(config, null, logger)[_DYN_WATCH](configHandler));
    }
    __name(onConfigChange, "onConfigChange");
    function runTargetUnload(target, isAsync) {
      if (target && target[_DYN_UNLOAD]) return target[_DYN_UNLOAD](isAsync);
    }
    __name(runTargetUnload, "runTargetUnload");
    function doUnloadAll(targets, isAsync, done) {
      var result;
      return done || (result = createPromise(function (resolved) {
        done = resolved;
      })), targets && getLength(targets) > 0 ? doAwaitResponse(runTargetUnload(targets[0], isAsync), function () {
        doUnloadAll(arrSlice(targets, 1), isAsync, done);
      }) : done(), result;
    }
    __name(doUnloadAll, "doUnloadAll");
    var ChannelControllerPriority = 500;
    function _stringToBoolOrDefault(theValue, defaultValue, theConfig) {
      return !theValue && isNullOrUndefined(theValue) ? defaultValue : isBoolean(theValue) ? theValue : asString(theValue)[_DYN_TO_LOWER_CASE]() === "true";
    }
    __name(_stringToBoolOrDefault, "_stringToBoolOrDefault");
    function cfgDfMerge(defaultValue) {
      return {
        mrg: !0,
        v: defaultValue
      };
    }
    __name(cfgDfMerge, "cfgDfMerge");
    function cfgDfValidate(validator, defaultValue, fallBackName) {
      return {
        fb: fallBackName,
        isVal: validator,
        v: defaultValue
      };
    }
    __name(cfgDfValidate, "cfgDfValidate");
    function cfgDfBoolean(defaultValue, fallBackName) {
      return {
        fb: fallBackName,
        set: _stringToBoolOrDefault,
        v: !!defaultValue
      };
    }
    __name(cfgDfBoolean, "cfgDfBoolean");
    var listenerFuncs = [STR_EVENTS_SENT, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_PERF_EVENT],
      _aiNamespace = null,
      _debugListener;
    function _listenerProxyFunc(name, config) {
      return function () {
        var args = arguments,
          dbgExt = getDebugExt(config);
        if (dbgExt) {
          var listener = dbgExt.listener;
          listener && listener[name] && listener[name][_DYN_APPLY](listener, args);
        }
      };
    }
    __name(_listenerProxyFunc, "_listenerProxyFunc");
    function _getExtensionNamespace() {
      var target = getInst("Microsoft");
      return target && (_aiNamespace = target.ApplicationInsights), _aiNamespace;
    }
    __name(_getExtensionNamespace, "_getExtensionNamespace");
    function getDebugExt(config) {
      var ns = _aiNamespace;
      return !ns && config.disableDbgExt !== !0 && (ns = _aiNamespace || _getExtensionNamespace()), ns ? ns.ChromeDbgExt : null;
    }
    __name(getDebugExt, "getDebugExt");
    function getDebugListener(config) {
      if (!_debugListener) {
        _debugListener = {};
        for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH]; lp++) _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
      }
      return _debugListener;
    }
    __name(getDebugListener, "getDebugListener");
    var _a,
      STR_WARN_TO_CONSOLE = "warnToConsole",
      AiNonUserActionablePrefix = "AI (Internal): ",
      AiUserActionablePrefix = "AI: ",
      AIInternalMessagePrefix = "AITR_",
      defaultValues = {
        loggingLevelConsole: 0,
        loggingLevelTelemetry: 1,
        maxMessageLimit: 25,
        enableDebug: !1
      },
      _logFuncs = (_a = {}, _a[0] = null, _a[1] = "errorToConsole", _a[2] = STR_WARN_TO_CONSOLE, _a[3] = "debugToConsole", _a);
    function _sanitizeDiagnosticText(text) {
      return text ? '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"' : STR_EMPTY;
    }
    __name(_sanitizeDiagnosticText, "_sanitizeDiagnosticText");
    function _logToConsole(func, message) {
      var theConsole = getConsole();
      if (theConsole) {
        var logFunc = "log";
        theConsole[func] && (logFunc = func), isFunction(theConsole[logFunc]) && theConsole[logFunc](message);
      }
    }
    __name(_logToConsole, "_logToConsole");
    var _InternalLogMessage = function () {
      function _InternalLogMessage(msgId, msg, isUserAct, properties) {
        isUserAct === void 0 && (isUserAct = !1);
        var _self = this;
        _self[_DYN_MESSAGE_ID] = msgId, _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
        var strProps = STR_EMPTY;
        hasJSON() && (strProps = getJSON().stringify(properties));
        var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
        _self[_DYN_MESSAGE] += diagnosticText;
      }
      return __name(_InternalLogMessage, "_InternalLogMessage"), _InternalLogMessage.dataType = "MessageData", _InternalLogMessage;
    }();
    function safeGetLogger(core, config) {
      return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
    }
    __name(safeGetLogger, "safeGetLogger");
    var DiagnosticLogger = function () {
      function DiagnosticLogger(config) {
        this.identifier = "DiagnosticLogger", this.queue = [];
        var _messageCount = 0,
          _messageLogged = {},
          _loggingLevelConsole,
          _loggingLevelTelemetry,
          _maxInternalMessageLimit,
          _enableDebug,
          _unloadHandler;
        dynamicProto(DiagnosticLogger, this, function (_self) {
          _unloadHandler = _setDefaultsFromConfig(config || {}), _self.consoleLoggingLevel = function () {
            return _loggingLevelConsole;
          }, _self[_DYN_THROW_INTERNAL] = function (severity, msgId, msg, properties, isUserAct) {
            isUserAct === void 0 && (isUserAct = !1);
            var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
            if (_enableDebug) throw dumpObj(message);
            var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;
            if (isUndefined(message[_DYN_MESSAGE])) _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);else {
              if (isUserAct) {
                var messageKey = +message[_DYN_MESSAGE_ID];
                !_messageLogged[messageKey] && _loggingLevelConsole >= severity && (_self[logFunc](message[_DYN_MESSAGE]), _messageLogged[messageKey] = !0);
              } else _loggingLevelConsole >= severity && _self[logFunc](message[_DYN_MESSAGE]);
              _logInternalMessage(severity, message);
            }
          }, _self.debugToConsole = function (message) {
            _logToConsole("debug", message), _debugExtMsg("warning", message);
          }, _self[_DYN_WARN_TO_CONSOLE] = function (message) {
            _logToConsole("warn", message), _debugExtMsg("warning", message);
          }, _self.errorToConsole = function (message) {
            _logToConsole("error", message), _debugExtMsg("error", message);
          }, _self.resetInternalMessageCount = function () {
            _messageCount = 0, _messageLogged = {};
          }, _self[_DYN_LOG_INTERNAL_MESSAGE] = _logInternalMessage, _self[_DYN_UNLOAD] = function (isAsync) {
            _unloadHandler && _unloadHandler.rm(), _unloadHandler = null;
          };
          function _logInternalMessage(severity, message) {
            if (!_areInternalMessagesThrottled()) {
              var logMessage = !0,
                messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
              if (_messageLogged[messageKey] ? logMessage = !1 : _messageLogged[messageKey] = !0, logMessage && (severity <= _loggingLevelTelemetry && (_self.queue[_DYN_PUSH](message), _messageCount++, _debugExtMsg(severity === 1 ? "error" : "warn", message)), _messageCount === _maxInternalMessageLimit)) {
                var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.",
                  throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, !1);
                _self.queue[_DYN_PUSH](throttleMessage), severity === 1 ? _self.errorToConsole(throttleLimitMessage) : _self[_DYN_WARN_TO_CONSOLE](throttleLimitMessage);
              }
            }
          }
          __name(_logInternalMessage, "_logInternalMessage");
          function _setDefaultsFromConfig(config) {
            return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {
              var config = details.cfg;
              _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4], _loggingLevelTelemetry = config.loggingLevelTelemetry, _maxInternalMessageLimit = config.maxMessageLimit, _enableDebug = config.enableDebug;
            });
          }
          __name(_setDefaultsFromConfig, "_setDefaultsFromConfig");
          function _areInternalMessagesThrottled() {
            return _messageCount >= _maxInternalMessageLimit;
          }
          __name(_areInternalMessagesThrottled, "_areInternalMessagesThrottled");
          function _debugExtMsg(name, data) {
            var dbgExt = getDebugExt(config || {});
            dbgExt && dbgExt[_DYN_DIAG_LOG] && dbgExt[_DYN_DIAG_LOG](name, data);
          }
          __name(_debugExtMsg, "_debugExtMsg");
        });
      }
      return __name(DiagnosticLogger, "DiagnosticLogger"), DiagnosticLogger.__ieDyn = 1, DiagnosticLogger;
    }();
    function _getLogger(logger) {
      return logger || new DiagnosticLogger();
    }
    __name(_getLogger, "_getLogger");
    function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
      isUserAct === void 0 && (isUserAct = !1), _getLogger(logger)[_DYN_THROW_INTERNAL](severity, msgId, msg, properties, isUserAct);
    }
    __name(_throwInternal, "_throwInternal");
    function _warnToConsole(logger, message) {
      _getLogger(logger)[_DYN_WARN_TO_CONSOLE](message);
    }
    __name(_warnToConsole, "_warnToConsole");
    var _a,
      _b,
      strToGMTString = "toGMTString",
      strToUTCString = "toUTCString",
      strCookie = "cookie",
      strExpires = "expires",
      strIsCookieUseDisabled = "isCookieUseDisabled",
      strDisableCookiesUsage = "disableCookiesUsage",
      strConfigCookieMgr = "_ckMgr",
      _supportsCookies = null,
      _allowUaSameSite = null,
      _parsedCookieValue = null,
      _doc,
      _cookieCache = {},
      _globalCookieConfig = {},
      rootDefaultConfig = (_a = {
        cookieCfg: cfgDfMerge((_b = {}, _b[STR_DOMAIN] = {
          fb: "cookieDomain",
          dfVal: isNotNullOrUndefined
        }, _b.path = {
          fb: "cookiePath",
          dfVal: isNotNullOrUndefined
        }, _b.enabled = UNDEFINED_VALUE, _b.ignoreCookies = UNDEFINED_VALUE, _b.blockedCookies = UNDEFINED_VALUE, _b)),
        cookieDomain: UNDEFINED_VALUE,
        cookiePath: UNDEFINED_VALUE
      }, _a[strDisableCookiesUsage] = UNDEFINED_VALUE, _a);
    function _getDoc() {
      !_doc && (_doc = getLazy(function () {
        return getDocument();
      }));
    }
    __name(_getDoc, "_getDoc");
    function _isMgrEnabled(cookieMgr) {
      return cookieMgr ? cookieMgr.isEnabled() : !0;
    }
    __name(_isMgrEnabled, "_isMgrEnabled");
    function _isIgnoredCookie(cookieMgrCfg, name) {
      return name && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies) ? arrIndexOf(cookieMgrCfg.ignoreCookies, name) !== -1 : !1;
    }
    __name(_isIgnoredCookie, "_isIgnoredCookie");
    function _isBlockedCookie(cookieMgrCfg, name) {
      return name && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies) && arrIndexOf(cookieMgrCfg.blockedCookies, name) !== -1 ? !0 : _isIgnoredCookie(cookieMgrCfg, name);
    }
    __name(_isBlockedCookie, "_isBlockedCookie");
    function _isCfgEnabled(rootConfig, cookieMgrConfig) {
      var isCfgEnabled = cookieMgrConfig[_DYN_ENABLED];
      if (isNullOrUndefined(isCfgEnabled)) {
        var cookieEnabled = void 0;
        isUndefined(rootConfig[strIsCookieUseDisabled]) || (cookieEnabled = !rootConfig[strIsCookieUseDisabled]), isUndefined(rootConfig[strDisableCookiesUsage]) || (cookieEnabled = !rootConfig[strDisableCookiesUsage]), isCfgEnabled = cookieEnabled;
      }
      return isCfgEnabled;
    }
    __name(_isCfgEnabled, "_isCfgEnabled");
    function createCookieMgr(rootConfig, logger) {
      var _a, cookieMgrConfig, _path, _domain, unloadHandler, _enabled, _getCookieFn, _setCookieFn, _delCookieFn;
      rootConfig = createDynamicConfig(rootConfig || _globalCookieConfig, null, logger).cfg, unloadHandler = onConfigChange(rootConfig, function (details) {
        details[_DYN_SET_DF](details.cfg, rootDefaultConfig), cookieMgrConfig = details.ref(details.cfg, "cookieCfg"), _path = cookieMgrConfig[STR_PATH] || "/", _domain = cookieMgrConfig[STR_DOMAIN], _enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== !1, _getCookieFn = cookieMgrConfig.getCookie || _getCookieValue, _setCookieFn = cookieMgrConfig.setCookie || _setCookieValue, _delCookieFn = cookieMgrConfig.delCookie || _setCookieValue;
      }, logger);
      var cookieMgr = (_a = {
        isEnabled: function () {
          var enabled = _isCfgEnabled(rootConfig, cookieMgrConfig) !== !1 && _enabled && areCookiesSupported(logger),
            gblManager = _globalCookieConfig[strConfigCookieMgr];
          return enabled && gblManager && cookieMgr !== gblManager && (enabled = _isMgrEnabled(gblManager)), enabled;
        },
        setEnabled: function (value) {
          _enabled = value !== !1, cookieMgrConfig[_DYN_ENABLED] = value;
        },
        set: function (name, value, maxAgeSec, domain, path) {
          var result = !1;
          if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name)) {
            var values = {},
              theValue = strTrim(value || STR_EMPTY),
              idx = strIndexOf(theValue, ";");
            if (idx !== -1 && (theValue = strTrim(strLeft(value, idx)), values = _extractParts(strSubstring(value, idx + 1))), setValue(values, STR_DOMAIN, domain || _domain, isTruthy, isUndefined), !isNullOrUndefined(maxAgeSec)) {
              var _isIE = isIE();
              if (isUndefined(values[strExpires])) {
                var nowMs = utcNow(),
                  expireMs = nowMs + maxAgeSec * 1e3;
                if (expireMs > 0) {
                  var expiry = new Date();
                  expiry.setTime(expireMs), setValue(values, strExpires, _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY, isTruthy);
                }
              }
              _isIE || setValue(values, "max-age", STR_EMPTY + maxAgeSec, null, isUndefined);
            }
            var location_1 = getLocation();
            location_1 && location_1.protocol === "https:" && (setValue(values, "secure", null, null, isUndefined), _allowUaSameSite === null && (_allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT])), _allowUaSameSite && setValue(values, "SameSite", "None", null, isUndefined)), setValue(values, STR_PATH, path || _path, null, isUndefined), _setCookieFn(name, _formatCookieValue(theValue, values)), result = !0;
          }
          return result;
        },
        get: function (name) {
          var value = STR_EMPTY;
          return _isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name) && (value = _getCookieFn(name)), value;
        },
        del: function (name, path) {
          var result = !1;
          return _isMgrEnabled(cookieMgr) && (result = cookieMgr.purge(name, path)), result;
        },
        purge: function (name, path) {
          var _a,
            result = !1;
          if (areCookiesSupported(logger)) {
            var values = (_a = {}, _a[STR_PATH] = path || "/", _a[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a);
            isIE() || (values["max-age"] = "0"), _delCookieFn(name, _formatCookieValue(STR_EMPTY, values)), result = !0;
          }
          return result;
        }
      }, _a[_DYN_UNLOAD] = function (isAsync) {
        unloadHandler && unloadHandler.rm(), unloadHandler = null;
      }, _a);
      return cookieMgr[strConfigCookieMgr] = cookieMgr, cookieMgr;
    }
    __name(createCookieMgr, "createCookieMgr");
    function areCookiesSupported(logger) {
      if (_supportsCookies === null) {
        _supportsCookies = !1, !_doc && _getDoc();
        try {
          var doc = _doc.v || {};
          _supportsCookies = doc[strCookie] !== void 0;
        } catch (e) {
          _throwInternal(logger, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), {
            exception: dumpObj(e)
          });
        }
      }
      return _supportsCookies;
    }
    __name(areCookiesSupported, "areCookiesSupported");
    function _extractParts(theValue) {
      var values = {};
      if (theValue && theValue[_DYN_LENGTH]) {
        var parts = strTrim(theValue)[_DYN_SPLIT](";");
        arrForEach(parts, function (thePart) {
          if (thePart = strTrim(thePart || STR_EMPTY), thePart) {
            var idx = strIndexOf(thePart, "=");
            idx === -1 ? values[thePart] = null : values[strTrim(strLeft(thePart, idx))] = strTrim(strSubstring(thePart, idx + 1));
          }
        });
      }
      return values;
    }
    __name(_extractParts, "_extractParts");
    function _formatDate(theDate, func) {
      return isFunction(theDate[func]) ? theDate[func]() : null;
    }
    __name(_formatDate, "_formatDate");
    function _formatCookieValue(value, values) {
      var cookieValue = value || STR_EMPTY;
      return objForEachKey(values, function (name, theValue) {
        cookieValue += "; " + name + (isNullOrUndefined(theValue) ? STR_EMPTY : "=" + theValue);
      }), cookieValue;
    }
    __name(_formatCookieValue, "_formatCookieValue");
    function _getCookieValue(name) {
      var cookieValue = STR_EMPTY;
      if (!_doc && _getDoc(), _doc.v) {
        var theCookie = _doc.v[strCookie] || STR_EMPTY;
        _parsedCookieValue !== theCookie && (_cookieCache = _extractParts(theCookie), _parsedCookieValue = theCookie), cookieValue = strTrim(_cookieCache[name] || STR_EMPTY);
      }
      return cookieValue;
    }
    __name(_getCookieValue, "_getCookieValue");
    function _setCookieValue(name, cookieValue) {
      !_doc && _getDoc(), _doc.v && (_doc.v[strCookie] = name + "=" + cookieValue);
    }
    __name(_setCookieValue, "_setCookieValue");
    function uaDisallowsSameSiteNone(userAgent) {
      return isString(userAgent) ? !!(strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12") || strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari") || strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)") || strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6") || strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome") || strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) : !1;
    }
    __name(uaDisallowsSameSiteNone, "uaDisallowsSameSiteNone");
    var defaultValues = {
      perfEvtsSendAll: !1
    };
    function _runListeners(listeners, name, isAsync, callback) {
      arrForEach(listeners, function (listener) {
        if (listener && listener[name]) if (isAsync) scheduleTimeout(function () {
          return callback(listener);
        }, 0);else try {
          callback(listener);
        } catch {}
      });
    }
    __name(_runListeners, "_runListeners");
    var NotificationManager = function () {
        function NotificationManager(config) {
          this.listeners = [];
          var perfEvtsSendAll,
            unloadHandler,
            _listeners = [],
            cfgHandler = createDynamicConfig(config, defaultValues);
          unloadHandler = cfgHandler[_DYN_WATCH](function (details) {
            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;
          }), dynamicProto(NotificationManager, this, function (_self) {
            objDefine(_self, "listeners", {
              g: function () {
                return _listeners;
              }
            }), _self[_DYN_ADD_NOTIFICATION_LIS1] = function (listener) {
              _listeners[_DYN_PUSH](listener);
            }, _self[_DYN_REMOVE_NOTIFICATION_2] = function (listener) {
              for (var index = arrIndexOf(_listeners, listener); index > -1;) _listeners[_DYN_SPLICE](index, 1), index = arrIndexOf(_listeners, listener);
            }, _self[STR_EVENTS_SENT] = function (events) {
              _runListeners(_listeners, STR_EVENTS_SENT, !0, function (listener) {
                listener[STR_EVENTS_SENT](events);
              });
            }, _self[STR_EVENTS_DISCARDED] = function (events, reason) {
              _runListeners(_listeners, STR_EVENTS_DISCARDED, !0, function (listener) {
                listener[STR_EVENTS_DISCARDED](events, reason);
              });
            }, _self[STR_EVENTS_SEND_REQUEST] = function (sendReason, isAsync) {
              _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync, function (listener) {
                listener[STR_EVENTS_SEND_REQUEST](sendReason, isAsync);
              });
            }, _self[STR_PERF_EVENT] = function (perfEvent) {
              perfEvent && (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT]()) && _runListeners(_listeners, STR_PERF_EVENT, !1, function (listener) {
                perfEvent[_DYN_IS_ASYNC] ? scheduleTimeout(function () {
                  return listener[STR_PERF_EVENT](perfEvent);
                }, 0) : listener[STR_PERF_EVENT](perfEvent);
              });
            }, _self[_DYN_UNLOAD] = function (isAsync) {
              var _finishUnload = __name(function () {
                  unloadHandler && unloadHandler.rm(), unloadHandler = null, _listeners = [];
                }, "_finishUnload"),
                waiting;
              if (_runListeners(_listeners, "unload", !1, function (listener) {
                var asyncUnload = listener[_DYN_UNLOAD](isAsync);
                asyncUnload && (waiting || (waiting = []), waiting[_DYN_PUSH](asyncUnload));
              }), waiting) return createPromise(function (resolve) {
                return doAwaitResponse(createAllPromise(waiting), function () {
                  _finishUnload(), resolve();
                });
              });
              _finishUnload();
            };
          });
        }
        return __name(NotificationManager, "NotificationManager"), NotificationManager.__ieDyn = 1, NotificationManager;
      }(),
      strExecutionContextKey = "ctx",
      strParentContextKey = "ParentContextKey",
      strChildrenContextKey = "ChildrenContextKey",
      _defaultPerfManager = null,
      PerfEvent = function () {
        function PerfEvent(name, payloadDetails, isAsync) {
          var _self = this;
          if (_self.start = utcNow(), _self[_DYN_NAME] = name, _self[_DYN_IS_ASYNC] = isAsync, _self[_DYN_IS_CHILD_EVT] = function () {
            return !1;
          }, isFunction(payloadDetails)) {
            var theDetails_1;
            objDefine(_self, "payload", {
              g: function () {
                return !theDetails_1 && isFunction(payloadDetails) && (theDetails_1 = payloadDetails(), payloadDetails = null), theDetails_1;
              }
            });
          }
          _self[_DYN_GET_CTX] = function (key) {
            return key ? key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey] ? _self[key] : (_self[strExecutionContextKey] || {})[key] : null;
          }, _self[_DYN_SET_CTX] = function (key, value) {
            if (key) if (key === PerfEvent[strParentContextKey]) _self[key] || (_self[_DYN_IS_CHILD_EVT] = function () {
              return !0;
            }), _self[key] = value;else if (key === PerfEvent[strChildrenContextKey]) _self[key] = value;else {
              var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
              ctx[key] = value;
            }
          }, _self[_DYN_COMPLETE] = function () {
            var childTime = 0,
              childEvts = _self[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
            if (isArray(childEvts)) for (var lp = 0; lp < childEvts[_DYN_LENGTH]; lp++) {
              var childEvt = childEvts[lp];
              childEvt && (childTime += childEvt[_DYN_TIME]);
            }
            _self[_DYN_TIME] = utcNow() - _self.start, _self.exTime = _self[_DYN_TIME] - childTime, _self[_DYN_COMPLETE] = function () {};
          };
        }
        return __name(PerfEvent, "PerfEvent"), PerfEvent.ParentContextKey = "parent", PerfEvent.ChildrenContextKey = "childEvts", PerfEvent;
      }(),
      PerfManager = function () {
        function PerfManager(manager) {
          this.ctx = {}, dynamicProto(PerfManager, this, function (_self) {
            _self.create = function (src, payloadDetails, isAsync) {
              return new PerfEvent(src, payloadDetails, isAsync);
            }, _self.fire = function (perfEvent) {
              perfEvent && (perfEvent[_DYN_COMPLETE](), manager && isFunction(manager[STR_PERF_EVENT]) && manager[STR_PERF_EVENT](perfEvent));
            }, _self[_DYN_SET_CTX] = function (key, value) {
              if (key) {
                var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                ctx[key] = value;
              }
            }, _self[_DYN_GET_CTX] = function (key) {
              return (_self[strExecutionContextKey] || {})[key];
            };
          });
        }
        return __name(PerfManager, "PerfManager"), PerfManager.__ieDyn = 1, PerfManager;
      }(),
      doPerfActiveKey = "CoreUtils.doPerf";
    function doPerf(mgrSource, getSource, func, details, isAsync) {
      if (mgrSource) {
        var perfMgr = mgrSource;
        if (perfMgr[STR_GET_PERF_MGR] && (perfMgr = perfMgr[STR_GET_PERF_MGR]()), perfMgr) {
          var perfEvt = void 0,
            currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
          try {
            if (perfEvt = perfMgr.create(getSource(), details, isAsync), perfEvt) {
              if (currentActive && perfEvt[_DYN_SET_CTX] && (perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive), currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX])) {
                var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                children || (children = [], currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children)), children[_DYN_PUSH](perfEvt);
              }
              return perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt), func(perfEvt);
            }
          } catch (ex) {
            perfEvt && perfEvt[_DYN_SET_CTX] && perfEvt[_DYN_SET_CTX]("exception", ex);
          } finally {
            perfEvt && perfMgr.fire(perfEvt), perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
          }
        }
      }
      return func();
    }
    __name(doPerf, "doPerf");
    function getGblPerfMgr() {
      return _defaultPerfManager;
    }
    __name(getGblPerfMgr, "getGblPerfMgr");
    var INVALID_TRACE_ID = "00000000000000000000000000000000",
      INVALID_SPAN_ID = "0000000000000000";
    function _isValid(value, len, invalidValue) {
      return value && value[_DYN_LENGTH] === len && value !== invalidValue ? !!value.match(/^[\da-f]*$/i) : !1;
    }
    __name(_isValid, "_isValid");
    function isValidTraceId(value) {
      return _isValid(value, 32, INVALID_TRACE_ID);
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(value) {
      return _isValid(value, 16, INVALID_SPAN_ID);
    }
    __name(isValidSpanId, "isValidSpanId");
    var pluginStateData = createElmNodeData("plugin");
    function _getPluginState(plugin) {
      return pluginStateData.get(plugin, "state", {}, !0);
    }
    __name(_getPluginState, "_getPluginState");
    function initializePlugins(processContext, extensions) {
      for (var initPlugins = [], lastPlugin = null, proxy = processContext[_DYN_GET_NEXT](), pluginState; proxy;) {
        var thePlugin = proxy[_DYN_GET_PLUGIN]();
        if (thePlugin) {
          lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN] && thePlugin[STR_PROCESS_TELEMETRY] && lastPlugin[_DYN_SET_NEXT_PLUGIN](thePlugin), pluginState = _getPluginState(thePlugin);
          var isInitialized = !!pluginState[_DYN_IS_INITIALIZED];
          thePlugin[_DYN_IS_INITIALIZED] && (isInitialized = thePlugin[_DYN_IS_INITIALIZED]()), isInitialized || initPlugins[_DYN_PUSH](thePlugin), lastPlugin = thePlugin, proxy = proxy[_DYN_GET_NEXT]();
        }
      }
      arrForEach(initPlugins, function (thePlugin) {
        var core = processContext[STR_CORE]();
        thePlugin[_DYN_INITIALIZE](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT]()), pluginState = _getPluginState(thePlugin), !thePlugin[STR_CORE] && !pluginState[STR_CORE] && (pluginState[STR_CORE] = core), pluginState[_DYN_IS_INITIALIZED] = !0, delete pluginState[_DYN_TEARDOWN];
      });
    }
    __name(initializePlugins, "initializePlugins");
    function sortPlugins(plugins) {
      return plugins.sort(function (extA, extB) {
        var result = 0;
        if (extB) {
          var bHasProcess = extB[STR_PROCESS_TELEMETRY];
          extA[STR_PROCESS_TELEMETRY] ? result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1 : bHasProcess && (result = -1);
        } else result = extA ? 1 : -1;
        return result;
      });
    }
    __name(sortPlugins, "sortPlugins");
    function createDistributedTraceContext(parentCtx) {
      var trace = {};
      return {
        getName: function () {
          return trace[_DYN_NAME];
        },
        setName: function (newValue) {
          parentCtx && parentCtx.setName(newValue), trace[_DYN_NAME] = newValue;
        },
        getTraceId: function () {
          return trace[_DYN_TRACE_ID];
        },
        setTraceId: function (newValue) {
          parentCtx && parentCtx.setTraceId(newValue), isValidTraceId(newValue) && (trace[_DYN_TRACE_ID] = newValue);
        },
        getSpanId: function () {
          return trace[_DYN_SPAN_ID];
        },
        setSpanId: function (newValue) {
          parentCtx && parentCtx.setSpanId(newValue), isValidSpanId(newValue) && (trace[_DYN_SPAN_ID] = newValue);
        },
        getTraceFlags: function () {
          return trace[_DYN_TRACE_FLAGS];
        },
        setTraceFlags: function (newTraceFlags) {
          parentCtx && parentCtx.setTraceFlags(newTraceFlags), trace[_DYN_TRACE_FLAGS] = newTraceFlags;
        }
      };
    }
    __name(createDistributedTraceContext, "createDistributedTraceContext");
    var strTelemetryPluginChain = "TelemetryPluginChain",
      strHasRunFlags = "_hasRun",
      strGetTelCtx = "_getTelCtx",
      _chainId = 0;
    function _getNextProxyStart(proxy, core, startAt) {
      for (; proxy;) {
        if (proxy[_DYN_GET_PLUGIN]() === startAt) return proxy;
        proxy = proxy[_DYN_GET_NEXT]();
      }
      return createTelemetryProxyChain([startAt], core.config || {}, core);
    }
    __name(_getNextProxyStart, "_getNextProxyStart");
    function _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {
      var _nextProxy = null,
        _onComplete = [];
      dynamicHandler || (dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER])), startAt !== null && (_nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain);
      var context = {
        _next: _moveNext,
        ctx: {
          core: function () {
            return core;
          },
          diagLog: function () {
            return safeGetLogger(core, dynamicHandler.cfg);
          },
          getCfg: function () {
            return dynamicHandler.cfg;
          },
          getExtCfg: _resolveExtCfg,
          getConfig: _getConfig,
          hasNext: function () {
            return !!_nextProxy;
          },
          getNext: function () {
            return _nextProxy;
          },
          setNext: function (nextPlugin) {
            _nextProxy = nextPlugin;
          },
          iterate: _iterateChain,
          onComplete: _addOnComplete
        }
      };
      function _addOnComplete(onComplete, that) {
        for (var args = [], _i = 2; _i < arguments.length; _i++) args[_i - 2] = arguments[_i];
        onComplete && _onComplete[_DYN_PUSH]({
          func: onComplete,
          self: isUndefined(that) ? context.ctx : that,
          args: args
        });
      }
      __name(_addOnComplete, "_addOnComplete");
      function _moveNext() {
        var nextProxy = _nextProxy;
        if (_nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null, !nextProxy) {
          var onComplete = _onComplete;
          onComplete && onComplete[_DYN_LENGTH] > 0 && (arrForEach(onComplete, function (completeDetails) {
            try {
              completeDetails.func.call(completeDetails.self, completeDetails.args);
            } catch (e) {
              _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + dumpObj(e));
            }
          }), _onComplete = []);
        }
        return nextProxy;
      }
      __name(_moveNext, "_moveNext");
      function _getExtCfg(identifier, createIfMissing) {
        var idCfg = null,
          cfg = dynamicHandler.cfg;
        if (cfg && identifier) {
          var extCfg = cfg[STR_EXTENSION_CONFIG];
          !extCfg && createIfMissing && (extCfg = {}), cfg[STR_EXTENSION_CONFIG] = extCfg, extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG), extCfg && (idCfg = extCfg[identifier], !idCfg && createIfMissing && (idCfg = {}), extCfg[identifier] = idCfg, idCfg = dynamicHandler.ref(extCfg, identifier));
        }
        return idCfg;
      }
      __name(_getExtCfg, "_getExtCfg");
      function _resolveExtCfg(identifier, defaultValues) {
        var newConfig = _getExtCfg(identifier, !0);
        return defaultValues && objForEachKey(defaultValues, function (field, defaultValue) {
          if (isNullOrUndefined(newConfig[field])) {
            var cfgValue = dynamicHandler.cfg[field];
            (cfgValue || !isNullOrUndefined(cfgValue)) && (newConfig[field] = cfgValue);
          }
          _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);
        }), dynamicHandler[_DYN_SET_DF](newConfig, defaultValues);
      }
      __name(_resolveExtCfg, "_resolveExtCfg");
      function _getConfig(identifier, field, defaultValue) {
        defaultValue === void 0 && (defaultValue = !1);
        var theValue,
          extConfig = _getExtCfg(identifier, !1),
          rootConfig = dynamicHandler.cfg;
        return extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field])) ? theValue = extConfig[field] : (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) && (theValue = rootConfig[field]), theValue || !isNullOrUndefined(theValue) ? theValue : defaultValue;
      }
      __name(_getConfig, "_getConfig");
      function _iterateChain(cb) {
        for (var nextPlugin; nextPlugin = context._next();) {
          var plugin = nextPlugin[_DYN_GET_PLUGIN]();
          plugin && cb(plugin);
        }
      }
      return __name(_iterateChain, "_iterateChain"), context;
    }
    __name(_createInternalContext, "_createInternalContext");
    function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {
      var config = createDynamicConfig(cfg),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(env) {
        var nextPlugin = internalContext._next();
        return nextPlugin && nextPlugin[STR_PROCESS_TELEMETRY](env, context), !nextPlugin;
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config.cfg, core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryContext, "createProcessTelemetryContext");
    function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
      var config = createDynamicConfig(core.config),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(unloadState) {
        var nextPlugin = internalContext._next();
        return nextPlugin && nextPlugin[_DYN_UNLOAD](context, unloadState), !nextPlugin;
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryUnloadContext, "createProcessTelemetryUnloadContext");
    function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
      var config = createDynamicConfig(core.config),
        internalContext = _createInternalContext(telemetryChain, config, core, startAt),
        context = internalContext.ctx;
      function _processNext(updateState) {
        return context.iterate(function (plugin) {
          isFunction(plugin[_DYN_UPDATE]) && plugin[_DYN_UPDATE](context, updateState);
        });
      }
      __name(_processNext, "_processNext");
      function _createNew(plugins, startAt) {
        return plugins === void 0 && (plugins = null), isArray(plugins) && (plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt)), createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt);
      }
      return __name(_createNew, "_createNew"), context[_DYN_PROCESS_NEXT] = _processNext, context[_DYN_CREATE_NEW] = _createNew, context;
    }
    __name(createProcessTelemetryUpdateContext, "createProcessTelemetryUpdateContext");
    function createTelemetryProxyChain(plugins, config, core, startAt) {
      var firstProxy = null,
        add = !startAt;
      if (isArray(plugins) && plugins[_DYN_LENGTH] > 0) {
        var lastProxy_1 = null;
        arrForEach(plugins, function (thePlugin) {
          if (!add && startAt === thePlugin && (add = !0), add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
            var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
            firstProxy || (firstProxy = newProxy), lastProxy_1 && lastProxy_1._setNext(newProxy), lastProxy_1 = newProxy;
          }
        });
      }
      return startAt && !firstProxy ? createTelemetryProxyChain([startAt], config, core) : firstProxy;
    }
    __name(createTelemetryProxyChain, "createTelemetryProxyChain");
    function createTelemetryPluginProxy(plugin, config, core) {
      var nextProxy = null,
        hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]),
        hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]),
        chainId;
      plugin ? chainId = plugin[_DYN_IDENTIFIER] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++ : chainId = "Unknown-0-" + _chainId++;
      var proxyChain = {
        getPlugin: function () {
          return plugin;
        },
        getNext: function () {
          return nextProxy;
        },
        processTelemetry: _processTelemetry,
        unload: _unloadPlugin,
        update: _updatePlugin,
        _id: chainId,
        _setNext: function (nextPlugin) {
          nextProxy = nextPlugin;
        }
      };
      function _getTelCtx() {
        var itemCtx;
        return plugin && isFunction(plugin[strGetTelCtx]) && (itemCtx = plugin[strGetTelCtx]()), itemCtx || (itemCtx = createProcessTelemetryContext(proxyChain, config, core)), itemCtx;
      }
      __name(_getTelCtx, "_getTelCtx");
      function _processChain(itemCtx, processPluginFn, name, details, isAsync) {
        var hasRun = !1,
          identifier = plugin ? plugin[_DYN_IDENTIFIER] : strTelemetryPluginChain,
          hasRunContext = itemCtx[strHasRunFlags];
        return hasRunContext || (hasRunContext = itemCtx[strHasRunFlags] = {}), itemCtx.setNext(nextProxy), plugin && doPerf(itemCtx[STR_CORE](), function () {
          return identifier + ":" + name;
        }, function () {
          hasRunContext[chainId] = !0;
          try {
            var nextId = nextProxy ? nextProxy._id : STR_EMPTY;
            nextId && (hasRunContext[nextId] = !1), hasRun = processPluginFn(itemCtx);
          } catch (error) {
            var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : !0;
            hasNextRun && (hasRun = !0), (!nextProxy || !hasNextRun) && _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 73, "Plugin [" + identifier + "] failed during " + name + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
          }
        }, details, isAsync), hasRun;
      }
      __name(_processChain, "_processChain");
      function _processTelemetry(env, itemCtx) {
        itemCtx = itemCtx || _getTelCtx();
        function _callProcessTelemetry(itemCtx) {
          if (!plugin || !hasProcessTelemetry) return !1;
          var pluginState = _getPluginState(plugin);
          return pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED] ? !1 : (hasSetNext && plugin[_DYN_SET_NEXT_PLUGIN](nextProxy), plugin[STR_PROCESS_TELEMETRY](env, itemCtx), !0);
        }
        __name(_callProcessTelemetry, "_callProcessTelemetry"), _processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function () {
          return {
            item: env
          };
        }, !env.sync) || itemCtx[_DYN_PROCESS_NEXT](env);
      }
      __name(_processTelemetry, "_processTelemetry");
      function _unloadPlugin(unloadCtx, unloadState) {
        function _callTeardown() {
          var hasRun = !1;
          if (plugin) {
            var pluginState = _getPluginState(plugin),
              pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
            plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN] && (pluginState[STR_CORE] = null, pluginState[_DYN_TEARDOWN] = !0, pluginState[_DYN_IS_INITIALIZED] = !1, plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === !0 && (hasRun = !0));
          }
          return hasRun;
        }
        __name(_callTeardown, "_callTeardown"), _processChain(unloadCtx, _callTeardown, "unload", function () {}, unloadState[_DYN_IS_ASYNC]) || unloadCtx[_DYN_PROCESS_NEXT](unloadState);
      }
      __name(_unloadPlugin, "_unloadPlugin");
      function _updatePlugin(updateCtx, updateState) {
        function _callUpdate() {
          var hasRun = !1;
          if (plugin) {
            var pluginState = _getPluginState(plugin),
              pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
            plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN] && plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === !0 && (hasRun = !0);
          }
          return hasRun;
        }
        __name(_callUpdate, "_callUpdate"), _processChain(updateCtx, _callUpdate, "update", function () {}, !1) || updateCtx[_DYN_PROCESS_NEXT](updateState);
      }
      return __name(_updatePlugin, "_updatePlugin"), objFreeze(proxyChain);
    }
    __name(createTelemetryPluginProxy, "createTelemetryPluginProxy");
    function createUnloadHandlerContainer() {
      var handlers = [];
      function _addHandler(handler) {
        handler && handlers[_DYN_PUSH](handler);
      }
      __name(_addHandler, "_addHandler");
      function _runHandlers(unloadCtx, unloadState) {
        arrForEach(handlers, function (handler) {
          try {
            handler(unloadCtx, unloadState);
          } catch (e) {
            _throwInternal(unloadCtx[_DYN_DIAG_LOG](), 2, 73, "Unexpected error calling unload handler - " + dumpObj(e));
          }
        }), handlers = [];
      }
      return __name(_runHandlers, "_runHandlers"), {
        add: _addHandler,
        run: _runHandlers
      };
    }
    __name(createUnloadHandlerContainer, "createUnloadHandlerContainer");
    function createUnloadHookContainer() {
      var _hooks = [];
      function _doUnload(logger) {
        var oldHooks = _hooks;
        _hooks = [], arrForEach(oldHooks, function (fn) {
          try {
            (fn.rm || fn.remove).call(fn);
          } catch (e) {
            _throwInternal(logger, 2, 73, "Unloading:" + dumpObj(e));
          }
        });
      }
      __name(_doUnload, "_doUnload");
      function _addHook(hooks) {
        hooks && arrAppend(_hooks, hooks);
      }
      return __name(_addHook, "_addHook"), {
        run: _doUnload,
        add: _addHook
      };
    }
    __name(createUnloadHookContainer, "createUnloadHookContainer");
    var _a,
      strGetPlugin = "getPlugin",
      defaultValues = (_a = {}, _a[STR_EXTENSION_CONFIG] = {
        isVal: isNotNullOrUndefined,
        v: {}
      }, _a),
      BaseTelemetryPlugin = function () {
        function BaseTelemetryPlugin() {
          var _self = this,
            _isinitialized,
            _rootCtx,
            _nextPlugin,
            _unloadHandlerContainer,
            _hookContainer;
          _initDefaults(), dynamicProto(BaseTelemetryPlugin, _self, function (_self) {
            _self[_DYN_INITIALIZE] = function (config, core, extensions, pluginChain) {
              _setDefaults(config, core, pluginChain), _isinitialized = !0;
            }, _self[_DYN_TEARDOWN] = function (unloadCtx, unloadState) {
              var _a,
                core = _self[STR_CORE];
              if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) return;
              var result,
                unloadDone = !1,
                theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin),
                theUnloadState = unloadState || (_a = {
                  reason: 0
                }, _a[_DYN_IS_ASYNC] = !1, _a);
              function _unloadCallback() {
                unloadDone || (unloadDone = !0, _unloadHandlerContainer.run(theUnloadCtx, unloadState), _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG]()), result === !0 && theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState), _initDefaults());
              }
              return __name(_unloadCallback, "_unloadCallback"), !_self[_DYN__DO_TEARDOWN] || _self[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== !0 ? _unloadCallback() : result = !0, result;
            }, _self[_DYN_UPDATE] = function (updateCtx, updateState) {
              var core = _self[STR_CORE];
              if (!core || updateCtx && core !== updateCtx[STR_CORE]()) return;
              var result,
                updateDone = !1,
                theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin),
                theUpdateState = updateState || {
                  reason: 0
                };
              function _updateCallback() {
                updateDone || (updateDone = !0, _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]()));
              }
              return __name(_updateCallback, "_updateCallback"), !_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== !0 ? _updateCallback() : result = !0, result;
            }, proxyFunctionAs(_self, "_addUnloadCb", function () {
              return _unloadHandlerContainer;
            }, "add"), proxyFunctionAs(_self, "_addHook", function () {
              return _hookContainer;
            }, "add"), objDefine(_self, "_unloadHooks", {
              g: function () {
                return _hookContainer;
              }
            });
          }), _self[_DYN_DIAG_LOG] = function (itemCtx) {
            return _getTelCtx(itemCtx)[_DYN_DIAG_LOG]();
          }, _self[_DYN_IS_INITIALIZED] = function () {
            return _isinitialized;
          }, _self.setInitialized = function (isInitialized) {
            _isinitialized = isInitialized;
          }, _self[_DYN_SET_NEXT_PLUGIN] = function (next) {
            _nextPlugin = next;
          }, _self[_DYN_PROCESS_NEXT] = function (env, itemCtx) {
            itemCtx ? itemCtx[_DYN_PROCESS_NEXT](env) : _nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY]) && _nextPlugin[STR_PROCESS_TELEMETRY](env, null);
          }, _self._getTelCtx = _getTelCtx;
          function _getTelCtx(currentCtx) {
            currentCtx === void 0 && (currentCtx = null);
            var itemCtx = currentCtx;
            if (!itemCtx) {
              var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
              _nextPlugin && _nextPlugin[strGetPlugin] ? itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]) : itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
            }
            return itemCtx;
          }
          __name(_getTelCtx, "_getTelCtx");
          function _setDefaults(config, core, pluginChain) {
            createDynamicConfig(config, defaultValues, safeGetLogger(core)), !pluginChain && core && (pluginChain = core[_DYN_GET_PROCESS_TEL_CONT0]()[_DYN_GET_NEXT]());
            var nextPlugin = _nextPlugin;
            _nextPlugin && _nextPlugin[strGetPlugin] && (nextPlugin = _nextPlugin[strGetPlugin]()), _self[STR_CORE] = core, _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
          }
          __name(_setDefaults, "_setDefaults");
          function _initDefaults() {
            _isinitialized = !1, _self[STR_CORE] = null, _rootCtx = null, _nextPlugin = null, _hookContainer = createUnloadHookContainer(), _unloadHandlerContainer = createUnloadHandlerContainer();
          }
          __name(_initDefaults, "_initDefaults");
        }
        return __name(BaseTelemetryPlugin, "BaseTelemetryPlugin"), BaseTelemetryPlugin.__ieDyn = 1, BaseTelemetryPlugin;
      }();
    function _addInitializer(_initializers, id, telemetryInitializer) {
      var theInitializer = {
        id: id,
        fn: telemetryInitializer
      };
      arrAppend(_initializers, theInitializer);
      var handler = {
        remove: function () {
          arrForEach(_initializers, function (initializer, idx) {
            if (initializer.id === theInitializer.id) return _initializers[_DYN_SPLICE](idx, 1), -1;
          });
        }
      };
      return handler;
    }
    __name(_addInitializer, "_addInitializer");
    function _runInitializers(_initializers, item, logger) {
      for (var doNotSendItem = !1, telemetryInitializersCount = _initializers[_DYN_LENGTH], i = 0; i < telemetryInitializersCount; ++i) {
        var telemetryInitializer = _initializers[i];
        if (telemetryInitializer) try {
          if (telemetryInitializer.fn[_DYN_APPLY](null, [item]) === !1) {
            doNotSendItem = !0;
            break;
          }
        } catch (e) {
          _throwInternal(logger, 2, 64, "Telemetry initializer failed: " + getExceptionName(e), {
            exception: dumpObj(e)
          }, !0);
        }
      }
      return !doNotSendItem;
    }
    __name(_runInitializers, "_runInitializers");
    var TelemetryInitializerPlugin = function (_super) {
        __extends(TelemetryInitializerPlugin, _super);
        function TelemetryInitializerPlugin() {
          var _this = _super.call(this) || this;
          _this.identifier = "TelemetryInitializerPlugin", _this.priority = 199;
          var _id, _initializers;
          _initDefaults(), dynamicProto(TelemetryInitializerPlugin, _this, function (_self, _base) {
            _self.addTelemetryInitializer = function (telemetryInitializer) {
              return _addInitializer(_initializers, _id++, telemetryInitializer);
            }, _self[STR_PROCESS_TELEMETRY] = function (item, itemCtx) {
              _runInitializers(_initializers, item, itemCtx ? itemCtx[_DYN_DIAG_LOG]() : _self[_DYN_DIAG_LOG]()) && _self[_DYN_PROCESS_NEXT](item, itemCtx);
            }, _self[_DYN__DO_TEARDOWN] = function () {
              _initDefaults();
            };
          });
          function _initDefaults() {
            _id = 0, _initializers = [];
          }
          return __name(_initDefaults, "_initDefaults"), _this;
        }
        return __name(TelemetryInitializerPlugin, "TelemetryInitializerPlugin"), TelemetryInitializerPlugin.__ieDyn = 1, TelemetryInitializerPlugin;
      }(BaseTelemetryPlugin),
      _a,
      strValidationError = "Plugins must provide initialize method",
      strNotificationManager = "_notificationManager",
      strSdkUnloadingError = "SDK is still unloading...",
      strSdkNotInitialized = "SDK is not initialized",
      defaultConfig = objDeepFreeze((_a = {
        cookieCfg: {}
      }, _a[STR_EXTENSIONS] = {
        rdOnly: !0,
        ref: !0,
        v: []
      }, _a[STR_CHANNELS] = {
        rdOnly: !0,
        ref: !0,
        v: []
      }, _a[STR_EXTENSION_CONFIG] = {
        ref: !0,
        v: {}
      }, _a[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE, _a.loggingLevelConsole = 0, _a.diagnosticLogInterval = UNDEFINED_VALUE, _a));
    function _createPerfManager(core, notificationMgr) {
      return new PerfManager(notificationMgr);
    }
    __name(_createPerfManager, "_createPerfManager");
    function _validateExtensions(logger, channelPriority, allExtensions) {
      var _a,
        coreExtensions = [],
        channels = [],
        extPriorities = {};
      return arrForEach(allExtensions, function (ext) {
        (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE])) && throwError(strValidationError);
        var extPriority = ext[STR_PRIORITY],
          identifier = ext[_DYN_IDENTIFIER];
        ext && extPriority && (isNullOrUndefined(extPriorities[extPriority]) ? extPriorities[extPriority] = identifier : _warnToConsole(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier)), !extPriority || extPriority < channelPriority ? coreExtensions[_DYN_PUSH](ext) : channels[_DYN_PUSH](ext);
      }), _a = {}, _a[STR_CORE] = coreExtensions, _a[STR_CHANNELS] = channels, _a;
    }
    __name(_validateExtensions, "_validateExtensions");
    function _isPluginPresent(thePlugin, plugins) {
      var exists = !1;
      return arrForEach(plugins, function (plugin) {
        if (plugin === thePlugin) return exists = !0, -1;
      }), exists;
    }
    __name(_isPluginPresent, "_isPluginPresent");
    function _deepMergeConfig(details, target, newValues, merge) {
      newValues && objForEachKey(newValues, function (key, value) {
        merge && isPlainObject(value) && isPlainObject(target[key]) && _deepMergeConfig(details, target[key], value, merge), merge && isPlainObject(value) && isPlainObject(target[key]) ? _deepMergeConfig(details, target[key], value, merge) : details.set(target, key, value);
      });
    }
    __name(_deepMergeConfig, "_deepMergeConfig");
    function _findWatcher(listeners, newWatcher) {
      var theListener = null,
        idx = -1;
      return arrForEach(listeners, function (listener, lp) {
        if (listener.w === newWatcher) return theListener = listener, idx = lp, -1;
      }), {
        i: idx,
        l: theListener
      };
    }
    __name(_findWatcher, "_findWatcher");
    function _addDelayedCfgListener(listeners, newWatcher) {
      var theListener = _findWatcher(listeners, newWatcher).l;
      return theListener || (theListener = {
        w: newWatcher,
        rm: function () {
          var fnd = _findWatcher(listeners, newWatcher);
          fnd.i !== -1 && listeners[_DYN_SPLICE](fnd.i, 1);
        }
      }, listeners[_DYN_PUSH](theListener)), theListener;
    }
    __name(_addDelayedCfgListener, "_addDelayedCfgListener");
    function _registerDelayedCfgListener(config, listeners, logger) {
      arrForEach(listeners, function (listener) {
        var unloadHdl = onConfigChange(config, listener.w, logger);
        delete listener.w, listener.rm = function () {
          unloadHdl.rm();
        };
      });
    }
    __name(_registerDelayedCfgListener, "_registerDelayedCfgListener");
    var AppInsightsCore = function () {
        function AppInsightsCore() {
          var _configHandler, _isInitialized, _logger, _eventQueue, _notificationManager, _perfManager, _cfgPerfManager, _cookieManager, _pluginChain, _configExtensions, _channelConfig, _channels, _isUnloading, _telemetryInitializerPlugin, _internalLogsEventName, _evtNamespace, _unloadHandlers, _hookContainer, _debugListener, _traceCtx, _instrumentationKey, _cfgListeners, _extensions, _pluginVersionStringArr, _pluginVersionString, _internalLogPoller, _internalLogPollerListening, _forceStopInternalLogPoller;
          dynamicProto(AppInsightsCore, this, function (_self) {
            _initDefaults(), _self._getDbgPlgTargets = function () {
              return [_extensions];
            }, _self[_DYN_IS_INITIALIZED] = function () {
              return _isInitialized;
            }, _self[_DYN_INITIALIZE] = function (config, extensions, logger, notificationManager) {
              _isUnloading && throwError(strSdkUnloadingError), _self[_DYN_IS_INITIALIZED]() && throwError("Core cannot be initialized more than once"), _configHandler = createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER], !1), config = _configHandler.cfg, _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                _instrumentationKey = details.cfg.instrumentationKey;
                var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);
                objForEachKey(extCfg, function (key) {
                  details.ref(extCfg, key);
                }), isNullOrUndefined(_instrumentationKey) && throwError("Please provide instrumentation key");
              })), _notificationManager = notificationManager, _initDebugListener(), _initPerfManager(), _self[_DYN_LOGGER] = logger;
              var cfgExtensions = config[STR_EXTENSIONS];
              if (_configExtensions = [], _configExtensions[_DYN_PUSH].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, !1), cfgExtensions)), _channelConfig = config[STR_CHANNELS], _initPluginChain(null), (!_channels || _channels[_DYN_LENGTH] === 0) && throwError("No " + STR_CHANNELS + " available"), _channelConfig && _channelConfig[_DYN_LENGTH] > 1) {
                var teeController = _self[_DYN_GET_PLUGIN]("TeeChannelController");
                (!teeController || !teeController.plugin) && _throwInternal(_logger, 1, 28, "TeeChannel required");
              }
              _registerDelayedCfgListener(config, _cfgListeners, _logger), _cfgListeners = null, _isInitialized = !0, _self.releaseQueue(), _self[_DYN_POLL_INTERNAL_LOGS]();
            }, _self.getChannels = function () {
              var controls = [];
              return _channels && arrForEach(_channels, function (channel) {
                controls[_DYN_PUSH](channel);
              }), objFreeze(controls);
            }, _self.track = function (telemetryItem) {
              doPerf(_self[STR_GET_PERF_MGR](), function () {
                return "AppInsightsCore:track";
              }, function () {
                telemetryItem === null && (_notifyInvalidEvent(telemetryItem), throwError("Invalid telemetry item")), !telemetryItem[_DYN_NAME] && isNullOrUndefined(telemetryItem[_DYN_NAME]) && (_notifyInvalidEvent(telemetryItem), throwError("telemetry name required")), telemetryItem.iKey = telemetryItem.iKey || _instrumentationKey, telemetryItem[_DYN_TIME] = telemetryItem[_DYN_TIME] || toISOString(new Date()), telemetryItem.ver = telemetryItem.ver || "4.0", !_isUnloading && _self[_DYN_IS_INITIALIZED]() ? _createTelCtx()[_DYN_PROCESS_NEXT](telemetryItem) : _eventQueue[_DYN_PUSH](telemetryItem);
              }, function () {
                return {
                  item: telemetryItem
                };
              }, !telemetryItem.sync);
            }, _self[_DYN_GET_PROCESS_TEL_CONT0] = _createTelCtx, _self[_DYN_GET_NOTIFY_MGR] = function () {
              return _notificationManager || (_notificationManager = new NotificationManager(_configHandler.cfg), _self[strNotificationManager] = _notificationManager), _notificationManager;
            }, _self[_DYN_ADD_NOTIFICATION_LIS1] = function (listener) {
              _self[_DYN_GET_NOTIFY_MGR]()[_DYN_ADD_NOTIFICATION_LIS1](listener);
            }, _self[_DYN_REMOVE_NOTIFICATION_2] = function (listener) {
              _notificationManager && _notificationManager[_DYN_REMOVE_NOTIFICATION_2](listener);
            }, _self.getCookieMgr = function () {
              return _cookieManager || (_cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER])), _cookieManager;
            }, _self.setCookieMgr = function (cookieMgr) {
              _cookieManager !== cookieMgr && (runTargetUnload(_cookieManager, !1), _cookieManager = cookieMgr);
            }, _self[STR_GET_PERF_MGR] = function () {
              return !_perfManager && !_cfgPerfManager && _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                if (details.cfg.enablePerfMgr) {
                  var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR];
                  isFunction(createPerfMgr) && (_cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR]()));
                }
              })), _perfManager || _cfgPerfManager || getGblPerfMgr();
            }, _self.setPerfMgr = function (perfMgr) {
              _perfManager = perfMgr;
            }, _self.eventCnt = function () {
              return _eventQueue[_DYN_LENGTH];
            }, _self.releaseQueue = function () {
              if (_isInitialized && _eventQueue[_DYN_LENGTH] > 0) {
                var eventQueue = _eventQueue;
                _eventQueue = [], arrForEach(eventQueue, function (event) {
                  _createTelCtx()[_DYN_PROCESS_NEXT](event);
                });
              }
            }, _self[_DYN_POLL_INTERNAL_LOGS] = function (eventName) {
              return _internalLogsEventName = eventName || null, _forceStopInternalLogPoller = !1, _internalLogPoller && _internalLogPoller[_DYN_CANCEL](), _startLogPoller(!0);
            };
            function _startLogPoller(alwaysStart) {
              if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED]) && !_forceStopInternalLogPoller) {
                var shouldStart = alwaysStart || _logger && _logger.queue[_DYN_LENGTH] > 0;
                shouldStart && (_internalLogPollerListening || (_internalLogPollerListening = !0, _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                  var interval = details.cfg.diagnosticLogInterval;
                  (!interval || !(interval > 0)) && (interval = 1e4);
                  var isRunning = !1;
                  _internalLogPoller && (isRunning = _internalLogPoller[_DYN_ENABLED], _internalLogPoller[_DYN_CANCEL]()), _internalLogPoller = createTimeout(_flushInternalLogs, interval), _internalLogPoller.unref(), _internalLogPoller[_DYN_ENABLED] = isRunning;
                }))), _internalLogPoller[_DYN_ENABLED] = !0);
              }
              return _internalLogPoller;
            }
            __name(_startLogPoller, "_startLogPoller"), _self[_DYN_STOP_POLLING_INTERNA3] = function () {
              _forceStopInternalLogPoller = !0, _internalLogPoller && _internalLogPoller[_DYN_CANCEL](), _flushInternalLogs();
            }, proxyFunctions(_self, function () {
              return _telemetryInitializerPlugin;
            }, ["addTelemetryInitializer"]), _self[_DYN_UNLOAD] = function (isAsync, unloadComplete, cbTimeout) {
              var _a;
              isAsync === void 0 && (isAsync = !0), _isInitialized || throwError(strSdkNotInitialized), _isUnloading && throwError(strSdkUnloadingError);
              var unloadState = (_a = {
                  reason: 50
                }, _a[_DYN_IS_ASYNC] = isAsync, _a.flushComplete = !1, _a),
                result;
              isAsync && !unloadComplete && (result = createPromise(function (resolve) {
                unloadComplete = resolve;
              }));
              var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
              processUnloadCtx[_DYN_ON_COMPLETE](function () {
                _hookContainer.run(_self[_DYN_LOGGER]), doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {
                  _initDefaults(), unloadComplete && unloadComplete(unloadState);
                });
              }, _self);
              function _doUnload(flushComplete) {
                unloadState.flushComplete = flushComplete, _isUnloading = !0, _unloadHandlers.run(processUnloadCtx, unloadState), _self[_DYN_STOP_POLLING_INTERNA3](), processUnloadCtx[_DYN_PROCESS_NEXT](unloadState);
              }
              return __name(_doUnload, "_doUnload"), _flushInternalLogs(), _flushChannels(isAsync, _doUnload, 6, cbTimeout), result;
            }, _self[_DYN_GET_PLUGIN] = _getPlugin, _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {
              if (!plugin) {
                addCb && addCb(!1), _logOrThrowError(strValidationError);
                return;
              }
              var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER]);
              if (existingPlugin && !replaceExisting) {
                addCb && addCb(!1), _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER] + "] is already loaded!");
                return;
              }
              var updateState = {
                reason: 16
              };
              function _addPlugin(removed) {
                _configExtensions[_DYN_PUSH](plugin), updateState.added = [plugin], _initPluginChain(updateState), addCb && addCb(!0);
              }
              if (__name(_addPlugin, "_addPlugin"), existingPlugin) {
                var removedPlugins_1 = [existingPlugin.plugin],
                  unloadState = {
                    reason: 2,
                    isAsync: !!isAsync
                  };
                _removePlugins(removedPlugins_1, unloadState, function (removed) {
                  removed ? (updateState.removed = removedPlugins_1, updateState.reason |= 32, _addPlugin()) : addCb && addCb(!1);
                });
              } else _addPlugin();
            }, _self.updateCfg = function (newConfig, mergeExisting) {
              mergeExisting === void 0 && (mergeExisting = !0);
              var updateState;
              if (_self[_DYN_IS_INITIALIZED]()) {
                updateState = {
                  reason: 1,
                  cfg: _configHandler.cfg,
                  oldCfg: deepExtend({}, _configHandler.cfg),
                  newConfig: deepExtend({}, newConfig),
                  merge: mergeExisting
                }, newConfig = updateState.newConfig;
                var cfg = _configHandler.cfg;
                newConfig[STR_EXTENSIONS] = cfg[STR_EXTENSIONS], newConfig[STR_CHANNELS] = cfg[STR_CHANNELS];
              }
              _configHandler._block(function (details) {
                var theConfig = details.cfg;
                _deepMergeConfig(details, theConfig, newConfig, mergeExisting), mergeExisting || objForEachKey(theConfig, function (key) {
                  objHasOwn(newConfig, key) || details.set(theConfig, key, UNDEFINED_VALUE);
                }), details[_DYN_SET_DF](theConfig, defaultConfig);
              }, !0), _configHandler[_DYN_NOTIFY](), updateState && _doUpdate(updateState);
            }, _self.evtNamespace = function () {
              return _evtNamespace;
            }, _self.flush = _flushChannels, _self.getTraceCtx = function (createNew) {
              return _traceCtx || (_traceCtx = createDistributedTraceContext()), _traceCtx;
            }, _self.setTraceCtx = function (traceCtx) {
              _traceCtx = traceCtx || null;
            }, _self.addUnloadHook = _addUnloadHook, proxyFunctionAs(_self, "addUnloadCb", function () {
              return _unloadHandlers;
            }, "add"), _self.onCfgChange = function (handler) {
              var unloadHook;
              return _isInitialized ? unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER]) : unloadHook = _addDelayedCfgListener(_cfgListeners, handler), {
                rm: function () {
                  unloadHook.rm();
                }
              };
            }, _self.getWParam = function () {
              return hasDocument() || _configHandler.cfg.enableWParam ? 0 : -1;
            };
            function _setPluginVersions() {
              var thePlugins = {};
              _pluginVersionStringArr = [];
              var _addPluginVersions = __name(function (plugins) {
                plugins && arrForEach(plugins, function (plugin) {
                  if (plugin[_DYN_IDENTIFIER] && plugin[_DYN_VERSION] && !thePlugins[plugin.identifier]) {
                    var ver = plugin[_DYN_IDENTIFIER] + "=" + plugin[_DYN_VERSION];
                    _pluginVersionStringArr[_DYN_PUSH](ver), thePlugins[plugin.identifier] = plugin;
                  }
                });
              }, "_addPluginVersions");
              _addPluginVersions(_channels), _channelConfig && arrForEach(_channelConfig, function (channels) {
                _addPluginVersions(channels);
              }), _addPluginVersions(_configExtensions);
            }
            __name(_setPluginVersions, "_setPluginVersions");
            function _initDefaults() {
              _isInitialized = !1, _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER]), _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4] = 1, objDefine(_self, "config", {
                g: function () {
                  return _configHandler.cfg;
                },
                s: function (newValue) {
                  _self.updateCfg(newValue, !1);
                }
              }), objDefine(_self, "pluginVersionStringArr", {
                g: function () {
                  return _pluginVersionStringArr || _setPluginVersions(), _pluginVersionStringArr;
                }
              }), objDefine(_self, "pluginVersionString", {
                g: function () {
                  return _pluginVersionString || (_pluginVersionStringArr || _setPluginVersions(), _pluginVersionString = _pluginVersionStringArr.join(";")), _pluginVersionString || STR_EMPTY;
                }
              }), objDefine(_self, "logger", {
                g: function () {
                  return _logger || (_logger = new DiagnosticLogger(_configHandler.cfg), _configHandler[_DYN_LOGGER] = _logger), _logger;
                },
                s: function (newLogger) {
                  _configHandler[_DYN_LOGGER] = newLogger, _logger !== newLogger && (runTargetUnload(_logger, !1), _logger = newLogger);
                }
              }), _self[_DYN_LOGGER] = new DiagnosticLogger(_configHandler.cfg), _extensions = [];
              var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
              cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH]), arrAppend(cfgExtensions, _extensions), _telemetryInitializerPlugin = new TelemetryInitializerPlugin(), _eventQueue = [], runTargetUnload(_notificationManager, !1), _notificationManager = null, _perfManager = null, _cfgPerfManager = null, runTargetUnload(_cookieManager, !1), _cookieManager = null, _pluginChain = null, _configExtensions = [], _channelConfig = null, _channels = null, _isUnloading = !1, _internalLogsEventName = null, _evtNamespace = createUniqueNamespace("AIBaseCore", !0), _unloadHandlers = createUnloadHandlerContainer(), _traceCtx = null, _instrumentationKey = null, _hookContainer = createUnloadHookContainer(), _cfgListeners = [], _pluginVersionString = null, _pluginVersionStringArr = null, _forceStopInternalLogPoller = !1;
            }
            __name(_initDefaults, "_initDefaults");
            function _createTelCtx() {
              var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);
              return theCtx[_DYN_ON_COMPLETE](_startLogPoller), theCtx;
            }
            __name(_createTelCtx, "_createTelCtx");
            function _initPluginChain(updateState) {
              var theExtensions = _validateExtensions(_self[_DYN_LOGGER], ChannelControllerPriority, _configExtensions);
              _pluginChain = null, _pluginVersionString = null, _pluginVersionStringArr = null, _channels = (_channelConfig || [])[0] || [], _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS]));
              var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE]), _channels);
              _extensions = objFreeze(allExtensions);
              var cfgExtensions = _self.config[STR_EXTENSIONS] || [];
              cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH]), arrAppend(cfgExtensions, _extensions);
              var rootCtx = _createTelCtx();
              _channels && _channels[_DYN_LENGTH] > 0 && initializePlugins(rootCtx[_DYN_CREATE_NEW](_channels), allExtensions), initializePlugins(rootCtx, allExtensions), updateState && _doUpdate(updateState);
            }
            __name(_initPluginChain, "_initPluginChain");
            function _getPlugin(pluginIdentifier) {
              var theExt = null,
                thePlugin = null,
                channelHosts = [];
              return arrForEach(_extensions, function (ext) {
                if (ext[_DYN_IDENTIFIER] === pluginIdentifier && ext !== _telemetryInitializerPlugin) return thePlugin = ext, -1;
                ext.getChannel && channelHosts[_DYN_PUSH](ext);
              }), !thePlugin && channelHosts[_DYN_LENGTH] > 0 && arrForEach(channelHosts, function (host) {
                if (thePlugin = host.getChannel(pluginIdentifier), !thePlugin) return -1;
              }), thePlugin && (theExt = {
                plugin: thePlugin,
                setEnabled: function (enabled) {
                  _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                },
                isEnabled: function () {
                  var pluginState = _getPluginState(thePlugin);
                  return !pluginState[_DYN_TEARDOWN] && !pluginState[STR_DISABLED];
                },
                remove: function (isAsync, removeCb) {
                  var _a;
                  isAsync === void 0 && (isAsync = !0);
                  var pluginsToRemove = [thePlugin],
                    unloadState = (_a = {
                      reason: 1
                    }, _a[_DYN_IS_ASYNC] = isAsync, _a);
                  _removePlugins(pluginsToRemove, unloadState, function (removed) {
                    removed && _initPluginChain({
                      reason: 32,
                      removed: pluginsToRemove
                    }), removeCb && removeCb(removed);
                  });
                }
              }), theExt;
            }
            __name(_getPlugin, "_getPlugin");
            function _getPluginChain() {
              if (!_pluginChain) {
                var extensions = (_extensions || []).slice();
                arrIndexOf(extensions, _telemetryInitializerPlugin) === -1 && extensions[_DYN_PUSH](_telemetryInitializerPlugin), _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);
              }
              return _pluginChain;
            }
            __name(_getPluginChain, "_getPluginChain");
            function _removePlugins(thePlugins, unloadState, removeComplete) {
              if (thePlugins && thePlugins[_DYN_LENGTH] > 0) {
                var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self),
                  unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                unloadCtx[_DYN_ON_COMPLETE](function () {
                  var removed = !1,
                    newConfigExtensions = [];
                  arrForEach(_configExtensions, function (plugin, idx) {
                    _isPluginPresent(plugin, thePlugins) ? removed = !0 : newConfigExtensions[_DYN_PUSH](plugin);
                  }), _configExtensions = newConfigExtensions, _pluginVersionString = null, _pluginVersionStringArr = null;
                  var newChannelConfig = [];
                  _channelConfig && (arrForEach(_channelConfig, function (queue, idx) {
                    var newQueue = [];
                    arrForEach(queue, function (channel) {
                      _isPluginPresent(channel, thePlugins) ? removed = !0 : newQueue[_DYN_PUSH](channel);
                    }), newChannelConfig[_DYN_PUSH](newQueue);
                  }), _channelConfig = newChannelConfig), removeComplete && removeComplete(removed), _startLogPoller();
                }), unloadCtx[_DYN_PROCESS_NEXT](unloadState);
              } else removeComplete(!1);
            }
            __name(_removePlugins, "_removePlugins");
            function _flushInternalLogs() {
              if (_logger && _logger.queue) {
                var queue = _logger.queue.slice(0);
                _logger.queue[_DYN_LENGTH] = 0, arrForEach(queue, function (logMessage) {
                  var _a,
                    item = (_a = {}, _a[_DYN_NAME] = _internalLogsEventName || "InternalMessageId: " + logMessage[_DYN_MESSAGE_ID], _a.iKey = _instrumentationKey, _a[_DYN_TIME] = toISOString(new Date()), _a.baseType = _InternalLogMessage.dataType, _a.baseData = {
                      message: logMessage[_DYN_MESSAGE]
                    }, _a);
                  _self.track(item);
                });
              }
            }
            __name(_flushInternalLogs, "_flushInternalLogs");
            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
              var waiting = 1,
                doneIterating = !1,
                cbTimer = null;
              cbTimeout = cbTimeout || 5e3;
              function doCallback() {
                waiting--, doneIterating && waiting === 0 && (cbTimer && cbTimer[_DYN_CANCEL](), cbTimer = null, callBack && callBack(doneIterating), callBack = null);
              }
              if (__name(doCallback, "doCallback"), _channels && _channels[_DYN_LENGTH] > 0) {
                var flushCtx = _createTelCtx()[_DYN_CREATE_NEW](_channels);
                flushCtx.iterate(function (plugin) {
                  if (plugin.flush) {
                    waiting++;
                    var handled_1 = !1;
                    plugin.flush(isAsync, function () {
                      handled_1 = !0, doCallback();
                    }, sendReason) || handled_1 || (isAsync && cbTimer == null ? cbTimer = scheduleTimeout(function () {
                      cbTimer = null, doCallback();
                    }, cbTimeout) : doCallback());
                  }
                });
              }
              return doneIterating = !0, doCallback(), !0;
            }
            __name(_flushChannels, "_flushChannels");
            function _initDebugListener() {
              !_notificationManager && _self[_DYN_GET_NOTIFY_MGR](), _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                var disableDbgExt = details.cfg.disableDbgExt;
                disableDbgExt === !0 && _debugListener && (_notificationManager[_DYN_REMOVE_NOTIFICATION_2](_debugListener), _debugListener = null), _notificationManager && !_debugListener && disableDbgExt !== !0 && (_debugListener = getDebugListener(details.cfg), _notificationManager[_DYN_ADD_NOTIFICATION_LIS1](_debugListener));
              }));
            }
            __name(_initDebugListener, "_initDebugListener");
            function _initPerfManager() {
              _addUnloadHook(_configHandler[_DYN_WATCH](function (details) {
                var enablePerfMgr = details.cfg.enablePerfMgr;
                !enablePerfMgr && _cfgPerfManager && (_cfgPerfManager = null), enablePerfMgr && getSetValue(details.cfg, STR_CREATE_PERF_MGR, _createPerfManager);
              }));
            }
            __name(_initPerfManager, "_initPerfManager");
            function _doUpdate(updateState) {
              var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
              updateCtx[_DYN_ON_COMPLETE](_startLogPoller), (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== !0) && updateCtx[_DYN_PROCESS_NEXT](updateState);
            }
            __name(_doUpdate, "_doUpdate");
            function _logOrThrowError(message) {
              var logger = _self[_DYN_LOGGER];
              logger ? (_throwInternal(logger, 2, 73, message), _startLogPoller()) : throwError(message);
            }
            __name(_logOrThrowError, "_logOrThrowError");
            function _notifyInvalidEvent(telemetryItem) {
              var manager = _self[_DYN_GET_NOTIFY_MGR]();
              manager && manager[STR_EVENTS_DISCARDED]([telemetryItem], 2);
            }
            __name(_notifyInvalidEvent, "_notifyInvalidEvent");
            function _addUnloadHook(hooks) {
              _hookContainer.add(hooks);
            }
            __name(_addUnloadHook, "_addUnloadHook");
          });
        }
        return __name(AppInsightsCore, "AppInsightsCore"), AppInsightsCore.__ieDyn = 1, AppInsightsCore;
      }(),
      strOnPrefix = "on",
      strAttachEvent = "attachEvent",
      strAddEventHelper = "addEventListener",
      strDetachEvent = "detachEvent",
      strRemoveEventListener = "removeEventListener",
      strEvents = "events";
    createUniqueNamespace("aiEvtPageHide"), createUniqueNamespace("aiEvtPageShow");
    var rRemoveEmptyNs = /\.[\.]+/g,
      rRemoveTrailingEmptyNs = /[\.]+$/,
      _guid = 1,
      elmNodeData = createElmNodeData("events"),
      eventNamespace = /^([^.]*)(?:\.(.+)|)/;
    function _normalizeNamespace(name) {
      return name && name[_DYN_REPLACE] ? name[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY) : name;
    }
    __name(_normalizeNamespace, "_normalizeNamespace");
    function _getEvtNamespace(eventName, evtNamespace) {
      var _a;
      if (evtNamespace) {
        var theNamespace_1 = STR_EMPTY;
        isArray(evtNamespace) ? (theNamespace_1 = STR_EMPTY, arrForEach(evtNamespace, function (name) {
          name = _normalizeNamespace(name), name && (name[0] !== "." && (name = "." + name), theNamespace_1 += name);
        })) : theNamespace_1 = _normalizeNamespace(evtNamespace), theNamespace_1 && (theNamespace_1[0] !== "." && (theNamespace_1 = "." + theNamespace_1), eventName = (eventName || STR_EMPTY) + theNamespace_1);
      }
      var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
      return _a = {}, _a[_DYN_TYPE] = parsedEvent[1], _a.ns = (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT](".").sort().join("."), _a;
    }
    __name(_getEvtNamespace, "_getEvtNamespace");
    function _getRegisteredEvents(target, evtName, addDefault) {
      addDefault === void 0 && (addDefault = !0);
      var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault),
        registeredEvents = aiEvts[evtName];
      return registeredEvents || (registeredEvents = aiEvts[evtName] = []), registeredEvents;
    }
    __name(_getRegisteredEvents, "_getRegisteredEvents");
    function _doDetach(obj, evtName, handlerRef, useCapture) {
      obj && evtName && evtName[_DYN_TYPE] && (obj[strRemoveEventListener] ? obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture) : obj[strDetachEvent] && obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef));
    }
    __name(_doDetach, "_doDetach");
    function _doAttach(obj, evtName, handlerRef, useCapture) {
      var result = !1;
      return obj && evtName && evtName[_DYN_TYPE] && handlerRef && (obj[strAddEventHelper] ? (obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture), result = !0) : obj[strAttachEvent] && (obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef), result = !0)), result;
    }
    __name(_doAttach, "_doAttach");
    function _doUnregister(target, events, evtName, unRegFn) {
      for (var idx = events[_DYN_LENGTH]; idx--;) {
        var theEvent = events[idx];
        theEvent && (!evtName.ns || evtName.ns === theEvent.evtName.ns) && (!unRegFn || unRegFn(theEvent)) && (_doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER], theEvent.capture), events[_DYN_SPLICE](idx, 1));
      }
    }
    __name(_doUnregister, "_doUnregister");
    function _unregisterEvents(target, evtName, unRegFn) {
      if (evtName[_DYN_TYPE]) _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);else {
        var eventCache = elmNodeData.get(target, strEvents, {});
        objForEachKey(eventCache, function (evtType, events) {
          _doUnregister(target, events, evtName, unRegFn);
        }), objKeys(eventCache)[_DYN_LENGTH] === 0 && elmNodeData.kill(target, strEvents);
      }
    }
    __name(_unregisterEvents, "_unregisterEvents");
    function mergeEvtNamespace(theNamespace, namespaces) {
      var newNamespaces;
      return namespaces ? (isArray(namespaces) ? newNamespaces = [theNamespace].concat(namespaces) : newNamespaces = [theNamespace, namespaces], newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".")) : newNamespaces = theNamespace, newNamespaces;
    }
    __name(mergeEvtNamespace, "mergeEvtNamespace");
    function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
      var _a;
      useCapture === void 0 && (useCapture = !1);
      var result = !1;
      if (target) try {
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        if (result = _doAttach(target, evtName, handlerRef, useCapture), result && elmNodeData.accept(target)) {
          var registeredEvent = (_a = {
            guid: _guid++,
            evtName: evtName
          }, _a[_DYN_HANDLER] = handlerRef, _a.capture = useCapture, _a);
          _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
        }
      } catch {}
      return result;
    }
    __name(eventOn, "eventOn");
    function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
      if (useCapture === void 0 && (useCapture = !1), target) try {
        var evtName_1 = _getEvtNamespace(eventName, evtNamespace),
          found_1 = !1;
        _unregisterEvents(target, evtName_1, function (regEvent) {
          return evtName_1.ns && !handlerRef || regEvent[_DYN_HANDLER] === handlerRef ? (found_1 = !0, !0) : !1;
        }), found_1 || _doDetach(target, evtName_1, handlerRef, useCapture);
      } catch {}
    }
    __name(eventOff, "eventOff");
    var DisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation",
      SampleRate = "sampleRate",
      ProcessLegacy = "ProcessLegacy",
      HttpMethod = "http.method",
      DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com",
      DEFAULT_BREEZE_PATH = "/v2/track",
      strNotSpecified = "not_specified",
      RequestHeaders = createValueMap({
        requestContextHeader: [0, "Request-Context"],
        requestContextTargetKey: [1, "appId"],
        requestContextAppIdFormat: [2, "appId=cid-v1:"],
        requestIdHeader: [3, "Request-Id"],
        traceParentHeader: [4, "traceparent"],
        traceStateHeader: [5, "tracestate"],
        sdkContextHeader: [6, "Sdk-Context"],
        sdkContextHeaderAppIdRequest: [7, "appId"],
        requestContextHeaderLowerCase: [8, "request-context"]
      }),
      _DYN_SPLIT = "split",
      _DYN_LENGTH = "length",
      _DYN_TO_LOWER_CASE = "toLowerCase",
      _DYN_INGESTIONENDPOINT = "ingestionendpoint",
      _DYN_TO_STRING = "toString",
      _DYN_PUSH = "push",
      _DYN_REMOVE_ITEM = "removeItem",
      _DYN_NAME = "name",
      _DYN_MESSAGE = "message",
      _DYN_COUNT = "count",
      _DYN_STRINGIFY = "stringify",
      _DYN_PATHNAME = "pathname",
      _DYN_EXCEPTIONS = "exceptions",
      _DYN_PARSED_STACK = "parsedStack",
      _DYN_PROPERTIES = "properties",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_SIZE_IN_BYTES = "sizeInBytes",
      _DYN_TYPE_NAME = "typeName",
      _DYN_SEVERITY_LEVEL = "severityLevel",
      _DYN_PROBLEM_GROUP = "problemGroup",
      _DYN_IS_MANUAL = "isManual",
      _DYN__CREATE_FROM_INTERFA1 = "CreateFromInterface",
      _DYN_ASSEMBLY = "assembly",
      _DYN_FILE_NAME = "fileName",
      _DYN_HAS_FULL_STACK = "hasFullStack",
      _DYN_LEVEL = "level",
      _DYN_METHOD = "method",
      _DYN_LINE = "line",
      _DYN_DURATION = "duration",
      _DYN_RECEIVED_RESPONSE = "receivedResponse";
    function dataSanitizeKeyAndAddUniqueness(logger, key, map) {
      var origLength = key[_DYN_LENGTH],
        field = dataSanitizeKey(logger, key);
      if (field[_DYN_LENGTH] !== origLength) {
        for (var i = 0, uniqueField = field; map[uniqueField] !== void 0;) i++, uniqueField = strSubstring(field, 0, 147) + dsPadNumber(i);
        field = uniqueField;
      }
      return field;
    }
    __name(dataSanitizeKeyAndAddUniqueness, "dataSanitizeKeyAndAddUniqueness");
    function dataSanitizeKey(logger, name) {
      var nameTrunc;
      return name && (name = strTrim(asString(name)), name[_DYN_LENGTH] > 150 && (nameTrunc = strSubstring(name, 0, 150), _throwInternal(logger, 2, 57, "name is too long.  It has been truncated to 150 characters.", {
        name: name
      }, !0))), nameTrunc || name;
    }
    __name(dataSanitizeKey, "dataSanitizeKey");
    function dataSanitizeString(logger, value, maxLength) {
      maxLength === void 0 && (maxLength = 1024);
      var valueTrunc;
      return value && (maxLength = maxLength || 1024, value = strTrim(asString(value)), value[_DYN_LENGTH] > maxLength && (valueTrunc = strSubstring(value, 0, maxLength), _throwInternal(logger, 2, 61, "string value is too long. It has been truncated to " + maxLength + " characters.", {
        value: value
      }, !0))), valueTrunc || value;
    }
    __name(dataSanitizeString, "dataSanitizeString");
    function dataSanitizeUrl(logger, url) {
      return dataSanitizeInput(logger, url, 2048, 66);
    }
    __name(dataSanitizeUrl, "dataSanitizeUrl");
    function dataSanitizeMessage(logger, message) {
      var messageTrunc;
      return message && message[_DYN_LENGTH] > 32768 && (messageTrunc = strSubstring(message, 0, 32768), _throwInternal(logger, 2, 56, "message is too long, it has been truncated to 32768 characters.", {
        message: message
      }, !0)), messageTrunc || message;
    }
    __name(dataSanitizeMessage, "dataSanitizeMessage");
    function dataSanitizeException(logger, exception) {
      var exceptionTrunc;
      if (exception) {
        var value = "" + exception;
        value[_DYN_LENGTH] > 32768 && (exceptionTrunc = strSubstring(value, 0, 32768), _throwInternal(logger, 2, 52, "exception is too long, it has been truncated to 32768 characters.", {
          exception: exception
        }, !0));
      }
      return exceptionTrunc || exception;
    }
    __name(dataSanitizeException, "dataSanitizeException");
    function dataSanitizeProperties(logger, properties) {
      if (properties) {
        var tempProps_1 = {};
        objForEachKey(properties, function (prop, value) {
          if (isObject(value) && hasJSON()) try {
            value = getJSON()[_DYN_STRINGIFY](value);
          } catch (e) {
            _throwInternal(logger, 2, 49, "custom property is not valid", {
              exception: e
            }, !0);
          }
          value = dataSanitizeString(logger, value, 8192), prop = dataSanitizeKeyAndAddUniqueness(logger, prop, tempProps_1), tempProps_1[prop] = value;
        }), properties = tempProps_1;
      }
      return properties;
    }
    __name(dataSanitizeProperties, "dataSanitizeProperties");
    function dataSanitizeMeasurements(logger, measurements) {
      if (measurements) {
        var tempMeasurements_1 = {};
        objForEachKey(measurements, function (measure, value) {
          measure = dataSanitizeKeyAndAddUniqueness(logger, measure, tempMeasurements_1), tempMeasurements_1[measure] = value;
        }), measurements = tempMeasurements_1;
      }
      return measurements;
    }
    __name(dataSanitizeMeasurements, "dataSanitizeMeasurements");
    function dataSanitizeId(logger, id) {
      return id && dataSanitizeInput(logger, id, 128, 69)[_DYN_TO_STRING]();
    }
    __name(dataSanitizeId, "dataSanitizeId");
    function dataSanitizeInput(logger, input, maxLength, _msgId) {
      var inputTrunc;
      return input && (input = strTrim(asString(input)), input[_DYN_LENGTH] > maxLength && (inputTrunc = strSubstring(input, 0, maxLength), _throwInternal(logger, 2, _msgId, "input is too long, it has been truncated to " + maxLength + " characters.", {
        data: input
      }, !0))), inputTrunc || input;
    }
    __name(dataSanitizeInput, "dataSanitizeInput");
    function dsPadNumber(num) {
      var s = "00" + num;
      return strSubstr(s, s[_DYN_LENGTH] - 3);
    }
    __name(dsPadNumber, "dsPadNumber");
    var _document = getDocument() || {},
      _htmlAnchorIdx = 0,
      _htmlAnchorElement = [null, null, null, null, null];
    function urlParseUrl(url) {
      var anchorIdx = _htmlAnchorIdx,
        anchorCache = _htmlAnchorElement,
        tempAnchor = anchorCache[anchorIdx];
      return _document.createElement ? anchorCache[anchorIdx] || (tempAnchor = anchorCache[anchorIdx] = _document.createElement("a")) : tempAnchor = {
        host: urlParseHost(url, !0)
      }, tempAnchor.href = url, anchorIdx++, anchorIdx >= anchorCache[_DYN_LENGTH] && (anchorIdx = 0), _htmlAnchorIdx = anchorIdx, tempAnchor;
    }
    __name(urlParseUrl, "urlParseUrl");
    function urlParseHost(url, inclPort) {
      var fullHost = urlParseFullHost(url, inclPort) || "";
      if (fullHost) {
        var match = fullHost.match(/(www\d{0,5}\.)?([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 3 && isString(match[2]) && match[2][_DYN_LENGTH] > 0) return match[2] + (match[3] || "");
      }
      return fullHost;
    }
    __name(urlParseHost, "urlParseHost");
    function urlParseFullHost(url, inclPort) {
      var result = null;
      if (url) {
        var match = url.match(/(\w{1,150}):\/\/([^\/:]{1,256})(:\d{1,20})?/i);
        if (match != null && match[_DYN_LENGTH] > 2 && isString(match[2]) && match[2][_DYN_LENGTH] > 0 && (result = match[2] || "", inclPort && match[_DYN_LENGTH] > 2)) {
          var protocol = (match[1] || "")[_DYN_TO_LOWER_CASE](),
            port = match[3] || "";
          (protocol === "http" && port === ":80" || protocol === "https" && port === ":443") && (port = ""), result += port;
        }
      }
      return result;
    }
    __name(urlParseFullHost, "urlParseFullHost");
    var _internalEndpoints = [DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH, "https://breeze.aimon.applicationinsights.io" + DEFAULT_BREEZE_PATH, "https://dc-int.services.visualstudio.com" + DEFAULT_BREEZE_PATH];
    function isInternalApplicationInsightsEndpoint(endpointUrl) {
      return arrIndexOf(_internalEndpoints, endpointUrl[_DYN_TO_LOWER_CASE]()) !== -1;
    }
    __name(isInternalApplicationInsightsEndpoint, "isInternalApplicationInsightsEndpoint");
    function AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName) {
      var target,
        name = commandName,
        data = commandName;
      if (absoluteUrl && absoluteUrl[_DYN_LENGTH] > 0) {
        var parsedUrl = urlParseUrl(absoluteUrl);
        if (target = parsedUrl.host, !name) if (parsedUrl[_DYN_PATHNAME] != null) {
          var pathName = parsedUrl.pathname[_DYN_LENGTH] === 0 ? "/" : parsedUrl[_DYN_PATHNAME];
          pathName.charAt(0) !== "/" && (pathName = "/" + pathName), data = parsedUrl[_DYN_PATHNAME], name = dataSanitizeString(logger, method ? method + " " + pathName : pathName);
        } else name = dataSanitizeString(logger, absoluteUrl);
      } else target = commandName, name = commandName;
      return {
        target: target,
        name: name,
        data: data
      };
    }
    __name(AjaxHelperParseDependencyPath, "AjaxHelperParseDependencyPath");
    var StorageType = createEnumStyle({
        LocalStorage: 0,
        SessionStorage: 1
      }),
      _canUseSessionStorage = void 0,
      _storagePrefix = "";
    function _getVerifiedStorageObject(storageType) {
      try {
        if (isNullOrUndefined(getGlobal())) return null;
        var uid = new Date()[_DYN_TO_STRING](),
          storage = getGlobalInst(storageType === StorageType.LocalStorage ? "localStorage" : "sessionStorage"),
          name_1 = _storagePrefix + uid;
        storage.setItem(name_1, uid);
        var fail = storage.getItem(name_1) !== uid;
        if (storage[_DYN_REMOVE_ITEM](name_1), !fail) return storage;
      } catch {}
      return null;
    }
    __name(_getVerifiedStorageObject, "_getVerifiedStorageObject");
    function _getSessionStorageObject() {
      return utlCanUseSessionStorage() ? _getVerifiedStorageObject(StorageType.SessionStorage) : null;
    }
    __name(_getSessionStorageObject, "_getSessionStorageObject");
    function utlSetStoragePrefix(storagePrefix) {
      _storagePrefix = storagePrefix || "";
    }
    __name(utlSetStoragePrefix, "utlSetStoragePrefix");
    function utlCanUseSessionStorage(reset) {
      return (reset || _canUseSessionStorage === void 0) && (_canUseSessionStorage = !!_getVerifiedStorageObject(StorageType.SessionStorage)), _canUseSessionStorage;
    }
    __name(utlCanUseSessionStorage, "utlCanUseSessionStorage");
    function utlGetSessionStorage(logger, name) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.getItem(name);
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 2, "Browser failed read of session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return null;
    }
    __name(utlGetSessionStorage, "utlGetSessionStorage");
    function utlSetSessionStorage(logger, name, data) {
      var storage = _getSessionStorageObject();
      if (storage !== null) try {
        return storage.setItem(name, data), !0;
      } catch (e) {
        _canUseSessionStorage = !1, _throwInternal(logger, 2, 4, "Browser failed write to session storage. " + getExceptionName(e), {
          exception: dumpObj(e)
        });
      }
      return !1;
    }
    __name(utlSetSessionStorage, "utlSetSessionStorage");
    var _FIELDS_SEPARATOR = ";",
      _FIELD_KEY_VALUE_SEPARATOR = "=";
    function parseConnectionString(connectionString) {
      if (!connectionString) return {};
      var kvPairs = connectionString[_DYN_SPLIT](_FIELDS_SEPARATOR),
        result = arrReduce(kvPairs, function (fields, kv) {
          var kvParts = kv[_DYN_SPLIT](_FIELD_KEY_VALUE_SEPARATOR);
          if (kvParts[_DYN_LENGTH] === 2) {
            var key = kvParts[0][_DYN_TO_LOWER_CASE](),
              value = kvParts[1];
            fields[key] = value;
          }
          return fields;
        }, {});
      if (objKeys(result)[_DYN_LENGTH] > 0) {
        if (result.endpointsuffix) {
          var locationPrefix = result.location ? result.location + "." : "";
          result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || "https://" + locationPrefix + "dc." + result.endpointsuffix;
        }
        result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT] || DEFAULT_BREEZE_ENDPOINT, strEndsWith(result[_DYN_INGESTIONENDPOINT], "/") && (result[_DYN_INGESTIONENDPOINT] = result[_DYN_INGESTIONENDPOINT].slice(0, -1));
      }
      return result;
    }
    __name(parseConnectionString, "parseConnectionString");
    var Envelope = function () {
        function Envelope(logger, data, name) {
          var _this = this,
            _self = this;
          _self.ver = 1, _self.sampleRate = 100, _self.tags = {}, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self.data = data, _self.time = toISOString(new Date()), _self.aiDataContract = {
            time: 1,
            iKey: 1,
            name: 1,
            sampleRate: function () {
              return _this.sampleRate === 100 ? 4 : 1;
            },
            tags: 1,
            data: 1
          };
        }
        return __name(Envelope, "Envelope"), Envelope;
      }(),
      Event = function () {
        function Event(logger, name, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            name: 1,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Event, "Event"), Event.envelopeType = "Microsoft.ApplicationInsights.{0}.Event", Event.dataType = "EventData", Event;
      }(),
      NoMethod = "<no_method>",
      strError = "error",
      strStack = "stack",
      strStackDetails = "stackDetails",
      strErrorSrc = "errorSrc",
      strMessage = "message",
      strDescription = "description";
    function _stringify(value, convertToString) {
      var result = value;
      return result && !isString(result) && (JSON && JSON[_DYN_STRINGIFY] ? (result = JSON[_DYN_STRINGIFY](value), convertToString && (!result || result === "{}") && (isFunction(value[_DYN_TO_STRING]) ? result = value[_DYN_TO_STRING]() : result = "" + value)) : result = "" + value + " - (Missing JSON.stringify)"), result || "";
    }
    __name(_stringify, "_stringify");
    function _formatMessage(theEvent, errorType) {
      var evtMessage = theEvent;
      return theEvent && (evtMessage && !isString(evtMessage) && (evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage), evtMessage && !isString(evtMessage) && (evtMessage = _stringify(evtMessage, !0)), theEvent.filename && (evtMessage = evtMessage + " @" + (theEvent.filename || "") + ":" + (theEvent.lineno || "?") + ":" + (theEvent.colno || "?"))), errorType && errorType !== "String" && errorType !== "Object" && errorType !== "Error" && strIndexOf(evtMessage || "", errorType) === -1 && (evtMessage = errorType + ": " + evtMessage), evtMessage || "";
    }
    __name(_formatMessage, "_formatMessage");
    function _isExceptionDetailsInternal(value) {
      try {
        if (isObject(value)) return "hasFullStack" in value && "typeName" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionDetailsInternal, "_isExceptionDetailsInternal");
    function _isExceptionInternal(value) {
      try {
        if (isObject(value)) return "ver" in value && "exceptions" in value && "properties" in value;
      } catch {}
      return !1;
    }
    __name(_isExceptionInternal, "_isExceptionInternal");
    function _isStackDetails(details) {
      return details && details.src && isString(details.src) && details.obj && isArray(details.obj);
    }
    __name(_isStackDetails, "_isStackDetails");
    function _convertStackObj(errorStack) {
      var src = errorStack || "";
      isString(src) || (isString(src[strStack]) ? src = src[strStack] : src = "" + src);
      var items = src[_DYN_SPLIT](`
`);
      return {
        src: src,
        obj: items
      };
    }
    __name(_convertStackObj, "_convertStackObj");
    function _getOperaStack(errorMessage) {
      for (var stack = [], lines = errorMessage[_DYN_SPLIT](`
`), lp = 0; lp < lines[_DYN_LENGTH]; lp++) {
        var entry = lines[lp];
        lines[lp + 1] && (entry += "@" + lines[lp + 1], lp++), stack[_DYN_PUSH](entry);
      }
      return {
        src: errorMessage,
        obj: stack
      };
    }
    __name(_getOperaStack, "_getOperaStack");
    function _getStackFromErrorObj(errorObj) {
      var details = null;
      if (errorObj) try {
        if (errorObj[strStack]) details = _convertStackObj(errorObj[strStack]);else if (errorObj[strError] && errorObj[strError][strStack]) details = _convertStackObj(errorObj[strError][strStack]);else if (errorObj.exception && errorObj.exception[strStack]) details = _convertStackObj(errorObj.exception[strStack]);else if (_isStackDetails(errorObj)) details = errorObj;else if (_isStackDetails(errorObj[strStackDetails])) details = errorObj[strStackDetails];else if (getWindow() && getWindow().opera && errorObj[strMessage]) details = _getOperaStack(errorObj[_DYN_MESSAGE]);else if (errorObj.reason && errorObj.reason[strStack]) details = _convertStackObj(errorObj.reason[strStack]);else if (isString(errorObj)) details = _convertStackObj(errorObj);else {
          var evtMessage = errorObj[strMessage] || errorObj[strDescription] || "";
          isString(errorObj[strErrorSrc]) && (evtMessage && (evtMessage += `
`), evtMessage += " from " + errorObj[strErrorSrc]), evtMessage && (details = _convertStackObj(evtMessage));
        }
      } catch (e) {
        details = _convertStackObj(e);
      }
      return details || {
        src: "",
        obj: null
      };
    }
    __name(_getStackFromErrorObj, "_getStackFromErrorObj");
    function _formatStackTrace(stackDetails) {
      var stack = "";
      return stackDetails && (stackDetails.obj ? arrForEach(stackDetails.obj, function (entry) {
        stack += entry + `
`;
      }) : stack = stackDetails.src || ""), stack;
    }
    __name(_formatStackTrace, "_formatStackTrace");
    function _parseStack(stack) {
      var parsedStack,
        frames = stack.obj;
      if (frames && frames[_DYN_LENGTH] > 0) {
        parsedStack = [];
        var level_1 = 0,
          totalSizeInBytes_1 = 0;
        arrForEach(frames, function (frame) {
          var theFrame = frame[_DYN_TO_STRING]();
          if (_StackFrame.regex.test(theFrame)) {
            var parsedFrame = new _StackFrame(theFrame, level_1++);
            totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES], parsedStack[_DYN_PUSH](parsedFrame);
          }
        });
        var exceptionParsedStackThreshold = 32 * 1024;
        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) for (var left = 0, right = parsedStack[_DYN_LENGTH] - 1, size = 0, acceptedLeft = left, acceptedRight = right; left < right;) {
          var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES],
            rSize = parsedStack[right][_DYN_SIZE_IN_BYTES];
          if (size += lSize + rSize, size > exceptionParsedStackThreshold) {
            var howMany = acceptedRight - acceptedLeft + 1;
            parsedStack.splice(acceptedLeft, howMany);
            break;
          }
          acceptedLeft = left, acceptedRight = right, left++, right--;
        }
      }
      return parsedStack;
    }
    __name(_parseStack, "_parseStack");
    function _getErrorType(errorType) {
      var typeName = "";
      if (errorType && (typeName = errorType.typeName || errorType[_DYN_NAME] || "", !typeName)) try {
        var funcNameRegex = /function (.{1,200})\(/,
          results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING]());
        typeName = results && results[_DYN_LENGTH] > 1 ? results[1] : "";
      } catch {}
      return typeName;
    }
    __name(_getErrorType, "_getErrorType");
    function _formatErrorCode(errorObj) {
      if (errorObj) try {
        if (!isString(errorObj)) {
          var errorType = _getErrorType(errorObj),
            result = _stringify(errorObj, !1);
          return (!result || result === "{}") && (errorObj[strError] && (errorObj = errorObj[strError], errorType = _getErrorType(errorObj)), result = _stringify(errorObj, !0)), strIndexOf(result, errorType) !== 0 && errorType !== "String" ? errorType + ":" + result : result;
        }
      } catch {}
      return "" + (errorObj || "");
    }
    __name(_formatErrorCode, "_formatErrorCode");
    var Exception = function () {
        function Exception(logger, exception, properties, measurements, severityLevel, id) {
          this.aiDataContract = {
            ver: 1,
            exceptions: 1,
            severityLevel: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _isExceptionInternal(exception) ? (_self[_DYN_EXCEPTIONS] = exception[_DYN_EXCEPTIONS] || [], _self[_DYN_PROPERTIES] = exception[_DYN_PROPERTIES], _self[_DYN_MEASUREMENTS] = exception[_DYN_MEASUREMENTS], exception[_DYN_SEVERITY_LEVEL] && (_self[_DYN_SEVERITY_LEVEL] = exception[_DYN_SEVERITY_LEVEL]), exception.id && (_self.id = exception.id, exception[_DYN_PROPERTIES].id = exception.id), exception[_DYN_PROBLEM_GROUP] && (_self[_DYN_PROBLEM_GROUP] = exception[_DYN_PROBLEM_GROUP]), isNullOrUndefined(exception[_DYN_IS_MANUAL]) || (_self[_DYN_IS_MANUAL] = exception[_DYN_IS_MANUAL])) : (properties || (properties = {}), id && (properties.id = id), _self[_DYN_EXCEPTIONS] = [new _ExceptionDetails(logger, exception, properties)], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel), id && (_self.id = id));
        }
        return __name(Exception, "Exception"), Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {
          var _a,
            errorType = _getErrorType(error || evt || message);
          return _a = {}, _a[_DYN_MESSAGE] = _formatMessage(message, errorType), _a.url = url, _a.lineNumber = lineNumber, _a.columnNumber = columnNumber, _a.error = _formatErrorCode(error || evt || message), _a.evt = _formatErrorCode(evt || message), _a[_DYN_TYPE_NAME] = errorType, _a.stackDetails = _getStackFromErrorObj(stack || error || evt), _a.errorSrc = errorSrc, _a;
        }, Exception.CreateFromInterface = function (logger, exception, properties, measurements) {
          var exceptions = exception[_DYN_EXCEPTIONS] && arrMap(exception[_DYN_EXCEPTIONS], function (ex) {
              return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1](logger, ex);
            }),
            exceptionData = new Exception(logger, __assign(__assign({}, exception), {
              exceptions: exceptions
            }), properties, measurements);
          return exceptionData;
        }, Exception.prototype.toInterface = function () {
          var _a,
            _b = this,
            exceptions = _b.exceptions,
            properties = _b.properties,
            measurements = _b.measurements,
            severityLevel = _b.severityLevel,
            problemGroup = _b.problemGroup,
            id = _b.id,
            isManual = _b.isManual,
            exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function (exception) {
              return exception.toInterface();
            }) || void 0;
          return _a = {
            ver: "4.0"
          }, _a[_DYN_EXCEPTIONS] = exceptionDetailsInterface, _a.severityLevel = severityLevel, _a.properties = properties, _a.measurements = measurements, _a.problemGroup = problemGroup, _a.id = id, _a.isManual = isManual, _a;
        }, Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {
          var _a;
          return {
            exceptions: [(_a = {}, _a[_DYN_HAS_FULL_STACK] = !0, _a.message = message, _a.stack = details, _a.typeName = typeName, _a)]
          };
        }, Exception.envelopeType = "Microsoft.ApplicationInsights.{0}.Exception", Exception.dataType = "ExceptionData", Exception.formatError = _formatErrorCode, Exception;
      }(),
      _ExceptionDetails = function () {
        function _ExceptionDetails(logger, exception, properties) {
          this.aiDataContract = {
            id: 0,
            outerId: 0,
            typeName: 1,
            message: 1,
            hasFullStack: 0,
            stack: 0,
            parsedStack: 2
          };
          var _self = this;
          if (_isExceptionDetailsInternal(exception)) _self[_DYN_TYPE_NAME] = exception[_DYN_TYPE_NAME], _self[_DYN_MESSAGE] = exception[_DYN_MESSAGE], _self[strStack] = exception[strStack], _self[_DYN_PARSED_STACK] = exception[_DYN_PARSED_STACK] || [], _self[_DYN_HAS_FULL_STACK] = exception[_DYN_HAS_FULL_STACK];else {
            var error = exception,
              evt = error && error.evt;
            isError(error) || (error = error[strError] || evt || error), _self[_DYN_TYPE_NAME] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME])) || strNotSpecified;
            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);
            _self[_DYN_PARSED_STACK] = _parseStack(stack), isArray(_self[_DYN_PARSED_STACK]) && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
              frame[_DYN_ASSEMBLY] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY]), frame[_DYN_FILE_NAME] = dataSanitizeString(logger, frame[_DYN_FILE_NAME]);
            }), _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack)), _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH] > 0, properties && (properties[_DYN_TYPE_NAME] = properties[_DYN_TYPE_NAME] || _self[_DYN_TYPE_NAME]);
          }
        }
        return __name(_ExceptionDetails, "_ExceptionDetails"), _ExceptionDetails.prototype.toInterface = function () {
          var _a,
            _self = this,
            parsedStack = _self[_DYN_PARSED_STACK] instanceof Array && arrMap(_self[_DYN_PARSED_STACK], function (frame) {
              return frame.toInterface();
            }),
            exceptionDetailsInterface = (_a = {
              id: _self.id,
              outerId: _self.outerId,
              typeName: _self[_DYN_TYPE_NAME],
              message: _self[_DYN_MESSAGE],
              hasFullStack: _self[_DYN_HAS_FULL_STACK],
              stack: _self[strStack]
            }, _a[_DYN_PARSED_STACK] = parsedStack || void 0, _a);
          return exceptionDetailsInterface;
        }, _ExceptionDetails.CreateFromInterface = function (logger, exception) {
          var parsedStack = exception[_DYN_PARSED_STACK] instanceof Array && arrMap(exception[_DYN_PARSED_STACK], function (frame) {
              return _StackFrame[_DYN__CREATE_FROM_INTERFA1](frame);
            }) || exception[_DYN_PARSED_STACK],
            exceptionDetails = new _ExceptionDetails(logger, __assign(__assign({}, exception), {
              parsedStack: parsedStack
            }));
          return exceptionDetails;
        }, _ExceptionDetails;
      }(),
      _StackFrame = function () {
        function _StackFrame(sourceFrame, level) {
          this.aiDataContract = {
            level: 1,
            method: 1,
            assembly: 0,
            fileName: 0,
            line: 0
          };
          var _self = this;
          if (_self[_DYN_SIZE_IN_BYTES] = 0, typeof sourceFrame == "string") {
            var frame = sourceFrame;
            _self[_DYN_LEVEL] = level, _self[_DYN_METHOD] = NoMethod, _self[_DYN_ASSEMBLY] = strTrim(frame), _self[_DYN_FILE_NAME] = "", _self[_DYN_LINE] = 0;
            var matches = frame.match(_StackFrame.regex);
            matches && matches[_DYN_LENGTH] >= 5 && (_self[_DYN_METHOD] = strTrim(matches[2]) || _self[_DYN_METHOD], _self[_DYN_FILE_NAME] = strTrim(matches[4]), _self[_DYN_LINE] = parseInt(matches[5]) || 0);
          } else _self[_DYN_LEVEL] = sourceFrame[_DYN_LEVEL], _self[_DYN_METHOD] = sourceFrame[_DYN_METHOD], _self[_DYN_ASSEMBLY] = sourceFrame[_DYN_ASSEMBLY], _self[_DYN_FILE_NAME] = sourceFrame[_DYN_FILE_NAME], _self[_DYN_LINE] = sourceFrame[_DYN_LINE], _self[_DYN_SIZE_IN_BYTES] = 0;
          _self.sizeInBytes += _self.method[_DYN_LENGTH], _self.sizeInBytes += _self.fileName[_DYN_LENGTH], _self.sizeInBytes += _self.assembly[_DYN_LENGTH], _self[_DYN_SIZE_IN_BYTES] += _StackFrame.baseSize, _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH], _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH];
        }
        return __name(_StackFrame, "_StackFrame"), _StackFrame.CreateFromInterface = function (frame) {
          return new _StackFrame(frame, null);
        }, _StackFrame.prototype.toInterface = function () {
          var _self = this;
          return {
            level: _self[_DYN_LEVEL],
            method: _self[_DYN_METHOD],
            assembly: _self[_DYN_ASSEMBLY],
            fileName: _self[_DYN_FILE_NAME],
            line: _self[_DYN_LINE]
          };
        }, _StackFrame.regex = /^([\s]+at)?[\s]{0,50}([^\@\()]+?)[\s]{0,50}(\@|\()([^\(\n]+):([0-9]+):([0-9]+)(\)?)$/, _StackFrame.baseSize = 58, _StackFrame;
      }(),
      DataPoint = function () {
        function DataPoint() {
          this.aiDataContract = {
            name: 1,
            kind: 0,
            value: 1,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0
          }, this.kind = 0;
        }
        return __name(DataPoint, "DataPoint"), DataPoint;
      }(),
      Metric = function () {
        function Metric(logger, name, value, count, min, max, stdDev, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            metrics: 1,
            properties: 0
          };
          var _self = this;
          _self.ver = 2;
          var dataPoint = new DataPoint();
          dataPoint[_DYN_COUNT] = count > 0 ? count : void 0, dataPoint.max = isNaN(max) || max === null ? void 0 : max, dataPoint.min = isNaN(min) || min === null ? void 0 : min, dataPoint[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, dataPoint.value = value, dataPoint.stdDev = isNaN(stdDev) || stdDev === null ? void 0 : stdDev, _self.metrics = [dataPoint], _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(Metric, "Metric"), Metric.envelopeType = "Microsoft.ApplicationInsights.{0}.Metric", Metric.dataType = "MetricData", Metric;
      }(),
      strEmpty = "";
    function msToTimeSpan(totalms) {
      (isNaN(totalms) || totalms < 0) && (totalms = 0), totalms = Math.round(totalms);
      var ms = strEmpty + totalms % 1e3,
        sec = strEmpty + Math.floor(totalms / 1e3) % 60,
        min = strEmpty + Math.floor(totalms / (1e3 * 60)) % 60,
        hour = strEmpty + Math.floor(totalms / (1e3 * 60 * 60)) % 24,
        days = Math.floor(totalms / (1e3 * 60 * 60 * 24));
      return ms = ms[_DYN_LENGTH] === 1 ? "00" + ms : ms[_DYN_LENGTH] === 2 ? "0" + ms : ms, sec = sec[_DYN_LENGTH] < 2 ? "0" + sec : sec, min = min[_DYN_LENGTH] < 2 ? "0" + min : min, hour = hour[_DYN_LENGTH] < 2 ? "0" + hour : hour, (days > 0 ? days + "." : strEmpty) + hour + ":" + min + ":" + sec + "." + ms;
    }
    __name(msToTimeSpan, "msToTimeSpan");
    var PageView = function () {
        function PageView(logger, name, url, durationMs, properties, measurements, id) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            properties: 0,
            measurements: 0,
            id: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = dataSanitizeId(logger, id), _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, isNaN(durationMs) || (_self[_DYN_DURATION] = msToTimeSpan(durationMs)), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(PageView, "PageView"), PageView.envelopeType = "Microsoft.ApplicationInsights.{0}.Pageview", PageView.dataType = "PageviewData", PageView;
      }(),
      RemoteDependencyData = function () {
        function RemoteDependencyData(logger, id, absoluteUrl, commandName, value, success, resultCode, method, requestAPI, correlationContext, properties, measurements) {
          requestAPI === void 0 && (requestAPI = "Ajax"), this.aiDataContract = {
            id: 1,
            ver: 1,
            name: 0,
            resultCode: 0,
            duration: 0,
            success: 0,
            data: 0,
            target: 0,
            type: 0,
            properties: 0,
            measurements: 0,
            kind: 0,
            value: 0,
            count: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            dependencyKind: 0,
            dependencySource: 0,
            commandName: 0,
            dependencyTypeName: 0
          };
          var _self = this;
          _self.ver = 2, _self.id = id, _self[_DYN_DURATION] = msToTimeSpan(value), _self.success = success, _self.resultCode = resultCode + "", _self.type = dataSanitizeString(logger, requestAPI);
          var dependencyFields = AjaxHelperParseDependencyPath(logger, absoluteUrl, method, commandName);
          _self.data = dataSanitizeUrl(logger, commandName) || dependencyFields.data, _self.target = dataSanitizeString(logger, dependencyFields.target), correlationContext && (_self.target = "".concat(_self.target, " | ").concat(correlationContext)), _self[_DYN_NAME] = dataSanitizeString(logger, dependencyFields[_DYN_NAME]), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements);
        }
        return __name(RemoteDependencyData, "RemoteDependencyData"), RemoteDependencyData.envelopeType = "Microsoft.ApplicationInsights.{0}.RemoteDependency", RemoteDependencyData.dataType = "RemoteDependencyData", RemoteDependencyData;
      }(),
      Trace = function () {
        function Trace(logger, message, severityLevel, properties, measurements) {
          this.aiDataContract = {
            ver: 1,
            message: 1,
            severityLevel: 0,
            properties: 0
          };
          var _self = this;
          _self.ver = 2, message = message || strNotSpecified, _self[_DYN_MESSAGE] = dataSanitizeMessage(logger, message), _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), severityLevel && (_self[_DYN_SEVERITY_LEVEL] = severityLevel);
        }
        return __name(Trace, "Trace"), Trace.envelopeType = "Microsoft.ApplicationInsights.{0}.Message", Trace.dataType = "MessageData", Trace;
      }(),
      PageViewPerformance = function () {
        function PageViewPerformance(logger, name, url, unused, properties, measurements, cs4BaseData) {
          this.aiDataContract = {
            ver: 1,
            name: 0,
            url: 0,
            duration: 0,
            perfTotal: 0,
            networkConnect: 0,
            sentRequest: 0,
            receivedResponse: 0,
            domProcessing: 0,
            properties: 0,
            measurements: 0
          };
          var _self = this;
          _self.ver = 2, _self.url = dataSanitizeUrl(logger, url), _self[_DYN_NAME] = dataSanitizeString(logger, name) || strNotSpecified, _self[_DYN_PROPERTIES] = dataSanitizeProperties(logger, properties), _self[_DYN_MEASUREMENTS] = dataSanitizeMeasurements(logger, measurements), cs4BaseData && (_self.domProcessing = cs4BaseData.domProcessing, _self[_DYN_DURATION] = cs4BaseData[_DYN_DURATION], _self.networkConnect = cs4BaseData.networkConnect, _self.perfTotal = cs4BaseData.perfTotal, _self[_DYN_RECEIVED_RESPONSE] = cs4BaseData[_DYN_RECEIVED_RESPONSE], _self.sentRequest = cs4BaseData.sentRequest);
        }
        return __name(PageViewPerformance, "PageViewPerformance"), PageViewPerformance.envelopeType = "Microsoft.ApplicationInsights.{0}.PageviewPerformance", PageViewPerformance.dataType = "PageviewPerformanceData", PageViewPerformance;
      }(),
      Data = function () {
        function Data(baseType, data) {
          this.aiDataContract = {
            baseType: 1,
            baseData: 1
          }, this.baseType = baseType, this.baseData = data;
        }
        return __name(Data, "Data"), Data;
      }(),
      SeverityLevel = createEnumStyle({
        Verbose: 0,
        Information: 1,
        Warning: 2,
        Error: 3,
        Critical: 4
      });
    function _aiNameFunc(baseName) {
      var aiName = "ai." + baseName + ".";
      return function (name) {
        return aiName + name;
      };
    }
    __name(_aiNameFunc, "_aiNameFunc");
    var _aiApplication = _aiNameFunc("application"),
      _aiDevice = _aiNameFunc("device"),
      _aiLocation = _aiNameFunc("location"),
      _aiOperation = _aiNameFunc("operation"),
      _aiSession = _aiNameFunc("session"),
      _aiUser = _aiNameFunc("user"),
      _aiCloud = _aiNameFunc("cloud"),
      _aiInternal = _aiNameFunc("internal"),
      ContextTagKeys = function (_super) {
        __extends(ContextTagKeys, _super);
        function ContextTagKeys() {
          return _super.call(this) || this;
        }
        return __name(ContextTagKeys, "ContextTagKeys"), ContextTagKeys;
      }(createClassFromInterface({
        applicationVersion: _aiApplication("ver"),
        applicationBuild: _aiApplication("build"),
        applicationTypeId: _aiApplication("typeId"),
        applicationId: _aiApplication("applicationId"),
        applicationLayer: _aiApplication("layer"),
        deviceId: _aiDevice("id"),
        deviceIp: _aiDevice("ip"),
        deviceLanguage: _aiDevice("language"),
        deviceLocale: _aiDevice("locale"),
        deviceModel: _aiDevice("model"),
        deviceFriendlyName: _aiDevice("friendlyName"),
        deviceNetwork: _aiDevice("network"),
        deviceNetworkName: _aiDevice("networkName"),
        deviceOEMName: _aiDevice("oemName"),
        deviceOS: _aiDevice("os"),
        deviceOSVersion: _aiDevice("osVersion"),
        deviceRoleInstance: _aiDevice("roleInstance"),
        deviceRoleName: _aiDevice("roleName"),
        deviceScreenResolution: _aiDevice("screenResolution"),
        deviceType: _aiDevice("type"),
        deviceMachineName: _aiDevice("machineName"),
        deviceVMName: _aiDevice("vmName"),
        deviceBrowser: _aiDevice("browser"),
        deviceBrowserVersion: _aiDevice("browserVersion"),
        locationIp: _aiLocation("ip"),
        locationCountry: _aiLocation("country"),
        locationProvince: _aiLocation("province"),
        locationCity: _aiLocation("city"),
        operationId: _aiOperation("id"),
        operationName: _aiOperation("name"),
        operationParentId: _aiOperation("parentId"),
        operationRootId: _aiOperation("rootId"),
        operationSyntheticSource: _aiOperation("syntheticSource"),
        operationCorrelationVector: _aiOperation("correlationVector"),
        sessionId: _aiSession("id"),
        sessionIsFirst: _aiSession("isFirst"),
        sessionIsNew: _aiSession("isNew"),
        userAccountAcquisitionDate: _aiUser("accountAcquisitionDate"),
        userAccountId: _aiUser("accountId"),
        userAgent: _aiUser("userAgent"),
        userId: _aiUser("id"),
        userStoreRegion: _aiUser("storeRegion"),
        userAuthUserId: _aiUser("authUserId"),
        userAnonymousUserAcquisitionDate: _aiUser("anonUserAcquisitionDate"),
        userAuthenticatedUserAcquisitionDate: _aiUser("authUserAcquisitionDate"),
        cloudName: _aiCloud("name"),
        cloudRole: _aiCloud("role"),
        cloudRoleVer: _aiCloud("roleVer"),
        cloudRoleInstance: _aiCloud("roleInstance"),
        cloudEnvironment: _aiCloud("environment"),
        cloudLocation: _aiCloud("location"),
        cloudDeploymentUnit: _aiCloud("deploymentUnit"),
        internalNodeName: _aiInternal("nodeName"),
        internalSdkVersion: _aiInternal("sdkVersion"),
        internalAgentVersion: _aiInternal("agentVersion"),
        internalSnippet: _aiInternal("snippet"),
        internalSdkSrc: _aiInternal("sdkSrc")
      })),
      CtxTagKeys = new ContextTagKeys();
    function _disableEvents(target, evtNamespace) {
      eventOff(target, null, null, evtNamespace);
    }
    __name(_disableEvents, "_disableEvents");
    function createOfflineListener(parentEvtNamespace) {
      var _document = getDocument(),
        _navigator = getNavigator(),
        _isListening = !1,
        listenerList = [],
        rState = 1;
      _navigator && !isNullOrUndefined(_navigator.onLine) && !_navigator.onLine && (rState = 2);
      var uState = 0,
        _currentState = calCurrentState(),
        _evtNamespace = mergeEvtNamespace(createUniqueNamespace("OfflineListener"), parentEvtNamespace);
      try {
        if (_enableEvents(getWindow()) && (_isListening = !0), _document) {
          var target = _document.body || _document;
          target.ononline && _enableEvents(target) && (_isListening = !0);
        }
      } catch {
        _isListening = !1;
      }
      function _enableEvents(target) {
        var enabled = !1;
        return target && (enabled = eventOn(target, "online", _setOnline, _evtNamespace), enabled && eventOn(target, "offline", _setOffline, _evtNamespace)), enabled;
      }
      __name(_enableEvents, "_enableEvents");
      function _isOnline() {
        return _currentState;
      }
      __name(_isOnline, "_isOnline");
      function calCurrentState() {
        return !(uState === 2 || rState === 2);
      }
      __name(calCurrentState, "calCurrentState");
      function listnerNoticeCheck() {
        var newState = calCurrentState();
        _currentState !== newState && (_currentState = newState, arrForEach(listenerList, function (callback) {
          var offlineState = {
            isOnline: _currentState,
            rState: rState,
            uState: uState
          };
          try {
            callback(offlineState);
          } catch {}
        }));
      }
      __name(listnerNoticeCheck, "listnerNoticeCheck");
      function setOnlineState(newState) {
        uState = newState, listnerNoticeCheck();
      }
      __name(setOnlineState, "setOnlineState");
      function _setOnline() {
        rState = 1, listnerNoticeCheck();
      }
      __name(_setOnline, "_setOnline");
      function _setOffline() {
        rState = 2, listnerNoticeCheck();
      }
      __name(_setOffline, "_setOffline");
      function _unload() {
        var win = getWindow();
        if (win && _isListening) {
          if (_disableEvents(win, _evtNamespace), _document) {
            var target = _document.body || _document;
            isUndefined(target.ononline) || _disableEvents(target, _evtNamespace);
          }
          _isListening = !1;
        }
      }
      __name(_unload, "_unload");
      function addListener(callback) {
        return listenerList[_DYN_PUSH](callback), {
          rm: function () {
            var index = listenerList.indexOf(callback);
            if (index > -1) return listenerList.splice(index, 1);
          }
        };
      }
      return __name(addListener, "addListener"), {
        isOnline: _isOnline,
        isListening: function () {
          return _isListening;
        },
        unload: _unload,
        addListener: addListener,
        setOnlineState: setOnlineState
      };
    }
    __name(createOfflineListener, "createOfflineListener");
    var BreezeChannelIdentifier = "AppInsightsChannelPlugin",
      STR_DURATION = "duration",
      _DYN_TAGS = "tags",
      _DYN_DEVICE_TYPE = "deviceType",
      _DYN_DATA = "data",
      _DYN_NAME = "name",
      _DYN_TRACE_ID = "traceID",
      _DYN_LENGTH = "length",
      _DYN_STRINGIFY = "stringify",
      _DYN_MEASUREMENTS = "measurements",
      _DYN_DATA_TYPE = "dataType",
      _DYN_ENVELOPE_TYPE = "envelopeType",
      _DYN_TO_STRING = "toString",
      _DYN__GET = "_get",
      _DYN_ENQUEUE = "enqueue",
      _DYN_COUNT = "count",
      _DYN_EVENTS_LIMIT_IN_MEM = "eventsLimitInMem",
      _DYN_PUSH = "push",
      _DYN_EMIT_LINE_DELIMITED_0 = "emitLineDelimitedJson",
      _DYN_CLEAR = "clear",
      _DYN_BATCH_PAYLOADS = "batchPayloads",
      _DYN_CREATE_NEW = "createNew",
      _DYN_MARK_AS_SENT = "markAsSent",
      _DYN_CLEAR_SENT = "clearSent",
      _DYN_BUFFER_OVERRIDE = "bufferOverride",
      _DYN__BUFFER__KEY = "BUFFER_KEY",
      _DYN__SENT__BUFFER__KEY = "SENT_BUFFER_KEY",
      _DYN_CONCAT = "concat",
      _DYN__MAX__BUFFER__SIZE = "MAX_BUFFER_SIZE",
      _DYN_SEND_POST = "sendPOST",
      _DYN_TRIGGER_SEND = "triggerSend",
      _DYN_DIAG_LOG = "diagLog",
      _DYN__SENDER = "_sender",
      _DYN_CUSTOM_HEADERS = "customHeaders",
      _DYN_MAX_BATCH_SIZE_IN_BY1 = "maxBatchSizeInBytes",
      _DYN_ONUNLOAD_DISABLE_BEA2 = "onunloadDisableBeacon",
      _DYN_IS_BEACON_API_DISABL3 = "isBeaconApiDisabled",
      _DYN_ALWAYS_USE_XHR_OVERR4 = "alwaysUseXhrOverride",
      _DYN_ENABLE_SESSION_STORA5 = "enableSessionStorageBuffer",
      _DYN__BUFFER = "_buffer",
      _DYN_ONUNLOAD_DISABLE_FET6 = "onunloadDisableFetch",
      _DYN_DISABLE_SEND_BEACON_7 = "disableSendBeaconSplit",
      _DYN_INSTRUMENTATION_KEY = "instrumentationKey",
      _DYN_UNLOAD_TRANSPORTS = "unloadTransports",
      _DYN_CONVERT_UNDEFINED = "convertUndefined",
      _DYN_MAX_BATCH_INTERVAL = "maxBatchInterval",
      _DYN_SERIALIZE = "serialize",
      _DYN__XHR_READY_STATE_CHA8 = "_xhrReadyStateChange",
      _DYN__ON_ERROR = "_onError",
      _DYN__ON_PARTIAL_SUCCESS = "_onPartialSuccess",
      _DYN__ON_SUCCESS = "_onSuccess",
      _DYN_ITEMS_ACCEPTED = "itemsAccepted",
      _DYN_ITEMS_RECEIVED = "itemsReceived",
      _DYN_BASE_TYPE = "baseType",
      _DYN_SAMPLE_RATE = "sampleRate",
      _DYN_ORI_PAYLOAD = "oriPayload",
      _DYN_SET_REQUEST_HEADER = "setRequestHeader",
      _DYN_EVENTS_SEND_REQUEST = "eventsSendRequest",
      _DYN_GET_SAMPLING_SCORE = "getSamplingScore",
      _DYN_GET_HASH_CODE_SCORE = "getHashCodeScore",
      strBaseType = "baseType",
      strBaseData = "baseData",
      strProperties = "properties",
      strTrue = "true";
    function _setValueIf(target, field, value) {
      return setValue(target, field, value, isTruthy);
    }
    __name(_setValueIf, "_setValueIf");
    function _extractPartAExtensions(logger, item, env) {
      var envTags = env[_DYN_TAGS] = env[_DYN_TAGS] || {},
        itmExt = item.ext = item.ext || {},
        itmTags = item[_DYN_TAGS] = item[_DYN_TAGS] || [],
        extUser = itmExt.user;
      extUser && (_setValueIf(envTags, CtxTagKeys.userAuthUserId, extUser.authId), _setValueIf(envTags, CtxTagKeys.userId, extUser.id || extUser.localId));
      var extApp = itmExt.app;
      extApp && _setValueIf(envTags, CtxTagKeys.sessionId, extApp.sesId);
      var extDevice = itmExt.device;
      extDevice && (_setValueIf(envTags, CtxTagKeys.deviceId, extDevice.id || extDevice.localId), _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice.deviceClass), _setValueIf(envTags, CtxTagKeys.deviceIp, extDevice.ip), _setValueIf(envTags, CtxTagKeys.deviceModel, extDevice.model), _setValueIf(envTags, CtxTagKeys[_DYN_DEVICE_TYPE], extDevice[_DYN_DEVICE_TYPE]));
      var web = item.ext.web;
      if (web) {
        _setValueIf(envTags, CtxTagKeys.deviceLanguage, web.browserLang), _setValueIf(envTags, CtxTagKeys.deviceBrowserVersion, web.browserVer), _setValueIf(envTags, CtxTagKeys.deviceBrowser, web.browser);
        var envData = env[_DYN_DATA] = env[_DYN_DATA] || {},
          envBaseData = envData[strBaseData] = envData[strBaseData] || {},
          envProps = envBaseData[strProperties] = envBaseData[strProperties] || {};
        _setValueIf(envProps, "domain", web.domain), _setValueIf(envProps, "isManual", web.isManual ? strTrue : null), _setValueIf(envProps, "screenRes", web.screenRes), _setValueIf(envProps, "userConsent", web.userConsent ? strTrue : null);
      }
      var extOs = itmExt.os;
      extOs && _setValueIf(envTags, CtxTagKeys.deviceOS, extOs[_DYN_NAME]);
      var extTrace = itmExt.trace;
      extTrace && (_setValueIf(envTags, CtxTagKeys.operationParentId, extTrace.parentID), _setValueIf(envTags, CtxTagKeys.operationName, dataSanitizeString(logger, extTrace[_DYN_NAME])), _setValueIf(envTags, CtxTagKeys.operationId, extTrace[_DYN_TRACE_ID]));
      for (var tgs = {}, i = itmTags[_DYN_LENGTH] - 1; i >= 0; i--) {
        var tg = itmTags[i];
        objForEachKey(tg, function (key, value) {
          tgs[key] = value;
        }), itmTags.splice(i, 1);
      }
      objForEachKey(itmTags, function (tg, value) {
        tgs[tg] = value;
      });
      var theTags = __assign(__assign({}, envTags), tgs);
      theTags[CtxTagKeys.internalSdkVersion] || (theTags[CtxTagKeys.internalSdkVersion] = dataSanitizeString(logger, "javascript:".concat(EnvelopeCreator.Version), 64)), env[_DYN_TAGS] = optimizeObject(theTags);
    }
    __name(_extractPartAExtensions, "_extractPartAExtensions");
    function _extractPropsAndMeasurements(data, properties, measurements) {
      isNullOrUndefined(data) || objForEachKey(data, function (key, value) {
        isNumber(value) ? measurements[key] = value : isString(value) ? properties[key] = value : hasJSON() && (properties[key] = getJSON()[_DYN_STRINGIFY](value));
      });
    }
    __name(_extractPropsAndMeasurements, "_extractPropsAndMeasurements");
    function _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue) {
      isNullOrUndefined(properties) || objForEachKey(properties, function (key, value) {
        properties[key] = value || customUndefinedValue;
      });
    }
    __name(_convertPropsUndefinedToCustomDefinedValue, "_convertPropsUndefinedToCustomDefinedValue");
    function _createEnvelope(logger, envelopeType, telemetryItem, data) {
      var envelope = new Envelope(logger, data, envelopeType);
      _setValueIf(envelope, "sampleRate", telemetryItem[SampleRate]), (telemetryItem[strBaseData] || {}).startTime && (envelope.time = toISOString(telemetryItem[strBaseData].startTime)), envelope.iKey = telemetryItem.iKey;
      var iKeyNoDashes = telemetryItem.iKey.replace(/-/g, "");
      return envelope[_DYN_NAME] = envelope[_DYN_NAME].replace("{0}", iKeyNoDashes), _extractPartAExtensions(logger, telemetryItem, envelope), telemetryItem[_DYN_TAGS] = telemetryItem[_DYN_TAGS] || [], optimizeObject(envelope);
    }
    __name(_createEnvelope, "_createEnvelope");
    function EnvelopeCreatorInit(logger, telemetryItem) {
      isNullOrUndefined(telemetryItem[strBaseData]) && _throwInternal(logger, 1, 46, "telemetryItem.baseData cannot be null.");
    }
    __name(EnvelopeCreatorInit, "EnvelopeCreatorInit");
    var EnvelopeCreator = {
      Version: "3.1.0"
    };
    function DependencyEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {},
        customProperties = telemetryItem[strBaseData][strProperties] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var bd = telemetryItem[strBaseData];
      if (isNullOrUndefined(bd)) return _warnToConsole(logger, "Invalid input for dependency data"), null;
      var method = bd[strProperties] && bd[strProperties][HttpMethod] ? bd[strProperties][HttpMethod] : "GET",
        remoteDepData = new RemoteDependencyData(logger, bd.id, bd.target, bd[_DYN_NAME], bd[STR_DURATION], bd.success, bd.responseCode, method, bd.type, bd.correlationContext, customProperties, customMeasurements),
        data = new Data(RemoteDependencyData[_DYN_DATA_TYPE], remoteDepData);
      return _createEnvelope(logger, RemoteDependencyData[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(DependencyEnvelopeCreator, "DependencyEnvelopeCreator");
    function EventEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customProperties = {},
        customMeasurements = {};
      telemetryItem[strBaseType] !== Event[_DYN_DATA_TYPE] && (customProperties.baseTypeSource = telemetryItem[strBaseType]), telemetryItem[strBaseType] === Event[_DYN_DATA_TYPE] ? (customProperties = telemetryItem[strBaseData][strProperties] || {}, customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {}) : telemetryItem[strBaseData] && _extractPropsAndMeasurements(telemetryItem[strBaseData], customProperties, customMeasurements), _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var eventName = telemetryItem[strBaseData][_DYN_NAME],
        eventData = new Event(logger, eventName, customProperties, customMeasurements),
        data = new Data(Event[_DYN_DATA_TYPE], eventData);
      return _createEnvelope(logger, Event[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(EventEnvelopeCreator, "EventEnvelopeCreator");
    function ExceptionEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var customMeasurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {},
        customProperties = telemetryItem[strBaseData][strProperties] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], customProperties, customMeasurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(customProperties, customUndefinedValue);
      var bd = telemetryItem[strBaseData],
        exData = Exception.CreateFromInterface(logger, bd, customProperties, customMeasurements),
        data = new Data(Exception[_DYN_DATA_TYPE], exData);
      return _createEnvelope(logger, Exception[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(ExceptionEnvelopeCreator, "ExceptionEnvelopeCreator");
    function MetricEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var baseData = telemetryItem[strBaseData],
        props = baseData[strProperties] || {},
        measurements = baseData[_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
      var baseMetricData = new Metric(logger, baseData[_DYN_NAME], baseData.average, baseData.sampleCount, baseData.min, baseData.max, baseData.stdDev, props, measurements),
        data = new Data(Metric[_DYN_DATA_TYPE], baseMetricData);
      return _createEnvelope(logger, Metric[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(MetricEnvelopeCreator, "MetricEnvelopeCreator");
    function PageViewEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var duration,
        baseData = telemetryItem[strBaseData];
      !isNullOrUndefined(baseData) && !isNullOrUndefined(baseData[strProperties]) && !isNullOrUndefined(baseData[strProperties][STR_DURATION]) ? (duration = baseData[strProperties][STR_DURATION], delete baseData[strProperties][STR_DURATION]) : !isNullOrUndefined(telemetryItem[_DYN_DATA]) && !isNullOrUndefined(telemetryItem[_DYN_DATA][STR_DURATION]) && (duration = telemetryItem[_DYN_DATA][STR_DURATION], delete telemetryItem[_DYN_DATA][STR_DURATION]);
      var bd = telemetryItem[strBaseData],
        currentContextId;
      ((telemetryItem.ext || {}).trace || {})[_DYN_TRACE_ID] && (currentContextId = telemetryItem.ext.trace[_DYN_TRACE_ID]);
      var id = bd.id || currentContextId,
        name = bd[_DYN_NAME],
        url = bd.uri,
        properties = bd[strProperties] || {},
        measurements = bd[_DYN_MEASUREMENTS] || {};
      if (isNullOrUndefined(bd.refUri) || (properties.refUri = bd.refUri), isNullOrUndefined(bd.pageType) || (properties.pageType = bd.pageType), isNullOrUndefined(bd.isLoggedIn) || (properties.isLoggedIn = bd.isLoggedIn[_DYN_TO_STRING]()), !isNullOrUndefined(bd[strProperties])) {
        var pageTags = bd[strProperties];
        objForEachKey(pageTags, function (key, value) {
          properties[key] = value;
        });
      }
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
      var pageViewData = new PageView(logger, name, url, duration, properties, measurements, id),
        data = new Data(PageView[_DYN_DATA_TYPE], pageViewData);
      return _createEnvelope(logger, PageView[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(PageViewEnvelopeCreator, "PageViewEnvelopeCreator");
    function PageViewPerformanceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var bd = telemetryItem[strBaseData],
        name = bd[_DYN_NAME],
        url = bd.uri || bd.url,
        properties = bd[strProperties] || {},
        measurements = bd[_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], properties, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(properties, customUndefinedValue);
      var baseData = new PageViewPerformance(logger, name, url, void 0, properties, measurements, bd),
        data = new Data(PageViewPerformance[_DYN_DATA_TYPE], baseData);
      return _createEnvelope(logger, PageViewPerformance[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(PageViewPerformanceEnvelopeCreator, "PageViewPerformanceEnvelopeCreator");
    function TraceEnvelopeCreator(logger, telemetryItem, customUndefinedValue) {
      EnvelopeCreatorInit(logger, telemetryItem);
      var message = telemetryItem[strBaseData].message,
        severityLevel = telemetryItem[strBaseData].severityLevel,
        props = telemetryItem[strBaseData][strProperties] || {},
        measurements = telemetryItem[strBaseData][_DYN_MEASUREMENTS] || {};
      _extractPropsAndMeasurements(telemetryItem[_DYN_DATA], props, measurements), isNullOrUndefined(customUndefinedValue) || _convertPropsUndefinedToCustomDefinedValue(props, customUndefinedValue);
      var baseData = new Trace(logger, message, severityLevel, props, measurements),
        data = new Data(Trace[_DYN_DATA_TYPE], baseData);
      return _createEnvelope(logger, Trace[_DYN_ENVELOPE_TYPE], telemetryItem, data);
    }
    __name(TraceEnvelopeCreator, "TraceEnvelopeCreator");
    var BaseSendBuffer = function () {
        function BaseSendBuffer(logger, config) {
          var _buffer = [],
            _bufferFullMessageSent = !1;
          this[_DYN__GET] = function () {
            return _buffer;
          }, this._set = function (buffer) {
            return _buffer = buffer, _buffer;
          }, dynamicProto(BaseSendBuffer, this, function (_self) {
            _self[_DYN_ENQUEUE] = function (payload) {
              if (_self[_DYN_COUNT]() >= config[_DYN_EVENTS_LIMIT_IN_MEM]) {
                _bufferFullMessageSent || (_throwInternal(logger, 2, 105, "Maximum in-memory buffer size reached: " + _self[_DYN_COUNT](), !0), _bufferFullMessageSent = !0);
                return;
              }
              _buffer[_DYN_PUSH](payload);
            }, _self[_DYN_COUNT] = function () {
              return _buffer[_DYN_LENGTH];
            }, _self.size = function () {
              for (var size = _buffer[_DYN_LENGTH], lp = 0; lp < _buffer[_DYN_LENGTH]; lp++) size += _buffer[lp][_DYN_LENGTH];
              return config[_DYN_EMIT_LINE_DELIMITED_0] || (size += 2), size;
            }, _self[_DYN_CLEAR] = function () {
              _buffer = [], _bufferFullMessageSent = !1;
            }, _self.getItems = function () {
              return _buffer.slice(0);
            }, _self[_DYN_BATCH_PAYLOADS] = function (payload) {
              if (payload && payload[_DYN_LENGTH] > 0) {
                var batch = config[_DYN_EMIT_LINE_DELIMITED_0] ? payload.join(`
`) : "[" + payload.join(",") + "]";
                return batch;
              }
              return null;
            }, _self[_DYN_CREATE_NEW] = function (newLogger, newConfig, canUseSessionStorage) {
              var items = _buffer.slice(0);
              newLogger = newLogger || logger, newConfig = newConfig || {};
              var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
              return arrForEach(items, function (payload) {
                newBuffer[_DYN_ENQUEUE](payload);
              }), newBuffer;
            };
          });
        }
        return __name(BaseSendBuffer, "BaseSendBuffer"), BaseSendBuffer.__ieDyn = 1, BaseSendBuffer;
      }(),
      ArraySendBuffer = function (_super) {
        __extends(ArraySendBuffer, _super);
        function ArraySendBuffer(logger, config) {
          var _this = _super.call(this, logger, config) || this;
          return dynamicProto(ArraySendBuffer, _this, function (_self, _base) {
            _self[_DYN_MARK_AS_SENT] = function (payload) {
              _base[_DYN_CLEAR]();
            }, _self[_DYN_CLEAR_SENT] = function (payload) {};
          }), _this;
        }
        return __name(ArraySendBuffer, "ArraySendBuffer"), ArraySendBuffer.__ieDyn = 1, ArraySendBuffer;
      }(BaseSendBuffer),
      SessionStorageSendBuffer = function (_super) {
        __extends(SessionStorageSendBuffer, _super);
        function SessionStorageSendBuffer(logger, config) {
          var _this = _super.call(this, logger, config) || this,
            _bufferFullMessageSent = !1,
            _namePrefix = config == null ? void 0 : config.namePrefix,
            _a = config[_DYN_BUFFER_OVERRIDE] || {
              getItem: utlGetSessionStorage,
              setItem: utlSetSessionStorage
            },
            getItem = _a.getItem,
            setItem = _a.setItem;
          return dynamicProto(SessionStorageSendBuffer, _this, function (_self, _base) {
            var bufferItems = _getBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY]),
              notDeliveredItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]),
              buffer = _self._set(bufferItems[_DYN_CONCAT](notDeliveredItems));
            buffer[_DYN_LENGTH] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE] && (buffer[_DYN_LENGTH] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], []), _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], buffer), _self[_DYN_ENQUEUE] = function (payload) {
              if (_self[_DYN_COUNT]() >= SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]) {
                _bufferFullMessageSent || (_throwInternal(logger, 2, 67, "Maximum buffer size reached: " + _self[_DYN_COUNT](), !0), _bufferFullMessageSent = !0);
                return;
              }
              _base[_DYN_ENQUEUE](payload), _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET]());
            }, _self[_DYN_CLEAR] = function () {
              _base[_DYN_CLEAR](), _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET]()), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], []), _bufferFullMessageSent = !1;
            }, _self[_DYN_MARK_AS_SENT] = function (payload) {
              _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY], _self._set(_removePayloadsFromBuffer(payload, _self[_DYN__GET]())));
              var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]);
              sentElements instanceof Array && payload instanceof Array && (sentElements = sentElements[_DYN_CONCAT](payload), sentElements[_DYN_LENGTH] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE] && (_throwInternal(logger, 1, 67, "Sent buffer reached its maximum size: " + sentElements[_DYN_LENGTH], !0), sentElements[_DYN_LENGTH] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE]), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], sentElements));
            }, _self[_DYN_CLEAR_SENT] = function (payload) {
              var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]);
              sentElements = _removePayloadsFromBuffer(payload, sentElements), _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY], sentElements);
            }, _self[_DYN_CREATE_NEW] = function (newLogger, newConfig, canUseSessionStorage) {
              canUseSessionStorage = !!canUseSessionStorage;
              var unsentItems = _self[_DYN__GET]().slice(0),
                sentItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY]).slice(0);
              newLogger = newLogger || logger, newConfig = newConfig || {}, _self[_DYN_CLEAR]();
              var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);
              return arrForEach(unsentItems, function (payload) {
                newBuffer[_DYN_ENQUEUE](payload);
              }), canUseSessionStorage && newBuffer[_DYN_MARK_AS_SENT](sentItems), newBuffer;
            };
            function _removePayloadsFromBuffer(payloads, buffer) {
              var remaining = [];
              return arrForEach(buffer, function (value) {
                !isFunction(value) && arrIndexOf(payloads, value) === -1 && remaining[_DYN_PUSH](value);
              }), remaining;
            }
            __name(_removePayloadsFromBuffer, "_removePayloadsFromBuffer");
            function _getBuffer(key) {
              var prefixedKey = key;
              try {
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                var bufferJson = getItem(logger, prefixedKey);
                if (bufferJson) {
                  var buffer_1 = getJSON().parse(bufferJson);
                  if (isString(buffer_1) && (buffer_1 = getJSON().parse(buffer_1)), buffer_1 && isArray(buffer_1)) return buffer_1;
                }
              } catch (e) {
                _throwInternal(logger, 1, 42, " storage key: " + prefixedKey + ", " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              return [];
            }
            __name(_getBuffer, "_getBuffer");
            function _setBuffer(key, buffer) {
              var prefixedKey = key;
              try {
                prefixedKey = _namePrefix ? _namePrefix + "_" + prefixedKey : prefixedKey;
                var bufferJson = JSON[_DYN_STRINGIFY](buffer);
                setItem(logger, prefixedKey, bufferJson);
              } catch (e) {
                setItem(logger, prefixedKey, JSON[_DYN_STRINGIFY]([])), _throwInternal(logger, 2, 41, " storage key: " + prefixedKey + ", " + getExceptionName(e) + ". Buffer cleared", {
                  exception: dumpObj(e)
                });
              }
            }
            __name(_setBuffer, "_setBuffer");
          }), _this;
        }
        return __name(SessionStorageSendBuffer, "SessionStorageSendBuffer"), SessionStorageSendBuffer.BUFFER_KEY = "AI_buffer", SessionStorageSendBuffer.SENT_BUFFER_KEY = "AI_sentBuffer", SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2e3, SessionStorageSendBuffer;
      }(BaseSendBuffer),
      Serializer = function () {
        function Serializer(logger) {
          dynamicProto(Serializer, this, function (_self) {
            _self[_DYN_SERIALIZE] = function (input) {
              var output = _serializeObject(input, "root");
              try {
                return getJSON()[_DYN_STRINGIFY](output);
              } catch (e) {
                _throwInternal(logger, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
              }
            };
            function _serializeObject(source, name) {
              var circularReferenceCheck = "__aiCircularRefCheck",
                output = {};
              if (!source) return _throwInternal(logger, 1, 48, "cannot serialize object because it is null or undefined", {
                name: name
              }, !0), output;
              if (source[circularReferenceCheck]) return _throwInternal(logger, 2, 50, "Circular reference detected while serializing object", {
                name: name
              }, !0), output;
              if (!source.aiDataContract) {
                if (name === "measurements") output = _serializeStringMap(source, "number", name);else if (name === "properties") output = _serializeStringMap(source, "string", name);else if (name === "tags") output = _serializeStringMap(source, "string", name);else if (isArray(source)) output = _serializeArray(source, name);else {
                  _throwInternal(logger, 2, 49, "Attempting to serialize an object which does not implement ISerializable", {
                    name: name
                  }, !0);
                  try {
                    getJSON()[_DYN_STRINGIFY](source), output = source;
                  } catch (e) {
                    _throwInternal(logger, 1, 48, e && isFunction(e[_DYN_TO_STRING]) ? e[_DYN_TO_STRING]() : "Error serializing object", null, !0);
                  }
                }
                return output;
              }
              return source[circularReferenceCheck] = !0, objForEachKey(source.aiDataContract, function (field, contract) {
                var isRequired = isFunction(contract) ? contract() & 1 : contract & 1,
                  isHidden = isFunction(contract) ? contract() & 4 : contract & 4,
                  isArray = contract & 2,
                  isPresent = source[field] !== void 0,
                  isObj = isObject(source[field]) && source[field] !== null;
                if (isRequired && !isPresent && !isArray) _throwInternal(logger, 1, 24, "Missing required field specification. The field is required but not present on source", {
                  field: field,
                  name: name
                });else if (!isHidden) {
                  var value = void 0;
                  isObj ? isArray ? value = _serializeArray(source[field], field) : value = _serializeObject(source[field], field) : value = source[field], value !== void 0 && (output[field] = value);
                }
              }), delete source[circularReferenceCheck], output;
            }
            __name(_serializeObject, "_serializeObject");
            function _serializeArray(sources, name) {
              var output;
              if (sources) if (!isArray(sources)) _throwInternal(logger, 1, 54, `This field was specified as an array in the contract but the item is not an array.\r
`, {
                name: name
              }, !0);else {
                output = [];
                for (var i = 0; i < sources[_DYN_LENGTH]; i++) {
                  var source = sources[i],
                    item = _serializeObject(source, name + "[" + i + "]");
                  output[_DYN_PUSH](item);
                }
              }
              return output;
            }
            __name(_serializeArray, "_serializeArray");
            function _serializeStringMap(map, expectedType, name) {
              var output;
              return map && (output = {}, objForEachKey(map, function (field, value) {
                if (expectedType === "string") value === void 0 ? output[field] = "undefined" : value === null ? output[field] = "null" : value[_DYN_TO_STRING] ? output[field] = value[_DYN_TO_STRING]() : output[field] = "invalid field: toString() is not defined.";else if (expectedType === "number") {
                  if (value === void 0) output[field] = "undefined";else if (value === null) output[field] = "null";else {
                    var num = parseFloat(value);
                    output[field] = num;
                  }
                } else output[field] = "invalid field: " + name + " is of unknown type.", _throwInternal(logger, 1, output[field], null, !0);
              })), output;
            }
            __name(_serializeStringMap, "_serializeStringMap");
          });
        }
        return __name(Serializer, "Serializer"), Serializer.__ieDyn = 1, Serializer;
      }(),
      MIN_INPUT_LENGTH = 8,
      HashCodeScoreGenerator = function () {
        function HashCodeScoreGenerator() {}
        return __name(HashCodeScoreGenerator, "HashCodeScoreGenerator"), HashCodeScoreGenerator.prototype.getHashCodeScore = function (key) {
          var score = this.getHashCode(key) / HashCodeScoreGenerator.INT_MAX_VALUE;
          return score * 100;
        }, HashCodeScoreGenerator.prototype.getHashCode = function (input) {
          if (input === "") return 0;
          for (; input[_DYN_LENGTH] < MIN_INPUT_LENGTH;) input = input[_DYN_CONCAT](input);
          for (var hash = 5381, i = 0; i < input[_DYN_LENGTH]; ++i) hash = (hash << 5) + hash + input.charCodeAt(i), hash = hash & hash;
          return Math.abs(hash);
        }, HashCodeScoreGenerator.INT_MAX_VALUE = 2147483647, HashCodeScoreGenerator;
      }(),
      SamplingScoreGenerator = function () {
        function SamplingScoreGenerator() {
          var _self = this,
            hashCodeGenerator = new HashCodeScoreGenerator(),
            keys = new ContextTagKeys();
          _self[_DYN_GET_SAMPLING_SCORE] = function (item) {
            var score = 0;
            return item[_DYN_TAGS] && item[_DYN_TAGS][keys.userId] ? score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.userId]) : item.ext && item.ext.user && item.ext.user.id ? score = hashCodeGenerator[_DYN_GET_HASH_CODE_SCORE](item.ext.user.id) : item[_DYN_TAGS] && item[_DYN_TAGS][keys.operationId] ? score = hashCodeGenerator.getHashCodeScore(item[_DYN_TAGS][keys.operationId]) : item.ext && item.ext.telemetryTrace && item.ext.telemetryTrace[_DYN_TRACE_ID] ? score = hashCodeGenerator.getHashCodeScore(item.ext.telemetryTrace[_DYN_TRACE_ID]) : score = Math.random() * 100, score;
          };
        }
        return __name(SamplingScoreGenerator, "SamplingScoreGenerator"), SamplingScoreGenerator;
      }(),
      Sample = function () {
        function Sample(sampleRate, logger) {
          this.INT_MAX_VALUE = 2147483647;
          var _logger = logger || safeGetLogger(null);
          (sampleRate > 100 || sampleRate < 0) && (_logger.throwInternal(2, 58, "Sampling rate is out of range (0..100). Sampling will be disabled, you may be sending too much data which may affect your AI service level.", {
            samplingRate: sampleRate
          }, !0), sampleRate = 100), this[_DYN_SAMPLE_RATE] = sampleRate, this.samplingScoreGenerator = new SamplingScoreGenerator();
        }
        return __name(Sample, "Sample"), Sample.prototype.isSampledIn = function (envelope) {
          var samplingPercentage = this[_DYN_SAMPLE_RATE],
            isSampledIn = !1;
          return samplingPercentage == null || samplingPercentage >= 100 || envelope.baseType === Metric[_DYN_DATA_TYPE] ? !0 : (isSampledIn = this.samplingScoreGenerator[_DYN_GET_SAMPLING_SCORE](envelope) < samplingPercentage, isSampledIn);
        }, Sample;
      }(),
      _a,
      _b,
      UNDEFINED_VALUE = void 0,
      EMPTY_STR = "",
      FetchSyncRequestSizeLimitBytes = 65e3;
    function _getResponseText(xhr) {
      try {
        return xhr.responseText;
      } catch {}
      return null;
    }
    __name(_getResponseText, "_getResponseText");
    function isOverrideFn(httpXHROverride) {
      return httpXHROverride && httpXHROverride[_DYN_SEND_POST];
    }
    __name(isOverrideFn, "isOverrideFn");
    function _prependTransports(theTransports, newTransports) {
      return newTransports && (isNumber(newTransports) ? theTransports = [newTransports][_DYN_CONCAT](theTransports) : isArray(newTransports) && (theTransports = newTransports[_DYN_CONCAT](theTransports))), theTransports;
    }
    __name(_prependTransports, "_prependTransports");
    var defaultAppInsightsChannelConfig = objDeepFreeze((_a = {
      endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)
    }, _a[_DYN_EMIT_LINE_DELIMITED_0] = cfgDfBoolean(), _a[_DYN_MAX_BATCH_INTERVAL] = 15e3, _a[_DYN_MAX_BATCH_SIZE_IN_BY1] = 102400, _a.disableTelemetry = cfgDfBoolean(), _a[_DYN_ENABLE_SESSION_STORA5] = cfgDfBoolean(!0), _a.isRetryDisabled = cfgDfBoolean(), _a[_DYN_IS_BEACON_API_DISABL3] = cfgDfBoolean(!0), _a[_DYN_DISABLE_SEND_BEACON_7] = cfgDfBoolean(!0), _a.disableXhr = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_FET6] = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_BEA2] = cfgDfBoolean(), _a[_DYN_INSTRUMENTATION_KEY] = UNDEFINED_VALUE, _a.namePrefix = UNDEFINED_VALUE, _a.samplingPercentage = cfgDfValidate(_chkSampling, 100), _a[_DYN_CUSTOM_HEADERS] = UNDEFINED_VALUE, _a[_DYN_CONVERT_UNDEFINED] = UNDEFINED_VALUE, _a[_DYN_EVENTS_LIMIT_IN_MEM] = 1e4, _a[_DYN_BUFFER_OVERRIDE] = !1, _a.httpXHROverride = {
      isVal: isOverrideFn,
      v: UNDEFINED_VALUE
    }, _a[_DYN_ALWAYS_USE_XHR_OVERR4] = cfgDfBoolean(), _a.transports = UNDEFINED_VALUE, _a));
    function _chkSampling(value) {
      return !isNaN(value) && value > 0 && value <= 100;
    }
    __name(_chkSampling, "_chkSampling");
    var EnvelopeTypeCreator = (_b = {}, _b[Event.dataType] = EventEnvelopeCreator, _b[Trace.dataType] = TraceEnvelopeCreator, _b[PageView.dataType] = PageViewEnvelopeCreator, _b[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _b[Exception.dataType] = ExceptionEnvelopeCreator, _b[Metric.dataType] = MetricEnvelopeCreator, _b[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _b),
      Sender = function (_super) {
        __extends(Sender, _super);
        function Sender() {
          var _this = _super.call(this) || this;
          _this.priority = 1001, _this.identifier = BreezeChannelIdentifier;
          var _consecutiveErrors,
            _retryAt,
            _paused,
            _timeoutHandle,
            _serializer,
            _stamp_specific_redirects,
            _headers,
            _syncFetchPayload = 0,
            _syncUnloadSender,
            _offlineListener,
            _evtNamespace,
            _endpointUrl,
            _orgEndpointUrl,
            _maxBatchSizeInBytes,
            _beaconSupported,
            _beaconOnUnloadSupported,
            _beaconNormalSupported,
            _customHeaders,
            _disableTelemetry,
            _instrumentationKey,
            _convertUndefined,
            _isRetryDisabled,
            _maxBatchInterval,
            _sessionStorageUsed,
            _bufferOverrideUsed,
            _namePrefix,
            _enableSendPromise,
            _alwaysUseCustomSend,
            _disableXhr,
            _fetchKeepAlive,
            _xhrSend,
            _fallbackSend,
            _disableBeaconSplit;
          return dynamicProto(Sender, _this, function (_self, _base) {
            _initDefaults(), _self.pause = function () {
              _clearScheduledTimer(), _paused = !0;
            }, _self.resume = function () {
              _paused && (_paused = !1, _retryAt = null, _checkMaxSize(), _setupTimer());
            }, _self.flush = function (isAsync, callBack, sendReason) {
              if (isAsync === void 0 && (isAsync = !0), !_paused) {
                _clearScheduledTimer();
                try {
                  return _self[_DYN_TRIGGER_SEND](isAsync, null, sendReason || 1);
                } catch (e) {
                  _throwInternal(_self[_DYN_DIAG_LOG](), 1, 22, "flush failed, telemetry will not be collected: " + getExceptionName(e), {
                    exception: dumpObj(e)
                  });
                }
              }
            }, _self.onunloadFlush = function () {
              if (!_paused) if (_beaconSupported || _alwaysUseCustomSend) try {
                return _self[_DYN_TRIGGER_SEND](!0, _doUnloadSend, 2);
              } catch (e) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 1, 20, "failed to flush with beacon sender on page unload, telemetry will not be collected: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              } else _self.flush(!1);
            }, _self.addHeader = function (name, value) {
              _headers[name] = value;
            }, _self.initialize = function (config, core, extensions, pluginChain) {
              _self.isInitialized() && _throwInternal(_self[_DYN_DIAG_LOG](), 1, 28, "Sender is already initialized"), _base.initialize(config, core, extensions, pluginChain);
              var identifier = _self.identifier;
              _serializer = new Serializer(core.logger), _consecutiveErrors = 0, _retryAt = null, _self[_DYN__SENDER] = null, _stamp_specific_redirects = 0;
              var diagLog = _self[_DYN_DIAG_LOG]();
              _evtNamespace = mergeEvtNamespace(createUniqueNamespace("Sender"), core.evtNamespace && core.evtNamespace()), _offlineListener = createOfflineListener(_evtNamespace), _self._addHook(onConfigChange(config, function (details) {
                var config = details.cfg;
                config.storagePrefix && utlSetStoragePrefix(config.storagePrefix);
                var ctx = createProcessTelemetryContext(null, config, core),
                  senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);
                objDefine(_self, "_senderConfig", {
                  g: function () {
                    return senderConfig;
                  }
                }), _orgEndpointUrl !== senderConfig.endpointUrl && (_endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl), _customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS] && arrForEach(_customHeaders, function (customHeader) {
                  delete _headers[customHeader.header];
                }), _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1], _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === !1 || senderConfig[_DYN_IS_BEACON_API_DISABL3] === !1) && isBeaconsSupported(), _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2] === !1 && isBeaconsSupported(), _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3] === !1 && isBeaconsSupported(), _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4], _disableXhr = !!senderConfig.disableXhr;
                var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE],
                  canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5] && (!!bufferOverride || utlCanUseSessionStorage()),
                  namePrefix = senderConfig.namePrefix,
                  shouldUpdate = canUseSessionStorage !== _sessionStorageUsed || canUseSessionStorage && _namePrefix !== namePrefix || canUseSessionStorage && _bufferOverrideUsed !== bufferOverride;
                if (_self[_DYN__BUFFER]) {
                  if (shouldUpdate) try {
                    _self._buffer = _self._buffer[_DYN_CREATE_NEW](diagLog, senderConfig, canUseSessionStorage);
                  } catch (e) {
                    _throwInternal(_self[_DYN_DIAG_LOG](), 1, 12, "failed to transfer telemetry to different buffer storage, telemetry will be lost: " + getExceptionName(e), {
                      exception: dumpObj(e)
                    });
                  }
                  _checkMaxSize();
                } else _self[_DYN__BUFFER] = canUseSessionStorage ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);
                _namePrefix = namePrefix, _sessionStorageUsed = canUseSessionStorage, _bufferOverrideUsed = bufferOverride, _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6] && isFetchSupported(!0), _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7], _self._sample = new Sample(senderConfig.samplingPercentage, diagLog), _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY], _validateInstrumentationKey(_instrumentationKey, config) || _throwInternal(diagLog, 1, 100, "Invalid Instrumentation key " + _instrumentationKey), _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS], !isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH] > 0 ? arrForEach(_customHeaders, function (customHeader) {
                  _this.addHeader(customHeader.header, customHeader.value);
                }) : _customHeaders = null, _enableSendPromise = senderConfig.enableSendPromise;
                var customInterface = senderConfig.httpXHROverride,
                  httpInterface = null,
                  syncInterface = null,
                  theTransports = _prependTransports([3, 1, 2], senderConfig.transports);
                httpInterface = _getSenderInterface(theTransports, !1);
                var xhrInterface = {
                  sendPOST: _xhrSender
                };
                _xhrSend = __name(function (payload, isAsync) {
                  return _doSend(xhrInterface, payload, isAsync);
                }, "_xhrSend"), _fallbackSend = __name(function (payload, isAsync) {
                  return _doSend(xhrInterface, payload, isAsync, !1);
                }, "_fallbackSend"), httpInterface = _alwaysUseCustomSend ? customInterface : httpInterface || customInterface || xhrInterface, _self[_DYN__SENDER] = function (payload, isAsync) {
                  return _doSend(httpInterface, payload, isAsync);
                }, _fetchKeepAlive && (_syncUnloadSender = _fetchKeepAliveSender);
                var syncTransports = _prependTransports([3, 1], senderConfig[_DYN_UNLOAD_TRANSPORTS]);
                _fetchKeepAlive || (syncTransports = syncTransports.filter(function (transport) {
                  return transport !== 2;
                })), syncInterface = _getSenderInterface(syncTransports, !0), syncInterface = _alwaysUseCustomSend ? customInterface : syncInterface || customInterface, (_alwaysUseCustomSend || senderConfig[_DYN_UNLOAD_TRANSPORTS] || !_syncUnloadSender) && syncInterface && (_syncUnloadSender = __name(function (payload, isAsync) {
                  return _doSend(syncInterface, payload, isAsync);
                }, "_syncUnloadSender")), _syncUnloadSender || (_syncUnloadSender = _xhrSend), _disableTelemetry = senderConfig.disableTelemetry, _convertUndefined = senderConfig[_DYN_CONVERT_UNDEFINED] || UNDEFINED_VALUE, _isRetryDisabled = senderConfig.isRetryDisabled, _maxBatchInterval = senderConfig[_DYN_MAX_BATCH_INTERVAL];
              }));
            }, _self.processTelemetry = function (telemetryItem, itemCtx) {
              itemCtx = _self._getTelCtx(itemCtx);
              var diagLogger = itemCtx[_DYN_DIAG_LOG]();
              try {
                var isValidate = _validate(telemetryItem, diagLogger);
                if (!isValidate) return;
                var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);
                if (!aiEnvelope) return;
                var payload = _serializer[_DYN_SERIALIZE](aiEnvelope),
                  buffer = _self[_DYN__BUFFER];
                _checkMaxSize(payload), buffer[_DYN_ENQUEUE](payload), _setupTimer();
              } catch (e) {
                _throwInternal(diagLogger, 2, 12, "Failed adding telemetry to the sender's buffer, some telemetry will be lost: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              _self.processNext(telemetryItem, itemCtx);
            }, _self.isCompletelyIdle = function () {
              return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT]() === 0;
            }, _self[_DYN__XHR_READY_STATE_CHA8] = function (xhr, payload, countOfItemsInPayload) {
              xhr.readyState === 4 && _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, _formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);
            }, _self[_DYN_TRIGGER_SEND] = function (async, forcedSender, sendReason) {
              async === void 0 && (async = !0);
              var result;
              if (!_paused) try {
                var buffer = _self[_DYN__BUFFER];
                if (_disableTelemetry) buffer[_DYN_CLEAR]();else if (buffer[_DYN_COUNT]() > 0) {
                  var payload = buffer.getItems();
                  _notifySendRequest(sendReason || 0, async), forcedSender ? result = forcedSender.call(_self, payload, async) : result = _self[_DYN__SENDER](payload, async);
                }
                _clearScheduledTimer();
              } catch (e) {
                var ieVer = getIEVersion();
                (!ieVer || ieVer > 9) && _throwInternal(_self[_DYN_DIAG_LOG](), 1, 40, "Telemetry transmission failed, some telemetry will be lost: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
              return result;
            }, _self.getOfflineSupport = function () {
              var _a;
              return _a = {
                getUrl: function () {
                  return _endpointUrl;
                },
                createPayload: _createPayload
              }, _a[_DYN_SERIALIZE] = _serialize, _a.batch = _batch, _a.shouldProcess = function (evt) {
                return !!_validate(evt);
              }, _a;
            }, _self._doTeardown = function (unloadCtx, unloadState) {
              _self.onunloadFlush(), runTargetUnload(_offlineListener, !1), _initDefaults();
            }, _self[_DYN__ON_ERROR] = function (payload, message, event) {
              _throwInternal(_self[_DYN_DIAG_LOG](), 2, 26, "Failed to send telemetry.", {
                message: message
              }), _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
            }, _self[_DYN__ON_PARTIAL_SUCCESS] = function (payload, results) {
              for (var failed = [], retry = [], errors = results.errors.reverse(), _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
                var error = errors_1[_i],
                  extracted = payload.splice(error.index, 1)[0];
                _isRetriable(error.statusCode) ? retry[_DYN_PUSH](extracted) : failed[_DYN_PUSH](extracted);
              }
              payload[_DYN_LENGTH] > 0 && _self[_DYN__ON_SUCCESS](payload, results[_DYN_ITEMS_ACCEPTED]), failed[_DYN_LENGTH] > 0 && _self[_DYN__ON_ERROR](failed, _formatErrorMessageXhr(null, ["partial success", results[_DYN_ITEMS_ACCEPTED], "of", results.itemsReceived].join(" "))), retry[_DYN_LENGTH] > 0 && (_resendPayload(retry), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, "Partial success. Delivered: " + payload[_DYN_LENGTH] + ", Failed: " + failed[_DYN_LENGTH] + ". Will retry to send " + retry[_DYN_LENGTH] + " our of " + results[_DYN_ITEMS_RECEIVED] + " items"));
            }, _self[_DYN__ON_SUCCESS] = function (payload, countOfItemsInPayload) {
              _self._buffer && _self._buffer[_DYN_CLEAR_SENT](payload);
            }, _self._xdrOnLoad = function (xdr, payload) {
              var responseText = _getResponseText(xdr);
              if (xdr && (responseText + "" == "200" || responseText === "")) _consecutiveErrors = 0, _self[_DYN__ON_SUCCESS](payload, 0);else {
                var results = _parseResponse(responseText);
                results && results.itemsReceived && results.itemsReceived > results[_DYN_ITEMS_ACCEPTED] && !_isRetryDisabled ? _self[_DYN__ON_PARTIAL_SUCCESS](payload, results) : _self[_DYN__ON_ERROR](payload, _formatErrorMessageXdr(xdr));
              }
            };
            function _validate(telemetryItem, diagLogger) {
              if (_disableTelemetry) return !1;
              if (!telemetryItem) return diagLogger && _throwInternal(diagLogger, 1, 7, "Cannot send empty telemetry"), !1;
              if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE]) return diagLogger && _throwInternal(diagLogger, 1, 70, "Cannot send telemetry without baseData and baseType"), !1;
              if (telemetryItem[_DYN_BASE_TYPE] || (telemetryItem[_DYN_BASE_TYPE] = "EventData"), !_self[_DYN__SENDER]) return diagLogger && _throwInternal(diagLogger, 1, 28, "Sender was not initialized"), !1;
              if (_isSampledIn(telemetryItem)) telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE];else return diagLogger && _throwInternal(diagLogger, 2, 33, "Telemetry item was sampled out and not sent", {
                SampleRate: _self._sample[_DYN_SAMPLE_RATE]
              }), !1;
              return !0;
            }
            __name(_validate, "_validate");
            function _getEnvelope(telemetryItem, diagLogger) {
              var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey,
                aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);
              if (!aiEnvelope) {
                _throwInternal(diagLogger, 1, 47, "Unable to create an AppInsights envelope");
                return;
              }
              var doNotSendItem = !1;
              if (telemetryItem[_DYN_TAGS] && telemetryItem[_DYN_TAGS][ProcessLegacy] && (arrForEach(telemetryItem[_DYN_TAGS][ProcessLegacy], function (callBack) {
                try {
                  callBack && callBack(aiEnvelope) === !1 && (doNotSendItem = !0, _warnToConsole(diagLogger, "Telemetry processor check returns false"));
                } catch (e) {
                  _throwInternal(diagLogger, 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), {
                    exception: dumpObj(e)
                  }, !0);
                }
              }), delete telemetryItem[_DYN_TAGS][ProcessLegacy]), !doNotSendItem) return aiEnvelope;
            }
            __name(_getEnvelope, "_getEnvelope");
            function _serialize(item) {
              var rlt = EMPTY_STR,
                diagLogger = _self[_DYN_DIAG_LOG]();
              try {
                var valid = _validate(item, diagLogger),
                  envelope = null;
                valid && (envelope = _getEnvelope(item, diagLogger)), envelope && (rlt = _serializer[_DYN_SERIALIZE](envelope));
              } catch {}
              return rlt;
            }
            __name(_serialize, "_serialize");
            function _batch(arr) {
              var rlt = EMPTY_STR;
              return arr && arr[_DYN_LENGTH] && (rlt = "[" + arr.join(",") + "]"), rlt;
            }
            __name(_batch, "_batch");
            function _createPayload(data) {
              var _a,
                headers = _headers;
              return isInternalApplicationInsightsEndpoint(_endpointUrl) && (headers[RequestHeaders[6]] = RequestHeaders[7]), _a = {
                urlString: _endpointUrl
              }, _a[_DYN_DATA] = data, _a.headers = headers, _a;
            }
            __name(_createPayload, "_createPayload");
            function _isSampledIn(envelope) {
              return _self._sample.isSampledIn(envelope);
            }
            __name(_isSampledIn, "_isSampledIn");
            function _getSenderInterface(transports, syncSupport) {
              for (var _a, transportType = null, sendPostFunc = null, lp = 0; sendPostFunc == null && lp < transports[_DYN_LENGTH];) transportType = transports[lp], !_disableXhr && transportType === 1 ? useXDomainRequest() ? sendPostFunc = _xdrSender : isXhrSupported() && (sendPostFunc = _xhrSender) : transportType === 2 && isFetchSupported(syncSupport) ? sendPostFunc = _fetchSender : transportType === 3 && (syncSupport ? _beaconOnUnloadSupported : _beaconNormalSupported) && (sendPostFunc = _beaconSender), lp++;
              return sendPostFunc ? (_a = {}, _a[_DYN_SEND_POST] = sendPostFunc, _a) : null;
            }
            __name(_getSenderInterface, "_getSenderInterface");
            function _getOnComplete(payload, status, headers, response) {
              status === 200 && payload ? _self._onSuccess(payload, payload[_DYN_LENGTH]) : response && _self[_DYN__ON_ERROR](payload, response);
            }
            __name(_getOnComplete, "_getOnComplete");
            function _doSend(sendInterface, payload, isAsync, markAsSent) {
              markAsSent === void 0 && (markAsSent = !0);
              var onComplete = __name(function (status, headers, response) {
                  return _getOnComplete(payload, status, headers, response);
                }, "onComplete"),
                payloadData = _getPayload(payload),
                sendPostFunc = sendInterface && sendInterface[_DYN_SEND_POST];
              return sendPostFunc && payloadData ? (markAsSent && _self._buffer[_DYN_MARK_AS_SENT](payload), sendPostFunc(payloadData, onComplete, !isAsync)) : null;
            }
            __name(_doSend, "_doSend");
            function _getPayload(payload) {
              var _a;
              if (isArray(payload) && payload[_DYN_LENGTH] > 0) {
                var batch = _self._buffer[_DYN_BATCH_PAYLOADS](payload),
                  payloadData = (_a = {}, _a[_DYN_DATA] = batch, _a.urlString = _endpointUrl, _a.headers = _headers, _a.disableXhrSync = _disableXhr, _a.disableFetchKeepAlive = !_fetchKeepAlive, _a[_DYN_ORI_PAYLOAD] = payload, _a);
                return payloadData;
              }
              return null;
            }
            __name(_getPayload, "_getPayload");
            function _fetchSender(payload, oncomplete, sync) {
              return _doFetchSender(payload, oncomplete, !1);
            }
            __name(_fetchSender, "_fetchSender");
            function _checkMaxSize(incomingPayload) {
              var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH] : 0;
              return _self[_DYN__BUFFER].size() + incomingSize > _maxBatchSizeInBytes ? ((!_offlineListener || _offlineListener.isOnline()) && _self[_DYN_TRIGGER_SEND](!0, null, 10), !0) : !1;
            }
            __name(_checkMaxSize, "_checkMaxSize");
            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {
              var response = null;
              if (_self._appId || (response = _parseResponse(res), response && response.appId && (_self._appId = response.appId)), (status < 200 || status >= 300) && status !== 0) {
                if ((status === 301 || status === 307 || status === 308) && !_checkAndUpdateEndPointUrl(responseUrl)) {
                  _self[_DYN__ON_ERROR](payload, errorMessage);
                  return;
                }
                !_isRetryDisabled && _isRetriable(status) ? (_resendPayload(payload), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Response code " + status + ". Will retry to send " + payload[_DYN_LENGTH] + " items.")) : _self[_DYN__ON_ERROR](payload, errorMessage);
              } else if (_offlineListener && !_offlineListener.isOnline()) {
                if (!_isRetryDisabled) {
                  var offlineBackOffMultiplier = 10;
                  _resendPayload(payload, offlineBackOffMultiplier), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Offline - Response Code: ".concat(status, ". Offline status: ").concat(!_offlineListener.isOnline(), ". Will retry to send ").concat(payload.length, " items."));
                }
              } else _checkAndUpdateEndPointUrl(responseUrl), status === 206 ? (response || (response = _parseResponse(res)), response && !_isRetryDisabled ? _self[_DYN__ON_PARTIAL_SUCCESS](payload, response) : _self[_DYN__ON_ERROR](payload, errorMessage)) : (_consecutiveErrors = 0, _self[_DYN__ON_SUCCESS](payload, countOfItemsInPayload));
            }
            __name(_checkResponsStatus, "_checkResponsStatus");
            function _checkAndUpdateEndPointUrl(responseUrl) {
              return _stamp_specific_redirects >= 10 ? !1 : !isNullOrUndefined(responseUrl) && responseUrl !== "" && responseUrl !== _endpointUrl ? (_endpointUrl = responseUrl, ++_stamp_specific_redirects, !0) : !1;
            }
            __name(_checkAndUpdateEndPointUrl, "_checkAndUpdateEndPointUrl");
            function _doOnComplete(oncomplete, status, headers, response) {
              try {
                oncomplete(status, headers, response);
              } catch {}
            }
            __name(_doOnComplete, "_doOnComplete");
            function _doUnloadSend(payload, isAsync) {
              if (_syncUnloadSender) _syncUnloadSender(payload, !1);else {
                var payloadData = _getPayload(payload);
                _self._buffer[_DYN_MARK_AS_SENT](payload), _beaconSender(payloadData);
              }
            }
            __name(_doUnloadSend, "_doUnloadSend");
            function _doBeaconSend(payload, oncomplete) {
              var nav = getNavigator(),
                url = _endpointUrl,
                buffer = _self[_DYN__BUFFER],
                batch = buffer[_DYN_BATCH_PAYLOADS](payload),
                plainTextBatch = new Blob([batch], {
                  type: "text/plain;charset=UTF-8"
                }),
                queued = nav.sendBeacon(url, plainTextBatch);
              return queued && _self._onSuccess(payload, payload[_DYN_LENGTH]), queued;
            }
            __name(_doBeaconSend, "_doBeaconSend");
            function _beaconSender(payload, oncomplete, sync) {
              var internalPayload = payload,
                data = internalPayload && internalPayload[_DYN_ORI_PAYLOAD];
              if (isArray(data) && data[_DYN_LENGTH] > 0 && !_doBeaconSend(data)) if (_disableBeaconSplit) _fallbackSend && _fallbackSend(data, !0), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender.");else {
                for (var droppedPayload = [], lp = 0; lp < data[_DYN_LENGTH]; lp++) {
                  var thePayload = data[lp];
                  _doBeaconSend([thePayload]) || droppedPayload[_DYN_PUSH](thePayload);
                }
                droppedPayload[_DYN_LENGTH] > 0 && (_fallbackSend && _fallbackSend(droppedPayload, !0), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with normal sender."));
              }
            }
            __name(_beaconSender, "_beaconSender");
            function _xhrSender(payload, oncomplete, sync) {
              var internalPayload = payload,
                thePromise,
                resolveFunc,
                rejectFunc,
                xhr = new XMLHttpRequest(),
                endPointUrl = _endpointUrl;
              try {
                xhr[DisabledPropertyName] = !0;
              } catch {}
              return xhr.open("POST", endPointUrl, !sync), xhr[_DYN_SET_REQUEST_HEADER]("Content-type", "application/json"), isInternalApplicationInsightsEndpoint(endPointUrl) && xhr[_DYN_SET_REQUEST_HEADER](RequestHeaders[6], RequestHeaders[7]), arrForEach(objKeys(_headers), function (headerName) {
                xhr[_DYN_SET_REQUEST_HEADER](headerName, _headers[headerName]);
              }), xhr.onreadystatechange = function () {
                var oriPayload = internalPayload[_DYN_ORI_PAYLOAD];
                _self._xhrReadyStateChange(xhr, oriPayload, oriPayload[_DYN_LENGTH]), xhr.readyState === 4 && resolveFunc && resolveFunc(!0);
              }, xhr.onerror = function (event) {
                _doOnComplete(oncomplete, 400, {}, _formatErrorMessageXhr(xhr)), rejectFunc && rejectFunc(event);
              }, !sync && _enableSendPromise && (thePromise = createPromise(function (resolve, reject) {
                resolveFunc = resolve, rejectFunc = reject;
              })), xhr.send(payload[_DYN_DATA]), thePromise;
            }
            __name(_xhrSender, "_xhrSender");
            function _fetchKeepAliveSender(payload, isAsync) {
              var onComplete = __name(function (status, headers, response) {
                return _getOnComplete(payload, status, headers, response);
              }, "onComplete");
              if (isArray(payload)) {
                for (var payloadSize = payload[_DYN_LENGTH], lp = 0; lp < payload[_DYN_LENGTH]; lp++) payloadSize += payload[lp][_DYN_LENGTH];
                var payloadData = _getPayload(payload);
                _self._buffer[_DYN_MARK_AS_SENT](payload), _syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes ? _doFetchSender(payloadData, onComplete, !0) : isBeaconsSupported() ? _beaconSender(payloadData) : (_fallbackSend && _fallbackSend(payload, !0), _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Failed to send telemetry with Beacon API, retried with xhrSender."));
              }
            }
            __name(_fetchKeepAliveSender, "_fetchKeepAliveSender");
            function _doFetchSender(payload, oncomplete, sync) {
              var _a,
                endPointUrl = _endpointUrl,
                internalPayload = payload,
                batch = internalPayload[_DYN_DATA],
                plainTextBatch = new Blob([batch], {
                  type: "application/json"
                }),
                thePromise,
                resolveFunc,
                rejectFunc,
                requestHeaders = new Headers(),
                batchLength = batch[_DYN_LENGTH],
                ignoreResponse = !1,
                responseHandled = !1;
              isInternalApplicationInsightsEndpoint(endPointUrl) && requestHeaders.append(RequestHeaders[6], RequestHeaders[7]), arrForEach(objKeys(_headers), function (headerName) {
                requestHeaders.append(headerName, _headers[headerName]);
              });
              var init = (_a = {
                method: "POST",
                headers: requestHeaders,
                body: plainTextBatch
              }, _a[DisabledPropertyName] = !0, _a);
              sync && (init.keepalive = !0, ignoreResponse = !0, _syncFetchPayload += batchLength);
              var request = new Request(endPointUrl, init);
              try {
                request[DisabledPropertyName] = !0;
              } catch {}
              !sync && _enableSendPromise && (thePromise = createPromise(function (resolve, reject) {
                resolveFunc = resolve, rejectFunc = reject;
              }));
              try {
                doAwaitResponse(fetch(request), function (result) {
                  if (sync && (_syncFetchPayload -= batchLength, batchLength = 0), !responseHandled) if (responseHandled = !0, result.rejected) _doOnComplete(oncomplete, 400, {}, result.reason && result.reason.message), rejectFunc && rejectFunc(result.reason);else {
                    var response_1 = result.value;
                    response_1.ok ? doAwaitResponse(response_1.text(), function (resp) {
                      var oriPayload = internalPayload[_DYN_ORI_PAYLOAD];
                      _checkResponsStatus(response_1.status, oriPayload, response_1.url, oriPayload[_DYN_LENGTH], response_1.statusText, resp.value || ""), resolveFunc && resolveFunc(!0);
                    }) : (_doOnComplete(oncomplete, 400, {}, response_1.statusText), resolveFunc && resolveFunc(!1));
                  }
                });
              } catch (e) {
                responseHandled || (_doOnComplete(oncomplete, 400, {}, dumpObj(e)), rejectFunc && rejectFunc(e));
              }
              return ignoreResponse && !responseHandled && (responseHandled = !0, _doOnComplete(oncomplete, 200, {}), resolveFunc && resolveFunc(!0)), thePromise;
            }
            __name(_doFetchSender, "_doFetchSender");
            function _parseResponse(response) {
              try {
                if (response && response !== "") {
                  var result = getJSON().parse(response);
                  if (result && result.itemsReceived && result.itemsReceived >= result[_DYN_ITEMS_ACCEPTED] && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH]) return result;
                }
              } catch (e) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 1, 43, "Cannot parse the response. " + getExceptionName(e), {
                  response: response
                });
              }
              return null;
            }
            __name(_parseResponse, "_parseResponse");
            function _resendPayload(payload, linearFactor) {
              if (linearFactor === void 0 && (linearFactor = 1), !(!payload || payload[_DYN_LENGTH] === 0)) {
                var buffer = _self[_DYN__BUFFER];
                buffer[_DYN_CLEAR_SENT](payload), _consecutiveErrors++;
                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {
                  var item = payload_1[_i];
                  buffer[_DYN_ENQUEUE](item);
                }
                _setRetryTime(linearFactor), _setupTimer();
              }
            }
            __name(_resendPayload, "_resendPayload");
            function _setRetryTime(linearFactor) {
              var SlotDelayInSeconds = 10,
                delayInSeconds;
              if (_consecutiveErrors <= 1) delayInSeconds = SlotDelayInSeconds;else {
                var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2,
                  backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;
                backOffDelay = linearFactor * backOffDelay, delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);
              }
              var retryAfterTimeSpan = dateNow() + delayInSeconds * 1e3;
              _retryAt = retryAfterTimeSpan;
            }
            __name(_setRetryTime, "_setRetryTime");
            function _setupTimer() {
              if (!_timeoutHandle && !_paused) {
                var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0,
                  timerValue = Math.max(_maxBatchInterval, retryInterval);
                _timeoutHandle = scheduleTimeout(function () {
                  _timeoutHandle = null, _self[_DYN_TRIGGER_SEND](!0, null, 1);
                }, timerValue);
              }
            }
            __name(_setupTimer, "_setupTimer");
            function _clearScheduledTimer() {
              _timeoutHandle && _timeoutHandle.cancel(), _timeoutHandle = null, _retryAt = null;
            }
            __name(_clearScheduledTimer, "_clearScheduledTimer");
            function _isRetriable(statusCode) {
              return statusCode === 401 || statusCode === 403 || statusCode === 408 || statusCode === 429 || statusCode === 500 || statusCode === 502 || statusCode === 503 || statusCode === 504;
            }
            __name(_isRetriable, "_isRetriable");
            function _formatErrorMessageXhr(xhr, message) {
              return xhr ? "XMLHttpRequest,Status:" + xhr.status + ",Response:" + _getResponseText(xhr) || xhr.response || "" : message;
            }
            __name(_formatErrorMessageXhr, "_formatErrorMessageXhr");
            function _xdrSender(payload, oncomplete, sync) {
              var internalPayload = payload,
                _window = getWindow(),
                xdr = new XDomainRequest(),
                data = internalPayload[_DYN_DATA];
              xdr.onload = function () {
                var oriPayload = internalPayload[_DYN_ORI_PAYLOAD];
                _self._xdrOnLoad(xdr, oriPayload);
              }, xdr.onerror = function () {
                _doOnComplete(oncomplete, 400, {}, _formatErrorMessageXdr(xdr));
              };
              var hostingProtocol = _window && _window.location && _window.location.protocol || "";
              if (_endpointUrl.lastIndexOf(hostingProtocol, 0) !== 0) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 2, 40, ". Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol."), _self._buffer[_DYN_CLEAR]();
                return;
              }
              var endpointUrl = _endpointUrl.replace(/^(https?:)/, "");
              xdr.open("POST", endpointUrl), xdr.send(data);
            }
            __name(_xdrSender, "_xdrSender");
            function _formatErrorMessageXdr(xdr, message) {
              return xdr ? "XDomainRequest,Response:" + _getResponseText(xdr) || "" : message;
            }
            __name(_formatErrorMessageXdr, "_formatErrorMessageXdr");
            function _getNotifyMgr() {
              var func = "getNotifyMgr";
              return _self.core[func] ? _self.core[func]() : _self.core._notificationManager;
            }
            __name(_getNotifyMgr, "_getNotifyMgr");
            function _notifySendRequest(sendRequest, isAsync) {
              var manager = _getNotifyMgr();
              if (manager && manager[_DYN_EVENTS_SEND_REQUEST]) try {
                manager[_DYN_EVENTS_SEND_REQUEST](sendRequest, isAsync);
              } catch (e) {
                _throwInternal(_self[_DYN_DIAG_LOG](), 1, 74, "send request notification failed: " + getExceptionName(e), {
                  exception: dumpObj(e)
                });
              }
            }
            __name(_notifySendRequest, "_notifySendRequest");
            function _validateInstrumentationKey(instrumentationKey, config) {
              var disableValidation = config.disableInstrumentationKeyValidation,
                disableIKeyValidationFlag = isNullOrUndefined(disableValidation) ? !1 : disableValidation;
              if (disableIKeyValidationFlag) return !0;
              var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
                regexp = new RegExp(UUID_Regex);
              return regexp.test(instrumentationKey);
            }
            __name(_validateInstrumentationKey, "_validateInstrumentationKey");
            function _initDefaults() {
              _self[_DYN__SENDER] = null, _self[_DYN__BUFFER] = null, _self._appId = null, _self._sample = null, _headers = {}, _offlineListener = null, _consecutiveErrors = 0, _retryAt = null, _paused = !1, _timeoutHandle = null, _serializer = null, _stamp_specific_redirects = 0, _syncFetchPayload = 0, _syncUnloadSender = null, _evtNamespace = null, _endpointUrl = null, _orgEndpointUrl = null, _maxBatchSizeInBytes = 0, _beaconSupported = !1, _customHeaders = null, _disableTelemetry = !1, _instrumentationKey = null, _convertUndefined = UNDEFINED_VALUE, _isRetryDisabled = !1, _sessionStorageUsed = null, _namePrefix = UNDEFINED_VALUE, _disableXhr = !1, _fetchKeepAlive = !1, _disableBeaconSplit = !1, _xhrSend = null, _fallbackSend = null, objDefine(_self, "_senderConfig", {
                g: function () {
                  return objExtend({}, defaultAppInsightsChannelConfig);
                }
              });
            }
            __name(_initDefaults, "_initDefaults");
          }), _this;
        }
        return __name(Sender, "Sender"), Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {
          var envelope;
          iKey !== orig.iKey && !isNullOrUndefined(iKey) ? envelope = __assign(__assign({}, orig), {
            iKey: iKey
          }) : envelope = orig;
          var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;
          return creator(logger, envelope, convertUndefined);
        }, Sender;
      }(BaseTelemetryPlugin),
      _DYN_INSTRUMENTATION_KEY = "instrumentationKey",
      _DYN_CONNECTION_STRING = "connectionString",
      defaultConfigValues = {
        diagnosticLogInterval: cfgDfValidate(_chkDiagLevel, 1e4)
      };
    function _chkDiagLevel(value) {
      return value && value > 0;
    }
    __name(_chkDiagLevel, "_chkDiagLevel");
    var ApplicationInsights = function () {
      function ApplicationInsights(config) {
        var core = new AppInsightsCore(),
          _config;
        (isNullOrUndefined(config) || isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY]) && isNullOrUndefined(config[_DYN_CONNECTION_STRING])) && throwError("Invalid input configuration"), dynamicProto(ApplicationInsights, this, function (_self) {
          objDefine(_self, "config", {
            g: function () {
              return _config;
            }
          }), _initialize(), _self.initialize = _initialize, _self.track = _track, proxyFunctions(_self, core, ["flush", "pollInternalLogs", "stopPollingInternalLogs", "unload", "getPlugin", "addPlugin", "evtNamespace", "addUnloadCb", "onCfgChange"]);
          function _initialize() {
            var cfgHandler = createDynamicConfig(config || {}, defaultConfigValues);
            _config = cfgHandler.cfg, core.addUnloadHook(onConfigChange(cfgHandler, function () {
              if (_config[_DYN_CONNECTION_STRING]) {
                var cs = parseConnectionString(_config[_DYN_CONNECTION_STRING]),
                  ingest = cs.ingestionendpoint;
                _config.endpointUrl = ingest ? ingest + DEFAULT_BREEZE_PATH : _config.endpointUrl, _config[_DYN_INSTRUMENTATION_KEY] = cs.instrumentationkey || _config[_DYN_INSTRUMENTATION_KEY];
              }
            })), core.initialize(_config, [new Sender()]);
          }
          __name(_initialize, "_initialize");
        });
        function _track(item) {
          item && (item.baseData = item.baseData || {}, item.baseType = item.baseType || "EventData"), core.track(item);
        }
        __name(_track, "_track");
      }
      return __name(ApplicationInsights, "ApplicationInsights"), ApplicationInsights.__ieDyn = 1, ApplicationInsights;
    }();
    e.AppInsightsCore = Hr, e.ApplicationInsights = WU, e.Sender = FA, e.SeverityLevel = EU, e.arrForEach = kr, e.isNullOrUndefined = ce, e.proxyFunctions = ch, e.throwError = ms;
  });
});